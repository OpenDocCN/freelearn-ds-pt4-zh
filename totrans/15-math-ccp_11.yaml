- en: <st c="0">10</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Network Analysis</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="20">This chapter is about networks and datasets represented by networks.</st>
    <st c="90">Networks link things together.</st> <st c="121">Since many things in
    real-world data science are linked to each other, you will encounter networks
    and network data a lot as a data scientist.</st> <st c="264">Therefore, as a data
    scientist, you must learn something about networks and how to analyze them.</st>
    <st c="361">To learn about networks, we will cover the</st> <st c="404">following
    topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="421">Graphs and network data</st>*<st c="445">: In this section, we’ll
    learn why network data is important for data science and what a</st> <st c="535">graph
    is</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="543">Basic characteristics of graphs</st>*<st c="575">: Here, we’ll
    learn the essential concepts and terminology relating to graphs, and in particular
    about</st> <st c="679">adjacency matrices</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="697">Different types of graphs</st>*<st c="723">: In this section,
    we’ll learn about some of the main classes of graphs you will encounter as a data
    scientist and the behavior and properties of those different classes</st> <st
    c="894">of graphs</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="903">Community detection and decomposing graphs</st>*<st c="946">:
    Finally, we’ll learn about breaking a graph down into its</st> <st c="1007">important
    sub-graphs</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1027">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1050">All the code examples provided in this chapter can be found in
    this book’s GitHub repository:</st> [<st c="1145">https://github.com/PacktPublishing/15-Math-Concepts-Every-Data-Scientist-Should-Know/tree/main/Chapter10</st>](https://github.com/PacktPublishing/15-Math-Concepts-Every-Data-Scientist-Should-Know/tree/main/Chapter10)<st
    c="1249">. To run the Jupyter Notebooks provided, you will need a full Python
    installation, including the</st> <st c="1346">following packages:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="1365">numpy</st>` <st c="1371">(>=1.24.3)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="1382">matplotlib</st>` <st c="1393">(>=3.7.2)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="1403">NetworkX</st>` <st c="1412">(>=3.1.0)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1422">Graphs and network data</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1446">In the introduction, we</st> <st c="1470">mentioned that much of
    the real-world data you will encounter as a data scientist is network data.</st>
    <st c="1570">However, not all real-world</st> <st c="1598">data is network data.</st>
    <st c="1620">So, how do we recognize when we are dealing with network data, and
    perhaps more importantly, how do we recognize when the network aspect of the data
    is relevant to how we analyze</st> <st c="1799">the data?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1808">Network data is about relationships</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="1844">In the introduction, we</st> <st c="1869">explained that we need
    to learn about network data because the things that produce the data are linked
    to each other.</st> <st c="1987">This tells us that network data is about relationships.</st>
    <st c="2043">Or rather, network data arises when we have relationships between
    many of the data-generating entities we are studying.</st> <st c="2163">This also
    gives us a useful rule-of-thumb for when we should take the network aspect of
    the data into account in</st> <st c="2276">our analysis:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2289">If the relationships between the entities we are studying are strong,
    then we can’t ignore the network aspect of</st> <st c="2403">the data</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2411">Conversely, if the relationships between the entities we are studying
    are all weak, then we can probably ignore the network aspect of</st> <st c="2546">the
    data</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2554">It is important to realize that when relationships are weak, we
    still have a network and network data.</st> <st c="2658">But by ignoring the network
    structure in our analysis, we are making an approximation.</st> <st c="2745">Analyzing
    the data on this basis will be easier and will still yield valuable insights,
    so the approximation of ignoring the network aspect of the data is a useful one.</st>
    <st c="2914">However, we would get more accurate analysis and insights if we did
    consider the network aspect of the data, but this would be at the expense of having
    to use or implement more complex analyses</st> <st c="3108">and algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3123">So, how do we decide whether the relationships are weak enough
    to ignore?</st> <st c="3198">This is a skill that’s acquired through experience.</st>
    <st c="3250">To help you with this, we’ll look at a couple of real-world examples
    where the presence of relationships is central to the data to be analyzed.</st>
    <st c="3394">We’ll touch on these examples throughout</st> <st c="3435">this chapter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3448">Example 1 – substituting goods in a supermarket</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3496">We’ll start with a</st> <st c="3516">commerce example – goods sold
    in a supermarket.</st> <st c="3564">When a shopper buys food in a supermarket,
    they have many choices.</st> <st c="3631">Let’s consider the example of a shopper
    wanting to buy a frozen pizza.</st> <st c="3702">In many supermarkets, the shopper
    will have the choice between a couple of different brands and several different
    flavors.</st> *<st c="3825">Figure 10</st>**<st c="3834">.1</st>* <st c="3836">shows
    a hypothetical but realistic example of the set of brands and flavors that a shopper
    might choose between when buying a</st> <st c="3963">frozen pizza:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Frozen pizza brands and flavors](img/B19496_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="4222">Figure 10.1: Frozen pizza brands and flavors</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4266">When choosing a pizza, shoppers are happy to swap between certain
    brands and certain flavors if the price is right.</st> <st c="4383">The solid
    line between two pizzas in</st> <st c="4420">Figure 10</st><st c="4429">.1 indicates
    that a shopper considers those pizzas interchangeable or substitutes for each
    other.</st> <st c="4527">This means that there is a relationship between those
    two pizzas, that</st> <st c="4598">of substitutability.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4618">From the supermarket’s perspective, it is crucial to understand
    which pairs of pizzas are substitutes for each other.</st> <st c="4737">The more
    substitutes a shopper considers there to be, the more options they have if one
    of the pizzas is priced too high, and so the more price-sensitive the shopper
    is when choosing between the substitutes.</st> <st c="4945">This means that pizzas
    with a lot of substitutes must be priced very competitively.</st> <st c="5029">In
    contrast, the ham and pineapple pizza in</st> *<st c="5073">Figure 10</st>**<st
    c="5082">.1</st>* <st c="5084">has only one substitute – the ham and cheese pizza
    – and so doesn’t have to be priced as competitively as the pepperoni and cheese
    and tomato pizzas.</st> <st c="5235">From the supermarket’s perspective, knowing
    this substitutability network structure determines their pricing strategy and
    ultimately</st> <st c="5368">their profitability.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5388">Example 2 – international trade</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5420">If we want to understand</st> <st c="5445">economics at an international
    level, we need to understand the imports and exports from each country as trade
    between countries contributes significantly to the balance sheet of each country.</st>
    <st c="5638">This means we cannot ignore trading relationships between countries
    when analyzing the GDP of</st> <st c="5732">each country.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="5745">Figure 10</st>**<st c="5755">.2</st>* <st c="5757">shows the
    cash value (in US dollars) of the total exports from five different European countries
    (UK, Germany, France, Italy, and Spain) for 2022\.</st> <st c="5905">The export
    figures were obtained from</st> [<st c="5943">https://comtradeplus.un.org/</st>](https://comtradeplus.un.org/)<st
    c="5971">. Each arc represents the total export from one country to the other.</st>
    <st c="6041">The color of the arc matches the exporting country.</st> <st c="6093">The
    thickness of the arc is proportional to the total</st> <st c="6147">export value:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The network of exports between Germany (GER), France (FRA),
    Italy (ITA), Spain (SPN), and the United Kingdom (UK) in 2022](img/B19496_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="6162">Figure 10.2: The network of exports between Germany (GER), France
    (FRA), Italy (ITA), Spain (SPN), and the United Kingdom (UK) in 2022</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6296">The network structure of international trade is clear from this
    visualization.</st> <st c="6376">The visualization also makes it immediately clear
    which countries export the most, and which have the strongest</st> <st c="6487">reciprocal</st>
    <st c="6499">trading relationships.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6521">Now that we have introduced two examples of networks in real-world
    data science, let’s look at what they have in common and the terminology we can
    use to describe those common features.</st> <st c="6708">This brings us to the
    mathematical concept of</st> <st c="6754">a</st> **<st c="6756">graph</st>**<st
    c="6761">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6762">What is a graph?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6779">In both the</st> <st c="6792">real-world examples provided, we
    visualized the network as a 2D object, consisting</st> <st c="6875">of a set of
    entities with connections or arcs between them.</st> <st c="6935">This is because
    this is a very natural and intuitive way of visualizing a network.</st> <st c="7018">Because
    of this, these 2D objects are considered mathematical objects in their own right
    and have their own branch of mathematics that studies them.</st> <st c="7167">In
    mathematics, a 2D object such as that shown in</st> *<st c="7217">Figure 10</st>**<st
    c="7226">.1</st>* <st c="7228">or</st> *<st c="7232">Figure 10</st>**<st c="7241">.2</st>*
    <st c="7244">is called a</st> **<st c="7256">graph</st>**<st c="7261">. The mathematical
    study of graphs is</st> <st c="7299">called</st> **<st c="7306">graph theory</st>**<st
    c="7318">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7319">Consequently, the terms</st> **<st c="7344">network</st>** <st
    c="7351">and</st> **<st c="7356">graph</st>** <st c="7361">are used interchangeably.</st>
    <st c="7388">Likewise, network analysis and graph theory are used interchangeably,
    although network analysis tends to be preferentially used when we are dealing
    with real-world networks or data generated by real-world networks, while graph
    theory tends to be preferentially used when we are dealing with the more abstract
    analysis of graph structures and</st> <st c="7730">their properties.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7747">What is central to graph theory is that a graph consists of a set</st>
    <st c="7814">of entities called</st> **<st c="7833">nodes</st>** <st c="7838">and
    a set of connections between</st> <st c="7872">nodes called</st> **<st c="7885">edges</st>**<st
    c="7890">. In graph theory, a node tends to be</st> <st c="7927">called a</st>
    **<st c="7937">vertex</st>**<st c="7943">, so the terminology nodes and vertices
    are interchangeable.</st> <st c="8004">Consequently, a graph,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3354.png)<st
    c="8027"><st c="8028">, consists of a set of vertices,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="8061"><st c="8062">, and a set of edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3356.png)<st
    c="8084"><st c="8085">. In math, we denote this as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3357.png)<st
    c="8114"><st c="8119">, meaning the graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3354.png)<st
    c="8140"><st c="8141">, has vertices,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="8157"><st c="8158">, and edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3360.png)<st
    c="8171"><st c="8172">. This is illustrated schematically by the generic graph
    in</st> <st c="8232">Figure</st> <st c="8238">10</st><st c="8241">.3:</st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Schematic of a generic graph, ​G.​](img/B19496_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="8286">Figure 10.3: Schematic of a generic graph, G</st><st c="8330">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8331">In our first</st> <st c="8345">real-world example, the nodes or
    vertices are the different pizzas, and the edges are the solid lines indicating
    a substitutability relationship between two types of pizza.</st> <st c="8518">In
    our second real-world example, the nodes or vertices were the European countries,
    and the edges were the trading relationships</st> <st c="8648">between them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8661">In a graph, both the nodes and edges can have attributes – that
    is, additional data or values associated with them.</st> <st c="8778">Typically,
    in a data science context, it is these attributes that we are interested in, and
    we study how the network</st> <st c="8895">structure or</st> **<st c="8908">topology</st>**
    <st c="8916">affects them.</st> <st c="8931">In our first real-world example,
    it was the price of the pizzas that we were interested in, and this was an attribute
    of the pizzas – that is, a node attribute.</st> <st c="9092">In our second real-world
    example, it was the total exports from one country to another that we were interested
    in, and this was an edge attribute.</st> <st c="9239">In general, an edge attribute
    is termed</st> <st c="9279">an</st> **<st c="9282">edge weight</st>**<st c="9293">,
    as it is typically used to quantify the strength or weight of the relationship
    between the entities represented by the two nodes connected by</st> <st c="9437">the
    edge.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9446">From our real-world examples, we can see that although graphs consist
    of just two simple things, nodes and edges, graphs are far from being simple mathematical
    objects.</st> <st c="9616">There are a lot of different quantities and characteristics
    of a graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3361.png)<st
    c="9688"><st c="9689">, that we can calculate.</st> <st c="9714">In the next section,
    we will begin to outline some of the more commonly calculated graph characteristics
    and introduce some of the more commonly used concepts and terminology in graph
    theory.</st> <st c="9906">However, this is also a good place to end this introductory
    section on network data and what networks are, so we’ll recap what we</st> <st
    c="10036">have covered.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10049">What we’ve learned</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10068">In this section, we learned</st> <st c="10097">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10111">Networks imply relationships and we use networks to represent
    data where relationships are important.</st> <st c="10214">This is usually where
    those relationships have a significant effect on the data associated with the
    entities between which the</st> <st c="10341">relationships exist.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10361">A network is also a graph.</st> <st c="10389">A graph consists
    of nodes (vertices) and edges.</st> <st c="10437">The nodes and edges can have
    attributes or weights associated</st> <st c="10499">with them.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10509">Having introduced the basic idea of what a network is and how
    one can be used to represent relationship data, let’s learn how to mathematically
    characterize the properties of</st> <st c="10685">a graph.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10693">Basic characteristics of graphs</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="10725">A graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3361.png)<st
    c="10735"><st c="10736">, has nodes (vertices),</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3363.png)<st
    c="10760"><st c="10761">, and edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3364.png)<st
    c="10774"><st c="10775">, but to uncover and analyze the rich structure</st> <st
    c="10822">present in a network, we’ll need to introduce additional concepts and
    terminology beyond just nodes and edges.</st> <st c="10934">Let’s start with those
    edges, which come in</st> <st c="10978">two flavors.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10990">Undirected and directed edges</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11020">A key</st> <st c="11027">difference between our two real-world
    examples was that in our pizza example, the presence of an edge denoted a substitutability
    relationship that applied in both directions.</st> <st c="11202">An ACME Pizzas
    cheese and tomato pizza is considered by</st> <st c="11258">shoppers to be a substitute
    for a Premier Pizzas cheese and tomato pizza, and vice versa.</st> <st c="11348">In
    contrast, the arcs in our trade network in</st> <st c="11394">Figure 10</st><st
    c="11403">.2 have a direction associated with them, indicated by the arrow at
    the end of each arc.</st> <st c="11492">The exports from the UK to Germany do
    not match the exports from Germany to the UK.</st> <st c="11576">In</st> <st c="11579">Figure
    10</st><st c="11588">.2, we represented this by having two directed edges between
    the UK and Germany nodes, with different edge weights.</st> <st c="11704">Schematically,
    we used the arc thickness to represent the edge weight, so you can see the asymmetry
    in exports between the UK and Germany in</st> <st c="11845">Figure 10</st><st
    c="11854">.2.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11857">More generally, we</st> <st c="11876">refer to an edge</st> <st
    c="11893">as being</st> **<st c="11903">directed</st>** <st c="11911">if it has
    a specific direction</st> <st c="11942">associated with it.</st> <st c="11963">If
    an edge does not have a specific direction associated with it, we say it is an</st>
    **<st c="12045">undirected</st>** <st c="12055">edge.</st> <st c="12062">Edges</st>
    <st c="12067">that represent flows of some quantity are directed, while an edge
    that represents a symmetric relationship is undirected.</st> <st c="12190">Figure
    10</st><st c="12199">.4 shows the different types of edges we can get bet</st><st
    c="12251">ween</st> <st c="12257">two nodes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: A schematic of the different types of edges](img/B19496_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="12453">Figure 10.4: A schematic of the different types of edges</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12509">By comparing examples</st> *<st c="12532">a</st>* <st c="12533">and</st>
    *<st c="12538">d</st>* <st c="12539">in</st> <st c="12543">Figure 10</st><st c="12552">.4,
    we can see that two directed edges of equal weight between two nodes are not equivalent
    to an undirected edge between those two nodes.</st> <st c="12691">If we want to
    represent two flows of equal strength between the two nodes, we should use directed
    edges, while if we want to denote the presence of some symmetric logical property
    between the nodes, we should use an</st> <st c="12907">undirected edge.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12923">Having introduced the idea of a directed edge, we can now introduce
    the idea that a node can have a relationship with itself.</st> <st c="13050">We
    can do this by using a directed edge of the form shown i</st><st c="13109">n</st>
    <st c="13112">Figure 10</st><st c="13121">.5:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: A schematic of the directed edge between a node and itself](img/B19496_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="13126">Figure 10.5: A schematic of the directed edge between a node
    and itself</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13197">A directed edge between a node and itself is ideal when we want
    to represent a dynamic flow of some quantity out from the node, but some of that
    quantity may be retained by</st> <st c="13370">the node.</st> <st c="13381">For
    example, let’s say we were modeling</st> <st c="13420">flows over time of internet
    users between different pages of a website.</st> <st c="13493">From one time point
    to the next, a user may navigate to a new page within a website or remain on the
    current page.</st> <st c="13608">Here, nodes would represent pages within the
    website and directed edges would represent the flows.</st> <st c="13707">The fact
    that in a single timestep, a proportion of users don’t move pages – that is, they
    effectively flow from the page to itself – means we would represent that using
    an edge of the form in</st> <st c="13900">Figure 10</st><st c="13909">.5.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13912">Once we have the</st> <st c="13929">concept of a directed edge,
    we naturally have the concept of a</st> **<st c="13993">directed network</st>**
    <st c="14009">or</st> **<st c="14013">directed graph</st>**<st c="14027">. This
    is a graph consisting of directed</st> <st c="14067">edges.</st> <st c="14075">An
    example directed graph is shown by the schematic in</st> <st c="14130">Figure
    10</st><st c="14139">.6\.</st> <st c="14143">Likewise, a</st> <st c="14154">graph
    made up of undirected</st> <st c="14183">edges is called an</st> **<st c="14202">undirected
    graph</st>** <st c="14218">or an</st> **<st c="14225">undirected network</st>**<st
    c="14243">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: A simple directed graph](img/B19496_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="14246">Figure 10.6: A simple directed graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14282">Now that we have introduced the different types of edges, let’s
    look at how to mathematically encode a graph and how that encoding can change
    according to the different edge types in</st> <st c="14466">the graph.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14476">The adjacency matrix</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="14497">So far, we</st> <st c="14509">have been focusing on the visual
    representation of a graph.</st> <st c="14569">This is good, but what if we want
    to do some mathematics on a graph?</st> <st c="14638">How can we represent a graph
    mathematically?</st> <st c="14683">We introduced the notation that a graph is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3365.png)<st
    c="14726"><st c="14731">, but that is a bit abstract.</st> <st c="14761">What
    if want to work with actual numbers?</st> <st c="14803">How do we encode the presence
    of a relationship or edge mathematically?</st> <st c="14875">We do this using</st>
    <st c="14891">the idea of an</st> **<st c="14907">adjacency matrix</st>**<st c="14923">.
    For a graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3366.png)<st
    c="14938"><st c="14939">, with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)
    <st c="14946"><st c="14947">nodes, its adjacency matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/607.png)<st
    c="14977"><st c="14978">, is an</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:math>](img/651.png)
    <st c="14986"><st c="14987">matrix whose elements are defined</st> <st c="15022">as
    follows:</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>1</mn><mtext>if</mtext><mtext>an</mtext><mtext>edge</mtext><mtext>exists</mtext><mtext>between</mtext><mtext>node</mtext><mi>i</mi><mtext>and</mtext><mtext>node</mtext><mi>j</mi></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3370.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15099">Eq.</st> <st c="15103">1</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15104">The adjacency matrix encodes with 1s and 0s, whether two nodes
    are connected or not.</st> <st c="15189">If two nodes are connected, we say they
    are neighbors or adjacent to each other, hence the name adjacency matrix.</st>
    <st c="15303">Another way of looking at this is that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3371.png)
    <st c="15342"><st c="15343">if we can get from node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="15368"><st c="15369">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="15378"><st c="15379">in one step, and if we can they are</st> <st c="15416">nearest
    neighbors.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15434">Properties of the adjacency matrix</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="15469">Figure 10</st><st c="15479">.7 shows a</st> <st c="15489">simple
    undirected graph where we have numbered the nodes, along with their correspond</st><st
    c="15575">ing</st> <st c="15580">adjacency matrix:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: An example undirected graph and its corresponding adjacency
    matrix](img/B19496_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="15748">Figure 10.7: An example undirected graph and its corresponding
    adjacency matrix</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15827">Because the adjacency matrix encodes the connections of a graph,
    it has some very nice properties and</st> <st c="15930">allows us to do some neat
    calculations.</st> <st c="15970">We’ll look at two of those</st> <st c="15997">properties
    now:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="16012">Symmetry</st>**<st c="16021">: For an undirected graph such
    as that in</st> <st c="16064">Figure 10</st><st c="16073">.7, the adjacency matrix
    is symmetric.</st> <st c="16112">We can easily see this from the fact that if</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3374.png)<st
    c="16157"><st c="16158">, then there is an edge between nodes</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16196"><st c="16197">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)<st
    c="16202"><st c="16203">, so node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16213"><st c="16214">is also a neighbor of node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)<st
    c="16242"><st c="16243">, which implies that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3379.png)<st
    c="16264"><st c="16265">. A similar argument shows that if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/3380.png)<st
    c="16300"><st c="16301">, then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16308"><st c="16309">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>j</mi></mrow></math>](img/3382.png)<st
    c="16314"><st c="16315">are not neighbors, so</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/3383.png)<st
    c="16337"><st c="16338">. So, overall, for an undirected graph, we always have</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/3384.png)<st
    c="16393"><st c="16394">, meaning the matrix</st> <st c="16415">is symmetric.</st></st></st></st></st></st></st></st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16428">Next-nearest-neighbors</st>**<st c="16451">: The adjacency
    matrix allows us to identify next-nearest-neighbors and next-next-nearest-neighbors
    and so on.</st> <st c="16563">Consider the product of matrix elements,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3385.png)<st
    c="16604"><st c="16612">. This number is 1 only if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3386.png)
    <st c="16639"><st c="16640">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3387.png)<st
    c="16645"><st c="16646">, so only if there is a connection between node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="16694"><st c="16695">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3389.png)
    <st c="16705"><st c="16706">and also a connection between node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3389.png)
    <st c="16742"><st c="16743">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="16753"><st c="16754">. So,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3392.png)
    <st c="16760"><st c="16767">if we can get from node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/3393.png)
    <st c="16791"><st c="16792">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)
    <st c="16801"><st c="16802">in two steps via node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3395.png)<st
    c="16825"><st c="16826">, and 0 otherwise.</st> <st c="16845">Now, let’s consider
    all possible intermediate nodes,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/2075.png)<st
    c="16898"><st c="16899">. If we compute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3397.png)<st
    c="16915"><st c="16924">, it will simply count a 1 every time there is a two-step
    path between node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17000"><st c="17001">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="17011"><st c="17012">. So,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3400.png)
    <st c="17018"><st c="17025">gives the number of possible two-step routes between</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17078"><st c="17079">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="17084"><st c="17085">. But wait a minute,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3400.png)
    <st c="17106"><st c="17113">looks like something we’ve seen before!</st> <st c="17153">It
    is just matrix multiplication.</st> <st c="17187">In</st> [*<st c="17190">Chapter
    3</st>*](B19496_03.xhtml#_idTextAnchor141)<st c="17199">, I mentioned that matrices
    would crop up everywhere in data science.</st> <st c="17269">Here,</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msup><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><mn>2</mn></msup><mo>=</mo><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><mo>×</mo><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder></mrow></mrow></math>](img/3404.png)
    <st c="17275"><st c="17285">is a matrix whose matrix elements tell us the number
    of two-step paths between each pair of nodes in the network.</st> <st c="17399">If
    the matrix element,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mfenced
    open="(" close=")"><msup><munder><munder><mi>A</mi><mo stretchy="true">_</mo></munder><mo
    stretchy="true">_</mo></munder><mn>2</mn></msup></mfenced><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo></mrow></mrow></math>](img/3405.png)<st
    c="17422"><st c="17423">is non-zero, it means that nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17456"><st c="17457">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="17462"><st c="17463">are connected by a two-step path and so are next-nearest-neighbors.</st>
    <st c="17532">Unsurprisingly, we can continue this logic and we find that the
    matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math>](img/3408.png)<st
    c="17604"><st c="17609">, has matrix elements that count the number of three-step
    paths between each pair of nodes and can be used to easily identify next-next-nearest-neighbors.</st>
    <st c="17764">More generally, the matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3409.png)<st
    c="17792"><st c="17797">, counts the number of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3410.png)
    <st c="17820"><st c="17827">paths between each pair</st> <st c="17851">of nodes.</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17860">The adjacency matrix for a directed graph</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="17902">We have</st> <st c="17911">used undirected graphs to introduce
    the idea of the adjacency matrix, but can the concept be extended to directed
    graphs?</st> <st c="18033">The answer is yes.</st> <st c="18052">Again, the definition</st>
    <st c="18074">is simple:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>1</mn><mtext>if</mtext><mtext>a</mtext><mtext>directed</mtext><mtext>edge</mtext><mtext>exists</mtext><mtext>going</mtext><mtext>from</mtext><mtext>node</mtext><mi>i</mi><mtext>to</mtext><mtext>node</mtext><mi>j</mi></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3411.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="18160">Eq.</st> <st c="18164">2</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18165">Figure 10</st><st c="18174">.8 shows an example directed graph
    and its correspon</st><st c="18226">ding</st> <st c="18232">adjacency matrix:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="18403">Figure 10.8: An example directed graph and its corresponding
    adjacency matrix</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18480">From</st> <st c="18486">Figure 10</st><st c="18495">.8, we can
    see that a directed graph does not necessarily have a symmetric adjacency matrix.</st>
    <st c="18588">It will only be symmetric if, between a pair of nodes, there are
    edges in both directions or no edges</st> <st c="18690">at all.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18697">We can also see that we now have the possibility of non-zero matrix
    elements on the diagonal of the adjacency matrix.</st> <st c="18816">These represent
    edges from a node to itself.</st> <st c="18861">In the example in</st> <st c="18879">Figure
    10</st><st c="18888">.8, we have included an edge from node 2 to itself and likewise
    an edge from node 4</st> <st c="18972">to itself.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18982">As with the undirected case, we can use the adjacency matrix of
    a directed graph to identify next-nearest-neighbors and so on.</st> <st c="19110">The
    matrix elements of the matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3412.png)<st
    c="19145"><st c="19148">, still correspond</st> <st c="19166">to counts of the
    number of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3413.png)
    <st c="19194"><st c="19201">paths between each pair of nodes; it’s just that when
    following an</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3413.png)
    <st c="19268"><st c="19275">path, we are only allowed to move in the direction
    given by the edge.</st> <st c="19345">Consequently, as with the undirected case,
    a non-zero value in the matrix element,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3415.png)<st
    c="19428"><st c="19429">, means that there is at least one</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3416.png)
    <st c="19464"><st c="19471">path between nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="19490"><st c="19491">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="19495"><st c="19496">.</st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19497">Adjacency matrices for weighted directed graphs</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="19545">Again, it is</st> <st c="19558">natural to ask if we can take
    the edge weights into account when defining the adjacency matrix.</st> <st c="19655">Since
    the adjacency matrix captures the neighbor structure of the graph, can we not
    include the edge weight as a measure of “neighborliness?” Again, the answer is
    yes by extending the definition of the matrix elements to</st> <st c="19876">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mtext>Weight</mtext><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mtext>if</mtext><mtext>a</mtext><mtext>directed</mtext><mtext>edge</mtext><mtext>exists</mtext><mtext>going</mtext><mtext>from</mtext><mtext>node</mtext><mi>i</mi><mtext>to</mtext><mtext>node</mtext><mi>j</mi></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3419.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="19968">Eq.</st> <st c="19972">3</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19973">Since we only have a non-zero edge weight,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3420.png)<st
    c="20016"><st c="20017">, if there is an edge going from node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="20055"><st c="20056">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="20065"><st c="20066">, the matrix of edge weights,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/3423.png)<st
    c="20096"><st c="20097">, is the adjacency matrix in this general definition.</st>
    <st c="20151">So, in general,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder><mml:mo>=</mml:mo><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/3424.png)<st
    c="20167"><st c="20173">. This means we can also think of the absence of an edge
    as simply an edge with</st> <st c="20253">zero weight.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20265">Figure 10</st><st c="20275">.9 shows an example of a weighted
    directed graph and its correspo</st><st c="20340">nding</st> <st c="20347">adjacency
    matrix:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="20520">Figure 10.9: An example weighted directed graph and its corresponding
    adjacency matrix</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20606">The most</st> <st c="20616">obvious difference between</st> <st
    c="20643">Figure 10</st><st c="20652">.9 and the previous examples in</st> <st
    c="20684">Figure 10</st><st c="20693">.7 and</st> <st c="20700">Figure 10</st><st
    c="20709">.8 is that the matrix elements are no longer just 1s and 0s.</st> <st
    c="20770">This means that the matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3425.png)<st
    c="20798"><st c="20803">, no longer counts the number of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3410.png)
    <st c="20836"><st c="20843">paths between nodes.</st> <st c="20864">In fact, if
    the edge weights are allowed to be negative, the interpretation of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3409.png)
    <st c="20943"><st c="20948">is not always clear.</st> <st c="20969">However, if
    the edge weights are restricted to being positive or zero, then a non-zero value
    for the matrix element,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3428.png)<st
    c="21086"><st c="21089">, still indicates that there is at least one</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3410.png)
    <st c="21134"><st c="21141">path between nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="21160"><st c="21161">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="21165"><st c="21166">.</st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21167">The different forms of the adjacency matrix that we have illustrated
    here show how useful it is since it encodes almost everything about a graph.</st>
    <st c="21314">Consequently, almost all calculations involving graphs make use
    of the adjacency matrix.</st> <st c="21403">We’ll look at more characteristics
    of graphs and in some cases show how those characteristics can be calculated from
    the</st> <st c="21524">adjacency matrix.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21541">In-degree and out-degree</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21566">We can</st> <st c="21574">also see from</st> <st c="21588">Figure
    10</st><st c="21597">.8 that taking edge direction into account when defining
    the</st> <st c="21658">adjacency matrix can change the matrix markedly.</st> <st
    c="21707">Other than the addition of an edge from node 2 to itself and likewise
    for node 4, the topology of the graph in</st> <st c="21818">Figure 10</st><st
    c="21827">.8 is the same as that for the undirected graph in</st> <st c="21878">Figure
    10</st><st c="21887">.7\.</st> <st c="21891">However, some nodes in</st> <st c="21914">Figure
    10</st><st c="21923">.8 have few edges.</st> <st c="21942">Take node 6, for example.</st>
    <st c="21968">The directed graph in</st> <st c="21990">Figure 10</st><st c="21999">.8
    only has one edge, while the undirected graph in</st> <st c="22051">Figure 10</st><st
    c="22060">.7, which has the same topology, shows that node 6 has three edges.</st>
    <st c="22128">This naturally introduces the idea that we should distinguish between
    counts of edges that are incoming to a node and counts of edges that are outgoing
    from</st> <st c="22285">a node.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22292">The number</st> <st c="22303">of edges coming into a node is known
    as the node’s</st> **<st c="22355">in-degree</st>**<st c="22364">, while the number
    of edges leaving a node is known as the node’s</st> **<st c="22430">out-degree</st>**<st
    c="22440">. How</st> <st c="22446">do we calculate the in-degree and out-degree?</st>
    <st c="22492">Using the adjacency matrix, of course.</st> <st c="22531">If we
    have an adjacency matrix of the form shown in</st> <st c="22583">Figure 10</st><st
    c="22592">.8, consisting of just 1s and 0s, then the in-degree for the</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="22653"><st c="22665">node is just the sum of the matrix elements in the</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="22716"><st c="22728">column of the adjacency matrix.</st> <st c="22760">In
    math form, this looks</st> <st c="22785">as follows:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>In-degree</mtext><mtext>for</mtext><mtext>node</mtext><mi>i</mi><mo>=</mo><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mrow></mrow></math>](img/3434.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="22826">Eq.</st> <st c="22830">4</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22831">This also means that if we put all the in-degree values for all
    the nodes,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:math>](img/3435.png)<st
    c="22906"><st c="22907">, into a vector, we can calculate that vector using matrix
    multiplic</st><st c="22975">ation like</st> <st c="22987">like so:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>In-degree</mtext><mtext>vector</mtext><mtext>=</mtext><msup><msub><munder><mn>1</mn><mo
    stretchy="true">_</mo></munder><mi>N</mi></msub><mi mathvariant="normal">⊤</mi></msup><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder></mrow></mrow></math>](img/3436.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="23017">Eq.</st> <st c="23021">5</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23022">In Eq.</st> <st c="23029">5,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:msub><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/3437.png)<st
    c="23032"><st c="23033">means an</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)<st
    c="23042"><st c="23043">-element</st> <st c="23052">row-vector consisting of all
    1s.</st> <st c="23085">A similar bit of logic shows that</st> <st c="23118">the
    out-degree of node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="23142"><st c="23143">is just the sum of all the matrix elements in the</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="23194"><st c="23206">row of the adjacency matrix.</st> <st c="23235">In
    math terms, we have</st> <st c="23258">the following:</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Out-degree</mtext><mtext>for</mtext><mtext>node</mtext><mi>i</mi><mo>=</mo><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></mrow></math>](img/3441.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="23303">Eq.</st> <st c="23307">6</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23308">So, the vector of out-degree values can calculated as a matrix
    multiplication via the</st> <st c="23394">following equation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Out-degree</mtext><mtext>vector</mtext><mtext>=</mtext><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><msub><munder><mn>1</mn><mo
    stretchy="true">_</mo></munder><mi>N</mi></msub></mrow></mrow></math>](img/3442.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="23437">Eq.</st> <st c="23441">7</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23442">Centrality</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="23452">The in-degree and</st> <st c="23471">out-degree are node-level
    characteristics.</st> <st c="23514">Adding the in-degree and out-degree values
    together gives us the total number of edges connected to a node – its total degree.</st>
    <st c="23641">A node with a high total number of edges is connected to a lot of
    other nodes and so is likely to be at the heart of the network.</st> <st c="23771">This
    means that the total degree value of a node gives a measure of how important or
    how central it is</st> <st c="23873">to the network.</st> <st c="23890">We say
    that the total degree value is a</st> **<st c="23930">centrality measure</st>**<st
    c="23948">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23949">As you can imagine, there are many ways in which you can judge
    the importance of a node, so there are many node centrality measures.</st> <st
    c="24083">The centrality measure based on the number of edges connected to a</st>
    <st c="24149">node is called</st> **<st c="24165">degree centrality</st>**<st
    c="24182">. The following are some other node centrality measures</st> <st c="24238">to
    consider:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24250">Betweenness centrality</st>**<st c="24273">: This</st> <st
    c="24281">attempts to measure to what extent a node lies between key parts of
    the network, and so acts as a node through which paths must pass when going between
    any other two nodes in</st> <st c="24456">the network.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24468">Closeness centrality</st>**<st c="24489">: As the</st> <st
    c="24499">name suggests, this measures how close the node is to all the other
    nodes, based on path distances along the edges of the network.</st> <st c="24630">A
    node that has a short average distance from other nodes is at the heart of</st>
    <st c="24707">the network.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24719">Eigenvector centrality</st>**<st c="24742">: A measure</st>
    <st c="24754">of node importance based on the likelihood of ending up at a node
    while performing a long random walk on the network.</st> <st c="24873">This measures
    how popular the node is, as voted for by the</st> <st c="24932">other nodes.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="24944">Different</st> <st c="24955">node centrality measures capture
    different aspects of node importance.</st> <st c="25026">A node can be very important
    by one centrality measure, and not so important by another measure.</st> <st c="25123">We
    need to be aware of the nuances of different centrality measures when we</st>
    <st c="25199">use them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25208">But why do we care about node centrality measures?</st> <st c="25260">Why
    do we care about knowing whether a node is important or not?</st> <st c="25325">In
    a real-world setting, an important node is typically an influential node, and
    therefore one we want to identify by ranking on a particular node centrality measure.</st>
    <st c="25492">More interestingly, graphs with certain types of highly influential
    nodes can have some surprising behaviors.</st> <st c="25602">We’ll learn about
    these graphs and their behaviors in the next section, but for now, we’ll summarize
    what we have learned in this section about the basic characteristics</st> <st
    c="25772">of graphs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25782">What we’ve learned</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="25801">In this section, we learned</st> <st c="25830">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25844">How edges in a graph can be undirected or directed, meaning a
    graph can be an undirected graph or a</st> <st c="25945">directed graph</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25959">How we can have a directed edge from a node</st> <st c="26004">to
    itself</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26013">How edges can have a weight associated</st> <st c="26053">with
    them</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26062">Adjacency matrices and how they mathematically encode the</st>
    <st c="26121">network structure</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26138">How an adjacency matrix can be used to identify and count</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3443.png)
    <st c="26197"><st c="26204">paths between each pair of nodes in</st> <st c="26240">a
    network</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26249">The in-degree and out-degree values of a node and how they can
    be calculated from the</st> <st c="26336">adjacency matrix</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26352">How the total degree value of a node (the sum of the node’s in-degree
    and out-degree) is a centrality measure that measures the importance of</st> <st
    c="26495">a node</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26501">How there are many other different node</st> <st c="26542">centrality
    measures</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26561">Having learned the basic concepts and terminology that describe
    a graph, next, we’ll look at different types or families of graphs and focus on
    some of their specific but very</st> <st c="26738">interesting properties.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26761">Different types of graphs</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="26787">There are many different</st> <st c="26813">graphs you may encounter
    as a data scientist.</st> <st c="26859">Many of these graphs can be grouped into
    different classes.</st> <st c="26919">In this section, we will outline some of
    the most important classes of graphs you will encounter.</st> <st c="27017">The
    list of classes we’ll cover here is not intended to be exhaustive.</st> <st c="27088">It
    will introduce you to the concepts and terminology associated with the most common
    classes of graphs you</st> <st c="27196">will encounter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27211">Fully connected graphs</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="27234">One of</st> <st c="27241">the differences between our two real-world
    examples is that in our trade network example, each node (country) is connected
    to</st> <st c="27368">every other node.</st> <st c="27386">We say that the trade
    network is</st> **<st c="27419">fully connected</st>**<st c="27434">. In contrast,
    in our pizza network, every pizza is not connected to every</st> <st c="27509">other
    pizza.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27521">The left-hand graph in</st> <st c="27545">Figure 10</st><st c="27554">.10
    shows a graph with four nodes.</st> <st c="27589">Each of the nodes is connected
    to every one of the other three nodes.</st> <st c="27659">It is fully connected.</st>
    <st c="27682">In contrast, the graph on the right-hand side of</st> <st c="27731">Figure
    10</st><st c="27740">.10 also contains the same</st> <st c="27766">four nodes
    but is not</st> <st c="27789">fully connected:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="27842">Figure 10.10: A graph that is fully connected and one that is
    not</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27907">Disconnected graphs</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="27927">Our</st> <st c="27931">real-world pizza example graph is not fully
    connected.</st> <st c="27987">Some</st> <st c="27992">edges that could be possible
    are absent.</st> <st c="28033">What would happen if we removed even more edges
    from our pizza network?</st> <st c="28105">Removing edges from a network will
    eventually cause it to break into separate distinct and un-connected gra</st><st
    c="28212">phs.</st> <st c="28218">Figure 10</st><st c="28227">.11 shows such</st>
    <st c="28242">an example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="28278">Figure 10.11: Disconnected components in a graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28326">We</st> <st c="28330">refer to</st> <st c="28339">the separate
    disconnected parts of the graph as</st> **<st c="28387">components</st>**<st c="28397">.
    In</st> <st c="28402">Figure 10</st><st c="28411">.11, there are two components.</st>
    <st c="28442">One can have graphs that have many disconnected components.</st>
    <st c="28502">Each component is a graph in its own right, and any analysis we
    apply to a graph can be applied to each separate component of a graph.</st> <st
    c="28637">Consequently, from now on, we shall only discuss how to analyze</st>
    <st c="28701">single-component graphs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28725">Directed acyclic graphs</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="28749">Directed graphs</st> <st c="28766">are great for representing
    flows.</st> <st c="28800">They</st> <st c="28804">are also great for representing
    how one quantity (node) depends on another, or how one quantity (node) influences
    another.</st> <st c="28928">The presence of a directed edge from node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="28970"><st c="28971">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="28980"><st c="28981">in a directed graph could be used to indicate that
    the quantity represented by node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="29066"><st c="29067">influences the quantity represented by node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="29112"><st c="29113">. Or equivalently, node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="29137"><st c="29138">has a dependency on node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)<st
    c="29164"><st c="29165">. Directed graphs are often used to represent patterns
    of dependencies.</st> <st c="29237">An important requirement of any such dependency
    graph is that there are no</st> **<st c="29312">cycles</st>**<st c="29318">. A
    cycle is</st> <st c="29331">a set of steps (hops) that take us from a node back
    to itself.</st> <st c="29394">A cycle would mean we have a chain of dependencies
    from a node back to itself – the quantity would have a dependency on itself, something
    that cannot</st> <st c="29544">be resolved.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29556">The graph on the left-hand side of</st> <st c="29592">Figure 10</st><st
    c="29601">.12 shows a directed graph with a cycle.</st> <st c="29642">The high</st><st
    c="29650">lighted cycle is a path between</st> <st c="29683">three nodes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="29754">Figure 10.12: Directed graphs with and without cycles</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29807">There are</st> <st c="29818">many cycles in the left-hand graph
    in</st> <st c="29856">Figure 10</st><st c="29865">.12 – there are several pairs
    of nodes with directed edges in both directions between them.</st> <st c="29957">Also,
    any edge from a node to itself automatically represents</st> <st c="30019">a cycle.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30027">For dependency</st> <st c="30043">graphs, we want graphs that
    do not have any cycles.</st> <st c="30095">Since such graphs have no cycles or
    are</st> **<st c="30135">acyclic</st>**<st c="30142">, they are referred to as</st>
    **<st c="30168">directed acyclic graphs</st>** <st c="30191">(</st>**<st c="30193">DAGs</st>**<st
    c="30197">).</st> <st c="30201">The right-hand graph of</st> <st c="30225">Figure
    10</st><st c="30234">.12 shows an example of</st> <st c="30258">a DAG.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30264">Small-world networks</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="30285">You may</st> <st c="30294">have already heard of small-world networks
    as many real-world networks are said to be small-world networks.</st> <st c="30402">Small-world
    networks</st> <st c="30423">are not so much a class of networks but are networks
    that display the small-world effect or small-world phenomenon.</st> <st c="30539">The
    small-world phenomenon is also known colloquially as the “six degrees of separation”
    effect.</st> <st c="30636">It refers to the observation that in many networks,
    the shortest path between any two nodes is not very long – typically only six
    steps or “hops,” meaning that we can get from any node on the network to any other
    node on the network in typically six hops or less.</st> <st c="30900">In a real-world
    setting, you may have heard of the example that any Hollywood actor can be connected
    to actor Kevin Bacon via a chain of six movies or less.</st> <st c="31057">This
    is the “six degrees of Kevin</st> <st c="31091">Bacon” phenomenon.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31109">The small-world phenomenon is widespread in real-world networks.</st>
    <st c="31175">Theoretical models of how networks evolve and grow suggest that
    the small-world phenomenon should be expected in most networks.</st> <st c="31303">The
    phrase “small-world network” itself stems from the real-world phenomenon</st>
    <st c="31380">we often experience in social-network settings, where we meet someone
    new from another part of the world and it turns out they already know one of our
    best friends or one of the friends of our friends.</st> <st c="31582">This strikes
    us as an unlikely occurrence and we exclaim, “What a</st> <st c="31648">small
    world!”</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31661">At the</st> <st c="31669">heart of the small-world phenomenon
    is the presence of nodes in the network that have a high total degree.</st> <st
    c="31776">As we said when introducing centrality measures, total degree is one
    way of identifying the important nodes.</st> <st c="31885">A node with a high
    total degree is connected to a lot of other nodes.</st> <st c="31955">If you want
    to find a short path between two nodes, going via a node that is connected to
    almost every other node in the network would seem like a smart idea.</st> <st
    c="32114">High-degree nodes allow us to efficie</st><st c="32151">ntly move between
    different parts of</st> <st c="32189">the network:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="32203">Figure 10.13: A high-degree node that connects all parts of the
    network</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32274">Figure 10</st><st c="32284">.13 shows an example of a high-degree
    node, colored in red, that acts as a connection between any other two nodes.</st>
    <st c="32399">By passing through the red node, we can go from one side of the
    network to the other in three steps</st> <st c="32499">or less.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32507">Let’s put a bit of math detail on the small-world phenomenon.</st>
    <st c="32570">The presence of high-degree nodes means the typical shortest-path
    distance between any two nodes is always small, no matter how big the network
    gets.</st> <st c="32720">If we denote the shortest-path distance between node</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="32773"><st c="32774">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="32784"><st c="32785">as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3452.png)<st
    c="32789"><st c="32790">, then the mean shortest-path distance i</st><st c="32830">s
    given by the</st> <st c="32846">following equation:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mover><mi>D</mi><mo
    stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mn>1</mn><msup><mi>N</mi><mn>2</mn></msup></mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></mrow></mrow></math>](img/3453.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="32877">Eq.</st> <st c="32881">8</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32882">In Eq.</st> <st c="32889">8,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/686.png)
    <st c="32892"><st c="32893">is the number of nodes in the network.</st> <st c="32933">A
    mathematical statement of the small-world phenomenon is that</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3455.png)
    <st c="32996"><st c="32997">grows very slowly as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/629.png)
    <st c="33019"><st c="33020">is increased.</st> <st c="33035">Theoretical analysis
    of</st> <st c="33059">small-world networks shows that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)
    <st c="33091"><st c="33092">typically grows as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3458.png)<st
    c="33112"><st c="33113">. This means that if we double the size of a small-world
    network by doubling</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/443.png)<st
    c="33190"><st c="33191">, we only increase the typical shortest-path distance
    between nodes by an amount,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:math>](img/3460.png)
    <st c="33273"><st c="33278">– that is, a small increase.</st> <st c="33307">A</st>
    <st c="33309">consequence of this is that typical distances between nodes on even
    very large real-world networks, such as the World Wide Web or popular social networks,
    are not large (between</st> <st c="33487">10-20 hops).</st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33499">Another common</st> <st c="33514">feature of small-world networks
    is that some of the highly connected nodes also exhibit</st> **<st c="33603">long-range</st>**
    <st c="33613">connections.</st> <st c="33627">This means they are not just connected
    to lots of nodes in the same part of the network, but they are connected to lots
    of different parts of the network.</st> <st c="33782">In</st> <st c="33785">Figure
    10</st><st c="33794">.13, the red node is connected to nodes on the very right-hand
    side of the network via those curved edges.</st> <st c="33901">The red node is
    connected to almost every other node in the network.</st> <st c="33970">In social
    network settings, such nodes are the people who seem to know everyone.</st> <st
    c="34051">In our Hollywood actor example, Kevin Bacon is a node who is connected
    to many other</st> <st c="34136">Hollywood actors.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34153">Nodes with many long-range connections not only have a large total
    degree, but they also have a total degree that is significantly above what we
    might expect given the values from most of the other nodes.</st> <st c="34359">This
    raises the question of what sort of distribution of node degree values we see
    in different types of networks.</st> <st c="34474">In a small-world network, we
    expect to see an extended right-hand tail to the distribution, meaning that there
    is a small, but non-negligible, probability of getting a node with a very large
    total degree value.</st> <st c="34685">Beyond this, what kind of degree distribution
    should we expect for a graph?</st> <st c="34761">Does it have a natural shape
    or scale?</st> <st c="34800">Some of the most interesting graphs that graph theorists
    have studied recently are those whose degree distributions have no scale to them
    at all.</st> <st c="34946">These are</st> <st c="34955">called</st> **<st c="34963">scale-free</st>**
    <st c="34973">graphs, and we’ll introduce</st> <st c="35002">them next.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35012">Scale-free networks</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="35032">A</st> <st c="35035">scale-free network is</st> <st c="35056">a
    network whose statistical properties have no natural scale to them.</st> <st c="35127">This
    means that if the node degree value is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="35171"><st c="35172">, then the probability distribution of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35211"><st c="35212">can’t be written as some function,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>/</mml:mo><mml:mi>λ</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3463.png)<st
    c="35248"><st c="35255">. If it could, it would mean that the value of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>λ</mml:mi></mml:math>](img/3464.png)
    <st c="35302"><st c="35303">would provide a natural scale against which to measure
    the values of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="35373"><st c="35374">. The only possible distributions that satisfy the requirement
    of not having a</st> <st c="35453">scale are</st> **<st c="35463">power-law distributions</st>**<st
    c="35486">. This means the probability of getting a degree value of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35544"><st c="35545">is proportional to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:msup></mml:math>](img/3467.png)<st
    c="35565"><st c="35566">. The parameter,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>α</mml:mi><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/3468.png)<st
    c="35583"><st c="35585">, is the exponent of the power-law distribution.</st>
    <st c="35634">The degree value is a discrete quantity, so we can write</st> <st
    c="35690">the probability distribution</st> <st c="35720">as follows:</st></st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Prob</mtext><mfenced
    open="(" close=")"><mrow><mtext>Total</mtext><mtext>Degree</mtext><mtext>=</mtext><mi>x</mi></mrow></mfenced><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>0</mn><mtext>if</mtext><mi>x</mi><mo><</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd><mfrac><msup><mi>x</mi><mrow><mo>−</mo><mi>α</mi></mrow></msup><mrow><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced></mrow></mfrac></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3469.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="35782">Eq.</st> <st c="35786">9</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35787">The</st> <st c="35790">value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/3470.png)
    <st c="35800"><st c="35804">is the minimum value that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35830"><st c="35831">can take.</st> <st c="35842">The function,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>ζ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/3472.png)<st
    c="35856"><st c="35857">, in Eq.</st> <st c="35866">9 is known as the</st> **<st
    c="35884">Hurwitz zeta function</st>**<st c="35905">. It ensures that the probability
    distribution is properly normalized – that is, the sum of all the probabilities
    is 1\.</st> <st c="36025">This means that the function,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>ζ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/3473.png)<st
    c="36055"><st c="36056">, is given by the</st> <st c="36074">following equation:</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced><mo>=</mo><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><msup><mfenced open="(" close=")"><mrow><mi>n</mi><mo>+</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfenced><mrow><mo>−</mo><mi>α</mi></mrow></msup></mrow></mrow></mrow></math>](img/3474.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36120">Eq.</st> <st c="36124">10</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36126">The power-law distribution in Eq.</st> <st c="36161">9 is a slowly
    decreasing function.</st> <st c="36196">The slow decrease in probability as</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="36232"><st c="36233">increases means that there is a small but non-negligible
    probability of getting a very large value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="36336"><st c="36337">. In simple terms, it means that in any large scale-free
    network, there will be a few nodes that are connected to a large proportion of</st>
    <st c="36473">the network.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36485">What does a power-law distribution look like?</st> <st c="36532">Pretty
    boring in fact.</st> <st c="36555">If we look at Eq.</st> <st c="36573">9 in a
    bit more detail and take the logarithm of it for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi
    mathvariant="normal">n</mml:mi></mml:mrow></mml:msub></mml:math>](img/3477.png)<st
    c="36629"><st c="36630">, then we have</st> <st c="36645">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>log</mi><mtext>Prob</mtext><mfenced
    open="(" close=")"><mrow><mtext>Total</mtext><mtext>Degree</mtext><mtext>=</mtext><mi>x</mi></mrow></mfenced><mo>=</mo><mo>−</mo><mi>α</mi><mi>log</mi><mi>x</mi><mo>−</mo><mi>log</mi><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced></mrow></mrow></math>](img/3478.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36712">Eq.</st> <st c="36716">11</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36718">Eq.</st> <st c="36723">11 is just the equation of a straight line
    with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3479.png)
    <st c="36771"><st c="36777">being the variable on the</st> *<st c="36803">x</st>*<st
    c="36804">-axis.</st> <st c="36811">This means that on a logarithmic scale, our
    power-law probabilities decrease linearly.</st> <st c="36898">Figure 10</st><st
    c="36907">.14 shows an example of a power-law distribution for</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>2.5</mml:mn></mml:math>](img/3480.png)
    <st c="36960"><st c="36961">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3481.png)<st
    c="36966"><st c="36967">. The line shows the</st> <st c="36987">probabilities
    calculated according to Eq.</st> <st c="37030">9\.</st> <st c="37033">Note that
    the red line is linear.</st> <st c="37067">That is because we have plotted both
    the</st> *<st c="37108">x</st>*<st c="37109">-axis and</st> *<st c="37119">y</st>*<st
    c="37120">-axis in</st> <st c="37129">Figure 10</st><st c="37138">.14 on a logarithmic
    sca</st><st c="37162">le to emphasize the power-law decay of</st> <st c="37202">the
    probabilities:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19496_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="37333">Figure 10.14: A power-law distribution of node degree values</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37393">The</st> <st c="37398">black dots in</st> <st c="37412">Figure
    10</st><st c="37421">.14 represent sample proportions of the different node degree
    values when I generated a sample of 5,000,000 degree values from the probability
    distribution represented by the red line.</st> <st c="37606">As you would expect,
    the sample proportions follow the line closely.</st> <st c="37675">We can see
    from those black dots that there is a small but not insignificant fraction of
    total degree values greater than 1,000\.</st> <st c="37804">This would represent
    nodes that were connected to more than 1,000</st> <st c="37870">other nodes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37882">From the example in</st> <st c="37903">Figure 10</st><st c="37912">.14,
    it should be apparent that scale-free networks exhibit the small-world phenomenon,
    so scale-free networks are also small-world networks.</st> <st c="38054">Perhaps
    more interesting is that for scale-free networks, the mean shortest path distance
    between nodes,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3482.png)<st
    c="38159"><st c="38160">, only grows as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math>](img/3483.png)
    <st c="38176"><st c="38184">as the size of the network,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/686.png)<st
    c="38212"><st c="38213">, increases.</st> <st c="38226">Now,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math>](img/3483.png)
    <st c="38231"><st c="38239">is an even more slowly increasing function of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)
    <st c="38285"><st c="38286">than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3487.png)<st
    c="38292"><st c="38293">, meaning that in scale-free networks, the typical distance
    between nodes hardly changes, even as we get to very big networks.</st> <st c="38420">We
    can think of scale-free networks as being</st> <st c="38465">super-small-world
    networks.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38492">In reality, any finite-sized network</st> <st c="38529">always
    has a scale associated with it – the size of the network.</st> <st c="38595">That
    means a real-world network cannot be truly scale-free.</st> <st c="38655">Does
    this mean scale-free networks are useless to us?</st> <st c="38709">No, far from
    it.</st> <st c="38726">Many large real-world networks, while not</st> **<st c="38768">exactly</st>**
    <st c="38775">scale-free, are extremely well approximated by scale-free networks,
    so studying and understanding the properties of scale-free networks helps us understand
    the properties of those real-world networks.</st> <st c="38977">For example, the
    node degree values of real-world</st> <st c="39027">networks can display linear
    behavior like that in</st> <st c="39077">Figure 10</st><st c="39086">.14 or very
    close to it.</st> <st c="39111">Examples of real-world networks whose node degree
    distributions are modeled well by a power-law distribution include</st> <st c="39228">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39242">The World Wide Web, where both the node in-degree and out-degree
    values of websites follow power-law</st> <st c="39344">distributions closely</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39365">Scientific paper citation networks, where the in-degree values
    appear to follow a</st> <st c="39448">power-law distribution</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39470">That concludes our introduction to different classes of graphs.</st>
    <st c="39535">We have covered only a small number of classes in this section.</st>
    <st c="39599">There are many more.</st> <st c="39620">However, you will have gained
    a flavor of and feel for the rich variety of structures, behaviors, and uses that
    you can see across different classes of graphs.</st> <st c="39780">Let’s remind
    ourselves what we have covered in</st> <st c="39827">this section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39840">What we’ve learned</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="39859">In this section, we learned</st> <st c="39888">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39902">A graph can be fully connected if every node is connected to every</st>
    <st c="39970">other node.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39981">A graph can consist of several disconnected components, each of
    which is a graph in its</st> <st c="40070">own right.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40080">A directed graph can be used to represent a set of dependencies,
    in which case it is desirable not to have any cycles in the directed graph.</st>
    <st c="40222">Such graphs are</st> <st c="40238">called DAGs.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40250">Many real-world graphs exhibit the small-world phenomenon, where
    the typical distance between any two nodes is small and only a weakly growing
    function of the</st> <st c="40410">network size.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40423">Scale-free networks have node degree distributions that are scale-free
    and follow a power-law.</st> <st c="40519">Scale-free networks exhibit the</st>
    <st c="40551">small-world phenomenon.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40574">Having learned about some different types of graphs, including
    graph types that occur frequently in real-world settings, in the next section,
    we’ll do some calculations with graph data.</st> <st c="40761">We will look at
    community detection, where we take a graph and try to identify the main sub-graphs
    within it that represent distinct communities</st> <st c="40906">of nodes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40915">Community detection and decomposing graphs</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="40958">Community detection</st> <st c="40978">is a common data science
    task and a useful technique to have in your data science toolkit, but let’s start
    by describing what we mean by</st> <st c="41116">a community.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41128">What is a community?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="41149">In many real-world networks, nodes are used to represent people.</st>
    <st c="41215">Consequently, when we have a</st> <st c="41243">collection of highly
    connected nodes, forming almost a fully connected separate graph, we can think
    of this as a</st> **<st c="41357">community</st>** <st c="41366">of</st> <st c="41370">interacting
    people.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41389">We can extend this idea to situations where the nodes do not represent
    people.</st> <st c="41469">For example, our trade network example at the beginning
    of this chapter was fully connected, but if it wasn’t, there might be groups of
    countries that preferentially trade with each other and don’t trade with other
    countries.</st> <st c="41695">We would have separate trading blocks or trading
    communities.</st> <st c="41757">Similarly, in our pizza example, we have groups
    of pizzas that are more similar to each other and hence interchangeable.</st>
    <st c="41878">This means we have communities</st> <st c="41909">of pizzas.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41919">Why is knowing about communities useful to us?</st> <st c="41967">A
    community represents a group of similar entities.</st> <st c="42019">In data</st>
    <st c="42027">science, it is often useful to be able to group things – to analyze
    them together, to model their response to a feature using a single parameter.</st>
    <st c="42173">This means we often want to take a graph, as represented by an adjacency
    matrix, and identify the community</st> <st c="42281">structure present in the
    graph.</st> <st c="42313">This is the problem of</st> **<st c="42336">community
    detection</st>**<st c="42355">. We are taking a graph and breaking it down into
    a set of sub-graphs.</st> <st c="42426">In other words, community detection is
    about decomposing</st> <st c="42483">a graph.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42491">How to do community detection</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="42521">We have said that we can think of a community as a highly connected
    set of related nodes.</st> <st c="42612">This means that when we have isolated
    communities, detecting them is easy.</st> <st c="42687">Figure 10</st><st c="42696">.15
    shows an example of two distinct communities of nodes.</st> <st c="42755">The
    different communities are obvious.</st> <st c="42794">The different communities
    correspond to separate graphs.</st> <st c="42851">The communities</st> <st c="42866">are
    disconnected from each other.</st> <st c="42901">If</st> <st c="42904">Figure
    10</st><st c="42913">.15 looks familiar, that is because it is the same as</st>
    <st c="42967">Figure 10</st><st c="42976">.11, which we u</st><st c="42991">sed
    to illustrate a graph consisting of</st> <st c="43032">disconnected components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: Two distinct communities of nodes](img/B19496_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="43081">Figure 10.15: Two distinct communities of nodes</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43128">Mathematically, detecting communities is easy when they correspond
    to disconnected components of a graph.</st> <st c="43235">However, consider the
    graph in</st> <st c="43266">Figure 10</st><st c="43275">.16\.</st> <st c="43280">It
    is a single graph, but how many communities</st> <st c="43327">are there?</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: A single graph with two communities](img/B19496_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="43339">Figure 10.16: A single graph with two communities</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43388">To most</st> <st c="43397">people, the graph in</st> <st c="43418">Figure
    10</st><st c="43427">.16 would also appear to consist of two communities.</st>
    <st c="43480">The communities are clear.</st> <st c="43507">There is one community
    on the left-hand part of the graph in</st> <st c="43568">Figure 10</st><st c="43577">.16
    and one on the right-hand side.</st> <st c="43613">To any human observer, the
    identification of the commun</st><st c="43668">ities is obvious and corresponds
    to that shown in</st> <st c="43719">Figure 10</st><st c="43728">.17:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Identifying two communities in a single graph](img/B19496_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="43759">Figure 10.17: Identifying two communities in a single graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43818">The two communities in</st> <st c="43842">Figure 10</st><st c="43851">.17
    are connected and have a node in common.</st> <st c="43896">As humans, we are
    OK with the idea that communities are connected, with nodes that act as links
    between them.</st> <st c="44006">Mathematically, we need algorithms that are comfortable
    with the ambiguity of not having perfectly disconnected components and can identify
    the parts of the graph that are most community-like.</st> <st c="44199">We will
    briefly describe some of these</st> <st c="44238">algorithms next.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44254">Community detection algorithms</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="44285">Community detection algorithms</st> <st c="44317">attempt to identify
    the parts of a graph that look most like a distinct community.</st> <st c="44400">As
    you can imagine, they do this by attempting to find a subset of nodes that are
    tightly connected and weakly connected to nodes outside of the subset.</st> <st
    c="44553">Essentially, community detection corresponds to a process of using the
    information encoded in a graph’s adjacency matrix to assign each node to a subset
    (</st><st c="44707">the community).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44723">Once each node has been assigned to a community, we can assess
    the quality of the assignment by measuring how inter-connected nodes within the
    same community are compared to nodes from separate communities.</st> <st c="44931">If
    we have a quantitative metric that measures this quality – that is, measures the
    within-community connectedness compared to the between-community connectedness
    – then we can iterate the overall process to maximize this community quality metric.</st>
    <st c="45179">This is the essence of a community</st> <st c="45214">detection
    algorithm.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45234">As you can imagine, there are different metrics we can use to
    measure the quality of a specific node-to-community assignment and different optimization
    approaches we can use to maximize the chosen assignment quality metric.</st> <st
    c="45459">This means there are many different types and flavors of community</st>
    <st c="45526">detection algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45547">The most commonly used type of community detection algorithm is</st>
    **<st c="45612">modularity maximization</st>**<st c="45635">. As the</st> <st
    c="45644">name suggests, this algorithm maximizes the total modularity score of
    the community assignment.</st> <st c="45740">The modularity score of a community
    is the difference between the actual number of edges between nodes within the
    community and the expected number of edges within the community if the edges of
    the graph were placed at random.</st> <st c="45967">So, we can think of the modularity
    score as a measure of the observed within-community excess number of edges.</st>
    <st c="46078">If our community assignment genuinely reflected some true underlying
    community structure, then we would expect this excess number of edges to be high
    as nodes within a genuine community have a high probability of being connected.</st>
    <st c="46308">So, a high modularity score is indicative of a good community assignment.</st>
    <st c="46382">Modularity maximization can be applied to split a graph into just
    two communities or more than two communities.</st> <st c="46494">There are also
    different algorithms to perform the maximization, including</st> <st c="46569">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46583">Greedy algorithms, which perform the</st> <st c="46621">maximization
    iteratively</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="46645">The spectral method, which uses the eigen-decomposition (see</st>
    [*<st c="46707">Chapter 3</st>*](B19496_03.xhtml#_idTextAnchor141)<st c="46716">)
    of the modularity matrix (which is derived from the adjacency matrix) to find
    an optimal</st> <st c="46808">community assignment.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="46829">The Louvain algorithm, which performs the modularity maximization
    agglomeratively.</st> <st c="46913">It</st> <st c="46915">starts by joining single
    nodes into pairs, then joining other pairs or single nodes together, and so on,
    each time measuring the modularity score until no improvement in the modularity
    score</st> <st c="47107">is obtained.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47119">There are also other classes of community detection algorithms,
    including</st> <st c="47194">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="47208">Model-based approaches</st>**<st c="47231">: These fit a probabilistic
    model (see</st> [*<st c="47271">Chapter 5</st>*](B19496_05.xhtml#_idTextAnchor261)<st
    c="47280">) to the</st> <st c="47289">graph structure, with the model assuming
    some community structure.</st> <st c="47357">This allows us to compute the likelihood
    of the observed network structure given the assumed community structure.</st>
    <st c="47471">The likelihood can then be maximized with respect to the community
    structure to obtain a community structure that is highly compatible with the given
    network</st> <st c="47629">adjacency matrix.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="47646">Betweenness-based approaches</st>**<st c="47675">: These attempt
    to uncover the community</st> <st c="47717">structure present in a graph by breaking
    the graph apart into disconnected components.</st> <st c="47804">By iteratively
    identifying and then removing edges that have a high “betweenness” score – that
    is, those edges that connect a high number of different parts of the network –
    the idea is that the graph will quickly separate (fall apart) into disconnected
    communities after the removal of these high “betweenness” edges.</st> <st c="48123">Perhaps
    the most well-known and commonly used betweenness community detection algorithm
    is that of Girvan and Newman – see the</st> *<st c="48250">Notes and further reading</st>*
    <st c="48275">section at the end of this chapter for details on</st> <st c="48326">this
    algorithm.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="48341">Having introduced community detection algorithms, let’s try some
    out with a</st> <st c="48418">code example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48431">Community detection code example</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="48464">The following</st> <st c="48479">code example and more can be
    found in the</st> `<st c="48521">Code_Examples_Chap10.ipynb</st>` <st c="48547">Jupyter
    Notebook in this book’s GitHub repository.</st> <st c="48599">It uses the example
    of the graph in</st> <st c="48635">Figure 10</st><st c="48644">.16\.</st> <st
    c="48649">We’ll use the</st> `<st c="48663">NetworkX</st>` <st c="48671">Python
    package to do the community detection.</st> <st c="48718">The graph in</st> <st
    c="48731">Figure 10</st><st c="48740">.16 is represented as a series of nodes
    and edges and stored in the</st> `<st c="48808">Data/example_network_adjlist.txt</st>`
    <st c="48840">file in this book’s GitHub repository.</st> <st c="48880">The data
    in the file is in a format that the</st> `<st c="48925">NetworkX</st>` <st c="48933">package
    can understand.</st> <st c="48958">Let’s start by reading in</st> <st c="48984">the
    graph:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49088">The</st> `<st c="49093">nodetype=int</st>` <st c="49105">option
    tells</st> `<st c="49119">NetworkX</st>` <st c="49127">that the nodes are represented
    (labeled) by integers.</st> <st c="49182">Now that the graph is stored in</st>
    `<st c="49214">G</st>`<st c="49215">, we can</st> <st c="49224">visualize it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49325">This results in the following graph.</st> <st c="49363">We have
    ove</st><st c="49374">rridden the default node color to make the node labels</st>
    <st c="49430">more visible:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18: Our starting labeled graph](img/B19496_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="49445">Figure 10.18: Our starting labeled graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49485">Now, we’ll apply a modularity maximization algorithm to the graph,</st>
    `<st c="49553">G</st>`<st c="49554">. In this case, we’ll use the greedy</st>
    <st c="49591">modularity maximization algorithm that the</st> `<st c="49634">NetworkX</st>`
    <st c="49642">package supplies:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49720">We’ve stored the result in the</st> `<st c="49752">communities</st>`
    <st c="49763">object.</st> <st c="49772">Let’s look</st> <st c="49783">at it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49801">This gives us the</st> <st c="49820">following output:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49915">Here, we can see that the</st> `<st c="49942">communities</st>`
    <st c="49953">object is two lists of integers, corresponding to the node IDs that
    the greedy modularity maximization algorithm has placed into two communities.</st>
    <st c="50100">In other words, the algorithm has identified two communities, one
    consisting of nodes [1,2,3,4,5,6], and the other corresponding to nodes [7,8,9,10,11,12,13].</st>
    <st c="50259">We’ll add some colors to the nodes according to which community
    they</st> <st c="50328">are in:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50567">Note that we first created a dictionary that mapped the node label
    to a community color and then created a list that used that dictionary to map
    the node index to a community color.</st> <st c="50750">This is because the order
    in which the nodes are indexed does not necessarily match the node labels, even
    if those labels are integer values.</st> <st c="50892">So, the node with a label
    of “6” is not necessarily stored as the 6</st><st c="50959">th</st> <st c="50962">node.</st>
    <st c="50969">To check the order in which the nodes are indexed, you can</st>
    <st c="51028">use</st> `<st c="51032">G.nodes</st>`<st c="51039">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51049">This gives us the</st> <st c="51068">following output:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51147">Here, we</st> <st c="51156">can see that node 7 is indexed in
    the 6</st><st c="51196">th</st> <st c="51199">position, and node 6 is indexed
    in the 7</st><st c="51240">th</st> <st c="51243">position.</st> <st c="51254">With
    that little nuance sorted out and a color map created, we can now redraw the graph
    with each node colored according to which community it</st> <st c="51397">is in:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51489">This gives us the</st> <st c="51508">following graph:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19: Our graph with two communities identified and nodes colored
    according to which community they belong to](img/B19496_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="51526">Figure 10.19: Our graph with two communities identified and nodes
    colored according to which community they belong to</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51643">From</st> <st c="51649">Figure 10</st><st c="51658">.19, we can
    see that the community detection algorithm has uncovered what we would regard
    as the obvious communities that are present in the starting graph in</st> <st
    c="51817">Figure 10</st><st c="51826">.18\.</st> <st c="51831">While it is a simple
    example, it does illustrate how easy it is to run community detection algorithms.</st>
    <st c="51934">It also illustrates the usefulness of those algorithms.</st> <st
    c="51990">It is usually relatively easy to construct a pairwise measure or weight
    of how closely related two nodes or objects are.</st> <st c="52111">This means
    we can easily construct a weighted adjacency matrix for a set of interacting objects,
    such as a retailer’s products.</st> <st c="52239">Community detection</st> <st
    c="52258">algorithms then allow us to easily uncover the natural groupings of
    those objects, with minimal</st> <st c="52355">extra coding.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52368">Having run a simple code example to illustrate how community detection
    is performed, we’ll wrap up this section and</st> <st c="52485">this chapter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52498">What we’ve learned</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="52517">In this section, we learned</st> <st c="52546">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52560">A community represents a collection of similar or</st> <st c="52611">related
    nodes</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52624">Community detection attempts to break a graph into distinct sub-graphs</st>
    <st c="52696">or communities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52710">How community detection algorithms work by optimizing a metric
    that measures the quality of the assignment of nodes</st> <st c="52827">to communities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52841">Modularity maximization community</st> <st c="52876">detection
    algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52896">Other approaches to community detection, such as model-based approaches
    and</st> <st c="52973">betweenness-centrality-based approaches</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53012">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="53020">This chapter has been about a specific type of data – network
    data.</st> <st c="53089">We have learned that networks are used to represent relationships.</st>
    <st c="53156">Since relationships are prevalent in many real-world scenarios,
    it is essential that, as a data scientist, you are familiar with the main concepts
    and terminology relating to networks.</st> <st c="53341">Of these, the most important
    concepts we have covered in this chapter are</st> <st c="53415">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53426">What a network represents and that a network is</st> <st c="53475">a
    graph</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53482">A graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3366.png)<st
    c="53492"><st c="53493">, consists of a set of nodes (vertices),</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="53534"><st c="53535">, and a set of edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3360.png)<st
    c="53557"><st c="53558">, between</st> <st c="53568">those nodes</st></st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53579">The edges of a graph can be undirected or directed and can have
    weights associated</st> <st c="53663">with them</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53672">The structure of a graph is encoded in the</st> <st c="53716">adjacency
    matrix</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53732">The in-degree and out-degree of a node can be calculated from
    the adjacency matrix and tell us the number of edges coming into a node and leaving
    a</st> <st c="53881">node, respectively</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53899">The sum of the node in-degree and out-degree values gives us the
    total degree value for a node and is a node centrality measure, which is a measure
    of the importance of</st> <st c="54069">the node</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54077">A graph can be fully connected if every node is connected to every</st>
    <st c="54145">other node</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54155">If a directed graph doesn’t have any cycles, then it is called
    a DAG, and DAGs are used to represent dependency structures</st> <st c="54279">between
    entities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54295">Many graphs exhibit the small-world phenomenon, whereby the typical
    distance between two nodes on the graph is small and a weakly growing function
    of the</st> <st c="54450">network size</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54462">Scale-free graphs have node degree distributions that</st> <st
    c="54517">are power-laws</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54531">Community detection algorithms attempt to break down a graph into
    its natural sub-graphs of closely connected subsets</st> <st c="54650">of nodes</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54658">Key community detection algorithms such as</st> <st c="54702">modularity
    maximization</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54725">The next chapter, like this chapter on network data, is about
    another specific type of data and the systems that generate it.</st> <st c="54852">We’ll
    be looking at dynamical systems, the data they generate, and the underlying equations
    that control the evolution of those</st> <st c="54980">dynamical systems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54998">Exercises</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="55008">The following is a series of exercises.</st> <st c="55049">Answers
    to all these exercises can be found in the</st> `<st c="55100">Answers_to_Exercises_Chap10.ipynb</st>`
    <st c="55133">Jupyter Notebook in this book’s</st> <st c="55166">GitHub repository:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55184">The Zachary Karate Club is a well-known network in the field of
    network science, so much so that a copy of the network is stored in the</st> `<st
    c="55321">NetworkX</st>` <st c="55329">package and can be accessed via the</st>
    `<st c="55366">karate_club_graph()</st>` <st c="55385">function.</st> <st c="55396">Use
    this function to create the karate club graph and then use the</st> `<st c="55463">community.greedy_modularity_communities</st>`
    <st c="55502">function to identify the communities within the graph.</st> <st
    c="55558">You can assume that there are two communities, so you should look at
    how to use the</st> `<st c="55642">cutoff</st>` <st c="55648">and</st> `<st c="55653">best_n</st>`
    <st c="55659">parameters of the</st> `<st c="55678">community.greedy_modularity_communities</st>`
    <st c="55718">function to ensure that only two communities are found.</st> <st
    c="55774">Which nodes do you think are at the center of each of the two</st> <st
    c="55836">communities found?</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="55854">Use the</st> `<st c="55863">scale_free_graph</st>` <st c="55879">function
    of the</st> `<st c="55896">NetworkX</st>` <st c="55904">package to create a scale-free
    graph with 10,000 nodes.</st> <st c="55961">Having generated the scale-free graph,
    use the</st> `<st c="56008">degree</st>` <st c="56014">function of the</st> `<st
    c="56031">NetworkX</st>` <st c="56039">package to calculate the degree value of
    each node.</st> <st c="56092">Sort the node degree values in descending order
    and plot them against their rank on a log-log plot.</st> <st c="56192">You should
    see a linear relationship on the log-log plot.</st> <st c="56250">You’ll need
    to pay attention to the object type returned by the</st> `<st c="56314">degree</st>`
    <st c="56320">function of the</st> `<st c="56337">NetworkX</st>` <st c="56345">package.</st>
    <st c="56355">You may find it useful to convert it into a dictionary by wrapping
    it inside a call</st> <st c="56439">to</st> `<st c="56442">dict()</st>`<st c="56448">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="56449">Look at the</st> `<st c="56462">NetworkX</st>` <st c="56470">package
    documentation for the</st> `<st c="56501">watts_strogatz_graph</st>` <st c="56521">function.</st>
    <st c="56532">This uses the Strogatz and Watts algorithm to generate simulated
    small-world networks.</st> <st c="56619">Use this function to generate a series
    of graphs with the number of nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/3491.png)<st
    c="56693"><st c="56694">=10,20,40,80,160,320,640,1280\.</st> <st c="56725">For
    each graph, set k=5 and p=0.3\.</st> <st c="56760">These are the initial degree
    values and edge re-wiring probability of the Strogatz and Watts algorithm, respectively.</st>
    <st c="56878">For each graph, use the</st> `<st c="56902">shortest_path_length</st>`
    <st c="56922">function of the</st> `<st c="56939">NetworkX</st>` <st c="56947">package
    to compute the shortest path distance between each of the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/3492.png)
    <st c="57014"><st c="57015">pair of nodes in the graph.</st> <st c="57044">For
    each value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)<st
    c="57062"><st c="57063">, calculate the average shortest path distance,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)<st
    c="57111"><st c="57112">, as defined by Eq.</st> <st c="57132">8, and plot</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)
    <st c="57144"><st c="57145">against</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3496.png)<st
    c="57154"><st c="57155">. You should see a linear relationship between</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3482.png)
    <st c="57202"><st c="57203">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3498.png)<st
    c="57208"><st c="57209">. See if you can spot a short-cut where you don’t have
    to compute all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/3499.png)
    <st c="57279"><st c="57280">shortest path distances to</st> <st c="57308">calculate</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)<st
    c="57318"><st c="57319">.</st></st></st></st></st></st></st></st></st></st></st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="57320">Notes and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="57346">For details on the Girvan and Newman algorithm, see the research
    paper by M.</st> <st c="57424">Girvan and M.E.J.</st> <st c="57442">Newman</st>*<st
    c="57448">, Community structure in social and biological networks</st>*<st c="57503">,
    Proceedings of the National Academy of Sciences USA, 99:7821-7826, 2002\.</st>
    <st c="57578">A preprint version of the paper can be found in the arXiv archive</st>
    <st c="57644">at</st> [<st c="57647">https://arxiv.org/pdf/cond-mat/0112110.pdf</st>](https://arxiv.org/pdf/cond-mat/0112110.pdf)<st
    c="57689">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="0">Part 3: Selected Advanced Concepts</st>'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="35">In this part, we will introduce a selection of advanced math concepts.</st>
    <st c="107">As with Part 2, each concept is a standalone topic.</st> <st c="159">But,
    in contrast to Part 2, we’re now introducing topics at the cutting edge of data
    science and data science research.</st> <st c="279">There is still a high probability
    you will encounter these concepts in your data science work, especially the longer
    you work in data science.</st> <st c="422">Because of the advanced nature of the
    topics, each chapter is only designed to give you a basic grounding in that topic.</st>
    <st c="543">But by the end of Part 3, you will understand the core ideas of each
    of these topics and be able to use that understanding to guide your</st> <st c="680">own
    studies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="692">This section contains the</st> <st c="719">following chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="738">Chapter 11</st>*](B19496_11.xhtml#_idTextAnchor555)<st c="749">,</st>
    *<st c="751">Dynamical Systems</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="768">Chapter 12</st>*](B19496_12.xhtml#_idTextAnchor612)<st c="779">,</st>
    *<st c="781">Kernel Methods</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="795">Chapter 13</st>*](B19496_13.xhtml#_idTextAnchor646)*<st c="806">,
    Information Theory</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="826">Chapter 14</st>*](B19496_14.xhtml#_idTextAnchor702)*<st c="837">,
    Bayesian Non-Parametric Methods</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="870">Chapter 15</st>*](B19496_15.xhtml#_idTextAnchor739)*<st c="881">,
    Random Matrices</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
