<html><head></head><body>
  <div id="_idContainer026" class="Basic-Text-Frame">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-15" class="chapterTitle">Overview of Algorithms</h1>
    <blockquote class="packt_quote">
      <p class="quote">An algorithm must be seen to be believed.</p>
      <p class="cite">– Donald Knuth</p>
    </blockquote>
    <p class="normal">This book covers the information needed to understand, classify, select, and implement important algorithms. In addition to explaining their logic, this book also discusses data structures, development environments, and production environments that are suitable for different classes of algorithms. This is the second edition of this book. In this edition, we especially focus on modern machine learning algorithms that are becoming more and more important. Along with the logic, practical examples of the use of algorithms to solve actual everyday problems are also presented.</p>
    <p class="normal">This chapter provides an insight into the fundamentals of algorithms. It starts with a section on the basic concepts needed to understand the workings of different algorithms. To provide a historical perspective, this section summarizes how people started using algorithms to mathematically formulate a certain class of problems. It also mentions the limitations of different algorithms. The next section explains the various ways to specify the logic of an algorithm. As Python is used in this book to write the algorithms, how to set up a Python environment to run the examples is explained. Then, the various ways that an algorithm’s performance can be quantified and compared against other algorithms are discussed. Finally, this chapter discusses various ways a particular implementation of an algorithm can be validated.</p>
    <p class="normal">To sum up, this chapter covers the following main points:</p>
    <ul>
      <li class="bulletList">What is an algorithm?</li>
      <li class="bulletList">The phases of an algorithm</li>
      <li class="bulletList">Development environment</li>
      <li class="bulletList">Algorithm design techniques</li>
      <li class="bulletList">Performance analysis</li>
      <li class="bulletList">Validating an algorithm</li>
    </ul>
    <h1 id="_idParaDest-16" class="heading-1">What is an algorithm?</h1>
    <p class="normal">In the simplest terms, an <a id="_idIndexMarker000"/>algorithm is a set of rules for carrying out some calculations to solve a problem. It is designed to yield results for any valid input according to precisely defined instructions. If you look up the word algorithm in a dictionary (such as American Heritage), it defines the concept as follows:</p>
    <blockquote class="packt_quote">
      <p class="quote">An algorithm is a finite set of unambiguous instructions that, given some set of initial conditions, can be performed in a prescribed sequence to achieve a certain goal and that has a recognizable set of end conditions.</p>
    </blockquote>
    <p class="normal">Designing an algorithm is an effort to create a mathematical recipe in the most efficient way that can effectively be used to solve a real-world problem. This recipe may be used as the basis for developing a more reusable and generic mathematical solution that can be applied to a wider set of similar problems.</p>
    <h2 id="_idParaDest-17" class="heading-2">The phases of an algorithm</h2>
    <p class="normal">The different phases <a id="_idIndexMarker001"/>of developing, deploying, and finally, using an algorithm are illustrated in <em class="italic">Figure 1.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_01_01.png" alt="Diagram, schematic  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.1: The different phases of developing, deploying, and using an algorithm</p>
    <p class="normal">As we can see, the process starts with understanding the requirements from the problem statement that details what needs to be done. Once the problem is clearly stated, it leads us to the<a id="_idIndexMarker002"/> development phase.</p>
    <p class="normal">The development phase consists of two phases:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">The design phase</strong>: In the <a id="_idIndexMarker003"/>design phase, the architecture, logic, and implementation details of the algorithm are envisioned and documented. While designing an algorithm, we keep both accuracy and performance in mind. While searching for the best solution to a given problem, in many cases, we will end up having more than one candidate algorithm. The design phase of an algorithm is an iterative process that involves comparing different candidate algorithms. Some algorithms may provide simple and fast solutions but may compromise accuracy. Other algorithms may be very accurate but may take considerable time to run due to their complexity. Some of these complex algorithms may be more efficient than others. Before making a choice, all the inherent tradeoffs of the candidate algorithms should be carefully studied. Particularly for a complex problem, designing an efficient algorithm is important. A correctly designed algorithm will result in an efficient solution that will be capable of providing both satisfactory performance and reasonable accuracy at the same time.</li>
      <li class="numberedList"><strong class="keyWord">The coding phase</strong>: In the<a id="_idIndexMarker004"/> coding phase, the designed algorithm is converted into a computer program. It is important that the computer program implements all the logic and architecture suggested in the design phase.</li>
    </ol>
    <p class="normal">The requirements of the business problem can be divided into functional and non-functional requirements. The requirements that directly specify the expected features of the solutions are called the<a id="_idIndexMarker005"/> functional requirements. Functional requirements detail the expected behavior of the solution. On the other hand, the non-functional requirements are about the performance, scalability, usability, and accuracy of the algorithm. Non-functional requirements<a id="_idIndexMarker006"/> also establish the expectations about the security of the data. For example, let us consider that we are required to design an algorithm for a credit card company that can identify and flag fraudulent transactions. Function requirements in this example will specify the expected behavior of a valid solution by providing the details of the expected output given a certain set of input data. In this case, the input data may be the details of the transaction, and the output may be a binary flag that labels a transaction as fraudulent or non-fraudulent. In this example, the non-functional requirements may specify the response time of each of the predictions. Non-functional requirements will also set the <a id="_idIndexMarker007"/>allowable thresholds for accuracy. As we are dealing with financial data in this example, the security requirements related to user authentication, authorization, and data confidentiality are also expected to be part of non-functional requirements.</p>
    <p class="normal">Note that <a id="_idIndexMarker008"/>functional and non-functional requirements aim to precisely define <em class="italic">what</em> needs to be done. Designing the solution is about figuring out <em class="italic">how</em> it will be done. And implementing the design is developing the actual solution in the programming language of your choice. Coming up with a design that fully meets both functional and non-functional requirements may take lots of time and effort. The choice of the right programming language and development/production environment may depend on the requirements of the problem. For example, as C/C++ is a lower-level language than Python, it may be a better choice for algorithms needing compiled code and lower-level optimization.</p>
    <p class="normal">Once the design phase is<a id="_idIndexMarker009"/> completed and the coding is complete, the algorithm is ready to be deployed. Deploying an algorithm involves the design of the actual production environment in which the code will run. The production environment needs to be designed according to the data and processing needs of the algorithm. For example, for parallelizable algorithms, a cluster with an appropriate number of computer nodes will be needed for the efficient execution of the algorithm. For data-intensive algorithms, a data ingress pipeline and the strategy to cache and store data may need to be designed. Designing a production environment is discussed in more detail in <em class="chapterRef">Chapter 15</em>, <em class="italic">Large-Scale Algorithms</em>, and <em class="chapterRef">Chapter 16</em>, <em class="italic">Practical Considerations</em>. </p>
    <p class="normal">Once the production environment is designed and implemented, the algorithm is deployed, which takes the input data, processes it, and generates the output as per the requirements.</p>
    <h2 id="_idParaDest-18" class="heading-2">Development environment</h2>
    <p class="normal">Once designed, algorithms need to<a id="_idIndexMarker010"/> be implemented in a programming language as per the design. For this book, we have chosen the programming language Python. We chose it because Python is flexible and is an open-source programming language. Python is also one of the languages that you can use in various cloud computing infrastructures, such <a id="_idIndexMarker011"/>as <strong class="keyWord">Amazon Web Services</strong> (<strong class="keyWord">AWS</strong>), Microsoft<a id="_idIndexMarker012"/> Azure, and <strong class="keyWord">Google Cloud Platform</strong> (<strong class="keyWord">GCP</strong>).</p>
    <p class="normal">The official Python<a id="_idIndexMarker013"/> home page is available at <a href="https://www.python.org/"><span class="url">https://www.python.org/</span></a>, which also has instructions for installation and a useful beginner’s guide.</p>
    <p class="normal">A basic understanding of Python is required to better understand the concepts presented in this book.</p>
    <p class="normal">For this book, we expect<a id="_idIndexMarker014"/> you to use the most recent version of Python 3. At the time of writing, the most recent version is 3.10, which is what we will use to run the exercises in this book.</p>
    <p class="normal">We will be using Python throughout this book. We will also be using Jupyter Notebook to run the code. The rest of the chapters in this book assume that Python is installed and Jupyter Notebook has been properly configured and is running.</p>
    <h1 id="_idParaDest-19" class="heading-1">Python packages</h1>
    <p class="normal">Python<a id="_idIndexMarker015"/> is a general-purpose language. It follows the philosophy of “batteries included,” which means that there is a standard library that is available, without making the user download separate packages. However, the standard library modules only provide the bare minimum functionality. Based on the specific use case you are working on, additional packages may need to be installed. The official third-party repository for Python packages<a id="_idIndexMarker016"/> is called <a id="_idIndexMarker017"/>PyPI, which stands for <strong class="keyWord">Python Package Index</strong>. It hosts Python packages both as source distribution and pre-compiled code. Currently, there are more than 113,000 Python packages hosted at PyPI. The easiest way to install additional packages is through the <code class="inlineCode">pip</code> package management system. <code class="inlineCode">pip</code> is a nerdy recursive acronym, which are abundant in Python culture. <code class="inlineCode">pip</code> stands for <strong class="keyWord">Pip Installs Python</strong>. The good news is that starting from<a id="_idIndexMarker018"/> version 3.4 of Python, <code class="inlineCode">pip</code> is installed by default. To check the version of <code class="inlineCode">pip</code>, you can type on the command line:</p>
    <pre class="programlisting con"><code class="hljs-con">pip --version
</code></pre>
    <p class="normal">This <code class="inlineCode">pip</code> command can be used to install additional packages:</p>
    <pre class="programlisting con"><code class="hljs-con">pip install PackageName
</code></pre>
    <p class="normal">The <a id="_idIndexMarker019"/>packages that have already been installed need to be periodically updated to get the latest functionality. This is achieved by using the <code class="inlineCode">upgrade</code> flag:</p>
    <pre class="programlisting con"><code class="hljs-con">pip install PackageName --upgrade
</code></pre>
    <p class="normal">And to install a specific version of a Python package:</p>
    <pre class="programlisting con"><code class="hljs-con">pip install PackageName==2.1
</code></pre>
    <div class="note">
      <p class="normal">Adding the right libraries and versions has become part of setting up the Python programming environment. One feature that helps with maintaining these libraries is the ability to create a requirements file that lists all the packages that are needed. The requirements file is a simple text file that contains the name of the libraries and their associated versions. A sample of the requirements file looks as follows:</p>
      <p class="normal"><code class="inlineCode">scikit-learn==0.24.1</code></p>
      <p class="normal"><code class="inlineCode">tensorflow==2.5.0</code></p>
      <p class="normal"><code class="inlineCode">tensorboard==2.5.0</code></p>
      <p class="normal">By convention, the <code class="inlineCode">requirements.txt</code> is placed in the project’s top-level directory.</p>
      <p class="normal">Once created, the requirements file can be used to set up the development environment by installing all the Python libraries and their associated versions by using the following command:</p>
      <pre class="programlisting con"><code class="hljs-con">pip install -r requirements.txt
</code></pre>
    </div>
    <p class="normal">Now let us look into the main packages that we will be using in this book.</p>
    <h2 id="_idParaDest-20" class="heading-2">The SciPy ecosystem</h2>
    <p class="normal"><strong class="keyWord">Scientific Python</strong> (<strong class="keyWord">SciPy</strong>)—pronounced <a id="_idIndexMarker020"/>sigh pie—is a group of Python packages created for the scientific community. It contains many functions, including a wide range of random number generators, linear algebra routines, and optimizers.</p>
    <p class="normal">SciPy is a <a id="_idIndexMarker021"/>comprehensive package and, over time, people have developed many extensions to customize and extend the package according to their needs. SciPy is performant as it acts as a thin wrapper around optimized code written in C/C++ or Fortran.</p>
    <p class="normal">The following are the main packages that are part of this ecosystem:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">NumPy</strong>: For <a id="_idIndexMarker022"/>algorithms, the ability to create <a id="_idIndexMarker023"/>multi-dimensional data structures, such as arrays and matrices, is really important. NumPy offers a set of array and matrix data types that are important for statistics and data analysis. Details about NumPy can be<a id="_idIndexMarker024"/> found at <a href="http://www.numpy.org/"><span class="url">http://www.numpy.org/</span></a>.</li>
      <li class="bulletList"><strong class="keyWord">scikit-learn</strong>: This <a id="_idIndexMarker025"/>machine learning extension is one of <a id="_idIndexMarker026"/>the most popular extensions of SciPy. Scikit-learn provides a wide range of important machine learning algorithms, including classification, regression, clustering, and model validation. You can find more<a id="_idIndexMarker027"/> details about scikit-learn at <a href="http://scikit-learn.org/"><span class="url">http://scikit-learn.org/</span></a>.</li>
      <li class="bulletList"><strong class="keyWord">pandas</strong>: pandas<a id="_idIndexMarker028"/> contains the tabular complex data structure <a id="_idIndexMarker029"/>that is used widely to input, output, and process tabular data in various algorithms. The pandas library contains many useful functions <a id="_idIndexMarker030"/>and it also offers highly optimized performance. More details about pandas can be found at <a href="http://pandas.pydata.org/"><span class="url">http://pandas.pydata.org/</span></a>.</li>
      <li class="bulletList"><strong class="keyWord">Matplotlib</strong>: Matplotlib <a id="_idIndexMarker031"/>provides tools to <a id="_idIndexMarker032"/>create powerful visualizations. Data can be presented as line plots, scatter plots, bar charts, histograms, pie charts, and so on. More <a id="_idIndexMarker033"/>information can be found at <a href="https://matplotlib.org/"><span class="url">https://matplotlib.org/</span></a>.</li>
    </ul>
    <h3 id="_idParaDest-21" class="heading-3">Using Jupyter Notebook</h3>
    <p class="normal">We will be using <a id="_idIndexMarker034"/>Jupyter Notebook and Google’s Colaboratory as the IDE. More details about the setup and the use of Jupyter Notebook and Colab can be found in <em class="italic">Appendix A</em> and <em class="italic">B</em>.</p>
    <h1 id="_idParaDest-22" class="heading-1">Algorithm design techniques</h1>
    <p class="normal">An algorithm<a id="_idIndexMarker035"/> is a mathematical solution to a real-world problem. When designing an algorithm, we keep the following three design concerns in mind as we work on designing and fine-tuning the algorithms:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Concern 1</strong>: Is this algorithm producing the result we expected?</li>
      <li class="bulletList"><strong class="keyWord">Concern 2</strong>: Is this the most optimal way to get these results?</li>
      <li class="bulletList"><strong class="keyWord">Concern 3</strong>: How is the algorithm going to perform on larger datasets?</li>
    </ul>
    <p class="normal">It is important to understand the complexity of the problem itself before designing a solution for it. For example, it helps us to design an appropriate solution if we characterize the problem in terms of its needs and complexity. </p>
    <p class="normal">Generally, the algorithms can be divided into the following types based on the characteristics of the problem:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Data-intensive algorithms</strong>: Data-intensive algorithms are designed to deal with a large amount of <a id="_idIndexMarker036"/>data. They are expected to have relatively simplistic processing requirements. A compression <a id="_idIndexMarker037"/>algorithm applied to a huge file is a good example of data-intensive algorithms. For such algorithms, the size of the data is expected to be much larger than the memory of the processing engine (a single node or cluster), and an iterative processing design may need to be developed to efficiently process the data according to the requirements.</li>
      <li class="bulletList"><strong class="keyWord">Compute-intensive algorithms</strong>: Compute-intensive algorithms have considerable processing requirements <a id="_idIndexMarker038"/>but do not<a id="_idIndexMarker039"/> involve large amounts of data. A simple example is the algorithm to find a very large prime number. Finding a strategy to divide the algorithm into different phases so that at least some of the phases are parallelized is key to maximizing the performance of the algorithm.</li>
      <li class="bulletList"><strong class="keyWord">Both data and compute-intensive algorithms</strong>: There are certain algorithms that deal with a large amount of data and also have considerable computing requirements. Algorithms used to perform sentiment analysis on live video feeds are a good example of where both the data and the processing requirements are huge in accomplishing the task. Such algorithms are the most resource-intensive algorithms and require careful design of the algorithm and intelligent allocation of available resources.</li>
    </ul>
    <p class="normal">To characterize the problem in terms of its complexity and needs, it helps if we study its data and compute dimensions in more depth, which we will do in the following section.</p>
    <h2 id="_idParaDest-23" class="heading-2">The data dimension</h2>
    <p class="normal">To categorize the <a id="_idIndexMarker040"/>data dimension of the problem, we look at its <strong class="keyWord">volume</strong>, <strong class="keyWord">velocity</strong>, and <strong class="keyWord">variety</strong> (the <strong class="keyWord">3Vs</strong>), which are defined as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Volume</strong>: The volume<a id="_idIndexMarker041"/> is the expected size of the data that the algorithm will process.</li>
      <li class="bulletList"><strong class="keyWord">Velocity</strong>: The velocity<a id="_idIndexMarker042"/> is the expected rate of new data generation when the algorithm is used. It can be zero.</li>
      <li class="bulletList"><strong class="keyWord">Variety</strong>: The variety<a id="_idIndexMarker043"/> quantifies how many different types of data the designed algorithm is expected to deal with.</li>
    </ul>
    <p class="normal"><em class="italic">Figure 1.2</em> shows the 3Vs of the data in more detail. The center of this diagram shows the simplest possible data, with a small volume and low variety and velocity. As we move away from the center, the complexity of the data increases. It can increase in one or more of the three dimensions. </p>
    <p class="normal">For example, in the dimension of velocity, we have the batch process as the simplest, followed by the periodic process, and then the near real-time process. Finally, we have the real-time process, which is the most complex to handle in the context of data velocity. For example, a collection of live video feeds gathered by a group of monitoring cameras will have a high volume, high velocity, and high variety and may need an appropriate design to have the ability to store and process data effectively:</p>
    <figure class="mediaobject"><img src="../Images/B18046_01_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.2: 3Vs of Data: Volume, Velocity, and Variety</p>
    <p class="normal">Let us consider <a id="_idIndexMarker044"/>three examples of use cases having three different types of data:</p>
    <ul>
      <li class="bulletList">First, consider a simple data-processing use case where the input data is a .<code class="inlineCode">csv</code> file. In this case, the volume, velocity, and variety of the data will be low.</li>
      <li class="bulletList">Second, consider the use case where the input data is the live stream of a security video camera. Now the volume, velocity, and variety of the data will be quite high and should be kept in mind while designing an algorithm for it.</li>
      <li class="bulletList">Third, consider the use case of a typical sensor network. Let us assume that the data source of the sensor network is a mesh of temperature sensors installed in a large building. Although the velocity of the data being generated is typically very high (as new data is being generated very quickly), the volume is expected to be quite low (as each data element is typically only 16-bits long consisting of an 8-bit measurement plus 8-bit metadata such as a timestamp and the geo-coordinates.</li>
    </ul>
    <p class="normal">The processing<a id="_idIndexMarker045"/> requirements, storage needs, and suitable software stack selection will be different for all the above three examples and, in general, are dependent on the volume, velocity, and variety of the data sources. It is important to first characterize data as the first step of designing an algorithm.</p>
    <h2 id="_idParaDest-24" class="heading-2">The compute dimension</h2>
    <p class="normal">To characterize the <a id="_idIndexMarker046"/>compute dimension, we analyze the processing needs of the problem at hand. The processing needs of an algorithm determine what sort of design is most efficient for it. For example, complex algorithms, in general, require lots of processing power. For such algorithms, it may be important to have multi-node parallel architecture. Modern deep algorithms usually involve considerable numeric processing and may need the power of GPUs or TUPs as discussed in <em class="chapterRef">Chapter 16</em>, <em class="italic">Practical Considerations</em>.</p>
    <h1 id="_idParaDest-25" class="heading-1">Performance analysis</h1>
    <p class="normal">Analyzing the performance of <a id="_idIndexMarker047"/>an algorithm is an important part of its design. One of the ways to estimate the performance of an algorithm is to analyze its complexity.</p>
    <p class="normal">Complexity theory<a id="_idIndexMarker048"/> is the study of how complicated algorithms are. To be useful, any algorithm should have three key features:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Should be correct</strong>: A good algorithm should produce the correct result. To confirm that an algorithm is working correctly, it needs to be extensively tested, especially testing edge cases.</li>
      <li class="bulletList"><strong class="keyWord">Should be understandable</strong>: A good algorithm should be understandable. The best algorithm in the world is not very useful if it’s too complicated for us to implement on a computer.</li>
      <li class="bulletList"><strong class="keyWord">Should be efficient</strong>: A good algorithm should be efficient. Even if an algorithm produces the correct result, it won’t help us much if it takes a thousand years or if it requires 1 billion terabytes of memory.</li>
    </ul>
    <p class="normal">There are two possible types of analysis to quantify the complexity of an algorithm:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Space complexity analysis</strong>: Estimates<a id="_idIndexMarker049"/> the runtime memory requirements needed to execute the algorithm.</li>
      <li class="bulletList"><strong class="keyWord">Time complexity analysis</strong>: Estimates<a id="_idIndexMarker050"/> the time the algorithm will take to run.</li>
    </ul>
    <p class="normal">Let us study them one by one:</p>
    <h2 id="_idParaDest-26" class="heading-2">Space complexity analysis</h2>
    <p class="normal">Space complexity analysis<a id="_idIndexMarker051"/> estimates the amount of memory required by the algorithm to process input data. While processing the input data, the algorithm needs to store the transient temporary data structures in memory. The way the algorithm is designed affects the number, type, and size of these data structures. In an age of distributed computing and with increasingly large amounts of data that needs to be processed, space complexity analysis is becoming more and more important. The size, type, and number of these data structures will dictate the memory requirements for the underlying hardware. Modern in-memory data structures used in distributed computing need to have efficient resource allocation mechanisms that are aware of the memory requirements at different execution phases of the algorithm. Complex algorithms tend to be iterative in nature. Instead of bringing all the information into the memory at once, such algorithms iteratively populate the data structures. To calculate the space complexity, it is important to first classify the type of iterative algorithm we plan to use. An iterative algorithm can use one of the following three types of iterations:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Converging Iterations</strong>: As the <a id="_idIndexMarker052"/>algorithm proceeds through iterations, the amount of data it processes in each individual iteration decreases. In other words, space complexity decreases as the algorithm proceeds through its iterations. The main challenge is to tackle the space complexity of the initial iterations. Modern scalable cloud infrastructures such as AWS and Google Cloud are best suited to run such algorithms.</li>
      <li class="bulletList"><strong class="keyWord">Diverging Iterations</strong>: As the <a id="_idIndexMarker053"/>algorithm proceeds through iterations, the amount of data it processes in each individual iteration increases. As the space complexity increases with the algorithm’s progress through iterations, it is important to set constraints to prevent the system from becoming unstable. The constraints can be set by limiting the number of iterations and/or by setting a limit on the size of initial data. </li>
      <li class="bulletList"><strong class="keyWord">Flat Iterations</strong>: As the <a id="_idIndexMarker054"/>algorithm proceeds through iterations, the amount of data it processes in each individual iteration remains constant. As space complexity does not change, elasticity in infrastructure is not needed.</li>
    </ul>
    <p class="normal">To calculate the space complexity, we need to focus on one of the most complex iterations. In many algorithms, as we converge towards the solution, the resource needs are gradually reduced. In such cases, initial iterations are the most complex and give us a better estimate of space complexity. Once chosen, we estimate the total amount of memory used by the algorithm, including the memory used by its transient data structures, execution, and input values. This will give us a good estimate of the space complexity of an algorithm.</p>
    <p class="normal">The following are <a id="_idIndexMarker055"/>guidelines to minimize the space complexity:</p>
    <ul>
      <li class="bulletList">Whenever possible, try to design an algorithm as iterative.</li>
      <li class="bulletList">While designing an iterative algorithm, whenever there is a choice, prefer a larger number of iterations over a smaller number of iterations. A fine-grained larger number of iterations is expected to have less space complexity.</li>
      <li class="bulletList">Algorithms should bring only the information needed for current processing into memory. Whatever is not needed should be flushed out from the memory.</li>
    </ul>
    <p class="normal">Space complexity analysis is a must for the efficient design of algorithms. If proper space complexity analysis is not conducted while designing a particular algorithm, insufficient memory availability for the transient temporary data structures may trigger unnecessary disk spillovers, which could potentially considerably affect the performance and efficiency of the algorithm.</p>
    <p class="normal">In this chapter, we will look deeper into time complexity. Space complexity will be discussed in <em class="chapterRef">Chapter 15</em>, <em class="italic">Large-Scale Algorithms</em>, in more detail, where we will deal with large-scale distributed algorithms with complex runtime memory requirements.</p>
    <h2 id="_idParaDest-27" class="heading-2">Time complexity analysis</h2>
    <p class="normal">Time complexity analysis<a id="_idIndexMarker056"/> estimates how long it will take for an algorithm to complete its assigned job based on its structure. In contrast to space complexity, time complexity is not dependent on any hardware that the algorithm will run on. Time complexity analysis solely depends on the structure of the algorithm itself. The overall goal of time complexity analysis is to try to answer these important two questions:</p>
    <ul>
      <li class="bulletList">Will this algorithm scale? A well-designed algorithm should be fully capable of taking advantage of the modern elastic infrastructure available in cloud computing environments. An algorithm should be designed in a way such that it can utilize the availability of more CPUs, processing cores, GPUs, and memory. For example, an algorithm used for training a model in a machine learning problem should be able to use distributed training as more CPUs are available. </li>
    </ul>
    <p class="bulletList">Such algorithms should also take advantage of GPUs and additional memory if made available during the execution of the algorithm.</p>
    <ul>
      <li class="bulletList">How well will this algorithm handle larger datasets?</li>
    </ul>
    <p class="normal">To answer these questions, we need to determine the effect on the performance of an algorithm as the size of the data is increased and make sure that the algorithm is designed in a way that not only makes it accurate but also scales well. The performance of an algorithm is becoming more and more important for larger datasets in today’s world of “big data.”</p>
    <p class="normal">In many cases, we may have more than one approach available to design the algorithm. The goal of conducting time complexity analysis, in this case, will be as follows:</p>
    <p class="normal"><em class="italic">“Given a certain problem and more than one algorithm, which one is the most efficient to use in terms of time efficiency?”</em></p>
    <p class="normal">There can be two basic <a id="_idIndexMarker057"/>approaches to calculating the time complexity of an algorithm:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">A post-implementation profiling approach</strong>: In this approach, different candidate algorithms are implemented, and their performance is compared.</li>
      <li class="bulletList"><strong class="keyWord">A pre-implementation theoretical approach</strong>: In this approach, the performance of each algorithm is approximated mathematically before running an algorithm.</li>
    </ul>
    <p class="normal">The advantage of the<a id="_idIndexMarker058"/> theoretical approach is that it only depends on the structure of the algorithm itself. It does not depend on the actual hardware that will be used to run the algorithm, the choice of the software stack chosen at runtime, or the programming language used to implement the algorithm.</p>
    <h2 id="_idParaDest-28" class="heading-2">Estimating the performance</h2>
    <p class="normal">The performance of a typical algorithm<a id="_idIndexMarker059"/> will depend on the type of data given to it as an input. For example, if the data is already sorted according to the context of the problem we are trying to solve, the algorithm may perform blazingly fast. If the sorted input is used to benchmark this particular algorithm, then it will give an unrealistically good performance number, which will not be a true reflection of its real performance in most scenarios. To handle this dependency of algorithms on the input data, we have different types of cases to consider when conducting a performance analysis.</p>
    <h3 id="_idParaDest-29" class="heading-3">The best case</h3>
    <p class="normal">In the best case, the<a id="_idIndexMarker060"/> data given as input is organized in a way that the algorithm will give its best performance. Best-case analysis gives the upper bound of the performance.</p>
    <h3 id="_idParaDest-30" class="heading-3">The worst case</h3>
    <p class="normal">The second way to estimate the <a id="_idIndexMarker061"/>performance of an algorithm is to try to find the maximum possible time it will take to get the job done under a given set of conditions. This worst-case analysis of an algorithm is quite useful as we are guaranteeing that regardless of the conditions, the performance of the algorithm will always be better than the numbers that come out of our analysis. Worst-case analysis is especially useful for estimating the performance when dealing with complex problems with larger datasets. Worst-case analysis gives the lower bound of the performance of the algorithm.</p>
    <h3 id="_idParaDest-31" class="heading-3">The average case</h3>
    <p class="normal">This starts by dividing the various<a id="_idIndexMarker062"/> possible inputs into various groups. Then, it conducts the performance analysis from one of the representative inputs from each group. Finally, it calculates the average of the performance of each of the groups.</p>
    <p class="normal">Average-case analysis <a id="_idIndexMarker063"/>is not always accurate as it needs to consider all the different combinations and possibilities of input to the algorithm, which is not always easy to do.</p>
    <h2 id="_idParaDest-32" class="heading-2">Big O notation</h2>
    <p class="normal">Big O notation <a id="_idIndexMarker064"/>was first introduced by Bachmann in 1894 in a research paper to approximate an algorithm’s growth. He wrote:</p>
    <p class="normal">“… with the symbol <em class="italic">O(n)</em> we express a magnitude whose order in respect to <em class="italic">n</em> does not exceed the order of <em class="italic">n</em>” (Bachmann 1894, p. 401).</p>
    <p class="normal">Big-O notation provides a way to describe the long-term growth rate of an algorithm’s performance. In simpler terms, it tells us how the runtime of an algorithm increases as the input size grows. Let’s break it down with the help of two functions, <em class="italic">f(n)</em> and <em class="italic">g(n)</em>. If we say <em class="italic">f </em>=<em class="italic"> O(g)</em>, what we mean is that as n approaches infinity, the ratio <img src="../Images/B18046_01_001.png" alt="" role="presentation"/> stays limited or bounded. In other words, no matter how large our input gets, <em class="italic">f(n)</em> will not grow disproportionately faster than <em class="italic">g(n)</em>.</p>
    <p class="normal">Let’s look at particular functions:</p>
    <p class="center"><em class="italic">f(n)</em> = 1000<em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">2</sup> + 100<em class="italic">n</em> + 10</p>
    <p class="normal">and</p>
    <p class="center"><em class="italic">g(n)</em> = <em class="italic">n</em><sup class="superscript">2</sup></p>
    <p class="normal">Note that both functions will approach infinity as <em class="italic">n</em> approaches infinity. Let’s ﬁnd out if <em class="italic">f</em> = <em class="italic">O(g)</em> by applying the deﬁnition.</p>
    <p class="normal">First, let us calculate <img src="../Images/B18046_01_002.png" alt="" role="presentation"/>,</p>
    <p class="normal">which will be equal to <img src="../Images/B18046_01_003.png" alt="" role="presentation"/> = <img src="../Images/B18046_01_004.png" alt="" role="presentation"/> = (1000 + <img src="../Images/B18046_01_005.png" alt="" role="presentation"/>).</p>
    <p class="normal">It is clear that <img src="../Images/B18046_01_003.png" alt="" role="presentation"/> is bounded and will not approach infinity as <em class="italic">n</em> approaches infinity.</p>
    <p class="normal">Thus <em class="italic">f(n)</em> = <em class="italic">O(g)</em> = <em class="italic">O(n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">)</em>.</p>
    <p class="normal"><em class="italic">(n</em><sup class="superscript">2</sup><em class="italic">)</em> represents that the complexity of this function increases as the square of input <em class="italic">n</em>. If we double the number of input elements, the complexity is expected to increase by 4.</p>
    <p class="normal">Note the following 4 rules when dealing with Big-O notation.</p>
    <p class="normal"><strong class="keyWord">Rule 1</strong>:</p>
    <p class="normal">Let us look into the complexity of loops in algorithms. If an algorithm performs a certain sequence of steps <em class="italic">n</em> times, then it has <em class="italic">O(n)</em> performance.</p>
    <p class="normal"><strong class="keyWord">Rule 2</strong>:</p>
    <p class="normal">Let us look into the nested loops of the algorithms. If an algorithm performs a function that has a loop of <em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">1</sup> steps, and for each loop it performs another <em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">2</sup> steps, the algorithm’s total performance is <em class="italic">O(n</em><sup class="superscript-italic" style="font-style: italic;">1</sup><em class="italic"> × n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">)</em>.</p>
    <p class="normal">For example, if an algorithm has both outer and inner loops having <em class="italic">n</em> steps, then the complexity of the algorithm will be represented by:</p>
    <p class="normal"><em class="italic">O(n*n)</em> = <em class="italic">O(n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">)</em></p>
    <p class="normal"><strong class="keyWord">Rule 3</strong>:</p>
    <p class="normal">If an algorithm <a id="_idIndexMarker065"/>performs a function <em class="italic">f(n)</em> that takes <em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">1</sup> steps and then performs another function <em class="italic">g(n)</em> that takes <em class="italic">n</em><sup class="superscript">2</sup> steps, the algorithm’s total performance is <em class="italic">O(f(n)+g(n))</em>.</p>
    <p class="normal"><strong class="keyWord">Rule 4</strong>:</p>
    <p class="normal">If an algorithm takes <em class="italic">O(g(n) + h(n))</em> and the function <em class="italic">g(n)</em> is greater than <em class="italic">h(n)</em> for large <em class="italic">n</em>, the algorithm’s performance can be simplified to <em class="italic">O(g(n))</em>.</p>
    <p class="normal">It means that <em class="italic">O(1+n)</em> = <em class="italic">O(n)</em>.</p>
    <p class="normal">And <em class="italic">O(n</em><sup class="superscript">2</sup><em class="italic">+ n</em><sup class="superscript">3</sup><em class="italic">)</em> = <em class="italic">O(n</em><sup class="superscript">2</sup><em class="italic">)</em>.</p>
    <p class="normal"><strong class="keyWord">Rule 5</strong>:</p>
    <p class="normal">When calculating the complexity of an algorithm, ignore constant multiples. If <em class="italic">k</em> is a constant, <em class="italic">O(kf(n))</em> is the same as <em class="italic">O(f(n))</em>.</p>
    <p class="normal">Also, <em class="italic">O(f(k × n))</em> is the same as <em class="italic">O(f(n))</em>.</p>
    <p class="normal">Thus <em class="italic">O(5n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">)</em> = <em class="italic">O(n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">).</em></p>
    <p class="normal">And <em class="italic">O((3n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">))</em> = <em class="italic">O(n</em><sup class="superscript-italic" style="font-style: italic;">2</sup><em class="italic">).</em></p>
    <p class="normal">Note that:</p>
    <ul>
      <li class="bulletList">The complexity quantified by Big O notation is only an estimate.</li>
      <li class="bulletList">For smaller sizes of data, we do not care about the time complexity. <em class="italic">n</em><sup class="superscript">0</sup> in the graph defines the threshold above which we are interested in finding the time complexity. The shaded area describes this area of interest where we will analyze the time complexity.</li>
      <li class="bulletList"><em class="italic">T(n)</em> time complexity is more than the original function. A good choice of <em class="italic">T(n)</em> will try to create a tight upper bound for <em class="italic">F(n)</em>.</li>
    </ul>
    <p class="normal">The following table<a id="_idIndexMarker066"/> summarizes the different kinds of Big O notation types discussed in this section:</p>
    <table id="table001" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Complexity Class</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Name</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Example Operations</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(1)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Constant</p>
          </td>
          <td class="table-cell">
            <p class="normal">Append, get item, set item.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(logn)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Logarithmic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Finding an element in a sorted array.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Linear</p>
          </td>
          <td class="table-cell">
            <p class="normal">Copy, insert, delete, iteration</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n</code><sup class="superscript">2</sup><code class="inlineCode">)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Quadratic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Nested loops</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h2 id="_idParaDest-33" class="heading-2">Constant time (O(1)) complexity</h2>
    <p class="normal">If an algorithm takes the same <a id="_idIndexMarker067"/>amount of time to run, independent of the size of the input data, it is said to run in constant time. It is represented by <em class="italic">O(1)</em>. Let’s take the example of accessing the <em class="italic">n</em><sup class="superscript">th</sup> element of an array. Regardless of the size of the array, it will take constant time to get the results. For example, the following function will return the first element of the array and has a complexity of <em class="italic">O(1)</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">get_first</span>(<span class="hljs-params">my_list</span>):
    <span class="hljs-keyword">return</span> my_list[<span class="hljs-number">0</span>]
get_first([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">1
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">get_first([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">1
</code></pre>
    <p class="normal">Note that:</p>
    <ul>
      <li class="bulletList">The addition of a new element to a stack is done by using <code class="inlineCode">push</code> and removing an element from a stack is done by using <code class="inlineCode">pop</code>. Regardless of the size of the stack, it will take the same time to add or remove an element.</li>
      <li class="bulletList">When <a id="_idIndexMarker068"/>accessing the element of the hashtable, note that it is a data structure that stores data in an associative format, usually as key-value pairs.</li>
    </ul>
    <h2 id="_idParaDest-34" class="heading-2">Linear time (O(n)) complexity</h2>
    <p class="normal">An algorithm is said to <a id="_idIndexMarker069"/>have a complexity of linear time, represented by <em class="italic">O(n)</em>, if the execution time is directly proportional to the size of the input. A simple example is to add the elements in a single-dimensional data structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sum</span>(<span class="hljs-params">my_list</span>):
    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:
        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + item
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>
</code></pre>
    <p class="normal">Note the main loop of the algorithm. The number of iterations in the main loop increases linearly with an increasing value of <em class="italic">n</em>, producing an <em class="italic">O(n)</em> complexity in the following figure:</p>
    <pre class="programlisting code"><code class="hljs-code">get_sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">6
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">get_sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">10
</code></pre>
    <p class="normal">Some other examples of array operations are as follows:</p>
    <ul>
      <li class="bulletList">Searching an element</li>
      <li class="bulletList">Finding the minimum value among all the elements of an array</li>
    </ul>
    <h2 id="_idParaDest-35" class="heading-2">Quadratic time (O(n2)) complexity</h2>
    <p class="normal">An algorithm is said to<a id="_idIndexMarker070"/> run in quadratic time if the execution time of an algorithm is proportional to the square of the input size; for example, a simple function that sums up a two-dimensional array, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sum</span>(<span class="hljs-params">my_list</span>):
    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> my_list:
        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> row:
            <span class="hljs-built_in">sum</span> += item
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>
</code></pre>
    <p class="normal">Note the nested inner loop within the other main loop. This nested loop gives the preceding code the complexity of <em class="italic">O(n</em><sup class="superscript">2</sup><em class="italic">)</em>:</p>
    <pre class="programlisting code"><code class="hljs-code">get_sum([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">10
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">get_sum([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">21
</code></pre>
    <p class="normal">Another<a id="_idIndexMarker071"/> example is the <em class="italic">bubble sort algorithm</em> (which will be discussed in <em class="chapterRef">Chapter 2</em>, <em class="italic">Data Structures Used in Algorithms</em>).</p>
    <h2 id="_idParaDest-36" class="heading-2">Logarithmic time (O(logn)) complexity</h2>
    <p class="normal">An algorithm is<a id="_idIndexMarker072"/> said to run in logarithmic time if the execution time of the algorithm is proportional to the logarithm of the input size. With each iteration, the input size decreases by constant multiple factors. An example of a logarithmic algorithm is binary search. The binary search algorithm is used to find a particular element in a one-dimensional data structure, such as a Python list. The elements within the data structure need to be sorted in descending order. The binary search algorithm is implemented in a function named <code class="inlineCode">search_binary</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">search_binary</span>(<span class="hljs-params">my_list, item</span>):
    first = <span class="hljs-number">0</span>
    last = <span class="hljs-built_in">len</span>(my_list)-<span class="hljs-number">1</span>
    found_flag = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">while</span>(first &lt;= last <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> found_flag):
        mid = (first + last)//<span class="hljs-number">2</span>
        <span class="hljs-keyword">if</span> my_list[mid] == item:
            found_flag = <span class="hljs-literal">True</span>           
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> item &lt; my_list[mid]:
                last = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                first = mid + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> found_flag
<span class="hljs-title">searchBinary</span>([<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">3000</span>], <span class="hljs-number">10</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">True
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">searchBinary</span>([<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">3000</span>], <span class="hljs-number">5</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">False
</code></pre>
    <p class="normal">The main loop takes advantage of the fact that the list is ordered. It divides the list in half with each iteration until it gets to the result.</p>
    <p class="normal">After defining the function, it is tested to search a particular element in lines <code class="inlineCode">11</code> and <code class="inlineCode">12</code>. The binary search algorithm is further discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Sorting and Searching Algorithms</em>.</p>
    <p class="normal">Note that among the four types of Big O notation types presented, <em class="italic">O(n</em><sup class="superscript">2</sup><em class="italic">)</em> has the worst performance and <em class="italic">O(logn)</em> has the best performance. On the other hand, <em class="italic">O(n</em><sup class="superscript">2</sup><em class="italic">)</em> is not as bad as <em class="italic">O(n</em><sup class="superscript">3</sup><em class="italic">)</em>, but still, algorithms that fall in this class cannot be used on big data as the time complexity puts limitations on how much data they can realistically process. The performance of four types of Big O notations is shown in <em class="italic">Figure 1.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_01_03.png" alt="Chart, line chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.3: Big O complexity chart</p>
    <p class="normal">One way to <a id="_idIndexMarker073"/>reduce the complexity of an algorithm is to compromise on its<a id="_idIndexMarker074"/> accuracy, producing a type of algorithm called an <strong class="keyWord">approximate algorithm</strong>.</p>
    <h1 id="_idParaDest-37" class="heading-1">Selecting an algorithm</h1>
    <p class="normal">How do you know which one is a <a id="_idIndexMarker075"/>better solution? How do you know which algorithm runs faster? Analyzing the time complexity of an algorithm may answer these types of questions.</p>
    <p class="normal">To see where it can be useful, let’s take a simple example where the objective is to sort a list of numbers. There are a bunch of algorithms readily available that can do the job. The issue is how to choose the right one.</p>
    <p class="normal">First, an observation that can be made is that if there are not too many numbers in the list, then it does not matter which algorithm we choose to sort the list of numbers. So, if there are only 10 numbers in the list (<em class="italic">n=10</em>), then it does not matter which algorithm we choose as it would probably not take more than a few microseconds, even with a very simple algorithm. But as <em class="italic">n</em> increases, the choice of the right algorithm starts to make a difference. A poorly designed algorithm may take a couple of hours to run, while a well-designed algorithm may finish sorting the list in a couple of seconds. So, for larger input datasets, it makes a lot of sense to invest time and effort, perform a performance analysis, and choose the correctly designed algorithm that will do the job required in an efficient manner.</p>
    <h1 id="_idParaDest-38" class="heading-1">Validating an algorithm</h1>
    <p class="normal">Validating <a id="_idIndexMarker076"/>an algorithm confirms that it is actually providing a mathematical solution to the problem we are trying to solve. A validation process should check the results for as many possible values and types of input values as possible.</p>
    <h2 id="_idParaDest-39" class="heading-2">Exact, approximate, and randomized algorithms</h2>
    <p class="normal">Validating an algorithm also depends on the type of the algorithm as the testing techniques are different. Let’s first differentiate between deterministic and randomized algorithms.</p>
    <p class="normal">For deterministic algorithms, a<a id="_idIndexMarker077"/> particular input always generates<a id="_idIndexMarker078"/> exactly the same<a id="_idIndexMarker079"/> output. But for certain classes of algorithms, a<a id="_idIndexMarker080"/> sequence of random numbers is also taken as input, which makes the output different each time the algorithm is run. The k-means clustering algorithm, which is detailed in <em class="chapterRef">Chapter 6</em>, <em class="italic">Unsupervised Machine Learning Algorithms</em>, is an example of such an algorithm:</p>
    <figure class="mediaobject"><img src="../Images/B18046_01_04.png" alt="Waterfall chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.4: Deterministic and Randomized Algorithms</p>
    <p class="normal">Algorithms can also be divided into the following two types based on assumptions or approximation used to simplify the logic to make them run faster:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">An exact algorithm</strong>: Exact algorithms<a id="_idIndexMarker081"/> are expected to produce a precise<a id="_idIndexMarker082"/> solution without introducing any assumptions or approximations.</li>
      <li class="bulletList"><strong class="keyWord">An approximate algorithm</strong>: When the<a id="_idIndexMarker083"/> problem complexity is too much to handle for the given resources, we simplify our <a id="_idIndexMarker084"/>problem by making some assumptions. The algorithms based on these simplifications or assumptions are called approximate algorithms, which don’t quite give us the precise solution.</li>
    </ul>
    <p class="normal">Let’s look at an example to understand the difference between exact and approximate algorithms—the famous traveling salesman problem, which was presented in 1930. Traveling salesman challenges you to find the shortest route for a particular salesman that visits each city (from a list of cities) and then returns to the origin, which is why he is named the traveling salesman. The first attempt to provide the solution will include generating all the permutations of cities and choosing the combination of cities that is cheapest. It is obvious that time complexity starts to become unmanageable beyond 30 cities.</p>
    <p class="normal">If the number of cities is more than 30, one way of reducing the complexity is to introduce some approximations and assumptions.</p>
    <p class="normal">For approximate algorithms, it is important to set the expectations for accuracy when gathering the requirements. Validating an approximation algorithm is about verifying that the error of the results is within an acceptable range.</p>
    <h2 id="_idParaDest-40" class="heading-2">Explainability</h2>
    <p class="normal">When algorithms are used for critical cases, it becomes important to have the ability to explain the reason behind each and every result whenever needed. This is necessary to make sure that decisions based on the results of the algorithms do not introduce bias.</p>
    <p class="normal">The ability to exactly identify the features that are used directly or indirectly to come up with a particular<a id="_idIndexMarker085"/> decision is called the <strong class="keyWord">explainability</strong> of an algorithm. Algorithms, when<a id="_idIndexMarker086"/> used for critical use cases, need to be evaluated for bias and prejudice. The ethical analysis of algorithms has become a standard part of the validation process for those algorithms that can affect decision-making that relates to the lives of people.</p>
    <p class="normal">For algorithms that deal with deep learning, explainability is difficult to achieve. For example, if an algorithm is used to refuse the mortgage application of a person, it is important to have the transparency and ability to explain the reason.</p>
    <p class="normal">Algorithmic explainability is an active area of research. One of the effective techniques that have been recently developed<a id="_idIndexMarker087"/> is <strong class="keyWord">Local Interpretable Model-Agnostic Explanations </strong>(<strong class="keyWord">LIME</strong>), as proposed in the proceedings<a id="_idIndexMarker088"/> of the 22<sup class="superscript">nd</sup> <strong class="keyWord">Association for Computing Machinery </strong>(<strong class="keyWord">ACM</strong>) at the <strong class="keyWord">Special Interest Group on Knowledge Discovery and Data Mining </strong>(<strong class="keyWord">SIGKDD</strong>) international<a id="_idIndexMarker089"/> conference on knowledge discovery and data mining in 2016. LIME is based on a concept where small changes are introduced to the input for each instance and then an effort to map the local decision boundary for that instance is made. It can then quantify the influence of each variable for that instance.</p>
    <h1 id="_idParaDest-41" class="heading-1">Summary</h1>
    <p class="normal">This chapter was about learning the basics of algorithms. First, we learned about the different phases of developing an algorithm. We discussed the different ways of specifying the logic of an algorithm that are necessary for designing it. Then, we looked at how to design an algorithm. We learned two different ways of analyzing the performance of an algorithm. Finally, we studied different aspects of validating an algorithm.</p>
    <p class="normal">After going through this chapter, we should be able to understand the pseudocode of an algorithm. We should understand the different phases in developing and deploying an algorithm. We also learned how to use Big O notation to evaluate the performance of an algorithm.</p>
    <p class="normal">The next chapter is about the data structures used in algorithms. We will start by looking at the data structures available in Python. We will then look at how we can use these data structures to create more sophisticated data structures, such as stacks, queues, and trees, which are needed to develop complex algorithms.</p>
    <h1 id="_idParaDest-42" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>