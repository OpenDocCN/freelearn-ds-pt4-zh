<html><head></head><body>
  <div id="_idContainer040" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-43" class="chapterTitle">Data Structures Used in Algorithms</h1>
    <p class="normal">Algorithms need in-memory data structures that can hold temporary data while executing. Choosing the right data structures is essential for their efficient implementation. Certain classes of algorithms are recursive or iterative in logic and need data structures that are specially designed for them. For example, a recursive algorithm may be more easily implemented, exhibiting better performance, if nested data structures are used. In this chapter, data structures are discussed in the context of algorithms. As we are using Python in this book, this chapter focuses on Python data structures, but the concepts presented in this chapter can be used in other languages such as Java and C++.</p>
    <p class="normal">By the end of this chapter, you should be able to understand how Python handles complex data structures and which one should be used for a certain type of data.</p>
    <p class="normal">Here are the main points discussed in this chapter:</p>
    <ul>
      <li class="bulletList">Exploring Python built-in data types</li>
      <li class="bulletList">Using Series and DataFrames</li>
      <li class="bulletList">Exploring matrices and matrix operations</li>
      <li class="bulletList">Understanding abstract data types</li>
    </ul>
    <h1 id="_idParaDest-44" class="heading-1">Exploring Python built-in data types</h1>
    <p class="normal">In any language, data<a id="_idIndexMarker090"/> structures are used to store and manipulate complex data. In Python, data structures are storage containers for managing, organizing, and searching data in an efficient way. They are used to store a group of data elements called collections that need to be stored and processed together. In Python, the important data structures that can be used to store collections are summarized in <em class="italic">Table 2.1</em>:</p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Data Structure</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Brief Explanation</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Example</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">List</p>
          </td>
          <td class="table-cell">
            <p class="normal">An ordered, possibly nested, mutable sequence of elements</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">["John", 33,"Toronto", True]</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Tuple</p>
          </td>
          <td class="table-cell">
            <p class="normal">An ordered immutable sequence of elements</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">('Red','Green','Blue','Yellow')</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Dictionary</p>
          </td>
          <td class="table-cell">
            <p class="normal">An unordered collection of key-value pairs</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">{'brand': 'Apple', 'color': 'black'}</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Set</p>
          </td>
          <td class="table-cell">
            <p class="normal">An unordered collection of elements</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">{'a', 'b', 'c'}</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 2.1: Python Data Structures</p>
    <p class="normal">Let us look <a id="_idIndexMarker091"/>into them in more detail in the upcoming subsections.</p>
    <h2 id="_idParaDest-45" class="heading-2">Lists</h2>
    <p class="normal">In Python, a list <a id="_idIndexMarker092"/>is the<a id="_idIndexMarker093"/> main data type used to store a mutable sequence of elements. The sequence of elements stored in the list need not be of the same type.</p>
    <p class="normal">A list can be defined by enclosing the elements in <code class="inlineCode">[ ]</code> and they need to be separated by a comma. For example, the following code creates four data elements together that are of different types:</p>
    <pre class="programlisting code"><code class="hljs-code">list_a = [<span class="hljs-string">"John"</span>, <span class="hljs-number">33</span>,<span class="hljs-string">"Toronto"</span>, <span class="hljs-literal">True</span>]
<span class="hljs-built_in">print</span>(list_a)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">['John', 33, 'Toronto', True]
</code></pre>
    <p class="normal">In Python, a list is a handy way of creating one-dimensional writable data structures, which are especially needed at different internal stages of algorithms.</p>
    <h3 id="_idParaDest-46" class="heading-3">Using lists</h3>
    <p class="normal">Utility functions in data<a id="_idIndexMarker094"/> structures make them very<a id="_idIndexMarker095"/> useful as they can be used to manage data in lists.</p>
    <p class="normal">Let’s look into how we can use them:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">List indexing</strong>: As the<a id="_idIndexMarker096"/> position of an element is deterministic in a list, the index can be used to get an element at a particular position. The following code demonstrates the concept:
        <pre class="programlisting code"><code class="hljs-code">bin_colors=[<span class="hljs-string">'Red'</span>,<span class="hljs-string">'Green'</span>,<span class="hljs-string">'</span><span class="hljs-string">Blue'</span>,<span class="hljs-string">'Yellow'</span>]
</code></pre>
      
    <p class="normal">The four-element list created by this code is shown in <em class="italic">Figure 2.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_02_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.1: A four-element list in Python</p>
    <p class="normal">Now, we will run the code:</p>
    <pre class="programlisting code"><code class="hljs-code">bin_colors[<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">'Green'
</code></pre>
    <p class="normal">Note that Python is a zero-indexing language. This means that the initial index of any<a id="_idIndexMarker097"/> data structure, including lists, will be <code class="inlineCode">0</code>. <code class="inlineCode">Green</code>, which is the second element, is retrieved by index <code class="inlineCode">1</code> – that is, <code class="inlineCode">bin_colors[1]</code>.</p>
    </li>
    </ul>
	<ul>
      <li class="bulletList"><strong class="keyWord">List slicing</strong>: Retrieving a<a id="_idIndexMarker098"/> subset of the elements of a list by specifying a range of indexes is called <strong class="keyWord">slicing</strong>. The following code can be used to create a slice of the list:
        <pre class="programlisting code"><code class="hljs-code">bin_colors[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">['Red', 'Green'] 
</code></pre>
      
    <p class="normal">Note that lists are one of the most popular single-dimensional data structures in Python.</p>
    <div class="note">
      <p class="normal">While slicing a list, the range is indicated as follows: the first number (inclusive) and the second number (exclusive). For example, <code class="inlineCode">bin_colors[0:2]</code> will include <code class="inlineCode">bin_color[0]</code> and <code class="inlineCode">bin_color[1]</code> but not <code class="inlineCode">bin_color[2]</code>. While using lists, this should be kept in mind, as some users of the Python language complain that this is not very intuitive.</p>
    </div>
    <p class="normal">Let’s have a look at the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">bin_colors=[<span class="hljs-string">'Red'</span>,<span class="hljs-string">'Green'</span>,<span class="hljs-string">'Blue'</span>,<span class="hljs-string">'Yellow'</span>]
bin_colors[<span class="hljs-number">2</span>:]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">['Blue', 'Yellow']
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">bin_colors[:<span class="hljs-number">2</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">['Red', 'Green']
</code></pre>
    <p class="normal">If the starting index is <a id="_idIndexMarker099"/>not specified, it means the beginning of the list, and if the ending index is not specified, it means the end of the list, as demonstrated by the preceding code.</p>
    </li>
    </ul>
	<ul>
      <li class="bulletList"><strong class="keyWord">Negative indexing</strong>: In Python, we<a id="_idIndexMarker100"/> also have negative indices, which count from the end of the list. This is demonstrated in the following code:
        <pre class="programlisting code"><code class="hljs-code">bin_colors=[<span class="hljs-string">'Red'</span>,<span class="hljs-string">'Green'</span>,<span class="hljs-string">'Blue'</span>,<span class="hljs-string">'Yellow'</span>]
bin_colors[:<span class="hljs-number">-1</span>]
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">['Red', 'Green', 'Blue']
</code></pre>
        <pre class="programlisting code"><code class="hljs-code">bin_colors[:<span class="hljs-number">-2</span>]
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">['Red', 'Green']
</code></pre>
        <pre class="programlisting code"><code class="hljs-code">bin_colors[<span class="hljs-number">-2</span>:<span class="hljs-number">-1</span>]
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">['Blue']
</code></pre>
      
    <p class="normal">Note that negative indices are especially useful when we want to use the last element as a reference point instead of the first one.</p>
    </li>
    </ul>
	<ul>
      <li class="bulletList"><strong class="keyWord">Nesting</strong>: An element <a id="_idIndexMarker101"/>of a list can be of any data type. This allows nesting in lists. For iterative and recursive algorithms, this provides important capabilities.
    <p class="normal">Let’s have a look at the following code, which is an example of a list within a list (nesting):</p>
    <pre class="programlisting code"><code class="hljs-code">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>],6]
<span class="hljs-built_in">max</span>(a[<span class="hljs-number">2</span>])
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">300
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">200
</code></pre></li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Iteration</strong>: Python allows <a id="_idIndexMarker102"/>iterating over each element on a list by using a <code class="inlineCode">for</code> loop. This is demonstrated in the following example:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> color_a <span class="hljs-keyword">in</span> bin_colors:
    <span class="hljs-built_in">print</span>(color_a + <span class="hljs-string">" Square"</span>)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Red Square 
Green Square 
Blue Square 
Yellow Square
</code></pre>
      </li>
    </ul>
    <p class="normal">Note that the preceding code iterates through the list and prints each element. Now let us remove the last element from the stack using <code class="inlineCode">pop()</code> function.</p>
    <h3 id="_idParaDest-47" class="heading-3">Modifying lists: append and pop operations</h3>
    <p class="normal">Let’s take a <a id="_idIndexMarker103"/>look at <a id="_idIndexMarker104"/>modifying some lists, including the append and pop operations.</p>
    <h4 class="heading-4">Adding elements with append()</h4>
    <p class="normal">When you <a id="_idIndexMarker105"/>want to insert a <a id="_idIndexMarker106"/>new item at the end of a list, you employ the <code class="inlineCode">append()</code> method. It works by adding the new element to the nearest available memory slot. If the list is already at full capacity, Python extends the memory allocation, replicates the previous items in this newly carved out space, and then slots in the new addition:</p>
    <pre class="programlisting code"><code class="hljs-code">bin_colors = [<span class="hljs-string">'Red'</span>,<span class="hljs-string"> 'Green'</span>,<span class="hljs-string"> 'Blue'</span>,<span class="hljs-string"> 'Yellow'</span>]
bin_colors.append('<span class="hljs-string">Purple</span>')
<span class="hljs-built_in">print</span>(bin_colors)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">['Red', 'Green', 'Blue', 'Yellow', 'Purple']
</code></pre>
    <h4 class="heading-4">Removing elements with pop()</h4>
    <p class="normal">To extract an <a id="_idIndexMarker107"/>element <a id="_idIndexMarker108"/>from the list, particularly the last one, the <code class="inlineCode">pop()</code> method is a handy tool. When invoked, this method extracts the specified item (or the last item if no index is given). The elements <a id="_idIndexMarker109"/>situated after the popped item get repositioned to <a id="_idIndexMarker110"/>maintain memory continuity:</p>
    <pre class="programlisting code"><code class="hljs-code">bin_colors.pop()
<span class="hljs-built_in">print</span>(bin_colors)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">['Red', 'Green', 'Blue', 'Yellow']
</code></pre>
    <h3 id="_idParaDest-48" class="heading-3">The range() function</h3>
    <p class="normal">The <code class="inlineCode">range()</code> function <a id="_idIndexMarker111"/>can be used to easily generate <a id="_idIndexMarker112"/>a large list of numbers. It is used to auto-populate sequences of numbers in a list.</p>
    <p class="normal">The <code class="inlineCode">range()</code> function is simple to use. We can use it by just specifying the number of elements we want in the list. By default, it starts from zero and increments by one:</p>
    <pre class="programlisting code"><code class="hljs-code">x = <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> x:
  <span class="hljs-built_in">print</span>(n)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">0 1 2 3
</code></pre>
    <p class="normal">We can also specify the end number and the step:</p>
    <pre class="programlisting code"><code class="hljs-code">odd_num = <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>,<span class="hljs-number">2</span>)
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> odd_num:
  <span class="hljs-built_in">print</span>(n)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">3 5 7 9 11 13 15 17 19 21 23 25 27 29
</code></pre>
    <p class="normal">The preceding range function will give us odd numbers from <code class="inlineCode">3</code> to <code class="inlineCode">29</code>.</p>
    <p class="normal">To iterate through a list, we can use the <code class="inlineCode">for</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> odd_num:
    <span class="hljs-built_in">print</span>(i*<span class="hljs-number">100</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">300 500 700 900 1100 1300 1500 1700 1900 2100 2300 2500 2700 2900
</code></pre>
    <p class="normal">We can use the <code class="inlineCode">range()</code> function to generate a list of random numbers. For example, to simulate ten trials of a dice, we can use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> random
dice_output = [random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) for x in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]     
<span class="hljs-built_in">print</span>(dice_output)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[6, 6, 6, 6, 2, 4, 6, 5, 1, 4]
</code></pre>
    <h3 id="_idParaDest-49" class="heading-3">The time complexity of lists</h3>
    <p class="normal">The time complexity <a id="_idIndexMarker113"/>of various functions <a id="_idIndexMarker114"/>of a list can be summarized as follows using the Big O notation:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Inserting an element</strong>: The insertion<a id="_idIndexMarker115"/> of an element at the end of a list typically has a constant time complexity, denoted as <em class="italic">O(1)</em>. This means the time taken for this operation remains fairly consistent, irrespective of the list’s size.</li>
      <li class="bulletList"><strong class="keyWord">Deleting an element</strong>: Deleting an element from a list can have a time complexity of <em class="italic">O(n)</em> in its worst-case scenario. This is because, in the least favorable situation, the program might need to traverse the entire list before removing the desired element.</li>
      <li class="bulletList"><strong class="keyWord">Slicing</strong>: When we slice a list or extract a portion of it, the operation can take time proportional to the size of the slice; hence, its time complexity is <em class="italic">O(n)</em>.</li>
      <li class="bulletList"><strong class="keyWord">Element retrieval</strong>: Finding an element within a list, without any indexing, can require scanning through all its elements in the worst case. Thus, its time complexity is also <em class="italic">O(n)</em>.</li>
      <li class="bulletList"><strong class="keyWord">Copying</strong>: Creating a copy of the list necessitates visiting every element once, leading to a time complexity of <em class="italic">O(n)</em>.</li>
    </ul>
    <h2 id="_idParaDest-50" class="heading-2">Tuples</h2>
    <p class="normal">The second data structure<a id="_idIndexMarker116"/> that can be used to store a collection is<a id="_idIndexMarker117"/> a tuple. In contrast to lists, tuples are immutable (read-only) data structures. Tuples consist of several elements surrounded by <code class="inlineCode">( )</code>.</p>
    <p class="normal">Like lists, elements within a tuple can be of different types. They also allow their elements to be complex data types. So, there can be a tuple within a tuple providing a way to create a nested data structure. The capability to create nested data structures is especially useful in iterative and recursive algorithms.</p>
    <p class="normal">The following code demonstrates how to create tuples:</p>
    <pre class="programlisting code"><code class="hljs-code">bin_colors=(<span class="hljs-string">'</span><span class="hljs-string">Red'</span>,<span class="hljs-string">'Green'</span>,<span class="hljs-string">'Blue'</span>,<span class="hljs-string">'Yellow'</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"The second element of the tuple is</span> <span class="hljs-subst">{bin_colors[</span><span class="hljs-number">1</span><span class="hljs-subst">]}</span><span class="hljs-string">"</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">The second element of the tuple is Green
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">f"The elements after third element onwards are</span> <span class="hljs-subst">{bin_colors[</span><span class="hljs-number">2</span>:<span class="hljs-subst">]}</span><span class="hljs-string">"</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">The elements after third element onwards are ('Blue', 'Yellow')
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"># Nested Tuple Data structure
nested_tuple = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>),<span class="hljs-number">6</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"The maximum value of the inner tuple</span> <span class="hljs-subst">{max(nested_tuple[</span><span class="hljs-number">2</span><span class="hljs-subst">])}</span><span class="hljs-string">"</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">The maximum value of the inner tuple 300
</code></pre>
    <div class="note">
      <p class="normal">Wherever possible, immutable data structures (such as tuples) should be preferred over mutable data structures (such as lists) due to performance. Especially when dealing with big data, immutable data structures are considerably faster than mutable ones. When a data structure is passed to a function as immutable, its copy does not need to be created as the function cannot change it. So, the output can refer to the input data structure. This is called referential transparency and improves the performance. There is a price we pay for the ability to change data elements in lists and we should carefully analyze whether it is really needed so we can implement the code as read-only tuples, which will be much faster.</p>
    </div>
    <p class="normal">Note that, as Python<a id="_idIndexMarker118"/> is a zero-index-based language, <code class="inlineCode">a[2]</code> refers to<a id="_idIndexMarker119"/> the third element, which is a tuple, <code class="inlineCode">(100,200,300)</code>, and <code class="inlineCode">a[2][1]</code> refers to the second element within this tuple, which is <code class="inlineCode">200</code>.</p>
    <h3 id="_idParaDest-51" class="heading-3">The time complexity of tuples</h3>
    <p class="normal">The time complexity of <a id="_idIndexMarker120"/>various functions of tuples can be summarized as follows (using Big O notation):</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Accessing an element</strong>: Tuples allow direct access to their elements via indexing. This operation is constant time, <em class="italic">O(1)</em>, meaning the time taken remains consistent regardless of the tuple’s size.</li>
      <li class="bulletList"><strong class="keyWord">Slicing</strong>: When a portion of a tuple is extracted or sliced, the operation’s efficiency is proportional to the size of the slice, resulting in a time complexity of <em class="italic">O(n)</em>.</li>
      <li class="bulletList"><strong class="keyWord">Element retrieval</strong>: Searching for an element in a tuple, in the absence of any indexing aid, might require traversing all its elements in the worst-case scenario. Hence, its time complexity is <em class="italic">O(n)</em>.</li>
      <li class="bulletList"><strong class="keyWord">Copying</strong>: Duplicating a tuple, or creating its copy, requires iterating through each element once, giving it<a id="_idIndexMarker121"/> a time complexity of <em class="italic">O(n)</em>.</li>
    </ul>
    <h2 id="_idParaDest-52" class="heading-2">Dictionaries and sets</h2>
    <p class="normal">In this section, we will discuss sets and dictionaries, which are used to store data in which there is no explicit or implicit ordering. Both dictionaries and sets are quite similar. The difference is that a dictionary has a key-value pair. A set can be thought of as a collection of unique keys.</p>
    <p class="normal">Let us look into them one by one.</p>
    <h3 id="_idParaDest-53" class="heading-3">Dictionaries</h3>
    <p class="normal">Holding data as<a id="_idIndexMarker122"/> key-value pairs is important, especially<a id="_idIndexMarker123"/> in distributed algorithms. In Python, a collection of these key-value pairs is stored as a data structure called a dictionary. To create a dictionary, a key should be chosen as an attribute that is best suited to identify data throughout data processing. The limitation on the value of keys is that they must be hashable types. A hashable is the type of object on which we can run the hash function, generating a hash code that never changes during its lifetime. This ensures that the keys are unique and searching for a key is fast. Numeric types and flat immutable types are all hashable and are good choices for the dictionary keys. The value can be an element of any type, for example, a number or string. Python also always uses complex data types such as lists as values. Nested dictionaries can be created by using a dictionary as the data type of a value.</p>
    <p class="normal">To create a simple dictionary that assigns colors to various variables, the key-value pairs need to be enclosed in <code class="inlineCode">{ }</code>. For example, the following code creates a simple dictionary consisting of three key-value pairs:</p>
    <pre class="programlisting code"><code class="hljs-code">bin_colors ={
  <span class="hljs-string">"manual_color"</span>: <span class="hljs-string">"Yellow"</span>,
  <span class="hljs-string">"approved_color"</span>: <span class="hljs-string">"Green"</span>,
  <span class="hljs-string">"refused_color"</span>: <span class="hljs-string">"Red"</span>
}
<span class="hljs-built_in">print</span>(bin_colors)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{'manual_color': 'Yellow', 'approved_color': 'Green', 'refused_color': 'Red'}
</code></pre>
    <p class="normal">The three key-value pairs created by the preceding piece of code are also illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B18046_02_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.2: Key-value pairs in a simple dictionary</p>
    <p class="normal">Now, let’s see how to <a id="_idIndexMarker124"/>retrieve and update a value associated with a key:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">To retrieve a value associated with a key, either the <code class="inlineCode">get</code> function can be used or the key can be used as the index:
        <pre class="programlisting code"><code class="hljs-code">bin_colors.get(<span class="hljs-string">'approved_color'</span>)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">'Green'
</code></pre>
        <pre class="programlisting code"><code class="hljs-code">bin_colors[<span class="hljs-string">'approved_color'</span>]
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">'Green'
</code></pre>
      </li>
      <li class="numberedList">To update a value associated with a key, use the following code:
        <pre class="programlisting code"><code class="hljs-code">bin_colors[<span class="hljs-string">'approved_color'</span>]=<span class="hljs-string">"Purple"</span>
<span class="hljs-built_in">print</span>(bin_colors)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">{'manual_color': 'Yellow', 'approved_color': 'Purple', 'refused_color': 'Red'}
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that the <a id="_idIndexMarker125"/>preceding code shows how we can update a value related to a particular key in a dictionary.</p>
    <p class="normal">When iterating through a dictionary, usually, we will need both the keys and the values. We can iterate through a dictionary in Python by using <code class="inlineCode">.items()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> bin_colors.items():
    <span class="hljs-built_in">print</span>(k,'-&gt;',v+' color')
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">manual_color -&gt; Yellow color 
approved_color -&gt; Purple color 
refused_color -&gt; Red color
</code></pre>
    <p class="normal">To <code class="inlineCode">del</code> an element<a id="_idIndexMarker126"/> from a dictionary, we will use the <code class="inlineCode">del</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">del</span> bin_colors[<span class="hljs-string">'approved_color'</span>]
<span class="hljs-built_in">print</span>(bin_colors)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{'manual_color': 'Yellow', 'refused_color': 'Red'}
</code></pre>
    <h4 class="heading-4">The time complexity of a dictionary</h4>
    <p class="normal">For Python <a id="_idIndexMarker127"/>dictionaries, the time complexities for various operations are listed here:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Accessing a value by key</strong>: Dictionaries are designed for fast look-ups. When you have the key, accessing the corresponding value is, on average, a constant time operation, <em class="italic">O(1)</em>. This holds true unless there’s a hash collision, which is a rare scenario.</li>
      <li class="bulletList"><strong class="keyWord">Inserting a key-value pair</strong>: Adding a new key-value pair is generally a swift operation with a time complexity of <em class="italic">O(1)</em>.</li>
      <li class="bulletList"><strong class="keyWord">Deleting a key-value pair</strong>: Removing an entry from a dictionary, when the key is known, is also an <em class="italic">O(1)</em> operation on average.</li>
      <li class="bulletList"><strong class="keyWord">Searching for a key</strong>: Verifying the presence of a key, thanks to hashing mechanisms, is usually a constant time, <em class="italic">O(1)</em>, operation. However, worst-case scenarios could elevate this to <em class="italic">O(n)</em>, especially with many hash collisions.</li>
      <li class="bulletList"><strong class="keyWord">Copying</strong>: Creating a duplicate of a dictionary necessitates going through each key-value pair, resulting in a linear time complexity, <em class="italic">O(n)</em>.</li>
    </ul>
    <h3 id="_idParaDest-54" class="heading-3">Sets</h3>
    <p class="normal">Closely related to<a id="_idIndexMarker128"/> a dictionary is a set, which is defined as an <a id="_idIndexMarker129"/>unordered collection of distinct elements that can be of different types. One of the ways to define a set is to enclose the values in <code class="inlineCode">{ }</code>. For example, have a look at the following code block:</p>
    <pre class="programlisting code"><code class="hljs-code">green = {<span class="hljs-string">'grass'</span>, <span class="hljs-string">'leaves'</span>}
<span class="hljs-built_in">print</span>(green)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{'leaves', 'grass'}
</code></pre>
    <p class="normal">The defining characteristic of a set is that it only stores the distinct value of each element. If we try to add another redundant element, it will ignore that, as illustrated in the following:</p>
    <pre class="programlisting code"><code class="hljs-code">green = {<span class="hljs-string">'grass'</span>, <span class="hljs-string">'leaves'</span>,<span class="hljs-string">'leaves'</span>}
<span class="hljs-built_in">print</span>(green)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{'leaves', 'grass'}
</code></pre>
    <p class="normal">To demonstrate what sort of operations can be done on sets, let’s define two sets:</p>
    <ul>
      <li class="bulletList">A set named <code class="inlineCode">yellow</code>, which has things that are yellow</li>
      <li class="bulletList">A set named <code class="inlineCode">red</code>, which has things that are red</li>
    </ul>
    <p class="normal">Note that some things are common between these two sets. The two sets and their relationship can be represented with the help of the following Venn diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_02_03.png" alt="Diagram, venn diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.3: Venn diagram showing how elements are stored in sets</p>
    <p class="normal">If we want to <a id="_idIndexMarker130"/>implement these two sets in Python, the code will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">yellow = {<span class="hljs-string">'dandelions'</span>, <span class="hljs-string">'fire hydrant'</span>, <span class="hljs-string">'leaves'</span>}
red = {<span class="hljs-string">'fire hydrant'</span>, <span class="hljs-string">'blood'</span>, <span class="hljs-string">'rose'</span>, <span class="hljs-string">'leaves'</span>}
</code></pre>
    <p class="normal">Now, let’s consider the following code, which demonstrates set operations using Python:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">f"The union of yellow and red sets is </span><span class="hljs-subst">{</span><span class="hljs-subst">yellow|red}</span><span class="hljs-string">"</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">The union of yellow and red sets is {leaves, blood, dandelions, fire hydrant, rose}
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">f"The intersection of yellow and red is</span> <span class="hljs-subst">{yellow&amp;red}</span><span class="hljs-string">"</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">The intersection of yellow and red is {'fire hydrant', 'leaves'}
</code></pre>
    <p class="normal">As shown in the preceding code snippet, sets in Python can have operations such as unions and intersections. As we know, a union operation combines all of the elements of both sets, and the intersection operation will give a set of common elements between the two sets. Note the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">yellow|red</code> is used to get the union of the preceding two defined sets.</li>
      <li class="bulletList"><code class="inlineCode">yellow&amp;red</code> is used to get the overlap between yellow and red.</li>
    </ul>
    <p class="normal">As sets are unordered, the items of a set have no index. That means that we cannot access the items by referring to an index.</p>
    <p class="normal">We can loop through the set items using a <code class="inlineCode">for</code> loop:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> yellow:
    <span class="hljs-built_in">print</span>(x)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">fire hydrant 
leaves 
dandelions
</code></pre>
    <p class="normal">We can<a id="_idIndexMarker131"/> also<a id="_idIndexMarker132"/> check if a specified value is present in a set by using the <code class="inlineCode">in</code> keyword.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">"leaves"</span> in yellow)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">True
</code></pre>
    <h3 id="_idParaDest-55" class="heading-3">Time complexity analysis for sets</h3>
    <p class="normal">The following is<a id="_idIndexMarker133"/> the time complexity analysis for sets:</p>
    <table id="table002" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Sets</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Complexity</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Add an element</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(1)</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Remove an element</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(1)</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Copy</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n)</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 2.2: Time complexity for sets</p>
    <h3 id="_idParaDest-56" class="heading-3">When to use a dictionary and when to use a set</h3>
    <p class="normal">Let us assume that <a id="_idIndexMarker134"/>we are looking for a<a id="_idIndexMarker135"/> data structure for our phone book. We want to store the phone numbers of the employees of a company. For this purpose, a dictionary is the right data structure. The name of each employee will be the key and the value will be the phone number:</p>
    <pre class="programlisting code"><code class="hljs-code">employees_dict = {
    <span class="hljs-string">"Ikrema Hamza"</span>: <span class="hljs-string">"555-555-5555"</span>,
    <span class="hljs-string">"Joyce Doston"</span> : <span class="hljs-string">"212-555-5555"</span>,
}
</code></pre>
    <p class="normal">But if we want to store only the unique value of the employees, then that should be done using sets:</p>
    <pre class="programlisting code"><code class="hljs-code">employees_set = {
    <span class="hljs-string">"Ikrema Hamza"</span>,
    <span class="hljs-string">"Joyce Doston"</span>
}
</code></pre>
    <h2 id="_idParaDest-57" class="heading-2">Using Series and DataFrames</h2>
    <p class="normal">Processing <a id="_idIndexMarker136"/>data is one of the core things that need to be <a id="_idIndexMarker137"/>done while implementing <a id="_idIndexMarker138"/>most of<a id="_idIndexMarker139"/> the algorithms. In Python, data processing is usually done by using various functions and data structures of the <code class="inlineCode">pandas</code> library. </p>
    <p class="normal">In this section, we will look into the following two important data structures of the pandas library, which will be used to implement various algorithms later in this book:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Series</strong>: A one-dimensional array of values</li>
      <li class="bulletList"><strong class="keyWord">DataFrame</strong>: A two-dimensional data structure used to store tabular data</li>
    </ul>
    <p class="normal">Let us look<a id="_idIndexMarker140"/> into<a id="_idIndexMarker141"/> the Series data structure first.</p>
    <h3 id="_idParaDest-58" class="heading-3">Series</h3>
    <p class="normal">In the <code class="inlineCode">pandas</code> <a id="_idIndexMarker142"/>library, a Series is a one-dimensional array of values for homogenous data. We can think of a Series as a single column in a spreadsheet. We can think of Series as holding various values of a particular variable.</p>
    <p class="normal">A Series can be defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
person_1 = pd.Series([<span class="hljs-string">'John'</span>,<span class="hljs-string">"Male"</span>,<span class="hljs-number">33</span>,<span class="hljs-literal">True</span>])
<span class="hljs-built_in">print</span>(person_1)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">0    John 
1    Male 
2    33 
3    True 
dtype:    object
</code></pre>
    <p class="normal">Note that in <code class="inlineCode">pandas</code> Series-based data structures, there is a term called “axis,” which is used to represent a sequence of values in a particular dimension. <em class="italic">Series</em> has only “axis 0” because it has only one dimension. We will see how this axis concept is applied to a DataFrame in the next section.</p>
    <h3 id="_idParaDest-59" class="heading-3">DataFrame</h3>
    <p class="normal">A DataFrame is built<a id="_idIndexMarker143"/> upon the Series data structure. It is stored as two-dimensional tabular data. It is used to process traditional structured data. Let’s consider the following table:</p>
    <table id="table003" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">id</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">name</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">age</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">decision</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Fares</p>
          </td>
          <td class="table-cell">
            <p class="normal">32</p>
          </td>
          <td class="table-cell">
            <p class="normal">True</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">Elena</p>
          </td>
          <td class="table-cell">
            <p class="normal">23</p>
          </td>
          <td class="table-cell">
            <p class="normal">False</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">Doug</p>
          </td>
          <td class="table-cell">
            <p class="normal">40</p>
          </td>
          <td class="table-cell">
            <p class="normal">True</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Now, let’s represent this using a DataFrame.</p>
    <p class="normal">A simple DataFrame can be created by using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">employees_df = pd.DataFrame([
    [<span class="hljs-string">'</span><span class="hljs-string">1'</span>, <span class="hljs-string">'Fares'</span>, <span class="hljs-number">32</span>, <span class="hljs-literal">True</span>],
    [<span class="hljs-string">'2'</span>, <span class="hljs-string">'Elena'</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">False</span>],
    [<span class="hljs-string">'3'</span>, <span class="hljs-string">'Doug'</span>, <span class="hljs-number">40</span>, <span class="hljs-literal">True</span>]])
employees_df.columns = [<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'decision'</span>]
<span class="hljs-built_in">print</span>(employees_df)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">    id    name    age    decision
0    1    Fares    32    True
1    2    Elena    23    False
2    3    Doug    40    True
</code></pre>
    <p class="normal">Note that, in the preceding code, <code class="inlineCode">df.column</code> is a list that specifies the names of the columns. In DataFrame, a single<a id="_idIndexMarker144"/> column or row is called an axis.</p>
    <div class="note">
      <p class="normal">DataFrames are also used in other popular languages and frameworks to implement a tabular data structure. Examples are R and the Apache Spark framework.</p>
    </div>
    <h3 id="_idParaDest-60" class="heading-3">Creating a subset of a DataFrame</h3>
    <p class="normal">Fundamentally, there <a id="_idIndexMarker145"/>are two main ways of creating the subset of a DataFrame:</p>
    <ul>
      <li class="bulletList">Column selection</li>
      <li class="bulletList">Row selection</li>
    </ul>
    <p class="normal">Let’s look at them one by one.</p>
    <h4 class="heading-4">Column selection</h4>
    <p class="normal">In machine <a id="_idIndexMarker146"/>learning algorithms, selecting the right set of features is an important task. Out of all of the features that we may have, not all of them may be needed at a particular stage of the algorithm. In Python, feature selection is achieved by column selection, which is explained in this section.</p>
    <p class="normal">A column may be retrieved by <code class="inlineCode">name</code>, as in the following:</p>
    <pre class="programlisting code"><code class="hljs-code">df[[<span class="hljs-string">'name'</span>,<span class="hljs-string">'age'</span>]]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">     name    age
0    Fares    32
1    Elena    23
2    Doug     40
</code></pre>
    <p class="normal">The positioning of a column is deterministic in a DataFrame. A column can be retrieved by its position, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">df.iloc[:,<span class="hljs-number">3</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">0    True 
1    False 
2    True 
Name: decision, dtype: bool
</code></pre>
    <p class="normal">Note that, in this <a id="_idIndexMarker147"/>code, we are retrieving all rows of the DataFrame.</p>
    <h4 class="heading-4">Row selection</h4>
    <p class="normal">Each row in a<a id="_idIndexMarker148"/> DataFrame corresponds to a data point in our problem space. We need to perform row selection if we want to create a subset of the data elements that we have in our problem space. This subset can be created by using one of the two following methods:</p>
    <ul>
      <li class="bulletList">By specifying their position</li>
      <li class="bulletList">By specifying a filter</li>
    </ul>
    <p class="normal">A subset of rows can be retrieved by its position, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">df.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">    id    name    age    decision
1    2    Elena    23    False
</code></pre>
    <p class="normal">Note that the preceding code will return the second and third rows plus all columns. It uses the <code class="inlineCode">iloc</code> method, which allows us to access the elements by their numerical index.</p>
    <p class="normal">To create a subset by specifying the filter, we need to use one or more columns to define the selection criterion. For example, a subset of data elements can be selected by this method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">df[df.age&gt;<span class="hljs-number">30</span>]
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">    id    name    age    decision
0    1    Fares    32    True
2    3    Doug     40    True
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">df[(df.age&lt;<span class="hljs-number">35</span>)&amp;(df.decision==<span class="hljs-literal">True</span>)]    id    name    age    decision
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">    id    name    age    decision
0    1    Fares    32    True
</code></pre>
    <p class="normal">Note that this <a id="_idIndexMarker149"/>code creates a subset of rows that satisfies the condition stipulated in the filter.</p>
    <h4 class="heading-4">Time complexity analysis for sets</h4>
    <p class="normal">Let’s unveil the<a id="_idIndexMarker150"/> time complexities of some fundamental DataFrame operations.</p>
    <ul>
      <li class="bulletList">Selection operations<ul>
          <li class="bulletList"><strong class="keyWord">Column selection</strong>: Accessing<a id="_idIndexMarker151"/> a DataFrame column, often done using the bracket notation or dot notation (for column names without spaces), is an <em class="italic">O(1)</em> operation. It offers a quick reference to the data without copying.</li>
          <li class="bulletList"><strong class="keyWord">Row selection</strong>: Using methods like <code class="inlineCode">.loc[]</code> or <code class="inlineCode">.iloc[]</code> to select rows, especially with slicing, has a time complexity of <em class="italic">O(n)</em>, where “<em class="italic">n</em>” represents the number of rows you’re accessing.</li>
        </ul>
      </li>
      <li class="bulletList">Insertion operations<ul>
          <li class="bulletList"><strong class="keyWord">Column insertion</strong>: Appending a <a id="_idIndexMarker152"/>new column to a DataFrame is typically an <em class="italic">O(1)</em> operation. However, the actual time can vary depending on the data type and size of the data being added.</li>
          <li class="bulletList"><strong class="keyWord">Row insertion</strong>: Adding rows using methods like <code class="inlineCode">.append()</code> or <code class="inlineCode">.concat()</code> can result in an <em class="italic">O(n)</em> complexity since it often requires rearranging and <a id="_idIndexMarker153"/>reallocation.</li>
        </ul>
      </li>
      <li class="bulletList">Deletion operations<ul>
          <li class="bulletList"><strong class="keyWord">Column deletion</strong>: Dropping a<a id="_idIndexMarker154"/> column from a DataFrame, facilitated by the <code class="inlineCode">.drop()</code> method, is an <em class="italic">O(1)</em> operation. It marks the column for garbage collection rather than immediate deletion.</li>
          <li class="bulletList"><strong class="keyWord">Row deletion</strong>: Similar to row insertion, row deletion can lead to an <em class="italic">O(n)</em> time complexity, as<a id="_idIndexMarker155"/> the DataFrame has to rearrange its structure.</li>
        </ul>
      </li>
    </ul>
    <h2 id="_idParaDest-61" class="heading-2">Matrices</h2>
    <p class="normal">A matrix is a two-dimensional <a id="_idIndexMarker156"/>data structure with a fixed number of columns and rows. Each element of a matrix can be referred to by its column and the row.</p>
    <p class="normal">In Python, a matrix can be created by using a <code class="inlineCode">numpy</code> array or a list. But <code class="inlineCode">numpy</code> arrays are much faster than lists because they are collections of homogenous data elements located in a contiguous memory location. The following code can be used to create a matrix from a <code class="inlineCode">numpy</code> array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
matrix_1 = np.array([[<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>], [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>], [<span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>]])
<span class="hljs-built_in">print</span>(matrix_1)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[[11 12 13] 
 [21 22 23] 
 [31 32 33]]
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(matrix_1))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">&lt;class 'numpy.ndarray'&gt;
</code></pre>
    <p class="normal">Note that the preceding code will create a matrix that has three rows and three columns.</p>
    <h3 id="_idParaDest-62" class="heading-3">Matrix operations</h3>
    <p class="normal">There are many<a id="_idIndexMarker157"/> operations available <a id="_idIndexMarker158"/>for matrix data manipulation. For example, let’s try to transpose the preceding matrix. We will use the <code class="inlineCode">transpose()</code> function, which will convert columns into rows and rows into columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(matrix_1.transpose())
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">array([[11, 21, 31], 
       [12, 22, 32], 
       [13, 23, 33]])
</code></pre>
    <p class="normal">Note that matrix operations are used a lot in multimedia data manipulation.</p>
    <h3 id="_idParaDest-63" class="heading-3">Big O notation and matrices</h3>
    <p class="normal">When discussing <a id="_idIndexMarker159"/>the efficiency of <a id="_idIndexMarker160"/>operations, the Big O notation <a id="_idIndexMarker161"/>provides a<a id="_idIndexMarker162"/> high-level understanding of its impact as data scales:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Access</strong>: Accessing an element, whether in a Python list or a <code class="inlineCode">numpy</code> array, is a constant time operation, <em class="italic">O(1)</em>. This is because, with the index of the element, you can directly access it.</li>
      <li class="bulletList"><strong class="keyWord">Appending</strong>: Appending an element at the end of a Python list is an average-case <em class="italic">O(1)</em> operation. However, for a numpy array, the operation can be <em class="italic">O(n)</em> in the worst case, as the entire array might need to be copied to a new memory location if there’s no contiguous space available.</li>
      <li class="bulletList"><strong class="keyWord">Matrix multiplication</strong>: This is where numpy shines. Matrix multiplication can be computationally intensive. Traditional methods can have a time complexity of <em class="italic">O(n</em><sup class="superscript">3</sup><em class="italic">)</em> for <em class="italic">n x n</em> matrices. However, <code class="inlineCode">numpy</code> uses optimized algorithms, like the Strassen algorithm, which reduces this significantly.</li>
    </ul>
    <p class="normal">Now that we have learned about data structures in Python, let’s move on to abstract data types in the next section.</p>
    <h1 id="_idParaDest-64" class="heading-1">Exploring abstract data types</h1>
    <p class="normal"><strong class="keyWord">Abstract data types</strong> (<strong class="keyWord">ADTs</strong>) are high-level abstractions whose behavior is defined by a set of variables and <a id="_idIndexMarker163"/>a set of related operations. ADTs define the implementation guidance of “what” needs to be expected but give the programmer freedom in “how” it will be exactly implemented. Examples are vectors, queues, and stacks. This means that two different programmers can take two different approaches to implementing an ADT, like a stack. By hiding the implementation level details and giving the user a generic, implementation-independent data structure, the use of ADTs creates algorithms that result in simpler and cleaner code. ADTs can be implemented in any programming language, such as C++, Java, and Scala. In this section, we shall implement ADTs using Python. Let’s start with vectors first.</p>
    <h2 id="_idParaDest-65" class="heading-2">Vector</h2>
    <p class="normal">A vector is a <a id="_idIndexMarker164"/>single-dimension structure for storing data. They are one of the most popular data structures in Python. There are two ways of creating vectors in Python, as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Using a Python list</strong>: The simplest way to create a vector is by using a Python list, as follows:
        <pre class="programlisting code"><code class="hljs-code">vector_1 = [<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>]
<span class="hljs-built_in">print</span>(vector_1)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">[22, 33, 44, 55]
</code></pre>
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(vector_1))
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">&lt;class 'list'&gt;
</code></pre>
      </li>
    </ul>
    <p class="normal">Note that this code will create a list with four elements.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Using a numpy array</strong>: Another popular way to create a vector is to use <code class="inlineCode">numpy</code> arrays. <code class="inlineCode">numpy</code> arrays are generally faster and more memory-efficient than Python lists, especially for operations that involve large amounts of data. This is because <code class="inlineCode">numpy</code> is designed to work with homogenous data and can take advantage of low-level optimizations. A <code class="inlineCode">numpy</code> array can be implemented as follows:
        <pre class="programlisting code"><code class="hljs-code">vector_2 = np.array([<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>])
<span class="hljs-built_in">print</span>(vector_2)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">[22 33 44 55]
</code></pre>
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(vector_2))
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">&lt;class 'numpy.ndarray'&gt;
</code></pre>
      </li>
    </ul>
    <p class="normal">Note that we created <code class="inlineCode">myVector</code> using <code class="inlineCode">np.array</code> in this code.</p>
    <div class="packt_tip">
      <p class="normal">In Python, we can represent integers using underscores to separate parts. This makes them more readable and less error-prone. This is especially useful when dealing with large<a id="_idIndexMarker165"/> numbers. So, one billion can be represented as <code class="inlineCode">1000_000_000</code>.</p>
    </div>
    <pre class="programlisting code"><code class="hljs-code">large_number=<span class="hljs-number">1000_000_000</span>
<span class="hljs-built_in">print</span>(large_number)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">1000000000
</code></pre>
    <h3 id="_idParaDest-66" class="heading-3">Time complexity of vectors</h3>
    <p class="normal">When discussing <a id="_idIndexMarker166"/>the efficiency of vector<a id="_idIndexMarker167"/> operations, it’s vital to understand the time complexity:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Access</strong>: Accessing an element in both a Python list and a <code class="inlineCode">numpy</code> array (vector) takes constant time, <em class="italic">O(1)</em>. This ensures rapid data retrieval.</li>
      <li class="bulletList"><strong class="keyWord">Appending</strong>: Appending an element to a Python list has an average time complexity of <em class="italic">O(1)</em>. However, for a numpy array, appending could take up to <em class="italic">O(n)</em> in the worst case since numpy arrays require contiguous memory locations.</li>
      <li class="bulletList"><strong class="keyWord">Searching</strong>: Finding an element in a vector has a time complexity of <em class="italic">O(n)</em> because, in the worst case, you might have to scan through all elements.</li>
    </ul>
    <h2 id="_idParaDest-67" class="heading-2">Stacks</h2>
    <p class="normal">A stack is a <a id="_idIndexMarker168"/>linear<a id="_idIndexMarker169"/> data structure to store a one-dimensional list. It can store items either in a <strong class="keyWord">Last-In, First-Out</strong> (<strong class="keyWord">LIFO</strong>) or <strong class="keyWord">First-In, Last-Out</strong> (<strong class="keyWord">FILO</strong>) manner. The<a id="_idIndexMarker170"/> defining <a id="_idIndexMarker171"/>characteristic of a stack is the way elements are added to and removed from it. A new element is added at one end and an element is removed from that end only.</p>
    <p class="normal">The following are the operations related to stacks:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">isEmpty</strong>: Returns <code class="inlineCode">true</code> if the stack is empty</li>
      <li class="bulletList"><strong class="keyWord">push</strong>: Adds a new element</li>
      <li class="bulletList"><strong class="keyWord">pop</strong>: Returns the element added most recently and removes it</li>
    </ul>
    <p class="normal"><em class="italic">Figure 2.4</em> shows how <code class="inlineCode">push</code> and <code class="inlineCode">pop</code> operations can be used to add and remove data from a stack:</p>
    <figure class="mediaobject"><img src="../Images/B18046_02_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.4: Push and pop operations</p>
    <p class="normal">The top portion of <em class="italic">Figure 2.4</em> shows the use of <code class="inlineCode">push</code> operations to add items to the stack. In <em class="italic">steps 1.1</em>, <em class="italic">1.2</em>, and <em class="italic">1.3</em>, <code class="inlineCode">push</code> operations are used three times to add three elements to the <a id="_idIndexMarker172"/>stack. The bottom portion of the preceding <a id="_idIndexMarker173"/>diagram is used to retrieve the stored values from the stack. In <em class="italic">steps 2.2</em> and <em class="italic">2.3</em>, <code class="inlineCode">pop</code> operations are used to retrieve two elements from the stack in LIFO format.</p>
    <p class="normal">Let’s create a class named <code class="inlineCode">Stack</code> in Python, where we will define all of the operations related to the <code class="inlineCode">Stack</code> class. The code of this class will be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>:
     <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):
         self.items = []
     <span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">self</span>):
         <span class="hljs-keyword">return</span> self.items == []
     <span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, item</span>):
         self.items.append(item)
     <span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):
         <span class="hljs-keyword">return</span> self.items.pop()
     <span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):
         <span class="hljs-keyword">return</span> self.items[<span class="hljs-built_in">len</span>(self.items)-<span class="hljs-number">1</span>]
     <span class="hljs-keyword">def</span> <span class="hljs-title">size</span>(<span class="hljs-params">self</span>):
         <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)
</code></pre>
    <p class="normal">To push four elements to the stack, the following code can be used:</p>
    <pre class="programlisting code"><code class="hljs-code">Populate the stack
stack=Stack()
stack.push(<span class="hljs-string">'Red'</span>)
stack.push(<span class="hljs-string">'Green'</span>)
stack.push(<span class="hljs-string">"Blue"</span>)
stack.push(<span class="hljs-string">"Yellow"</span>)
</code></pre>
    <p class="normal">Note that the <a id="_idIndexMarker174"/>preceding code creates a stack with four data <a id="_idIndexMarker175"/>elements:</p>
    <pre class="programlisting code"><code class="hljs-code">Pop
stack.pop()
stack.isEmpty()
</code></pre>
    <h3 id="_idParaDest-68" class="heading-3">Time complexity of stack operations</h3>
    <p class="normal">Let us look into<a id="_idIndexMarker176"/> the time complexity <a id="_idIndexMarker177"/>of stack operations:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Push</strong>: This operation adds an element to the top of the stack. Since it doesn’t involve any iteration or checking, the time complexity of the push operation is <em class="italic">O(1)</em>, or constant time. The element is placed on top regardless of the stack’s size.</li>
      <li class="bulletList"><strong class="keyWord">Pop</strong>: Popping refers to removing the top element from the stack. Given that there’s no need to interact with the rest of the stack, the pop operation also has a time complexity of <em class="italic">O(1)</em>. It’s a direct action on the top element.</li>
    </ul>
    <h3 id="_idParaDest-69" class="heading-3">Practical example</h3>
    <p class="normal">A stack is used as <a id="_idIndexMarker178"/>the data structure in<a id="_idIndexMarker179"/> many use cases. For example, when a user wants to browse the history in a web browser, it is a LIFO data access pattern, and a stack can be used to store the history. Another example is when a user wants to perform an undo operation in word processing software.</p>
    <h2 id="_idParaDest-70" class="heading-2">Queues</h2>
    <p class="normal">Like stacks, a queue <a id="_idIndexMarker180"/>stores <em class="italic">n</em> elements in a single-dimensional<a id="_idIndexMarker181"/> structure. The elements are added and removed in FIFO format. One end of the queue is called the <code class="inlineCode">rear</code> and the other is called the <code class="inlineCode">front</code>. When elements are removed from the front, the operation is called <code class="inlineCode">dequeue</code>. When elements are added at the rear, the operation is called <code class="inlineCode">enqueue</code>.</p>
    <p class="normal">In the following diagram, the top portion shows the enqueue operation. <em class="italic">Steps 1.1</em>, <em class="italic">1.2</em>, and <em class="italic">1.3</em> add three elements to the queue and the resultant queue is shown in <em class="italic">1.4</em>. Note that <strong class="screenText">Yellow</strong> is the <code class="inlineCode">rear</code> and <strong class="screenText">Red</strong> is the <code class="inlineCode">front</code>.</p>
    <p class="normal">The bottom portion of the following diagram shows a <code class="inlineCode">dequeue</code> operation. <em class="italic">Steps 2.2</em>, <em class="italic">2.3</em>, and <em class="italic">2.4</em> remove elements from the queue one by one from the front of the queue:</p>
    <figure class="mediaobject"><img src="../Images/B18046_02_05.png" alt="A picture containing diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.5: Enqueue and dequeue operations</p>
    <p class="normal">The queue shown in the preceding diagram can be implemented by using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>(<span class="hljs-title">object</span>):
   <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):
      self.items = []
   <span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">self</span>):
      <span class="hljs-keyword">return</span> self.items == []
   <span class="hljs-keyword">def</span> <span class="hljs-title">enqueue</span>(<span class="hljs-params">self, item</span>):
       self.items.insert(<span class="hljs-number">0</span>,item)
   <span class="hljs-keyword">def</span> <span class="hljs-title">dequeue</span>(<span class="hljs-params">self</span>):
      <span class="hljs-keyword">return</span> self.items.pop()
   <span class="hljs-keyword">def</span> <span class="hljs-title">size</span>(<span class="hljs-params">self</span>):
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)
</code></pre>
    <p class="normal">Let’s enqueue and dequeue elements as shown in the preceding diagramm with the help of the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Using Queue</span>
queue = Queue()
queue.enqueue(<span class="hljs-string">"Red"</span>)
queue.enqueue(<span class="hljs-string">'Green'</span>)
queue.enqueue(<span class="hljs-string">'Blue'</span>)
queue.enqueue(<span class="hljs-string">'Yellow'</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Size of queue is </span><span class="hljs-subst">{queue.size()}</span><span class="hljs-string">"</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Size of queue is 4
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(queue.dequeue())
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Red
</code></pre>
    <p class="normal">Note that the<a id="_idIndexMarker182"/> preceding code creates a queue first and then<a id="_idIndexMarker183"/> enqueues four items into it.</p>
    <h3 id="_idParaDest-71" class="heading-3">Time complexity analysis for queues</h3>
    <p class="normal">Let us look into <a id="_idIndexMarker184"/>the time complexity for queues:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Enqueue</strong>: This operation inserts an element t the end of the queue. Given its straightforward nature, without any need for iterating or traversing, the <code class="inlineCode">enqueue</code> operation bears a time complexity of <em class="italic">O(1)</em> – a constant time.</li>
      <li class="bulletList"><strong class="keyWord">Dequeue</strong>: Dequeueing means removing the front element from the queue. As the operation only involves the first element without any checks or iterations through<a id="_idIndexMarker185"/> the queue, its time complexity remains constant at <em class="italic">O(1)</em>.</li>
    </ul>
    <h3 id="_idParaDest-72" class="heading-3">The basic idea behind the use of stacks and queues</h3>
    <p class="normal">Let’s look into the basic idea <a id="_idIndexMarker186"/>behind the use<a id="_idIndexMarker187"/> of stacks and queues using an analogy. Let’s assume that we have a table where we put our incoming mail from our postal service, for example, Canada Mail. We stack them until we have some time to open and look at the letters, one by one. There are two possible ways of doing this:</p>
    <ul>
      <li class="bulletList">We put the letters in a stack and, whenever we get a new letter, we put it on the top of the stack. When we want to read a letter, we start with the one that is on top. This is what we call a <strong class="keyWord">stack</strong>. Note that the latest letter to arrive will be on the top and will be processed first. Picking up a letter from the top of the list is called a <code class="inlineCode">pop</code> operation. Whenever a new letter arrives, putting it on the top is called a <code class="inlineCode">push</code> operation. If we end up having a sizable stack and lots of letters are continuously arriving, there is a chance that we never get a chance to reach a very important letter waiting for us at the lower end of the stack.</li>
      <li class="bulletList">We put the letters in the pile, but we want to handle the oldest letter first; every time we want to look at one or more letters, we take care to handle the oldest one first. This is what we call a <strong class="keyWord">queue</strong>. Adding a letter to the pile is called an <code class="inlineCode">enqueue</code> operation. Removing the letter from the pile is called a <code class="inlineCode">dequeue</code> operation.</li>
    </ul>
    <h2 id="_idParaDest-73" class="heading-2">Tree</h2>
    <p class="normal">In the context <a id="_idIndexMarker188"/>of algorithms, a tree is one of the most useful <a id="_idIndexMarker189"/>data structures due to its hierarchical data storage capabilities. While designing algorithms, we use trees wherever we need to represent hierarchical relationships among the data elements that we need to store or process.</p>
    <p class="normal">Let’s look deeper into this interesting and quite important data structure.</p>
    <p class="normal">Each tree has a finite set of nodes so that it has a starting data element called a <strong class="keyWord">root</strong> and a set of nodes joined together by links called <strong class="keyWord">branches</strong>.</p>
    <h3 id="_idParaDest-74" class="heading-3">Terminology</h3>
    <p class="normal">Let’s look into some of<a id="_idIndexMarker190"/> the terminology related to the tree data structure:</p>
    <table id="table004" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Root node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">A node with no parent is called the root node. For example, in the following diagram, the root node is A. In algorithms, usually, the root node holds the most important value in the tree structure.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Level of a node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">The distance from the root node is the level of a node. For example, in the following diagram, the level of nodes D, E, and F is two.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Siblings nodes</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">Two nodes in a tree are called siblings if they are at the same level. For example, if we check the following diagram, nodes B and C are siblings.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Child and parent node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">Node F is a child of node C if both are directly connected and the level of node C is less than node F. Conversely, node C is a parent of node F. Nodes C and F in the following diagram show this parent-child relationship.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Degree of a node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">The degree of a node is the number of children it has. For example, in the following diagram, node B has a degree of two.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Degree of a tree</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">The degree of a tree is equal to the maximum degree that can be found among the constituent nodes of a tree. For example, the tree presented in the following diagram has a degree of two.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Subtree</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">A subtree of a tree is a portion of the tree with the chosen node as the root node of the subtree and all of the children as the nodes of the tree. For example, a subtree at node E of the tree presented in the following diagram consists of node E as the root node and nodes G and H as the two children.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Leaf node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">A node in a tree with no children is called a leaf node. For example, in the following figure, nodes D, G, H, and F are the four leaf nodes.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Internal node</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">Any node that is neither a root nor a leaf node is an internal node. An internal node will have at least one parent and at least one child node.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <div class="note">
      <p class="normal">Note that trees are a kind of network or graph that we will study in <em class="chapterRef">Chapter 6</em>, <em class="italic">Unsupervised Machine Learning Algorithms</em>. For graphs and network analysis, we use the terms <strong class="keyWord">link</strong> or <strong class="keyWord">edge</strong> instead of branches. Most of the other terminology <a id="_idIndexMarker191"/>remains unchanged.</p>
    </div>
    <h3 id="_idParaDest-75" class="heading-3">Types of trees</h3>
    <p class="normal">There are different <a id="_idIndexMarker192"/>types of trees, which are explained as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Binary tree</strong>: If the degree<a id="_idIndexMarker193"/> of a tree is two, that tree is called a <em class="italic">binary tree</em>. For example, the tree shown in the following diagram is a binary tree as it has a degree of two:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18046_02_06.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.6: A binary tree</p>
    <p class="normal">Note that the preceding diagram shows a tree that has four levels with eight nodes.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Full tree</strong>: A full tree is <a id="_idIndexMarker194"/>one in which all of the nodes are of the same degree, which will be equal to the degree of the tree. The following diagram shows the kinds of trees discussed earlier:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18046_02_07.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.7: A full tree </p>
    <p class="normal">Note that the binary tree on the left is not a full tree, as node C has a degree of one and all other nodes have a degree of two. The tree in the middle and the one on the right are both full trees.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Perfect tree</strong>: A perfect tree is <a id="_idIndexMarker195"/>a special type of full tree in which all the leaf nodes are at the same level. For example, the binary tree on the right as shown in the preceding diagram is a perfect, full tree as all the leaf nodes are at the same level – that is, <strong class="keyWord">level 2</strong>.</li>
      <li class="bulletList"><strong class="keyWord">Ordered tree</strong>: If the children of a node are organized in some order according to particular criteria, the tree is <a id="_idIndexMarker196"/>called an <strong class="keyWord">ordered tree</strong>. A tree, for example, can<a id="_idIndexMarker197"/> be ordered from left to right in ascending order in which the nodes at the same level will increase in value while traversing from left to right.</li>
    </ul>
    <h3 id="_idParaDest-76" class="heading-3">Practical examples</h3>
    <p class="normal">An ADT tree is one of the <a id="_idIndexMarker198"/>main data structures that is used in developing decision trees, as will be discussed in <em class="chapterRef">Chapter 7</em>, <em class="italic">Traditional Supervised Learning Algorithms</em>. Due to its hierarchical structure, it is also popular in algorithms related to network analysis, as will be discussed in detail in <em class="chapterRef">Chapter 6</em>, <em class="italic">Unsupervised Machine Learning Algorithms</em>. Trees are also used in various search and sort algorithms in which divide and conquer strategies need to be implemented.</p>
    <h1 id="_idParaDest-77" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed data structures that can be used to implement various types of algorithms. After going through this chapter, you should now be able to select the right data structure to be used to store and process data with an algorithm. You should also be able to understand the implications of our choice on the performance of the algorithm.</p>
    <p class="normal">The next chapter is about sorting and searching algorithms, in which we will use some of the data structures presented in this chapter in the implementation of the algorithms.</p>
    <h1 id="_idParaDest-78" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>