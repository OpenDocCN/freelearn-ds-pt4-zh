- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Structures Used in Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithms need in-memory data structures that can hold temporary data while
    executing. Choosing the right data structures is essential for their efficient
    implementation. Certain classes of algorithms are recursive or iterative in logic
    and need data structures that are specially designed for them. For example, a
    recursive algorithm may be more easily implemented, exhibiting better performance,
    if nested data structures are used. In this chapter, data structures are discussed
    in the context of algorithms. As we are using Python in this book, this chapter
    focuses on Python data structures, but the concepts presented in this chapter
    can be used in other languages such as Java and C++.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand how Python handles
    complex data structures and which one should be used for a certain type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main points discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Python built-in data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Series and DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring matrices and matrix operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding abstract data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Python built-in data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any language, data structures are used to store and manipulate complex data.
    In Python, data structures are storage containers for managing, organizing, and
    searching data in an efficient way. They are used to store a group of data elements
    called collections that need to be stored and processed together. In Python, the
    important data structures that can be used to store collections are summarized
    in *Table 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Structure** | **Brief Explanation** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| List | An ordered, possibly nested, mutable sequence of elements | `["John",
    33,"Toronto", True]` |'
  prefs: []
  type: TYPE_TB
- en: '| Tuple | An ordered immutable sequence of elements | `(''Red'',''Green'',''Blue'',''Yellow'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | An unordered collection of key-value pairs | `{''brand'': ''Apple'',
    ''color'': ''black''}` |'
  prefs: []
  type: TYPE_TB
- en: '| Set | An unordered collection of elements | `{''a'', ''b'', ''c''}` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Python Data Structures'
  prefs: []
  type: TYPE_NORMAL
- en: Let us look into them in more detail in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, a list is the main data type used to store a mutable sequence of
    elements. The sequence of elements stored in the list need not be of the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list can be defined by enclosing the elements in `[ ]` and they need to be
    separated by a comma. For example, the following code creates four data elements
    together that are of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Python, a list is a handy way of creating one-dimensional writable data structures,
    which are especially needed at different internal stages of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Using lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Utility functions in data structures make them very useful as they can be used
    to manage data in lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look into how we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List indexing**: As the position of an element is deterministic in a list,
    the index can be used to get an element at a particular position. The following
    code demonstrates the concept:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The four-element list created by this code is shown in *Figure 2.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18046_02_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.1: A four-element list in Python'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will run the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that Python is a zero-indexing language. This means that the initial index
    of any data structure, including lists, will be `0`. `Green`, which is the second
    element, is retrieved by index `1` – that is, `bin_colors[1]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**List slicing**: Retrieving a subset of the elements of a list by specifying
    a range of indexes is called **slicing**. The following code can be used to create
    a slice of the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that lists are one of the most popular single-dimensional data structures
    in Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While slicing a list, the range is indicated as follows: the first number (inclusive)
    and the second number (exclusive). For example, `bin_colors[0:2]` will include
    `bin_color[0]` and `bin_color[1]` but not `bin_color[2]`. While using lists, this
    should be kept in mind, as some users of the Python language complain that this
    is not very intuitive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the starting index is not specified, it means the beginning of the list,
    and if the ending index is not specified, it means the end of the list, as demonstrated
    by the preceding code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Negative indexing**: In Python, we also have negative indices, which count
    from the end of the list. This is demonstrated in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that negative indices are especially useful when we want to use the last
    element as a reference point instead of the first one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Nesting**: An element of a list can be of any data type. This allows nesting
    in lists. For iterative and recursive algorithms, this provides important capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code, which is an example of a list within
    a list (nesting):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Iteration**: Python allows iterating over each element on a list by using
    a `for` loop. This is demonstrated in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the preceding code iterates through the list and prints each element.
    Now let us remove the last element from the stack using `pop()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying lists: append and pop operations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at modifying some lists, including the append and pop operations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements with append()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you want to insert a new item at the end of a list, you employ the `append()`
    method. It works by adding the new element to the nearest available memory slot.
    If the list is already at full capacity, Python extends the memory allocation,
    replicates the previous items in this newly carved out space, and then slots in
    the new addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Removing elements with pop()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To extract an element from the list, particularly the last one, the `pop()`
    method is a handy tool. When invoked, this method extracts the specified item
    (or the last item if no index is given). The elements situated after the popped
    item get repositioned to maintain memory continuity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The range() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `range()` function can be used to easily generate a large list of numbers.
    It is used to auto-populate sequences of numbers in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range()` function is simple to use. We can use it by just specifying the
    number of elements we want in the list. By default, it starts from zero and increments
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify the end number and the step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding range function will give us odd numbers from `3` to `29`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate through a list, we can use the `for` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `range()` function to generate a list of random numbers. For
    example, to simulate ten trials of a dice, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The time complexity of various functions of a list can be summarized as follows
    using the Big O notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inserting an element**: The insertion of an element at the end of a list
    typically has a constant time complexity, denoted as *O(1)*. This means the time
    taken for this operation remains fairly consistent, irrespective of the list’s
    size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deleting an element**: Deleting an element from a list can have a time complexity
    of *O(n)* in its worst-case scenario. This is because, in the least favorable
    situation, the program might need to traverse the entire list before removing
    the desired element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slicing**: When we slice a list or extract a portion of it, the operation
    can take time proportional to the size of the slice; hence, its time complexity
    is *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element retrieval**: Finding an element within a list, without any indexing,
    can require scanning through all its elements in the worst case. Thus, its time
    complexity is also *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copying**: Creating a copy of the list necessitates visiting every element
    once, leading to a time complexity of *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second data structure that can be used to store a collection is a tuple.
    In contrast to lists, tuples are immutable (read-only) data structures. Tuples
    consist of several elements surrounded by `( )`.
  prefs: []
  type: TYPE_NORMAL
- en: Like lists, elements within a tuple can be of different types. They also allow
    their elements to be complex data types. So, there can be a tuple within a tuple
    providing a way to create a nested data structure. The capability to create nested
    data structures is especially useful in iterative and recursive algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to create tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Wherever possible, immutable data structures (such as tuples) should be preferred
    over mutable data structures (such as lists) due to performance. Especially when
    dealing with big data, immutable data structures are considerably faster than
    mutable ones. When a data structure is passed to a function as immutable, its
    copy does not need to be created as the function cannot change it. So, the output
    can refer to the input data structure. This is called referential transparency
    and improves the performance. There is a price we pay for the ability to change
    data elements in lists and we should carefully analyze whether it is really needed
    so we can implement the code as read-only tuples, which will be much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as Python is a zero-index-based language, `a[2]` refers to the third
    element, which is a tuple, `(100,200,300)`, and `a[2][1]` refers to the second
    element within this tuple, which is `200`.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The time complexity of various functions of tuples can be summarized as follows
    (using Big O notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing an element**: Tuples allow direct access to their elements via
    indexing. This operation is constant time, *O(1)*, meaning the time taken remains
    consistent regardless of the tuple’s size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slicing**: When a portion of a tuple is extracted or sliced, the operation’s
    efficiency is proportional to the size of the slice, resulting in a time complexity
    of *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element retrieval**: Searching for an element in a tuple, in the absence
    of any indexing aid, might require traversing all its elements in the worst-case
    scenario. Hence, its time complexity is *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copying**: Duplicating a tuple, or creating its copy, requires iterating
    through each element once, giving it a time complexity of *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries and sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will discuss sets and dictionaries, which are used to store
    data in which there is no explicit or implicit ordering. Both dictionaries and
    sets are quite similar. The difference is that a dictionary has a key-value pair.
    A set can be thought of as a collection of unique keys.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look into them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Holding data as key-value pairs is important, especially in distributed algorithms.
    In Python, a collection of these key-value pairs is stored as a data structure
    called a dictionary. To create a dictionary, a key should be chosen as an attribute
    that is best suited to identify data throughout data processing. The limitation
    on the value of keys is that they must be hashable types. A hashable is the type
    of object on which we can run the hash function, generating a hash code that never
    changes during its lifetime. This ensures that the keys are unique and searching
    for a key is fast. Numeric types and flat immutable types are all hashable and
    are good choices for the dictionary keys. The value can be an element of any type,
    for example, a number or string. Python also always uses complex data types such
    as lists as values. Nested dictionaries can be created by using a dictionary as
    the data type of a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple dictionary that assigns colors to various variables, the
    key-value pairs need to be enclosed in `{ }`. For example, the following code
    creates a simple dictionary consisting of three key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The three key-value pairs created by the preceding piece of code are also illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18046_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Key-value pairs in a simple dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how to retrieve and update a value associated with a key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve a value associated with a key, either the `get` function can be
    used or the key can be used as the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To update a value associated with a key, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the preceding code shows how we can update a value related to a particular
    key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'When iterating through a dictionary, usually, we will need both the keys and
    the values. We can iterate through a dictionary in Python by using `.items()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To `del` an element from a dictionary, we will use the `del` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of a dictionary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For Python dictionaries, the time complexities for various operations are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing a value by key**: Dictionaries are designed for fast look-ups.
    When you have the key, accessing the corresponding value is, on average, a constant
    time operation, *O(1)*. This holds true unless there’s a hash collision, which
    is a rare scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inserting a key-value pair**: Adding a new key-value pair is generally a
    swift operation with a time complexity of *O(1)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deleting a key-value pair**: Removing an entry from a dictionary, when the
    key is known, is also an *O(1)* operation on average.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching for a key**: Verifying the presence of a key, thanks to hashing
    mechanisms, is usually a constant time, *O(1)*, operation. However, worst-case
    scenarios could elevate this to *O(n)*, especially with many hash collisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copying**: Creating a duplicate of a dictionary necessitates going through
    each key-value pair, resulting in a linear time complexity, *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Closely related to a dictionary is a set, which is defined as an unordered
    collection of distinct elements that can be of different types. One of the ways
    to define a set is to enclose the values in `{ }`. For example, have a look at
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The defining characteristic of a set is that it only stores the distinct value
    of each element. If we try to add another redundant element, it will ignore that,
    as illustrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate what sort of operations can be done on sets, let’s define two
    sets:'
  prefs: []
  type: TYPE_NORMAL
- en: A set named `yellow`, which has things that are yellow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set named `red`, which has things that are red
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that some things are common between these two sets. The two sets and their
    relationship can be represented with the help of the following Venn diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, venn diagram  Description automatically generated](img/B18046_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Venn diagram showing how elements are stored in sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to implement these two sets in Python, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s consider the following code, which demonstrates set operations using
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, sets in Python can have operations
    such as unions and intersections. As we know, a union operation combines all of
    the elements of both sets, and the intersection operation will give a set of common
    elements between the two sets. Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yellow|red` is used to get the union of the preceding two defined sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yellow&red` is used to get the overlap between yellow and red.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As sets are unordered, the items of a set have no index. That means that we
    cannot access the items by referring to an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can loop through the set items using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We can also check if a specified value is present in a set by using the `in`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Time complexity analysis for sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the time complexity analysis for sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sets** | **Complexity** |'
  prefs: []
  type: TYPE_TB
- en: '| Add an element | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove an element | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Copy | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Time complexity for sets'
  prefs: []
  type: TYPE_NORMAL
- en: When to use a dictionary and when to use a set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us assume that we are looking for a data structure for our phone book.
    We want to store the phone numbers of the employees of a company. For this purpose,
    a dictionary is the right data structure. The name of each employee will be the
    key and the value will be the phone number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we want to store only the unique value of the employees, then that should
    be done using sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Using Series and DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing data is one of the core things that need to be done while implementing
    most of the algorithms. In Python, data processing is usually done by using various
    functions and data structures of the `pandas` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look into the following two important data structures
    of the pandas library, which will be used to implement various algorithms later
    in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: A one-dimensional array of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: A two-dimensional data structure used to store tabular data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us look into the Series data structure first.
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `pandas` library, a Series is a one-dimensional array of values for homogenous
    data. We can think of a Series as a single column in a spreadsheet. We can think
    of Series as holding various values of a particular variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Series can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that in `pandas` Series-based data structures, there is a term called “axis,”
    which is used to represent a sequence of values in a particular dimension. *Series*
    has only “axis 0” because it has only one dimension. We will see how this axis
    concept is applied to a DataFrame in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A DataFrame is built upon the Series data structure. It is stored as two-dimensional
    tabular data. It is used to process traditional structured data. Let’s consider
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **id** | **name** | **age** | **decision** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Fares | 32 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Elena | 23 | False |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Doug | 40 | True |'
  prefs: []
  type: TYPE_TB
- en: Now, let’s represent this using a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple DataFrame can be created by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the preceding code, `df.column` is a list that specifies the names
    of the columns. In DataFrame, a single column or row is called an axis.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrames are also used in other popular languages and frameworks to implement
    a tabular data structure. Examples are R and the Apache Spark framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a subset of a DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fundamentally, there are two main ways of creating the subset of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: Column selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Column selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In machine learning algorithms, selecting the right set of features is an important
    task. Out of all of the features that we may have, not all of them may be needed
    at a particular stage of the algorithm. In Python, feature selection is achieved
    by column selection, which is explained in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A column may be retrieved by `name`, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The positioning of a column is deterministic in a DataFrame. A column can be
    retrieved by its position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this code, we are retrieving all rows of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Row selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each row in a DataFrame corresponds to a data point in our problem space. We
    need to perform row selection if we want to create a subset of the data elements
    that we have in our problem space. This subset can be created by using one of
    the two following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: By specifying their position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By specifying a filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A subset of rows can be retrieved by its position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code will return the second and third rows plus all
    columns. It uses the `iloc` method, which allows us to access the elements by
    their numerical index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a subset by specifying the filter, we need to use one or more columns
    to define the selection criterion. For example, a subset of data elements can
    be selected by this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code creates a subset of rows that satisfies the condition stipulated
    in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity analysis for sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s unveil the time complexities of some fundamental DataFrame operations.
  prefs: []
  type: TYPE_NORMAL
- en: Selection operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column selection**: Accessing a DataFrame column, often done using the bracket
    notation or dot notation (for column names without spaces), is an *O(1)* operation.
    It offers a quick reference to the data without copying.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Row selection**: Using methods like `.loc[]` or `.iloc[]` to select rows,
    especially with slicing, has a time complexity of *O(n)*, where “*n*” represents
    the number of rows you’re accessing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column insertion**: Appending a new column to a DataFrame is typically an
    *O(1)* operation. However, the actual time can vary depending on the data type
    and size of the data being added.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Row insertion**: Adding rows using methods like `.append()` or `.concat()`
    can result in an *O(n)* complexity since it often requires rearranging and reallocation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column deletion**: Dropping a column from a DataFrame, facilitated by the
    `.drop()` method, is an *O(1)* operation. It marks the column for garbage collection
    rather than immediate deletion.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Row deletion**: Similar to row insertion, row deletion can lead to an *O(n)*
    time complexity, as the DataFrame has to rearrange its structure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A matrix is a two-dimensional data structure with a fixed number of columns
    and rows. Each element of a matrix can be referred to by its column and the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, a matrix can be created by using a `numpy` array or a list. But
    `numpy` arrays are much faster than lists because they are collections of homogenous
    data elements located in a contiguous memory location. The following code can
    be used to create a matrix from a `numpy` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code will create a matrix that has three rows and three
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many operations available for matrix data manipulation. For example,
    let’s try to transpose the preceding matrix. We will use the `transpose()` function,
    which will convert columns into rows and rows into columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note that matrix operations are used a lot in multimedia data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Big O notation and matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When discussing the efficiency of operations, the Big O notation provides a
    high-level understanding of its impact as data scales:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access**: Accessing an element, whether in a Python list or a `numpy` array,
    is a constant time operation, *O(1)*. This is because, with the index of the element,
    you can directly access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appending**: Appending an element at the end of a Python list is an average-case
    *O(1)* operation. However, for a numpy array, the operation can be *O(n)* in the
    worst case, as the entire array might need to be copied to a new memory location
    if there’s no contiguous space available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matrix multiplication**: This is where numpy shines. Matrix multiplication
    can be computationally intensive. Traditional methods can have a time complexity
    of *O(n*³*)* for *n x n* matrices. However, `numpy` uses optimized algorithms,
    like the Strassen algorithm, which reduces this significantly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned about data structures in Python, let’s move on to abstract
    data types in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring abstract data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Abstract data types** (**ADTs**) are high-level abstractions whose behavior
    is defined by a set of variables and a set of related operations. ADTs define
    the implementation guidance of “what” needs to be expected but give the programmer
    freedom in “how” it will be exactly implemented. Examples are vectors, queues,
    and stacks. This means that two different programmers can take two different approaches
    to implementing an ADT, like a stack. By hiding the implementation level details
    and giving the user a generic, implementation-independent data structure, the
    use of ADTs creates algorithms that result in simpler and cleaner code. ADTs can
    be implemented in any programming language, such as C++, Java, and Scala. In this
    section, we shall implement ADTs using Python. Let’s start with vectors first.'
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A vector is a single-dimension structure for storing data. They are one of
    the most popular data structures in Python. There are two ways of creating vectors
    in Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Python list**: The simplest way to create a vector is by using a
    Python list, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this code will create a list with four elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a numpy array**: Another popular way to create a vector is to use `numpy`
    arrays. `numpy` arrays are generally faster and more memory-efficient than Python
    lists, especially for operations that involve large amounts of data. This is because
    `numpy` is designed to work with homogenous data and can take advantage of low-level
    optimizations. A `numpy` array can be implemented as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we created `myVector` using `np.array` in this code.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can represent integers using underscores to separate parts. This
    makes them more readable and less error-prone. This is especially useful when
    dealing with large numbers. So, one billion can be represented as `1000_000_000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Time complexity of vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When discussing the efficiency of vector operations, it’s vital to understand
    the time complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access**: Accessing an element in both a Python list and a `numpy` array
    (vector) takes constant time, *O(1)*. This ensures rapid data retrieval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appending**: Appending an element to a Python list has an average time complexity
    of *O(1)*. However, for a numpy array, appending could take up to *O(n)* in the
    worst case since numpy arrays require contiguous memory locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: Finding an element in a vector has a time complexity of *O(n)*
    because, in the worst case, you might have to scan through all elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stack is a linear data structure to store a one-dimensional list. It can store
    items either in a **Last-In, First-Out** (**LIFO**) or **First-In, Last-Out**
    (**FILO**) manner. The defining characteristic of a stack is the way elements
    are added to and removed from it. A new element is added at one end and an element
    is removed from that end only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the operations related to stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**isEmpty**: Returns `true` if the stack is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**push**: Adds a new element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pop**: Returns the element added most recently and removes it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2.4* shows how `push` and `pop` operations can be used to add and remove
    data from a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18046_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Push and pop operations'
  prefs: []
  type: TYPE_NORMAL
- en: The top portion of *Figure 2.4* shows the use of `push` operations to add items
    to the stack. In *steps 1.1*, *1.2*, and *1.3*, `push` operations are used three
    times to add three elements to the stack. The bottom portion of the preceding
    diagram is used to retrieve the stored values from the stack. In *steps 2.2* and
    *2.3*, `pop` operations are used to retrieve two elements from the stack in LIFO
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a class named `Stack` in Python, where we will define all of the
    operations related to the `Stack` class. The code of this class will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To push four elements to the stack, the following code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding code creates a stack with four data elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Time complexity of stack operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us look into the time complexity of stack operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: This operation adds an element to the top of the stack. Since it
    doesn’t involve any iteration or checking, the time complexity of the push operation
    is *O(1)*, or constant time. The element is placed on top regardless of the stack’s
    size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pop**: Popping refers to removing the top element from the stack. Given that
    there’s no need to interact with the rest of the stack, the pop operation also
    has a time complexity of *O(1)*. It’s a direct action on the top element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A stack is used as the data structure in many use cases. For example, when a
    user wants to browse the history in a web browser, it is a LIFO data access pattern,
    and a stack can be used to store the history. Another example is when a user wants
    to perform an undo operation in word processing software.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like stacks, a queue stores *n* elements in a single-dimensional structure.
    The elements are added and removed in FIFO format. One end of the queue is called
    the `rear` and the other is called the `front`. When elements are removed from
    the front, the operation is called `dequeue`. When elements are added at the rear,
    the operation is called `enqueue`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following diagram, the top portion shows the enqueue operation. *Steps
    1.1*, *1.2*, and *1.3* add three elements to the queue and the resultant queue
    is shown in *1.4*. Note that **Yellow** is the `rear` and **Red** is the `front`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom portion of the following diagram shows a `dequeue` operation. *Steps
    2.2*, *2.3*, and *2.4* remove elements from the queue one by one from the front
    of the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B18046_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Enqueue and dequeue operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The queue shown in the preceding diagram can be implemented by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s enqueue and dequeue elements as shown in the preceding diagramm with
    the help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code creates a queue first and then enqueues four items
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity analysis for queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us look into the time complexity for queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enqueue**: This operation inserts an element t the end of the queue. Given
    its straightforward nature, without any need for iterating or traversing, the
    `enqueue` operation bears a time complexity of *O(1)* – a constant time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dequeue**: Dequeueing means removing the front element from the queue. As
    the operation only involves the first element without any checks or iterations
    through the queue, its time complexity remains constant at *O(1)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic idea behind the use of stacks and queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look into the basic idea behind the use of stacks and queues using an
    analogy. Let’s assume that we have a table where we put our incoming mail from
    our postal service, for example, Canada Mail. We stack them until we have some
    time to open and look at the letters, one by one. There are two possible ways
    of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: We put the letters in a stack and, whenever we get a new letter, we put it on
    the top of the stack. When we want to read a letter, we start with the one that
    is on top. This is what we call a **stack**. Note that the latest letter to arrive
    will be on the top and will be processed first. Picking up a letter from the top
    of the list is called a `pop` operation. Whenever a new letter arrives, putting
    it on the top is called a `push` operation. If we end up having a sizable stack
    and lots of letters are continuously arriving, there is a chance that we never
    get a chance to reach a very important letter waiting for us at the lower end
    of the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We put the letters in the pile, but we want to handle the oldest letter first;
    every time we want to look at one or more letters, we take care to handle the
    oldest one first. This is what we call a **queue**. Adding a letter to the pile
    is called an `enqueue` operation. Removing the letter from the pile is called
    a `dequeue` operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of algorithms, a tree is one of the most useful data structures
    due to its hierarchical data storage capabilities. While designing algorithms,
    we use trees wherever we need to represent hierarchical relationships among the
    data elements that we need to store or process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look deeper into this interesting and quite important data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Each tree has a finite set of nodes so that it has a starting data element called
    a **root** and a set of nodes joined together by links called **branches**.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look into some of the terminology related to the tree data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Root node** | A node with no parent is called the root node. For example,
    in the following diagram, the root node is A. In algorithms, usually, the root
    node holds the most important value in the tree structure. |'
  prefs: []
  type: TYPE_TB
- en: '| **Level of a node** | The distance from the root node is the level of a node.
    For example, in the following diagram, the level of nodes D, E, and F is two.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Siblings nodes** | Two nodes in a tree are called siblings if they are
    at the same level. For example, if we check the following diagram, nodes B and
    C are siblings. |'
  prefs: []
  type: TYPE_TB
- en: '| **Child and parent node** | Node F is a child of node C if both are directly
    connected and the level of node C is less than node F. Conversely, node C is a
    parent of node F. Nodes C and F in the following diagram show this parent-child
    relationship. |'
  prefs: []
  type: TYPE_TB
- en: '| **Degree of a node** | The degree of a node is the number of children it
    has. For example, in the following diagram, node B has a degree of two. |'
  prefs: []
  type: TYPE_TB
- en: '| **Degree of a tree** | The degree of a tree is equal to the maximum degree
    that can be found among the constituent nodes of a tree. For example, the tree
    presented in the following diagram has a degree of two. |'
  prefs: []
  type: TYPE_TB
- en: '| **Subtree** | A subtree of a tree is a portion of the tree with the chosen
    node as the root node of the subtree and all of the children as the nodes of the
    tree. For example, a subtree at node E of the tree presented in the following
    diagram consists of node E as the root node and nodes G and H as the two children.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Leaf node** | A node in a tree with no children is called a leaf node.
    For example, in the following figure, nodes D, G, H, and F are the four leaf nodes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Internal node** | Any node that is neither a root nor a leaf node is an
    internal node. An internal node will have at least one parent and at least one
    child node. |'
  prefs: []
  type: TYPE_TB
- en: Note that trees are a kind of network or graph that we will study in *Chapter
    6*, *Unsupervised Machine Learning Algorithms*. For graphs and network analysis,
    we use the terms **link** or **edge** instead of branches. Most of the other terminology
    remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Types of trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are different types of trees, which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary tree**: If the degree of a tree is two, that tree is called a *binary
    tree*. For example, the tree shown in the following diagram is a binary tree as
    it has a degree of two:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18046_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: A binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding diagram shows a tree that has four levels with eight
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Full tree**: A full tree is one in which all of the nodes are of the same
    degree, which will be equal to the degree of the tree. The following diagram shows
    the kinds of trees discussed earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18046_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: A full tree'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the binary tree on the left is not a full tree, as node C has a degree
    of one and all other nodes have a degree of two. The tree in the middle and the
    one on the right are both full trees.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perfect tree**: A perfect tree is a special type of full tree in which all
    the leaf nodes are at the same level. For example, the binary tree on the right
    as shown in the preceding diagram is a perfect, full tree as all the leaf nodes
    are at the same level – that is, **level 2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordered tree**: If the children of a node are organized in some order according
    to particular criteria, the tree is called an **ordered tree**. A tree, for example,
    can be ordered from left to right in ascending order in which the nodes at the
    same level will increase in value while traversing from left to right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ADT tree is one of the main data structures that is used in developing decision
    trees, as will be discussed in *Chapter 7*, *Traditional Supervised Learning Algorithms*.
    Due to its hierarchical structure, it is also popular in algorithms related to
    network analysis, as will be discussed in detail in *Chapter 6*, *Unsupervised
    Machine Learning Algorithms*. Trees are also used in various search and sort algorithms
    in which divide and conquer strategies need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed data structures that can be used to implement
    various types of algorithms. After going through this chapter, you should now
    be able to select the right data structure to be used to store and process data
    with an algorithm. You should also be able to understand the implications of our
    choice on the performance of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about sorting and searching algorithms, in which we will
    use some of the data structures presented in this chapter in the implementation
    of the algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1955211820597889031.png)'
  prefs: []
  type: TYPE_IMG
