<html><head></head><body>
  <div id="_idContainer049" class="Basic-Text-Frame">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-79" class="chapterTitle">Sorting and Searching Algorithms</h1>
    <p class="normal">In this chapter, we will look at the algorithms that are used for sorting and searching. This is an important class of algorithms that can be used on their own or can become the foundation <a id="_idIndexMarker199"/>for more complex algorithms. These include <strong class="keyWord">Natural Language Processing</strong> (<strong class="keyWord">NLP</strong>) and pattern-extracting algorithms. This chapter starts by presenting different types of sorting algorithms. It compares the performance of various approaches to designing a sorting algorithm. Then, some searching algorithms are presented in detail. Finally, a practical example of the sorting and searching algorithms presented in this chapter is studied.</p>
    <p class="normal">By the end of this chapter, we should be able to understand the various algorithms that are used for sorting and searching, and we will be able to comprehend their strengths and weaknesses. As searching and sorting algorithms are the building blocks for many complex algorithms, understanding them in detail will help us better understand modern complex algorithms as well, as presented in the later chapters.</p>
    <p class="normal">The following are the main concepts discussed in this chapter:</p>
    <ul>
      <li class="bulletList">Introducing sorting algorithms</li>
      <li class="bulletList">Introducing searching algorithms</li>
      <li class="bulletList">Performance analysis of sorting and searching algorithms</li>
      <li class="bulletList">Practical applications of sorting and searching</li>
    </ul>
    <p class="normal">Let’s first look at some sorting algorithms.</p>
    <h1 id="_idParaDest-80" class="heading-1">Introducing sorting algorithms</h1>
    <p class="normal">The ability to efficiently sort and search items in a complex data structure is important as it is needed by many modern algorithms. The right strategy to sort and search data will depend <a id="_idIndexMarker200"/>on the size and type of the data, as discussed in this chapter. While the end result is exactly the same, the right sorting and searching algorithm will be needed for an efficient solution to a real-world problem. Thus, carefully analyzing the performance of these algorithms is important.</p>
    <p class="normal">Sorting algorithms are used extensively in distributed data storage systems such as modern NoSQL databases that enable cluster and cloud computing architectures. In such data storage systems, data elements need to be regularly sorted and stored so that they can be retrieved efficiently.</p>
    <p class="normal">The following sorting algorithms are presented in this chapter:</p>
    <ul>
      <li class="bulletList">Bubble sort</li>
      <li class="bulletList">Merge sort</li>
      <li class="bulletList">Insertion sort</li>
      <li class="bulletList">Shell sort</li>
      <li class="bulletList">Selection sort</li>
    </ul>
    <p class="normal">But before we look into these algorithms, let us first discuss the variable-swapping technique in Python that we will be using in the code presented in this chapter.</p>
    <h2 id="_idParaDest-81" class="heading-2">Swapping variables in Python</h2>
    <p class="normal">When <a id="_idIndexMarker201"/>implementing sorting and searching algorithms, we <a id="_idIndexMarker202"/>need to swap the values <a id="_idIndexMarker203"/>of two variables. In Python, there is a standard way to swap two variables, which is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">var_1 = <span class="hljs-number">1</span>
var_2 = <span class="hljs-number">2</span>
var_1, var_2 = var_2, var_1
<span class="hljs-built_in">print</span>(var_1,var_2)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">2, 1
</code></pre>
    <p class="normal">This simple way of swapping values is used throughout the sorting and searching algorithms in this chapter.</p>
    <p class="normal">Let’s start by looking at the bubble sort algorithm in the next section.</p>
    <h2 id="_idParaDest-82" class="heading-2">Bubble sort</h2>
    <p class="normal">Bubble sort is one of the simplest and slowest algorithms used for sorting. It is designed in such a <a id="_idIndexMarker204"/>way that the highest value in a list of data <em class="italic">bubbles</em> makes its way to the top as the algorithm loops through iterations. Bubble sort requires little runtime memory to run because all the ordering occurs within the original data <a id="_idIndexMarker205"/>structure. No new data structures are needed as temporary buffers. But its worst-case performance is <em class="italic">O(N2)</em>, which is quadratic time complexity (where <em class="italic">N</em> is the number of elements being sorted). As discussed in the following section, it is recommended to be used only for smaller datasets. Actual recommended limits for the size of the data for the use of bubble sort for sorting will depend on the memory and the processing resources available but keeping the number of elements (<em class="italic">N</em>) below 1000 can be considered as a general recommendation.</p>
    <h3 id="_idParaDest-83" class="heading-3">Understanding the logic behind bubble sort</h3>
    <p class="normal">Bubble sort is based on various iterations, called passes. For a list of size <em class="italic">N</em>, bubble sort will have <em class="italic">N-1</em> passes. To understand its working, let’s focus on the first iteration: pass one.</p>
    <p class="normal">The goal <a id="_idIndexMarker206"/>of pass one is to push the highest value to the highest index (top of the list). In other words, we will see the highest value of the list <em class="italic">bubbling</em> its way to the top as pass one progresses.</p>
    <p class="normal">Bubble sort’s logic is based on comparing adjacent neighbor values. If the value at a higher index is higher in value than the value at a lower index, we exchange the values. This iteration continues until we reach the end of the list. This is shown in <em class="italic">Figure 3.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_03_01.png" alt="A picture containing text, electronics  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.1: Bubble sort algorithm</p>
    <p class="normal">Let’s now see how bubble sort can be implemented using Python. If we implement pass one of bubble sort in Python, it will look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">list</span> = [<span class="hljs-number">25</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">24</span>,<span class="hljs-number">23</span>,<span class="hljs-number">27</span>,<span class="hljs-number">26</span>]
last_element_index = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>)-<span class="hljs-number">1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">list</span>)
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(last_element_index):
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[idx]&gt;<span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>]:
                    <span class="hljs-built_in">list</span>[idx],<span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>]=<span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>],<span class="hljs-built_in">list</span>[idx]
                <span class="hljs-built_in">print</span>(idx+<span class="hljs-number">1</span>,<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">0 [25, 21, 22, 24, 23, 27, 26]
1 [21, 25, 22, 24, 23, 27, 26]
2 [21, 22, 25, 24, 23, 27, 26]
3 [21, 22, 24, 25, 23, 27, 26]
4 [21, 22, 24, 23, 25, 27, 26]
5 [21, 22, 24, 23, 25, 27, 26]
6 [21, 22, 24, 23, 25, 26, 27]
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker207"/>after the <em class="italic">first pass</em>:</p>
    <ul>
      <li class="bulletList">The highest value is at the top of the list, stored at <code class="inlineCode">idx+1</code>.</li>
      <li class="bulletList">While executing the first pass, the algorithm has to compare each of the elements of the list individually to <em class="italic">bubble</em> the maximum value to the top.</li>
    </ul>
    <p class="normal">After completing the first pass, the algorithm moves on to the <em class="italic">second pass</em>. The goal of the second pass is to move the second-highest value to the second-highest index of the list. To do that, the algorithm will again compare adjacent neighbor values, exchanging them if they are not in order. The second pass will exclude the value at the top index, which was put in the right place by the first pass. So, it will have one less data element to tackle.</p>
    <p class="normal">After completing the second pass, the algorithm keeps on performing the third pass and subsequent ones until all the data points of the list are in ascending order. The algorithm will need <em class="italic">N-1</em> passes for a list of size <em class="italic">N</em> to completely sort it. </p>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 24, 23, 25, 26, 27]
</code></pre>
    <p class="normal">We mentioned that performance is one of the limitations of the bubble sort algorithm. Let’s quantify <a id="_idIndexMarker208"/>the performance of bubble sort through the performance analysis of the bubble sort algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span>(<span class="hljs-built_in">list</span>):
<span class="hljs-comment"># Exchange the elements to arrange in order</span>
    last_element_index = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>)-<span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> pass_no <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(last_element_index,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pass_no):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[idx]&gt;<span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>]:
                <span class="hljs-built_in">list</span>[idx],<span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>]=<span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>],<span class="hljs-built_in">list</span>[idx]
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>
<span class="hljs-built_in">list</span> = [<span class="hljs-number">25</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">24</span>,<span class="hljs-number">23</span>,<span class="hljs-number">27</span>,<span class="hljs-number">26</span>]
<span class="hljs-title">bubble_sort</span>(<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 23, 24, 25, 26, 27]
</code></pre>
    <h3 id="_idParaDest-84" class="heading-3">Optimizing bubble sort</h3>
    <p class="normal">The above implementation of bubble sort implemented with the <code class="inlineCode">bubble_sort</code> function is a straightforward sorting method where adjacent elements are repeatedly compared and swapped <a id="_idIndexMarker209"/>if they are out of order. The algorithm consistently requires <em class="italic">O(N2)</em> comparisons and swaps in the worst-case scenario, where <em class="italic">N</em> is the number of elements in the list. This is because, for a list of <em class="italic">N</em> elements, the algorithm invariably goes through <em class="italic">N-1</em> passes, regardless of the initial order of the list.</p>
    <p class="normal">The following is an optimized version of bubble sort:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">optimized_bubble_sort</span>(<span class="hljs-built_in">list</span>):
    last_element_index = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>)-<span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> pass_no <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(last_element_index, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):
        swapped = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pass_no):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[idx] &gt; <span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>]:
                <span class="hljs-built_in">list</span>[idx], <span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>[idx+<span class="hljs-number">1</span>], <span class="hljs-built_in">list</span>[idx]
                swapped = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> swapped:
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>
<span class="hljs-built_in">list</span> = [<span class="hljs-number">25</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">24</span>,<span class="hljs-number">23</span>,<span class="hljs-number">27</span>,<span class="hljs-number">26</span>]
<span class="hljs-title">optimized_bubble_sort</span>(<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 23, 24, 25, 26, 27]
</code></pre>
    <p class="normal">The <code class="inlineCode">optimized_bubble_sort</code> function introduces a notable enhancement to the bubble sort algorithm’s performance. By adding a <code class="inlineCode">swapped</code> flag, this optimization permits the algorithm to detect early if the list is already sorted before making all <em class="italic">N-1</em> passes. When a pass completes without any swaps, it’s a clear indicator that the list has been sorted, and the algorithm can exit prematurely. Therefore, while the worst-case time complexity remains <em class="italic">O(N2)</em> for completely unsorted or reverse-sorted lists, the best-case complexity improves to <em class="italic">O(N)</em> for already sorted lists due to this optimization.</p>
    <p class="normal">In essence, while both <a id="_idIndexMarker210"/>functions have a worst-case time complexity of <em class="italic">O(N2)</em>, the <code class="inlineCode">optimized_bubble_sort</code> has the potential to perform significantly faster in real-world scenarios where data might be partially sorted, making it a more efficient version of the conventional bubble sort algorithm.</p>
    <h3 id="_idParaDest-85" class="heading-3">Performance analysis of the bubble sort algorithm</h3>
    <p class="normal">It is <a id="_idIndexMarker211"/>easy to see that bubble sort involves two levels of loops:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">An outer loop</strong>: These <a id="_idIndexMarker212"/>are also <a id="_idIndexMarker213"/>called <strong class="keyWord">passes</strong>. For example, pass one is the first iteration of the outer loop.</li>
      <li class="bulletList"><strong class="keyWord">An inner loop</strong>: This is <a id="_idIndexMarker214"/>when the remaining unsorted elements in the list are sorted until the highest value is bubbled to the right. The first pass will have <em class="italic">N-1</em> comparisons, the second pass will have <em class="italic">N-2</em> comparisons, and each subsequent pass will reduce the number of comparisons by one.</li>
    </ul>
    <p class="normal">The time complexity of the bubble sort algorithm is as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Best case</strong>: If the <a id="_idIndexMarker215"/>list is already sorted (or almost all elements are sorted), then the runtime complexity is <em class="italic">O(1)</em>.</li>
      <li class="bulletList"><strong class="keyWord">Worst case</strong>: If none <a id="_idIndexMarker216"/>or very few elements are sorted, then the worst-case runtime complexity is <em class="italic">O(n2)</em> as the algorithm will have to completely run through both the inner and outer loops.</li>
    </ul>
    <p class="normal">Now let us look into the insertion sort algorithm.</p>
    <h2 id="_idParaDest-86" class="heading-2">Insertion sort</h2>
    <p class="normal">The basic idea of insertion sort is that in each iteration, we remove a data point from the data <a id="_idIndexMarker217"/>structure we have and then insert it into its right position. That is why <a id="_idIndexMarker218"/>we call this the insertion sort algorithm.</p>
    <p class="normal">In the first iteration, we select the two data points and sort them. Then, we expand our selection and select the third data point and find its correct position, based on its value. The algorithm progresses until all the data points are moved to their correct positions. </p>
    <p class="normal">This process <a id="_idIndexMarker219"/>is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_03_02.png" alt="A picture containing table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.2: Insertion sort algorithm</p>
    <p class="normal">The insertion <a id="_idIndexMarker220"/>sort algorithm can be coded in Python as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">insertion_sort</span>(<span class="hljs-params">elements</span>):
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(elements)):
        j = i - <span class="hljs-number">1</span>
        next_element = elements[i]
        <span class="hljs-comment"># Iterate backward through the sorted portion, </span>
        <span class="hljs-comment"># looking for the appropriate position for 'next_element'</span>
        <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> elements[j] &gt; next_element:
            elements[j + <span class="hljs-number">1</span>] = elements[j]
            j -= <span class="hljs-number">1</span>
        elements[j + <span class="hljs-number">1</span>] = next_element
    <span class="hljs-keyword">return</span> elements
<span class="hljs-built_in">list</span> = [<span class="hljs-number">25</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">24</span>,<span class="hljs-number">23</span>,<span class="hljs-number">27</span>,<span class="hljs-number">26</span>]
<span class="hljs-title">insertion_sort</span>(<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 23, 24, 25, 26, 27]
</code></pre>
    <p class="normal">In the core loop of the algorithm, we traverse through each element of the list starting from the second element (indexed at<em class="italic"> 1</em>). For each element, the algorithm checks the preceding elements to find their correct position in the sorted sublist. This check is performed in the condition <code class="inlineCode">elements[j] &gt; next_element</code>, ensuring that we’re placing our current ‘<code class="inlineCode">next_element</code>' in the appropriate position in the sorted portion of the list.</p>
    <p class="normal">Let’s look at the performance of the insertion sort algorithm.</p>
    <h3 id="_idParaDest-87" class="heading-3">Performance analysis of the insertion sort algorithm</h3>
    <p class="normal">Understanding the efficiency of an algorithm is crucial in determining its suitability for different <a id="_idIndexMarker221"/>applications. Let’s delve into the performance characteristics of the insertion sort.</p>
    <p class="normal"><strong class="keyWord">Best case scenario</strong></p>
    <p class="normal">When the input data is already sorted, insertion sort demonstrates its best behavior. In such cases, the algorithm efficiently runs in linear time, denoted as <em class="italic">O(n)</em>, where <em class="italic">n</em> represents the number of elements in the data structure.</p>
    <p class="normal"><strong class="keyWord">Worst case scenario</strong></p>
    <p class="normal">The efficiency takes a hit when the input is in reverse order, meaning the largest element is at the beginning. Here, for every element <em class="italic">i</em> (where <em class="italic">i</em> stands for the current element’s index in the loop), the inner loop might need to shift almost all preceding elements. The performance of insertion sort in this scenario can be represented mathematically by a quadratic function of the form:</p>
    <p class="center"><a id="_idIndexMarker222"/><img src="../Images/B18046_03_001.png" alt="" role="presentation"/></p>
    <p class="normal">where:</p>
    <ul>
      <li class="bulletList"><em class="italic">w</em> is a weighting factor, adjusting the effect of <em class="italic">i</em><sup class="superscript-italic" style="font-style: italic;">2</sup>.</li>
      <li class="bulletList"><em class="italic">N</em> represents a coefficient that scales with the size of the input.</li>
      <li class="bulletList"><a id="_idIndexMarker223"/><img src="../Images/B18046_03_002.png" alt="" role="presentation"/> is a constant, typically representing minor overheads not covered by the other terms.</li>
    </ul>
    <p class="normal"><strong class="keyWord">Average case scenario</strong></p>
    <p class="normal">Generally, the average performance of insertion sort tends to be quadratic, which can be problematic for larger datasets.</p>
    <p class="normal"><strong class="keyWord">Use cases and recommendations</strong></p>
    <p class="normal">Insertion sort is exceptionally efficient for:</p>
    <ul>
      <li class="bulletList">Small datasets.</li>
      <li class="bulletList">Nearly sorted datasets, where only a few elements are out of order.</li>
    </ul>
    <p class="normal">However, for larger, more random datasets, algorithms with better average and worst-case performances, like merge sort or quick sort, are more suitable. Insertion sort’s quadratic time complexity makes it less scalable for substantial amounts of data.</p>
    <h2 id="_idParaDest-88" class="heading-2">Merge sort</h2>
    <p class="normal">Merge sort stands distinctively among sorting algorithms, like bubble sort and insertion sort, for its <a id="_idIndexMarker224"/>unique approach. Historically, it’s noteworthy that John von Neumann introduced this technique in 1940. While many sorting algorithms <a id="_idIndexMarker225"/>perform better on partially sorted data, merge sort remains unfazed; its performance remains consistent irrespective of the initial arrangement of the data. This resilience makes it the preferred choice for sorting large datasets.</p>
    <p class="normal"><strong class="keyWord">Divide and conquer: the core of merge sort</strong></p>
    <p class="normal">Merge sort employs a divide-and-conquer strategy comprising two key phases – splitting and merging:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Splitting phase</strong>: Unlike <a id="_idIndexMarker226"/>directly iterating over the list, this phase recursively divides the dataset into halves. This division continues until each section reaches a minimal size (for illustrative purposes, let’s say a single element). While it might seem counterintuitive to split data to such granular levels, this granularity facilitates the organized merging in the next phase.</li>
      <li class="numberedList"><strong class="keyWord">Merging phase</strong>: Here, the <a id="_idIndexMarker227"/>previously divided parts are systematically merged. The algorithm continually processes and combines these sections until the entire list is sorted.</li>
    </ol>
    <p class="normal">Refer to <em class="italic">Figure 3.3</em> for a visual representation of the merge sort algorithm.</p>
    <figure class="mediaobject"><img src="../Images/B18046_03_03.png" alt="A diagram of a program  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 3.3: Merge sort algorithm</p>
    <p class="normal"><strong class="keyWord">Pseudocode overview</strong></p>
    <p class="normal">Before delving <a id="_idIndexMarker228"/>into the actual code, let’s understand its logic with some pseudocode:</p>
    <pre class="programlisting code"><code class="hljs-code">merge_sort (elements, start, end)
    <span class="hljs-keyword">if</span>(start &lt; end)
        midPoint = (end - start) / <span class="hljs-number">2</span> + start
        merge_sort (elements, start, midPoint)
        merge_sort (elements, midPoint + <span class="hljs-number">1</span>, end)
        merge(elements, start, midPoint, end)
</code></pre>
    <p class="normal">The pseudocode gives a snapshot of the algorithm’s steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Divide the list around a central <code class="inlineCode">midPoint</code>.</li>
      <li class="numberedList">Recursively split until each section has just one element.</li>
      <li class="numberedList">Systematically merge the sorted sections into a comprehensive sorted list.</li>
    </ol>
    <p class="normal"><strong class="keyWord">Python implementation</strong></p>
    <p class="normal">Here’s <a id="_idIndexMarker229"/>the Python rendition of merge sort:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">elements</span>):
    <span class="hljs-comment"># Base condition to break the recursion</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elements) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> elements
    mid = <span class="hljs-built_in">len</span>(elements) // <span class="hljs-number">2</span>  <span class="hljs-comment"># Split the list in half</span>
    left = elements[:mid]
    right = elements[mid:]
    merge_sort(left)   <span class="hljs-comment"># Sort the left half</span>
    merge_sort(right)  <span class="hljs-comment"># Sort the right half</span>
    a, b, c = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    <span class="hljs-comment"># Merge the two halves</span>
    <span class="hljs-keyword">while</span> a &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> b &lt; <span class="hljs-built_in">len</span>(right):
        <span class="hljs-keyword">if</span> left[a] &lt; right[b]:
            elements[c] = left[a]
            a += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            elements[c] = right[b]
            b += <span class="hljs-number">1</span>
        c += <span class="hljs-number">1</span>
    <span class="hljs-comment"># If there are remaining elements in the left half</span>
    <span class="hljs-keyword">while</span> a &lt; <span class="hljs-built_in">len</span>(left):
        elements[c] = left[a]
        a += <span class="hljs-number">1</span>
        c += <span class="hljs-number">1</span>
    <span class="hljs-comment"># If there are remaining elements in the right half</span>
    <span class="hljs-keyword">while</span> b &lt; <span class="hljs-built_in">len</span>(right):
        elements[c] = right[b]
        b += <span class="hljs-number">1</span>
        c += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> elements
<span class="hljs-built_in">list</span> = [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>]
<span class="hljs-title">merge_sort</span>(<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 23, 24, 25, 26, 27]
</code></pre>
    <h2 id="_idParaDest-89" class="heading-2">Shell sort</h2>
    <p class="normal">The bubble <a id="_idIndexMarker230"/>sort algorithm compares immediate neighbors and exchanges <a id="_idIndexMarker231"/>them if they are out of order. On the other hand, insertion sort creates the sorted list by transferring one element at a time. If we have a partially sorted list, insertion sort should give reasonable performance.</p>
    <p class="normal">But for a totally unsorted list, sized <em class="italic">N</em>, you can argue that bubble sort will have to fully iterate through <em class="italic">N-1</em> passes in order to get it fully sorted.</p>
    <p class="normal">Donald Shell proposed Shell sort (named after him), which questions the importance of selecting immediate neighbors for comparison and swapping.</p>
    <p class="normal">Now, let’s understand this concept.</p>
    <p class="normal">In pass one, instead of selecting immediate neighbors, we use elements that are at a fixed gap, eventually sorting a sublist consisting of a pair of data points. This is shown in the following diagram. In pass two, it sorts sublists containing four data points (see the following diagram). In subsequent passes, the number of data points per sublist keeps on increasing <a id="_idIndexMarker232"/>and the number of sublists keeps on decreasing <a id="_idIndexMarker233"/>until we reach a situation where there is just one sublist that consists of all the data points. </p>
    <p class="normal">At this point, we can assume that the list is sorted:</p>
    <figure class="mediaobject"><img src="../Images/B18046_03_04.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.4: Passes in the Shell sort algorithm</p>
    <p class="normal">In Python, the code for implementing the Shell sort algorithm is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span>(<span class="hljs-params">elements</span>):
    distance = <span class="hljs-built_in">len</span>(elements) // <span class="hljs-number">2</span>
    <span class="hljs-keyword">while</span> distance &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(distance, <span class="hljs-built_in">len</span>(elements)):
            temp = elements[i]
            j = i
<span class="hljs-comment"># Sort the sub list for this distance</span>
            <span class="hljs-keyword">while</span> j &gt;= distance <span class="hljs-keyword">and</span> elements[j - distance] &gt; temp:
                <span class="hljs-built_in">list</span>[j] = elements[j - distance]
                j = j-distance
            <span class="hljs-built_in">list</span>[j] = temp
<span class="hljs-comment"># Reduce the distance for the next element</span>
        distance = distance//<span class="hljs-number">2</span>
    <span class="hljs-keyword">return</span> elements
<span class="hljs-built_in">list</span> = [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>]
<span class="hljs-title">shell_sort</span>(<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 23, 24, 25, 26, 27]
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker234"/>calling the <code class="inlineCode">ShellSort</code> function has resulted in sorting <a id="_idIndexMarker235"/>the input array.</p>
    <h3 id="_idParaDest-90" class="heading-3">Performance analysis of the Shell sort algorithm</h3>
    <p class="normal">It can be observed that, in the worst case, the Shell sort algorithm will have to run through <a id="_idIndexMarker236"/>both loops giving it a complexity of <em class="italic">O(n2)</em>. Shell sort is not for big data. It is used for medium-sized datasets. Roughly speaking, it has a reasonably good performance on a list with up to 6,000 elements. If the data is partially in the correct order, the performance will be better. In a best-case scenario, if a list is already sorted, it will only need one pass through <em class="italic">N</em> elements to validate the order, producing a best-case performance of <em class="italic">O(N)</em>.</p>
    <h2 id="_idParaDest-91" class="heading-2">Selection sort</h2>
    <p class="normal">As we saw earlier in this chapter, bubble sort is one of the simplest sorting algorithms. Selection <a id="_idIndexMarker237"/>sort is an improvement on bubble sort, where we try to minimize the total number of swaps required with the algorithm. It is designed to make one swap for each pass, compared to <em class="italic">N-1</em> passes with the bubble sort algorithm. Instead of bubbling the largest value toward the top in baby steps (as done in bubble sort, resulting in <em class="italic">N-1</em> swaps), we look for the largest value in each pass and move it toward the top. So, after the first pass, the largest value will be at the top. After the second pass, the second largest value will be next to the top value. As the algorithm progresses, the subsequent values will move to their correct place based on their values. </p>
    <p class="normal">The last <a id="_idIndexMarker238"/>value will be moved after the <em class="italic">(N-1)</em><sup class="superscript">th</sup> pass. So, selection sort takes <em class="italic">N-1</em> passes to sort <em class="italic">N</em> items:</p>
    <figure class="mediaobject"><img src="../Images/B18046_03_05.png" alt="Picture 16"/></figure>
    <p class="packt_figref">Figure 3.5: Selection sort algorithm</p>
    <p class="normal">The implementation of selection sort in Python is shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span>(<span class="hljs-built_in">list</span>):
    <span class="hljs-keyword">for</span> fill_slot <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):
        max_index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> location <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, fill_slot + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[location] &gt; <span class="hljs-built_in">list</span>[max_index]:
                max_index = location
        <span class="hljs-built_in">list</span>[fill_slot],<span class="hljs-built_in">list</span>[max_index] = <span class="hljs-built_in">list</span>[max_index],<span class="hljs-built_in">list</span>[fill_slot]
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>
<span class="hljs-built_in">list</span> = [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>]
<span class="hljs-title">selection_sort</span>(<span class="hljs-built_in">list</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[21, 22, 23, 24, 25, 26, 27]
</code></pre>
    <h3 id="_idParaDest-92" class="heading-3">Performance analysis of the selection sort algorithm</h3>
    <p class="normal">Selection <a id="_idIndexMarker239"/>sort’s worst-case performance is <em class="italic">O(N2)</em>. Note that its worst performance is similar to bubble sort, and it should not be used for sorting larger datasets. Still, selection sort is a better-designed algorithm than bubble sort and its average performance is better than bubble sort due to the reduction in the number of exchanges.</p>
    <h2 id="_idParaDest-93" class="heading-2">Choosing a sorting algorithm</h2>
    <p class="normal">When it comes to sorting algorithms, there isn’t a one-size-fits-all solution. The optimal choice often <a id="_idIndexMarker240"/>hinges on the specific circumstances surrounding your data, such as its size and current state. Here, we’ll delve into how to make an informed decision and highlight some real-world examples.</p>
    <p class="normal"><strong class="keyWord">Small and already sorted lists</strong></p>
    <p class="normal">For petite datasets, especially those already in order, it’s usually overkill to deploy a sophisticated algorithm. While an algorithm like merge sort is undeniably powerful, its complexities might overshadow its benefits for small data.</p>
    <p class="normal"><em class="italic">Real-life example</em>: Imagine sorting a handful of books on a shelf by their authors’ last names. It’s simpler and quicker to just scan through and rearrange them manually (akin to a bubble sort) than to employ a detailed sorting method.</p>
    <p class="normal"><strong class="keyWord">Partially sorted data</strong></p>
    <p class="normal">When dealing with data that’s already somewhat organized, algorithms like insertion sort shine. They capitalize on the existing order, enhancing efficiency.</p>
    <p class="normal"><em class="italic">Real-life example</em>: Consider a classroom scenario. If students line up by height but a few are slightly out of place, the teacher can easily spot and adjust these minor discrepancies (mimicking insertion sort), rather than reordering the entire line.</p>
    <p class="normal"><strong class="keyWord">Large datasets</strong></p>
    <p class="normal">For extensive data, where the sheer volume can be overwhelming, merge sort proves to be a reliable ally. Its divide-and-conquer strategy efficiently tackles big lists, making it an industry favorite.</p>
    <p class="normal"><em class="italic">Real-life example</em>: Think about a massive library that receives thousands of books. Sorting these by publication date or author necessitates a systematic approach. Here, a method like merge sort, which breaks down the task into manageable chunks, is invaluable.</p>
    <h1 id="_idParaDest-94" class="heading-1">Introduction to searching algorithms</h1>
    <p class="normal">At the heart of many computational tasks lies a fundamental need: locating specific data within complex structures. On the surface, the most straightforward approach might be to scan every <a id="_idIndexMarker241"/>single data point until you find your target. But, as we can imagine, this method loses its sheen as the volume of data swells.</p>
    <p class="normal">Why is searching so critical? Whether it’s a user querying a database, a system accessing files, or an application fetching specific data, efficient searching determines the speed and responsiveness of these operations. Without adept searching techniques, systems can become sluggish, especially with burgeoning datasets.</p>
    <p class="normal">As the need for fast data retrieval rises, the role of sophisticated search algorithms becomes undeniable. They provide the agility and efficiency needed to wade through vast amounts of data, ensuring that systems remain nimble and users are satisfied. Thus, search algorithms act as the navigators of the digital realm, guiding us to the precise data we seek amid a sea of information.</p>
    <p class="normal">The following searching algorithms are presented in this section:</p>
    <ul>
      <li class="bulletList">Linear search</li>
      <li class="bulletList">Binary search</li>
      <li class="bulletList">Interpolation search</li>
    </ul>
    <p class="normal">Let’s look at each of them in more detail.</p>
    <h2 id="_idParaDest-95" class="heading-2">Linear search</h2>
    <p class="normal">One of the simplest strategies for searching data is to simply loop through each element looking for the target. Each data point is searched for a match and, when a match is found, the results <a id="_idIndexMarker242"/>are returned and the algorithm <a id="_idIndexMarker243"/>exits the loop. Otherwise, the algorithm keeps on searching until it reaches the end of the data. The obvious disadvantage of linear search is that it is very slow due to the inherent exhaustive search. The advantage is that the data does not need to be sorted, as required by the other algorithms presented in this chapter.</p>
    <p class="normal">Let’s look at the code for linear search:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">linear_search</span>(<span class="hljs-params">elements, item</span>):
    index = <span class="hljs-number">0</span>
    found = <span class="hljs-literal">False</span>
<span class="hljs-comment"># Match the value with each data element       </span>
    <span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(elements) <span class="hljs-keyword">and</span> found <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:
        <span class="hljs-keyword">if</span> elements[index] == item:
            found = <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            index = index + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> found
</code></pre>
    <p class="normal">Let’s now <a id="_idIndexMarker244"/>look at <a id="_idIndexMarker245"/>the output of the preceding code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">list</span> = [<span class="hljs-number">12</span>, <span class="hljs-number">33</span>, <span class="hljs-number">11</span>, <span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">55</span>, <span class="hljs-number">90</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-title">linear_search</span>(<span class="hljs-built_in">list</span>, <span class="hljs-number">12</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-title">linear_search</span>(<span class="hljs-built_in">list</span>, <span class="hljs-number">91</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">True
False
</code></pre>
    <p class="normal">Note that running the <code class="inlineCode">LinearSearch</code> function returns a <code class="inlineCode">True</code> value if it can successfully find the data.</p>
    <h3 id="_idParaDest-96" class="heading-3">Performance analysis of the linear search algorithm</h3>
    <p class="normal">As discussed, linear <a id="_idIndexMarker246"/>search is a simple algorithm that performs an exhaustive search. Its worst-case behavior is <code class="inlineCode">O(N)</code>. More info can be found at <a href="https://wiki.python.org/moin/TimeComplexity"><span class="url">https://wiki.python.org/moin/TimeComplexity</span></a>.</p>
    <h2 id="_idParaDest-97" class="heading-2">Binary search</h2>
    <p class="normal">The prerequisite <a id="_idIndexMarker247"/>of the binary search algorithm is sorted data. The algorithm <a id="_idIndexMarker248"/>iteratively divides a list into two parts and keeps track of the lowest and highest indices until it finds the value it is looking for:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">elements, item</span>):
    first = <span class="hljs-number">0</span>
    last = <span class="hljs-built_in">len</span>(elements) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> first&lt;=last:
        midpoint = (first + last) // <span class="hljs-number">2</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">elements</span>[midpoint] == item:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> item &lt; elements[midpoint]:
                last = midpoint - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                first = midpoint + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
    <p class="normal">The <a id="_idIndexMarker249"/>output is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">list</span> = [<span class="hljs-number">12</span>, <span class="hljs-number">33</span>, <span class="hljs-number">11</span>, <span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">55</span>, <span class="hljs-number">90</span>]
sorted_list = <span class="hljs-title">bubble_sort</span>(<span class="hljs-built_in">list</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-title">binary_search</span>(<span class="hljs-built_in">list</span>, <span class="hljs-number">12</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-title">binary_search</span>(<span class="hljs-built_in">list</span>, <span class="hljs-number">91</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">True
False
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker250"/>calling the <code class="inlineCode">BinarySearch</code> function will return <code class="inlineCode">True</code> if the value is found in the input list.</p>
    <h3 id="_idParaDest-98" class="heading-3">Performance analysis of the binary search algorithm</h3>
    <p class="normal">Binary search <a id="_idIndexMarker251"/>is so named because, at each iteration, the algorithm divides the data into two parts. If the data has N items, it will take a maximum of <code class="inlineCode">O(logN)</code> steps to iterate. This means that the algorithm has an <code class="inlineCode">O(logN)</code> runtime.</p>
    <h2 id="_idParaDest-99" class="heading-2">Interpolation search</h2>
    <p class="normal">Binary search is based on the logic that it focuses on the middle section of the data. Interpolation <a id="_idIndexMarker252"/>search is more sophisticated. It uses the target value to estimate the position of the element in the sorted array. Let’s try to understand it by using an example. Let’s assume we want to search for a word in an English dictionary, such as the word <em class="italic">river</em>. We will use this information to interpolate and start searching for words starting with <em class="italic">r</em>. A more generalized interpolation search can be programmed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">int_polsearch</span>(<span class="hljs-built_in">list</span><span class="hljs-params">,x </span>):
    idx0 = <span class="hljs-number">0</span>
    idxn = (<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>) - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> idx0 &lt;= idxn <span class="hljs-keyword">and</span> x &gt;= <span class="hljs-built_in">list</span>[idx0] <span class="hljs-keyword">and</span> x &lt;= <span class="hljs-built_in">list</span>[idxn]:
<span class="hljs-comment"># Find the mid point</span>
        mid = idx0 +<span class="hljs-built_in">int</span>(((<span class="hljs-built_in">float</span>(idxn - idx0)/(<span class="hljs-built_in">list</span>[idxn] - <span class="hljs-built_in">list</span>[idx0])) * (x - <span class="hljs-built_in">list</span>[idx0])))
<span class="hljs-comment"># Compare the value at mid point with search value </span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[mid] == x:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[mid] &lt; x:
            idx0 = mid + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
    <p class="normal">The output <a id="_idIndexMarker253"/>is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">list</span> = [<span class="hljs-number">12</span>, <span class="hljs-number">33</span>, <span class="hljs-number">11</span>, <span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">55</span>, <span class="hljs-number">90</span>]
sorted_list = <span class="hljs-title">bubble_sort</span>(<span class="hljs-built_in">list</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-title">int_polsearch</span>(<span class="hljs-built_in">list</span>, <span class="hljs-number">12</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-title">int_polsearch</span>(<span class="hljs-built_in">list</span>, <span class="hljs-number">91</span>))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">True
False
</code></pre>
    <p class="normal">Note that before using <code class="inlineCode">IntPolsearch</code>, the array first needs to be sorted using a sorting algorithm.</p>
    <h3 id="_idParaDest-100" class="heading-3">Performance analysis of the interpolation search algorithm</h3>
    <p class="normal">If the data <a id="_idIndexMarker254"/>is unevenly distributed, the performance of the interpolation search algorithm will be poor. The worst-case performance of this algorithm is <em class="italic">O(N)</em>, and if the data is somewhat reasonably uniform, the best performance is <code class="inlineCode">O(log(log N))</code>.</p>
    <h1 id="_idParaDest-101" class="heading-1">Practical applications</h1>
    <p class="normal">The ability to efficiently and accurately search data in a given data repository is critical to many real-life applications. Depending on your choice of searching algorithm, you may need to sort <a id="_idIndexMarker255"/>the data first as well. The choice of the right sorting and searching algorithms will depend on the type and the size of the data, as well as the nature of the problem you are trying to solve.</p>
    <p class="normal">Let’s try to use the algorithms presented in this chapter to solve the problem of matching a new applicant at the immigration department of a certain country with historical records. When someone applies for a visa to enter the country, the system tries to match the applicant with the existing historical records. If at least one match is found, then the system further calculates the number of times that the individual has been approved or refused in the past. On the other hand, if no match is found, the system classes the applicant as a new applicant and issues them a new identifier. </p>
    <p class="normal">The ability to search, locate, and identify a person in the historical data is critical for the system. This information is important because if someone has applied in the past and the application is known to have been refused, then this may affect that individual’s current application in a negative way. Similarly, if someone’s application is known to have been approved <a id="_idIndexMarker256"/>in the past, this approval may increase the chances of that individual getting approval for their current application. Typically, the historical database will have millions of rows, and we will need a well-designed solution to match new applicants in the historical database.</p>
    <p class="normal">Let’s assume that the historical table in the database looks like the following:</p>
    <table id="table001-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Personal ID</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Application ID</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">First name</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Surname</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">DOB</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Decision</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Decision date</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">45583</p>
          </td>
          <td class="table-cell">
            <p class="normal">677862</p>
          </td>
          <td class="table-cell">
            <p class="normal">John</p>
          </td>
          <td class="table-cell">
            <p class="normal">Doe</p>
          </td>
          <td class="table-cell">
            <p class="normal">2000-09-19</p>
          </td>
          <td class="table-cell">
            <p class="normal">Approved</p>
          </td>
          <td class="table-cell">
            <p class="normal">2018-08-07</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">54543</p>
          </td>
          <td class="table-cell">
            <p class="normal">877653</p>
          </td>
          <td class="table-cell">
            <p class="normal">Xman</p>
          </td>
          <td class="table-cell">
            <p class="normal">Xsir</p>
          </td>
          <td class="table-cell">
            <p class="normal">1970-03-10</p>
          </td>
          <td class="table-cell">
            <p class="normal">Rejected</p>
          </td>
          <td class="table-cell">
            <p class="normal">2018-06-07</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">34332</p>
          </td>
          <td class="table-cell">
            <p class="normal">344565</p>
          </td>
          <td class="table-cell">
            <p class="normal">Agro</p>
          </td>
          <td class="table-cell">
            <p class="normal">Waka</p>
          </td>
          <td class="table-cell">
            <p class="normal">1973-02-15</p>
          </td>
          <td class="table-cell">
            <p class="normal">Rejected</p>
          </td>
          <td class="table-cell">
            <p class="normal">2018-05-05</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">45583</p>
          </td>
          <td class="table-cell">
            <p class="normal">677864</p>
          </td>
          <td class="table-cell">
            <p class="normal">John</p>
          </td>
          <td class="table-cell">
            <p class="normal">Doe</p>
          </td>
          <td class="table-cell">
            <p class="normal">2000-09-19</p>
          </td>
          <td class="table-cell">
            <p class="normal">Approved</p>
          </td>
          <td class="table-cell">
            <p class="normal">2018-03-02</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">22331</p>
          </td>
          <td class="table-cell">
            <p class="normal">344553</p>
          </td>
          <td class="table-cell">
            <p class="normal">Kal</p>
          </td>
          <td class="table-cell">
            <p class="normal">Sorts</p>
          </td>
          <td class="table-cell">
            <p class="normal">1975-01-02</p>
          </td>
          <td class="table-cell">
            <p class="normal">Approved</p>
          </td>
          <td class="table-cell">
            <p class="normal">2018-04-15</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">In this table, the first column, <code class="inlineCode">Personal ID</code>, is associated with each of the unique applicants in the historical database. If there are 30 million unique applicants in the historical database, then there will be 30 million unique personal IDs. Each personal ID identifies an applicant in the historical database system.</p>
    <p class="normal">The second column we have is <code class="inlineCode">Application ID</code>. Each application ID identifies a unique application in the system. A person may have applied more than once in the past. So, this means that, in the historical database, we will have more unique application IDs than personal IDs. John Doe will only have one personal ID but has two application IDs, as shown in the preceding table.</p>
    <p class="normal">The preceding table only shows a sample of the historical dataset. Let’s assume that we have close to 1 million <a id="_idIndexMarker257"/>rows in our historical dataset, which contains the records of the last 10 years of applicants. New applicants are continuously arriving at the average rate of around 2 applicants per minute. For each applicant, we need to do the following:</p>
    <ul>
      <li class="bulletList">Issue a new application ID for the applicant.</li>
      <li class="bulletList">See if there is a match with an applicant in the historical database.</li>
      <li class="bulletList">If a match is found, use the personal ID for that applicant, as found in the historical database. We also need to determine how many times the application has been approved or refused in the historical database.</li>
      <li class="bulletList">If no match is found, then we need to issue a new personal ID for that individual.</li>
    </ul>
    <p class="normal">Suppose a new person arrives with the following credentials:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">First Name: John</code></li>
      <li class="bulletList"><code class="inlineCode">Surname: Doe</code></li>
      <li class="bulletList"><code class="inlineCode">DOB: 2000-09-19</code></li>
    </ul>
    <p class="normal">Now, how can we design an application that can perform an efficient and cost-effective search?</p>
    <p class="normal">One strategy for searching the new application in the database can be devised as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Sort the historical database by <code class="inlineCode">DOB</code>.</li>
      <li class="numberedList">Each time a new person arrives, issue a new application ID to the applicant.</li>
      <li class="numberedList">Fetch all the records that match that date of birth. This will be the primary search.</li>
      <li class="numberedList">Out of the records that have come up as matches, perform a secondary search using the first and last name.</li>
      <li class="numberedList">If a match is found, use <code class="inlineCode">Personal ID</code> to refer to the applicants. Calculate the number of approvals and refusals.</li>
      <li class="numberedList">If no match is found, issue a new personal ID to the applicant.</li>
    </ol>
    <p class="normal">Let’s try choosing the right algorithm to sort the historical database. We can safely rule out bubble sort as the size of the data is huge. Shell sort will perform better, but only if we have partially sorted lists. So, merge sort may be the best option for sorting the historical database.</p>
    <p class="normal">When a new person arrives, we need to search for and locate that person in the historical database. As the data is already sorted, either interpolation search or binary search can be used. Because applicants are likely to be equally spread out, as per <code class="inlineCode">DOB</code>, we can safely use binary search.</p>
    <p class="normal">Initially, we search based on <code class="inlineCode">DOB</code>, which returns a set of applicants sharing the same date of birth. Now, we need to find the required person within the small subset of people who share <a id="_idIndexMarker258"/>the same date of birth. As we have successfully reduced the data to a small subset, any of the search algorithms, including bubble sort, can be used to search for the applicant. Note that we have simplified the secondary search problem here a bit. We also need to calculate the total number of approvals and refusals by aggregating the search results, if more than one match is found.</p>
    <p class="normal">In a real-world scenario, each individual needs to be identified in the secondary search using some fuzzy search algorithm, as the first and last names may be spelled slightly differently. The search may need to use some kind of distance algorithm to implement the fuzzy search, where the data points whose similarity is above a defined threshold are considered the same.</p>
    <h1 id="_idParaDest-102" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we presented a set of sorting and searching algorithms. We also discussed the strengths and weaknesses of different sorting and searching algorithms. We quantified the performance of these algorithms and learned when to use each algorithm.</p>
    <p class="normal">In the next chapter, we will study dynamic algorithms. We will also look at a practical example of designing an algorithm and the details of the page ranking algorithm. Finally, we will study the linear programming algorithm.</p>
    <h1 id="_idParaDest-103" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>