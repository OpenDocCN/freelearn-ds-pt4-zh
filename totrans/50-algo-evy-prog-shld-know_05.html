<html><head></head><body>
  <div id="_idContainer068" class="Basic-Text-Frame">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-104" class="chapterTitle">Designing Algorithms</h1>
    <p class="normal">This chapter presents the core design concepts of various algorithms. It discusses the strengths and weaknesses of various techniques for designing algorithms. By understanding these concepts, we will learn how to design efficient algorithms.</p>
    <p class="normal">This chapter starts by discussing the different choices available to us when designing algorithms. Then, it discusses the importance of characterizing the particular problem that we are trying to solve. Next, it uses the famous <strong class="keyWord">Traveling Salesperson Problem</strong> (<strong class="keyWord">TSP</strong>) as a use<a id="_idIndexMarker259"/> case and applies the different design techniques that we will be presenting. Then, it introduces linear programming and discusses its applications. Finally, it presents how linear programming can be used to solve a real-world problem.</p>
    <p class="normal">By the end of this chapter, you should be able to understand the basic concepts of designing an efficient algorithm.</p>
    <p class="normal">The following concepts are discussed in this chapter:</p>
    <ul>
      <li class="bulletList">The various approaches to designing an algorithm</li>
      <li class="bulletList">Understanding the trade-offs involved in choosing the correct design for an algorithm</li>
      <li class="bulletList">Best practices for formulating a real-world problem</li>
      <li class="bulletList">Solving a real-world optimization problem</li>
    </ul>
    <p class="normal">Let’s first look at the basic concepts of designing an algorithm.</p>
    <h1 id="_idParaDest-105" class="heading-1">Introducing the basic concepts of designing an algorithm</h1>
    <p class="normal">An algorithm, according<a id="_idIndexMarker260"/> to the American Heritage Dictionary, is defined as follows:</p>
    <blockquote class="packt_quote">
      <p class="quote">A finite set of unambiguous instructions that given some set of initial conditions can be performed in a prescribed sequence to achieve a certain goal and that has a recognizable set of end conditions.</p>
    </blockquote>
    <p class="normal">Designing an algorithm is about coming up with this “<em class="italic">finite set of unambiguous instructions</em>” in the most efficient way to “<em class="italic">achieve a certain goal</em>.” For a complex real-world problem, designing an algorithm is a tedious task. To come up with a good design, we first need to fully understand the problem we are trying to solve. We start by figuring out what needs to be done (that is, understanding the requirements) before looking into how it will be done (that is, designing the algorithm). Understanding the problem includes addressing both the functional and non-functional requirements of the problem. Let’s look at what these are:</p>
    <ul>
      <li class="bulletList">Functional requirements formally specify the input and output interfaces of the problem that we want to solve and the functions associated with them. Functional requirements help us understand data processing, data manipulation, and the calculations that need to be implemented to generate the result.</li>
      <li class="bulletList">Non-functional requirements set the expectations about the performance and security aspects of the algorithm.</li>
    </ul>
    <p class="normal">Note that designing an algorithm is about addressing both the functional and non-functional requirements in the best possible way under the given set of circumstances and keeping in mind the set of resources available to run the designed algorithm.</p>
    <p class="normal">To come up with a good response that can meet the functional and non-functional requirements, our design should respect the following three concerns, as discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Overview of Algorithms</em>:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Correctness</strong>: Will the<a id="_idIndexMarker261"/> designed algorithm produce the result we expect?</li>
      <li class="bulletList"><strong class="keyWord">Performance</strong>: Is this the optimal way to get these results?</li>
      <li class="bulletList"><strong class="keyWord">Scalability</strong>: How is the algorithm going to perform on larger datasets?</li>
    </ul>
    <p class="normal">In this section, let’s look at these concerns one by one.</p>
    <h2 id="_idParaDest-106" class="heading-2">Concern 1: correctness: will the designed algorithm produce the result we expect?</h2>
    <p class="normal">An algorithm is<a id="_idIndexMarker262"/> a mathematical solution to a real-world problem. To be useful, it should produce accurate results. How to verify the correctness of an algorithm should not be an afterthought; instead, it should be baked into the design of the algorithm. Before strategizing how to verify an algorithm, we need to think about the following two aspects:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Defining the truth</strong>: To verify the algorithm, we need some known correct results for a given set of inputs. These known correct results are called the truths, in the context of the problem we are trying to solve. The truth is important as it is used as a reference when we iteratively work on evolving our algorithm toward a better solution.</li>
      <li class="bulletList"><strong class="keyWord">Choosing metrics</strong>: We also need to think about how we are going to quantify the deviation from the defined truth. Choosing the correct metrics will help us to accurately quantify the quality of our algorithm.
    <p class="normal">For example, for supervised machine learning algorithms, we can use existing labeled data as the truth. We can choose one or more metrics, such as accuracy, recall, or precision, to quantify deviation from the truth. It is important to note that, in some use cases, the correct output is not a single value. Instead, the correct output is defined as the range for a given set of inputs. As we work on the design and development of our algorithm, the objective will be to iteratively improve the algorithm until it is within the range specified in the requirements.</p></li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Consideration of edge cases</strong>: An edge case happens when our designed algorithm is operating at the extremes of operating parameters. An edge case is usually a scenario that is rare but needs to be well tested, as it can cause our algorithm to fail. The non-edge cases are called the “happy path” covering all the scenarios that usually happen when the operating parameters are within the normal range. The vast majority of the time, the algorithm will remain on the “happy path.” Unfortunately, there is no way to come up with all possible edge cases for a given algorithm, but we should consider as many edge cases as possible. But without consideration and thinking about the edge cases, problems may arise.</li>
    </ul>
    <h2 id="_idParaDest-107" class="heading-2">Concern 2: performance: is this the optimal way to get these results?</h2>
    <p class="normal">The second <a id="_idIndexMarker263"/>concern is about finding the answer to the following question:</p>
    <p class="normal">Is this the optimal solution and can we verify that no other solution exists for this problem that is better than our solution?</p>
    <p class="normal">At first glance, this question looks quite simple to answer. However, for a certain class of algorithms, researchers have unsuccessfully spent decades verifying whether a particular solution generated by an algorithm is also the best and that no other solution exists that can give better performance. So, it becomes important that we first understand the problem, its requirements, and the resources available to run the algorithm.</p>
    <p class="normal">To provide the best solution to a certain complex problem, we need to answer the fundamental question of whether we should even aim to find the optimal solution for this problem. If finding and verifying the optimal solution is a hugely time-consuming and complex task, then a workable solution may be our best bet. These approximate workable solutions are <em class="italic">heuristics</em>.</p>
    <p class="normal">So, understanding the problem and its complexities is important and helps us estimate the resource requirements.</p>
    <p class="normal">Before we start looking deeper into this, first, let’s define a couple of terms here:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Polynomial algorithm</strong>: If an algorithm <a id="_idIndexMarker264"/>has a time complexity of <em class="italic">O(n</em><sup class="superscript">k</sup><em class="italic">)</em>, we call it a polynomial algorithm, where <em class="italic">k</em> is a constant.</li>
      <li class="bulletList"><strong class="keyWord">Certificate</strong>: A proposed candidate solution produced at the end of an iteration is called a certificate. As we progress iteratively in solving a particular problem, we typically generate a series of certificates. If the solution is moving toward convergence, each generated certificate will be better than the previous one. At some point, when our certificate meets the requirements, we will choose that certificate as the final solution.</li>
    </ul>
    <p class="normal">In <em class="chapterRef">Chapter 1</em>, <em class="italic">Overview of Algorithms</em>, we introduced Big O notation, which can be used to analyze the time complexity of an algorithm. In the context of analyzing time complexity, we are looking at the following different time intervals:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Candidate solution generation time</strong>, <em class="italic">t</em><sub class="subscript">r</sub>: It is the time it takes for an algorithm to produce a candidate solution.</li>
      <li class="bulletList"><strong class="keyWord">Candidate solution verification time</strong>, <em class="italic">t</em><sub class="subscript">s</sub>: It is the time it takes to verify the candidate <a id="_idIndexMarker265"/>solution (certificate).</li>
    </ul>
    <h3 id="_idParaDest-108" class="heading-3">Characterizing the complexity of the problem</h3>
    <p class="normal">Over the years, the research community has divided problems into various categories according to their complexity. </p>
    <p class="normal">Before we attempt to design the solution to a problem, it makes sense to first try to characterize it. Generally, there are three types of problems:</p>
    <ul>
      <li class="bulletList">Problems for which we can guarantee that a polynomial algorithm exists that can be used to solve them</li>
      <li class="bulletList">Problems for which we can prove that they cannot be solved by a polynomial algorithm</li>
      <li class="bulletList">Problems for which we are unable to find a polynomial algorithm to solve them, but we are also unable to prove that a polynomial solution for those problems is impossible to find</li>
    </ul>
    <p class="normal">Let’s look at the various classes of problems according to their complexity:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Non-Deterministic Polynomial</strong> (<strong class="keyWord">NP</strong>): Problems that can be solved in polynomial <a id="_idIndexMarker266"/>time by a non-deterministic computer. Broadly, it means that a reasonable solution to a problem can be found and verified in polynomial times by making a reasonable guess at every step without an effort to find the optimal solution. Formally, for a problem to be an <strong class="keyWord">NP</strong> problem, it must meet the following condition, named Condition A:<ul>
          <li class="bulletList"><strong class="keyWord">Condition A</strong>: It is guaranteed that there is a polynomial algorithm that can be used to verify that the candidate solution (certificate) is optimal.</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Polynominal</strong> (<strong class="keyWord">P</strong>): Problems that <a id="_idIndexMarker267"/>can be solved in polynomial time by a deterministic computer. These problems can be solved by some algorithm with runtime <em class="italic">O(N</em><sup class="superscript">k</sup><em class="italic">)</em> for some power <em class="italic">k</em>, no matter how large. These are types of problems that can be thought of as a subset of <strong class="keyWord">NP</strong>. In addition to meeting the condition of an NP problem, Condition A, P problems need to meet another condition, named Condition B:<ul>
          <li class="bulletList"><strong class="keyWord">Condition A</strong>: It is guaranteed that there is a polynomial algorithm that can be used to verify that the candidate solution (certificate) is optimal.</li>
          <li class="bulletList"><strong class="keyWord">Condition B</strong>: It is guaranteed that there is at least one polynomial algorithm that can be used to solve them.</li>
        </ul>
      </li>
    </ul>
    <h3 id="_idParaDest-109" class="heading-3">Exploring the relationship between P and NP</h3>
    <p class="normal">Understanding the <a id="_idIndexMarker268"/>relationship between P and NP is still a work in progress. What we know for sure is that P is a subset of NP, i.e., <img src="../Images/B18046_04_001.png" alt="" role="presentation"/>. That is obvious from the above discussion where <a id="_idIndexMarker269"/>NP needs to meet only the first of the two conditions that P needs to meet.</p>
    <p class="normal">The relationship between P and NP problems is shown in <em class="italic">Figure 4.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_04_01.png" alt="Venn diagram  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 4.1: Relationship between P and NP problems</p>
    <p class="normal">What we do not know for sure is that if a problem is NP, is it P as well? This is one of the greatest problems in computer science that remains unresolved. Millennium Prize Problems, selected by the Clay Mathematics Institute, has announced a 1-million-dollar prize for the solution to this problem as it will have a major impact on fields such as AI, cryptography, and theoretical computer sciences. There are certain problems, such as sorting, that are known to be in P. Others, such as the knapsack and TSP, are known to be in NP.</p>
    <p class="normal">There is a lot of ongoing research effort to answer this question. As yet, no researcher has discovered a polynomial-time-deterministic algorithm to solve the knapsack or TSP. It is still a work in <a id="_idIndexMarker270"/>progress and no one has been able to prove that no such algorithm is possible.</p>
    <figure class="mediaobject"><img src="../Images/B18046_04_02.png" alt="Venn diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.2: DoesP = NP? We do not know as yet</p>
    <h3 id="_idParaDest-110" class="heading-3">Introducing NP-complete and NP-hard</h3>
    <p class="normal">Let’s continue the list of various classes of problems:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">NP-complete</strong>: The NP-complete <a id="_idIndexMarker271"/>category contains the hardest problems of all NP problems. An NP-complete problem meets the following two conditions:<ul>
          <li class="bulletList">There are no known polynomial algorithms to generate a certificate.</li>
          <li class="bulletList">There are known polynomial algorithms to verify that the proposed certificate is optimal.</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">NP-hard</strong>: The NP-hard <a id="_idIndexMarker272"/>category contains<a id="_idIndexMarker273"/> problems that are at least as hard as any problem in the NP category, but that do not themselves need to be in the NP category.</li>
    </ul>
    <p class="normal">Now, let’s try to draw a diagram to illustrate these different classes of problems:</p>
    <figure class="mediaobject"><img src="../Images/B18046_04_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.3: Relationship between P, NP, NP-complete, and NP-hard</p>
    <p class="normal">Note that it is still to be proven by the research community whether P = NP. Although this has not yet been proven, it is extremely likely that P ≠ NP. In that case, no polynomial solution<a id="_idIndexMarker274"/> exists for NP-complete problems. Note that the preceding diagram is based on this assumption.</p>
    <h4 class="heading-4">The distinction between P, NP, NP-complete, and NP-hard</h4>
    <p class="normal">Unfortunately, the <a id="_idIndexMarker275"/>distinction<a id="_idIndexMarker276"/> between<a id="_idIndexMarker277"/> P, NP, NP-compete, and<a id="_idIndexMarker278"/> NP-hard is not clear-cut. Let us summarize and study some examples to make better sense of the concepts discussed in this section:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">P</strong>: It is the class of problems solvable in polynomial time. For example:<ul>
          <li class="bulletList">Hashtable lookup</li>
          <li class="bulletList">Shortest path algorithms like Djikstra’s algorithms</li>
          <li class="bulletList">Linear and binary search algorithms</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">NP-problem</strong>: The problems are not solvable in polynomial time, but their solution can be verified in polynomial time. For example:<ul>
          <li class="bulletList">RSA encryption algorithm</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">NP-hard</strong>: These are complex problems that no one has come up with a solution for as yet, but if solved, would have a polynomial time solution. For example:<ul>
          <li class="bulletList">Optimal clustering using the <em class="italic">K</em>-means algorithm</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">NP-complete</strong>: The NP-complete problems are the “hardest” in NP. They are both NP-hard and NP. For example:<ul>
          <li class="bulletList">Calculation <a id="_idIndexMarker279"/>of an optimal solution for the TSP</li>
        </ul>
      </li>
    </ul>
    <div class="note">
      <p class="normal">Finding a solution for one of either classes (NP-hard or NP-complete) would imply a solution for all NP-hard/NP-complete problems.</p>
    </div>
    <h2 id="_idParaDest-111" class="heading-2">Concern 3 – scalability: how is the algorithm going to perform on larger datasets?</h2>
    <p class="normal">An algorithm <a id="_idIndexMarker280"/>processes data in a defined way to produce a result. Generally, as the size of the data increases, it takes more and more time to process the<a id="_idIndexMarker281"/> data and calculate the required results. The <a id="_idIndexMarker282"/>term <strong class="keyWord">big data</strong> is sometimes used to roughly identify datasets that are expected to be challenging for the infrastructure and algorithms to work with due to their volume, variety, and velocity. A well-designed algorithm should be scalable, which means that it should be designed in a way that means, wherever possible, it should be able to run efficiently, making use of the available resources and generating the correct results in a reasonable timeframe. The design of the algorithm becomes even more important when dealing with big data. To quantify the scalability of an algorithm, we need to keep the following two aspects in mind:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">The increase in resource requirements as the input data is increased</strong>: Estimating a requirement such as this is called space complexity analysis.</li>
      <li class="bulletList"><strong class="keyWord">The increase in the time taken to run as the input data is increased</strong>: Estimating this is called time complexity analysis.</li>
    </ul>
    <p class="normal">Note that we are living in an era that is defined by data explosion. The term big data has become mainstream, as it captures the size and complexity of the data that is typically required to be processed by modern algorithms.</p>
    <p class="normal">While in the development and testing phase, many algorithms use only a small sample of data. When designing an algorithm, it is important to look into the scalability aspect of the algorithms. In particular, it is important to carefully analyze (that is, test or predict) the effect of<a id="_idIndexMarker283"/> an algorithm’s performance as datasets increase in size.</p>
    <h3 id="_idParaDest-112" class="heading-3">The elasticity of the cloud and algorithmic scalability</h3>
    <p class="normal">Cloud computing<a id="_idIndexMarker284"/> has made new options available to deal with the resource requirements of an algorithm. Cloud computing infrastructures are capable of provisioning more resources as the processing requirements increase. The ability of cloud computing is called the elasticity of the infrastructure and has now provided us with more options for designing an algorithm. When deployed on the cloud, an algorithm may demand additional CPUs or VMs based on the size of the data to be processed.</p>
    <p class="normal">Typical deep learning algorithms are a good example. To train a good deep learning model, lots of labeled data is needed. For a well-designed deep learning algorithm, the processing required to train a deep learning model is directly proportional to the number of examples or close to it. When training a deep learning model in the cloud, as the size of data increases, we try to provision more resources to keep training time within manageable limits.</p>
    <h1 id="_idParaDest-113" class="heading-1">Understanding algorithmic strategies</h1>
    <p class="normal">A well-designed algorithm<a id="_idIndexMarker285"/> tries to optimize the use of the available resources most efficiently by dividing the problem into smaller subproblems wherever possible. There are different algorithmic strategies for designing algorithms. An algorithmic strategy deals with the following three aspects of an algorithm list containing aspects of the missing algorithm.</p>
    <p class="normal">We will present the following three strategies in this section:</p>
    <ul>
      <li class="bulletList">The divide-and-conquer strategy</li>
      <li class="bulletList">The dynamic programming strategy</li>
      <li class="bulletList">The greedy algorithm strategy</li>
    </ul>
    <h2 id="_idParaDest-114" class="heading-2">Understanding the divide-and-conquer strategy</h2>
    <p class="normal">One of the <a id="_idIndexMarker286"/>strategies is to find a way to<a id="_idIndexMarker287"/> divide a larger problem into smaller problems that can be solved independently of each other. The subsolutions produced by these subproblems are then combined to generate the overall solution to the problem. This is called the divide-and-conquer strategy.</p>
    <p class="normal">Mathematically, if we are designing a solution for a problem (P) with <em class="italic">n</em> inputs that needs to process dataset <em class="italic">d</em>, we split the problem into <em class="italic">k</em> subproblems, <em class="italic">P1</em> to <em class="italic">Pk</em>. Each of the subproblems will process a partition of the dataset, <em class="italic">d</em>. Typically, we will have <em class="italic">P1</em> to <em class="italic">Pk</em> processing <em class="italic">d1</em> to <em class="italic">dk</em> respectively.</p>
    <p class="normal">Let’s look at a practical example.</p>
    <h3 id="_idParaDest-115" class="heading-3">A practical example – divide-and-conquer applied to Apache Spark</h3>
    <p class="normal">Apache Spark (<a href="https://spark.apache.org/"><span class="url">https://spark.apache.org/</span></a>) is an<a id="_idIndexMarker288"/> open-source framework that is used to solve<a id="_idIndexMarker289"/> complex distributed<a id="_idIndexMarker290"/> problems. It implements a divide-and-conquer strategy to solve problems. To process a problem, it divides the problem into various subproblems and processes them independently of each other. These subproblems can run on separate machines enabling horizontal scaling. We will demonstrate this by using a simple example of counting words from a list.</p>
    <p class="normal">Let’s assume that we have the following list of words:</p>
    <p class="normal"><code class="inlineCode">words_list = ["python", "java", "ottawa", "news", "java", "ottawa"]</code></p>
    <p class="normal">We want to calculate the frequency of each word in this list. For that, we will apply the divide-and-conquer strategy to solve this problem in an efficient way.</p>
    <p class="normal">The implementation of divide-and-conquer is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_04_04.png" alt="Diagram  Description automatically generated"/></figure>
    <figure class="mediaobject">Figure 4.4: Divide and conquer</figure>
    <p class="normal">The preceding<a id="_idIndexMarker291"/> diagram<a id="_idIndexMarker292"/> shows the following phases into which a problem is divided:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Splitting</strong>: The input data is divided into partitions that can be processed independently of each other. This is called splitting. We have three splits in the preceding figure.</li>
      <li class="numberedList"><strong class="keyWord">Mapping</strong>: Any operation that can run independently on a split is called a map. In the preceding diagram, the map operation converts each of the words in the partition in to key-value pairs. Corresponding to the three splits, there are three mappers that are run in parallel.</li>
      <li class="numberedList"><strong class="keyWord">Shuffling</strong>: Shuffling is the process of bringing similar keys together. Once similar keys are brought together, aggregation functions can be run on their values. Note that shuffling is a performance-intensive operation, as similar keys need to be brought together that can be originally distributed across the network.</li>
      <li class="numberedList"><strong class="keyWord">Reducing</strong>: Running an aggregation function on the values of similar keys is called reducing. In the preceding diagram, we have to count the number of words.</li>
    </ol>
    <p class="normal">Let’s see how we can write the code to implement this. To demonstrate the divide-and-conquer strategy, we need a distributed computing framework. We will run Python running on Apache Spark for this:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, in order to use Apache Spark, we will create a runtime context of Apache Spark:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> findspark
findspark.init()
<span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> SparkSession
spark = SparkSession.builder.master(<span class="hljs-string">"local[*]"</span>).getOrCreate()
sc = spark.sparkContext
</code></pre>
      </li>
      <li class="numberedList">Now, let’s create a sample list containing some words. We will convert this list into Spark’s native<a id="_idIndexMarker293"/> distributed data structure, called a <strong class="keyWord">Resilient Distributed</strong><strong class="keyWord"><a id="_idIndexMarker294"/></strong><strong class="keyWord"> Dataset</strong> (<strong class="keyWord">RDD</strong>):
        <pre class="programlisting code"><code class="hljs-code">wordsList = [<span class="hljs-string">'python'</span>, <span class="hljs-string">'java'</span>, <span class="hljs-string">'ottawa'</span>, <span class="hljs-string">'ottawa'</span>, <span class="hljs-string">'java'</span>,<span class="hljs-string">'news'</span>]
wordsRDD = sc.parallelize(wordsList, <span class="hljs-number">4</span>)
<span class="hljs-comment"># Print out the type of wordsRDD</span>
<span class="hljs-built_in">print</span> (wordsRDD.collect())
</code></pre>
      </li>
      <li class="numberedList">It will print:
        <pre class="programlisting con"><code class="hljs-con">['python', 'java', 'ottawa', 'ottawa', 'java', 'news']
</code></pre>
      </li>
      <li class="numberedList">Now, let’s use a <code class="inlineCode">map</code> function to convert the words into a key-value pair:
        <pre class="programlisting code"><code class="hljs-code">wordPairs = wordsRDD.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> w: (w, <span class="hljs-number">1</span>))
<span class="hljs-built_in">print</span> (wordPairs.collect())
</code></pre>
      </li>
      <li class="numberedList">It will print:
        <pre class="programlisting con"><code class="hljs-con">[('python', 1), ('java', 1), ('ottawa', 1), ('ottawa', 1), ('java', 1), ('news', 1)]
</code></pre>
      </li>
      <li class="numberedList">Let’s use the <code class="inlineCode">reduce</code> function to aggregate and get the result:
        <pre class="programlisting code"><code class="hljs-code">wordCountsCollected = wordPairs.reduceByKey(<span class="hljs-keyword">lambda</span> x,y: x+y)
<span class="hljs-built_in">print</span>(wordCountsCollected.collect())
</code></pre>
      </li>
      <li class="numberedList">It prints:
        <pre class="programlisting con"><code class="hljs-con">[('python', 1), ('java', 2), ('ottawa', 2), ('news', 1)]
</code></pre>
      </li>
    </ol>
    <p class="normal">This shows how we can use the divide-and-conquer strategy to count the number of words. Note that divide-and-conquer is useful when a problem can be divided into subproblems and each subproblem can at least be partially solved independently of other subproblems. It is not the best choice for algorithms that require intensive iterative processing, such as optimization algorithms. For such algorithms, dynamic programming is<a id="_idIndexMarker295"/> suitable, which<a id="_idIndexMarker296"/> is presented in the next section.</p>
    <div class="note">
      <p class="normal">Modern cloud computing infrastructures, such as Microsoft Azure, Amazon Web Services, and Google Cloud, achieve scalability in a distributed infrastructure that uses several CPUs/GPUs in parallel by implementing a divide-and-conquer strategy either directly or indirectly behind the scenes.</p>
    </div>
    <h2 id="_idParaDest-116" class="heading-2">Understanding the dynamic programming strategy</h2>
    <p class="normal">In the previous<a id="_idIndexMarker297"/> section, we studied divide<a id="_idIndexMarker298"/> and conquer, which is a top-down method. In contrast, dynamic programming is a bottom-up strategy. We start with the smallest subproblem and keep on combining the solutions. We keep on combining until we reach the final solution. Dynamic programming, like the divide-and-conquer method, solves problems by combining the solutions with subproblems.</p>
    <p class="normal">Dynamic programming is a strategy proposed in the 1950s by Richard Bellman to optimize certain classes of algorithms. Note that in dynamic programming, the word “programming” refers to the use of a tabular method and has nothing to do with writing code. In contrast to the divide and conquer strategy, dynamic programming is applicable when the subproblems are not independent. It is typically applied to optimization problems in which each subproblem’s solution has a value.</p>
    <p class="normal">Our objective is to find a solution with optimal value. A dynamic programming algorithm solves every subproblem just once and then saves its answer in a table, thereby avoiding the work of recomputing the answer every time the subproblem is encountered. </p>
    <h3 id="_idParaDest-117" class="heading-3">Components of dynamic programming</h3>
    <p class="normal">Dynamic programming <a id="_idIndexMarker299"/>is based on two major components:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Recursion</strong>: It solves subproblems recursively.</li>
      <li class="bulletList"><strong class="keyWord">Memoization</strong>: Memoization or caching. It is based on an intelligent caching mechanism that tries to reuse the results of heavy computations. This intelligent caching mechanism is called memoization. The subproblems partly involve a calculation that is repeated in those subproblems. The idea is to perform that calculation once (which is the time-consuming step) and then reuse it on the other subproblems. This is achieved using memoization, which is especially useful in solving recursive problems that may evaluate the same inputs multiple times.</li>
    </ul>
    <h3 id="_idParaDest-118" class="heading-3">Conditions for using dynamic programming</h3>
    <p class="normal">The problem we are<a id="_idIndexMarker300"/> trying to solve with dynamic programming should have two characteristics.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Optimal structure</strong>: Dynamic <a id="_idIndexMarker301"/>programming gives good performance benefits when the problem we are trying to solve can be divided into subproblems.</li>
      <li class="bulletList"><strong class="keyWord">Overlapping subproblems</strong>: Dynamic programming<a id="_idIndexMarker302"/> uses a <strong class="keyWord">recursive </strong>function that solves a particular problem by calling a copy of itself and solving smaller subproblems of the original problems. The computed solutions of the subproblems are stored in a table, so that these don’t have to be re-computed. Hence, this technique is needed where an overlapping sub-problem exists.</li>
    </ul>
    <p class="normal">Dynamic programming is a perfect fit for combinatorial optimization problems, which are problems that needs providing optimal combinations of input elements as a solution.</p>
    <p class="normal">Examples include:</p>
    <ul>
      <li class="bulletList">Finding the optimal way to deliver packages for a company like FedEx or UPS</li>
      <li class="bulletList">Finding the optimal airline routes and airports</li>
      <li class="bulletList">Deciding how to assign drivers for an online food delivery system like Uber Eats</li>
    </ul>
    <h2 id="_idParaDest-119" class="heading-2">Understanding greedy algorithms</h2>
    <p class="normal">As the name <a id="_idIndexMarker303"/>indicates, a greedy algorithm relatively<a id="_idIndexMarker304"/> quickly produces a good solution, but it cannot be the optimal solution. Like dynamic programming, greedy algorithms are mainly used to solve optimization problems where a divide-and-conquer strategy cannot be used. In the greedy algorithm, the solution is calculated following a sequence of steps. At each step, a locally<a id="_idIndexMarker305"/> optimal choice is made.</p>
    <h3 id="_idParaDest-120" class="heading-3">Conditions for using greedy programming</h3>
    <p class="normal">Greedy is a strategy<a id="_idIndexMarker306"/> that works well on problems with the following two characteristics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Global from local</strong>: A global <a id="_idIndexMarker307"/>optimum can be arrived at by selecting a local optimum.</li>
      <li class="bulletList"><strong class="keyWord">Optimal substructure</strong>: An optimal solution to the problem is made from optimal solutions to subproblems.</li>
    </ul>
    <p class="normal">To understand the greedy algorithm, let’s first define two terms:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Algorithmic overheads</strong>: Whenever we try to find the optimal solution to a certain problem, it takes some time. As the problems that we are trying to optimize become more and more complex, the time it takes to find the optimal solution also increases. We represent algorithmic overheads with <img src="../Images/B18046_04_002.png" alt="" role="presentation"/>.</li>
      <li class="bulletList"><strong class="keyWord">Delta from optimal</strong>: For a given optimization problem, there exists an optimal solution. Typically, we iteratively optimize the solution using our chosen algorithm. For a given problem, there always exists a perfect solution, called the optimal solution, to the current problem. As discussed, based on the classification of the problem we are trying to solve, it’s possible for the optimal solution to be unknown or for it to take an unreasonable amount of time to calculate and verify it. Assuming that the optimal solution is known, the difference from optimal for the current solution in the ith iteration is called delta from optimal and is represented by <img src="../Images/B18046_04_003.png" alt="" role="presentation"/>.</li>
    </ul>
    <p class="normal">For complex problems, we have two possible strategies:</p>
    <ul>
      <li class="bulletList">Spend more time finding a solution nearest to optimal so that <img src="../Images/B18046_04_004.png" alt="" role="presentation"/> is as small as possible.</li>
      <li class="bulletList">Minimize the algorithmic overhead, <img src="../Images/B18046_04_005.png" alt="" role="presentation"/>. Use the quick-and-dirty approach and just use a workable solution.</li>
    </ul>
    <p class="normal">Greedy algorithms are based on the second strategy, where we do not make an effort to find a global optimal and choose to minimize the algorithm overheads instead.</p>
    <p class="normal">Using a greedy algorithm is a quick and simple strategy for finding the global optimal value for multistage problems. It is based on selecting the local optimal values without making an effort to verify whether local optimal values are globally optimal as well. Generally, unless we are lucky, a greedy algorithm will not result in a value that can be considered globally<a id="_idIndexMarker308"/> optimal. However, finding a global optimal value is a time-consuming task. Hence, the greedy algorithm is fast compared to the divide-and-conquer and dynamic programming algorithms.</p>
    <p class="normal">Generally, a greedy algorithm is defined as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Let’s assume that we have a dataset, <em class="italic">D</em>. In this dataset, choose an element, <em class="italic">k</em>.</li>
      <li class="numberedList">Let’s assume the candidate solution or certificate is <em class="italic">S</em>. Consider including <em class="italic">k</em> in the solution, <em class="italic">S</em>. If it can be included, then the solution is <em class="italic">Union(S, e)</em>.</li>
      <li class="numberedList">Repeat the process until <em class="italic">S</em> is filled up or <em class="italic">D</em> is exhausted.</li>
    </ol>
    <p class="normal"><strong class="keyWord">Example</strong>:</p>
    <p class="normal">The <strong class="keyWord">Classification And Regression Tree</strong> (<strong class="keyWord">CART</strong>) algorithm is a greedy algorithm, which searches for an<a id="_idIndexMarker309"/> optimum split at the top level. It repeats the process at each subsequent level. Note that the CART algorithm does not calculate and check whether the split will lead to the lowest possible impurity several levels down. CART uses a greedy algorithm because finding the optimal tree is known to be an NP-complete problem. It has an algorithmic complexity of <em class="italic">O(exp(m))</em> time.</p>
    <h1 id="_idParaDest-121" class="heading-1">A practical application – solving the TSP</h1>
    <p class="normal">Let’s first look at <a id="_idIndexMarker310"/>the problem statement for the TSP, which is a well-known problem that was coined as a challenge in the 1930s. The TSP is an NP-hard problem. To start with, we can randomly generate a tour that meets the condition of visiting all of the cities without caring about the optimal solution. Then, we can work to improve the solution with each iteration. Each tour generated in an iteration is called a candidate solution (also called a certificate). Proving that a certificate is optimal requires an exponentially increasing amount of time. Instead, different heuristics-based solutions are used that generate tours that are near to optimal but are not optimal.</p>
    <p class="normal">A traveling salesperson needs to visit a given list of cities to get their job done:</p>
    <table id="table001-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">INPUT</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">A list of <em class="italic">n</em> cities (denoted as <em class="italic">V</em>) and the distances between each pair of cities, <em class="italic">d ij (1 ≤ i, j ≤ n)</em></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">OUTPUT</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">The shortest tour that visits each city exactly once and returns to the initial city</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note the following:</p>
    <ul>
      <li class="bulletList">The distances between the cities on the list are known</li>
      <li class="bulletList">Each city in the given list needs to be visited <em class="italic">exactly</em> once</li>
    </ul>
    <p class="normal">Can we generate the travel plan for the salesperson? What will be the optimal solution that can minimize the total distance traveled by the traveling salesperson?</p>
    <p class="normal">The following are the distances between five Canadian cities that we can use for the TSP:</p>
    <table id="table002-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell"/>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Ottawa</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Montreal</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Kingston</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Toronto</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Sudbury</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Ottawa</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">-</p>
          </td>
          <td class="table-cell">
            <p class="normal">199</p>
          </td>
          <td class="table-cell">
            <p class="normal">196</p>
          </td>
          <td class="table-cell">
            <p class="normal">450</p>
          </td>
          <td class="table-cell">
            <p class="normal">484</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Montreal</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">199</p>
          </td>
          <td class="table-cell">
            <p class="normal">-</p>
          </td>
          <td class="table-cell">
            <p class="normal">287</p>
          </td>
          <td class="table-cell">
            <p class="normal">542</p>
          </td>
          <td class="table-cell">
            <p class="normal">680</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Kingston</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">196</p>
          </td>
          <td class="table-cell">
            <p class="normal">287</p>
          </td>
          <td class="table-cell">
            <p class="normal">-</p>
          </td>
          <td class="table-cell">
            <p class="normal">263</p>
          </td>
          <td class="table-cell">
            <p class="normal">634</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Toronto</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">450</p>
          </td>
          <td class="table-cell">
            <p class="normal">542</p>
          </td>
          <td class="table-cell">
            <p class="normal">263</p>
          </td>
          <td class="table-cell">
            <p class="normal">-</p>
          </td>
          <td class="table-cell">
            <p class="normal">400</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Sudbury</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">484</p>
          </td>
          <td class="table-cell">
            <p class="normal">680</p>
          </td>
          <td class="table-cell">
            <p class="normal">634</p>
          </td>
          <td class="table-cell">
            <p class="normal">400</p>
          </td>
          <td class="table-cell">
            <p class="normal">-</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note that the objective is to get a tour that starts and ends in the initial city. For example, a typical tour can be Ottawa–Sudbury–Montreal–Kingston–Toronto–Ottawa with a cost of <em class="italic">484 + 680 + 287 + 263 + 450 = 2,164</em>. Is this the tour in which the salesperson has to travel the minimum distance? What will be the optimal solution that can minimize the <a id="_idIndexMarker311"/>total distance traveled by the traveling salesperson? I will leave this up to you to think about and calculate.</p>
    <h2 id="_idParaDest-122" class="heading-2">Using a brute-force strategy</h2>
    <p class="normal">The first solution that <a id="_idIndexMarker312"/>comes to mind <a id="_idIndexMarker313"/>to solve the TSP is using brute force to come up with the shortest path in which the salesperson visits every city exactly once and returns to the initial city. So, the brute-force strategy works as follows:</p>
    <ul>
      <li class="bulletList">Evaluate all possible tours.</li>
      <li class="bulletList">Choose the one for which we get the shortest distance.</li>
    </ul>
    <p class="normal">The problem is that for n number of cities, there are <em class="italic">(n-1)!</em> possible tours. That means that five cities will produce <em class="italic">4! = 24</em> tours, and we will select the one that corresponds to the lowest distance. It is obvious that this method will only work when we do not have too many cities. As the number of cities increases, the brute-force strategy becomes unsolvable due to the large number of permutations generated by using this approach.</p>
    <p class="normal">Let’s see how we can implement the brute-force strategy in Python.</p>
    <p class="normal">First, note that a tour, {<em class="italic">1,2,3</em>}, represents a tour of the city from city 1 to city 2 and city 3. The total distance in a tour is the total distance covered in a tour. We will assume that the distance between the cities is the shortest distance between them (which is the Euclidean distance).</p>
    <p class="normal">Let’s first define three utility functions:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">distance_points</code>: Calculates the absolute distance between two points</li>
      <li class="bulletList"><code class="inlineCode">distance_tour</code>: Calculates the total distance the salesperson has to cover in a given tour</li>
      <li class="bulletList"><code class="inlineCode">generate_cities</code>: Randomly generates a set of <em class="italic">n</em> cities located in a rectangle of width <code class="inlineCode">500</code> and height <code class="inlineCode">300</code></li>
    </ul>
    <p class="normal">Let’s look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> permutations
</code></pre>
    <p class="normal">In the preceding code, we implemented <code class="inlineCode">alltours</code> from the <code class="inlineCode">permutations</code> function of the <code class="inlineCode">itertools</code> package. We have also represented the distance with a complex number. This means the following:</p>
    <p class="normal">Calculating the distance between two cities, <em class="italic">a</em> and <em class="italic">b</em>, is as simple as <code class="inlineCode">distance (a,b)</code>.</p>
    <p class="normal">We can<a id="_idIndexMarker314"/> create <em class="italic">n </em>number of cities<a id="_idIndexMarker315"/> just by calling <code class="inlineCode">generate_cities(n)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">distance_tour</span>(<span class="hljs-params">aTour</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(distance_points(aTour[i - <span class="hljs-number">1</span>], aTour[i]) 
               <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(aTour))
    )
aCity = <span class="hljs-built_in">complex</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">distance_points</span>(<span class="hljs-params">first, second</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(first - second)
<span class="hljs-keyword">def</span> <span class="hljs-title">generate_cities</span> (number_of_cities):
    seed=<span class="hljs-number">111</span>
    width=<span class="hljs-number">500</span>
    height=<span class="hljs-number">300</span>
    random.seed((number_of_cities, seed))
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">frozenset</span>(aCity(random.randint(<span class="hljs-number">1</span>, width),
<span class="hljs-keyword">                          </span> random.randint(<span class="hljs-number">1</span>, height))
                     <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number_of_cities))
</code></pre>
    <p class="normal">Now let’s define a function, <code class="inlineCode">brute_force</code>, that generates all the possible tours of the cities. Once it has generated all possible tours, it will choose the one with the shortest distance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">brute_force</span>(<span class="hljs-params">cities</span>):
    <span class="hljs-keyword">return</span> shortest_tour(alltours(cities))
<span class="hljs-keyword">def</span> <span class="hljs-title">shortest_tour</span>(<span class="hljs-params">tours</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(tours, key=distance_tour)
</code></pre>
    <p class="normal">Now let’s define the utility functions that can help us plot the cities. We will define the following functions:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">visualize_tour</code>: Plots all the cities and links in a particular tour. It also highlights the city from which the tour started.</li>
      <li class="bulletList"><code class="inlineCode">visualize_segment</code>: Used by <code class="inlineCode">visualize_tour</code> to plot cities and links in a segment.</li>
    </ul>
    <p class="normal">Look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">def</span> <span class="hljs-title">visualize_tour</span>(<span class="hljs-params">tour, style=</span><span class="hljs-string">'bo-'</span>): 
<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tour) &gt; <span class="hljs-number">1000</span>:
<span class="hljs-keyword">       </span> plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>))
    start = tour[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]
    visualize_segment(tour + start, style)
    visualize_segment(start, <span class="hljs-string">'rD'</span>) 
    
<span class="hljs-keyword">def</span> <span class="hljs-title">visualize_segment</span> (segment, style=<span class="hljs-string">'</span><span class="hljs-string">bo-'</span>):
    plt.plot([X(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> segment], [Y(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> segment], style, clip_on=<span class="hljs-literal">False</span>)
    plt.axis(<span class="hljs-string">'scaled'</span>)
    plt.axis(<span class="hljs-string">'off'</span>)
    
<span class="hljs-keyword">def</span> <span class="hljs-title">X</span>(<span class="hljs-params">city</span>):
<span class="hljs-keyword">    </span><span class="hljs-string">"X axis"</span>;
<span class="hljs-string">    </span><span class="hljs-keyword">return</span> city.real
<span class="hljs-keyword">def</span> <span class="hljs-title">Y</span>(<span class="hljs-params">city</span>):
<span class="hljs-keyword">    </span><span class="hljs-string">"Y axis"</span>;
<span class="hljs-string">    </span><span class="hljs-keyword">return</span> city.imag
</code></pre>
    <p class="normal">Let’s implement<a id="_idIndexMarker316"/> a function, <code class="inlineCode">tsp()</code>, that<a id="_idIndexMarker317"/> does the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Generates the tour based on the algorithm and number of cities requested.</li>
      <li class="numberedList">Calculates the time it took for the algorithm to run.</li>
      <li class="numberedList">Generates a plot.</li>
    </ol>
    <p class="normal">Once <code class="inlineCode">tsp()</code> is defined, we can use it to create a tour:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter
<span class="hljs-keyword">def</span> <span class="hljs-title">tsp</span>(<span class="hljs-params">algorithm, cities</span>):
    t0 = time()
    tour = algorithm(cities)
    t1 = time()
    <span class="hljs-comment"># Every city appears exactly once in tour</span>
    <span class="hljs-keyword">assert</span> Counter(tour) == Counter(cities) 
    visalize_tour(tour)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"{}:{} cities =&gt; tour length {;.0f} (in {:.3f} sec"</span>.<span class="hljs-built_in">format</span>(
        name(algorithm), <span class="hljs-built_in">len</span>(tour), distance_tour(tour), t1-t0))
<span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">algorithm</span>):
<span class="hljs-keyword">    return</span> algorithm.__name__.replace(<span class="hljs-string">'_tsp'</span>,<span class="hljs-string">''</span>)
tps(brute_force, generate_cities(<span class="hljs-number">10</span>))
</code></pre>
    <figure class="mediaobject"><img src="../Images/B18046_04_05.png" alt="Chart, line chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.5: Solution of TSP</p>
    <p class="normal">Note that we have used it to generate the tour for 10 cities. As <em class="italic">n = 10</em>, it will generate <em class="italic">(10-1)! = 362,880</em> possible <a id="_idIndexMarker318"/>permutations. If n<a id="_idIndexMarker319"/> increases, the number of permutations sharply increases and the brute-force method cannot be used.</p>
    <h2 id="_idParaDest-123" class="heading-2">Using a greedy algorithm</h2>
    <p class="normal">If we use a greedy<a id="_idIndexMarker320"/> algorithm to solve <a id="_idIndexMarker321"/>the TSP, then, at each step, we can choose a city that seems reasonable, instead of finding a city to visit that will result in the best overall path. So, whenever we need to select a city, we just select the nearest city without bothering to verify that this choice will result in the globally optimal path.</p>
    <p class="normal">The approach of the greedy algorithm is simple:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start from any city.</li>
      <li class="numberedList">At each step, keep building the tour by moving to the next city where the nearest neighborhood has not been visited before.</li>
      <li class="numberedList">Repeat <em class="italic">step 2</em>.</li>
    </ol>
    <p class="normal">Let’s define a function named <code class="inlineCode">greedy_algorithm</code> that can implement this logic:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">greedy_algorithm</span>(<span class="hljs-params">cities, start=</span><span class="hljs-literal">None</span>):
    city_ = start <span class="hljs-keyword">or</span> first(cities)
    tour = [city_]
    unvisited = <span class="hljs-built_in">set</span>(cities - {city_})
    <span class="hljs-keyword">while</span> unvisited:
        city_ = nearest_neighbor(city_, unvisited)
        tour.append(city_)
        unvisited.remove(city_)
    <span class="hljs-keyword">return</span> tour
<span class="hljs-keyword">def</span> <span class="hljs-title">first</span>(<span class="hljs-params">collection</span>): <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(collection))
<span class="hljs-keyword">def</span> <span class="hljs-title">nearest_neighbor</span>(<span class="hljs-params">city_a, cities</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cities, key=<span class="hljs-keyword">lambda</span> city_: distance_points(city_, city_a))
</code></pre>
    <p class="normal">Now, let’s use <code class="inlineCode">greedy_algorithm</code> to create a tour for 2,000 cities:</p>
    <pre class="programlisting code"><code class="hljs-code">tsp(greedy_algorithm, generate_cities(<span class="hljs-number">2000</span>))
</code></pre>
    <figure class="mediaobject"><img src="../Images/B18046_04_06.png" alt="Qr code  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 4.6: Cities displayed in Jupyter Notebook</p>
    <p class="normal">Note that it took only <code class="inlineCode">0.514</code> seconds to generate the tour for 2,000 cities. If we had used the brute-force method, it would have generated <em class="italic">(2000-1)!</em> = 1.65<em class="italic">e</em><sup class="superscript">5732</sup> permutations, which is almost infinite.</p>
    <p class="normal">Note that the <a id="_idIndexMarker322"/>greedy algorithm<a id="_idIndexMarker323"/> is based on heuristics and there is no proof that the solution will be optimal.</p>
    <h2 id="_idParaDest-124" class="heading-2">Comparison of Three Strategies</h2>
    <p class="normal">To summarize, the<a id="_idIndexMarker324"/> outcome of the greedy algorithm is more efficient in terms of calculation time whereas the brute-force method provides the combination with the global optimum. This means the calculation time as well as the quality of the outcome differ. The proposed greedy algorithm may reach nearly as high outcomes as brute force does, with significantly less calculation time, but as it does not search for an optimal solution, it is based on a effort-based strategy and there are no guarantees.</p>
    <p class="normal">Now, let’s look at the design of the <strong class="keyWord">PageRank</strong> algorithm.</p>
    <h1 id="_idParaDest-125" class="heading-1">Presenting the PageRank algorithm</h1>
    <p class="normal">As a practical <a id="_idIndexMarker325"/>example, let’s look at the PageRank algorithm, which is used by Google to rank the search results of a user query. It generates a number that quantifies the importance of search results in the context of the query the user has executed. This was designed by two Ph.D. students, Larry Page and Sergey Brin, at Stanford in the late 1990s, who also went on to start Google. <em class="italic">The PageRank algorithm</em> was named after Larry Page.</p>
    <p class="normal">Let’s first formally define the problem for which PageRank was initially designed.</p>
    <h2 id="_idParaDest-126" class="heading-2">Problem definition</h2>
    <p class="normal">Whenever a user <a id="_idIndexMarker326"/>enters a query on a search engine on the web, it typically results in a large number of results. To make the results useful for the end user, it is important to rank the web pages using some criteria. The results that are displayed use this ranking to summarize the results for the user and are dependent on the criteria defined by the underlying algorithm being used.</p>
    <h2 id="_idParaDest-127" class="heading-2">Implementing the PageRank algorithm</h2>
    <p class="normal">First, while using<a id="_idIndexMarker327"/> the PageRank algorithm, the following representation is used:</p>
    <ul>
      <li class="bulletList">Web pages are represented by nodes in a directed graph.</li>
      <li class="bulletList">The graph edges correspond to hyperlinks.</li>
    </ul>
    <p class="normal">The most important part of the PageRank algorithm is to come up with the best way to calculate the importance of each page that is returned by the query results. The rank of a particular web page in the network is calculated as the probability that a person randomly traversing the edges (i.e., clicking on links) will arrive at that page. Also, this algorithm is parametrized by the damping factor alpha, which has a default value of 0.85. This damping factor is the probability that the user will continue clicking. Note that the page with the highest PageRank is the most attractive: regardless of where the person starts, this page has the highest probability of being the final destination.</p>
    <p class="normal">The algorithm requires many iterations or passes through the collection of web pages to determine the right importance (or PageRank value) of each web page.</p>
    <p class="normal">To calculate a number from <code class="inlineCode">0</code> to <code class="inlineCode">1</code> that can quantify the importance of a particular page, the algorithm incorporates information from the following two components:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Information that was specific to the query entered by the user</strong>: This component estimates, in the context of the query entered by the user, how relevant the content of the web page is. The content of the page is directly dependent on the author of the page.</li>
      <li class="bulletList"><strong class="keyWord">Information that was not relevant to the query entered by the user</strong>: This component tries to quantify the importance of each web page in the context of its links, views, and neighborhood. The neighborhood of a web page is the group of web pages directly connected to a certain page. This component is difficult to calculate as web pages are heterogeneous, and coming up with criteria that can be applied across the web is difficult to develop.</li>
    </ul>
    <p class="normal">In order to implement the PageRank algorithm in Python, first, let’s import the necessary libraries:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
</code></pre>
    <p class="normal">Note that the network is from <a href="https://networkx.org/"><span class="url">https://networkx.org/</span></a>. For the purpose of this demonstration, let’s assume that we are analyzing only five web pages in the network. Let’s call this set of pages <code class="inlineCode">my_pages</code> and together they are in a network named <code class="inlineCode">my_web</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">my_web = nx.DiGraph()
my_pages = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)
</code></pre>
    <p class="normal">Now, let’s connect them randomly to simulate an actual network:</p>
    <pre class="programlisting code"><code class="hljs-code">connections = [(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)]
my_web.add_nodes_from(my_pages)
my_web.add_edges_from(connections)
</code></pre>
    <p class="normal">Now, let’s plot this graph:</p>
    <pre class="programlisting code"><code class="hljs-code">pos = nx.shell_layout(my_web)
nx.draw(my_web, pos, arrows=<span class="hljs-literal">True</span>, with_labels=<span class="hljs-literal">True</span>)
plt.show()
</code></pre>
    <p class="normal">It creates the visual<a id="_idIndexMarker328"/> representation of our network, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18046_04_07.png" alt="Shape  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 4.7: Visual representation of the network</p>
    <p class="normal">In the PageRank algorithm, the patterns of a web page are contained in a matrix called the transition matrix. There are algorithms that constantly update the transition matrix to capture the constantly changing state of the web. The size of the transition matrix is n x n, where n is the number of nodes. The numbers in the matrix are the probability that a visitor will next go to that link due to the outbound link.</p>
    <p class="normal">In our case, the preceding graph shows the static web that we have. Let’s define a function that can be used to create the transition matrix:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">create_page_rank</span>(<span class="hljs-params">a_graph</span>):
    nodes_set = <span class="hljs-built_in">len</span>(a_graph)
    M = nx.to numpy_matrix(a_graph)
    outwards = np.squeeze(np.asarray (np. <span class="hljs-built_in">sum</span> (M, axis=<span class="hljs-number">1</span>)))
    prob outwards = np.array([
        <span class="hljs-number">1.0 </span>/ count <span class="hljs-keyword">if</span> count&gt;<span class="hljs-number">0</span>
        <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>
        <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> outwards
    ])
    G = np.asarray(np.multiply (M.T, prob_outwards))
    p = np.ones(nodes_set) / <span class="hljs-built_in">float</span> (nodes_set)
    <span class="hljs-keyword">return</span> G, p
</code></pre>
    <p class="normal">Note that this <a id="_idIndexMarker329"/>function will return <code class="inlineCode">G</code>, which represents the transition matrix for our graph.</p>
    <p class="normal">Let’s generate the transition matrix for our graph:</p>
    <pre class="programlisting code"><code class="hljs-code">G,p = create_page_rank(my_web)
<span class="hljs-built_in">print</span> (G)
</code></pre>
    <figure class="mediaobject"><img src="../Images/B18046_04_08.png" alt="Calendar  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 4.8: Transition matrix</p>
    <p class="normal">Note that the transition matrix is 5 x 5 for our graph. Each column corresponds to each node in the graph. For example, column 2 is about the second node. There is a <code class="inlineCode">0.5</code> probability that the visitor will navigate from node 2 to node 1 or node 3. Note that the diagonal of the transition matrix is <code class="inlineCode">0</code> as in our graph, there is no outbound link from a node to itself. In an actual network, it may be possible.</p>
    <p class="normal">Note that the transition matrix is a sparse matrix. As the number of nodes increases, most of its values will be <code class="inlineCode">0</code>. Thus, the structure of a graph is extracted as a <em class="italic">transition matrix</em>. In a transaction matrix, nodes are represented in columns and rows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Columns</strong>: Indicates to the node that a web surfer is online</li>
      <li class="bulletList"><strong class="keyWord">Rows</strong>: Indicates the probability that the surfer will visit other nodes because of outbound links</li>
    </ul>
    <p class="normal">In the real web, the<a id="_idIndexMarker330"/> transition matrix that feeds the PageRank algorithm is built by spiders’ continuous exploration of links. </p>
    <h1 id="_idParaDest-128" class="heading-1">Understanding linear programming</h1>
    <p class="normal">Many real-world<a id="_idIndexMarker331"/> problems involve maximizing or minimizing an objective, with some given constraints. One approach is to specify the objective as a linear function of some variables. We also formulate the constraints on resources as equalities or inequalities on those variables. This approach is called the linear programming problem. The basic algorithm behind linear programming was developed by George Dantzig at the University of California at Berkeley in the early 1940s. Dantzig used this concept to experiment with logistical supply-and-capacity planning for troops while working for the US Air Force. </p>
    <p class="normal">At the end of the Second World War, Dantzig started working for the Pentagon and matured his algorithm into a technique that he named linear programming. It was used for military combat planning.</p>
    <p class="normal">Today, it is used to solve important real-world problems that relate to minimizing or maximizing a variable based on certain constraints. Some examples of these problems are as follows:</p>
    <ul>
      <li class="bulletList">Minimizing the time to repair a car at a mechanic shop based on the resources</li>
      <li class="bulletList">Allocating available distributed resources in a distributed computing environment to minimize response times</li>
      <li class="bulletList">Maximizing the profit of a company based on the optimal assignment of resources within the company</li>
    </ul>
    <h2 id="_idParaDest-129" class="heading-2">Formulating a linear programming problem</h2>
    <p class="normal">The conditions for <a id="_idIndexMarker332"/>using linear programming are as follows:</p>
    <ul>
      <li class="bulletList">We should be able to formulate the problem through a set of equations.</li>
      <li class="bulletList">The variables used in the equation must be linear.</li>
    </ul>
    <h3 id="_idParaDest-130" class="heading-3">Defining the objective function</h3>
    <p class="normal">Note that the<a id="_idIndexMarker333"/> objective of each of the preceding three examples is about minimizing or maximizing a variable. This objective is mathematically formulated as a linear function of other variables and is called the objective function. The aim of a linear programming problem is to minimize or maximize the objective function while remaining within the specified constraints.</p>
    <h3 id="_idParaDest-131" class="heading-3">Specifying constraints</h3>
    <p class="normal">When trying to minimize <a id="_idIndexMarker334"/>or maximize something, there are certain constraints in real-world problems that need to be respected. For example, when trying to minimize the time it takes to repair a car, we also need to consider that there is a limited number of mechanics available. Specifying each constraint through a linear equation is an important part of formulating a linear programming problem.</p>
    <h2 id="_idParaDest-132" class="heading-2">A practical application – capacity planning with linear programming</h2>
    <p class="normal">Let’s look at a practical <a id="_idIndexMarker335"/>use case where linear programming can be used to solve a real-world problem. </p>
    <p class="normal">Let’s assume that we want to maximize the profits of a state-of-the-art factory that manufactures two different types of robots:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Advanced model </strong>(<strong class="keyWord">A</strong>): This provides full functionality. Manufacturing each unit of the advanced model results in a profit of $4,200.</li>
      <li class="bulletList"><strong class="keyWord">Basic model</strong> (<strong class="keyWord">B</strong>): This only provides basic functionality. Manufacturing each unit of the basic model results in a profit of $2,800.</li>
    </ul>
    <p class="normal">There are three different types of people needed to manufacture a robot. The exact number of days needed to manufacture a robot of each type is as follows:</p>
    <table id="table003-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Type of Robot</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Technician</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">AI Specialist</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Engineer</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Robot A: advanced model</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">3 days</p>
          </td>
          <td class="table-cell">
            <p class="normal">4 days</p>
          </td>
          <td class="table-cell">
            <p class="normal">4 days</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Robot B: basic model</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">2 days</p>
          </td>
          <td class="table-cell">
            <p class="normal">3 days</p>
          </td>
          <td class="table-cell">
            <p class="normal">3 days</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">The factory runs on 30-day cycles. A single AI specialist is available for 30 days in a cycle. Each of the two engineers will take 8 days off in 30 days. So, an engineer is available only for 22 days in a cycle. There is a single technician available for 20 days in a 30-day cycle.</p>
    <p class="normal">The following table shows the number of people we have in the factory:</p>
    <table id="table004-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell"/>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Technician</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">AI Specialist</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Engineer</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Number of people</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Total number of days in a cycle</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">1 x 20 = 20 days</p>
          </td>
          <td class="table-cell">
            <p class="normal">1 x 30 = 30 days</p>
          </td>
          <td class="table-cell">
            <p class="normal">2 x 22 = 44 days</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">This can be <a id="_idIndexMarker336"/>modeled as follows:</p>
    <ul>
      <li class="bulletList">Maximum profit = 4200A + 2800B</li>
      <li class="bulletList">This is subject to the following:<ul>
          <li class="bulletList"><code class="inlineCode">A ≥ 0</code>: The number of advanced robots produced can be 0 or more.</li>
          <li class="bulletList"><code class="inlineCode">B ≥</code><code class="inlineCode"> 0</code>: The number of basic robots produced can be 0 or more.</li>
          <li class="bulletList"><code class="inlineCode">3A + 2B ≤ 20</code>: These are the constraints of the technician’s availability.</li>
          <li class="bulletList"><code class="inlineCode">4A+3B ≤ 30</code>: These are the constraints of the AI specialist’s availability.</li>
          <li class="bulletList"><code class="inlineCode">4A+ 3B ≤ 44</code>: These are the constraints of the engineers’ availability.</li>
        </ul>
      </li>
    </ul>
    <p class="normal">First, we import the Python package named <code class="inlineCode">pulp</code>, which is used to implement linear programming:</p>
    <pre class="programlisting con"><code class="hljs-con">import pulp
</code></pre>
    <p class="normal">Then, we call the <code class="inlineCode">LpProblem</code> function in this package to instantiate the problem class. We name the instance <code class="inlineCode">Profit maximising problem</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Instantiate our problem class</span>
model = pulp.LpProblem(<span class="hljs-string">"Profit_maximising_problem"</span>, pulp.LpMaximize)
</code></pre>
    <p class="normal">Then, we define two linear variables, <code class="inlineCode">A</code> and <code class="inlineCode">B</code>. Variable <code class="inlineCode">A</code> represents the number of advanced robots that are produced and variable <code class="inlineCode">B</code> represents the number of basic robots that are produced:</p>
    <pre class="programlisting code"><code class="hljs-code">A = pulp.LpVariable(<span class="hljs-string">'A'</span>, lowBound=<span class="hljs-number">0</span>,  cat=<span class="hljs-string">'Integer'</span>)
B = pulp.LpVariable(<span class="hljs-string">'B'</span>, lowBound=<span class="hljs-number">0</span>, cat=<span class="hljs-string">'Integer'</span>)
</code></pre>
    <p class="normal">We define the <a id="_idIndexMarker337"/>objective function and constraints as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Objective function</span>
model += <span class="hljs-number">5000</span> * A + <span class="hljs-number">2500</span> * B, <span class="hljs-string">"Profit"</span>
<span class="hljs-comment"># Constraints</span>
model += <span class="hljs-number">3</span> * A + <span class="hljs-number">2</span> * B &lt;= <span class="hljs-number">20</span> 
model += <span class="hljs-number">4</span> * A + <span class="hljs-number">3</span> * B &lt;= <span class="hljs-number">30</span>
model += <span class="hljs-number">4</span> * A + <span class="hljs-number">3</span> * B &lt;= <span class="hljs-number">44</span>
</code></pre>
    <p class="normal">We use the solve function to generate a solution:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Solve our problem</span>
model.solve()
pulp.LpStatus[model.status]
</code></pre>
    <p class="normal">Then, we print the values of <code class="inlineCode">A</code> and <code class="inlineCode">B</code> and the value of the objective function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Print our decision variable values</span>
<span class="hljs-built_in">print</span> (A.varValue)
<span class="hljs-built_in">print</span> (B.varValue)
</code></pre>
    <p class="normal">The output is:</p>
    <pre class="programlisting con"><code class="hljs-con">6.0
1.0
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Print our objective function value</span>
<span class="hljs-built_in">print</span> (pulp.value(model.objective))
</code></pre>
    <p class="normal">It prints:</p>
    <pre class="programlisting con"><code class="hljs-con">32500.0
</code></pre>
    <div class="note">
      <p class="normal">Linear programming is extensively used in the manufacturing industry to find the optimal number of products that should be used to optimize the use of available resources.</p>
    </div>
    <p class="normal">And here we <a id="_idIndexMarker338"/>come to the end of this chapter! Let’s summarize what we have learned.</p>
    <h1 id="_idParaDest-133" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we studied various approaches to designing an algorithm. We looked at the trade-offs involved in choosing the correct design of an algorithm. We looked at the best practices for formulating a real-world problem. We also learned how to solve a real-world optimization problem. The lessons learned from this chapter can be used to implement well-designed algorithms.</p>
    <p class="normal">In the next chapter, we will focus on graph-based algorithms. We will start by looking at different ways of representing graphs. Then, we will study the techniques to establish a neighborhood around various data points to conduct a particular investigation. Finally, we will study the optimal ways to search for information in graphs.</p>
    <h1 id="_idParaDest-134" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>