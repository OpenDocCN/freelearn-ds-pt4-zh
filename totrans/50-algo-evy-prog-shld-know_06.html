<html><head></head><body>
  <div id="_idContainer116" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-135" class="chapterTitle">Graph Algorithms</h1>
    <p class="normal">Graphs offer a distinct way to represent data structures, especially when compared to structured or tabular data. While structured data, such as databases, excel at storing and querying static, uniform information, graphs shine in capturing intricate relationships and patterns that exist among entities. Think of Facebook, where every user is a node, and each friendship or interaction becomes a connecting edge; this web of connections can be best represented and analyzed using graph structures.</p>
    <p class="normal">In the computational realm, certain problems, often those involving relationships and connections, are more naturally addressed using graph algorithms. At their core, these algorithms aim to understand the structure of the graph. This understanding involves figuring out how data points (or nodes) connect via links (or edges) and how to effectively navigate these connections to retrieve or analyze the desired data.</p>
    <p class="normal">In this chapter, we’ll embark on a journey through the following territories:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Graph representations</strong>: Various ways to capture graphs.</li>
      <li class="bulletList"><strong class="keyWord">Network theory analysis</strong>: The foundational theory behind network structures.</li>
      <li class="bulletList"><strong class="keyWord">Graph traversals</strong>: Techniques to efficiently navigate through a graph.</li>
      <li class="bulletList"><strong class="keyWord">Case study</strong>: Delving into fraud analytics using graph algorithms.</li>
      <li class="bulletList"><strong class="keyWord">Neighborhood techniques</strong>: Methods to ascertain and analyze localized regions within larger graphs.</li>
    </ul>
    <p class="normal">Upon completion, we will have a robust grasp of graphs as data structures. We should be able to formulate complex relationships—both direct and indirect—and will be equipped to tackle complex, real-world problems using graph algorithms.</p>
    <h1 id="_idParaDest-136" class="heading-1">Understanding graphs: a brief introduction</h1>
    <p class="normal">In the vast interconnected landscapes of modern data, beyond the confines of tabular models, graph structures emerge as powerful tools to encapsulate intricate relationships. Their rise isn’t merely a trend but a response to challenges posed by the digital world’s interwoven fabric. Historical strides in graph theory, like Leonhard Euler’s pioneering solution to the Seven Bridges of Königsberg problem, laid the foundation for understanding complex relationships. Euler’s method of translating real-world issues into graphical representations revolutionized how we perceive and navigate graphs.</p>
    <h2 id="_idParaDest-137" class="heading-2">Graphs: the backbone of modern data networks</h2>
    <p class="normal">Graphs not only provide the backbone for platforms such as social media networks and recommendation engines but also serve as the key to unlocking patterns in seemingly unrelated sectors, like road networks, electrical circuits, organic molecules, ecosystems, and even the flow of logic in computer programs. What’s pivotal to graphs is their intrinsic capability to express both tangible and intangible interactions.</p>
    <p class="normal">But why is this structure, with its nodes and edges, so central to modern computing? The answer lies in graph algorithms. Tailored for understanding and interpreting relationships, these mathematical algorithms are precisely designed to process connections. They establish clear steps to decode a graph, revealing both its overarching characteristics and intricate details.</p>
    <p class="normal">Before delving into representations of graphs, it’s crucial to establish a foundational understanding of the mechanics behind them. Graphs, rooted in the rich soil of mathematics and computer science, offer an illustrative method to depict relationships among entities.</p>
    <h3 id="_idParaDest-138" class="heading-3">Real-world applications</h3>
    <p class="normal">The increasingly intricate patterns and connections observed in modern data find clarity in graph theory. Beyond the simple nodes and edges lie the solutions to some of the world’s most complex problems. When the mathematical precision of graph algorithms meets real-world challenges, the outcomes can be astonishingly transformative:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Fraud detection</strong>: In the world of digital finance, fraudulent transactions can be deeply interconnected, often weaving a subtle web meant to deceive conventional detection systems. Graph theory is deployed to spot these patterns. For instance, a sudden spike in interconnected small transactions from a singular source to multiple accounts might be a hint at money laundering. 
    <p class="bulletList">By charting out these transactions on a graph, analysts can identify unusual patterns, isolate suspicious nodes, and trace the origin of potential fraud, ensuring that digital economies remain secure.</p></li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Air traffic control</strong>: The skies are bustling with movement. Every aircraft must navigate a maze of routes while ensuring safe distances from others. Graph algorithms map the skies, treating each aircraft as a node and their flight paths as edges. The 2010 US air travel congestion events are a testament to the power of graph analytics. Scientists used graph theory to decipher systemic cascading delays, offering insights to optimize flight schedules and reduce the chances of such occurrences in the future.</li>
      <li class="bulletList"><strong class="keyWord">Disease spread modeling</strong>: The proliferation of diseases, especially contagious ones, doesn’t happen randomly; they follow the invisible lines of human interaction and movement. Graph theory creates intricate models that mimic these patterns. By treating individuals as nodes and their interactions as edges, epidemiologists have successfully projected disease spread, identifying potential hotspots and enabling timely interventions. For instance, during the early days of the COVID-19 pandemic, graph algorithms played a pivotal role in predicting potential outbreak clusters, helping to guide lockdowns and other preventive measures.</li>
      <li class="bulletList"><strong class="keyWord">Social media recommendations</strong>: Ever wondered how platforms like Facebook or Twitter suggest friends or content? Underlying these suggestions are vast graphs representing user interactions, interests, and behaviors. For example, if two users have multiple mutual friends or similar engagement patterns, there’s a high likelihood they might know each other or have aligned interests. Graph algorithms help decode these connections, enabling platforms to enhance user experience through relevant recommendations.</li>
    </ul>
    <h2 id="_idParaDest-139" class="heading-2">The basics of a graph: vertices (or nodes)</h2>
    <p class="normal">These are the individual entities or data points in the graph. Imagine each friend on your Facebook list as a separate vertex:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Edges (or links</strong>): The connections or relationships between the vertices. When you become friends with someone on Facebook, an edge is formed between your vertex and theirs.</li>
      <li class="bulletList"><strong class="keyWord">Network</strong>: A larger structure formed by the interconnected web of vertices and edges. For example, the entirety of Facebook, with all its users and their friendships, can be viewed as a colossal network. </li>
    </ul>
    <p class="normal">In <em class="italic">Figure 5.1</em>, <strong class="screenText">A</strong>, <strong class="screenText">B</strong>, and <strong class="screenText">C</strong> represent vertices, while the lines connecting them are edges. It’s a simple representation of a graph, laying the groundwork for the more intricate structures and operations we’ll explore.</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.1: Graphic representation of a simple graph</p>
    <h1 id="_idParaDest-140" class="heading-1">Graph theory and network analysis</h1>
    <p class="normal">Graph theory and network analysis, although intertwined, serve different functions in understanding <a id="_idIndexMarker339"/>complex systems. While graph theory is a branch of discrete mathematics <a id="_idIndexMarker340"/>that provides the foundational concepts of nodes (entities) and edges (relationships), network analysis is the application of these principles to study and interpret real-world networks. For instance, graph theory might define the structure of a social media platform where individuals are nodes and their friendships are edges; conversely, network analysis would delve into this structure to uncover patterns, like influencer hubs or isolated communities, thereby providing actionable insights into user behavior and platform dynamics. </p>
    <p class="normal">We will first start by looking into how we can mathematically and visually represent the graphs. Then we’ll harness the power of network analysis on these representations using a pivotal set of tools known as “graph algorithms.”</p>
    <h1 id="_idParaDest-141" class="heading-1">Representations of graphs</h1>
    <p class="normal">A graph is a structure that represents data in terms of vertices and edges. A graph is represented as <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub> = (<img src="../Images/B18046_05_001.png" alt="" role="presentation"/>, <img src="../Images/B18046_05_002.png" alt="" role="presentation"/>), where <img src="../Images/B18046_05_003.png" alt="" role="presentation"/> represents a set of vertices and <img src="../Images/B18046_05_004.png" alt="" role="presentation"/> represents a set of edges. Note that <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub> has <img src="../Images/B18046_05_005.png" alt="" role="presentation"/> vertices and <img src="../Images/B18046_05_006.png" alt="" role="presentation"/> edges. It’s important to note that unless specified <a id="_idIndexMarker341"/>otherwise, an edge can be bidirectional, implying a two-way relationship between the connected vertices.</p>
    <p class="normal">A vertex, <img src="../Images/B18046_05_007.png" alt="" role="presentation"/>, represents a real-world object, such as a person, a computer, or an activity. An edge, <img src="../Images/B18046_05_008.png" alt="" role="presentation"/>, connects two vertices in a network:</p>
    <p class="center"><img src="../Images/B18046_05_009.png" alt="" role="presentation"/></p>
    <p class="normal">The preceding equation indicates that in a graph, all edges belong to a set, <img src="../Images/B18046_05_004.png" alt="" role="presentation"/>, and all vertices belong to a set, <img src="../Images/B18046_05_001.png" alt="" role="presentation"/>. Note that the notation ‘|’ used here is a symbolic representation indicating that an element belongs to a particular set, ensuring clarity in the relationship between edges, vertices, and their respective sets.</p>
    <p class="normal">A vertex <a id="_idIndexMarker342"/>symbolizes tangible entities like individuals or computers, whereas an edge, connecting two vertices, denotes a relationship. Such relationships can be friendships between individuals, online connections, physical links between devices, or participatory connections such as attending a conference.</p>
    <h1 id="_idParaDest-142" class="heading-1">Graph mechanics and types</h1>
    <p class="normal">There are multiple <a id="_idIndexMarker343"/>types of graphs, each with its unique attributes:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Simple graph</strong>: A graph <a id="_idIndexMarker344"/>with no parallel edges or loops.</li>
      <li class="bulletList"><strong class="keyWord">Directed graph (DiGraph)</strong>: A graph <a id="_idIndexMarker345"/>where each edge has a direction, indicating a one-way relationship.</li>
      <li class="bulletList"><strong class="keyWord">Undirected graph</strong>: A graph <a id="_idIndexMarker346"/>where edges don’t have a specific direction, suggesting a mutual relationship.</li>
      <li class="bulletList"><strong class="keyWord">Weighted graph</strong>: A graph <a id="_idIndexMarker347"/>where each edge carries a weight, often representing distances, costs, etc.</li>
    </ul>
    <p class="normal">In this chapter, we will <a id="_idIndexMarker348"/>use the <code class="inlineCode">networkx</code> Python package to represent graphs. It can be downloaded from <a href="https://networkx.org/"><span class="url">https://networkx.org/</span></a>. Let’s try to create a simple graph using the <code class="inlineCode">networtx</code> package in Python. A “simple graph,” as alluded to in graph theory, is a graph that has no parallel edges or loops. To begin with, let’s try to create an empty graph, <code class="inlineCode">aGraph</code>, with no vertex or node:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
graph = nx.Graph()
</code></pre>
    <p class="normal">Let’s add a single vertex:</p>
    <pre class="programlisting code"><code class="hljs-code">graph.add_node(<span class="hljs-string">"Mike"</span>)
</code></pre>
    <p class="normal">We can also add a series of vertices using a list:</p>
    <pre class="programlisting code"><code class="hljs-code">graph.add_nodes_from([<span class="hljs-string">"Amine"</span>, <span class="hljs-string">"Wassim"</span>, <span class="hljs-string">"Nick"</span>])
</code></pre>
    <p class="normal">We can also add one edge between the existing vertices, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">graph.add_edge(<span class="hljs-string">"Mike"</span>, <span class="hljs-string">"Amine"</span>)
</code></pre>
    <p class="normal">Let’s now print the edges and avertices:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(graph.nodes())
<span class="hljs-built_in">print</span>(graph.edges())
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">['Mike', 'Amine', 'Wassim', 'Nick']
[('Mike', 'Amine')]
</code></pre>
    <p class="normal">Please note <a id="_idIndexMarker349"/>that if we add an edge, this also leads to adding the associated vertices, if they do not already exist, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">G.add_edge(<span class="hljs-string">"</span><span class="hljs-string">Amine"</span>, <span class="hljs-string">"Imran"</span>)
</code></pre>
    <p class="normal">If we print the list of nodes, the following is the output that we observe:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(graph.edges())
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[('Mike', 'Amine'), ('Amine', 'Imran')]
</code></pre>
    <p class="normal">Note that the request to add a vertex that already exists is silently ignored. The request is ignored or considered based on the type of graph we have created.</p>
    <h2 id="_idParaDest-143" class="heading-2">Ego-centered networks</h2>
    <p class="normal">At the heart <a id="_idIndexMarker350"/>of many network analyses lies a concept called <a id="_idIndexMarker351"/>the ego-centered network, or simply, the egonet. Imagine wanting to study not just an individual node but also its immediate surroundings. This is where the egonet comes into play.</p>
    <h3 id="_idParaDest-144" class="heading-3">Basics of egonets</h3>
    <p class="normal">For a given vertex—let’s call it <em class="italic">m</em>—the surrounding nodes that are directly connected to <em class="italic">m</em> from its <a id="_idIndexMarker352"/>direct neighborhood. This neighborhood, combined with <em class="italic">m</em> itself, constitutes the egonet of <em class="italic">m</em>. In this context:</p>
    <ul>
      <li class="bulletList"><em class="italic">m</em> is referred to as the <em class="italic">ego</em>.</li>
      <li class="bulletList">The directly connected nodes are termed <em class="italic">one-hop neighbors</em> or simply <em class="italic">alters</em>.</li>
    </ul>
    <h3 id="_idParaDest-145" class="heading-3">One-hop, two-hop, and beyond</h3>
    <p class="normal">When we say “one-hop neighbors,” we refer to nodes that are directly connected to our node of interest. Think <a id="_idIndexMarker353"/>of it as a single step or “hop” from one node to <a id="_idIndexMarker354"/>the next. If we were to consider nodes that are two steps away, they’d be termed “two-hop neighbors,” and so on. This <a id="_idIndexMarker355"/>nomenclature can extend to any number <a id="_idIndexMarker356"/>of hops, paving the way to understanding <em class="italic">n</em>-degree neighborhoods.</p>
    <p class="normal">The ego network of a particular node, <strong class="screenText">3</strong>, is shown in the following graph:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.2: Egonet of node 3, showcasing the ego and its one-hop neighbors</p>
    <h3 id="_idParaDest-146" class="heading-3">Applications of egonets</h3>
    <p class="normal">Egonets are widely utilized in social network analysis. They are pivotal in understanding local structures <a id="_idIndexMarker357"/>in large networks and can offer insights into individual behaviors, based on their immediate network surroundings. </p>
    <p class="normal">For instance, in online social platforms, egonets can help detect influential nodes or understand information dissemination patterns within localized network regions.</p>
    <h1 id="_idParaDest-147" class="heading-1">Introducing network analysis theory</h1>
    <p class="normal">Network analysis allows us to delve into data that’s interconnected, presenting it in the form of a network. It involves studying and employing methodologies to examine data that’s arranged in <a id="_idIndexMarker358"/>this network format. Here, we’ll break down the core elements and concepts related to network analysis.</p>
    <p class="normal">At the heart of a network lies the “vertex,” serving as the fundamental unit. Picture a network as a web; vertices are the points of this web, while the links connecting them represent relationships between different entities under study. Notably, different relationships can exist between two vertices, implying that edges can be labeled to denote various kinds of relationships. Imagine two people being connected as “friends” and “colleagues”; both are different relationships but link the same individuals.</p>
    <p class="normal">To fully harness the potential of network analysis, it’s vital to gauge the significance of a vertex within a network, especially concerning the problem at hand. Multiple techniques exist to aid us in ascertaining this significance.</p>
    <p class="normal">Let’s look at some of the important concepts used in network analysis theory.</p>
    <h2 id="_idParaDest-148" class="heading-2">Understanding the shortest path</h2>
    <p class="normal">In graph theory, a “path” is defined as a sequence of nodes, connecting a starting node to an ending node, without revisiting any node in between. Essentially, a path outlines the route between <a id="_idIndexMarker359"/>two chosen vertices. The “length” of this path is determined by counting the number of edges it contains. Among the various paths possible between two nodes, the one with the least number of edges is termed the “shortest path.”</p>
    <p class="normal">Identifying the shortest <a id="_idIndexMarker360"/>path is a fundamental task in many graph algorithms. However, its determination isn’t always straightforward. Over time, multiple algorithms have been developed to tackle this problem, with Dijkstra’s algorithm, introduced in the late 1950s, being one of the most renowned. This algorithm is designed to pinpoint the shortest distance in a graph and has found its way into applications like GPS devices, which rely on it to deduce the minimal distance between two points. In the realm of network routing, Dijkstra’s method again proves invaluable.</p>
    <p class="normal">Big tech companies like Google and Apple are in a continuous race, especially when it comes to enhancing their map services. The goal is not just to identify the shortest route but to do so swiftly, often in mere seconds.</p>
    <p class="normal">Later in this chapter, we’ll <a id="_idIndexMarker361"/>explore the <strong class="keyWord">breadth-first search</strong> (<strong class="keyWord">BFS</strong>) algorithm, a method that can serve as a foundation for Dijkstra’s algorithm. The standard BFS assumes equal costs to traverse any path in a graph. However, Dijkstra’s takes into account varying traversal costs. To adapt BFS into Dijkstra’s, we need <a id="_idIndexMarker362"/>to integrate these varying traversal costs.</p>
    <p class="normal">Lastly, while Dijkstra’s <a id="_idIndexMarker363"/>algorithm focuses on identifying the shortest path from a single source to all other vertices, if one aims to determine the shortest paths between every pair of vertices in a graph, the Floyd-Warshall algorithm is more suitable.</p>
    <h3 id="_idParaDest-149" class="heading-3">Creating a neighborhood</h3>
    <p class="normal">When diving into graph algorithms, the term “neighborhood” frequently emerges. So, what do we imply by a neighborhood in this setting? Think of it as a close-knit community centered <a id="_idIndexMarker364"/>around a specific node. This “community” comprises nodes that either have a direct connection or are closely associated with the focal node. </p>
    <p class="normal">As an analogy, envision a city map where landmarks represent nodes. The landmarks in the immediate vicinity of a notable place form its “neighborhood.”</p>
    <p class="normal">A widely adopted approach to demarcate these neighborhoods is through the <em class="italic">k</em>-order strategy. Here, we determine a node’s neighborhood by pinpointing vertices that lie <em class="italic">k</em> hops away. For a hands-on understanding, at <em class="italic">k</em>=<em class="italic">1</em>, the neighborhood houses all nodes linked directly to the focal node. For <em class="italic">k</em>=<em class="italic">2</em>, it broadens to include nodes connected to these immediate neighbors, and the pattern continues.</p>
    <p class="normal">Imagine a central dot within a circle as our target vertex. At <em class="italic">k</em>=<em class="italic">1</em>, any dot connected directly to this central figure is its neighbor. As we increment <em class="italic">k</em> the circle’s radius grows, encapsulating dots situated further away.</p>
    <p class="normal">Harnessing and interpreting neighborhoods is important for graph algorithms, as it identifies key analysis zones.</p>
    <p class="normal">Let’s look at the various criteria to create neighborhoods:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Triangles</li>
      <li class="numberedList">Density</li>
    </ol>
    <p class="normal">Let us look into them in more detail.</p>
    <h3 id="_idParaDest-150" class="heading-3">Triangles</h3>
    <p class="normal">In the expansive world of graph theory, pinpointing vertices that share robust interconnections can unveil critical insights. A classic approach is to spot triangles— subgraphs where three nodes maintain direct connections among themselves.</p>
    <p class="normal">Let’s explore this <a id="_idIndexMarker365"/>through a tangible use case, fraud detection, which we’ll dissect in more detail in this chapter’s case study. Imagine a scenario where there’s an interconnected web – an “egonet” – revolving around a central person—let’s name him Max. In this egonet, apart from Max, there are two individuals, Alice and Bob. Now, this trio forms a “triangle” - Max is our primary figure (or “ego”), while Alice and Bob are the secondary figures (or “alters”).</p>
    <p class="normal">Here’s where it gets interesting: if Alice and Bob have past records of fraudulent activities, it raises red flags about Max’s credibility. It’s like discovering two of your close friends have been involved in dubious deeds - it naturally puts you under scrutiny. However, if only one of them has a questionable past, then Max’s situation becomes ambiguous. We can’t label him outright but would need deeper investigation.</p>
    <p class="normal">To visualize, picture Max at the center of a triangle, with Alice and Bob at the other vertices. Their interrelationships, especially if they carry negative connotations, can influence the perception of Max’s integrity.</p>
    <h3 id="_idParaDest-151" class="heading-3">Density</h3>
    <p class="normal">In the realm of graph theory, density is a metric that quantifies how closely knit a network is. Specifically, it’s the ratio of the number of edges present in the graph to the maximum possible <a id="_idIndexMarker366"/>number of edges. Mathematically, for a simple undirected graph, density is defined as:</p>
    <p class="center"><img src="../Images/B18046_05_012.png" alt="" role="presentation"/></p>
    <p class="normal">To put this into perspective, let’s consider an example:</p>
    <p class="normal">Suppose we are part of a book club with five members: Alice, Bob, Charlie, Dave, and Eve. If every member knows and has interacted with every other member, there would be a total of 10 connections (or edges) among them (Alice-Bob, Alice-Charlie, Alice-Dave, Alice-Eve, Bob-Charlie, and so on). In this case, the maximum number of possible connections or edges is 10. If all these connections exist, then the density is:</p>
    <p class="center"><img src="../Images/B18046_05_013.png" alt="" role="presentation"/></p>
    <p class="normal">This indicates a perfectly dense or fully connected network.</p>
    <p class="normal">However, let’s assume Alice knows only Bob and Charlie, Bob knows Alice and Dave, and Charlie knows only Alice. Dave and Eve, although members, haven’t interacted with anyone yet. In this scenario, there are only three actual connections: Alice-Bob, Alice-Charlie, and Bob-Dave. Let’s calculate the density:</p>
    <p class="center"><img src="../Images/B18046_05_014.png" alt="" role="presentation"/></p>
    <p class="normal">This value, being less than 1, shows that the book club’s interaction network isn’t fully connected; many potential interactions (edges) haven’t occurred yet.</p>
    <p class="normal">In essence, a density close to 1 indicates a tightly connected network, while a value closer to 0 suggests <a id="_idIndexMarker367"/>sparse interactions. Understanding density can help in various scenarios, from analyzing social networks to optimizing infrastructure planning, by gauging how interconnected the elements of the system are.</p>
    <h2 id="_idParaDest-152" class="heading-2">Understanding centrality measures</h2>
    <p class="normal">Centrality measures offer a window into understanding the significance of individual nodes within a graph. Think of centrality to identify key players or hubs in a network. For instance, in a <a id="_idIndexMarker368"/>social setting, it can help pinpoint influencers or central figures that hold sway. In urban planning, centrality might indicate <a id="_idIndexMarker369"/>pivotal buildings or junctions that play a critical role in traffic flow or accessibility. Understanding centrality is essential because it reveals nodes that are crucial for the functioning, cohesion, or influence within a network.</p>
    <p class="normal">The most employed centrality metrics in graph analysis encompass:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Degree</strong>: Reflects the direct connections a node has.</li>
      <li class="bulletList"><strong class="keyWord">Betweenness</strong>: Indicates how often a node acts as a bridge along the shortest path between two other nodes.</li>
      <li class="bulletList"><strong class="keyWord">Closeness</strong>: Represents how close a node is to all other nodes in the network.</li>
      <li class="bulletList"><strong class="keyWord">Eigenvector</strong>: Measures a node’s influence based on the quality of its connections, not just the quantity.</li>
    </ul>
    <p class="normal">Note that centrality measures apply to all graphs. As we know, graphs are a general representation of objects (vertices or nodes) and their relationships (edges), and centrality measures help identify the importance or influence of these nodes within the graph. Recall that <a id="_idIndexMarker370"/>networks are specific realizations <a id="_idIndexMarker371"/>or applications of graphs, often representing real-world systems like social networks, transportation systems, or communication networks. So, while the centrality measures discussed can be applied universally across all types of graphs, they are often highlighted in the context of networks due to their practical implications in understanding and optimizing real-world systems.</p>
    <p class="normal">Let’s delve deeper into these metrics to better appreciate their utility and nuances.</p>
    <h3 id="_idParaDest-153" class="heading-3">Degree</h3>
    <p class="normal">The number of <a id="_idIndexMarker372"/>edges connected to a particular vertex is called its <strong class="keyWord">degree</strong>. It can <a id="_idIndexMarker373"/>indicate how well connected a particular vertex is and its ability to quickly spread a message across a network.</p>
    <p class="normal">Let’s consider <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub> = (<img src="../Images/B18046_05_001.png" alt="" role="presentation"/>, <img src="../Images/B18046_05_016.png" alt="" role="presentation"/>), where <img src="../Images/B18046_05_017.png" alt="" role="presentation"/> represents a set of vertices and <img src="../Images/B18046_05_016.png" alt="" role="presentation"/> represents a set of edges. Recall that <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub> has <img src="../Images/B18046_05_019.png" alt="" role="presentation"/> vertices and <img src="../Images/B18046_05_020.png" alt="" role="presentation"/> edges. If we divide the degree of a node by (<img src="../Images/B18046_05_021.png" alt="" role="presentation"/>), it is called degree centrality:</p>
    <p class="center"><img src="../Images/B18046_05_022.png" alt="" role="presentation"/></p>
    <p class="normal">Now, let’s look at a specific example. Consider the following graph:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_03.png" alt="A picture containing text, indoor, device  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.3: A sample graph illustrating the concept of degree and degree centrality</p>
    <p class="normal">Now, in the <a id="_idIndexMarker374"/>preceding graph, vertex <em class="italic">C</em> has a degree of 4. Its degree <a id="_idIndexMarker375"/>centrality can be calculated as follows:</p>
    <p class="center"><img src="../Images/B18046_05_023.png" alt="" role="presentation"/></p>
    <h3 id="_idParaDest-154" class="heading-3">Betweenness</h3>
    <p class="normal">Betweenness <a id="_idIndexMarker376"/>centrality is a key measure that gauges the significance of a vertex within a graph. When applied to social media contexts, it assesses the likelihood that an individual plays a crucial role in communications within a specific subgroup. In terms of computer networks, where a vertex symbolizes a computer, betweenness offers insights into the potential impact on communications between nodes if a particular computer (or vertex) were to fail.</p>
    <p class="normal">To calculate the <a id="_idIndexMarker377"/>betweenness of vertex <em class="italic">a</em> in a certain <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub> = (<img src="../Images/B18046_05_001.png" alt="" role="presentation"/>, <img src="../Images/B18046_05_016.png" alt="" role="presentation"/>), follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Compute the shortest paths between each pair of vertices in <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub>. Let’s represent this with <img src="../Images/B18046_05_026.png" alt="" role="presentation"/></li>
      <li class="numberedList">From<img src="../Images/B18046_05_027.png" alt="" role="presentation"/>, count the number of shortest paths that pass through vertex <em class="italic">a</em>. Let’s represent this with <img src="../Images/B18046_05_028.png" alt="" role="presentation"/></li>
      <li class="numberedList">Calculate the betweenness with:</li>
    </ol>
    <p class="center"><img src="../Images/B18046_05_029.png" alt="" role="presentation"/></p>
    <h3 id="_idParaDest-155" class="heading-3">Fairness and closeness</h3>
    <p class="normal">In graph theory, we often want to determine how central or how distant a specific vertex is in <a id="_idIndexMarker378"/>relation to other vertices. One way to quantify this is by calculating <a id="_idIndexMarker379"/>a metric known as “fairness.” For a given vertex, say “a,” in a graph “g,” the fairness is determined by adding up the distances from vertex “a” to every other vertex in the graph. Essentially, it gives us a sense of how “spread out” or “far” a vertex is from its neighbors. This concept ties in closely with the idea of centrality, where the centrality of a vertex measures its overall distance from all other vertices.</p>
    <p class="normal">Conversely, “closeness” can <a id="_idIndexMarker380"/>be thought of as the opposite of fairness. While <a id="_idIndexMarker381"/>it might be intuitive to think of closeness as the negative sum of a vertex’s distances from other vertices, that’s not technically accurate. Instead, closeness measures how near a vertex is to all other vertices in a graph, often calculated by taking the reciprocal of the sum of its distances to others.</p>
    <p class="normal">Both fairness <a id="_idIndexMarker382"/>and closeness are essential metrics in network <a id="_idIndexMarker383"/>analysis. They provide insight into how information might <a id="_idIndexMarker384"/>flow within a network or how influential a particular node might be. By <a id="_idIndexMarker385"/>understanding these metrics, one can derive a deeper comprehension of network structures and their underlying dynamics.</p>
    <h3 id="_idParaDest-156" class="heading-3">Eigenvector centrality</h3>
    <p class="normal">Eigenvector centrality is a metric that evaluates the significance of nodes within a graph. Rather than just considering the number of direct connections a node has, it takes into account the <a id="_idIndexMarker386"/>quality of those connections. In simple terms, a node is considered important if it is connected to other nodes that are themselves significant within the network.</p>
    <p class="normal">To give this a bit <a id="_idIndexMarker387"/>more mathematical context, imagine each node <em class="italic">v</em> has a centrality score <em class="italic">x</em>(<em class="italic">v</em>). For every node <em class="italic">v</em>, its eigenvector centrality is calculated based on the sum of the centrality scores of its neighbors, scaled by a factor <img src="../Images/B18046_05_030.png" alt="" role="presentation"/> (eigenvector’s associated eigenvalue):</p>
    <p class="center"><img src="../Images/B18046_05_031.png" alt="" role="presentation"/></p>
    <p class="normal">where <em class="italic">M</em>(<em class="italic">v</em>) denotes the neighbors of <em class="italic">v</em>.</p>
    <p class="normal">This idea of weighing the importance of a node based on its neighbors was foundational for Google when they developed the PageRank algorithm. The algorithm assigns a rank to every web page on the internet, signifying its importance, and is heavily influenced by the concept of eigenvector centrality.</p>
    <p class="normal">For readers interested in our upcoming watchtower example, understanding the essence of eigenvector centrality will provide deeper insights into the workings of sophisticated network analysis techniques.</p>
    <h2 id="_idParaDest-157" class="heading-2">Calculating centrality metrics using Python</h2>
    <p class="normal">Let’s <a id="_idIndexMarker388"/>create a network <a id="_idIndexMarker389"/>and then try to calculate its centrality <a id="_idIndexMarker390"/>metrics.</p>
    <h3 id="_idParaDest-158" class="heading-3">1. Setting the foundation: libraries and data</h3>
    <p class="normal">This includes <a id="_idIndexMarker391"/>importing necessary libraries and defining our data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
</code></pre>
    <p class="normal">For our sample, we’ve considered a set of vertices and edges:</p>
    <pre class="programlisting code"><code class="hljs-code">vertices = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)
edges = [(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">7</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">8</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)]
</code></pre>
    <p class="normal">In this setup, vertices represent individual points or nodes in our network. The edges signify the relationships or links between these nodes.</p>
    <h3 id="_idParaDest-159" class="heading-3">2. Crafting the graph</h3>
    <p class="normal">With the <a id="_idIndexMarker392"/>foundation set, we proceed to craft our graph. This involves feeding our data (vertices and edges) into the graph structure:</p>
    <pre class="programlisting code"><code class="hljs-code">graph = nx.Graph()
graph.add_nodes_from(vertices)
graph.add_edges_from(edges)
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">Graph()</code> function initiates an empty graph. The subsequent methods, <code class="inlineCode">add_nodes_from </code>and <code class="inlineCode">add_edges_from</code>, populate this graph with our defined nodes and edges.</p>
    <h3 id="_idParaDest-160" class="heading-3">3. Painting a picture: visualizing the graph</h3>
    <p class="normal">A graphical <a id="_idIndexMarker393"/>representation often speaks louder than raw data. Visualization not only aids comprehension but also offers a snapshot of the graph’s overall structure:</p>
    <pre class="programlisting code"><code class="hljs-code">nx.draw(graph, with_labels=<span class="hljs-literal">True</span>, node_color=<span class="hljs-string">'y'</span>, node_size=<span class="hljs-number">800</span>)
plt.show()
</code></pre>
    <p class="normal">This code paints the graph for us. The <code class="inlineCode">with_labels=True</code> method ensures each node is labeled, <code class="inlineCode">node_color</code> provides a distinct color, and <code class="inlineCode">node_size</code> adjusts the node’s size for clarity.</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_04.png" alt="A picture containing device  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.4: A schematic representation of the graph, showcasing nodes and their inter-relationships</p>
    <p class="normal">Once our <a id="_idIndexMarker394"/>graph is established, the next pivotal step is to compute and understand the centrality measures of each node. Centrality measures, as previously discussed, gauge the importance of nodes in the network.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Degree centrality</strong>: This <a id="_idIndexMarker395"/>measure gives the fraction of nodes that a particular node is connected to. In simpler terms, if a node has a high degree centrality, it’s connected to many other nodes in a graph. The function <code class="inlineCode">nx.degree_centrality(graph)</code> returns a dictionary with nodes as keys and their respective degree centrality as values:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Degree Centrality:"</span>, nx.degree_centrality(graph))
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Degree Centrality: {1: 0.25, 2: 0.5, 3: 0.25, 4: 0.25, 5: 0.25, 6: 0.125, 7: 0.625, 8: 0.125, 9: 0.125}
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Betweenness centrality</strong>: This metric indicates the number of shortest paths passing through <a id="_idIndexMarker396"/>a particular node. Nodes with high betweenness centrality can be seen as “bridges” or “bottlenecks” between different parts of a graph. The function <code class="inlineCode">nx.betweenness_centrality(graph)</code> computes this for each node:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Betweenness Centrality:"</span>, nx.betweenness_centrality(graph))
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Betweenness Centrality: {1: 0.25, 2: 0.46428571428571425, 3: 0.0, 4: 0.0, 5: 0.0, 6: 0.0, 7: 0.7142857142857142, 8: 0.0, 9: 0.0}
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Closeness centrality</strong>: This represents how close a node is to all other nodes in a graph. A node <a id="_idIndexMarker397"/>with high closeness centrality can quickly interact with all other nodes, making it centrally located. This measure is calculated with <code class="inlineCode">nx.closeness_centrality(graph)</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Closeness Centrality:"</span>, nx.closeness_centrality(graph))
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Closeness Centrality: {1: 0.5, 2: 0.6153846153846154, 3: 0.5333333333333333, 4: 0.47058823529411764, 5: 0.47058823529411764, 6: 0.34782608695652173, 7: 0.7272727272727273, 8: 0.4, 9: 0.4}
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Eigenvector centrality</strong>: Unlike the degree centrality, which counts direct connections, the <a id="_idIndexMarker398"/>eigenvector centrality considers the quality or strength of these connections. Nodes connected to other high-scoring nodes get a boost, making it a measure of influential nodes. We further sort these centrality values for ease of interpretation:
        <pre class="programlisting code"><code class="hljs-code">eigenvector_centrality = nx.eigenvector_centrality(graph)
sorted_centrality = <span class="hljs-built_in">sorted</span>((vertex, <span class="hljs-string">'{:0.2f}'</span>.<span class="hljs-built_in">format</span>(centrality_val)) 
                           <span class="hljs-keyword">for</span> vertex, centrality_val <span class="hljs-keyword">in</span> eigenvector_centrality.items())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Eigenvector Centrality:"</span>, sorted_centrality)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Eigenvector Centrality: [(1, '0.24'), (2, '0.45'), (3, '0.36'), (4, '0.32'), (5, '0.32'), (6, '0.08'), (7, '0.59'), (8, '0.16'), (9, '0.16')]
</code></pre>
      </li>
    </ul>
    <p class="normal">Note that the metrics of centrality are expected to give the centrality measure of a particular vertex in a graph or subgraph. Looking at the graph, the vertex labeled <em class="italic">7</em> seems to have <a id="_idIndexMarker399"/>the most central location. Vertex 7 has the highest values in all four metrics of centrality, thus reflecting its importance in this context.</p>
    <p class="normal">Now let’s look into how we can retrieve information from the graphs. Graphs are complex data structures with lots of information stored both in vertices and edges. Let’s look at some strategies that can be used to navigate through graphs efficiently, in order to gather information from them to answer queries.</p>
    <h2 id="_idParaDest-161" class="heading-2">Social network analysis</h2>
    <p class="normal"><strong class="keyWord">Social Network Analysis</strong> (<strong class="keyWord">SNA</strong>) stands <a id="_idIndexMarker400"/>out as a significant <a id="_idIndexMarker401"/>application within graph theory. At its core, an analysis qualifies as SNA when it adheres to the following criteria:</p>
    <ul>
      <li class="bulletList">Vertices in a graph symbolize individuals.</li>
      <li class="bulletList">Edges signify social connections between these individuals, which include friendships, shared interests, familial ties, differences in opinions, and more.</li>
      <li class="bulletList">The primary objective of graph analysis leans toward understanding a pronounced social context.</li>
    </ul>
    <p class="normal">One intriguing facet of SNA is its capacity to shed light on patterns linked to criminal behavior. By mapping out relationships and interactions, it’s feasible to pinpoint patterns or anomalies that might indicate fraudulent activities or behaviors. For instance, analyzing the connectivity patterns might reveal unusual connections or frequent interactions in specific locations, hinting at potential criminal hotspots or networks.</p>
    <div class="note">
      <p class="normal">LinkedIn has contributed a lot to the research and development of new techniques related to SNA. In fact, LinkedIn can be thought of as a pioneer of many algorithms in this area.</p>
    </div>
    <p class="normal">Thus, SNA—due to its inherent distributed and interconnected architecture of social networks—is one <a id="_idIndexMarker402"/>of the most powerful <a id="_idIndexMarker403"/>use cases for graph theory. Another way to abstract a graph is by considering it as a network and applying an algorithm designed for networks. This whole area is called network analysis theory, which we will discuss next.</p>
    <h1 id="_idParaDest-162" class="heading-1">Understanding graph traversals</h1>
    <p class="normal">To make use of graphs, information needs to be mined from them. Graph traversal is defined as the <a id="_idIndexMarker404"/>strategy used to make sure that every vertex and edge is visited in an orderly manner. An effort is made to make sure that each vertex and edge is visited exactly once—no more and no less. Broadly, there can be two different ways of traveling a graph to search the data in it. </p>
    <p class="normal">Earlier in this chapter we learned that going by breadth is called <strong class="keyWord">breadth-first search</strong> (<strong class="keyWord">BFS</strong>) – going by <a id="_idIndexMarker405"/>depth is called <strong class="keyWord">depth-first search</strong> (<strong class="keyWord">DFS</strong>). Let’s look at them one by one.</p>
    <h2 id="_idParaDest-163" class="heading-2">BFS</h2>
    <p class="normal">BFS works best <a id="_idIndexMarker406"/>when there is a concept of layers or levels of neighborhoods in the <em class="italic">a</em><sub class="subscript-italic" style="font-style: italic;">Graph</sub> we deal with. For example, when the connections of a person on LinkedIn are expressed as a graph, there are first-level connections and then there are second-level connections, which directly translate to the layers.</p>
    <p class="normal">The BFS algorithm starts from a root vertex and explores the vertices in the neighborhood vertices. It then moves to the next neighborhood level and repeats the process.</p>
    <p class="normal">Let’s look at a BFS algorithm. For that, let’s first consider the following undirected graph:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_05.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.5: An undirected graph demonstrating personal connections</p>
    <h3 id="_idParaDest-164" class="heading-3">Constructing the adjacency list</h3>
    <p class="normal">In Python, the dictionary data structure lends itself conveniently to representing the adjacency <a id="_idIndexMarker407"/>list of a graph. Here’s how <a id="_idIndexMarker408"/>we can define an undirected graph:</p>
    <pre class="programlisting code"><code class="hljs-code">graph={ <span class="hljs-string">'Amin'</span>   : {<span class="hljs-string">'Wasim'</span>, <span class="hljs-string">'Nick'</span>, <span class="hljs-string">'Mike'</span>},
         <span class="hljs-string">'Wasim'</span> : {<span class="hljs-string">'Imran'</span>, <span class="hljs-string">'Amin'</span>},
         <span class="hljs-string">'Imran'</span> : {<span class="hljs-string">'Wasim'</span>,<span class="hljs-string">'Faras'</span>},
         <span class="hljs-string">'Faras'</span> : {<span class="hljs-string">'Imran'</span>},
         <span class="hljs-string">'Mike'</span>  : {<span class="hljs-string">'Amin'</span>},
         <span class="hljs-string">'Nick'</span> :  {<span class="hljs-string">'Amin'</span>}}
</code></pre>
    <p class="normal">To implement it in Python, we will proceed as follows.</p>
    <p class="normal">We will first explain the initialization and then the main loop.</p>
    <h3 id="_idParaDest-165" class="heading-3">BFS algorithm implementation</h3>
    <p class="normal">The <a id="_idIndexMarker409"/>algorithm implementation will involve two main phases: the initialization and the main loop.</p>
    <h4 class="heading-4">Initialization</h4>
    <p class="normal">Our <a id="_idIndexMarker410"/>traversal through the graph relies on two key data structures:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">visited</strong>: A set that will hold all the vertices we’ve explored. It starts empty.</li>
      <li class="bulletList"><strong class="keyWord">queue</strong>: A list used to hold vertices pending exploration. Initially, it will contain just our starting vertex.</li>
    </ul>
    <h4 class="heading-4">Main loop</h4>
    <p class="normal">The primary <a id="_idIndexMarker411"/>logic of BFS revolves around exploring nodes layer by layer:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Remove the first node from the queue and consider it as the current node for the iteration:
        <pre class="programlisting code"><code class="hljs-code">node = queue.pop(<span class="hljs-number">0</span>)
</code></pre>
      </li>
      <li class="numberedList">If the node hasn’t been visited, mark it as visited and fetch its neighbors:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
    visited.add(node)
    neighbours = graph[node]
</code></pre>
      </li>
      <li class="numberedList">Append unvisited neighbors to the queue:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> neighbour <span class="hljs-keyword">in</span> neighbours:
    <span class="hljs-keyword">if</span> neighbour <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
        queue.append(neighbour)
</code></pre>
      </li>
      <li class="numberedList">Once the main loop is complete, the <code class="inlineCode">visited</code> data structure is returned, which contains all the nodes traversed.</li>
    </ol>
    <h4 class="heading-4">Complete BFS code implementation</h4>
    <p class="normal">The <a id="_idIndexMarker412"/>complete code, with both initialization and the main loop, will be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">graph, start</span>):
    visited = <span class="hljs-built_in">set</span>()
    queue = [start]
    <span class="hljs-keyword">while</span> queue:
        node = queue.pop(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:
            visited.add(node)
            neighbours = graph[node]
            unvisited_neighbours = [neighbour <span class="hljs-keyword">for</span> neighbour <span class="hljs-keyword">in</span> neighbours                                     <span class="hljs-keyword">if</span> neighbour <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited]
            queue.extend(unvisited_neighbours)
   <span class="hljs-keyword">return</span> visited
</code></pre>
    <p class="normal">The <a id="_idIndexMarker413"/>BFS traversal mechanism is as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The process starts at level one, represented by the node “Amin.”</li>
      <li class="numberedList">It then expands to level two, visiting “Wasim’,” “Nick,” and “Mike.”</li>
      <li class="numberedList">Subsequently, BFS delves into levels three and four, visiting “Imran” and “Faras,” respectively.</li>
    </ol>
    <p class="normal">By the time BFS completes its traversal, all nodes have been accounted for in the visited set, and the queue is empty.</p>
    <h3 id="_idParaDest-166" class="heading-3">Using BFS for specific searches</h3>
    <p class="normal">To practically <a id="_idIndexMarker414"/>understand BFS in action, let’s use our implemented function to find a path to a specific person in our graph:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_06.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.6: Layered traversal of a graph using BFS</p>
    <p class="normal">Now, let’s <a id="_idIndexMarker415"/>try to find a specific person from this graph using BFS. Let’s specify the data that we are searching for and observe the results:</p>
    <pre class="programlisting code"><code class="hljs-code">start_node = <span class="hljs-string">'Amin'</span>
<span class="hljs-built_in">print</span>(bfs(graph, start_node))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{'Faras', 'Nick', 'Wasim', 'Imran', 'Amin', 'Mike'}
</code></pre>
    <p class="normal">This signifies the sequence of nodes accessed when BFS starts from <code class="inlineCode">Amin</code>.</p>
    <p class="normal">Now let’s look into the DFS algorithm.</p>
    <h2 id="_idParaDest-167" class="heading-2">DFS</h2>
    <p class="normal"><strong class="keyWord">DFS</strong> offers an alternative approach to graph traversal than <strong class="keyWord">BFS</strong>. While BFS seeks to explore the graph level by level, focusing on immediate neighbors first, DFS ventures as deep as possible down a path before backtracking.</p>
    <p class="normal">Imagine a tree. Starting from the root, DFS dives down to the furthest leaf on a branch, marks all <a id="_idIndexMarker416"/>nodes along that branch as visited, then backtracks to explore other branches in a similar manner. The idea is to reach the furthest leaf node <a id="_idIndexMarker417"/>on a given branch before considering other branches. “Leaf” is a term used to refer to nodes in a tree that don’t have any child nodes or, in a graph context, any unvisited adjacent nodes.</p>
    <p class="normal">To ensure that the traversal doesn’t get stuck in a loop, especially in cyclic graphs, DFS employs a Boolean flag. This flag indicates whether a node has been visited, preventing the algorithm from revisiting nodes and getting trapped in infinite cycles.</p>
    <p class="normal">To implement DFS, we will use a stack data structure, which was discussed in detail in <em class="chapterRef">Chapter 2</em>, <em class="italic">Data Structures Used in Algorithms</em>. Remember that a stack is based on the <strong class="keyWord">Last In, First Out</strong> (<strong class="keyWord">LIFO</strong>) principle. This <a id="_idIndexMarker418"/>contrasts with a queue, as used <a id="_idIndexMarker419"/>for BFS, which works on the <strong class="keyWord">First In, First Out</strong> (<strong class="keyWord">FIFO</strong>) principle:</p>
    <p class="normal">The following code is used for DFS:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">graph, start, visited=</span><span class="hljs-literal">None</span>):
    <span class="hljs-keyword">if</span> visited <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        visited = <span class="hljs-built_in">set</span>()
    visited.add(start)
    <span class="hljs-built_in">print</span>(start)
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">next</span> <span class="hljs-keyword">in</span> graph[start] - visited:
        dfs(graph, <span class="hljs-built_in">next</span>, visited)
    <span class="hljs-keyword">return</span> visited
</code></pre>
    <p class="normal">Let’s again use the following code to test the <code class="inlineCode">dfs</code> function defined previously:</p>
    <pre class="programlisting code"><code class="hljs-code">graph={ <span class="hljs-string">'Amin'</span> : {<span class="hljs-string">'Wasim'</span>, <span class="hljs-string">'Nick'</span>, <span class="hljs-string">'Mike'</span>},
         <span class="hljs-string">'Wasim'</span> : {<span class="hljs-string">'Imran'</span>, <span class="hljs-string">'Amin'</span>},
         <span class="hljs-string">'Imran'</span> : {<span class="hljs-string">'Wasim'</span>,<span class="hljs-string">'Faras'</span>},
         <span class="hljs-string">'Faras'</span> : {<span class="hljs-string">'Imran'</span>},
         <span class="hljs-string">'Mike'</span>  :{<span class="hljs-string">'Amin'</span>},
         <span class="hljs-string">'Nick'</span>  :{<span class="hljs-string">'Amin'</span>}}
</code></pre>
    <p class="normal">If we run this algorithm, the output will look like the following:</p>
    <pre class="programlisting con"><code class="hljs-con">Amin
Wasim
Imran
Faras
Nick
Mike
</code></pre>
    <p class="normal">Let’s look <a id="_idIndexMarker420"/>at the exhaustive traversal pattern <a id="_idIndexMarker421"/>of this graph using the DFS methodology:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The iteration starts from the top node, Amin.</li>
      <li class="numberedList">Then, it moves to level two, Wasim. From there, it moves toward the lower levels until it reaches the end, which is the Imran and Fares nodes.</li>
      <li class="numberedList">After completing the first full branch, it backtracks and then goes to level two to visit Nick and Mike.</li>
    </ol>
    <p class="normal">The traversal pattern is shown in <em class="italic">Figure 5.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_07.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.7: A visual representation of DFS traversal</p>
    <p class="normal">Note that DFS can be used in trees as well.</p>
    <p class="normal">Let’s now <a id="_idIndexMarker422"/>look at a case study, which explains <a id="_idIndexMarker423"/>how the concepts we have discussed so far in this chapter can be used to solve a real-world problem.</p>
    <h1 id="_idParaDest-168" class="heading-1">Case study: fraud detection using SNA</h1>
    <h2 id="_idParaDest-169" class="heading-2">Introduction</h2>
    <p class="normal">Humans are inherently social, and their behavior often reflects the company they keep. In the realm <a id="_idIndexMarker424"/>of fraud analytics, a principle called “homophily” signifies <a id="_idIndexMarker425"/>the likelihood of individuals having associations based on shared attributes or behaviors. A homophilic network, for instance, might comprise people from the same hometown, university, or with shared hobbies. The underlying principle is that individuals’ behavior, including fraudulent activity, might be influenced by their immediate connections. This is also sometimes referred to as “guilt by association.”</p>
    <h2 id="_idParaDest-170" class="heading-2">What is fraud in this context?</h2>
    <p class="normal">In the context of this case study, fraud refers to deceptive activities that may include impersonation, credit card theft, fake check submission, or any other illicit activities that can be represented <a id="_idIndexMarker426"/>and analyzed in a network of relationships. In an effort to understand the process, let’s first look at a simple case. For that, let’s use a network with nine vertices and eight edges. In this network, four of the vertices are known <a id="_idIndexMarker427"/>fraud cases and are classified as <strong class="keyWord">fraud</strong> (<strong class="keyWord">F</strong>). Five of the remaining <a id="_idIndexMarker428"/>people have no fraud-related history and are classified as <strong class="keyWord">non-fraud</strong> (<strong class="keyWord">NF</strong>).</p>
    <p class="normal">We will write code with the following steps to generate this graph:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Let’s import the packages that we need:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
</code></pre>
      </li>
      <li class="numberedList">Define the data structures of <code class="inlineCode">vertices</code> and <code class="inlineCode">edges</code>:
        <pre class="programlisting code"><code class="hljs-code">vertices = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)
edges= [(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">7</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>), (<span class="hljs-number">7</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">7</span>,<span class="hljs-number">5</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">6</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>)]
</code></pre>
      </li>
      <li class="numberedList">Instantiate the graph:
        <pre class="programlisting code"><code class="hljs-code">graph = nx.Graph()
</code></pre>
      </li>
      <li class="numberedList">Now, draw the graph:
        <pre class="programlisting code"><code class="hljs-code">graph.add_nodes_from(vertices)
graph.add_edges_from(edges)
positions = nx.spring_layout(graph)
</code></pre>
      </li>
      <li class="numberedList">Let’s define the NF nodes:
        <pre class="programlisting code"><code class="hljs-code">nx.draw_networkx_nodes(graph, positions, 
                       nodelist=[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], 
                       with_labels=<span class="hljs-literal">True</span>, 
                       node_color=<span class="hljs-string">'g'</span>, 
                       node_size=<span class="hljs-number">1300</span>)
</code></pre>
      </li>
      <li class="numberedList">Now, let’s <a id="_idIndexMarker429"/>create the nodes that are known to be involved in fraud:
        <pre class="programlisting code"><code class="hljs-code">nx.draw_networkx_nodes(graph, positions, 
                       nodelist=[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], 
                       with_labels=<span class="hljs-literal">True</span>, 
                       node_color=<span class="hljs-string">'g'</span>, 
                       node_size=<span class="hljs-number">1300</span>)
</code></pre>
      </li>
      <li class="numberedList">Finally, create labels for the nodes:
        <pre class="programlisting code"><code class="hljs-code">labels = {<span class="hljs-number">1</span>: <span class="hljs-string">'1 NF'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'2 F'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'3 NF'</span>, <span class="hljs-number">4</span>: <span class="hljs-string">'4 NF'</span>, <span class="hljs-number">5</span>: <span class="hljs-string">'5 F'</span>, <span class="hljs-number">6</span>: <span class="hljs-string">'6 F'</span>, <span class="hljs-number">7</span>: <span class="hljs-string">'7 F'</span>, <span class="hljs-number">8</span>: <span class="hljs-string">'8 NF'</span>, <span class="hljs-number">9</span>: <span class="hljs-string">'9 NF'</span>}
nx.draw_networkx_labels(graph, positions, labels, font_size=<span class="hljs-number">16</span>)
nx.draw_networkx_edges(graph, positions, edges, width=<span class="hljs-number">3</span>, alpha=<span class="hljs-number">0.5</span>, edge_color=<span class="hljs-string">'b'</span>)
plt.show()
</code></pre>
      </li>
    </ol>
    <p class="normal">Once the preceding code runs, it will show us a graph like this:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_08.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.8: Initial network representation showing both fraudulent and non-fraudulent nodes</p>
    <p class="normal">Note that we <a id="_idIndexMarker430"/>have already conducted a detailed analysis to classify each node as a graph or non-graph. Let’s assume that we add another vertex, named <em class="italic">q</em>, to the network, as shown in the following figure. We have no prior information about this person and whether this person is involved in fraud or not. We want to classify this person as NF or F based on their links to the existing members of the social network:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_09.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.9: Introduction of a new node to the existing network</p>
    <p class="normal">We have <a id="_idIndexMarker431"/>devised two ways to classify this new person, represented by node <em class="italic">q</em>, as F or NF:</p>
    <ul>
      <li class="bulletList">Using a simple method that does not use centrality metrics and additional information about the type of fraud</li>
      <li class="bulletList">Using a watchtower methodology, which is an advanced technique that uses the centrality metrics of the existing nodes, as well as additional information about the type of fraud</li>
    </ul>
    <p class="normal">We will discuss each method in detail.</p>
    <h2 id="_idParaDest-171" class="heading-2">Conducting simple fraud analytics</h2>
    <p class="normal">The simple <a id="_idIndexMarker432"/>technique of fraud analytics is based on <a id="_idIndexMarker433"/>the assumption that in a network, the behavior of a person is affected by the people they are connected to. In a network, two vertices are more likely to have similar behavior if they are associated with each other.</p>
    <p class="normal">Based on this assumption, we will devise a simple technique. If we want to find the probability that a certain node, <em class="italic">a</em>, belongs to <em class="italic">F</em>, the probability is represented by <em class="italic">P(F/q)</em> and is calculated as follows:</p>
    <p class="center"><img src="../Images/B18046_05_032.png" alt="" role="presentation"/></p>
    <p class="normal">Let’s apply <a id="_idIndexMarker434"/>this to the preceding figure, where <em class="italic">Neighborhood</em><sub class="subscript-italic" style="font-style: italic;">n</sub> represents the neighborhood of vertex <em class="italic">n</em> and <em class="italic">w</em>(<em class="italic">n</em>, <em class="italic">n</em><sub class="subscript-italic" style="font-style: italic;">j</sub>) represents the weight of <a id="_idIndexMarker435"/>the connection between <em class="italic">n</em> and <em class="italic">n</em><sub class="subscript-italic" style="font-style: italic;">j</sub>. Also, <em class="italic">DOS</em><sub class="subscript-italic" style="font-style: italic;">normalized</sub> is the value of the <em class="italic">degree</em> of suspicion normalized between 0 and 1. Finally, <em class="italic">degree</em><sub class="subscript-italic" style="font-style: italic;">q</sub> is the degree of node <em class="italic">q</em>.</p>
    <p class="normal">The probability is calculated as follows:</p>
    <p class="center"><img src="../Images/B18046_05_033.png" alt="" role="presentation"/></p>
    <p class="normal">Based on this analysis, the likelihood of this person being involved in fraud is 67%. We need to set a threshold. If the threshold is 30%, then this person is above the threshold value, and we can safely flag them as <em class="italic">F</em>.</p>
    <p class="normal">Note that this process needs to be repeated for each of the new nodes in the network.</p>
    <p class="normal">Now, let’s look at an advanced way of conducting fraud analytics.</p>
    <h2 id="_idParaDest-172" class="heading-2">Presenting the watchtower fraud analytics methodology</h2>
    <p class="normal">The <a id="_idIndexMarker436"/>previous simple fraud analytics technique has the following two limitations:</p>
    <ul>
      <li class="bulletList">It does <a id="_idIndexMarker437"/>not evaluate the importance of each vertex in the social network. A connection to a hub that is involved in fraud may have different implications than a relationship with a remote, isolated person.</li>
      <li class="bulletList">When labeling someone as a known case of fraud in an existing network, we do not consider the severity of the crime.</li>
    </ul>
    <p class="normal">The <a id="_idIndexMarker438"/>watchtower fraud analytics methodology addresses these two limitations. First, let’s <a id="_idIndexMarker439"/>look at a couple of concepts.</p>
    <h3 id="_idParaDest-173" class="heading-3">Scoring negative outcomes</h3>
    <p class="normal">If a person is known to be involved in fraud, we say that there is a negative outcome associated <a id="_idIndexMarker440"/>with this individual. Not every negative outcome is of the same severity or seriousness. A person known <a id="_idIndexMarker441"/>to be impersonating another person will have a more serious type of negative outcome associated with them, compared to someone who is just trying to use an expired $20 gift card in a creative way to make it valid.</p>
    <p class="normal">From a score of 1 to 10, we will rate various negative outcomes as follows:</p>
    <table id="table001-4" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Negative outcome</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Negative outcome score</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Impersonation</p>
          </td>
          <td class="table-cell">
            <p class="normal">10</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Involvement in credit card theft</p>
          </td>
          <td class="table-cell">
            <p class="normal">8</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Fake check submission</p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Criminal record</p>
          </td>
          <td class="table-cell">
            <p class="normal">6</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">No record</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note that these scores will be based on our analysis of fraud cases and their impact from historical data.</p>
    <h3 id="_idParaDest-174" class="heading-3">Degree of suspicion</h3>
    <p class="normal">The <strong class="keyWord">degree of suspicion</strong> (<strong class="keyWord">DOS</strong>) quantifies <a id="_idIndexMarker442"/>our level <a id="_idIndexMarker443"/>of suspicion that a person may be involved in fraud. A DOS value of 0 means that this is a low-risk person, and a DOS value of 9 means that this is a high-risk person.</p>
    <p class="normal">Analysis of historical data shows that professional fraudsters have important positions in their social networks. To incorporate this, we first calculate all of the four centrality metrics of each vertex in our network. We then take the average of these vertices. This translates to the importance of that particular person in the network.</p>
    <p class="normal">If a person associated with a vertex is involved in fraud, we illustrate this negative outcome by scoring the person using the pre-determined values shown in the preceding table. This is done so that the severity of the crime is reflected in the value of each individual DOS.</p>
    <p class="normal">Finally, we multiply the average of the centrality metrics and the negative outcome score to <a id="_idIndexMarker444"/>get the value of the DOS. We normalize the DOS <a id="_idIndexMarker445"/>by dividing it by the maximum value of the DOS in the network.</p>
    <p class="normal">Let’s calculate the DOS for each of the nine nodes in the previous network:</p>
    <table id="table002-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell"/>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 1</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 2</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 3</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 4</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 5</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 6</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 7</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 8</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Node 9</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Degree of centrality</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0.25</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.5</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.25</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.25</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.25</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.13</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.63</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.13</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.13</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Betweenness</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0.25</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.47</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.71</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Closeness</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0.5</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.61</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.53</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.47</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.47</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.34</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.72</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.4</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.4</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Eigenvector</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0.24</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.45</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.36</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.32</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.32</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.08</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.59</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.16</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.16</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Average of centrality Metrics</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0.31</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.51</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.29</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.26</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.26</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.14</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.66</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.17</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.17</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Negative outcome score</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">6</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">8</p>
          </td>
          <td class="table-cell">
            <p class="normal">10</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">DOS</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1.82</p>
          </td>
          <td class="table-cell">
            <p class="normal">1.1</p>
          </td>
          <td class="table-cell">
            <p class="normal">6.625</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Normalized DOS</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.47</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.27</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.17</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Each <a id="_idIndexMarker446"/>of the nodes <a id="_idIndexMarker447"/>and their normalized DOS is shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B18046_05_10.png" alt="A screenshot of a game  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 5.10: Visualization of nodes with their calculated DOS values</p>
    <p class="normal">In order to calculate the DOS of the new node that has been added, we will use the following formula:</p>
    <p class="center"><img src="../Images/B18046_05_034.png" alt="" role="presentation"/></p>
    <p class="normal">Using the relevant values, we will calculate the DOS as follows:</p>
    <p class="center"><img src="../Images/B18046_05_035.png" alt="" role="presentation"/></p>
    <p class="normal">This will indicate the risk of fraud associated with this new node added to the system. It means <a id="_idIndexMarker448"/>that on a scale of 0 to 1, this person has a DOS value of <code class="inlineCode">0.42</code>. We <a id="_idIndexMarker449"/>can create different risk bins for the DOS, as follows:</p>
    <table id="table003-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Value of the DOS</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Risk classification</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">DOS = 0</p>
          </td>
          <td class="table-cell">
            <p class="normal">No risk</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">0&lt;DOS&lt;=0.10</p>
          </td>
          <td class="table-cell">
            <p class="normal">Low risk</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">0.10&lt;DOS&lt;=0.3</p>
          </td>
          <td class="table-cell">
            <p class="normal">Medium risk</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">DOS&gt;0.3</p>
          </td>
          <td class="table-cell">
            <p class="normal">High risk</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Based on these criteria, it can be seen that the new individual is a high-risk person and should be flagged.</p>
    <p class="normal">Usually, a time dimension is not involved when conducting such an analysis. But now, there are some advanced techniques that look at the growth of a graph as time progresses. This allows researchers to look at the relationship between vertices as the network evolves. Although such time-series analysis on graphs will increase the complexity of the problem many times over, it may give additional insight into the evidence of fraud that was not possible otherwise.</p>
    <h1 id="_idParaDest-175" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we learned about graph-based algorithms. This chapter used different techniques of representing, searching, and processing data represented as graphs. We also developed skills to be able to calculate the shortest distance between two vertices, and we built neighborhoods in our problem space. This knowledge should help us use graph theory to address problems such as fraud detection.</p>
    <p class="normal">In the next chapter, we will focus on different unsupervised machine learning algorithms. Many of the use-case techniques discussed in this chapter complement unsupervised learning algorithms, which will be discussed in detail in the next chapter. Finding evidence of fraud in a dataset is an example of such use cases.</p>
    <h1 id="_idParaDest-176" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>