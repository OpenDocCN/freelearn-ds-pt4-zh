<html><head></head><body>
  <div id="_idContainer154" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-178" class="chapterTitle">Unsupervised Machine Learning Algorithms</h1>
    <p class="normal">This chapter is about unsupervised machine learning algorithms. We aim, by the end of this chapter, to be able to understand how unsupervised learning, with its basic algorithms and methodologies, can be effectively applied to solve real-world problems.</p>
    <p class="normal">We will cover the following topics:</p>
    <ul>
      <li class="bulletList">Introducing unsupervised learning</li>
      <li class="bulletList">Understanding clustering algorithms</li>
      <li class="bulletList">Dimensionality reduction</li>
      <li class="bulletList">Association rules mining</li>
    </ul>
    <h1 id="_idParaDest-179" class="heading-1">Introducing unsupervised learning</h1>
    <p class="normal">If the data is not generated randomly, it tends to exhibit certain patterns or relationships among its <a id="_idIndexMarker450"/>elements within a multi-dimensional space. Unsupervised learning involves the process of detecting and utilizing these patterns within a dataset to structure and comprehend it more effectively. Unsupervised learning algorithms uncover these patterns and use them as a foundation for imparting a certain structure to the dataset. The identification of these patterns contributes to a deeper understanding and representation of the data. Extracting patterns from raw data leads to a better understanding of the raw data. </p>
    <p class="normal">This concept is shown in <em class="italic">Figure 6.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_01.png" alt="Shape, arrow  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.1: Using unsupervised machine learning to extract patterns from unlabeled raw data</p>
    <p class="normal">In the upcoming discussion, we will navigate through the CRISP-DM lifecycle, a popular model for the machine learning process. Within this context, we’ll pinpoint where unsupervised <a id="_idIndexMarker451"/>learning fits in. To illustrate, think of unsupervised learning like a detective piecing together clues to form patterns or groups, without having any predefined knowledge of what the end result might be. Just as a detective’s insights can be crucial in solving a case, unsupervised learning plays a pivotal role in the machine learning lifecycle.</p>
    <h2 id="_idParaDest-180" class="heading-2">Unsupervised learning in the data-mining lifecycle</h2>
    <p class="normal">Let us first look into the different phases of a typical machine learning process. To understand the <a id="_idIndexMarker452"/>different phases of the machine learning lifecycle, we will study the example of using machine learning for a data mining process. Data mining is the process of discovering meaningful correlations, patterns, and trends in a given dataset. To discuss the different phases of data mining using <a id="_idIndexMarker453"/>machine learning, this book utilizes the <strong class="keyWord">Cross-Industry Standard Process for Data Mining</strong> (<strong class="keyWord">CRISP-DM</strong>). CRISP-DM was conceived and brought to life by a group of data miners from different <a id="_idIndexMarker454"/>organizations, including notable names like Chrysler and IBM. More details can be found at <a href="https://www.ibm.com/docs/en/spss-modeler/saas?topic=dm-crisp-help-overview"><span class="url">https://www.ibm.com/docs/en/spss-modeler/saas?topic=dm-crisp-help-overview</span></a>.</p>
    <p class="normal">The CRISP-DM lifecycle consists of six distinct phases, which are shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.2: Different phases of the CRISP-DM lifecycle</p>
    <p class="normal">Let’s break <a id="_idIndexMarker455"/>down and explore each phase, one by one.</p>
    <h3 id="_idParaDest-181" class="heading-3">Phase 1: Business understanding </h3>
    <p class="normal">This phase is about gathering the requirements and involves trying to fully understand the problem <a id="_idIndexMarker456"/>in depth from a business point of view. Defining the scope of the problem and properly rephrasing it according to machine learning is an important part of this phase. This phase involves identifying the goals, defining the scope of the project, and understanding the requirements of the stakeholders. </p>
    <div class="note">
      <p class="normal">It is important to note that Phase 1 of the CRISP-DM lifecycle is about business understanding. It focuses on what needs to be done, not on how it will be done.</p>
    </div>
    <h3 id="_idParaDest-182" class="heading-3">Phase 2: Data understanding</h3>
    <p class="normal">This phase is about understanding the data that is available for data mining. In this phase, we will <a id="_idIndexMarker457"/>find out whether we have all information needed to solve the problem defined in Phase 1 in the given datasets. We can use tools like data visualization, dashboards, and summary reports to understand the patterns in the data. As explained later in this chapter, unsupervised machine learning algorithms can also be used to discover the patterns in the data and to understand them by analyzing their structure in detail.</p>
    <h3 id="_idParaDest-183" class="heading-3">Phase 3: Data preparation</h3>
    <p class="normal">This is about preparing the data for the ML model that we will later train in Phase 4. Depending <a id="_idIndexMarker458"/>on the use case and requirements, data preparation may include removing outliers, normalization, taking out null values, and reducing the dimensionality of the data. This is discussed in more detail in later chapters. After processing and preparing the data, it is usually split in a 70-30 ratio. The larger chunk, called the training data, is used to educate the model on various patterns, while the smaller chunk, referred to as the testing data, is saved for evaluating the model’s performance on unseen data during Phase 5. An optional set of data can also be kept aside for validating and fine-tuning the model to prevent it from overfitting.</p>
    <h3 id="_idParaDest-184" class="heading-3">Phase 4: Modeling</h3>
    <p class="normal">This is the phase where we formulate the patterns in the data by training the model. For model training, we will use the training data partition prepared in Phase 3. Model training <a id="_idIndexMarker459"/>involves feeding our prepared data into the machine learning algorithm. Through iterative learning, the algorithm identifies and learns the inherent patterns within the data. The objective is to formulate patterns representing the relationships and dependencies among different variables in the dataset. We will discuss in later chapters how the complexity and nature of these mathematical formulations depend heavily on our chosen algorithm – for instance, a linear regression model will generate a linear equation, while a decision tree model will construct a tree-like model of decisions.</p>
    <p class="normal">In addition to model training, model tuning is another component of this phase of the CRISP-DM lifecycle. This process includes optimizing the parameters of the learning algorithm to enhance its performance, thus making predictions more accurate. It involves fine-tuning the model using an optional validation set, which assists in adjusting the model’s complexity to find the right balance between learning from the data and generalizing to unseen data. A validation set, in machine learning terms, is a subset of your dataset that is used for the fine adjustment of a predictive model. </p>
    <p class="normal">It assists in modulating <a id="_idIndexMarker460"/>the model’s complexity, aiming to find an optimal balance between learning from known data and generalizing to unseen data. This balance is important in preventing overfitting, which is a scenario where the model learns the training data too well but performs poorly on new, unseen data. Hence, model tuning not only refines the model’s predictive power but also ensures its robustness and reliability.</p>
    <h3 id="_idParaDest-185" class="heading-3">Phase 5: Evaluation</h3>
    <p class="normal">This stage involves evaluating the recently trained model by using the test data derived from Phase 3. We measure the model’s performance against the established baseline, which is <a id="_idIndexMarker461"/>set during Phase 1. Setting a baseline in machine learning serves as a reference point, which can be determined using various methods. It could be established through basic rule-based systems, simple statistical models, random chance, or even based on the performance of human experts. The purpose of this baseline is to offer a minimal performance threshold that our machine learning models should surpass. The baseline acts as a benchmark for comparison, giving us a reference point for our expectations. If the model’s evaluation aligns with the expectations originally defined in Phase 1, we proceed further. If not, we must revisit and iterate through all the previous phases, starting again with Phase 1.</p>
    <h3 id="_idParaDest-186" class="heading-3">Phase 6: Deployment</h3>
    <p class="normal">Once the evaluation phase, Phase 5, concludes, we examine whether the performance of the trained model meets or surpasses the established expectations. It’s vital to remember <a id="_idIndexMarker462"/>that a successful evaluation doesn’t automatically imply readiness for deployment. The model has performed well on our test data, but that is not the only criterion for determining whether the model is ready to solve real-world problems, as defined in Phase 1. We must consider factors such as how the model will perform with new data it has never seen before, how it will integrate with existing systems, and how it will handle unforeseen edge cases. Therefore, it’s only when these extensive evaluations have been met satisfactorily that we can confidently proceed to deploy the model into a production environment, where it begins to provide a usable solution to our predefined problem.</p>
    <div class="note">
      <p class="normal">Phase 2 (Data understanding) and Phase 3 (Data preparation) of the CRISP-DM lifecycle are all about understanding the data and preparing it for training the model. These phases involve data processing. Some organizations employ specialists for this data engineering phase.</p>
    </div>
    <p class="normal">It is obvious that the process of suggesting a solution to a problem is fully data-driven. A combination <a id="_idIndexMarker463"/>of supervised and unsupervised machine learning is used to formulate a workable solution. This chapter focuses on the unsupervised learning part of the solution.</p>
    <div class="note">
      <p class="normal">Data engineering comprises Phase 2 and Phase 3 and is the most time-consuming part of machine learning. It can take as much as 70% of the time and resources <a id="_idIndexMarker464"/>of a typical <strong class="keyWord">Machine Learning</strong> (<strong class="keyWord">ML</strong>) project (<em class="italic">Data Management in Machine Learning: Challenges, Techniques, and Systems</em>, Cody et al, SIGMOD ‘17: Proceedings of the 2017 ACM International Conference on Management of Data, May 2017). Unsupervised learning algorithms can play an important role in data engineering.</p>
    </div>
    <p class="normal">The following sections provide more details regarding unsupervised algorithms.</p>
    <h2 id="_idParaDest-187" class="heading-2">Current research trends in unsupervised learning</h2>
    <p class="normal">The field of machine learning research has undergone a considerable transformation. In earlier times, the focus was primarily centered on supervised learning techniques. These methods are <a id="_idIndexMarker465"/>immediately useful for inference tasks, offering clear advantages such as time savings, cost reductions, and discernible improvements in prediction accuracy.</p>
    <p class="normal">Conversely, the intrinsic capabilities of unsupervised machine learning algorithms have only gained attention more recently. Unlike their supervised counterparts, unsupervised techniques function without direct instructions or preconceived assumptions. They are adept at exploring broader “dimensions” or facets in data, thus enabling a more comprehensive examination of a dataset.</p>
    <p class="normal">To clarify, in machine learning terminology, “features” are the individual measurable properties or characteristics of the phenomena being observed. For example, in a dataset concerning customer information, features could be aspects like the customer’s age, purchase history, or browsing behavior. “Labels,” on the other hand, represent the outcomes we want the model to predict based on these features.</p>
    <p class="normal">While supervised learning focuses primarily on establishing relationships between these features and a specific label, unsupervised learning does not restrict itself to a pre-determined label. Instead, it can delve deeper, unearthing intricate patterns among various features that might be overlooked when using supervised methods. This makes unsupervised learning potentially more expansive and versatile in its applications.</p>
    <p class="normal">This inherent flexibility of unsupervised learning, however, brings with it a challenge. Since the <a id="_idIndexMarker466"/>exploration space is larger, it can often result in <strong class="keyWord">increased computational</strong> requirements, leading to greater costs and longer processing times. Furthermore, managing the scale or “scope” of unsupervised learning tasks can be more complex due to their exploratory nature. Yet, the ability to unearth hidden patterns or correlations within the data makes unsupervised learning a powerful tool for data-driven insights.</p>
    <p class="normal">Today, research trends are moving toward the integration of supervised and unsupervised learning methods. This combined strategy aims to exploit the advantages of both methods.</p>
    <p class="normal">Now let us look into some practical examples.</p>
    <h2 id="_idParaDest-188" class="heading-2">Practical examples</h2>
    <p class="normal">Currently, unsupervised learning is used to get a better sense of the data and provide it with more <a id="_idIndexMarker467"/>structure—for example, it is used in marketing segmentation, data categorization, fraud detection, and market basket analysis (which is discussed later in this chapter). Let us look at the example of the use of unsupervised learning for marketing segmentation.</p>
    <h3 id="_idParaDest-189" class="heading-3">Marketing segmentation using unsupervised learning</h3>
    <p class="normal">Unsupervised learning serves as a powerful tool for marketing segmentation. Marketing segmentation <a id="_idIndexMarker468"/>refers to the process of dividing a target market into distinct groups based on shared characteristics, enabling companies to tailor their marketing strategies and messages to effectively reach and engage specific customer segments. The characteristics used for grouping the target market could include demographics, behaviors, or geographic similarities. By leveraging algorithms and statistical techniques, it enables businesses to extract meaningful insights from their customer data, identify hidden patterns, and group customers into <a id="_idIndexMarker469"/>distinct segments based on similarities in their behavior, preferences, or characteristics. This data-driven approach empowers marketers to develop tailored strategies, improve customer targeting, and enhance overall marketing effectiveness.</p>
    <h1 id="_idParaDest-190" class="heading-1">Understanding clustering algorithms</h1>
    <p class="normal">One of the simplest and most powerful techniques used in unsupervised learning is based on grouping similar patterns together through clustering algorithms. It is used to understand <a id="_idIndexMarker470"/>a particular aspect of the data that is related to the problem we are trying to solve. Clustering algorithms look for natural grouping in data items. As the group is not based on any target or assumptions, it is classified as an unsupervised learning technique.</p>
    <p class="normal">Consider a vast library full of books as an example. Each book represents a data point – containing a multitude of attributes like genre, author, publication year, and so forth. Now, imagine a librarian (the clustering algorithm) who is tasked with organizing these books. With no pre-existing categories or instructions, the librarian starts sorting the books based on their attributes – all the mysteries together, the classics together, books by the same author together, and so on. This is what we mean by “natural groups” in data items, where items that share similar characteristics are grouped together.</p>
    <p class="normal">Groupings created by various clustering algorithms are based on finding the similarities between various data points in the problem space. Note that, in the context of machine learning, a data point is a set of measurements or observations that exist in a multi-dimensional space. In simpler terms, it’s a single piece of information that helps the machine learn about the task it is trying to accomplish. The best way to determine the similarities between data points will vary from problem to problem and will depend on the nature of the problem we are dealing with. Let’s look at the various methods that can be used to calculate the similarities between various data points.</p>
    <h3 id="_idParaDest-191" class="heading-3">Quantifying similarities</h3>
    <p class="normal">Unsupervised <a id="_idIndexMarker471"/>learning techniques, such as clustering algorithms, work effectively by determining similarities between various data points within a given problem space. The effectiveness of these algorithms largely depends on our ability to correctly measure these similarities, and in machine learning terminology, these are often referred to as “distance measures.” But what exactly is a distance measure?</p>
    <p class="normal">In essence, a distance measure is a mathematical formula or method that calculates the “distance” or similarity between two data points. It’s crucial to understand that, in this context, the term “distance” doesn’t refer to physical distance, but rather to the similarity or dissimilarity between data points based on their features or characteristics.</p>
    <p class="normal">In clustering, we can talk about <a id="_idIndexMarker472"/>two main types of distances: intercluster <a id="_idIndexMarker473"/>and intracluster. The intercluster distance refers to the distance between different clusters, or groups of data points. In contrast, intracluster <a id="_idIndexMarker474"/>distance refers to the distance within the same cluster, or, in other words, the distance between data points within the same group. The objective of a good clustering algorithm is to maximize intercluster distance (making sure each cluster is distinct from the others) while minimizing intracluster distance (ensuring data points within the same cluster are as similar as possible). The following are three of the most popular methods that are used to quantify similarities:</p>
    <ul>
      <li class="bulletList">Euclidean distance measure</li>
      <li class="bulletList">Manhattan distance measure</li>
      <li class="bulletList">Cosine distance measure</li>
    </ul>
    <p class="normal">Let’s look at these distance measures in more detail.</p>
    <h3 id="_idParaDest-192" class="heading-3">Euclidean distance</h3>
    <p class="normal">The distance between different points can quantify the similarity between two data points and is <a id="_idIndexMarker475"/>extensively used in unsupervised machine learning techniques, such as clustering. Euclidean distance is the most common <a id="_idIndexMarker476"/>and simplest distance measure used. The term “distance,” in this context, quantifies how similar or different two data points are in a multi-dimensional space, which is crucial in understanding the grouping of data points. One of the simplest and most widely used measures of this distance is the Euclidean distance.</p>
    <p class="normal">The Euclidean distance can be thought of as the straight-line distance between two points in a three-dimensional space, similar to how we might measure distance in the real world. For example, consider two cities on a map; the Euclidean distance would be the “as-the-crow-flies” distance between these two cities, a straight line from city A to city B, ignoring any potential obstacles such as mountains or rivers.</p>
    <p class="normal">In a similar manner, in the multi-dimensional space of our data, the Euclidean distance calculates the shortest possible “straight line” distance between two data points. By doing so, it provides <a id="_idIndexMarker477"/>a quantitative measure of how close or far apart the <a id="_idIndexMarker478"/>data points are, based on their features or attributes. For example, let’s consider two points, <code class="inlineCode">A(1,1)</code> and <code class="inlineCode">B(4,4)</code>, in a two-dimensional space, as shown in the following plot:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_03.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.3: Calculating the Euclidean distance between two given points</p>
    <p class="normal">To calculate the distance between <code class="inlineCode">A</code> and <code class="inlineCode">B</code>—that is <code class="inlineCode">d(A,B)</code>, we can use the following Pythagorean formula:</p>
    <p class="center"><img src="../Images/B18046_06_001.png" alt="" role="presentation"/></p>
    <p class="normal">Note that this calculation is for a two-dimensional problem space. For an <em class="italic">n</em>-dimensional problem space, we can calculate the distance between two points, <strong class="keyWord">A</strong> and <strong class="keyWord">B</strong>, as follows:</p>
    <p class="center"><img src="../Images/B18046_06_002.png" alt="" role="presentation"/></p>
    <h3 id="_idParaDest-193" class="heading-3">Manhattan distance</h3>
    <p class="normal">In many situations, measuring the shortest distance between two points using the Euclidean distance measure will not truly represent the similarity or closeness between two points—for example, if two data points represent locations on a map, then the actual distance <a id="_idIndexMarker479"/>from point A to point B using ground transportation, such as a car or taxi, will be more than the distance calculated by the <a id="_idIndexMarker480"/>Euclidean distance. Let’s think of a bustling city grid, where you can’t cut straight through buildings to get from one point to another (like in the case of Euclidean distance), but rather, you must navigate through the grid of streets. Manhattan distance mirrors this real-world navigation – it calculates the total distance traveled along these grid lines from point A to point B.</p>
    <p class="normal">For situations such as these, we use Manhattan distance, which estimates the distance between two points, traveled when moving along grid-like city streets from a starting point to a destination. In contrast to straight-line distance measures like the Euclidean distance, the Manhattan distance provides a more accurate reflection of the practical distance between two locations in such contexts. The comparison between the Manhattan and Euclidean distance measures is shown in the following plot:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_04.png" alt="Chart, line chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.4: Calculating the Manhattan distance between two points</p>
    <p class="normal">Note that, in the figure, the Manhattan distance between these points is represented as a zigzag path that moves strictly along the grid lines of this plot. In contrast, the Euclidean distance is shown as a direct, straight line from point A to point B. It is obvious that the Manhattan distance will always be equal to or larger than the corresponding Euclidean distance calculated.</p>
    <h3 id="_idParaDest-194" class="heading-3">Cosine distance</h3>
    <p class="normal">While Euclidean and Manhattan distance measures serve us well in simpler, lower-dimensional <a id="_idIndexMarker481"/>spaces, their effectiveness diminishes as we venture into more complex, “high-dimensional” settings. A “high-dimensional” space refers to a dataset that contains a large number of features or variables. As the number of dimensions (features) increases, the calculation of distance becomes less meaningful and more <a id="_idIndexMarker482"/>computationally intensive with Euclidean and Manhattan distances.</p>
    <p class="normal">To tackle this issue, we use the “cosine distance” measure in high-dimensional contexts. This measure works by assessing the cosine of the angle formed by two data points connected to an origin point. It’s not the physical distance between the points that matters here, but the angle they create.</p>
    <p class="normal">If the data points are close in the multi-dimensional space, they’ll form a smaller angle, regardless of the number of dimensions involved. Conversely, if the data points are far apart, the resulting angle will be larger. Hence, cosine distance provides a more nuanced measure of similarity in high-dimensional data, helping us make better sense of complex data patterns:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_05.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.5: Calculating the cosine distance</p>
    <div class="note">
      <p class="normal">Textual data can almost be considered a highly dimensional space. It stems from the unique nature of text data, where each unique word can be considered a distinct dimension or feature. As the cosine distance measure works very well with h-dimensional spaces, it is a good choice when dealing with textual data.</p>
    </div>
    <p class="normal">Note that, in the preceding figure, the cosine of the angle between <code class="inlineCode">A(2,5)</code> and <code class="inlineCode">B(4.4)</code> is the cosine <a id="_idIndexMarker483"/>distance represented by <img src="../Images/B18046_06_003.png" alt="" role="presentation"/> in <em class="italic">Figure 6.5</em>. The reference between these points is the origin—that is, <code class="inlineCode">X(0,0)</code>. But in reality, any point <a id="_idIndexMarker484"/>in the problem space can act as the reference data point, and it does not have to be the origin.</p>
    <p class="normal">Let us now look into one of the most popular unsupervised machine learning techniques – that is, the k-means clustering algorithm.</p>
    <h2 id="_idParaDest-195" class="heading-2">k-means clustering algorithm</h2>
    <p class="normal">The k-means clustering algorithm gets its name from the procedure of creating “k” clusters and <a id="_idIndexMarker485"/>using means or averages to ascertain the “closeness” between data points. The term “means” refers to the method of calculating the centroid or the “center point” of each cluster, which is essentially the average of all the data points within the cluster. In other words, the algorithm calculates the mean value for each feature within the cluster, which results in a new data point – the centroid. This centroid then acts as the reference point for measuring the “closeness” of other data points.</p>
    <p class="normal">The popularity of k-means stems from its scalability and speed. The algorithm is computationally efficient because it uses a straightforward iterative process where the centroids of clusters are repeatedly adjusted until they become representative of the cluster members. This simplicity makes the algorithm particularly fast and scalable for large datasets.</p>
    <p class="normal">However, a notable limitation of the k-means algorithm is its inability to determine the optimal number of clusters, “k,” independently. The ideal “k” depends on the natural groupings within a given dataset. The design philosophy behind this constraint is to keep the algorithm straightforward and fast, hence assuming an external mechanism to calculate “k.” Depending on the context of the problem, “k” could be directly determined. For instance, if the task involves segregating a class of data science students into <a id="_idIndexMarker486"/>two clusters, one focusing on data science skills and the other on programming skills, “k” would naturally be two. However, for problems where the value of “k” is not readily apparent, an iterative process involving trial and error, or a heuristic-based method, might be required to estimate the most suitable number of clusters for a dataset.</p>
    <h3 id="_idParaDest-196" class="heading-3">The logic of k-means clustering</h3>
    <p class="normal">In this part, we’ll dive into the workings of the k-means clustering algorithm. We’ll break down how <a id="_idIndexMarker487"/>it operates, step by step, to give you a clear understanding of its mechanisms and uses. This section describes the logic of the k-means clustering algorithm.</p>
    <h3 id="_idParaDest-197" class="heading-3">Initialization</h3>
    <p class="normal">In order to group them, the k-means algorithm uses a distance measure to find the similarity or <a id="_idIndexMarker488"/>closeness between data points. Before using the k-means algorithm, the most appropriate distance measure needs to be selected. By default, the Euclidean distance measure will be used. However, depending on the nature and requirement of your data, you might find another distance measure, such as Manhattan or cosine, more suitable. Also, if the dataset has outliers, then a mechanism needs to be devised to determine the criteria that are to be identified and remove the outliers of the dataset. </p>
    <p class="normal">Various statistical methods are available for <a id="_idIndexMarker489"/>outlier detection, such as the Z-score method or the <strong class="keyWord">Interquartile Range</strong> (<strong class="keyWord">IQR</strong>) method. Now let’s look at the different steps involved in the k-means algorithm.</p>
    <h3 id="_idParaDest-198" class="heading-3">The steps of the k-means algorithm</h3>
    <p class="normal">The steps <a id="_idIndexMarker490"/>involved in the k-means clustering algorithm are as follows:</p>
    <table id="table001-5" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step 1</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">We choose the number of clusters, <em class="italic">k</em>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step 2</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">Among the data points, we randomly choose <em class="italic">k </em>points as cluster centers.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step 3</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">Based on the selected distance measure, we iteratively compute the distance from each point in the problem space to each of the <em class="italic">k </em>cluster centers. Based on the size of the dataset, this may be a time-consuming step—for example, if there are 10,000 points in the cluster and <em class="italic">k = 3</em>, this means that 30,000 distances need to be calculated.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step 4</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">We assign each data point in the problem space to the nearest cluster center.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step 5</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">Now each data point in our problem space has an assigned cluster center. But we are not done, as the selection of the initial cluster centers was based on random selection. We need to verify that the current randomly selected cluster centers are actually the center of gravity of each cluster. We recalculate the cluster centers by computing the mean of the constituent data points of each of the <em class="italic">k </em>clusters. This step explains why this algorithm is called <em class="italic">k</em>-means.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Step 6</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">If the cluster centers have shifted in step 5, this means that we need to recompute the cluster assignment for each data point. For this, we will go back to step 3 to repeat that compute-intensive step. If the cluster centers have not shifted or if our predetermined stop condition (for example, the number of maximum iterations) has been satisfied, then we are done. </p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">The following <a id="_idIndexMarker491"/>figure shows the result of running the k-means algorithm in a two-dimensional problem space:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_06.png" alt="Chart, scatter chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.6: Results of k-means clustering (a) Data points before clustering; (b) resultant clusters after running the k-means clustering algorithm</p>
    <p class="normal">Note that <a id="_idIndexMarker492"/>the two resulting clusters created after running k-means are well differentiated in this case. Now let us look into the stop condition of the k-means algorithm.</p>
    <h3 id="_idParaDest-199" class="heading-3">Stop condition</h3>
    <p class="normal">In unsupervised learning algorithms like k-means, the stop condition plays a crucial role in determining <a id="_idIndexMarker493"/>when the algorithm should cease its iterative process. For the k-means algorithm, the default stop condition is when there is no more shifting of cluster centers in step 5. But as with many other algorithms, k-means algorithms may take a lot of time to converge, especially while processing large datasets in a high-dimensional problem space. </p>
    <p class="normal">Instead of waiting for the algorithm to converge, we can also explicitly define the stop condition as follows:</p>
    <ul>
      <li class="bulletList">By specifying the maximum execution time:<ul>
          <li class="bulletList"><strong class="keyWord">Stop condition</strong>: <em class="italic">t</em>&gt;<em class="italic">t</em><sub class="subscript-italic" style="font-style: italic;">max</sub>, where <em class="italic">t</em> is the current execution time and <em class="italic">t</em><sub class="subscript-italic" style="font-style: italic;">max</sub> is the maximum execution time we have set for the algorithm.</li>
        </ul>
      </li>
      <li class="bulletList">By specifying the maximum iterations:<ul>
          <li class="bulletList"><strong class="keyWord">Stop condition</strong>: if <em class="italic">m</em>&gt;<em class="italic">m</em><sub class="subscript-italic" style="font-style: italic;">max</sub>, where <em class="italic">m</em> is the current iteration and <em class="italic">m</em><sub class="subscript-italic" style="font-style: italic;">max</sub> is the maximum number of iterations we have set for the algorithm.</li>
        </ul>
      </li>
    </ul>
    <h3 id="_idParaDest-200" class="heading-3">Coding the k-means algorithm</h3>
    <p class="normal">We’ll perform k-means clustering on a simple two-dimensional dataset you’ve provided, with two features, <code class="inlineCode">x</code> and <code class="inlineCode">y</code>. Imagine a swarm of fireflies scattered across a garden at night. Your task <a id="_idIndexMarker494"/>is to group these fireflies based on their proximity to each other. This is the essence of k-means clustering, a popular unsupervised learning algorithm.</p>
    <p class="normal">We’re given a dataset, much like our garden, with data points plotted in a two-dimensional space. Our data points are represented by <code class="inlineCode">x</code> and <code class="inlineCode">y</code> coordinates:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
dataset = pd.DataFrame({
    <span class="hljs-string">'x'</span>: [<span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">33</span>, <span class="hljs-number">24</span>, <span class="hljs-number">45</span>, <span class="hljs-number">45</span>, <span class="hljs-number">52</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">55</span>, <span class="hljs-number">53</span>, <span class="hljs-number">55</span>, <span class="hljs-number">61</span>, <span class="hljs-number">62</span>, <span class="hljs-number">70</span>, <span class="hljs-number">72</span>, <span class="hljs-number">10</span>],
    <span class="hljs-string">'y'</span>: [<span class="hljs-number">39</span>, <span class="hljs-number">36</span>, <span class="hljs-number">30</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">46</span>, <span class="hljs-number">55</span>, <span class="hljs-number">59</span>, <span class="hljs-number">63</span>, <span class="hljs-number">70</span>, <span class="hljs-number">66</span>, <span class="hljs-number">63</span>, <span class="hljs-number">58</span>, <span class="hljs-number">23</span>, <span class="hljs-number">14</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>, <span class="hljs-number">7</span>, <span class="hljs-number">24</span>, <span class="hljs-number">10</span>]
})
</code></pre>
    <p class="normal">Our task is to cluster these data points using the k-means algorithm.</p>
    <p class="normal">Firstly, we import the required libraries:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> cluster
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
</code></pre>
    <p class="normal">Next, we’ll initiate the <code class="inlineCode">KMeans</code> class by specifying the number of clusters (<code class="inlineCode">k</code>). For this example, let’s assume we want to divide our data into 3 clusters:</p>
    <pre class="programlisting code"><code class="hljs-code">kmeans = cluster.KMeans(n_clusters=<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">Now, we train our <code class="inlineCode">KMeans</code> model with our dataset. It is worth mentioning that this model only needs the feature matrix (<code class="inlineCode">x</code>) and not the target vector (<code class="inlineCode">y</code>) because it’s an unsupervised learning algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">kmeans.fit(dataset)
</code></pre>
    <p class="normal">Let us now look into the labels and the cluster centers:</p>
    <pre class="programlisting code"><code class="hljs-code">labels = labels = kmeans.labels_
centers = kmeans.cluster_centers_
<span class="hljs-built_in">print</span>(labels)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0]
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(centers)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[[16.77777778 48.88888889]
 [57.09090909 15.09090909]]
</code></pre>
    <p class="normal">Finally, to visualize our clusters, we plot our data points, coloring them according to their assigned cluster. The centers of clusters, also known as centroids, are also plotted:</p>
    <pre class="programlisting code"><code class="hljs-code">plt.scatter(dataset[<span class="hljs-string">'</span><span class="hljs-string">x'</span>], dataset[<span class="hljs-string">'y'</span>], c=labels)
plt.scatter(kmeans.cluster_centers_[:, <span class="hljs-number">0</span>], kmeans.cluster_centers_[:, <span class="hljs-number">1</span>], s=<span class="hljs-number">300</span>, c=<span class="hljs-string">'red'</span>)
plt.show()
</code></pre>
    <p class="normal">In the plot, the colored points represent our data points and their respective clusters, while the <a id="_idIndexMarker495"/>red points denote the centroids of each cluster.</p>
    <figure class="mediaobject"> <img src="../Images/B18046_06_07.png" alt="A graph with many colored dots  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.7: Results of k-means clustering</p>
    <p class="normal">Note that the bigger dots in the plot are the centroids as determined by the k-means algorithm.</p>
    <h3 id="_idParaDest-201" class="heading-3">Limitation of k-means clustering</h3>
    <p class="normal">The k-means <a id="_idIndexMarker496"/>algorithm is designed to be a simple and fast algorithm. Because of the intentional simplicity of its design, it comes with the following limitations:</p>
    <ul>
      <li class="bulletList">The biggest limitation of k-means clustering is that the initial number of clusters has to be predetermined.</li>
      <li class="bulletList">The initial assignment of cluster centers is random. This means that each time the algorithm is run, it may give slightly different clusters.</li>
      <li class="bulletList">Each data point is assigned to only one cluster.</li>
      <li class="bulletList">k-means <a id="_idIndexMarker497"/>clustering is sensitive to outliers.</li>
    </ul>
    <p class="normal">Now let us look into another unsupervised machine learning technique, hierarchical clustering.</p>
    <h3 id="_idParaDest-202" class="heading-3">Hierarchical clustering</h3>
    <p class="normal">K-means clustering uses a top-down approach because we start the algorithm from the most important data points, which are the cluster centers. There is an alternative approach of <a id="_idIndexMarker498"/>clustering where, instead of starting from the top, we start the algorithm from the bottom. The bottom, in this context, is each of the individual data points in the problem space. The solution is to keep on grouping similar data points together as it progresses up toward the cluster centers. This alternative bottom-up approach is used by hierarchical clustering algorithms and is discussed in this section.</p>
    <h1 id="_idParaDest-203" class="heading-1">Steps of hierarchical clustering</h1>
    <p class="normal">The following steps are involved in hierarchical clustering:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We create <a id="_idIndexMarker499"/>a separate cluster for each data point in our problem space. If our problem space consists of 100 data points, then it will start with 100 clusters.</li>
      <li class="numberedList">We group only those points that are closest to each other.</li>
      <li class="numberedList">We check for the stop condition; if the stop condition is not yet satisfied, then we repeat step 2.</li>
    </ol>
    <p class="normal">The resulting clustered <a id="_idIndexMarker500"/>structure is called a <strong class="keyWord">dendrogram</strong>.</p>
    <p class="normal">In a dendrogram, the height of the vertical lines determines how close the items are, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_08.png" alt="Diagram  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 6.8: Hierarchical clustering</p>
    <p class="normal">Note that <a id="_idIndexMarker501"/>the stop condition is shown as a dotted line in <em class="italic">Figure 6.8</em>.</p>
    <h1 id="_idParaDest-204" class="heading-1">Coding a hierarchical clustering algorithm</h1>
    <p class="normal">Let’s learn <a id="_idIndexMarker502"/>how we can code a hierarchical algorithm in Python:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We will first import <code class="inlineCode">AgglomerativeClustering</code> from the <code class="inlineCode">sklearn.cluster</code> library, along with the <code class="inlineCode">pandas</code> and <code class="inlineCode">numpy</code> packages:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> AgglomerativeClustering
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
</code></pre>
      </li>
      <li class="numberedList">Then we will create 20 data points in a two-dimensional problem space:
        <pre class="programlisting code"><code class="hljs-code">dataset = pd.DataFrame({
    <span class="hljs-string">'x'</span>: [<span class="hljs-number">11</span>,<span class="hljs-number"> 11</span>,<span class="hljs-number"> 20</span>,<span class="hljs-number"> 12</span>,<span class="hljs-number"> 16</span>,<span class="hljs-number"> 33</span>,<span class="hljs-number"> 24</span>,<span class="hljs-number"> 14</span>,<span class="hljs-number"> 45</span>,<span class="hljs-number"> 52</span>,<span class="hljs-number"> 51</span>,<span class="hljs-number"> 52</span>,<span class="hljs-number"> 55</span>,<span class="hljs-number"> 53</span>,<span class="hljs-number"> 55</span>,<span class="hljs-number"> 61</span>,<span class="hljs-number"> 62</span>,<span class="hljs-number"> 70</span>,<span class="hljs-number"> 72</span>,<span class="hljs-number"> 10</span>],
    <span class="hljs-string">'y'</span>: [<span class="hljs-number">39</span>,<span class="hljs-number"> 36</span>,<span class="hljs-number"> 30</span>,<span class="hljs-number"> 52</span>,<span class="hljs-number"> 53</span>,<span class="hljs-number"> 46</span>,<span class="hljs-number"> 55</span>,<span class="hljs-number"> 59</span>,<span class="hljs-number"> 12</span>,<span class="hljs-number"> 15</span>,<span class="hljs-number"> 16</span>,<span class="hljs-number"> 18</span>,<span class="hljs-number"> 11</span>,<span class="hljs-number"> 23</span>,<span class="hljs-number"> 14</span>,<span class="hljs-number"> 8</span>,<span class="hljs-number"> 18</span>,<span class="hljs-number"> 7</span>,<span class="hljs-number"> 24</span>,<span class="hljs-number"> 70</span>]
})
</code></pre>
      </li>
      <li class="numberedList">Then we create the hierarchical cluster by specifying the hyperparameters. Note that a hyperparameter refers to a configuration parameter of a machine learning model that is set before the training process and influences the model’s behavior and performance. We use the <code class="inlineCode">fit_predict</code> function to actually process the algorithm:
        <pre class="programlisting code"><code class="hljs-code">cluster = AgglomerativeClustering(n_clusters=<span class="hljs-number">2</span>, affinity=<span class="hljs-string">'euclidean'</span>, linkage=<span class="hljs-string">'ward'</span>)
cluster.fit_predict(dataset)
</code></pre>
      </li>
      <li class="numberedList">Now let’s look at the association of each data point to the two clusters that were created:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(cluster.labels_)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">[0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0]
</code></pre>
      </li>
    </ol>
    <p class="normal">You can see that the cluster assignment for both hierarchical and <em class="italic">k</em>-means algorithms are very similar.</p>
    <p class="normal">The hierarchical clustering algorithm has its distinct advantages and drawbacks when compared <a id="_idIndexMarker503"/>to the <em class="italic">k</em>-means clustering algorithm. One key advantage is that hierarchical clustering doesn’t require the number of clusters to be specified beforehand, unlike <em class="italic">k</em>-means. </p>
    <p class="normal">This feature can be incredibly useful when the data doesn’t clearly suggest an optimal number of clusters. Hierarchical clustering also provides a dendrogram, a tree-like diagram that can be very insightful for visualizing the nested grouping of data and understanding the hierarchical structure.</p>
    <p class="normal">However, hierarchical clustering has its drawbacks. It is computationally more intensive than <em class="italic">k</em>-means, making it less suitable for large datasets.</p>
    <h1 id="_idParaDest-205" class="heading-1">Understanding DBSCAN</h1>
    <p class="normal"><strong class="keyWord">Density-based spatial clustering of applications with noise</strong> (<strong class="keyWord">DBSCAN</strong>) is an unsupervised <a id="_idIndexMarker504"/>learning technique that performs clustering based on the density of the points. The basic idea is based on the assumption that if we group the data points in a crowded or high-density space together, we can achieve meaningful clustering.</p>
    <p class="normal">This approach to clustering has two important implications:</p>
    <ul>
      <li class="bulletList">Using this idea, the algorithm is likely to cluster together the points that exist together regardless of their shape or pattern. This methodology helps in creating clusters of arbitrary shapes. By “shape,” we refer to the pattern or distribution of data points in a multi-dimensional space. This capability is advantageous because real-world data is often complex and non-linear, and the ability to create clusters of arbitrary shapes enables more accurate representation and understanding of such data.</li>
      <li class="bulletList">Unlike the k-means algorithm, we do not need to specify the number of clusters and the algorithm can detect the appropriate number of groupings in the data.</li>
    </ul>
    <p class="normal">The following <a id="_idIndexMarker505"/>steps involve the DBSCAN algorithm:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The algorithm establishes a neighborhood around each data point. The term “neighborhood,” in this context, refers to an area wherein other data points are examined for proximity to the point of interest. This is accomplished by counting the number of data points within a distance usually represented by a variable, <em class="italic">eps</em>. The <em class="italic">eps</em> variable, in this setting, specifies the maximum distance between two data points for them to be considered as being in the same neighborhood. The distance is by default determined by the Euclidean distance measure. </li>
      <li class="numberedList">Next, the algorithm quantifies the density of each data point. It uses a variable named <code class="inlineCode">min_samples</code>, which represents the minimum number of other data points that should be in the <em class="italic">eps</em> distance for a data point to be regarded as a “core instance.” In simpler terms, a core instance is a data point that is densely surrounded by other data points. Logically, regions with a high density of data points will have a greater number of these core instances.</li>
      <li class="numberedList">Each of the identified neighborhoods identifies a cluster. It is crucial to note that the neighborhood surrounding one core instance (a data point that has a minimum number of other data points within its “eps” distance) may encompass additional core instances. This means that core instances are not exclusive to a single cluster but can contribute to the formation of multiple clusters due to their proximity to several data points. Consequently, the borders of these clusters may overlap, leading to a complex, interconnected cluster structure.</li>
      <li class="numberedList">Any data point that is not a core instance or does not lie in the neighborhood of a core instance is considered an outlier.</li>
    </ol>
    <p class="normal">Let us see how we can create clusters using DBSCAN in Python.</p>
    <h1 id="_idParaDest-206" class="heading-1">Creating clusters using DBSCAN in Python</h1>
    <p class="normal">First, we will import the necessary functions from the <code class="inlineCode">sklearn</code> library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_moons
</code></pre>
    <p class="normal">Let’s employ <code class="inlineCode">DBSCAN</code> to tackle a slightly more complex clustering problem, one that involves structures known as “half-moons.” In this context, “half-moons” refer to two sets of <a id="_idIndexMarker506"/>data points that are shaped like crescents, with each moon representing a unique cluster. Such datasets pose a challenge because the clusters are not linearly separable, meaning a straight line cannot easily divide the different groups.</p>
    <p class="normal">This <a id="_idIndexMarker507"/>is where the concept of “nonlinear class boundaries” comes into play. In contrast to linear class boundaries, which can be represented by a straight line, nonlinear class boundaries are more complex, often necessitating curved lines or multidimensional surfaces to accurately segregate different classes or clusters.</p>
    <p class="normal">To generate this half-moon dataset, we can leverage the <code class="inlineCode">make_moons()</code> function. This function creates a swirl pattern resembling two moons. The “noisiness” of the moon shapes and the number of samples to generate can be adjusted according to our needs. </p>
    <p class="normal">Here’s what the generated dataset looks like:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_09.png" alt="Chart, scatter chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.9: Data used for DBSCAN</p>
    <p class="normal">In order <a id="_idIndexMarker508"/>to use DBSCAN, we need to provide <a id="_idIndexMarker509"/>the <code class="inlineCode">eps</code> and <code class="inlineCode">min_samples</code> parameters as discussed:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> DataFrame
<span class="hljs-comment"># generate 2d classification dataset</span>
X, y = make_moons (n_samples=<span class="hljs-number">1000</span>, noise=<span class="hljs-number">0.05</span>)
<span class="hljs-comment"># scatter plot, dots colored by class value</span>
df = DataFrame (dict (x=X[,<span class="hljs-number">0</span>], y=X[,<span class="hljs-number">1</span>], label=y))
colors = {<span class="hljs-number">0</span>: <span class="hljs-string">'red'</span>, <span class="hljs-number">1</span>:<span class="hljs-string">'blue'</span>}
fig, ax = pyplot.subplots()
grouped = df.groupby(<span class="hljs-string">'label'</span>)
<span class="hljs-keyword">for</span> key, group <span class="hljs-keyword">in</span> grouped:
    group.plot(ax=ax, kind=<span class="hljs-string">'scatter'</span>, x=<span class="hljs-string">'x'</span>, y=<span class="hljs-string">'y'</span>, label=key, color-colors[key])
pyplot.show()
</code></pre>
    <h1 id="_idParaDest-207" class="heading-1">Evaluating the clusters</h1>
    <p class="normal">The objective of good quality clustering is that the data points that belong to the separate <a id="_idIndexMarker510"/>clusters should be differentiable. This implies the following:</p>
    <ul>
      <li class="bulletList">The data points that belong to the same cluster should be as similar as possible.</li>
      <li class="bulletList">Data points that belong to separate clusters should be as different as possible.</li>
    </ul>
    <p class="normal">Human intuition can be used to evaluate the clustering results by visualizing the clusters, but there are mathematical methods that can quantify the quality of the clusters. They not only measure the tightness of each cluster (cohesion) and the separation between different clusters but also offer a numerical, hence objective, way to assess the quality of clustering. Silhouette analysis is one such technique that compares the tightness and separation in the clusters created by the k-means algorithm. It’s a metric that quantifies the degree of cohesion and separation in clusters. While this technique has been mentioned in the context of k-means, it is in fact generalizable and can be applied <a id="_idIndexMarker511"/>to evaluate the results of any clustering algorithm, not just k-means.</p>
    <p class="normal">Silhouette analysis assigns a score, known as the Silhouette coefficient, to each data point in the range of 0 to 1. It essentially measures how close each data point in one cluster is to the points in the neighboring clusters. </p>
    <h3 id="_idParaDest-208" class="heading-3">Application of clustering</h3>
    <p class="normal">Clustering is <a id="_idIndexMarker512"/>used wherever we need to discover the underlying patterns in datasets.</p>
    <p class="normal">In government use cases, clustering can be used for the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Crime-hotspot analysis</strong>: Clustering is applied to geolocation data, incident reports, and <a id="_idIndexMarker513"/>other related features. It aids in identifying <a id="_idIndexMarker514"/>areas with high incidences of crime, enabling law enforcement agencies to optimize patrol routes and deploy resources more effectively.</li>
      <li class="bulletList"><strong class="keyWord">Demographic social analysis</strong>: Clustering can analyze demographic data such as <a id="_idIndexMarker515"/>age, income, education, and occupation. This aids in understanding the socioeconomic <a id="_idIndexMarker516"/>composition of different regions, informing public policy and social service provision.</li>
    </ul>
    <p class="normal">In market research, clustering can be used for the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Market segmentation</strong>: By clustering consumer data including spending habits, product <a id="_idIndexMarker517"/>preferences, and lifestyle indicators, businesses <a id="_idIndexMarker518"/>can identify distinct market segments. This allows for tailored product development and marketing approaches.</li>
      <li class="bulletList"><strong class="keyWord">Targeted advertisements</strong>: Clustering <a id="_idIndexMarker519"/>helps analyze customer online behavior, including <a id="_idIndexMarker520"/>browsing patterns, click-through rates, and purchase history. This enables companies to create personalized advertisements for each customer cluster, enhancing engagement and conversion rates.</li>
      <li class="bulletList"><strong class="keyWord">Customer categorization</strong>: Through clustering, businesses can categorize customers <a id="_idIndexMarker521"/>based on their interaction with products or services, their feedback, and their loyalty. This aids in understanding customer behavior, predicting trends, and developing retention strategies.</li>
    </ul>
    <p class="normal"><strong class="keyWord">Principal component analysis</strong> (<strong class="keyWord">PCA</strong>) is also used for generally exploring the data and removing <a id="_idIndexMarker522"/>noise from real-time data, such as stock-market trading. In this context, “noise” refers to random or irregular fluctuations that may obscure underlying patterns or trends in the data. PCA helps in filtering out these erratic fluctuations, allowing for clearer data analysis and interpretation.</p>
    <h1 id="_idParaDest-209" class="heading-1">Dimensionality reduction</h1>
    <p class="normal">Each feature in our data corresponds to a dimension in our problem space. Minimizing the number <a id="_idIndexMarker523"/>of features to make our problem space simpler is called <strong class="keyWord">dimensionality reduction</strong>. It can be done in one of the following two ways:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Feature selection</strong>: Selecting <a id="_idIndexMarker524"/>a set of features that are important in the context of the problem we are trying to solve</li>
      <li class="bulletList"><strong class="keyWord">Feature aggregation</strong>: Combining two or more features to reduce dimensions <a id="_idIndexMarker525"/>using one of the following algorithms:<ul>
          <li class="bulletList"><strong class="keyWord">PCA</strong>: A linear <a id="_idIndexMarker526"/>unsupervised ML algorithm</li>
          <li class="bulletList"><strong class="keyWord">Linear discriminant analysis</strong> (<strong class="keyWord">LDA</strong>): A linear <a id="_idIndexMarker527"/>supervised ML algorithm</li>
          <li class="bulletList"><strong class="keyWord">KPCA</strong>: A nonlinear algorithm</li>
        </ul>
      </li>
    </ul>
    <p class="normal">Let’s look deeper at one of the popular dimensionality reduction algorithms, namely PCA, in more detail.</p>
    <h2 id="_idParaDest-210" class="heading-2">Principal component analysis</h2>
    <p class="normal">PCA is a method in unsupervised machine learning that is typically employed to reduce the dimensionality <a id="_idIndexMarker528"/>of datasets through a process known as linear transformation. In simpler terms, it’s a way of simplifying data by focusing on its most important parts, which are identified based on their variance.</p>
    <p class="normal">Consider a graphical representation of a dataset, where each data point is plotted on a multi-dimensional space. PCA helps identify the principal components, which are the directions where the data varies the most. In <em class="italic">Figure 6.10</em>, we see two of these, PC1 and PC2. These principal components illustrate the overall “shape” of the distribution of data points.</p>
    <p class="normal">Each principal component corresponds to a new, lesser dimension that captures as much information as possible. In a practical sense, these principal components can be viewed as summary indicators of the original data, making the data more manageable and easier to analyze. For instance, in a large dataset concerning customer behavior, PCA can help us identify the key driving factors (principal components) that define the majority of customer behaviors.</p>
    <p class="normal">Determining the coefficients for these principal components involves calculating the eigenvectors and eigenvalues of the data covariance matrix, which is a topic we’ll delve into more deeply in a later section. These coefficients serve as weights for each original feature in the new component space, defining how each feature contributes to the principal component.</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_10.png" alt="Chart, pie chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.10: Principle component analysis</p>
    <p class="normal">To elaborate further, imagine you have a dataset containing various aspects of a country’s economy, such as GDP, employment rates, inflation, and more. The data is vast and multi-dimensional. Here, PCA would allow you to reduce these multiple dimensions into two principal components, PC1 and PC2. These components would encapsulate the most crucial information while discarding noise or less important details. </p>
    <p class="normal">The resulting graph, with PC1 and PC2 as axes, would give you an easier-to-interpret visual <a id="_idIndexMarker529"/>representation of the economic data, with each point representing an economy’s status based on its combination of GDP, employment rates, and other factors. </p>
    <p class="normal">This makes PCA an invaluable tool for simplifying and interpreting high-dimensional data.</p>
    <p class="normal">Let’s consider the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
url = <span class="hljs-string">"https://storage.googleapis.com/neurals/data/iris.csv"</span>
iris = pd.read_csv(url)
iris
X = iris.drop(<span class="hljs-string">'Species'</span>, axis=<span class="hljs-number">1</span>)
pca = PCA(n_components=<span class="hljs-number">4</span>)
pca.fit(X)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">   Sepal.Length   Sepal.Width    Petal.Length    Petal.Width    Species
0    5.1    3.5    1.4    0.2    setosa
1    4.9    3.0    1.4    0.2    setosa
2    4.7    3.2    1.3    0.2    setosa
3    4.6    3.1    1.5    0.2    setosa
4    5.0    3.6    1.4    0.2    setosa
...    ...    ...    ...    ...    ...
145    6.7    3.0    5.2    2.3    virginica
146    6.3    2.5    5.0    1.9    virginica
147    6.5    3.0    5.2    2.0    virginica
148    6.2    3.4    5.4    2.3    virginica
149    5.9    3.0    5.1    1.8    virginica
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">X = iris.drop(<span class="hljs-string">'Species'</span>, axis=<span class="hljs-number">1</span>)
pca = PCA(n_components=<span class="hljs-number">4</span>)
pca.fit(X)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">PCA(n_components=4)
</code></pre>
    <p class="normal">Now let’s print the coefficients of our PCA model:</p>
    <pre class="programlisting code"><code class="hljs-code">pca_df=(pd.DataFrame(pca.components_,columns=X.columns))
pca_df
</code></pre>
    <figure class="mediaobject"><img src="../Images/B18046_06_11.png" alt="Table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.11: Diagram highlighting coefficients of the PCA model</p>
    <p class="normal">Note that the original DataFrame has four features: <code class="inlineCode">Sepal.Length</code>, <code class="inlineCode">Sepal.Width</code>, <code class="inlineCode">Petal.Length</code>, and <code class="inlineCode">Petal.Width</code>. The preceding DataFrame specifies the coefficients of the four principal components, PC1, PC2, PC3, and PC4—for example, the first row specifies the coefficients of PC1 that can be used to replace the original four variables.</p>
    <p class="normal">It is important to note here that the number of principal components (in this case, four: PC1, PC2, PC3, and PC4) does not necessarily need to be two as in our previous economy example. The number of principal components is a choice we make based on the level of complexity we are willing to handle in our data. The more principal components we choose, the more of the original data’s variance we can retain, at the cost of increased complexity.</p>
    <p class="normal">Based on <a id="_idIndexMarker530"/>these coefficients, we can calculate the PCA components for our input DataFrame <code class="inlineCode">X</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">X[<span class="hljs-string">'</span><span class="hljs-string">PC1'</span>] = X[<span class="hljs-string">'Sepal.Length'</span>]* pca_df[<span class="hljs-string">'Sepal.Length'</span>][<span class="hljs-number">0</span>] + X[<span class="hljs-string">'Sepal.Width'</span>]* pca_df[<span class="hljs-string">'</span><span class="hljs-string">Sepal.Width'</span>][<span class="hljs-number">0</span>]+ X[<span class="hljs-string">'Petal.Length'</span>]* pca_df[<span class="hljs-string">'Petal.Length'</span>][<span class="hljs-number">0</span>]+X[<span class="hljs-string">'Petal.Width'</span>]* pca_df[<span class="hljs-string">'Petal.Width'</span>][<span class="hljs-number">0</span>]
X[<span class="hljs-string">'PC2'</span>] = X[<span class="hljs-string">'Sepal.Length'</span>]* pca_df[<span class="hljs-string">'</span><span class="hljs-string">Sepal.Length'</span>][<span class="hljs-number">1</span>] + X[<span class="hljs-string">'Sepal.Width'</span>]* pca_df[<span class="hljs-string">'Sepal.Width'</span>][<span class="hljs-number">1</span>]+ X[<span class="hljs-string">'Petal.Length'</span>]* pca_df[<span class="hljs-string">'Petal.Length'</span>][<span class="hljs-number">1</span>]+X[<span class="hljs-string">'Petal.Width'</span>]* pca_df[<span class="hljs-string">'Petal.Width'</span>][<span class="hljs-number">1</span>]
X[<span class="hljs-string">'PC3'</span>] = X[<span class="hljs-string">'Sepal.Length'</span>]* pca_df[<span class="hljs-string">'Sepal.Length'</span>][<span class="hljs-number">2</span>] + X[<span class="hljs-string">'Sepal.Width'</span>]* pca_df[<span class="hljs-string">'Sepal.Width'</span>][<span class="hljs-number">2</span>]+ X[<span class="hljs-string">'Petal.Length'</span>]* pca_df[<span class="hljs-string">'Petal.Length'</span>][<span class="hljs-number">2</span>]+X[<span class="hljs-string">'Petal.Width'</span>]* pca_df[<span class="hljs-string">'Petal.Width'</span>][<span class="hljs-number">2</span>]
X[<span class="hljs-string">'PC4'</span>] = X[<span class="hljs-string">'Sepal.Length'</span>]* pca_df[<span class="hljs-string">'Sepal.Length'</span>][<span class="hljs-number">3</span>] + X[<span class="hljs-string">'Sepal.Width'</span>]* pca_df[<span class="hljs-string">'Sepal.Width'</span>][<span class="hljs-number">3</span>]+ X[<span class="hljs-string">'Petal.Length'</span>]* pca_df[<span class="hljs-string">'Petal.Length'</span>][<span class="hljs-number">3</span>]+X[<span class="hljs-string">'Petal.Width'</span>]* pca_df[<span class="hljs-string">'Petal.Width'</span>][<span class="hljs-number">3</span>]
X
</code></pre>
    <p class="normal">Now let’s print <code class="inlineCode">X</code> after the calculation of the PCA components:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_12.png" alt="Table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.12: Printed calculation of the PCA components</p>
    <p class="normal">Now let’s <a id="_idIndexMarker531"/>print the variance ratio and try to understand the implications of using PCA:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(pca.explained_variance_ratio_)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[0.92461872 0.05306648 0.01710261 0.00521218]
</code></pre>
    <p class="normal">The variance ratio indicates the following:</p>
    <ul>
      <li class="bulletList">If we choose to replace the original four features with PC1, then we will be able to capture about 92.3% of the variance of the original variables. We will introduce some approximations by not capturing 100% of the variance of the original four features.</li>
      <li class="bulletList">If we choose to replace the original four features with PC1 and PC2, then we will capture an additional 5.3% of the variance of the original variables.</li>
      <li class="bulletList">If we choose to replace the original four features with PC1, PC2, and PC3, then we will now capture a further 0.017% of the variance of the original variables.</li>
      <li class="bulletList">If we choose to replace the original four features with four principal components, then we will capture 100% of the variance of the original variables (92.4 + 0.053 + 0.017 + 0.005), but replacing four original features with four principal components is meaningless as we did not reduce the dimensions at all and achieved nothing. Next, let us look into the limitations of PCA.</li>
    </ul>
    <h3 id="_idParaDest-211" class="heading-3">Limitations of PCA</h3>
    <p class="normal">Despite its <a id="_idIndexMarker532"/>many benefits, PCA is not without its limitations, as outlined below:</p>
    <ul>
      <li class="bulletList">First, PCA is most effective when dealing with continuous variables, as its underlying mathematical principles are designed to handle numerical data. It struggles with categorical variables, which are common in datasets that include attributes like gender, nationality, or product type. For instance, if you were analyzing a survey dataset with a mixture of numerical responses (such as age or income) and categorical responses (such as preferences or options selected), PCA wouldn’t be suitable for the categorical data.</li>
      <li class="bulletList">Furthermore, PCA operates by creating an approximation of the original high-dimensional data in a lower-dimensional space. While this reduction simplifies data handling and processing, it comes with a cost: a loss of some information. This is a trade-off that needs to be carefully evaluated in each use case. For instance, if you’re dealing with a biomedical dataset where each feature represents a specific genetic marker, using PCA could risk losing critical information that might be relevant for a particular disease’s diagnosis or treatment.</li>
    </ul>
    <p class="normal">So, while PCA is a powerful tool for dimensionality reduction, particularly when dealing with large datasets with many interrelated numerical variables, its limitations need to be considered carefully to ensure it is the right choice for a given application.</p>
    <h3 id="_idParaDest-212" class="heading-3">Association rules mining</h3>
    <p class="normal">Patterns <a id="_idIndexMarker533"/>in a particular dataset are the treasure that needs to be discovered, understood, and mined for the information they contain. There is an important set of algorithms that tries to focus on pattern analysis in a given dataset. One of the more popular algorithms in this class of algorithm <a id="_idIndexMarker534"/>is called the <strong class="keyWord">association rules mining</strong> algorithm, which provides us with the following capabilities:</p>
    <ul>
      <li class="bulletList">The ability to measure the frequency of a pattern</li>
      <li class="bulletList">The ability to establish <em class="italic">cause-and-effect</em> relationships among the patterns</li>
      <li class="bulletList">The ability to quantify the usefulness of patterns by comparing their accuracy to random guessing</li>
    </ul>
    <p class="normal">Now we <a id="_idIndexMarker535"/>will look at some examples of association rules mining.</p>
    <h3 id="_idParaDest-213" class="heading-3">Examples of use</h3>
    <p class="normal">Association rules mining is used when we are trying to investigate the cause-and-effect relationships <a id="_idIndexMarker536"/>between different variables of a dataset. The following are example questions that it can help to answer:</p>
    <ul>
      <li class="bulletList">Which values of humidity, cloud cover, and temperature can lead to rain tomorrow?</li>
      <li class="bulletList">What type of insurance claim can indicate fraud?</li>
      <li class="bulletList">What combinations of medicine may lead to complications for patients?</li>
    </ul>
    <p class="normal">As these examples illustrate, association rules mining has a broad array of applications spanning from business intelligence to healthcare and environmental studies. This algorithm is a potent instrument in the data scientist’s toolkit, capable of translating complex patterns into actionable insights across diverse fields.</p>
    <h3 id="_idParaDest-214" class="heading-3">Market basket analysis</h3>
    <p class="normal">Recommendation engines, an important topic extensively discussed in <em class="chapterRef">Chapter 12</em>, <em class="italic">Recommendation Engines</em> of this book, are powerful tools for personalizing user experiences. However, there’s a simpler, yet effective method for generating recommendations known as market basket analysis. Market basket analysis operates based <a id="_idIndexMarker537"/>on information about which items are frequently bought together. Unlike more sophisticated recommendation engines, this method does not take into account additional user-specific data or individual item preferences expressed by the user. It’s essential to draw a distinction here. Recommendation engines typically create personalized suggestions based on the user’s past behavior, preferences, and a wealth of other user-specific information. In contrast, market basket analysis solely focuses on the combinations of items purchased, regardless of who bought them or their individual preferences.</p>
    <p class="normal">One of the key advantages of market basket analysis is the relative ease of data collection. Gathering comprehensive user preference data can be complex and time-consuming. However, data regarding items bought together can often be simply extracted from transaction records, making market basket analysis a convenient starting point for businesses venturing into the domain of recommendations. For example, this kind of data is generated when we shop at Walmart, and no special technique is required to get the data.</p>
    <p class="normal">By “special techniques,” we refer to additional steps such as conducting user surveys, employing tracking cookies, or building complex data pipelines. Instead, the data is readily <a id="_idIndexMarker538"/>available as a byproduct of the sales process. This data, when collected over a period of time, is called <strong class="keyWord">transnational data</strong>. </p>
    <p class="normal">When <a id="_idIndexMarker539"/>association rules analysis is applied to transnational datasets of the shopping carts being used in convenience stores, supermarkets, and fast-food <a id="_idIndexMarker540"/>chains, it is called <strong class="keyWord">market basket analysis</strong>. It measures the conditional probability of buying a set of items together, which helps to answer the following questions:</p>
    <ul>
      <li class="bulletList">What is the optimal placement of items on the shelf?</li>
      <li class="bulletList">How should the items appear in the marketing catalog?</li>
      <li class="bulletList">What should be recommended, based on a user’s buying patterns?</li>
    </ul>
    <p class="normal">As market basket analysis can estimate how items are related to each other, it is often used for mass-market retail, such as supermarkets, convenience stores, drug stores, and fast-food chains. The advantage of market basket analysis is that the results are almost self-explanatory, which means that they are easily understood by business users.</p>
    <p class="normal">Let’s look at a typical superstore. All the unique items that are available in the store can be represented by a set, <img src="../Images/B18046_06_004.png" alt="" role="presentation"/> = {item<sub class="subscript">1</sub>, item<sub class="subscript">2</sub>, . . . , item<sub class="subscript">m</sub>}. So, if that superstore is selling 500 distinct items, then <img src="../Images/B18046_06_005.png" alt="" role="presentation"/> will be a set of size 500.</p>
    <p class="normal">People will buy items from this store. Each time someone buys an item and pays at the counter, it is added <a id="_idIndexMarker541"/>to a set of the items in a particular transaction, called an <strong class="keyWord">itemset</strong>. In a given period of time, the transactions are grouped together in a set represented by <img src="../Images/B18046_06_006.png" alt="" role="presentation"/>, where <img src="../Images/B18046_06_007.png" alt="" role="presentation"/> = {t<sub class="subscript">1</sub>, t<sub class="subscript">2</sub>, . . . , t<sub class="subscript">n</sub>}.</p>
    <p class="normal">Let’s look at the following simple transaction data consisting of only four transactions. These transactions are summarized in the following table:</p>
    <table id="table002-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal">t<sub class="subscript">1</sub></p>
          </td>
          <td class="table-cell">
            <p class="normal">Wickets, pads</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t<sub class="subscript">2</sub></p>
          </td>
          <td class="table-cell">
            <p class="normal">Bats, wickets, pads, helmets</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t<sub class="subscript">3</sub></p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmets, balls</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t<sub class="subscript">4</sub></p>
          </td>
          <td class="table-cell">
            <p class="normal">Bats, pads, helmets</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Let’s look at this example in more detail:</p>
    <p class="normal"><img src="../Images/B18046_06_008.png" alt="" role="presentation"/> = {bat, wickets, pads, helmets, balls}, which represents all the unique items available at the store.</p>
    <p class="normal">Let’s consider <a id="_idIndexMarker542"/>one of the transactions, t<sub class="subscript">3</sub>, from <img src="../Images/B18046_06_009.png" alt="" role="presentation"/>. Note that items bought in t<sub class="subscript">3</sub> can be represented in the itemset t<sub class="subscript">3</sub>= {helmets, balls}, signifying that a customer bought two items. This set is termed an itemset <a id="_idIndexMarker543"/>because it encompasses all items purchased in a single transaction. Given that there are two items in this itemset, the size of itemset t<sub class="subscript">3</sub> is said to be two. This terminology allows us to classify and analyze purchasing patterns more effectively.</p>
    <h1 id="_idParaDest-215" class="heading-1">Association rules mining</h1>
    <p class="normal">An association <a id="_idIndexMarker544"/>rule mathematically describes the relationship items involved in various transactions. It does this by investigating the relationship between two item sets in the form <em class="italic">X</em> ⇒ <em class="italic">Y</em>, where <img src="../Images/B18046_06_010.png" alt="" role="presentation"/>, <img src="../Images/B18046_06_011.png" alt="" role="presentation"/>. In addition, <em class="italic">X</em> and <em class="italic">Y</em> are non overlapping item sets; which means that <img src="../Images/B18046_06_012.png" alt="" role="presentation"/>.</p>
    <p class="normal">An association rule could be described in the following form:</p>
    <p class="center">{<em class="italic">helmets</em>, <em class="italic">balls</em>} ⇒ {<em class="italic">bike</em>}</p>
    <p class="center">Here, {<em class="italic">helmets</em>, <em class="italic">balls</em>} is <em class="italic">X</em>, and {<em class="italic">bike</em>} is <em class="italic">Y</em>.</p>
    <p class="normal">Let us look <a id="_idIndexMarker545"/>into the different types of association rules.</p>
    <h3 id="_idParaDest-216" class="heading-3">Types of rules</h3>
    <p class="normal">Running associative analysis algorithms will typically result in the generation of a large number <a id="_idIndexMarker546"/>of rules from a transaction dataset. Most of them are useless. To pick rules that can result in useful information, we can classify them as one of the following three types:</p>
    <ul>
      <li class="bulletList">Trivial</li>
      <li class="bulletList">Inexplicable</li>
      <li class="bulletList">Actionable</li>
    </ul>
    <p class="normal">Let’s look at each of these types in more detail.</p>
    <h3 id="_idParaDest-217" class="heading-3">Trivial rules</h3>
    <p class="normal">Among the large numbers of rules generated, many that are derived will be useless as they summarize <a id="_idIndexMarker547"/>common knowledge about the business. They are called trivial rules. Even if confidence in the trivial rules is high, they remain useless and cannot be used for any data-driven decision-making. Note that, here, “confidence” refers to a metric used in association analysis that quantifies the probability of occurrence of a particular event (let’s say B), given that another event (A) has already occurred. We can safely ignore all trivial rules.</p>
    <p class="normal">The following are examples of trivial rules:</p>
    <ul>
      <li class="bulletList">Anyone who jumps from a high-rise building is likely to die.</li>
      <li class="bulletList">Working harder leads to better scores in exams.</li>
      <li class="bulletList">The sales of heaters increase as the temperature drops.</li>
      <li class="bulletList">Driving a car over the speed limit on a highway leads to a higher chance of an accident.</li>
    </ul>
    <h3 id="_idParaDest-218" class="heading-3">Inexplicable rules</h3>
    <p class="normal">Among the <a id="_idIndexMarker548"/>rules that are generated after running the association rules algorithm, the ones that have no obvious explanation are the trickiest to use. Note that a rule can only be useful if it can help us discover and understand a new pattern that is expected to eventually lead toward a certain course of action. If that is not the case, and we cannot explain why event <em class="italic">X</em> led to event <em class="italic">Y</em>, then it is an inexplicable rule, because it’s just a mathematical formula that ends up exploring the pointless <a id="_idIndexMarker549"/>relationship between two events that are unrelated and independent.</p>
    <p class="normal">The following are examples of inexplicable rules:</p>
    <ul>
      <li class="bulletList">People who wear red shirts tend to score better in exams.</li>
      <li class="bulletList">Green bicycles are more likely to be stolen.</li>
      <li class="bulletList">People who buy pickles end up buying diapers as well.</li>
    </ul>
    <h3 id="_idParaDest-219" class="heading-3">Actionable rules</h3>
    <p class="normal">Actionable rules are the golden rules we are looking for. They are understood by the business and lead to insights. They can help us to discover the possible causes of an event when <a id="_idIndexMarker550"/>presented to an audience familiar with the business domain—for example, actionable rules may suggest the best placement in a store for a particular product based on current buying patterns. They may also suggest which items to place together to maximize their chances of selling as users tend to buy them together.</p>
    <p class="normal">The following <a id="_idIndexMarker551"/>are examples of actionable rules and their corresponding actions:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Rule 1</strong>: Displaying ads to users’ social media accounts results in a higher likelihood of sales.</li>
      <li class="bulletList"><strong class="keyWord">Actionable item</strong>: Suggests alternative ways of advertising a product.</li>
      <li class="bulletList"><strong class="keyWord">Rule 2</strong>: Creating more price points increases the likelihood of sales.</li>
      <li class="bulletList"><strong class="keyWord">Actionable item</strong>: One item may be advertised in a sale, while the price of another item is raised.</li>
    </ul>
    <p class="normal">Let us now look into how to rank the rules.</p>
    <h3 id="_idParaDest-220" class="heading-3">Ranking rules</h3>
    <p class="normal">Association <a id="_idIndexMarker552"/>rules are <a id="_idIndexMarker553"/>measured in three ways:</p>
    <ul>
      <li class="bulletList">Support (frequency) of items</li>
      <li class="bulletList">Confidence</li>
      <li class="bulletList">Lift</li>
    </ul>
    <p class="normal">Let’s look at them in more detail.</p>
    <h3 id="_idParaDest-221" class="heading-3">Support</h3>
    <p class="normal">The support measure is a number that quantifies how frequent the pattern we are looking for <a id="_idIndexMarker554"/>is in our dataset. It is calculated by first counting the number of occurrences of our pattern of interest and then dividing <a id="_idIndexMarker555"/>it by the total number of all the transactions.</p>
    <p class="normal">Let’s look at the following formula for a particular <em class="italic">itemset</em><sub class="subscript">a</sub>:</p>
    <p class="center"><em class="italic">numItemset</em><sub class="subscript-italic" style="font-style: italic;">a</sub><em class="italic"> = Number of transactions that contain itemset</em><sub class="subscript-italic" style="font-style: italic;">a</sub></p>
    <p class="center"><em class="italic">num</em><sub class="subscript-italic" style="font-style: italic;">total</sub><em class="italic"> = Total number of transactions</em></p>
    <p class="center"><img src="../Images/B18046_06_013.png" alt="" role="presentation"/></p>
    <p class="normal">By just looking at the support, we can get an idea of how rare the occurrence of a pattern is. Low support means that we are looking for a rare event. In a business context, these rare events could be exceptional cases or outliers, which might carry significant implications. For instance, they may denote unusual customer behavior or a unique sales trend, potentially marking opportunities or threats that require strategic attention.</p>
    <p class="normal">For example, if <em class="italic">itemset</em><sub class="subscript">a</sub><em class="italic"> = {helmet, ball}</em> appears in two transactions out of six, then support <em class="italic">(itemset</em><sub class="subscript">a</sub><em class="italic">) = 2/6 = 0.33</em>.</p>
    <h3 id="_idParaDest-222" class="heading-3">Confidence</h3>
    <p class="normal">The confidence is <a id="_idIndexMarker556"/>a number that quantifies how strongly we can associate <a id="_idIndexMarker557"/>the left side (<em class="italic">X</em>) with the right side (<em class="italic">Y</em>) by calculating the conditional probability. It calculates the probability that event <em class="italic">X</em> will lead toward event <em class="italic">Y</em>, given that event <em class="italic">X</em> occurred.</p>
    <p class="normal">Mathematically, consider the rule <em class="italic">X</em> ⇒ <em class="italic">Y</em>.</p>
    <p class="normal">The confidence of this rule is represented as confidence(<em class="italic">X</em> ⇒ <em class="italic">Y</em> ) and is measured as follows:</p>
    <p class="center"><img src="../Images/B18046_06_014.png" alt="" role="presentation"/></p>
    <p class="normal">Let’s look at an example. Consider the following rule:</p>
    <p class="center">{<em class="italic">helmet</em>, <em class="italic">ball</em>} ⇒ {<em class="italic">wickets</em>}</p>
    <p class="normal">The confidence <a id="_idIndexMarker558"/>of this rule is calculated by the <a id="_idIndexMarker559"/>following formula:</p>
    <p class="center"><img src="../Images/B18046_06_015.png" alt="" role="presentation"/></p>
    <p class="normal">This means that if someone has {helmet, balls} in the basket, then there is a 0.5 or 50% probability that they will also have wickets to go with it.</p>
    <h3 id="_idParaDest-223" class="heading-3">Lift</h3>
    <p class="normal">Another way to estimate the quality of a rule is by calculating the lift. The lift returns a number that quantifies how much improvement has been achieved by a rule at predicting the <a id="_idIndexMarker560"/>result compared to just assuming the result at the right-hand side of the equation. “Improvement” refers to the degree of enhancement or betterment <a id="_idIndexMarker561"/>achieved by a rule in its ability to predict an outcome compared to a baseline or default approach. It represents the extent to which the rule provides more accurate or insightful predictions than what would be obtained by making assumptions solely based on the right-hand side of the equation. If the <em class="italic">X</em> and <em class="italic">Y</em> itemsets are independent, then the lift is calculated as follows:</p>
    <p class="center"><img src="../Images/B18046_06_016.png" alt="" role="presentation"/></p>
    <h2 id="_idParaDest-224" class="heading-2">Algorithms for association analysis</h2>
    <p class="normal">In this <a id="_idIndexMarker562"/>section, we will explore the <a id="_idIndexMarker563"/>following two algorithms that can be used for association analysis:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Apriori algorithm</strong>: Proposed <a id="_idIndexMarker564"/>by Agrawal, R. and Srikant in 1994.</li>
      <li class="bulletList"><strong class="keyWord">FP-growth algorithm</strong>: An <a id="_idIndexMarker565"/>improvement suggested by Han et al. in 2001.</li>
    </ul>
    <p class="normal">Let’s look at each of these algorithms.</p>
    <h3 id="_idParaDest-225" class="heading-3">Apriori algorithm</h3>
    <p class="normal">The apriori algorithm is an iterative and multiphase algorithm used to generate association rules. It is based on a generation-and-test approach.</p>
    <p class="normal">Before <a id="_idIndexMarker566"/>executing the apriori algorithm, we need <a id="_idIndexMarker567"/>to define two variables: support<sub class="subscript">threshold</sub> and Confidence<sub class="subscript">threshold</sub>.</p>
    <p class="normal">The algorithm consists of the following two phases:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Candidate-generation phase</strong>: It generates the candidate itemsets, which contain <a id="_idIndexMarker568"/>sets of all itemsets above support<sub class="subscript">threshold</sub>.</li>
      <li class="bulletList"><strong class="keyWord">Filter phase</strong>: It filters <a id="_idIndexMarker569"/>out all rules below the expected confidence<sub class="subscript">threshold</sub>.</li>
    </ul>
    <p class="normal">After filtering, the resulting rules are the answer.</p>
    <h3 id="_idParaDest-226" class="heading-3">Limitations of the apriori algorithm</h3>
    <p class="normal">The major <a id="_idIndexMarker570"/>bottleneck in the apriori algorithm is the generation <a id="_idIndexMarker571"/>of candidate rules in Phase 1—for example, <img src="../Images/B18046_06_017.png" alt="" role="presentation"/> = {item<sub class="subscript">1</sub>, item<sub class="subscript">2</sub>, . . . , item<sub class="subscript">m</sub>} can produce 2<sup class="superscript">m</sup> possible itemsets. Because of its multiphase design, it first generates these itemsets and then works toward finding the frequent itemsets. This limitation is a huge performance bottleneck and makes the apriori algorithm unsuitable for larger items because it generates too many itemsets before it can find frequent items, which will have an effect on the time taken.</p>
    <p class="normal">Let us now look into the FP-growth algorithm.</p>
    <h3 id="_idParaDest-227" class="heading-3">FP-growth algorithm</h3>
    <p class="normal">The <strong class="keyWord">frequent pattern growth</strong> (<strong class="keyWord">FP-growth</strong>) algorithm is an improvement on the apriori algorithm. It <a id="_idIndexMarker572"/>starts by showing the <a id="_idIndexMarker573"/>frequent transaction FP-tree, which is an ordered tree. It consists of two steps:</p>
    <ul>
      <li class="bulletList">Populating the FP-tree</li>
      <li class="bulletList">Mining frequent patterns</li>
    </ul>
    <p class="normal">Let’s look at these steps one by one.</p>
    <h3 id="_idParaDest-228" class="heading-3">Populating the FP-tree</h3>
    <p class="normal">Let’s consider <a id="_idIndexMarker574"/>the transaction data shown in the following table. Let’s first represent it as a sparse matrix:</p>
    <table id="table003-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">ID</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Bat</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Wickets</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Pads</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Helmet</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Ball</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Let’s calculate the frequency of each item and sort them in descending order by frequency:</p>
    <table id="table004-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Item</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Frequency</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">pads</p>
          </td>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">helmets</p>
          </td>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">bats</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">wickets</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">balls</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Now let’s <a id="_idIndexMarker575"/>rearrange the transaction-based data based on the frequency:</p>
    <table id="table005" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">ID</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Original Items</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Reordered Items</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Wickets, pads</p>
          </td>
          <td class="table-cell">
            <p class="normal">Pads, wickets</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t2</p>
          </td>
          <td class="table-cell">
            <p class="normal">Bat, wickets, pads, helmets</p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmets, pads, wickets, bats</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t3</p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmets, balls</p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmets, balls</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">t4</p>
          </td>
          <td class="table-cell">
            <p class="normal">Bats, pads, helmets</p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmets, pads, bats</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">To build the FP-tree, let’s start with the first branch of the FP-tree. The FP-tree starts with a <strong class="keyWord">Null</strong> as the root. To build the tree, we can represent each item with a node, as shown in the following diagram (the tree representation of t<sub class="subscript">1</sub> is shown here). </p>
    <p class="normal">Note that the label of each node is the name of the item and its frequency is appended after the colon. Also, note that the <strong class="keyWord">pads</strong> item has a frequency of 1:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_13.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.13: FP-tree representation first transaction</p>
    <p class="normal">Using the <a id="_idIndexMarker576"/>same pattern, let’s draw all four transactions, resulting in the full FP-tree. The FP-tree has four leaf nodes, each representing the itemset associated with the four transactions. Note that we need to count the frequencies of each item and need to increase it when used multiple times—for example, when adding t<sub class="subscript">2</sub> to the FP-tree, the frequency of <strong class="keyWord">helmets</strong> was increased to two. Similarly, while adding t<sub class="subscript">4</sub>, it was increased again to three. </p>
    <p class="normal">The resulting tree is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_06_14.png" alt="Diagram, schematic  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.14: FP-tree representing all transactions</p>
    <p class="normal">Note that <a id="_idIndexMarker577"/>the FP-tree generated in the preceding diagram is an ordered tree. This leads us to the second phase of the FP-growth tree: mining frequent patterns.</p>
    <h3 id="_idParaDest-229" class="heading-3">Mining frequent patterns</h3>
    <p class="normal">The second phase of the FP-growth process is focused on mining the frequent patterns from the FP-tree. Creating an ordered tree is a deliberate move, aimed at producing a data structure <a id="_idIndexMarker578"/>that facilitates effortless navigation when hunting for these frequent patterns.</p>
    <p class="normal">We start this journey from a leaf node, which is an end node, and traverse upward. As an example, let’s begin from one of the leaf node items, “bats.” Our next task is to figure out the conditional pattern base for “bat.” The term “conditional pattern base” might sound complex, but it’s merely a collection of all paths that lead from a specific leaf node item to the root of the tree. For our item “bat,” the conditional pattern base will comprise all paths from the “bat” node to the top of the tree. At this point, understanding the difference between ordered and unordered trees becomes critical. In an ordered tree such as the FP-tree, the items adhere to a fixed order, simplifying the pattern mining process. An unordered tree doesn’t provide this structured setup, which could make discovering frequent patterns more challenging.</p>
    <p class="normal">When computing the conditional pattern base for “bats,” we are essentially mapping out all paths from the “bats” node to the root. These paths reveal the items that often co-occur with “bat” in transactions. In essence, we’re following the “branch” of the tree associated with “bat” to understand its relationships with other items. This visual illustration clarifies <a id="_idIndexMarker579"/>where we get this information from and how the FP-tree assists in illuminating frequent patterns in transaction data. The conditional pattern base for <strong class="keyWord">bat</strong> will be as follows:</p>
    <table id="table006" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal">Wicket: 1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Pads: 1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmet: 1</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Pad: 1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Helmet: 1</p>
          </td>
          <td class="table-cell"/>
        </tr>
      </tbody>
    </table>
    <p class="normal">The <strong class="keyWord">frequent pattern</strong> for <strong class="keyWord">bat </strong>will be as follows:</p>
    <p class="center">{<em class="italic">wicket</em>, <em class="italic">pads</em>, <em class="italic">helmet</em>}: <em class="italic">bat</em></p>
    <p class="center">{<em class="italic">pad</em>, <em class="italic">helmet</em>}: <em class="italic">bat</em></p>
    <h3 id="_idParaDest-230" class="heading-3">Code for using FP-growth</h3>
    <p class="normal">Let’s see how <a id="_idIndexMarker580"/>we can generate association rules using the FP-growth algorithm in Python. For this, we will be using the <code class="inlineCode">pyfpgrowth</code> package. First, if we have never used <code class="inlineCode">pyfpgrowth</code> before, let’s install it first:</p>
    <pre class="programlisting code"><code class="hljs-code">!pip install pyfpgrowth
</code></pre>
    <p class="normal">Then, let’s import the packages that we need to use to implement this algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pyfpgrowth <span class="hljs-keyword">as</span> fp
</code></pre>
    <p class="normal">Now we will create the input data in the form of <code class="inlineCode">transactionSet</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">dict1 = {
    <span class="hljs-string">'id'</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],
    <span class="hljs-string">'items'</span>:[[<span class="hljs-string">"wickets"</span>,<span class="hljs-string">"pads"</span>],
    [<span class="hljs-string">"bat"</span>,<span class="hljs-string">"wickets"</span>,<span class="hljs-string">"pads"</span>,<span class="hljs-string">"helmet"</span>],
    [<span class="hljs-string">"helmet"</span>,<span class="hljs-string">"</span><span class="hljs-string">pad"</span>],
    [<span class="hljs-string">"bat"</span>,<span class="hljs-string">"pads"</span>,<span class="hljs-string">"helmet"</span>]]
 }
transactionSet = pd.DataFrame(dict1)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">    id    items
0    0    [wickets, pads]
1    1    [bat, wickets, pads, helmet]
2    2    [helmet, pad]
3    3    [bat, pads, helmet]
</code></pre>
    <p class="normal">Once the input data is generated, we will generate patterns that will be based on the parameters that we passed in <code class="inlineCode">find_frequent_patterns()</code>. Note that the second parameter passed to this function is the minimum support, which is 1 in this case:</p>
    <pre class="programlisting code"><code class="hljs-code">patterns = fp.find_frequent_patterns(transactionSet[<span class="hljs-string">'items'</span>],<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">The patterns <a id="_idIndexMarker581"/>have been generated. Now let’s print the patterns. The patterns list the combinations of items with their supports:</p>
    <pre class="programlisting code"><code class="hljs-code">patterns
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{('pad',): 1,
 ('helmet', 'pad'): 1,
 ('wickets',): 2,
 ('pads', 'wickets'): 2,
 ('bat', 'wickets'): 1,
 ('helmet', 'wickets'): 1,
 ('bat', 'pads', 'wickets'): 1,
 ('helmet', 'pads', 'wickets'): 1,
 ('bat', 'helmet', 'wickets'): 1,
 ('bat', 'helmet', 'pads', 'wickets'): 1,
 ('bat',): 2,
 ('bat', 'helmet'): 2,
 ('bat', 'pads'): 2,
 ('bat', 'helmet', 'pads'): 2,
 ('pads',): 3,
 ('helmet',): 3,
 ('helmet', 'pads'): 2}
</code></pre>
    <p class="normal">Now let’s generate the rules:</p>
    <pre class="programlisting code"><code class="hljs-code">rules = fp.generate_association_rules(patterns,<span class="hljs-number">0.3</span>)
rules
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">{('helmet',): (('pads',), 0.6666666666666666),
 ('pad',): (('helmet',), 1.0),
 ('pads',): (('helmet',), 0.6666666666666666),
 ('wickets',): (('bat', 'helmet', 'pads'), 0.5),
 ('bat',): (('helmet', 'pads'), 1.0),
 ('bat', 'pads'): (('helmet',), 1.0),
 ('bat', 'wickets'): (('helmet', 'pads'), 1.0),
 ('pads', 'wickets'): (('bat', 'helmet'), 0.5),
 ('helmet', 'pads'): (('bat',), 1.0),
 ('helmet', 'wickets'): (('bat', 'pads'), 1.0),
 ('bat', 'helmet'): (('pads',), 1.0),
 ('bat', 'helmet', 'pads'): (('wickets',), 0.5),
 ('bat', 'helmet', 'wickets'): (('pads',), 1.0),
 ('bat', 'pads', 'wickets'): (('helmet',), 1.0),
 ('helmet', 'pads', 'wickets'): (('bat',), 1.0)}
</code></pre>
    <p class="normal">Each rule <a id="_idIndexMarker582"/>has a left-hand side and a right-hand side, separated by a colon (<code class="inlineCode">:</code>). It also gives us the support of each of the rules in our input dataset.</p>
    <h1 id="_idParaDest-231" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we looked at various unsupervised machine learning techniques. We looked at the circumstances in which it is a good idea to try to reduce the dimensionality of the problem we are trying to solve and the different methods of doing this. We also studied the practical examples where unsupervised machine learning techniques can be very helpful, including market basket analysis.</p>
    <p class="normal">In the next chapter, we will look at the various supervised learning techniques. We will start with linear regression and then we will look at more sophisticated supervised machine learning techniques, such as decision-tree-based algorithms, SVM, and XGBoost. We will also study the Naive Bayes algorithm, which is best suited for unstructured textual data.</p>
    <h1 id="_idParaDest-232" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>