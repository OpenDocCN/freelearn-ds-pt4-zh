<html><head></head><body>
  <div id="_idContainer256" class="Basic-Text-Frame">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-293" class="chapterTitle">Neural Network Algorithms</h1>
    <blockquote class="packt_quote">
      <p class="quote">There is no algorithm for humor.</p>
      <p class="cite">—Robert Mankoff</p>
    </blockquote>
    <p class="normal">Neural networks <a id="_idIndexMarker781"/>have been a topic of investigation for over seven decades, but their adoption was restricted due to constraints in computational capabilities and the dearth of digitized data. Today’s environment is significantly altered due to our growing need to solve complex challenges, the explosive growth in data production, and advancements such as cloud computing, which provide us with impressive computational abilities. These enhancements have opened up the potential for us to develop and apply these sophisticated algorithms to solve complex problems that were previously deemed impractical. In fact, this is the research area that is rapidly evolving and is responsible for most of the major advances claimed by leading-edge tech fields such as robotics, edge computing, natural language processing, and self-driving cars.</p>
    <p class="normal">This chapter first introduces the main concepts and components of a typical neural network. Then, it presents the various types of neural networks and explains the different kinds of activation functions used in these neural networks. Then, the backpropagation algorithm is discussed in detail, which is the most widely used algorithm for training a neural network. Next, the transfer learning technique is explained, which can be used to greatly simplify and partially automate the training of models. Finally, how to use deep learning to flag fraudulent documents by way of a real-world example application.</p>
    <p class="normal">The following are the main concepts discussed in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding neural networks</li>
      <li class="bulletList">The evolution of neural networks</li>
      <li class="bulletList">Training a neural network</li>
      <li class="bulletList">Tools and frameworks</li>
      <li class="bulletList">Transfer learning</li>
      <li class="bulletList">Case study: using deep learning for fraud detection</li>
    </ul>
    <p class="normal">Let’s start by looking at the basics of neural networks.</p>
    <h1 id="_idParaDest-294" class="heading-1">The evolution of neural networks</h1>
    <p class="normal">A <a id="_idIndexMarker782"/>neural network, at its most fundamental level, is composed of individual units known as neurons. These neurons serve as the cornerstone of the neural network, with each neuron performing its own specific task. The true power of a neural network unfolds when these individual neurons are organized into structured layers, facilitating complex processing. Each neural network is composed of an intricate web of these layers, connected to create an interconnected network.</p>
    <p class="normal">The information or signal is processed step by step as it travels through these layers. Each layer modifies the signal, contributing to the overall output. To explain, the initial layer receives the input signal, processes it, and then passes it to the next layer. This subsequent layer further processes the received signal and transfers it onward. This relay continues until the signal reaches the final layer, which generates the desired output.</p>
    <p class="normal">It’s these hidden layers, or intermediate layers, that give neural networks their ability to perform deep learning. These layers create a hierarchy of abstract representations by transforming the raw input data progressively into a form that is more useful. This facilitates the extraction of higher-level features from the raw data.</p>
    <p class="normal">This deep learning capability has a vast array of practical applications, from enabling Amazon’s Alexa to understand voice commands to powering Google’s Images and organizing Google Photos.</p>
    <h2 id="_idParaDest-295" class="heading-2">Historical background</h2>
    <p class="normal">Inspired<a id="_idIndexMarker783"/> by the workings of neurons in the human brain, the concept of neural networks was proposed by Frank Rosenblatt in 1957. To understand the architecture fully, it is helpful to briefly look at the layered structure of neurons in the human brain. (Refer to <em class="italic">Figure 8.1</em> to get an idea of how the neurons in the human brain are linked together.)</p>
    <p class="normal">In the<a id="_idIndexMarker784"/> human brain, <strong class="keyWord">dendrites</strong> act<a id="_idIndexMarker785"/> as sensors that detect a signal. Dendrites are integral components of a neuron, serving as the primary sensory apparatus. They are responsible for detecting incoming signals. The signal is then passed on<a id="_idIndexMarker786"/> to an <strong class="keyWord">axon</strong>, which is a long, slender projection of a nerve cell. The function of the axon is to transmit this signal to muscles, glands, and other neurons. As shown in the following diagram, the signal travels through interconnecting tissue <a id="_idIndexMarker787"/>called a <strong class="keyWord">synapse</strong> before being passed on to other neurons. Note that through this organic pipeline, the signal keeps traveling until it reaches the target muscle or gland, where it causes the required action. It typically takes seven to eight milliseconds for the signal to pass through the chain of neurons and reach its destination:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.1: Neuron chained together in the human brain</p>
    <p class="normal">Inspired by this natural architectural masterpiece of signal processing, Frank Rosenblatt devised a technique that would mean digital information could be processed in layers to solve a complex mathematical problem. His initial attempt at designing a neural network was quite simple and looked like a linear regression model. This simple neural network did not have any hidden layers and was named a <em class="italic">perceptron</em>. This simple neural network without any layers, the perceptron, became the basic unit for neural networks. Essentially, a perceptron is the mathematical analog of a biological neuron and hence, serves as the fundamental building block for more complex neural networks.</p>
    <p class="normal">Now, let us delve into a concise historical account of the evolutionary journey of <strong class="keyWord">Artificial Intelligence</strong> (<strong class="keyWord">AI</strong>).</p>
    <h2 id="_idParaDest-296" class="heading-2">AI winter and the dawn of AI spring</h2>
    <p class="normal">The initial enthusiasm toward the groundbreaking concept of the perceptron soon faded when its significant limitations were discovered. In 1969, Marvin Minsky and Seymour Papert conducted an in-depth study that led to the revelation that the perceptron was restricted in its learning capabilities. They found that a perceptron was incapable of learning and processing complex logical functions, even struggling with simple logic functions such as XOR.</p>
    <p class="normal">This discovery triggered a significant decline in interest <a id="_idIndexMarker788"/>in <strong class="keyWord">Machine Learning </strong>(<strong class="keyWord">ML</strong>) and neural networks, commencing an era often referred to as the “AI winter.” This was a period when the global research community largely dismissed the potential of AI, viewing it as inadequate for tackling complex problems.</p>
    <p class="normal">On reflection, the “AI winter” was<a id="_idIndexMarker789"/> in part a consequence of the restrictive hardware capabilities of the time. The hardware either lacked the necessary computing power or was prohibitively expensive, which severely hampered advancements in AI. This limitation stymied the progress and application of AI, leading to widespread disillusionment in its potential.</p>
    <p class="normal">Toward the end of the 1990s, there was a tidal shift regarding the image of AI and its perceived potential. The catalyst for this change was the advances in distributed computing, which provided easily available and affordable infrastructure. Seeing the potential, the newly crowned IT giants of that time (like Google) made AI the focus of their R&amp;D efforts. The renewed interest in AI resulted in the thaw of the so-called AI winter. The thaw reinvigorated research in AI. This eventually resulted in turning the current era into an era that can be called <a id="_idIndexMarker790"/>the <strong class="keyWord">AI spring</strong>, where there is so much interest in AI and neural networks. Also, the digitized data was not available.</p>
    <h1 id="_idParaDest-297" class="heading-1">Understanding neural networks</h1>
    <p class="normal">First, let us <a id="_idIndexMarker791"/>start with the heart of the neural network, the perceptron. You can think of a single perceptron as the simplest possible neural network, and it forms the basic building block of modern complex multi-layered architectures. Let us start by understanding the working of a perceptron.</p>
    <h2 id="_idParaDest-298" class="heading-2">Understanding perceptrons</h2>
    <p class="normal">A <a id="_idIndexMarker792"/>single perceptron<a id="_idIndexMarker793"/> has several inputs and a single output that is controlled or activated by an activation function. This is shown in <em class="italic">Figure 8.2</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.2: A simple perceptron</p>
    <p class="normal">The perceptron shown in <em class="italic">Figure 8.2</em> has three input features; <em class="italic">x</em><sub class="subscript-italic" style="font-style: italic;">1</sub>, <em class="italic">x</em><sub class="subscript-italic" style="font-style: italic;">2</sub>, and <em class="italic">x</em><sub class="subscript-italic" style="font-style: italic;">3</sub>. We also add a constant signal called bias. The bias plays a critical role in our neural network model, as it allows for flexibility in fitting the data. It operates similarly to an intercept added in a linear equation—acting as a sort of “shift” of the activation function—thereby allowing us to fit the data better when our inputs are equal to zero. The input features and the bias get multiplied by weights and are summed up as a weighted sum <img src="../Images/B18046_08_001.png" alt="" role="presentation"/> This weighted sum is passed on to the activation function, which generates the output y. The ability to use a wide variety of activation functions to formulate complex relationships between features and labels is one of the strengths of neural networks. A variety of activation functions is selectable through the hyperparameters. Some common examples include the sigmoid function, which squashes values between 0 and 1, making it a good choice for binary classification problems; the tanh function, which scales values between -1 and 1, providing a zero-centered output; and the <strong class="keyWord">Rectified Linear Unit</strong> (<strong class="keyWord">ReLU</strong>) function, which sets all negative values in the vector to zero, effectively removing any negative influence, and is commonly used in convolutional neural networks. These activation functions are discussed in detail later in the chapter.</p>
    <p class="normal">Let us now look into the intuition behind neural networks.</p>
    <h2 id="_idParaDest-299" class="heading-2">Understanding the intuition behind neural networks</h2>
    <p class="normal">In the last<a id="_idIndexMarker794"/> chapter, we discussed some traditional ML algorithms. These traditional ML algorithms work great for many important use cases. But they do have limitations as well. When the underlying patterns in the training dataset begin to become non-linear and multidimensional, it starts to go beyond the capabilities of traditional ML algorithms to accurately capture the complex relationships between features and labels. These incomprehensive, somewhat simplistic mathematical formulations of complex patterns result in suboptimal performance of the trained models for these use cases. </p>
    <p class="normal">In real-world scenarios, we often encounter situations where the relationships between our features and labels are not linear or straightforward but present complex patterns. This is where neural networks shine, offering us a powerful tool for modeling such intricacies.</p>
    <p class="normal">Neural networks are particularly effective when dealing with high-dimensional data or when the relationships between features and the outcome are non-linear. For instance, they excel in applications like image and speech recognition, where the input data (pixels or sound waves) has complex, hierarchical structures. Traditional ML algorithms might struggle in these instances, given the high degree of complexity and the non-linear relationships between features.</p>
    <p class="normal">While neural networks are incredibly powerful tools, it’s crucial to acknowledge that they aren’t without their limitations. These restrictions, explored in detail later in this chapter, are critical to grasp for the practical and effective use of neural networks in tackling real-world dilemmas.</p>
    <p class="normal">Now, let’s illustrate some common patterns and their associated challenges when simpler ML algorithms like linear regression are employed. Picture this – we’re trying to predict a data scientist’s salary based on the “years spent in education.” We have collected two different datasets from two separate organizations.</p>
    <p class="normal">First, let’s introduce you to Dataset 1, illustrated in <em class="italic">Figure 8.3(a)</em>. It depicts a relatively straightforward relationship between the feature (years spent in education) and the label (salary), which appears to be linear. However, even this simple pattern throws a couple of challenges when we attempt to mathematically model it using a linear algorithm:</p>
    <ul>
      <li class="bulletList">We know that a salary cannot be negative, meaning that regardless of the years spent in education, the salary (<code class="inlineCode">y</code>) should never be less than zero.</li>
      <li class="bulletList">There’s at least one junior data scientist who may have just graduated, thus spending “<code class="inlineCode">x</code><sub class="subscript">1</sub>” years in education, but currently earns zero salary, perhaps as an intern. Hence, for the “<code class="inlineCode">x</code>" values ranging from zero to “<code class="inlineCode">x</code><sub class="subscript">1</sub>,” the salary “<code class="inlineCode">y</code>" remains zero, as depicted in <em class="italic">Figure 8.3(a)</em>.</li>
    </ul>
    <p class="normal">Interestingly, we <a id="_idIndexMarker795"/>can capture such intricate relationships between the feature and label using the Rectified Linear activation function available in neural networks, a concept we will explore later.</p>
    <p class="normal">Next, we have Dataset 2, showcased in <em class="italic">Figure 8.3(b)</em>. This dataset represents a non-linear relationship between the feature and the label. Here’s how it works:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The salary “<code class="inlineCode">y</code>" remains at zero while “<code class="inlineCode">x</code>" (years spent in education) varies from zero to “<code class="inlineCode">x</code><sub class="subscript">1</sub>.”</li>
      <li class="numberedList">The salary increases sharply as “<code class="inlineCode">x</code>" nears “<code class="inlineCode">x</code><sub class="subscript">2</sub>.”</li>
      <li class="numberedList">But once “<code class="inlineCode">y</code>" exceeds “<code class="inlineCode">x</code><sub class="subscript">2</sub>,” the salary plateaus and flattens out.</li>
    </ol>
    <p class="normal">As we will see later in this book, we can model such relationships using the sigmoid activation function within a neural network framework. Understanding these patterns and knowing which tools to apply is essential to effectively leverage the power of neural networks:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_03.png" alt="Chart, scatter chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.3: Salary and years of education</p>
    <p class="packt_figref">(a) Dataset 1: Linear patterns (b) Dataset 2: Non-linear patterns</p>
    <h2 id="_idParaDest-300" class="heading-2">Understanding layered deep learning architectures</h2>
    <p class="normal">For more <a id="_idIndexMarker796"/>complex problems, researchers <a id="_idIndexMarker797"/>have developed a multilayer neural network<a id="_idIndexMarker798"/> called a <strong class="keyWord">multilayer perceptron</strong>. A <a id="_idIndexMarker799"/>multilayer neural network has a few different layers, as shown in the following diagram. These layers are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Input layer</strong>: The <a id="_idIndexMarker800"/>first layer is the input layer. At the input layer, the feature values are fed as input to the network.</li>
      <li class="bulletList"><strong class="keyWord">Hidden layer(s)</strong>: The <a id="_idIndexMarker801"/>input layer is followed by one or more hidden layers. Each hidden layers are the arrays of similar activation functions.</li>
      <li class="bulletList"><strong class="keyWord">Output layer</strong>: The<a id="_idIndexMarker802"/> final layer is called the output layer.</li>
    </ul>
    <div class="note">
      <p class="normal">A <a id="_idIndexMarker803"/>simple neural network will have one hidden layer. A deep neural network is <a id="_idIndexMarker804"/>a neural network with two or more hidden layers. See <em class="italic">Figure 8.4</em>.</p>
    </div>
    <figure class="mediaobject"><img src="../Images/B18046_08_04.png" alt="Chart, scatter chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.4: Simple neural network and deep neural network</p>
    <p class="normal">Next, let us try to understand the function of hidden layers.</p>
    <h3 id="_idParaDest-301" class="heading-3">Developing an intuition for hidden layers</h3>
    <p class="normal">In a<a id="_idIndexMarker805"/> neural network, hidden layers play a key role in interpreting the input data. Hidden layers are methodically organized in a hierarchical structure within the neural network, where each layer performs a distinct non-linear transformation on its input data. This design allows for the extraction of progressively more abstract and nuanced features from the input.</p>
    <p class="normal">Consider the example of convolutional neural networks, a subtype of neural networks specifically engineered for image-processing tasks. In this context, the lower hidden layers focus on discerning simple, local features such as edges and corners within an image. These features, while fundamental, don’t carry much meaning on their own.</p>
    <p class="normal">As we move deeper into the hidden layers, these layers start to connect the dots, so to speak. They integrate the basic patterns detected by the lower layers, assembling them into more complex, meaningful structures. As a result, an originally incoherent scatter of edges and corners transforms into recognizable shapes and patterns, granting the network a level of “vision.”</p>
    <p class="normal">This progressive transformation process turns unprocessed pixel values into an elaborate mapping of features and patterns, enabling advanced applications such as fingerprint <a id="_idIndexMarker806"/>recognition. Here, the network can pick out the unique arrangement of ridges and valleys in a fingerprint, converting this raw visual data into a unique identifier. Hence, hidden layers convert raw data and refined it into valuable insights.</p>
    <h3 id="_idParaDest-302" class="heading-3">How many hidden layers should be used?</h3>
    <p class="normal">Note that<a id="_idIndexMarker807"/> the optimal number of hidden layers will vary from problem to problem. For some problems, single-layer neural networks should be used. These problems typically exhibit straightforward patterns that can be easily captured and formulated by a minimalist network design. For others, we should add multiple layers for the best performance. For example, if you’re dealing with a complex problem, such as image recognition or natural language processing, a neural network with multiple hidden layers and a greater number of nodes in each layer might be necessary.</p>
    <p class="normal">The complexity of your data’s underlying patterns will largely influence your network design. For instance, using an excessively complex neural network for a simple problem might lead to overfitting, where your model becomes too tailored to the training data and performs poorly on new, unseen data. On the other hand, a model that’s too simple for a complex problem might result in underfitting, where the model fails to capture essential patterns in the data.</p>
    <p class="normal">Additionally, the choice of activation function plays a critical role. For example, if your output needs to be binary (like in a yes/no problem), a sigmoid function could be suitable. For multi-class classification problems, a softmax function might be better.</p>
    <p class="normal">Ultimately, the process of selecting your neural network’s architecture requires careful analysis of your problem, coupled with experimentation and fine-tuning. This is where developing a baseline experimental model can be beneficial, allowing you to iteratively adjust and enhance your network’s design for optimal performance.</p>
    <p class="normal">Let us next look into the mathematical basis of a neural network.</p>
    <h3 id="_idParaDest-303" class="heading-3">Mathematical basis of neural network</h3>
    <p class="normal">Understanding<a id="_idIndexMarker808"/> the mathematical foundation of neural networks is key to leveraging their power. While they may seem complex, the principles are based on familiar mathematical concepts such as linear algebra, calculus, and probability. The beauty of neural networks lies in their ability to learn from data and improve over time, attributes that are rooted in their mathematical structure:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_05.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.5: A multi-layer perceptron</p>
    <p class="normal"><em class="italic">Figure 8.5</em> shows<a id="_idIndexMarker809"/> a 4-layer neural network. In this neural network, an important thing to note is that the neuron is the basic unit of this network, and each neuron of a layer is connected to all neurons of the next layer. For complex networks, the number of these interconnections explodes, and we will explore different ways of reducing these interconnections without sacrificing too much quality.</p>
    <p class="normal">First, let’s try to formulate the problem we are trying to solve.</p>
    <p class="normal">The input is a feature vector, <em class="italic">x</em>, of dimensions <em class="italic">n</em>.</p>
    <p class="normal">We want the neural network to predict values. The predicted values are represented by <em class="italic">ý</em>.</p>
    <p class="normal">Mathematically, we want to determine, given a particular input, the probability that a transaction is fraudulent. In other words, given a particular value of <em class="italic">x</em>, what is the probability that <em class="italic">y</em> = 1? Mathematically, we can represent this as follows:</p>
    <p class="center"><img src="../Images/B18046_08_002.png" alt="" role="presentation"/></p>
    <p class="normal">Note <a id="_idIndexMarker810"/>that <em class="italic">x</em> is an <em class="italic">n</em><sub class="subscript-italic" style="font-style: italic;">x</sub>-dimensional vector, where <em class="italic">n</em><sub class="subscript-italic" style="font-style: italic;">x</sub> is the number of input variables.</p>
    <p class="normal">The neural network shown in <em class="italic">Figure 8.6</em> has four layers. The layers between the input and the output are the hidden layers. The number of neurons in the first hidden layer is denoted by <img src="../Images/B18046_08_003.png" alt="" role="presentation"/>. The links between various nodes are multiplied by parameters called <em class="italic">weights</em>. The process of training a neural network is fundamentally centered around determining the optimal values for the weights associated with the various connections between the network’s neurons. By adjusting these weights, the network can fine-tune its calculations and improve its performance over time.</p>
    <p class="normal">Let’s see how we can train a neural network.</p>
    <h1 id="_idParaDest-304" class="heading-1">Training a neural network</h1>
    <p class="normal">The<a id="_idIndexMarker811"/> process of building a neural network using a given dataset is called training a neural network. Let’s look into the anatomy of a typical neural network. When we talk about training a neural network, we are talking about calculating the best values for the weights. The training is done iteratively by using a set of examples in the form of training data. The examples in the training data have the expected values of the output for different combinations of input values. The training process for neural networks is different from the way traditional models are trained (which was discussed in <em class="chapterRef">Chapter 7</em>, <em class="italic">Traditional Supervised Learning Algorithms</em>).</p>
    <h1 id="_idParaDest-305" class="heading-1">Understanding the anatomy of a neural network</h1>
    <p class="normal">Let’s see what a <a id="_idIndexMarker812"/>neural network consists of:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Layers</strong>: Layers are<a id="_idIndexMarker813"/> the core building blocks of a neural network. Each layer is a data-processing module that acts as a filter. It takes one or more inputs, processes them in a certain way, and then produces one or more outputs. Every time data passes through a layer, it goes through a processing phase and shows patterns that are relevant to the business question we are trying to answer.</li>
      <li class="bulletList"><strong class="keyWord">Loss function</strong>: The <a id="_idIndexMarker814"/>loss function provides the feedback signal that is used in the various iterations of the learning process. The loss function provides the deviation for a single example.</li>
      <li class="bulletList"><strong class="keyWord">Cost function</strong>: The <a id="_idIndexMarker815"/>cost function is the loss function on a complete set of examples.</li>
      <li class="bulletList"><strong class="keyWord">Optimizer</strong>: An<a id="_idIndexMarker816"/> optimizer determines how the feedback signal provided by the loss function will be interpreted.</li>
      <li class="bulletList"><strong class="keyWord">Input data</strong>: Input data <a id="_idIndexMarker817"/>is the data that is used to train the neural network. It specifies the target variable.</li>
      <li class="bulletList"><strong class="keyWord">Weights</strong>: The weights <a id="_idIndexMarker818"/>are calculated by training the network. Weights roughly correspond to the importance of each of the inputs. For example, if a particular input is more important than other inputs, after training, it is given a greater weight value, acting as a multiplier. Even a weak signal for that important input will gather strength from the large weight value (which acts as a multiplier). Thus weight ends up turning each of the inputs according to their importance.</li>
      <li class="bulletList"><strong class="keyWord">Activation function</strong>: The <a id="_idIndexMarker819"/>values are multiplied by different weights and then aggregated. Exactly how they will be aggregated and how their value will be interpreted will be determined by the type of the chosen activation function.</li>
    </ul>
    <p class="normal">Let’s now have a look at a very important aspect of neural network training.</p>
    <p class="normal">While training neural networks, we take each of the examples one by one. For each of the examples, we generate the output using our under-training model. The term “under-training” refers to the model’s learning state, where it is still adjusting and learning from data and has not reached its optimal performance yet. During this stage, the model parameters, such as weights, are constantly updated and adjusted to improve its predictive performance. We calculate the difference between the expected output and the predicted output. For each individual example, this difference is called the <strong class="keyWord">loss</strong>. Collectively, the loss across the complete training dataset is called the <strong class="keyWord">cost</strong>. As we keep on training the model, we aim to find the right values of weights that will result in the smallest loss value. Throughout the training, we keep on adjusting the values of the weights until we find the set of values for the weights that results in the minimum possible overall cost. Once we reach the minimum cost, we mark the model as trained.</p>
    <h1 id="_idParaDest-306" class="heading-1">Defining gradient descent</h1>
    <p class="normal">The <a id="_idIndexMarker820"/>central goal of training a neural network is to identify the correct values for the weights, which act like “dials” or “knobs” that we adjust to minimize the difference between the model’s predictions and the actual values.</p>
    <p class="normal">When training begins, we initiate these weights with random or default values. We then progressively adjust them using an optimization algorithm, a popular choice being “gradient descent,” to incrementally improve our model’s predictions.</p>
    <p class="normal">Let’s dive deeper into the gradient descent algorithm. The journey of gradient descent starts from the initial random values of weights that we set. </p>
    <p class="normal">From this starting point, we iterate and, at each step, we adjust these weights to move us closer to the minimum cost.</p>
    <p class="normal">To paint a clearer picture, imagine our data features as the input vector <strong class="keyWord">X</strong>. The true value of the target variable is <strong class="keyWord">Y</strong>, while the value our model predicts is <strong class="keyWord">Y</strong>. We measure the difference, or deviation, between these actual and predicted values. This difference gives us our loss.</p>
    <p class="normal">We then update our weights, taking into account two key factors: the direction to move and the size of the step, also known as the learning rate.</p>
    <p class="normal">The “direction” informs us where to move to find the minimum of the loss function. Think of this as descending a hill – we want to go “downhill” where the slope is steepest to get to the bottom (our minimum loss) the fastest.</p>
    <p class="normal">The “learning rate” determines the size of our step in that chosen direction. It’s like deciding whether to walk or run down that hill – a larger learning rate means bigger steps (like running), and a smaller one means smaller steps (like walking).</p>
    <p class="normal">The goal of this iterative process is to reach a point from which we can’t go “downhill”, meaning we have found the minimum cost, indicating our weights are now optimal, and our model is well trained.</p>
    <p class="normal">This simple iterative process is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_06.png" alt="A picture containing text, athletic game, sport  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.6: Gradient Descent Algorithm, finding the minimum</p>
    <p class="normal">The diagram <a id="_idIndexMarker821"/>shows how, by varying the weights, gradient descent tries to find the minimum cost. The learning rate and chosen direction will determine the next point on the graph to explore.</p>
    <p class="normal">Selecting the right value for the learning rate is important. If the learning rate is too small, the problem may take a lot of time to converge. If the learning rate is too high, the problem will not converge. In the preceding diagram, the dot representing our current solution will keep oscillating between the two opposite lines of the graph.</p>
    <p class="normal">Now, let’s see how to minimize a gradient. Consider only two variables, <em class="italic">x</em> and <em class="italic">y</em>. The gradient of <em class="italic">x</em> and <em class="italic">y</em> is calculated as follows:</p>
    <p class="center"><img src="../Images/B18046_08_004.png" alt="" role="presentation"/></p>
    <p class="normal">To minimize the gradient, the following approach can be used:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">adjust_position</span>(<span class="hljs-params">gradient</span>):
    <span class="hljs-keyword">while</span> gradient != <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> gradient &lt; <span class="hljs-number">0</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Move right"</span>)
            <span class="hljs-comment"># here would be your logic to move right</span>
        <span class="hljs-keyword">elif</span> gradient &gt; <span class="hljs-number">0</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Move left"</span>)
            <span class="hljs-comment"># here would be your logic to move left</span>
</code></pre>
    <p class="normal">This algorithm can also be used to find the optimal or near-optimal values of weights for a neural network.</p>
    <p class="normal">Note that the calculation of gradient descent proceeds backward throughout the network. We start<a id="_idIndexMarker822"/> by calculating the gradient of the final layer first, and then the second-to-last one, and then the one before that, until we reach the first layer. This is called backpropagation, which was introduced by Hinton, Williams, and Rumelhart in 1985.</p>
    <p class="normal">Next, let’s look into activation functions.</p>
    <h1 id="_idParaDest-307" class="heading-1">Activation functions</h1>
    <p class="normal">An activation function <a id="_idIndexMarker823"/>formulates how the inputs to a particular neuron will be processed to generate an output.</p>
    <p class="normal">As shown in <em class="italic">Figure 8.7</em>, each of the neurons in a neural network has an activation function that determines how inputs will be processed:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_07.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.7: Activation function</p>
    <p class="normal">In the preceding diagram, we can see that the results generated by an activation function are passed on to the output. The activation function sets the criteria that how the values of the inputs are supposed to be interpreted to generate an output.</p>
    <p class="normal">For exactly the same input values, different activation functions will produce different outputs. Understanding how to select the right activation function is important when using neural networks to solve problems.</p>
    <p class="normal">Let’s now look into these activation functions one by one.</p>
    <h2 id="_idParaDest-308" class="heading-2">Step function</h2>
    <p class="normal">The <a id="_idIndexMarker824"/>simplest possible activation function is the threshold function. The <a id="_idIndexMarker825"/>output of the threshold function is binary: 0 or 1. It will generate 1 as the output if any of the inputs are greater than 1. This can be explained in <em class="italic">Figure 8.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_08.png" alt="Diagram  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.8: Step function</p>
    <p class="normal">Despite its simplicity, the threshold activation function plays an important role, especially when we need a clear demarcation between the outputs. With this function, as soon as there’s any non-zero value in the weighted sums of inputs, the output (<em class="italic">y</em>) turns to 1. However, its simplicity has its drawbacks – the function is exceedingly sensitive and could be erroneously triggered by the slightest signal or noise in the input.</p>
    <p class="normal">For instance, consider a situation where a neural network uses this function to classify emails into “spam” or “not spam.” Here, an output of 1 might represent “spam” and 0 might represent “not spam.” The slightest presence of a characteristic (like certain key spam words) could trigger the function to classify the email as “spam.” Hence, while it’s a valuable tool for certain use cases, its potential for over-sensitivity should be considered, especially in applications where noise or minor variances in input data are common. Next, let us look into the sigmoid function.</p>
    <h2 id="_idParaDest-309" class="heading-2">Sigmoid function</h2>
    <p class="normal">The <a id="_idIndexMarker826"/>sigmoid function<a id="_idIndexMarker827"/> can be thought of as an improvement of the threshold function. Here, we have control over the sensitivity of the activation function:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_09.png" alt="Diagram  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.9: Sigmoid activation function</p>
    <p class="normal">The<a id="_idIndexMarker828"/> sigmoid function, <em class="italic">y</em>, is defined as follows and shown in <em class="italic">Figure 8.9</em>:</p>
    <p class="center"><img src="../Images/B18046_08_005.png" alt="" role="presentation"/></p>
    <p class="normal">It can be implemented in Python as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">sigmoidFunction</span>(<span class="hljs-params">z</span>):
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/ (<span class="hljs-number">1</span>+np.exp(-z))
</code></pre>
    <p class="normal">The <a id="_idIndexMarker829"/>code above demonstrates the sigmoid function using Python. Here, <code class="inlineCode">np.exp(-z)</code> is the exponential operation applied to <code class="inlineCode">-z</code>, and this term is added to 1 to form the denominator of the equation, resulting in a value between 0 and 1.</p>
    <p class="normal">The reduction in the activation function’s sensitivity through the sigmoid function makes it less susceptible to sudden aberrations or “glitches” in the input. However, it’s worth noting that the output remains binary, meaning it can still only be 0 or 1.</p>
    <p class="normal">Sigmoid functions are widely used in binary classification problems where the output is expected to be either 0 or 1. For instance, if you are developing a model to predict whether an email is spam (1) or not spam (0), a sigmoid activation function would be a suitable choice.</p>
    <p class="normal">Now, let’s delve into the <strong class="keyWord">ReLU</strong> activation function.</p>
    <h2 id="_idParaDest-310" class="heading-2">ReLU</h2>
    <p class="normal">The <a id="_idIndexMarker830"/>output for the first two activation functions <a id="_idIndexMarker831"/>presented in this chapter was binary. That means that they will take a set of input variables and convert them into binary outputs. ReLU is an activation function that takes a set of input variables as input and converts them into a single continuous output. In neural networks, ReLU is the most popular activation function and is usually used in the hidden layers, where we do not want to convert continuous variables into category variables.</p>
    <p class="normal">The following diagram summarizes the ReLU activation function:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_10.png" alt="Chart, line chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.10: ReLU</p>
    <p class="normal">Note that when <em class="italic">x</em> ≤ 0, that means <em class="italic">y</em> = 0. This means that any signal from the input that is zero or less than zero is translated into a zero output:</p>
    <p class="center"><img src="../Images/B18046_08_006.png" alt="" role="presentation"/></p>
    <p class="center"><img src="../Images/B18046_08_007.png" alt="" role="presentation"/></p>
    <p class="normal">As soon as <em class="italic">x</em> becomes more than zero, it is <em class="italic">x</em>.</p>
    <p class="normal">The ReLU function is one of the most used activation functions in neural networks. It can be implemented<a id="_idIndexMarker832"/> in Python as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">relu</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> x
</code></pre>
    <p class="normal">Now let’s look into Leaky ReLU, which is based on ReLU.</p>
    <h3 id="_idParaDest-311" class="heading-3">Leaky ReLU</h3>
    <p class="normal">In ReLU, a <a id="_idIndexMarker833"/>negative value for <em class="italic">x</em> results in a zero value for <em class="italic">y</em>. This means that some information is lost in the process, which makes training cycles longer, especially at the start of training. The Leaky ReLU activation function resolves <a id="_idIndexMarker834"/>this issue. The following applies to Leaky ReLu:</p>
    <p class="center"><img src="../Images/B18046_08_008.png" alt="" role="presentation"/></p>
    <p class="center"><img src="../Images/B18046_08_007.png" alt="" role="presentation"/></p>
    <p class="normal">This is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_11.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.11: Leaky ReLU </p>
    <p class="normal">Here, <img src="../Images/B18046_07_033.png" alt="" role="presentation"/> is a<a id="_idIndexMarker835"/> parameter with a value less than<a id="_idIndexMarker836"/> one.</p>
    <p class="normal">It can be implemented in Python as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">leaky_relu</span>(<span class="hljs-params">x, beta=</span><span class="hljs-number">0.01</span>):
    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> beta * x    
    <span class="hljs-keyword">else</span>:        
        <span class="hljs-keyword">return</span> x
</code></pre>
    <p class="normal">There are various strategies for assigning a value to <img src="../Images/B18046_08_011.png" alt="" role="presentation"/>:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Default value</strong>: We<a id="_idIndexMarker837"/> can assign a default value to <img src="../Images/B18046_08_011.png" alt="" role="presentation"/>, typically <code class="inlineCode">0.01</code>. This is the most straightforward approach and can be useful in scenarios where we want a quick implementation without any intricate tuning.</li>
      <li class="bulletList"><strong class="keyWord">Parametric ReLU</strong>: Another <a id="_idIndexMarker838"/>approach is to allow <img src="../Images/B18046_08_011.png" alt="" role="presentation"/> to be a tunable parameter in our neural network model. In this case, the optimal value for <img src="../Images/B18046_08_011.png" alt="" role="presentation"/> is learned during the training process itself. This is beneficial in scenarios where we aim to tailor our activation function to the specific patterns present in our data.</li>
      <li class="bulletList"><strong class="keyWord">Randomized ReLU</strong>: We <a id="_idIndexMarker839"/>could also choose to randomly assign a value to <img src="../Images/B18046_08_015.png" alt="" role="presentation"/>. This technique, known as randomized ReLU, can act as a form of regularization and help prevent overfitting by introducing some randomness into the model. This could be helpful in scenarios where we have a large dataset with complex patterns and we want to ensure our model doesn’t overfit to the training data.</li>
    </ul>
    <h2 id="_idParaDest-312" class="heading-2">Hyperbolic tangent (tanh)</h2>
    <p class="normal">The<a id="_idIndexMarker840"/> hyperbolic tangent function, or tanh, is closely related to the sigmoid function, with a key distinction: it can output <a id="_idIndexMarker841"/>negative values, thereby offering a broader output range between <code class="inlineCode">-1</code> and <code class="inlineCode">1</code>. This can be useful in situations where we want to model phenomena that contain both positive and negative influences. <em class="italic">Figure 8.12</em> illustrates this:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_12.png" alt="Chart  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 8.12: Hyperbolic tangent</p>
    <p class="normal">The <em class="italic">y</em> function is as follows:</p>
    <p class="center"><img src="../Images/B18046_08_016.png" alt="" role="presentation"/></p>
    <p class="normal">It can be<a id="_idIndexMarker842"/> implemented by the following Python code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">def</span> <span class="hljs-title">tanh</span>(<span class="hljs-params">x</span>): 
    numerator = <span class="hljs-number">1</span> - np.exp(-<span class="hljs-number">2</span> * x) 
    denominator = <span class="hljs-number">1</span> + np.exp(-<span class="hljs-number">2</span> * x) 
    <span class="hljs-keyword">return</span> numerator / denominator
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker843"/>Python code, we’re using the <code class="inlineCode">numpy</code> library, indicated by <code class="inlineCode">np</code>, to handle the mathematical operations. The <code class="inlineCode">tanh</code> function, like the <code class="inlineCode">sigmoid</code>, is an activation function used in neural networks to add non-linearity to the model. It is often preferred over the sigmoid function in hidden layers of a neural network as it centers the data by making the output mean <code class="inlineCode">0</code>, which can make learning in the next layer easier. However, the choice between <code class="inlineCode">tanh</code>, <code class="inlineCode">sigmoid</code>, or any other activation function largely depends on the specific needs and complexities of the model you’re working with.</p>
    <p class="normal">Moving on, let’s now delve into the softmax function.</p>
    <h2 id="_idParaDest-313" class="heading-2">Softmax</h2>
    <p class="normal">Sometimes, we <a id="_idIndexMarker844"/>need more than two levels for the <a id="_idIndexMarker845"/>output of the activation function. Softmax is an activation function that provides us with more than two levels for the output. It is best suited to multiclass classification problems. Let’s assume that we have <em class="italic">n</em> classes. We have input values. The input values map the classes as follows:</p>
    <p class="center"><em class="italic">x = {x</em><sup class="superscript">(1)</sup><em class="italic">,x</em><sup class="superscript">(2)</sup><em class="italic">,....x</em><sup class="superscript">(n)</sup><em class="italic">}</em></p>
    <p class="normal">Softmax operates on probability theory. For binary classifiers, the activation function in the final layer will be sigmoid, and for multiclass classifiers, it will be softmax. To illustrate, let’s say we’re trying to classify an image of a fruit, where the classes are <code class="inlineCode">apple</code>, <code class="inlineCode">banana</code>, <code class="inlineCode">cherry</code>, and <code class="inlineCode">date</code>. The softmax function calculates the probabilities of the image belonging to each of these classes. The class with the highest probability is then considered as the prediction.</p>
    <p class="normal">To break this down in terms of Python code and equations, let’s look at the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">def</span> <span class="hljs-title">softmax</span>(<span class="hljs-params">x</span>): 
    <span class="hljs-keyword">return</span> np.exp(x) / np.<span class="hljs-built_in">sum</span>(np.exp(x), axis=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">In this code snippet, we’re using the <code class="inlineCode">numpy</code> library (<code class="inlineCode">np</code>) to perform the mathematical operations. The softmax function takes an array of <code class="inlineCode">x</code> as input, applies the exponential function to each element, and normalizes the results so that they sum up to <code class="inlineCode">1</code>, which is the total <a id="_idIndexMarker846"/>probability across all classes.</p>
    <p class="normal">Now let us look into various tools and frameworks related to neural networks.</p>
    <h1 id="_idParaDest-314" class="heading-1">Tools and frameworks</h1>
    <p class="normal">In this section, we<a id="_idIndexMarker847"/> will delve into the vast array of tools and frameworks that have been developed specifically to facilitate the implementation of neural networks. Each of these frameworks has its unique advantages and possible limitations.</p>
    <p class="normal">Among the <a id="_idIndexMarker848"/>numerous options available, we’ve chosen to spotlight Keras, a high-level neural network API, which is capable of running on top of TensorFlow. Why Keras and TensorFlow, you may wonder? Well, these two in combination offer several notable benefits that make them a popular choice among practitioners.</p>
    <p class="normal">Firstly, Keras, with <a id="_idIndexMarker849"/>its user-friendly and modular nature, simplifies the process of building and designing neural network models, thereby catering to beginners as well as experienced users. Secondly, its compatibility with TensorFlow, a powerful end-to-end open-source platform for ML, ensures robustness and versatility. TensorFlow’s ability to deliver high computational performance is another valuable asset. Together, they form a dynamic duo that strikes a balance between usability and functionality, making them an excellent choice for the development and deployment of neural network models.</p>
    <p class="normal">In the following sections, we’ll explore more about how to use Keras with a TensorFlow backend to construct neural networks.</p>
    <h2 id="_idParaDest-315" class="heading-2">Keras</h2>
    <p class="normal">Keras (<a href="https://www.tensorflow.org/guide/keras"><span class="url">https://www.tensorflow.org/guide/keras</span></a>) is <a id="_idIndexMarker850"/>one of the most popular and easy-to-use neural network libraries and is written in Python. It was written with ease of use in mind and provides the fastest way to implement deep learning. Keras only provides high-level blocks and is considered at the model level.</p>
    <p class="normal">Now, let’s look into the various backend engines of Keras.</p>
    <h3 id="_idParaDest-316" class="heading-3">Backend engines of Keras</h3>
    <p class="normal">Keras needs a <a id="_idIndexMarker851"/>lower-level deep learning library to perform tensor-level manipulations. This foundational layer is referred to as the “backend engine.” </p>
    <p class="normal">In simpler terms, tensor-level manipulations involve the computations and transformations that are performed on multi-dimensional arrays of data, known as<a id="_idIndexMarker852"/> tensors, which<a id="_idIndexMarker853"/> are the primary data structure used in neural networks. This lower-level deep-learning library is called the <em class="italic">backend engine</em>. Possible backend engines for Keras include the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">TensorFlow</strong> (<a href="http://www.tensorflow.org"><span class="url">www.tensorflow.org</span></a>): This is<a id="_idIndexMarker854"/> the most <a id="_idIndexMarker855"/>popular <a id="_idIndexMarker856"/>framework of its kind and is open sourced by Google.</li>
      <li class="bulletList"><strong class="keyWord">Theano</strong>: This <a id="_idIndexMarker857"/>was <a id="_idIndexMarker858"/>developed <a id="_idIndexMarker859"/>at the MILA lab at Université de Montréal.</li>
      <li class="bulletList"><strong class="keyWord">Microsoft Cognitive Toolkit</strong> (<strong class="keyWord">CNTK</strong>) (<a href="https://learn.microsoft.com/en-us/cognitive-toolkit/"><span class="url">https://learn.microsoft.com/en-us/cognitive-toolkit/</span></a>): This <a id="_idIndexMarker860"/>was <a id="_idIndexMarker861"/>developed <a id="_idIndexMarker862"/>by Microsoft.</li>
    </ul>
    <p class="normal">The format of this <a id="_idIndexMarker863"/>modular deep learning technology stack is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_13.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.13: Keras architecture</p>
    <p class="normal">The<a id="_idIndexMarker864"/> advantage of this modular deep learning architecture is that the backend of Keras can be changed without rewriting any code. For example, if we find TensorFlow better than Theona for a particular task, we can simply change the backend to TensorFlow without rewriting any code.</p>
    <p class="normal">Next, let us look into the low-level layers of the deep learning stack.</p>
    <h3 id="_idParaDest-317" class="heading-3">Low-level layers of the deep learning stack</h3>
    <p class="normal">The <a id="_idIndexMarker865"/>three backend engines we just mentioned can all run both on CPUs and GPUs using the low-level layers of the stack. For CPUs, a low-level library of tensor operations <a id="_idIndexMarker866"/>called <strong class="keyWord">Eigen</strong> is used. For GPUs, TensorFlow <a id="_idIndexMarker867"/>uses NVIDIA’s <strong class="keyWord">CUDA Deep Neural Network</strong> (<strong class="keyWord">cuDNN</strong>) library. It’s noteworthy to explain why GPUs are often preferred in ML. </p>
    <p class="normal">While CPUs are versatile and capable, GPUs are specifically designed to handle multiple operations concurrently, which is beneficial when processing large blocks of data, a common occurrence in ML tasks. This trait of GPUs, combined with their higher memory bandwidth, can significantly expedite ML computations, thereby making them a popular choice for such tasks.</p>
    <p class="normal">Next, let us explain the hyperparameters.</p>
    <h3 id="_idParaDest-318" class="heading-3">Defining hyperparameters</h3>
    <p class="normal">As <a id="_idIndexMarker868"/>discussed in <em class="chapterRef">Chapter 6</em>, <em class="italic">Unsupervised Machine Learning Algorithms</em>, a hyperparameter <a id="_idIndexMarker869"/>is a parameter whose value is chosen before the learning process starts. We start with common-sense values and then try to optimize them later. For neural networks, the important hyperparameters are these:</p>
    <ul>
      <li class="bulletList">The activation function</li>
      <li class="bulletList">The learning rate</li>
      <li class="bulletList">The number of hidden layers</li>
      <li class="bulletList">The number of neurons in each hidden layer</li>
    </ul>
    <p class="normal">Let’s look into how we can define a model using Keras.</p>
    <h3 id="_idParaDest-319" class="heading-3">Defining a Keras model</h3>
    <p class="normal">There are <a id="_idIndexMarker870"/>three steps involved in defining a complete Keras model:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Define the layers</li>
      <li class="numberedList">Define the learning process</li>
      <li class="numberedList">Test the model</li>
    </ol>
    <p class="normal">We can build a model using <code class="inlineCode">Keras</code> in two possible ways:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">The Functional API</strong>: This<a id="_idIndexMarker871"/> allows us to architect models for acyclic graphs of layers. More complex models can be created using the Functional API.</li>
      <li class="bulletList"><strong class="keyWord">The Sequential API</strong>: This <a id="_idIndexMarker872"/>allows us to architect models for a linear stack of layers. It is used for relatively simple models and is the usual choice for building models.</li>
    </ul>
    <p class="normal">First, we take a look at the Sequential way of defining a Keras model:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Let us start with importing the <code class="inlineCode">tensorflow</code> library:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
</code></pre>
      </li>
      <li class="numberedList">Then, load the MNIST dataset from Keras’ datasets:
        <pre class="programlisting code"><code class="hljs-code">mnist = tf.keras.datasets.mnist
</code></pre>
      </li>
      <li class="numberedList">Next, split the dataset into training and test sets:
        <pre class="programlisting code"><code class="hljs-code">(train_images, train_labels), (test_images, test_labels) = mnist.load_data()
</code></pre>
      </li>
      <li class="numberedList">We normalize the pixel values from a scale out of <code class="inlineCode">255</code> to a scale out of <code class="inlineCode">1:</code>
        <pre class="programlisting code"><code class="hljs-code">train_images, test_images = train_images / <span class="hljs-number">255.0</span>,                             test_images / <span class="hljs-number">255.0</span>
</code></pre>
      </li>
      <li class="numberedList">Next, we define the structure of the model:
        <pre class="programlisting code"><code class="hljs-code">model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>)),
    tf.keras.layers.Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">'relu'</span>),
    tf.keras.layers.Dropout(<span class="hljs-number">0.15</span>),
    tf.keras.layers.Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">'relu'</span>),
    tf.keras.layers.Dropout(<span class="hljs-number">0.15</span>),
    tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>),
])
</code></pre>
      </li>
    </ol>
    <p class="normal">This <a id="_idIndexMarker873"/>script is training a model to classify images from the <code class="inlineCode">MNIST</code> dataset, which is a set of 70,000 small images of digits handwritten by high school students and employees of the US Census Bureau.</p>
    <p class="normal">The model is defined using the <code class="inlineCode">Sequential</code> method in Keras, indicating that our model is organized as a linear stack of layers:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The first layer is a <code class="inlineCode">Flatten</code> layer, which transforms the format of the images from a two-dimensional array into a one-dimensional array.</li>
      <li class="numberedList">The next layer, a <code class="inlineCode">Dense</code> layer, is a fully connected neural layer with 128 nodes (or neurons). The <code class="inlineCode">relu</code> (ReLU) activation function is used here.</li>
      <li class="numberedList">The <code class="inlineCode">Dropout</code> layer randomly sets input units to <code class="inlineCode">0</code> with a frequency of rate at each step during training time, which helps prevent overfitting.</li>
      <li class="numberedList">Another <code class="inlineCode">Dense</code> layer is included; similar to the previous one, it’s also using the <code class="inlineCode">relu</code> activation function.</li>
      <li class="numberedList">We again apply a <code class="inlineCode">Dropout</code> layer with the same rate as before.</li>
      <li class="numberedList">The final layer is a 10-node softmax layer—this returns an array of 10 probability scores that sums to <code class="inlineCode">1</code>. Each node contains a score that indicates the probability that the current image belongs to one of the 10 digit classes.</li>
    </ol>
    <p class="normal">Note that, here, we<a id="_idIndexMarker874"/> have created three layers – the first two layers have the <code class="inlineCode">relu</code> activation function and the third layer has <code class="inlineCode">softmax</code> as the activation function.</p>
    <p class="normal">Now, let’s take a look at the Functional API way of defining a Keras model:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, let us import the <code class="inlineCode">tensorflow</code> library:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Ensure TensorFlow 2.x is being used</span>
%tensorflow_version <span class="hljs-number">2.</span>x
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> tensorflow.keras.datasets <span class="hljs-keyword">import</span> mnist
</code></pre>
      </li>
      <li class="numberedList">To work with the <code class="inlineCode">MNIST</code> dataset, we first load it into memory. The dataset is conveniently split into training and testing sets, with both images and corresponding labels:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Load MNIST dataset</span>
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()
<span class="hljs-comment"># Normalize the pixel values to be between 0 and 1</span>
train_images, test_images = train_images / <span class="hljs-number">255.0</span>, test_images / <span class="hljs-number">255.0</span>
</code></pre>
      </li>
      <li class="numberedList">The images in the <code class="inlineCode">MNIST</code> dataset are <code class="inlineCode">28x28</code> pixels in size. When setting up a neural network model using TensorFlow, you need to specify the shape of the input data, Here, we establish the input tensor for the model:
        <pre class="programlisting code"><code class="hljs-code">inputs = tf.keras.Input(shape=(<span class="hljs-number">28</span>,<span class="hljs-number">28</span>))
</code></pre>
      </li>
      <li class="numberedList">Next, the <code class="inlineCode">Flatten</code> layer is a simple data preprocessing step. It transforms the two-dimensional <code class="inlineCode">128x128</code> pixel input into a one-dimensional array by “flattening” it. This prepares the data for the following <code class="inlineCode">Dense</code> layer:
        <pre class="programlisting code"><code class="hljs-code">x = tf.keras.layers.Flatten()(inputs)
</code></pre>
      </li>
      <li class="numberedList">Then comes the first <code class="inlineCode">Dense</code> layer, also known as a fully connected layer, in which each input node (or neuron) is connected to each output node. The layer has 512 output nodes and uses the <code class="inlineCode">relu</code> activation function. ReLU is a popular choice of activation function that outputs the input directly if it is positive; otherwise, it outputs zero:
        <pre class="programlisting code"><code class="hljs-code">x = tf.keras.layers.Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'d1'</span>)(x)
</code></pre>
      </li>
      <li class="numberedList">The <code class="inlineCode">Dropout</code> layer randomly sets a fraction (0.2, or 20% in this case) of the input nodes to 0 at each update during training, which helps prevent overfitting:
        <pre class="programlisting code"><code class="hljs-code">x = tf.keras.layers.Dropout(<span class="hljs-number">0.2</span>)(x)
</code></pre>
      </li>
      <li class="numberedList">Finally, comes the output layer. It’s another <code class="inlineCode">Dense</code> layer with 10 output nodes (presumably for 10 classes). The <code class="inlineCode">softmax</code> activation function is applied, which outputs a probability distribution over the 10 classes, meaning it will output 10 values that sum to 1. Each value represents the model’s confidence that the input image corresponds to a particular class:
        <pre class="programlisting code"><code class="hljs-code">predictions = tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=tf.nn.softmax, name=<span class="hljs-string">'d2'</span>)(x)
model = tf.keras.Model(inputs=inputs, outputs=predictions)
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that we can define the same neural network using both the Sequential and Functional APIs. From the point of view of performance, it does not make any difference which approach you take to define the model.</p>
    <p class="normal">Let us convert the numerical <code class="inlineCode">train_labels</code> and <code class="inlineCode">test_labels</code> into one-hot encoded vectors. In the following code each label becomes a binary array of size 10 with a 1 at its respective digit’s index and 0s elsewhere:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># One-hot encode the labels</span>
train_labels_one_hot = tf.keras.utils.to_categorical(train_labels, <span class="hljs-number">10</span>)
test_labels_one_hot = tf.keras.utils.to_categorical(test_labels, <span class="hljs-number">10</span>)
</code></pre>
    <p class="normal">We should now define the learning process.</p>
    <p class="normal">In this step, we define three things:</p>
    <ul>
      <li class="bulletList">The optimizer</li>
      <li class="bulletList">The <code class="inlineCode">loss</code> function</li>
      <li class="bulletList">The metrics that will quantify the quality of the model:</li>
    </ul>
    <pre class="programlisting code"><code class="hljs-code">optimizer = tf.keras.optimizers.RMSprop()
loss = <span class="hljs-string">'categorical_crossentropy'</span>
metrics = [<span class="hljs-string">'accuracy'</span>]
model.<span class="hljs-built_in">compile</span>(optimizer=optimizer, loss=loss, metrics=metrics)
</code></pre>
    <p class="normal">Note <a id="_idIndexMarker875"/>that we use the <code class="inlineCode">model.compile</code> function to define the optimizer, loss function, and metrics.</p>
    <p class="normal">We will now train the model.</p>
    <p class="normal">Once the architecture is defined, it is time to train the model:</p>
    <pre class="programlisting code"><code class="hljs-code">history = model.fit(train_images, train_labels_one_hot, epochs=<span class="hljs-number">10</span>, validation_data=(test_images, test_labels_one_hot))
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker876"/>parameters such as <code class="inlineCode">batch_size</code> and <code class="inlineCode">epochs</code> are configurable parameters, making them hyperparameters.</p>
    <p class="normal">Next, let us look into how we can choose the sequential or functional model.</p>
    <h1 id="_idParaDest-320" class="heading-1">Choosing a sequential or functional model</h1>
    <p class="normal">When deciding <a id="_idIndexMarker877"/>between using a sequential or functional model <a id="_idIndexMarker878"/>to construct a neural network, the nature of your network’s architecture will guide your choice. The sequential model is suited to simple linear stacks of layers. It’s uncomplicated and straightforward to implement, making it an ideal choice for beginners or for simpler tasks. However, this model comes with a key limitation: each layer can be connected to precisely one input tensor and one output tensor.</p>
    <p class="normal">If the architecture of your network is more complex, such as having multiple inputs or outputs at any stage (input, output, or hidden layers), then the sequential model falls short. For such complex architectures, the functional model is more appropriate. This model provides a higher degree of flexibility, allowing for more complex network structures with multiple inputs and outputs at any layer. Let us now develop a deeper understanding of TensorFlow.</p>
    <h2 id="_idParaDest-321" class="heading-2">Understanding TensorFlow</h2>
    <p class="normal">TensorFlow is one <a id="_idIndexMarker879"/>of the most popular libraries for working with neural networks. In the preceding section, we saw how we can use it as the backend engine of Keras. It is an open-source, high-performance library that can actually be used for any numerical computation. </p>
    <p class="normal">If we look at the stack, we can see that we can write TensorFlow code in a high-level language such as Python or C++, which gets interpreted by the TensorFlow distributed execution engine. This makes it quite useful for and popular with developers.</p>
    <p class="normal">TensorFlow functions by <a id="_idIndexMarker880"/>using a <strong class="keyWord">directed graph</strong> (<strong class="keyWord">DG</strong>) to embody your computations. In this graph, nodes are mathematical operations, and the edges connecting these nodes signify the input and output of these operations. Moreover, these edges symbolize data arrays.</p>
    <p class="normal">Apart from serving as the backend engine for Keras, TensorFlow is broadly used in various scenarios. It <a id="_idIndexMarker881"/>can help in developing complex ML models, processing large datasets, and even deploying AI applications across different platforms. Whether you’re creating a recommendation system, image classification model, or natural language processing tool, TensorFlow can effectively cater to these tasks and more.</p>
    <h2 id="_idParaDest-322" class="heading-2">Presenting TensorFlow’s basic concepts</h2>
    <p class="normal">Let’s take a <a id="_idIndexMarker882"/>brief look at TensorFlow concepts such as scalars, vectors, and matrices. We know that a simple number, such as three or five, is called a <strong class="keyWord">scalar</strong> in<a id="_idIndexMarker883"/> traditional mathematics. Moreover, in physics, a <strong class="keyWord">vector</strong> is <a id="_idIndexMarker884"/>something with magnitude and direction. In terms of TensorFlow, we use a vector to mean one-dimensional arrays. Extending this concept, a two-dimensional array <a id="_idIndexMarker885"/>is a <strong class="keyWord">matrix</strong>. For a three-dimensional array, we use<a id="_idIndexMarker886"/> the term <strong class="keyWord">3D tensor</strong>. We use the<a id="_idIndexMarker887"/> term <strong class="keyWord">rank</strong> to capture the dimensionality of a data structure. As such, a <strong class="keyWord">scalar</strong> is a <strong class="keyWord">rank 0</strong> data structure, a <strong class="keyWord">vector</strong> is a <strong class="keyWord">rank 1</strong> data structure, and a <strong class="keyWord">matrix </strong>is a <strong class="keyWord">rank 2</strong> data structure. These multi-dimensional structures are known as <strong class="keyWord">tensors</strong> and<a id="_idIndexMarker888"/> are shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_14.png" alt="Shape, square  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.14: Multi-dimensional structures or tensors</p>
    <p class="normal">As we can see in the preceding diagram, the rank defines the dimensionality of a tensor.</p>
    <p class="normal">Let’s now look at another parameter, <code class="inlineCode">shape</code>. <code class="inlineCode">shape</code> is a tuple of integers specifying the length of an array in each dimension. </p>
    <p class="normal">The following diagram explains the concept of <code class="inlineCode">shape</code>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_15.png" alt="A picture containing graphical user interface  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.15: Concept of a shape</p>
    <p class="normal">Using <code class="inlineCode">shape</code> and ranks, we <a id="_idIndexMarker889"/>can specify the details of tensors.</p>
    <h2 id="_idParaDest-323" class="heading-2">Understanding Tensor mathematics</h2>
    <p class="normal">Let’s now <a id="_idIndexMarker890"/>look at different mathematical computations<a id="_idIndexMarker891"/> using tensors:</p>
    <ul>
      <li class="bulletList">Let’s define two scalars and try to add and multiply them using TensorFlow:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Define constant tensors"</span>)
a = tf.constant(<span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"</span><span class="hljs-string">a = %i"</span> % a)
b = tf.constant(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"b = %i"</span> % b)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Define constant tensors
a = 2
b = 3
</code></pre>
      </li>
      <li class="bulletList">We can add and multiply them and display the results:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Running operations, without tf.Session"</span>)
c = a + b
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a + b = %i"</span> % c)
d = a * b
<span class="hljs-built_in">print</span>(<span class="hljs-string">"</span><span class="hljs-string">a * b = %i"</span> % d)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">Running operations, without tf.Session
a + b = 5
a * b = 6
</code></pre>
      </li>
      <li class="bulletList">We <a id="_idIndexMarker892"/>can also create a new scalar tensor by adding the two tensors:
        <pre class="programlisting code"><code class="hljs-code">c = a + b
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a + b = %s"</span> % c)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">a + b = tf.Tensor(5, shape=(), dtype=int32)
</code></pre>
      </li>
      <li class="bulletList">We can<a id="_idIndexMarker893"/> also perform complex tensor functions:
        <pre class="programlisting code"><code class="hljs-code">d = a*b
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a * b = %s"</span> % d)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">a * b = tf.Tensor(6, shape=(), dtype=int32)
</code></pre>
      </li>
    </ul>
    <h1 id="_idParaDest-324" class="heading-1">Understanding the types of neural networks</h1>
    <p class="normal">Neural networks can <a id="_idIndexMarker894"/>be designed in various ways, depending on how the neurons are interconnected. In a dense, or fully connected, neural network, every single neuron in a given layer is linked to each neuron in the next layer. This means each input from the preceding layer is fed into every neuron of the subsequent layer, maximizing the flow of information.</p>
    <p class="normal">However, neural networks aren’t always fully connected. Some may have specific patterns of connections based on the problem they are designed to solve. For instance, in convolutional neural networks used for image processing, each neuron in a layer may only be connected to a small region of neurons in the previous layer. This mirrors the way neurons in the human visual cortex are organized and helps the network efficiently process visual information.</p>
    <p class="normal">Remember, the specific architecture of a neural network – how the neurons are interconnected – greatly impacts its functionality and performance.</p>
    <h2 id="_idParaDest-325" class="heading-2">Convolutional neural networks</h2>
    <p class="normal"><strong class="keyWord">Convolution neural networks</strong> (<strong class="keyWord">CNNs</strong>) are<a id="_idIndexMarker895"/> typically <a id="_idIndexMarker896"/>used to analyze multimedia data. In order to learn more about how a CNN is used to analyze image-based data, we need <a id="_idIndexMarker897"/>to have a grasp of the following processes:</p>
    <ul>
      <li class="bulletList">Convolution</li>
      <li class="bulletList">Pooling</li>
    </ul>
    <p class="normal">Let’s explore them one by one.</p>
    <h3 id="_idParaDest-326" class="heading-3">Convolution</h3>
    <p class="normal">The process of<a id="_idIndexMarker898"/> convolution emphasizes a pattern of interest in a particular image by processing it with another smaller image<a id="_idIndexMarker899"/> called a <strong class="keyWord">filter</strong> (also called a <strong class="keyWord">kernel</strong>). For <a id="_idIndexMarker900"/>example, if we want to find the edges of objects in an image, we can convolve the image with a particular filter to get them. Edge detection can help us in object detection, object classification, and other applications. So, the process of convolution is about finding characteristics and features in an image.</p>
    <p class="normal">The approach to finding patterns is based on finding patterns that can be reused on different data. The reusable patterns are called filters or kernels.</p>
    <h3 id="_idParaDest-327" class="heading-3">Pooling</h3>
    <p class="normal">An<a id="_idIndexMarker901"/> important part of processing multimedia data for the purpose of ML is downsampling it. Downsampling is the practice of <a id="_idIndexMarker902"/>reducing the resolution of your data, i.e., lessening the data’s complexity or dimensionality. Pooling <a id="_idIndexMarker903"/>offers <a id="_idIndexMarker904"/>two key advantages:</p>
    <ul>
      <li class="bulletList">By reducing the data’s complexity, we significantly decrease the training time for the model, enhancing computational efficiency.</li>
      <li class="bulletList">Pooling abstracts and aggregates unnecessary details in the multimedia data, making it more generalized. This, in turn, enhances the model’s ability to represent similar problems.</li>
    </ul>
    <p class="normal">Downsampling is performed as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_16.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.16: Downsampling</p>
    <p class="normal">In the <a id="_idIndexMarker905"/>downsampling process, we essentially <a id="_idIndexMarker906"/>condense a group of pixels into a single representative pixel. For instance, let’s say we condense a 2x2-pixel block into a single pixel, effectively downsampling the original data by a factor of four.</p>
    <p class="normal">The representative value for the new pixel can be chosen in various ways. One such method is “max pooling,” where we select the maximum value from the original pixel block to represent the new single pixel.</p>
    <p class="normal">On the other hand, if we chose to take the average of the pixel block’s values, the process would be <a id="_idIndexMarker907"/>termed “average pooling.”</p>
    <p class="normal">The choice <a id="_idIndexMarker908"/>between <a id="_idIndexMarker909"/>max pooling and average pooling often depends on<a id="_idIndexMarker910"/> the specific task at hand. Max pooling is particularly beneficial when we’re interested in preserving the most prominent features of the image, as it retains the maximum pixel value in a block, thus capturing the most standout or noticeable aspect within that section.</p>
    <p class="normal">In contrast, average pooling tends to be useful when we want to preserve the overall context and reduce noise, as it considers all values within a block and calculates their average, creating a more balanced representation that may be less sensitive to minor variations or noise in pixel values.</p>
    <h2 id="_idParaDest-328" class="heading-2">Generative Adversarial Networks</h2>
    <p class="normal">Generative Adversarial Networks, commonly referred to as GANs, represent a distinct class of <a id="_idIndexMarker911"/>neural networks capable of <a id="_idIndexMarker912"/>generating synthetic data. First introduced by Ian Goodfellow and his team in 2014, GANs have been hailed for their innovative approach to creating new data resembling the original training samples.</p>
    <p class="normal">One notable application of GANs is their ability to produce realistic images of people who don’t exist in reality, showcasing their remarkable capacity for detail generation. However, an even more crucial application lies in their potential to generate synthetic data, thereby <a id="_idIndexMarker913"/>augmenting existing training datasets, which can be extremely beneficial in scenarios where data availability is limited.</p>
    <p class="normal">Despite their <a id="_idIndexMarker914"/>potential, GANs are not without limitations. The training process of GANs can be quite challenging, often leading to issues such as mode collapse, where the generator starts producing limited varieties of samples. Additionally, the quality of the generated data is largely dependent on the quality and diversity of the input data. Poorly representative or biased data can result in less effective, potentially skewed synthetic data.</p>
    <p class="normal">In the upcoming section, we will see what transfer learning is.</p>
    <h1 id="_idParaDest-329" class="heading-1">Using transfer learning</h1>
    <p class="normal">Throughout<a id="_idIndexMarker915"/> the years, countless organizations, research entities, and contributors within the open-source community have meticulously built sophisticated models<a id="_idIndexMarker916"/> for general use cases. These models, often trained with vast amounts of data, have been optimized over years of hard work and are suited for various applications, such as:</p>
    <ul>
      <li class="bulletList">Detecting objects in videos or images</li>
      <li class="bulletList">Transcribing audio</li>
      <li class="bulletList">Analyzing sentiment in text</li>
    </ul>
    <p class="normal">When initiating the training of a new ML model, it’s worth questioning, rather than starting from a blank slate, whether we can modify an already established, pre-trained model to suit our needs. Put simply, could we leverage the learning of existing models to tailor a custom model that addresses our specific needs? Such an approach, known as transfer learning, can provide several advantages:</p>
    <ul>
      <li class="bulletList">It gives a head start to our model training.</li>
      <li class="bulletList">It potentially enhances the quality of our model by utilizing a pre-validated and reliable model. </li>
      <li class="bulletList">In cases where our problem lacks sufficient data, transfer learning using a pre-trained model can be of immense help.</li>
    </ul>
    <p class="normal">Consider the following practical<a id="_idIndexMarker917"/> examples where transfer learning would be beneficial:</p>
    <ul>
      <li class="bulletList">For training a robot, a neural network model could first be trained using a simulation game. In this controlled environment, we can create rare events that are difficult to replicate in the real world. Once trained, transfer learning can then be applied to adapt the model for real-world scenarios.</li>
      <li class="bulletList">Suppose we aim to build a model that distinguishes between Apple and Windows laptops in a video feed. Existing, open-source object detection models, known for their accuracy in classifying diverse objects in video feeds, could serve as an ideal starting point. Using transfer learning, we can first leverage these models to identify objects as laptops. Subsequently, we could refine our model further to differentiate between Apple and Windows laptops.</li>
    </ul>
    <p class="normal">In our next section, we will implement the principles discussed in this chapter to create a neural network for classifying fraudulent documents.</p>
    <p class="normal">As a visual example, consider a pre-trained model as a well-established tree with many branches (layers). Some branches are already ripe with fruits (trained to identify features). When applying transfer learning, we “freeze” these fruitful branches, preserving their established learning. We then allow new branches to grow and bear fruit, which is akin to training the additional layers to understand our specific features. This process of freezing some layers and training others encapsulates the essence of transfer learning.</p>
    <h1 id="_idParaDest-330" class="heading-1">Case study – using deep learning for fraud detection</h1>
    <p class="normal">Using <a id="_idIndexMarker918"/>ML techniques to identify fraudulent <a id="_idIndexMarker919"/>documents is an active and challenging field of research. Researchers are investigating to what extent the pattern recognition power of neural networks can be exploited for this purpose. Instead of manual attribute extractors, raw pixels can be used for several deep learning architectural structures.</p>
    <h2 id="_idParaDest-331" class="heading-2">Methodology</h2>
    <p class="normal">The <a id="_idIndexMarker920"/>technique presented in this section uses a type of neural network architecture called <strong class="keyWord">Siamese neural networks</strong>, which<a id="_idIndexMarker921"/> features two branches that share identical<a id="_idIndexMarker922"/> architectures and parameters. </p>
    <p class="normal">The use of Siamese neural networks to flag fraudulent documents is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_08_17.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.17: Siamese neural networks</p>
    <p class="normal">When a <a id="_idIndexMarker923"/>particular document needs to be verified for authenticity, we first classify the document based on its layout and type, and then we compare it against its expected template and pattern. If it deviates beyond a certain threshold, it is flagged as a fake document; otherwise, it is considered an authentic or true document. For critical use cases, we can add a manual process for borderline cases where the algorithm conclusively classifies a document as authentic or fake.</p>
    <p class="normal">To compare a document against its expected template, we use two identical CNNs in our Siamese architecture. CNNs have the advantage of learning optimal shift-invariant local feature detectors and can build representations that are robust to geometric distortions of the input image. This is well suited to our problem since we aim to pass authentic and test documents through a single network, and then compare their outcomes for similarity. To achieve this goal, we implement the following steps.</p>
    <p class="normal">Let’s assume that we want to test a document. For each class of document, we perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Get the stored image of the authentic document. We call it the <strong class="keyWord">true document</strong>. The test document <a id="_idIndexMarker924"/>should look like the true document.</li>
      <li class="numberedList">The true <a id="_idIndexMarker925"/>document is passed through the neural network layers to create a feature vector, which is the mathematical representation of the patterns of the true document. We call it <strong class="keyWord">Feature Vector 1</strong>, as<a id="_idIndexMarker926"/> shown in the preceding diagram.</li>
      <li class="numberedList">The document that needs to be tested is <a id="_idIndexMarker927"/>called the <strong class="keyWord">test document</strong>. We pass this document through a neural network similar to the one that was used to create the feature vector for the true document. The feature vector of the test <a id="_idIndexMarker928"/>document is called <strong class="keyWord">Feature Vector 2</strong>.</li>
      <li class="numberedList">We use the Euclidean distance between <strong class="keyWord">Feature Vector 1</strong> and <strong class="keyWord">Feature Vector 2</strong> to calculate the similarity score between the true document and the test document. This similarity score is called the <strong class="keyWord">Measure Of Similarity</strong> (<strong class="keyWord">MOS</strong>). The <a id="_idIndexMarker929"/>MOS is a number between 0 and 1. A higher number represents a lower distance between the documents and a greater likelihood that the documents are similar.</li>
      <li class="numberedList">If the similarity score calculated by the neural network is below a pre-defined threshold, we flag the document as fraudulent.</li>
    </ol>
    <p class="normal">Let’s see <a id="_idIndexMarker930"/>how we can implement Siamese neural networks using Python.</p>
    <p class="normal">To illustrate how we can implement Siamese neural networks using Python, we’ll break down the process into simpler, more manageable blocks. This approach will help us follow the PEP8 style guide and keep our code readable and maintainable:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, let’s import the Python packages that are required:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
</code></pre>
      </li>
      <li class="numberedList">Next, we define the network model that will process each branch of the Siamese network. Note that we’ve incorporated a dropout rate of <code class="inlineCode">0.15</code> to mitigate overfitting:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">createTemplate</span>():
    <span class="hljs-keyword">return</span> tf.keras.models.Sequential([
        tf.keras.layers.Flatten(),
        tf.keras.layers.Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">'relu'</span>),
        tf.keras.layers.Dropout(<span class="hljs-number">0.15</span>),
        tf.keras.layers.Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">'relu'</span>),
        tf.keras.layers.Dropout(<span class="hljs-number">0.15</span>),
        tf.keras.layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>), 
    ])
</code></pre>
      </li>
      <li class="numberedList">For our <a id="_idIndexMarker931"/>Siamese networks, we’ll use MNIST images. These images are excellent for testing the effectiveness of our Siamese network. We prepare the data such that each sample will contain two images and a binary similarity flag indicating whether they belong to the same class:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">prepareData</span>(<span class="hljs-params">inputs: np.ndarray, labels: np.ndarray</span>):
    classesNumbers = <span class="hljs-number">10</span>
    digitalIdx = [np.where(labels == i)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(classesNumbers)]
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">prepareData</code> function, we ensure an equal number of samples across all digits. We first create an index of where in our dataset each digit appears, using the <code class="inlineCode">np.where</code> function.
    <p class="normal">Then, we prepare our pairs of images and assign labels:</p>
    <pre class="programlisting code"><code class="hljs-code">    pairs = <span class="hljs-built_in">list</span>()
    labels = <span class="hljs-built_in">list</span>()
    n = <span class="hljs-built_in">min</span>([<span class="hljs-built_in">len</span>(digitalIdx[d]) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(classesNumbers)]) - <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(classesNumbers):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            z1, z2 = digitalIdx[d][i], digitalIdx[d][i + <span class="hljs-number">1</span>]
            pairs += [[inputs[z1], inputs[z2]]]
            inc = random.randrange(<span class="hljs-number">1</span>, classesNumbers)
            dn = (d + inc) % classesNumbers
            z1, z2 = digitalIdx[d][i], digitalIdx[dn][i]
            pairs += [[inputs[z1], inputs[z2]]]
            labels += [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] 
    <span class="hljs-keyword">return</span> np.array(pairs), np.array(labels, dtype=np.float32)
</code></pre></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Subsequently, we’ll<a id="_idIndexMarker932"/> prepare our training and testing datasets:
        <pre class="programlisting code"><code class="hljs-code">input_a = tf.keras.layers.Input(shape=input_shape)
encoder1 = base_network(input_a)
input_b = tf.keras.layers.Input(shape=input_shape)
encoder2 = base_network(input_b)
</code></pre>
      </li>
      <li class="numberedList">Lastly, we will implement the MOS, which quantifies the distance between two documents that we want to compare:
        <pre class="programlisting code"><code class="hljs-code">distance = tf.keras.layers.Lambda( 
    <span class="hljs-keyword">lambda</span> embeddings: tf.keras.backend.<span class="hljs-built_in">abs</span>(
        embeddings[<span class="hljs-number">0</span>] - embeddings[<span class="hljs-number">1</span>]
    )
) ([encoder1, encoder2])
measureOfSimilarity = tf.keras.layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'</span><span class="hljs-string">sigmoid'</span>) (distance)
</code></pre>
      </li>
    </ol>
    <p class="normal">Now, let’s train<a id="_idIndexMarker933"/> the model. We <a id="_idIndexMarker934"/>will use 10 epochs to train this model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Build the model</span>
model = tf.keras.models.Model([input_a, input_b], measureOfSimilarity)
<span class="hljs-comment"># Train</span>
model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">'binary_crossentropy'</span>,optimizer=tf.keras.optimizers.Adam(),metrics=[<span class="hljs-string">'accuracy'</span>])
model.fit([train_pairs[:, <span class="hljs-number">0</span>], train_pairs[:, <span class="hljs-number">1</span>]], tr_labels, 
          batch_size=<span class="hljs-number">128</span>,epochs=<span class="hljs-number">10</span>,validation_data=([test_pairs[:, <span class="hljs-number">0</span>], test_pairs[:, <span class="hljs-number">1</span>]], test_labels))
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Epoch 1/10
847/847 [==============================] - 6s 7ms/step - loss: 0.3459 - accuracy: 0.8500 - val_loss: 0.2652 - val_accuracy: 0.9105
Epoch 2/10
847/847 [==============================] - 6s 7ms/step - loss: 0.1773 - accuracy: 0.9337 - val_loss: 0.1685 - val_accuracy: 0.9508
Epoch 3/10
847/847 [==============================] - 6s 7ms/step - loss: 0.1215 - accuracy: 0.9563 - val_loss: 0.1301 - val_accuracy: 0.9610
Epoch 4/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0956 - accuracy: 0.9665 - val_loss: 0.1087 - val_accuracy: 0.9685
Epoch 5/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0790 - accuracy: 0.9724 - val_loss: 0.1104 - val_accuracy: 0.9669
Epoch 6/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0649 - accuracy: 0.9770 - val_loss: 0.0949 - val_accuracy: 0.9715
Epoch 7/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0568 - accuracy: 0.9803 - val_loss: 0.0895 - val_accuracy: 0.9722
Epoch 8/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0513 - accuracy: 0.9823 - val_loss: 0.0807 - val_accuracy: 0.9770
Epoch 9/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0439 - accuracy: 0.9847 - val_loss: 0.0916 - val_accuracy: 0.9737
Epoch 10/10
847/847 [==============================] - 6s 7ms/step - loss: 0.0417 - accuracy: 0.9853 - val_loss: 0.0835 - val_accuracy: 0.9749
&lt;tensorflow.python.keras.callbacks.History at 0x7ff1218297b8&gt;
</code></pre>
    <p class="normal">Note <a id="_idIndexMarker935"/>that we<a id="_idIndexMarker936"/> reached an accuracy of <code class="inlineCode">97.49%</code> using <code class="inlineCode">10</code> epochs. Increasing the number of epochs will further improve the level of accuracy.</p>
    <h1 id="_idParaDest-332" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we journeyed through the evolution of neural networks, examining different types, key components like activation functions, and the significant gradient descent algorithm. We touched upon the concept of transfer learning and its practical application in identifying fraudulent documents.</p>
    <p class="normal">As we proceed to the next chapter, we’ll delve into natural language processing, exploring areas such as word embedding and recurrent networks. We will also learn how to implement sentiment analysis. The captivating realm of neural networks continues to unfold.</p>
    <h1 id="_idParaDest-333" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>