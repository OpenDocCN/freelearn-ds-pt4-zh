- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best recommendation I can have is my own talents, and the fruits of my own
    labors, and what others will not do for me, I will try and do for myself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —18–19th-century scientist John James Audubon
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recommendation engines harness the power of available data on user preferences
    and item details to offer tailored suggestions. At their core, these engines aim
    to identify commonalities among various items and understand the dynamics of user-item
    interactions. Rather than just focusing on products, recommendation systems cast
    a wider net, considering any type of item – be it a song, a news article, or a
    product – and tailoring their suggestions accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by presenting the basics of recommendation engines. Then,
    it discusses various types of recommendation engines. In the subsequent sections
    of this chapter, we’ll explore the inner workings of recommendation systems. These
    systems are adept at suggesting tailored items or products to users, but they’re
    not without their challenges. We’ll discuss both their strengths and the limitations
    they present. Finally, we will learn to use recommendation engines to solve a
    real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of recommendation engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different categories of recommendation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing the constraints of recommendation approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Areas of practical application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practical example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand how to use recommendation
    engines to suggest various items based on some preference criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking into the background concepts of recommendation engines.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems are powerful tools, initially crafted by researchers
    but now widely adopted in commercial settings, that predict items a user might
    find appealing. Their ability to deliver personalized item suggestions makes them
    an invaluable asset, especially in the digital shopping landscape.
  prefs: []
  type: TYPE_NORMAL
- en: When used in e-commerce applications, recommendation engines use sophisticated
    algorithms to improve the shopping experience for shoppers, allowing service providers
    to customize products according to the preferences of the users.
  prefs: []
  type: TYPE_NORMAL
- en: A classic example of the significance of these systems is the Netflix Prize
    challenge in 2009\. Netflix, aiming to refine its recommendation algorithm, offered
    a whopping $1 million prize for any team that could enhance its current recommendation
    system, Cinematch, by 10%. This challenge saw participation from researchers globally,
    with BellKor’s Pragmatic Chaos team emerging as the winner. Their achievement
    underlines the essential role and potential of recommendation systems in the commercial
    domain. More about this fascinating challenge can be explored in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Types of recommendation engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can broadly classify recommendation engines into three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-based recommendation engines**: They focus on item attributes, matching
    the features of one product to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborative filtering engines**: They predict preferences based on user
    behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid recommendation engines**: A blend of both worlds, these engines integrate
    the strengths of content-based and collaborative filtering methods to refine their
    suggestions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having established the categories, let’s start by diving into the details of
    these three types of recommendation engines one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: Content-based recommendation engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Content-based recommendation engines** operate on a straightforward principle:
    they recommend items that are like ones the user has previously engaged with.
    The crux of these systems lies in accurately measuring the likeness between items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, imagine the scenario depicted in *Figure 12.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, schematic  Description automatically generated](img/B18046_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Content-based recommendation system'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that *User1* has read *Doc1*. Due to the similarities between the
    documents, we could then recommend *Doc2* to *User1*.
  prefs: []
  type: TYPE_NORMAL
- en: This method would only be effective if we could identify and quantify these
    similarities. Thus, identifying similarities between items is pivotal for recommendations.
    Let’s delve into how to quantify these similarities.
  prefs: []
  type: TYPE_NORMAL
- en: Determining similarities in unstructured documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way of determining the similarities between different documents is by using
    the co-occurrence matrix, which works on the premise that items frequently bought
    together likely share similarities or belong to complementary categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, someone buying a razor might also need shaving gel. Let’s decode
    this with data from four users’ buying habits:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Razor** | **Apple** | **Shaving cream** | **Bike** | **Hummus** |'
  prefs: []
  type: TYPE_TB
- en: '| **Mike** | 1 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Taylor** | 1 | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Elena** | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Amine** | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'To construct the co-occurrence matrix, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an *NxN* matrix, where *N* is the number of items. This matrix will
    store the co-occurrence counts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each user in the user-item matrix, update the co-occurrence matrix by incrementing
    the cell values for pairs of items that the user has interacted with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final matrix showcases the associations between items based on user interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The occurrence matrix of the above table will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Razor** | **Apple** | **Shaving cream** | **Bike** | **Hummus** |'
  prefs: []
  type: TYPE_TB
- en: '| **Razor** | - | 1 | 3 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **Apple** | 1 | - | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Shaving cream** | 3 | 1 | - | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| **Bike** | 1 | 0 | 1 | - | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Hummus** | 2 | 1 | 2 | 1 | - |'
  prefs: []
  type: TYPE_TB
- en: This matrix, in essence, showcases the likelihood of two items being bought
    together. It’s a valuable tool for recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering recommendation engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recommendations from **collaborative filtering** are based on the analysis
    of the historical buying patterns of users. The basic assumption is that if two
    users show interest in mostly the same items, we can classify both users as similar.
    In other words, we can assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the overlap in the buying history of two users exceeds a threshold, we can
    classify them as similar users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the history of similar users, the items that do not overlap in the
    buying history become the basis of future recommendations through collaborative
    filtering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let’s look at a specific example. We have two users, *User1* and
    *User2*, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a couple of people  Description automatically generated](img/B18046_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Collaborative filtering recommendation engine'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Both *User1* and *User2* have shown interest in exactly the same documents,
    *Doc1* and *Doc2*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on their similar historical patterns, we can classify both of them as
    similar users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *User1* now reads *Doc3*, then we can suggest *Doc3* to *User2* as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This strategy of suggesting items to users based on their history will not always
    work. Let us look into the issues related to collaborative filtering in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Issues related to collaborative filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three potential issues related to collaborative filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: Inaccuracies due to a limited sample size
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A vulnerability to **isolated analysis**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Over-reliance on history
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us look into the limitations in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Inaccuracies due to a limited sample size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The accuracy and efficacy of a collaborative filtering system also hinge on
    the sample size. For instance, if only three documents are analyzed, the potential
    for accurate recommendations is limited.
  prefs: []
  type: TYPE_NORMAL
- en: However, if a system has data on hundreds or thousands of documents and interactions,
    its predictive capabilities become significantly more reliable. It’s akin to the
    difference between making predictions based on a handful of data points versus
    having a comprehensive dataset to draw insights from.
  prefs: []
  type: TYPE_NORMAL
- en: Even when equipped with vast amounts of data, collaborative filtering isn’t
    foolproof. The reason is that it relies purely on the historical interactions
    between users and items, without accounting for any external factors.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerable to isolated analysis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Collaborative filtering zeroes in on patterns formed by user behaviors and their
    interactions with items. This means it often misses out on external influences
    that might dictate a user’s choice. For instance, a user might opt for a particular
    book not because of personal interest but because of academic needs or a friend’s
    recommendation. The collaborative filtering model won’t recognize these nuances.
  prefs: []
  type: TYPE_NORMAL
- en: Over-reliance on history
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the system hinges on historical data, it can sometimes end up reinforcing
    stereotypes or not catching up with a user’s evolving tastes. Imagine if a user
    once had a phase where they loved sci-fi movies but has since transitioned to
    enjoying romantic films. If they watched numerous sci-fi movies in the past, the
    system might still primarily recommend them, missing out on their current preferences.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, while collaborative filtering is powerful, especially with more
    data, it’s essential to understand its inherent limitations stemming from its
    isolated method of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at hybrid recommendation engines.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid recommendation engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have discussed content-based and collaborative-filtering-based recommendation
    engines. Both types of recommendation engines can be combined to create a **hybrid
    recommendation engine**. To do so, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a similarity matrix of the items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate preference matrices of the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate recommendations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look into these steps one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a similarity matrix of the items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In hybrid recommendations, we start by creating a similarity matrix of items
    using content-based recommendations. This can be done by using the co-occurrence
    matrix or any distance measure to quantify the similarities between items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we currently have five items. Using content-based recommendations,
    we generate a matrix that captures the similarities between items, as shown in
    *Figure 12.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calendar  Description automatically generated with low confidence](img/B18046_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Similarity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can combine this similarity matrix with a preference matrix
    to generate recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Generating reference vectors of the users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Based on the history of each of the users of the system, we will produce a preference
    vector that captures those users’ interests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we want to generate recommendations for an online store named
    *KentStreetOnline*, which sells 100 unique items. *KentStreetOnline* is popular
    and has 1 million active subscribers. It is important to note that we need to
    generate only one similarity matrix with dimensions of 100 by 100\. We also need
    to generate a preference vector for each of the users; this means that we need
    to generate 1 million preference vectors for each of the 1 million users.
  prefs: []
  type: TYPE_NORMAL
- en: Each entry of the performance vector represents a preference for an item. The
    value of the first row means that the preference weight for *Item 1* is *4*. The
    preference score isn’t a direct reflection of purchase counts. Instead, it’s a
    weighted metric, potentially considering factors like browsing history, past purchases,
    item ratings, and more.
  prefs: []
  type: TYPE_NORMAL
- en: A score of *4* could represent a combination of interest and past interactions
    with *Item 1*, suggesting a strong likelihood that the user would appreciate that
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is graphically shown in *Figure 12.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18046_12_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: User preference matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look into how we can generate recommendations based on the similarity
    matrix, *S*, and the user preference matrix, *U*.
  prefs: []
  type: TYPE_NORMAL
- en: Generating recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make recommendations, we can multiply the matrices. Users are more likely
    to be interested in an item that co-occurs frequently with an item that they gave
    a high rating to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Matrix*[*S*] × *Matrix*[*U*] = *Matrix*[*R*]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This calculation is shown graphically in *Figure 12.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18046_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Generation of a recommendation matrix'
  prefs: []
  type: TYPE_NORMAL
- en: A separate resultant matrix is generated for each of the users. The numbers
    in the recommendation matrix, *Matrix[R]*, quantify the predicted interest of
    a user in each of the items. For example, in the resultant matrix, the fourth
    item has the highest number, 58\. So this item is highly recommended for this
    particular user.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the recommendation system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recommendation systems aren’t static; they thrive on constant refinement. How
    does this evolution occur? By juxtaposing the recommended items (predictions)
    with the user’s actual choices. By analyzing discrepancies, the system identifies
    areas to improve. Over time, by recalibrating based on user feedback and observed
    behaviors, the system enhances its recommendation accuracy, ensuring users always
    receive the most relevant suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look into the limitations of different recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the limitations of recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation engines use predictive algorithms to suggest recommendations
    to a bunch of users. It is a powerful technology, but we should be aware of its
    limitations. Let’s look into the various limitations of recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: The cold start problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the core of collaborative filtering lies a crucial dependency: historical
    user data. Without a track record of user preferences, generating accurate suggestions
    becomes a challenge. For a new entrant into the system, the absence of data means
    our algorithms largely operate on assumptive grounds, which can lead to imprecise
    recommendations. Similarly, in content-based recommendation systems, fresh items
    might lack comprehensive details, making the suggestion process less reliable.
    This data dependency – the need for established user and item data to produce
    sound recommendations – is what’s termed **the cold start problem**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several strategies to counterbalance the cold start challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hybrid systems**: Merging collaborative and content-based filtering can offset
    the limitations of one system using the strengths of the other.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Knowledge-based recommendations**: If historical data is scant, leaning on
    explicit knowledge about users and items can help bridge the gap.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Onboarding questionnaires**: For new users, a brief questionnaire about preferences
    can seed the system with initial data, guiding early recommendations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding and countering these challenges ensures that recommendation systems
    remain an effective and reliable tool in user engagement strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While content-based recommendation systems can function without metadata, incorporating
    such details can enhance their precision. It’s important to note that metadata
    isn’t confined to just textual descriptions. In our multifaceted digital ecosystem,
    items span various media types like images, audio, or movies. For such media,
    the “content” can be derived from their inherent properties. For instance, image-based
    metadata might be pulled from visual patterns; audio metadata from elements like
    waveforms or spectral features; and for movies, aspects like genre, cast, or scene
    structure can be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating these diverse content dimensions allows recommendation systems to
    be more adaptable, offering refined suggestions across a wide range of items.
  prefs: []
  type: TYPE_NORMAL
- en: The data sparsity problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Across an enormous number of items, a user will have rated only a few items,
    resulting in a very sparse user/item rating matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon has around a billion users and a billion items. Amazon’s recommendation
    engine is said to have the sparsest data for any recommendation engine in the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: To tackle such sparsity, various techniques are deployed. **Matrix factorization
    methods**, for example, can predict potential ratings in these sparse areas, providing
    a more complete user-item interaction landscape. Additionally, **hybrid recommendation
    systems**, which combine elements of content-based and collaborative filtering,
    can generate meaningful recommendations even when user-item interactions are limited.
    By integrating these and other approaches, recommendation systems can effectively
    navigate and mitigate the challenges posed by sparse datasets.
  prefs: []
  type: TYPE_NORMAL
- en: The double-edged sword of social influence in recommendation systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recommendation systems can be significantly influenced by social dynamics. Indeed,
    our social circles often have a marked impact on our preferences and choices.
    For instance, friends tend to make similar purchases and rate products or services
    in similar ways.
  prefs: []
  type: TYPE_NORMAL
- en: On the positive side, leveraging social connections can boost recommendation
    relevance. If a system observes that individuals within a particular social group
    enjoyed a certain movie or product, it might make sense to recommend that same
    item to other members of the group. This could lead to increased user satisfaction
    and, potentially, higher conversion rates.
  prefs: []
  type: TYPE_NORMAL
- en: However, there’s a downside. Relying too heavily on social influence can introduce
    bias into the recommendations. It might inadvertently create echo chambers where
    users are only exposed to items their immediate social circle appreciate, limiting
    diversity and potentially missing out on products or services that could be more
    individually suited. Furthermore, this could lead to a self-reinforcing feedback
    loop, where the same items keep getting recommended, overshadowing other potentially
    valuable items.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, while social influence is a powerful tool in shaping user preferences,
    it’s essential for recommendation systems to balance it with individual user behavior
    and broader trends to ensure a diverse and personalized user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Areas of practical applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems play a pivotal role in our daily digital interactions.
    To truly understand their significance, let’s delve into their applications across
    various industries.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the comprehensive details provided about Netflix’s use of data science
    and its recommendation system, let’s look at the restructured statement addressing
    the points mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix’s mastery of data-driven recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Netflix, a leader in streaming, has harnessed data analytics to fine-tune content
    recommendations, with 800 engineers in Silicon Valley advancing this effort. Their
    emphasis on data-driven strategies is evident in the Netflix Prize challenge.
    The winning team, BellKor’s Pragmatic Chaos, used 107 diverse algorithms, from
    matrix factorization to restricted Boltzman machines, investing 2,000 hours in
    its development.
  prefs: []
  type: TYPE_NORMAL
- en: The results were a significant 10.06% improvement in their “Cinematch” system.
    This translated to more streaming hours, fewer subscription cancellations, and
    substantial savings for Netflix. Interestingly, recommendations now influence
    about 75% of what users watch. Töscher et al. (2009) highlighted a curious “one-day
    effect” suggesting shared accounts or user mood variations.
  prefs: []
  type: TYPE_NORMAL
- en: While the challenge showcased Netflix’s commitment to data, it also hinted at
    the potential of ensemble techniques in striking a balance between recommendation
    diversity and accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Today, elements of the winning model remain core to Netflix’s recommendation
    engine, but with ever-evolving technology, there’s potential for further refinements,
    like integrating reinforcement algorithms and improved A/B testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the source for the Netflix statistic: [https://towardsdatascience.com/netflix-recommender-system-a-big-data-case-study-19cfa6d56ff5](https://towardsdatascience.com/netflix-recommender-system-a-big-data-case-study-19cfa6d56ff5).'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of Amazon’s recommendation system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early 2000s, Amazon transformed its recommendation engine by shifting
    from user-based collaborative filtering to item-to-item collaborative filtering,
    as detailed in a seminal 2003 paper by Linden, Smith, and York. The strategy switched
    from recommending products based on similar users to suggesting products linked
    to individual product purchases.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of this “relatedness” was deciphered from observed customer purchasing
    patterns. If Harry Potter book buyers often bought a Harry Potter bookmark, the
    items were considered related. Yet, the initial system had flaws. For high-volume
    buyers, the recommendations weren’t as refined, leading Smith and his team to
    make necessary algorithmic tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward a few years – during a 2019 re:MARS conference, Amazon highlighted
    its significant advancements in movie recommendations for Prime Video customers,
    achieving a twofold improvement.
  prefs: []
  type: TYPE_NORMAL
- en: The technique utilized for this was inspired by a matrix completion problem.
    This method involves representing Prime Video customers and movies in a grid and
    predicting the probability of a customer watching a particular movie. Amazon then
    applied deep neural networks to this matrix problem, leading to more accurate
    and personalized movie recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: The future holds even more potential. With continued research and advancements,
    the Amazon team aims to further refine and revolutionize their recommendation
    algorithms, always striving to enhance the customer experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the Amazon statistic here: [https://www.amazon.science/the-history-of-amazons-recommendation-algorithm](https://www.amazon.science/the-history-of-amazons-recommendation-algorithm).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try to use a recommendation engine to solve a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: Practical example – creating a recommendation engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build a recommendation engine that can recommend movies to a bunch of
    users. We will use data put together by the GroupLens Research group at the University
    of Minnesota.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Setting up the framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first task is to ensure we have the right tools for the job. In the world
    of Python, this means importing necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '2\. Data loading: ingesting reviews and titles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s import the `df_reviews` and `df_movie_titles` datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `reviews.csv` dataset encompasses a rich collection of user reviews. Each
    entry features a user’s ID, a movie ID they’ve reviewed, their rating, and a timestamp
    of when the review was made.
  prefs: []
  type: TYPE_NORMAL
- en: '![A table with numbers and text  Description automatically generated](img/B18046_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Contents of the reviews.csv dataset'
  prefs: []
  type: TYPE_NORMAL
- en: The `movies.csv` dataset is a compilation of movie titles and their details.
    Each record usually contains a unique movie ID, the movie’s title, and its associated
    genre or genres.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18046_12_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Contents of the movies.csv dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Merging data: crafting a comprehensive view'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a holistic perspective, we need to merge these datasets. The `''movieId''`
    serves as our bridge between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The merged datasets should contain the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A table with numbers and words  Description automatically generated](img/B18046_12_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Merged movie data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief on each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userId`: A unique identifier for each user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movieId`: A unique identifier for each movie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating`: Represents the rating assigned by a user to a movie, ranging from
    1 to 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timestamp`: Denotes when a particular movie was rated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The movie’s title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`genres`: The genre(s) associated with the movie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4\. Descriptive analysis: gleaning insights from ratings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive into the heart of our data: the ratings. A good starting point is
    to compute the average rating for each movie. Alongside, understanding the number
    of users who rated a movie can provide insights into its popularity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mean` rating for each movie should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18046_12_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Calculating the mean rating'
  prefs: []
  type: TYPE_NORMAL
- en: With these aggregated metrics, we can discern popular movies with high average
    ratings, potential blockbusters with numerous ratings, or hidden gems that might
    have fewer reviews but high averages.
  prefs: []
  type: TYPE_NORMAL
- en: This foundation will pave the way for the subsequent steps, where we’ll delve
    into building the actual recommendation engine. As we progress, our understanding
    of user preferences will refine, enabling us to suggest movies that resonate with
    individual tastes.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Structuring for recommendations: crafting the matrix'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next logical step is to convert our dataset into a structure optimized
    for recommendations. Visualize this structure as a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: Rows represent our users (indexed by `userId`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columns signify movie titles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells within the matrix are populated with ratings, revealing what a user thought
    of a specific movie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `pivot_table` function in Pandas is a versatile tool that helps reshape
    or pivot data in a DataFrame to provide a summarized view. The function essentially
    creates a new derived table out of the original one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code will generate a very sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Putting the engine to test: recommending movies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see our engine in action. Suppose a user has just watched *Avatar* (2009).
    How can we find other movies they might enjoy?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to isolate all users who’ve rated *Avatar* (2009):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**userId**: This represents the unique identifier for each user in our dataset.
    The `userId` list contains `10`, `15`, `18`, `21`, and `22` – the first five users
    in our data snapshot who have rated *Avatar* (2009).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ratings**: The numbers adjacent to each `userId` (`2.5`, `3.0`, `4.0`, `4.0`,
    and `3.5`) represent the ratings these users assigned to *Avatar* (2009). The
    ratings range between `1` and `5`, where a higher value indicates a more favorable
    opinion about the movie. For example, *User 10* rated *Avatar* (2009) a `2.5`,
    suggesting they found the movie average or perhaps slightly below their expectations,
    and *User 22* rated it a `3.5`, expressing a slightly above-average appreciation
    for the movie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s build a recommendation engine that can recommend movies to a bunch of
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Finding movies correlating with Avatar (2009)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By determining how other movies correlate in rating patterns with *Avatar* (2009),
    we can suggest movies that might appeal to fans of *Avatar*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To present our findings neatly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 10,000 BC (2008) -0.075431 Understanding correlation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A higher correlation (close to 1) means a movie’s rating pattern is similar
    to *Avatar* (2009). A negative value indicates the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s crucial to approach the recommendations with caution. For instance,
    **batteries not included* (1987) emerged as a top recommendation for *Avatar*
    (2009) fans, which might not seem accurate. This could be due to the limitations
    of relying solely on user ratings without considering other factors, like genres
    or movie themes. Adjustments and refinements would be needed for a more precise
    recommendation system.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting table showcases movies that correlate in terms of user rating
    behavior with *Avatar*. The table produced at the end of our analysis lists movies
    in terms of their correlation to *Avatar* based on user ratings. But what does
    this mean in simpler terms?
  prefs: []
  type: TYPE_NORMAL
- en: 'Correlation, in this context, refers to a statistical measure that explains
    how one set of data moves in relation to another set of data. Specifically, we
    used the Pearson correlation coefficient, which ranges from -1 to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**: Perfect positive correlation. This means if *Avatar* received a high
    rating from a user, the other movie also received a high rating from the same
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-1**: Perfect negative correlation. If *Avatar* got a high rating from a
    user, the other movie got a low rating from the same user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0**: No correlation. The ratings of *Avatar* and the other movie are independent
    of each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our movie recommendation context, movies with a higher positive correlation
    value (closer to 1) to *Avatar* are deemed to be more suitable recommendations
    for users who liked *Avatar*. This is because these movies have shown a pattern
    of receiving ratings similar to *Avatar* from the users.
  prefs: []
  type: TYPE_NORMAL
- en: By inspecting the table, you can identify which movies have a rating behavior
    akin to *Avatar* and, thus, can be potential recommendations for its fans.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can use these movies as recommendations for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing and evaluation are critical. One way to evaluate our model is by using
    methods like train-test split, where a portion of data is set aside for testing.
    The model’s recommendations for the test set are then compared to actual user
    ratings. Metrics like **Mean Absolute Error** (**MAE**) or **Root Mean Square
    Error** (**RMSE**) can quantify the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retraining over time: incorporating user feedback'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: User preferences evolve. Retraining the recommendation model periodically with
    fresh data ensures its recommendations remain relevant. Incorporating a feedback
    loop where users can rate or review recommendations further refines the model’s
    accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about recommendation engines. We studied the selection
    of the right recommendation engine based on the problem that we are trying to
    solve. We also looked into how we can prepare data for recommendation engines
    to create a similarity matrix. We also learned how recommendation engines can
    be used to solve practical problems, such as suggesting movies to users based
    on their past patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the algorithms that are used to understand
    and process data.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1955211820597889031.png)'
  prefs: []
  type: TYPE_IMG
