<html><head></head><body>
  <div id="_idContainer459" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-472" class="chapterTitle">Algorithmic Strategies for Data Handling</h1>
    <blockquote class="packt_quote">
      <p class="quote"> Data is the New Oil of the Digital Economy.</p>
      <p class="cite">—Wired Magazine</p>
    </blockquote>
    <p class="normal">In this data-driven era, the ability to extract meaningful information from large data sets is fundamentally shaping our decision-making processes. The algorithms we delve into throughout this book lean heavily on this reliance on data. Therefore, it becomes important to develop tools, methodologies, and strategic plans aimed at creating robust and efficient infrastructures for data storage.</p>
    <p class="normal">The focus of this chapter is data-centric algorithms to efficiently manage data. Integral to these algorithms are operations such as efficient storage and data compression. By employing such methodologies, data-centric architectures enable data management and efficient resource utilization. By the end of this chapter, you should be well-equipped to understand the concepts and trade-offs involved in designing and implementing various data-centric algorithms.</p>
    <p class="normal">This chapter discusses the following concepts:</p>
    <ul>
      <li class="bulletList">Introduction to data algorithms</li>
      <li class="bulletList">Classification of data</li>
      <li class="bulletList">Data storage algorithms</li>
      <li class="bulletList">Data compression algorithms</li>
    </ul>
    <p class="normal">Let’s first introduce the basic concepts.</p>
    <h1 id="_idParaDest-473" class="heading-1">Introduction to data algorithms</h1>
    <p class="normal">Data algorithms are specialized for managing and optimizing data storage. Beyond storage, they handle <a id="_idIndexMarker1296"/>tasks like data compression, ensuring efficient storage space utilization, and streamline rapid data retrieval, critical in many applications.</p>
    <p class="normal">A critical facet in understanding data algorithms, especially in distributed systems, is the CAP theorem. Here’s where its significance lies: this theorem elucidates the balance among consistency, availability, and partition tolerance. In any distributed system, achieving two out of these three guarantees simultaneously is all we can hope for. Comprehending CAP’s subtleties aids in discerning the challenges and design decisions in modern data algorithms.</p>
    <p class="normal">In the scope of data governance, these algorithms are invaluable. They assure data consistency across all distributed system nodes, ensuring data integrity. They also assure efficient data availability and manage data partition tolerance, enhancing the system’s resilience and security.</p>
    <h2 id="_idParaDest-474" class="heading-2">Significance of CAP theorem in context of data algorithms</h2>
    <p class="normal">The CAP theorem doesn’t just set theoretical limits; it has practical implications in real-world scenarios <a id="_idIndexMarker1297"/>where data is manipulated, stored, and retrieved. Imagine, for instance, a scenario where an algorithm must retrieve data from a distributed system. The choices made around consistency, availability, and partition <a id="_idIndexMarker1298"/>tolerance directly impact the efficiency and reliability of that algorithm. If a system prioritizes availability, the data might be easily retrievable but may not be the most up-to-date version. Conversely, a system prioritizing consistency might sometimes delay data retrieval to ensure that only the most recent data is accessed.</p>
    <p class="normal">The data-centric algorithms we discuss here are, in many ways, influenced by these CAP constraints. By intertwining our understanding of CAP theorem with data algorithms, we can make more informed decisions when dealing with data challenges.</p>
    <h2 id="_idParaDest-475" class="heading-2">Storage in distributed environments</h2>
    <p class="normal">Single-node <a id="_idIndexMarker1299"/>architecture is effective <a id="_idIndexMarker1300"/>for smaller data sets. However, with the surge in dataset sizes, distributed environment storage has become standard for large scale problems. Identifying the right strategy for data storage in such environments depends on various factors, including the nature of the data and anticipated <a id="_idIndexMarker1301"/>usage patterns. </p>
    <p class="normal">The CAP theorem provides <a id="_idIndexMarker1302"/>a foundational principle for developing these storage strategies, helping us tackle challenges linked with managing expansive data sets.</p>
    <h2 id="_idParaDest-476" class="heading-2">Connecting CAP theorem and data compression</h2>
    <p class="normal">It might initially seem there’s little overlap between the CAP theorem and data compression. But <a id="_idIndexMarker1303"/>consider the practical implications. If <a id="_idIndexMarker1304"/>we prioritize consistency in our system (as per CAP considerations), our data compression methods would need to ensure that data remains <a id="_idIndexMarker1305"/>consistently compressed across all <a id="_idIndexMarker1306"/>nodes. In a system where availability takes precedence, the compression method might be optimized for speed, even if it leads to minor inconsistencies. This interplay highlights that our choices around CAP influence even how we compress and retrieve our data, demonstrating the theorem’s pervasive influence in data-centric algorithms.</p>
    <h1 id="_idParaDest-477" class="heading-1">Presenting the CAP theorem</h1>
    <p class="normal">In 1998, Eric Brewer proposed a theorem that later became famous as the CAP theorem. It highlights <a id="_idIndexMarker1307"/>the various trade-offs involved in designing a distributed service system. To understand the CAP theorem, first, let’s define the following three characteristics of distributed service systems: consistency, availability, and partition tolerance. CAP is, in fact, an acronym made up of these three characteristics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Consistency</strong> (or simply <strong class="keyWord">C</strong>): The distributed service consists of various nodes. Any of these <a id="_idIndexMarker1308"/>nodes can be used to read, write, or update records in the data repository. Consistency guarantees that at a certain time, t1, independent of which node we use to read the data, we will get the same result. Every read operation either returns the latest data that is consistent across the distributed repository or gives an error message.</li>
      <li class="bulletList"><strong class="keyWord">Availability</strong> (or simply <strong class="keyWord">A</strong>): In the <a id="_idIndexMarker1309"/>area of distributed systems, availability means that the system as a whole always responds to requests. This ensures that users get a reply every time they query the system, even if it might not always be the latest piece of data. So, instead of focusing on every single node being up-to-date, the emphasis is on the entire <a id="_idIndexMarker1310"/>system being responsive. It’s about guaranteeing that a user’s request never goes unanswered, even if some parts of the system have outdated information.</li>
      <li class="bulletList"><strong class="keyWord">Partition Tolerance</strong> (or simply <strong class="keyWord">P</strong>): In a distributed system, multiple nodes are connected <a id="_idIndexMarker1311"/>via a communication network. Partition tolerance guarantees that, in the event of communication failure between a small subset of nodes (one or more), the system remains operational. Note that to guarantee partition tolerance, data needs to be replicated across a sufficient number of nodes.</li>
    </ul>
    <p class="normal">Using these three characteristics, the CAP theorem carefully summarizes the trade-offs involved in the <a id="_idIndexMarker1312"/>architecture and design of a distributed service system. Specifically, the CAP theorem states that, in a distributed storage system, we can only have two of the following characteristics: consistency or <strong class="keyWord">C</strong>, availability or <strong class="keyWord">A</strong>, and partition tolerance or <strong class="keyWord">P</strong>.</p>
    <p class="normal">This is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_13_01.png" alt="Diagram, venn diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 13.1: Visualizing the choices in distributed systems: the CAP theorem</p>
    <p class="normal">Distributed data storage is increasingly becoming an essential component of modern IT infrastructure. Designing distributed data storage should be carefully considered, based on the characteristics of the data and the requirements of the problem we want to solve. When applied to distributed databases, the CAP theorem helps to guide the design and decision-making process by ensuring that developers and architects understand the fundamental trade-offs and limitations involved in creating distributed database systems. Balancing these three characteristics is crucial to achieve the desired performance, reliability, and scalability of the distributed database system. When applied to distributed databases, the CAP theorem helps to guide the design and decision-making <a id="_idIndexMarker1313"/>process by ensuring that developers and architects understand the fundamental trade-offs. Balancing these three characteristics is crucial in order to achieve the desired performance, reliability, and scalability of the distributed database system. In the context of the CAP theorem, we can assume that there are three types of distributed storage systems:</p>
    <ul>
      <li class="bulletList">A <strong class="keyWord">CA</strong> system (implementing Consistency-Availability)</li>
      <li class="bulletList">An <strong class="keyWord">AP</strong> system (implementing Availability-Partition Tolerance)</li>
      <li class="bulletList">A <strong class="keyWord">CP</strong> system (implementing Consistency-Partition Tolerance)</li>
    </ul>
    <p class="normal">Classifying data storage into <strong class="keyWord">CA</strong>, <strong class="keyWord">AP</strong>, and <strong class="keyWord">CP</strong> systems helps us to understand the various trade-offs involved when designing data storage systems.</p>
    <p class="normal">Let’s look into them, one by one.</p>
    <h2 id="_idParaDest-478" class="heading-2">CA systems</h2>
    <p class="normal">Traditional single-node systems are CA systems. In non-distributed systems, partition tolerance is <a id="_idIndexMarker1314"/>not a concern as there is no need to manage communication between multiple nodes. As a result, these systems can focus on maintaining both <a id="_idIndexMarker1315"/>consistency and availability. In other words, they are CA systems.</p>
    <p class="normal">A system can function without partition tolerance by storing and processing data on a single node or server. While this approach may not be suitable for handling large-scale data sets or high-velocity data streams, it can be effective for smaller data sizes or applications with less demanding performance requirements.</p>
    <p class="normal">Traditional single-node databases, such as Oracle or MySQL, are prime examples of CA systems. These systems are well-suited for use cases where data volume and velocity are relatively low, and partition tolerance is not a critical factor. Examples include small to medium-sized businesses, academic projects, or applications with a limited number of users and data sources.</p>
    <h2 id="_idParaDest-479" class="heading-2">AP systems</h2>
    <p class="normal">AP systems are distributed storage systems designed to prioritize availability and partition tolerance, even at the expense of consistency. These highly responsive systems can sacrifice <a id="_idIndexMarker1316"/>consistency, if necessary, to accommodate high-velocity data. In doing so, these distributed storage systems can handle user requests immediately, even if it results in temporarily serving slightly outdated or inconsistent data across different nodes.</p>
    <p class="normal">When consistency <a id="_idIndexMarker1317"/>is sacrificed in AP systems, users might occasionally may get slightly outdated information. In some cases, this temporary inconsistency is an acceptable trade-off, as the ability to quickly process user requests and maintain high availability is deemed more critical than strict data consistency.</p>
    <p class="normal">Typical AP systems are used in real-time monitoring systems, such as sensor networks. High-velocity distributed databases, like Cassandra, are prime examples of AP systems.</p>
    <p class="normal">An AP system is recommended for implementing distributed data storage in scenarios where high availability, responsiveness, and partition tolerance are essential. </p>
    <p class="normal">For example, if Transport Canada wants to monitor traffic on one of the highways in Ottawa through a network of sensors installed at different locations on the highway, an AP system would be the preferred choice. In this context, prioritizing real-time data processing and availability is crucial to ensuring that traffic monitoring can function effectively, even in the presence of network partitions or temporary inconsistencies. This is why an AP system is often the recommended choice for such applications, despite the potential trade-off of sacrificing consistency.</p>
    <h2 id="_idParaDest-480" class="heading-2">CP systems</h2>
    <p class="normal">CP systems prioritize both consistency and partition tolerance, ensuring that distributed storage systems <a id="_idIndexMarker1318"/>guarantee consistency before a read process retrieves a value. These systems are specifically designed to maintain data consistency and <a id="_idIndexMarker1319"/>continue operating effectively even in the presence of network partitions.</p>
    <p class="normal">The ideal data type for CP systems is data that requires strict consistency and accuracy, even if it means sacrificing the immediate availability of the system. Examples include financial transactions, inventory management, and critical business operations data. In these cases, ensuring that the data remains consistent and accurate across the distributed environment is of paramount importance.</p>
    <p class="normal">A typical use case for CP systems is when we want to store document files in JSON format. Document datastores, such as MongoDB, are CP systems tuned for consistency in a distributed environment.</p>
    <p class="normal">With an understanding of the different types of distributed storage systems, we can now move on to exploring data compression algorithms.</p>
    <h1 id="_idParaDest-481" class="heading-1">Decoding data compression algorithms</h1>
    <p class="normal">Data compression is an essential methodology used for data storage. It not only enhances <a id="_idIndexMarker1320"/>storage efficiency and minimizes data transmission times, but it also has significant implications for cost savings and performance improvements, particularly in the realm of big data and cloud computing. This section presents the details data compression techniques, with a special focus on the lossless algorithms Huffman and LZ77, and their influence on modern compression schemes, such as Gzip, LZO, and Snappy.</p>
    <h2 id="_idParaDest-482" class="heading-2">Lossless compression techniques</h2>
    <p class="normal">Lossless compression revolves around eliminating redundancy in data to minimize storage <a id="_idIndexMarker1321"/>needs while ensuring perfect reversibility. Huffman and LZ77 are two foundational algorithms that have <a id="_idIndexMarker1322"/>strongly influenced the field. </p>
    <p class="normal">Huffman coding focuses on variable-length coding, representing frequent characters with fewer bits, while LZ77, a dictionary-based algorithm, exploits repeated data sequences and represents them with shorter references. Let us look into them one by one.</p>
    <h3 id="_idParaDest-483" class="heading-3">Huffman coding: Implementing variable-length coding</h3>
    <p class="normal">Huffman coding, a form of entropy encoding, is used widely in lossless data compression. The <a id="_idIndexMarker1323"/>key principle underlying <a id="_idIndexMarker1324"/>Huffman coding is to assign shorter codes to more frequently occurring characters in a dataset, thereby reducing the overall data size.</p>
    <p class="normal">The algorithm <a id="_idIndexMarker1325"/>uses a specific type of binary tree known as a Huffman tree, where each leaf node corresponds to a data element. The frequency of occurrence of the element determines the placement in the tree: more frequent elements are placed closer to the root. This strategy ensures that the most common elements have the shortest codes.</p>
    <h4 class="heading-4">A quick example</h4>
    <p class="normal">Imagine we <a id="_idIndexMarker1326"/>have data containing letters <strong class="keyWord">A</strong>, <strong class="keyWord">B</strong>, and <strong class="keyWord">C</strong> with frequencies <code class="inlineCode">5</code>, <code class="inlineCode">9</code>, and <code class="inlineCode">12</code> respectively. In Huffman coding:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">C</strong>, being the most frequent, might get a short code like <code class="inlineCode">0</code>.</li>
      <li class="bulletList"><strong class="keyWord">B</strong>, the next frequent, could get <code class="inlineCode">10</code>.</li>
      <li class="bulletList"><strong class="keyWord">A</strong>, the least frequent, might have <code class="inlineCode">11</code>.</li>
    </ul>
    <p class="normal">To understand it fully, let us go through an example in Python.</p>
    <h4 class="heading-4">Implementing Huffman coding in Python</h4>
    <p class="normal">We start by creating a node for each character, where the node contains the character and its frequency. These nodes are then added to a priority queue, with the least frequent elements <a id="_idIndexMarker1327"/>having the highest priority. For <a id="_idIndexMarker1328"/>this, we create a <code class="inlineCode">Node</code> class to represent each character in the Huffman tree. Each <code class="inlineCode">Node</code> object contains the character, its frequency, and pointers to its left and right children. The <code class="inlineCode">__lt__</code> method is defined to compare two <code class="inlineCode">Node</code> objects based on their frequencies.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import </span>functools
@functools.total_ordering
<span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, char, freq</span>):
        self.char = char
        self.freq = freq
        self.left = <span class="hljs-literal">None</span>
        self.right = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">return</span> self.freq &lt; other.freq
    <span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(self, other):
        <span class="hljs-keyword">return</span> self.freq == other.freq
</code></pre>
    <p class="normal">Next, we build the Huffman tree. The construction of a Huffman tree involves a series of insertions and deletions in a priority queue, typically implemented as a binary heap. To build the Huffman tree, we create a min-heap of Node objects. A min-heap is a specialized tree-based structure that satisfies a simple but important condition: the parent node has a value less than or equal to its children. This property ensures that the smallest element is always at the root, making it efficient for priority operations. We repeatedly pop the two nodes with the lowest frequencies, merge them, and push the merged node back into the heap. This process continues until there is only one node left, which becomes the root of the Huffman tree. The tree can be built by <code class="inlineCode">build_tree</code> function, which is defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">def</span> <span class="hljs-title">build_tree</span>(<span class="hljs-params">frequencies</span>):
    heap = [Node(char, freq) <span class="hljs-keyword">for</span> char, freq <span class="hljs-keyword">in</span> frequencies.items()]
    heapq.heapify(heap)
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(heap) &gt; <span class="hljs-number">1</span>:
        node1 = heapq.heappop(heap)
        node2 = heapq.heappop(heap)
        merged = Node(<span class="hljs-literal">None</span>, node1.freq + node2.freq)
        merged.left = node1
        merged.right = node2
        heapq.heappush(heap, merged)
    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>]  <span class="hljs-comment"># the root node</span>
</code></pre>
    <p class="normal">Once the Huffman tree is constructed, we can generate the Huffman codes by traversing the tree. Starting from the root, we append a <code class="inlineCode">0</code> for every left branch we follow and a <code class="inlineCode">1</code> for every right branch. When we reach a leaf node, the sequence of <code class="inlineCode">0</code>s and <code class="inlineCode">1</code>s accumulated <a id="_idIndexMarker1329"/>along the path from the <a id="_idIndexMarker1330"/>root forms the Huffman code for the character at that leaf node. This functionality is achieved by creating <code class="inlineCode">generate_codes</code> function as follows.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_codes</span>(<span class="hljs-params">node, code=</span><span class="hljs-string">''</span><span class="hljs-params">, codes=</span><span class="hljs-literal">None</span>):
    <span class="hljs-keyword">if</span> codes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        codes = {}
    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> {}
    <span class="hljs-keyword">if</span> node.char <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        codes[node.char] = code
        <span class="hljs-keyword">return</span> codes
    generate_codes(node.left, code + <span class="hljs-string">'0'</span>, codes)
    generate_codes(node.right, code + <span class="hljs-string">'1'</span>, codes)
    <span class="hljs-keyword">return</span> codes
</code></pre>
    <p class="normal">Now let us use the Huffman tree. Let us first define data that we will use for Huffman’s encoding.</p>
    <pre class="programlisting con"><code class="hljs-con">data = {
    'L': 0.45,
    'M': 0.13,
    'N': 0.12,
    'X': 0.16,
    'Y': 0.09,
    'Z': 0.05
}
</code></pre>
    <p class="normal">Then, we print out the Huffman codes for each character.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Build the Huffman tree and generate the Huffman codes</span>
root = build_tree(data)
codes = generate_codes(root)
<span class="hljs-comment"># Print the root of the Huffman tree</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">f'Root of the Huffman tree: </span><span class="hljs-subst">{root}</span><span class="hljs-string">'</span>)
<span class="hljs-comment"># Print out the Huffman codes</span>
<span class="hljs-keyword">for</span> char, code <span class="hljs-keyword">in</span> codes.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'</span><span class="hljs-subst">{char}</span><span class="hljs-string">: </span><span class="hljs-subst">{code}</span><span class="hljs-string">'</span>)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Root of the Huffman tree: &lt;__main__.Node object at 0x7a537d66d240&gt;
L: 0
M: 101
N: 100
X: 111
Y: 1101
Z: 1100
</code></pre>
    <p class="normal">Now, we <a id="_idIndexMarker1331"/>can <a id="_idIndexMarker1332"/>infer the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Fixed length code</strong>: The fixed-length code for this table is <code class="inlineCode">3</code>. This is because, with six <a id="_idIndexMarker1333"/>characters, a fixed-length binary representation would need a maximum of three bits (2<sup class="superscript">3</sup> = 8 possible combinations, which can cover our 6 characters).</li>
      <li class="bulletList"><strong class="keyWord">Variable length code</strong>: The <a id="_idIndexMarker1334"/>variable-length code for this table is 
    <p class="normal"><code class="inlineCode">45(1) + .13(3) + .12(3) + .16(3) + .09(4) + .05(4) = 2.24.</code></p></li>
    </ul>
    <p class="normal">The following diagram shows the Huffman tree created from the preceding example:</p>
    <figure class="mediaobject"><img src="../Images/B18046_13_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 13.2: The Huffman tree: visualizing the vompression process</p>
    <p class="normal">Note that <a id="_idIndexMarker1335"/>Huffman encoding is about converting data into a Huffman tree that enables compression. Decoding or decompression <a id="_idIndexMarker1336"/>brings the data back to the original format.</p>
    <p class="normal">Having looked at Huffman’s encoding, let us now explore another lossless compression technique based on dictionary-based compression.</p>
    <p class="normal">Next, let us discuss dictionary-based compression.</p>
    <h3 id="_idParaDest-484" class="heading-3">Understanding dictionary-based compression LZ77</h3>
    <p class="normal">LZ77 belongs to a family of compression algorithms known as dictionary coders. Rather than maintaining <a id="_idIndexMarker1337"/>a static dictionary of code words, as in Huffman coding, LZ77 dynamically builds a dictionary of substrings seen in the input data. This dictionary isn’t stored separately but is implicitly referred to as a sliding window over the already-encoded input, facilitating an elegant and efficient method of representing repeating sequences.</p>
    <p class="normal">The LZ77 algorithm operates on the principle of replacing repeated occurrences of data with references to a single copy. It maintains a “sliding window” of recently processed data. When it encounters a substring that has occurred before, it doesn’t store the actual substring; instead, it stores a pair of values – the distance to the start of the repeated substring in the sliding window, and the length of the repeated substring.</p>
    <h4 class="heading-4">Understanding with an example</h4>
    <p class="normal">Imagine a scenario where you’re reading the string:</p>
    <p class="normal"><code class="inlineCode">data_string = "ABABCABABD"</code></p>
    <p class="normal">Now, as you <a id="_idIndexMarker1338"/>process this string left to right, when you encounter the substring "<code class="inlineCode">CABAB</code>", you’ll notice that "<code class="inlineCode">ABAB</code>" has appeared before, right after the initial "<code class="inlineCode">AB</code>". LZ77 takes advantage of such repetitions.</p>
    <p class="normal">Instead of writing "<code class="inlineCode">ABAB</code>" again, LZ77 would suggest: “Hey, look back two characters and copy the next two characters!” In technical terms, this is a reference back of two characters with a length of two characters.</p>
    <p class="normal">So, compressing our <code class="inlineCode">data_string</code> using LZ77, it might look something like:</p>
    <p class="normal"><code class="inlineCode">ABABC&lt;2,2&gt;D</code></p>
    <p class="normal">Here, <code class="inlineCode">&lt;2,2&gt;</code> is the LZ77 notation, indicating “go back by two characters and copy the next two.”</p>
    <h4 class="heading-4">Comparison with Huffman</h4>
    <p class="normal">To appreciate the power and differences between LZ77 and Huffman, it’s helpful to use the same data. Let’s stick with our <code class="inlineCode">data_string = "ABABCABABD"</code>.</p>
    <p class="normal">While LZ77 identifies repeated sequences in data and references them, Huffman encoding <a id="_idIndexMarker1339"/>is more about representing <a id="_idIndexMarker1340"/>frequent characters with shorter codes.</p>
    <p class="normal">For instance, if you were to compress our <code class="inlineCode">data_string</code> using Huffman, you might see certain characters, say '<code class="inlineCode">A</code>' and '<code class="inlineCode">B</code>', that are more frequent, represented with shorter binary codes than the less frequent '<code class="inlineCode">C</code>' and '<code class="inlineCode">D</code>'.</p>
    <p class="normal">This comparison showcases that while Huffman is all about frequency-based representation, LZ77 is about spotting and referencing patterns. Depending on the data type and structure, one might be more efficient than the other.</p>
    <h3 id="_idParaDest-485" class="heading-3">Advanced lossless compression formats</h3>
    <p class="normal">The <a id="_idIndexMarker1341"/>principles laid out by Huffman and LZ77 <a id="_idIndexMarker1342"/>have given rise to advanced compression formats. We will look into three advanced formats in this chapter.</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">LZO</li>
      <li class="numberedList">Snappy</li>
      <li class="numberedList">gzip</li>
    </ol>
    <p class="normal">Let us look into them one by one.</p>
    <h4 class="heading-4">LZO compression: Prioritizing speed</h4>
    <p class="normal">LZO is a <a id="_idIndexMarker1343"/>lossless data compression algorithm that emphasizes rapid compression and decompression. It replaces <a id="_idIndexMarker1344"/>repeated occurrences of data with references to a single copy. After this initial pass of LZ77 compression, the data is then passed through a Huffman coding stage.</p>
    <p class="normal">While its compression ratio might not be the highest, its processing speed is significantly faster than many other algorithms. This makes LZO an excellent choice for situations where quick data access is a priority, such as real-time data processing and streaming applications.</p>
    <h4 class="heading-4">Snappy compression: Striking a balance</h4>
    <p class="normal">Snappy is another fast compression and decompression library originally developed by Google. The <a id="_idIndexMarker1345"/>primary focus of Snappy is to achieve high speeds and reasonable compression, but not necessarily the maximum compression.</p>
    <p class="normal">Snappy’s compression <a id="_idIndexMarker1346"/>method is based on LZ77 but with a focus on speed and without an additional entropy encoding step like Huffman coding. Instead, Snappy utilizes a much simpler encoding algorithm that ensures speedy compressions and decompressions. The algorithm uses a copy-based strategy where it searches for repeated sequences in the data and then encodes them as a length and a reference to the previous location.</p>
    <p class="normal">It should be noted that due to this tradeoff for speed, Snappy does not compress data as efficiently as algorithms that use Huffman coding or other forms of entropy encoding. However, in use-cases where speed is more critical than the compression ratio, Snappy can be a very effective choice.</p>
    <h4 class="heading-4">GZIP compression: Maximizing storage efficiency</h4>
    <p class="normal"><code class="inlineCode">GZIP</code> is a file <a id="_idIndexMarker1347"/>format and a <a id="_idIndexMarker1348"/>software application used for file compression and decompression. The <code class="inlineCode">GZIP</code> data format uses a combination of the LZ77 algorithm and Huffman coding.</p>
    <h1 id="_idParaDest-486" class="heading-1">Practical example: Data management in AWS: A focus on CAP theorem and compression algorithms</h1>
    <p class="normal">Let us consider an example of a global e-commerce platform that runs on multiple cloud servers <a id="_idIndexMarker1349"/>across the world. This platform handles thousands of transactions every second, and the data generated from these transactions needs to be stored and processed efficiently. We’ll see how the CAP theorem and compression algorithms can guide the design of the platform’s data management system.</p>
    <h2 id="_idParaDest-487" class="heading-2">1. Applying the CAP theorem</h2>
    <p class="normal">The CAP theorem states that a distributed data store cannot simultaneously provide more than <a id="_idIndexMarker1350"/>two out of the following three guarantees: consistency, availability, and partition tolerance.</p>
    <p class="normal">In our e-commerce <a id="_idIndexMarker1351"/>platform scenario, availability and partition tolerance might be prioritized. High availability ensures that the system can continue processing transactions even if a few servers fail. Partition tolerance means the system can still function even if network failures cause some of the servers to be isolated.</p>
    <p class="normal">While this means the system may not always provide strong consistency (every read receives the most recent write), it could use eventual consistency (updates propagate through the system and eventually all replicas show the same value) to ensure a good user experience. In practice, slight inconsistencies might be acceptable, for example, when it takes a few seconds for a user’s shopping cart to update across all devices.</p>
    <p class="normal">In the AWS ecosystem, we have a variety of data storage services that can be chosen based on the needs defined by the CAP theorem. For our e-commerce platform, we would prefer availability and partition tolerance over consistency. Amazon DynamoDB, a key-value NoSQL database, would be an excellent fit. It offers built-in support for multi-region replication and automatic sharding, ensuring high availability and partition tolerance. </p>
    <p class="normal">For <a id="_idIndexMarker1352"/>consistency, DynamoDB <a id="_idIndexMarker1353"/>offers “eventual consistency” and “strong consistency” options. In our case, we would opt for eventual consistency to prioritize availability and performance.</p>
    <h2 id="_idParaDest-488" class="heading-2">2. Using compression algorithms</h2>
    <p class="normal">The platform would generate vast amounts of data, including transaction details, user behavior logs, and product information. Storing and transferring this data could be costly and time-consuming.</p>
    <p class="normal">Here, compression <a id="_idIndexMarker1354"/>algorithms like gzip, Snappy, or LZO can help. For instance, the platform might use gzip to compress transaction logs that are archived <a id="_idIndexMarker1355"/>for long-term storage. Given that gzip can typically compress text files to about 30% of their original size, this could reduce storage costs significantly.</p>
    <p class="normal">On the other hand, for real-time analytics on user behavior data, the platform might use Snappy or LZO. While these algorithms may not compress data as much as gzip, they are faster and would allow the analytics system to process data more quickly.</p>
    <p class="normal">AWS provides various ways to implement compression depending on the type and use of data. For compressing transaction logs for long-term storage, we could use Amazon S3 (Simple Storage Service) coupled with gzip compression. S3 supports automatic gzip compression for files being uploaded, which can significantly reduce storage costs. For real-time analytics on user behavior data, we could use Amazon Kinesis Data Streams with Snappy or LZO compression. Kinesis can capture, process, and store data streams for real-time analytics, and supports compression to handle high-volume data.</p>
    <h2 id="_idParaDest-489" class="heading-2">3. Quantifying the benefits</h2>
    <p class="normal">The benefits <a id="_idIndexMarker1356"/>can be quantified similarly as described earlier.</p>
    <p class="normal">Let’s take a practical example to demonstrate potential cost savings. Imagine our platform produces 1 TB of transaction logs daily. By leveraging gzip compression with S3, we can potentially shrink the storage requirement to roughly 300 GB. As of August 2023, S3 charges around $0.023 for every GB up to the initial 50 TB monthly. Doing the math, this equates to a saving of about $485 each month, or a significant $5,820 annually, just from the log storage. It’s worth noting that the cited AWS pricing is illustrative and specific to August 2023; be sure to check current rates as they might vary.</p>
    <p class="normal">Using Snappy or LZO with Kinesis for real-time analytics could improve data processing speed. This could lead to more timely and personalized user recommendations, potentially <a id="_idIndexMarker1357"/>increasing sales. The financial gain could be calculated based on the increase in conversion rate attributed to improved recommendation speed.</p>
    <p class="normal">Lastly, by using DynamoDB and adhering to the CAP theorem, we ensure a smooth shopping experience for our users even in the event of network partitions or individual server failures. The value of this choice could be reflected in the platform’s user retention rate and overall customer satisfaction.</p>
    <h1 id="_idParaDest-490" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we examined the design of data-centric algorithms, concentrating on three key components: data storage, data governance and data compression. We investigated the various issues related to data governance. We analyzed how the distinct attributes of data influence the architectural decisions for data storage. We investigated different data compression algorithms, each providing specific advantages in terms of efficiency and performance. In the next chapter, we will look at cryptographic algorithms. We will learn how we can use the power of these algorithms to secure exchanged and stored messages.</p>
    <h1 id="_idParaDest-491" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>