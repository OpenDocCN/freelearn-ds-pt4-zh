<html><head></head><body>
  <div id="_idContainer475" class="Basic-Text-Frame">
    <h1 class="chapterNumber">14</h1>
    <h1 id="_idParaDest-492" class="chapterTitle">Cryptography</h1>
    <blockquote class="packt_quote">
      <p class="quote">I carry my unwritten poems in cipher on my face!</p>
      <p class="cite">—George Eliot</p>
    </blockquote>
    <p class="normal">This chapter introduces you to algorithms related to cryptography. We will start by presenting the background, then we will discuss symmetric encryption algorithms. We will then explain the <strong class="keyWord">Message-Digest 5</strong> (<strong class="keyWord">MD5</strong>) algorithm and the <strong class="keyWord">Secure Hash Algorithm</strong> (<strong class="keyWord">SHA</strong>) and present the limitations and weaknesses of symmetric algorithms. Next, we will discuss asymmetric encryption algorithms and how they are used to create digital certificates. Finally, we will present a practical example that summarizes all of these techniques.</p>
    <p class="normal">By the end of this chapter, you will have a basic understanding of various issues related to cryptography.</p>
    <p class="normal">The following topics are discussed in this chapter:</p>
    <ul>
      <li class="bulletList">Introduction to cryptography</li>
      <li class="bulletList">Understanding the types of cryptography techniques</li>
      <li class="bulletList">Example – security concerns when deploying a machine learning model</li>
    </ul>
    <p class="normal">Let’s start by looking at the basic concepts.</p>
    <h1 id="_idParaDest-493" class="heading-1">Introduction to cryptography</h1>
    <p class="normal">Techniques to protect <a id="_idIndexMarker1358"/>secrets have been around for centuries. The earliest attempts to secure and hide data from adversaries date back to ancient inscriptions discovered on monuments in Egypt, where a special alphabet that was known by only a few trusted people was used. This early form of security is called obscurity and is still used in different forms today. In order for this method to work, it is critical to protect the secret, which would be the secret meaning of the alphabet in the above example. Later in time, finding foolproof ways of protecting important messages was important in both World War One and World War Two. In the late 20<sup class="superscript">th</sup> century, with the introduction of electronics and computers, sophisticated algorithms were developed to secure data, giving rise to a whole new field called cryptography. This chapter discusses the <a id="_idIndexMarker1359"/>algorithmic aspects of cryptography. One of the uses of these algorithms is to allow secure data exchange between two processes or users. Cryptographic algorithms find strategies for using mathematical functions to ensure the stated security goals.</p>
    <p class="normal">First, we will look at the importance of “the weakest link” in the infrastructure.</p>
    <h2 id="_idParaDest-494" class="heading-2">Understanding the importance of the weakest link</h2>
    <p class="normal">Sometimes, when architecting the security of digital infrastructure, we put too much emphasis on the security of individual entities and don’t pay the necessary attention to end-to-end security. This can result in us overlooking some loopholes and vulnerabilities in the system, which <a id="_idIndexMarker1360"/>can later be exploited by hackers to access sensitive data. The important point to remember is that a digital infrastructure, as a whole, is only as strong as its weakest link. For a hacker, this weakest link can provide backdoor access to sensitive data in the digital infrastructure. Beyond a certain point, there is not much benefit in fortifying the front door without closing all the back doors.</p>
    <p class="normal">As the algorithms and techniques for keeping digital infrastructure become more and more sophisticated, attackers keep upgrading their techniques as well. It is always important to remember that one of the easiest ways for attackers to hack digital infrastructure is by exploiting these vulnerabilities to access sensitive information.</p>
    <div class="note">
      <p class="normal">In 2014, a cyber attack on a Canadian federal research institute—the <strong class="keyWord">National Research Council</strong> (<strong class="keyWord">NRC</strong>)—is estimated to have cost hundreds of millions of dollars. The attackers <a id="_idIndexMarker1361"/>were able to steal decades of research data and intellectual property material. They used a loophole in the Apache software that was used on the web servers to gain access to the sensitive data.</p>
    </div>
    <p class="normal">In this chapter, we <a id="_idIndexMarker1362"/>will highlight the vulnerabilities of various encryption algorithms.</p>
    <p class="normal">Let’s first look at the basic terminology used.</p>
    <h2 id="_idParaDest-495" class="heading-2">The basic terminology</h2>
    <p class="normal">Let’s look at the basic terminology related to cryptography:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Cipher</strong>: An algorithm <a id="_idIndexMarker1363"/>that performs a particular cryptographic function.</li>
      <li class="bulletList"><strong class="keyWord">Plain text</strong>: The plain data, which can be a text file, a video, a bitmap, or a digitized voice. In this <a id="_idIndexMarker1364"/>chapter, we will represent plain text as <em class="italic">P</em>.</li>
      <li class="bulletList"><strong class="keyWord">Cipher text</strong>: The scrambled text that is obtained after applying cryptography to the plain text. In this <a id="_idIndexMarker1365"/>chapter, we will represent this as <em class="italic">C</em>.</li>
      <li class="bulletList"><strong class="keyWord">Cipher suite</strong>: A set or suite of cryptographic software components. When two separate <a id="_idIndexMarker1366"/>nodes want to exchange messages using cryptography, they first need to agree on a cipher suite. This is important in ensuring that they use exactly the same implementation of the cryptographic functions.</li>
      <li class="bulletList"><strong class="keyWord">Encryption</strong>: The process <a id="_idIndexMarker1367"/>of converting plain text, <em class="italic">P</em>, into cipher text, <em class="italic">C</em>, is called encryption. Mathematically, it is represented by <em class="italic">encrypt(P) = C</em>.</li>
      <li class="bulletList"><strong class="keyWord">Decryption</strong>: The process <a id="_idIndexMarker1368"/>of converting cipher text back into plain text. Mathematically, it is represented by <em class="italic">decrypt(C) = P</em>.</li>
      <li class="bulletList"><strong class="keyWord">Cryptanalysis</strong>: The methods <a id="_idIndexMarker1369"/>used to analyze the strength of cryptographic algorithms. The analyst tries to recover the plain text without access to the secret.</li>
      <li class="bulletList"><strong class="keyWord">Personally Identifiable Information</strong> (<strong class="keyWord">PII</strong>): PII is information that can be used to trace an <a id="_idIndexMarker1370"/>individual’s identity when used alone or with other relevant data. Some examples include protected information, such as a social security number, date of birth, or mother’s maiden name.</li>
    </ul>
    <p class="normal">Let us first understand the security needs of a system.</p>
    <h2 id="_idParaDest-496" class="heading-2">Understanding the security requirements</h2>
    <p class="normal">It is important to first understand the exact security needs of a system. Understanding this will help us use <a id="_idIndexMarker1371"/>the correct cryptographic technique and discover the potential loopholes in a system. </p>
    <p class="normal">One way of developing a better understanding of the security needs of a system is by answering the following four questions:</p>
    <ul>
      <li class="bulletList">Which individuals or processes need to be protected?</li>
      <li class="bulletList">Who are we protecting the individuals and processes from?</li>
      <li class="bulletList">Where should we protect them?</li>
      <li class="bulletList">Why are we protecting them?</li>
    </ul>
    <p class="normal">Let us take the example of a <strong class="keyWord">Virtual Private Cloud</strong> (<strong class="keyWord">VPC</strong>) in the AWS cloud. A VPC allows us to create a logical isolation <a id="_idIndexMarker1372"/>network where resources like virtual machines are added to it. In order to understand the security requirements of a VPC, it is important to first identify the identities by answering those four questions:</p>
    <ul>
      <li class="bulletList">How many individuals are planning to use this system? </li>
      <li class="bulletList">What sort of information needs to be protected? </li>
      <li class="bulletList">Should we protect the VPC only, or we are passing a message to the system that needs to be encrypted and communicated to the VPC?</li>
      <li class="bulletList">What is the security classification of the data? What are the potential risks? Why would anyone have an incentive to try to hack the system?</li>
    </ul>
    <p class="normal">Most of the answers to these questions will come by performing the following three steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Identify the entities.</li>
      <li class="numberedList">Establish the security goals.</li>
      <li class="numberedList">Understand the sensitivity of the data.</li>
    </ol>
    <p class="normal">Let’s look at these steps one by one.</p>
    <h3 id="_idParaDest-497" class="heading-3">Step 1: Identifying the entities</h3>
    <p class="normal">An entity can <a id="_idIndexMarker1373"/>be defined as an individual, a process, or a resource that is part of an information system. We first need to identify how users, resources, and processes are present at runtime. Then, we will quantify the security needs of these identified entities, either individually or as a group.</p>
    <p class="normal">Once we better <a id="_idIndexMarker1374"/>understand these requirements, we can establish the security goals of our digital system.</p>
    <h3 id="_idParaDest-498" class="heading-3">Step 2: Establishing the security goals</h3>
    <p class="normal">The goal of <a id="_idIndexMarker1375"/>designing a security system is to protect information from being stolen, compromised, or attacked. Cryptographic algorithms are typically used to meet one or more security goals:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Authentication</strong>: Authentication is a mechanism by which we ascertain the identity of a user, device, or system, confirming that they are indeed what or who they claim to be.</li>
      <li class="bulletList"><strong class="keyWord">Authorization</strong>: Authorization is the process of giving the user permission to access a specific resource or function.</li>
      <li class="bulletList"><strong class="keyWord">Confidentiality</strong>: Data that needs to be protected is called <strong class="keyWord">sensitive data</strong>. Confidentiality is the<a id="_idIndexMarker1376"/> concept of restricting sensitive data to authorized users only. To protect the confidentiality of sensitive data during its transit or in storage, you need to render the data so that it is unreadable except by authorized users. This is accomplished by using encryption algorithms, which we will discuss later on in this chapter.</li>
      <li class="bulletList"><strong class="keyWord">Integrity</strong>: Integrity is the process of establishing that data has not been altered in <a id="_idIndexMarker1377"/>any way during its transit or storage. For example, <strong class="keyWord">TCP</strong>/<strong class="keyWord">IP</strong> (<strong class="keyWord">Transmission Control Protocol</strong>/<strong class="keyWord">Internet Protocol</strong>) uses checksum or <strong class="keyWord">Cyclic Redundancy Check </strong>(<strong class="keyWord">CRC</strong>) algorithms <a id="_idIndexMarker1378"/>to verify data integrity.</li>
      <li class="bulletList"><strong class="keyWord">Non-repudiation</strong>: Non-repudiation is the ability to produce unforgeable and irrefutable evidence that a message was sent or received. This evidence can be used later to prove the receipt of data.</li>
    </ul>
    <h3 id="_idParaDest-499" class="heading-3">Step 3: Understanding the sensitivity of the data</h3>
    <p class="normal">It is important to <a id="_idIndexMarker1379"/>understand the classified nature of data. Data is categorized by regulatory authorities such as governments, agencies, or organizations <a id="_idIndexMarker1380"/>based on how serious the consequence will be if it is compromised. The categorization of the data helps us choose the correct cryptographic algorithm. There is more than one way to categorize data, based on the sensitivity of the information it contains. Let’s look at the typical ways of classifying data:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Public data or unclassified data</strong>: Anything that is available for consumption to the public, for example, information found on a company’s website or a government’s info portal.</li>
      <li class="bulletList"><strong class="keyWord">Internal data or confidential data</strong>: Although not for public consumption, exposing this data to the public may not have damaging consequences. For example, if an employee’s emails complaining about their manager are exposed, it may be embarrassing for the company but this may not have damaging consequences.</li>
      <li class="bulletList"><strong class="keyWord">Sensitive data or secret data</strong>: Data that is not supposed to be for public consumption and exposing it to the public could have damaging consequences for an individual or an organization. For example, leaking the details of a future iPhone may harm Apple’s business goals and could give an advantage to rivals, such as Samsung.</li>
      <li class="bulletList"><strong class="keyWord">Highly sensitive data</strong>: Also called <strong class="keyWord">top-secret data</strong>. This is information that, if disclosed, would be <a id="_idIndexMarker1381"/>extremely damaging to the organization. Examples of highly sensitive data include proprietary research, strategic business plans, or <a id="_idIndexMarker1382"/>internal financial data. </li>
    </ul>
    <p class="bulletList">Top-secret data is protected through multiple layers of security and <a id="_idIndexMarker1383"/>requires special permission to access it.</p>
    <div class="note">
      <p class="normal">In general, more sophisticated security designs are much slower than simple algorithms. It is important to strike the right balance between the security and the performance of the system.</p>
    </div>
    <h2 id="_idParaDest-500" class="heading-2">Understanding the basic design of ciphers</h2>
    <p class="normal">Designing ciphers is <a id="_idIndexMarker1384"/>about coming up with an algorithm that can scramble sensitive data so that a malicious process or an unauthorized user cannot access it. Although, over time, ciphers have become more and more sophisticated, the underlying principles that ciphers are based on remain unchanged.</p>
    <p class="normal">Let’s start by looking at some relatively simple ciphers that will help us understand the underlying principles that are used in the design of cryptographic algorithms.</p>
    <h3 id="_idParaDest-501" class="heading-3">Presenting substitution ciphers</h3>
    <p class="normal">Substitution ciphers <a id="_idIndexMarker1385"/>have been in use for hundreds of years in various forms. As the name indicates, substitution ciphers are based on a simple concept—substituting characters in plain text with other characters in a predetermined, organized way.</p>
    <p class="normal">Let’s look at the exact steps involved in this:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we map each character to a substitute character.</li>
      <li class="numberedList">Then, we encode and convert the plain text into cipher text by replacing each character in the plain text with another character in the cipher text using substitution mapping.</li>
      <li class="numberedList">To decode, we bring back the plaintext by using substitution mapping.</li>
    </ol>
    <p class="normal">The following are examples of substitution-based ciphers:</p>
    <ul>
      <li class="bulletList">Caesar cipher</li>
      <li class="bulletList">Rotation 13</li>
    </ul>
    <p class="normal">Let us look into them in more detail.</p>
    <h4 class="heading-4">Caesar cipher</h4>
    <p class="normal">Caesar ciphers are based on substitution mapping. Substitution mapping changes the actual string in a <a id="_idIndexMarker1386"/>deterministic way by applying a simple <a id="_idIndexMarker1387"/>formula that is kept secret. </p>
    <p class="normal">The substitution mapping is created by replacing each character with the third character to the right of it. This mapping is described in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 13.1: The substitution mapping of Caesar ciphers</p>
    <p class="normal">Let’s see how we can implement a Caesar cipher using Python:</p>
    <pre class="programlisting code"><code class="hljs-code">rotation = <span class="hljs-number">3</span>
P = <span class="hljs-string">'CALM'</span>; C=<span class="hljs-string">''</span>
<span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> P:
    C = C+ (<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(letter) + rotation))
</code></pre>
    <p class="normal">We can see that we applied a Caesar cipher to the plaintext <code class="inlineCode">CALM</code>.</p>
    <p class="normal">Let’s print the cipher text after encrypting it with the Caesar cipher:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(C)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">FDOP
</code></pre>
    <div class="note">
      <p class="normal">Caesar ciphers are said to have been used by Julius Caesar to communicate with his advisers.</p>
    </div>
    <p class="normal">A Caesar cipher is a simple cipher and is easy to implement. The downside is that it is not too difficult to <a id="_idIndexMarker1388"/>crack as a hacker could simply iterate <a id="_idIndexMarker1389"/>through all the possible shifts of the alphabet (all 2626 of them) and see if any coherent message appears. Given the current processing abilities of computers, this is a relatively small number of combinations to do. It should not be used to protect highly sensitive data.</p>
    <h4 class="heading-4">Rotation 13 (ROT13)</h4>
    <p class="normal">ROT13 is a special case of <a id="_idIndexMarker1390"/>the Caesar cipher where the substitution mapping is <a id="_idIndexMarker1391"/>created by replacing each character with the 13<sup class="superscript">th</sup> character to the right of it. The following diagram illustrates this:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_02.png" alt="A picture containing rectangle  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.2: Workings of ROT13</p>
    <p class="normal">This means that if <code class="inlineCode">ROT13()</code> is the function that implements ROT13, then the following applies:</p>
    <pre class="programlisting code"><code class="hljs-code">rotation = <span class="hljs-number">13</span>
P = <span class="hljs-string">'CALM'</span>; C=<span class="hljs-string">''</span>
<span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> P:
    C = C+ (<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(letter) + rotation))
</code></pre>
    <p class="normal">Now, let’s print the encoded value of <code class="inlineCode">C</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(c)
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">PNYZ
</code></pre>
    <p class="normal">ROT13 is actually <a id="_idIndexMarker1392"/>not used to accomplish data confidentiality. It is <a id="_idIndexMarker1393"/>used more to mask text, for example, to hide potentially offensive text. It can also be used to avoid giving away the answer to a puzzle, and in other similar use-cases.</p>
    <h3 id="_idParaDest-502" class="heading-3">Cryptanalysis of substitution ciphers</h3>
    <p class="normal">Substitution ciphers are simple to implement and understand. Unfortunately, they are also easy to crack. Simple cryptanalysis of substitution ciphers shows that if we use the English language <a id="_idIndexMarker1394"/>alphabet, then all we need to determine to crack the cipher is how much we are rotating by. We can try each letter of the English alphabet one by one until we are able to decrypt the text. This means that it will take around 25 attempts to reconstruct the plain text.</p>
    <p class="normal">Now, let’s look at another type of simple cipher—transposition ciphers.</p>
    <h3 id="_idParaDest-503" class="heading-3">Understanding transposition ciphers</h3>
    <p class="normal">In transposition ciphers, the<a id="_idIndexMarker1395"/> characters of the plain text are encrypted using transposition. Transposition is a method of encryption where we scramble the <a id="_idIndexMarker1396"/>position of the characters using deterministic logic. A transposition cipher writes characters into rows in a matrix and then reads the columns as output. Let’s look at an example.</p>
    <p class="normal">Let’s take the <code class="inlineCode">Ottawa Rocks</code> plain text (<em class="italic">P</em>).</p>
    <p class="normal">First, let’s encode <em class="italic">P</em>. For that, we will use a 3 x 4 matrix and write in the plaintext horizontally:</p>
    <table id="table001-9" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal">O</p>
          </td>
          <td class="table-cell">
            <p class="normal">t</p>
          </td>
          <td class="table-cell">
            <p class="normal">t</p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">w</p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
          <td class="table-cell">
            <p class="normal">R</p>
          </td>
          <td class="table-cell">
            <p class="normal">o</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">c</p>
          </td>
          <td class="table-cell">
            <p class="normal">k</p>
          </td>
          <td class="table-cell">
            <p class="normal">s</p>
          </td>
          <td class="table-cell"/>
        </tr>
      </tbody>
    </table>
    <p class="normal">The <code class="inlineCode">read</code> process will read the string vertically, which will generate the cipher text—<code class="inlineCode">OwctaktRsao</code>. The key would be {1,2,3,4}, which is the order in which the columns are read. Encrypting with a different key, say, {2,4,3,1}, would result in a different cipher text, in this case, <code class="inlineCode">takaotRsOwc</code>.</p>
    <div class="note">
      <p class="normal">The Germans used a cipher named ADFGVX in the First World War, which used both transposition and substitution ciphers. Years later, it was cracked by George Painvin.</p>
    </div>
    <p class="normal">So, these are some of the types of ciphers. In general, ciphers use a key to code plain text. Now, let’s look <a id="_idIndexMarker1397"/>at some of the cryptographic techniques that are currently used. Cryptography protects a message using encryption and decryption processes, as discussed in the next section.</p>
    <h1 id="_idParaDest-504" class="heading-1">Understanding the types of cryptographic techniques</h1>
    <p class="normal">Different types of cryptographic techniques use different types of algorithms and are used under different sets of circumstances. As different situations and use-cases have different requirements <a id="_idIndexMarker1398"/>of security based on the business requirements and the data classification, the selection of the right technique is important for a well-designed architecture.</p>
    <p class="normal">Broadly, cryptographic techniques can be divided into the following three types:</p>
    <ul>
      <li class="bulletList">Hashing</li>
      <li class="bulletList">Symmetric</li>
      <li class="bulletList">Asymmetric</li>
    </ul>
    <p class="normal">Let’s look at them one by one.</p>
    <h2 id="_idParaDest-505" class="heading-2">Using the cryptographic hash function</h2>
    <p class="normal">The cryptographic hash function is a mathematical algorithm that can be used to create a unique fingerprint <a id="_idIndexMarker1399"/>of a message. It creates an output, called a hash, from plain text. The size of the output is usually fixed but can vary for some specialized algorithms.</p>
    <p class="normal">Mathematically, this looks as follows:</p>
    <p class="center"><em class="italic">C</em><sub class="subscript">1</sub><em class="italic"> = hashFunction(P</em><sub class="subscript">1</sub><em class="italic">)</em></p>
    <p class="normal">This is explained as follows:</p>
    <ul>
      <li class="bulletList"><em class="italic">P</em><sub class="subscript">1</sub> is the plain text representing the input data</li>
      <li class="bulletList"><em class="italic">C</em><sub class="subscript">1</sub> is a fixed-length hash that is generated by the cryptographic hash function</li>
    </ul>
    <p class="normal">This is shown in the following diagram. The variable-length data is converted into a fixed-length hash through a one-way hash function:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.3: One-way hash functions</p>
    <p class="normal">A hash function is a mathematical algorithm that transforms an arbitrary amount of data into a fixed-size string of bytes. It plays a vital role in ensuring the integrity and authenticity of data. Below are the key characteristics that define a cryptographic hash function:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Deterministic</strong>: A hash function is deterministic, meaning that the same input (or “plaintext”) will always <a id="_idIndexMarker1400"/>produce the same output (or “hash”). No matter how many times you hash a particular piece of data, the result will remain consistent.</li>
      <li class="bulletList"><strong class="keyWord">Uniqueness</strong>: Ideally, different inputs should always produce unique hash outputs. If two distinct inputs produce the same hash, this is known as a collision. Quality hash functions are designed to minimize the likelihood of collisions.</li>
      <li class="bulletList"><strong class="keyWord">Fixed length</strong>: The output of a hash function has a fixed length, regardless of the size of the input data. Whether you’re hashing a single character or an entire novel, the resulting hash will be of the same size, specific to the hash algorithm used (e.g., 128 bits for MD5, 256 bits for SHA-256).</li>
      <li class="bulletList"><strong class="keyWord">Sensitive to input changes</strong>: Even a minor alteration in the plaintext leads to a significant and unpredictable change in the resulting hash value. This property ensures that it is not feasible to derive the original input or find a different input that produces the same hash, enhancing the security of the hash function. The effect is such that even changing a single letter in a large document will result in a hash that appears entirely different from the original.</li>
      <li class="bulletList"><strong class="keyWord">One-way function</strong>: Hash functions are one-way, meaning that it is computationally infeasible <a id="_idIndexMarker1401"/>to reverse the process and generate the original plaintext (P<sub class="subscript">1</sub>) from the hash (C<sub class="subscript">1</sub>). This ensures that even if an unauthorized party obtains the hash, they cannot use it to determine the original data.</li>
    </ul>
    <p class="normal">If we have a situation where each unique message does not have a unique hash, we call it a collision. In other words, a collision is when the hash algorithm produces the same hash value for two <a id="_idIndexMarker1402"/>different input values. For security applications, a collision is a potential vulnerability and its probability should be very low. That is, if we have two texts, P1 and P2, in the case of collision, it means <em class="italic">hashFunction(P</em><sub class="subscript">1</sub><em class="italic">) = hashFunction(P</em><sub class="subscript">2</sub><em class="italic">)</em>.</p>
    <p class="normal">Regardless of the hashing algorithm used, collisions are rare. Otherwise, hashing wouldn’t be useful. However, for some applications, collisions cannot be tolerated. In those cases, we need to use a hashing algorithm that is more complex but much less likely to generate hash values that collide.</p>
    <h3 id="_idParaDest-506" class="heading-3">Implementing cryptographic hash functions</h3>
    <p class="normal">Cryptographic hash <a id="_idIndexMarker1403"/>functions can be implemented by using various algorithms. Let’s take a deeper look at two of them:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">MD5</li>
      <li class="numberedList"><strong class="keyWord">Secure Hashing Algorithm</strong> (<strong class="keyWord">SHA</strong>)</li>
    </ol>
    <h4 class="heading-4">Understanding MD5-tolerated</h4>
    <p class="normal">MD5 was developed by Poul-Henning Kamp in 1994 to replace MD4. It generates a 128-bit hash. Generating a 128-bit hash means that the resulting hash value is made up of 128 binary digits (bits). </p>
    <p class="normal">This translates to a fixed length of 16 bytes or 32 hexadecimal characters. The fixed <a id="_idIndexMarker1404"/>length ensures that no matter the size of the original data, the hash will always be 128 bits long. The purpose <a id="_idIndexMarker1405"/>of this fixed-length output is to create a “fingerprint” or “digest” of the original data. MD5 is a relatively simple algorithm that is vulnerable to collision. In applications where a collision cannot be tolerated, MD5 should not be used. For example, it can be used to check the integrity of files downloaded from the internet.</p>
    <p class="normal">Let’s look at an example. In order to generate an MD5 hash in Python, we will start by using the <code class="inlineCode">hashlib</code> module, which is part of the Python Standard Library and provides a range of different cryptographic hashing algorithms: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> hashlib
</code></pre>
    <p class="normal">Next, we define a utility function called <code class="inlineCode">generate_md5_hash()</code>, which takes <code class="inlineCode">input_string</code> as a parameter. This string will be hashed by the function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_md5_hash</span>(<span class="hljs-params">input_string</span>):
    <span class="hljs-comment"># Create a new md5 hash object</span>
    md5_hash = hashlib.md5()
    <span class="hljs-comment"># Encode the input string to bytes and hash it</span>
    md5_hash.update(input_string.encode())
    <span class="hljs-comment"># Return the hexadecimal representation of the hash</span>
    <span class="hljs-keyword">return</span> md5_hash.hexdigest()
</code></pre>
    <p class="normal">Note that <code class="inlineCode">hashlib.md5()</code> creates a new hash object. This object uses the MD5 algorithm and <code class="inlineCode">md5_hash.update(input_string.encode())</code> updates the hash object with the bytes of the input string. The string is encoded to bytes using the default UTF-8 encoding. After all data has been updated in the hash object, we can call the <code class="inlineCode">hexdigest()</code> method to return the hexadecimal representation of the digest. This is the MD5 hash of the input string.</p>
    <p class="normal">Here we use the <code class="inlineCode">generate_md5_hash()</code> function to get the MD5 hash of the string <code class="inlineCode">"Hello, World!"</code>, and print the result to the console:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">verify_md5_hash</span>(<span class="hljs-params">input_string, correct_hash</span>):
    <span class="hljs-comment"># Generate md5 hash for the input_string</span>
    computed_hash = generate_md5_hash(input_string)
    <span class="hljs-comment"># Compare the computed hash with the provided hash</span>
    <span class="hljs-keyword">return</span> computed_hash == correct_hash
<span class="hljs-comment"># Test</span>
input_string = <span class="hljs-string">"Hello, World!"</span>
hash_value = generate_md5_hash(input_string)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Generated hash: </span><span class="hljs-subst">{hash_value}</span><span class="hljs-string">"</span>)
correct_hash = hash_value
<span class="hljs-built_in">print</span>(verify_md5_hash(input_string, correct_hash))<span class="hljs-comment"># This should return True</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Generated hash: 65a8e27d8879283831b664bd8b7f0ad4
True
</code></pre>
    <p class="normal">In the <code class="inlineCode">verify_md5_hash</code> function, we take an input string and a known correct MD5 hash. We generate <a id="_idIndexMarker1406"/>the MD5 hash of the <a id="_idIndexMarker1407"/>input string using our <code class="inlineCode">generate_md5_hash</code> function and then compare it to the known correct hash. </p>
    <h4 class="heading-4">When to use MD5</h4>
    <p class="normal">Looking back at history, weaknesses with MD5 were discovered in the late 1990s. Despite several issues, MD5 usage is still popular. It is ideal to be used for integrity checks for data. Note that <a id="_idIndexMarker1408"/>the MD5 message digest does not uniquely associate the hash with its owner as the MD5 digest is not a signed hash. MD5 is used to prove that a file has not been changed since the hash was computed. It is not used to prove the authenticity of a file. Now, let’s look at another hashing algorithm—SHA.</p>
    <h4 class="heading-4">Understanding Secure Hashing Algorithm (SHA)</h4>
    <p class="normal">SHA was developed by the <strong class="keyWord">National Institute of Standards and Technology</strong> (<strong class="keyWord">NIST</strong>). It’s widely used to <a id="_idIndexMarker1409"/>verify the integrity of data. Among <a id="_idIndexMarker1410"/>its variations, SHA-512 is a popular hash function, and Python’s <code class="inlineCode">hashlib</code> library includes it. Let’s see how we can use Python to create a hash using the SHA algorithm. For that, let us first import the <code class="inlineCode">hashlib</code> library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> hashlib
</code></pre>
    <p class="normal">Then we will define the salt and the message. Salting is the practice of adding random characters to a password before hashing. It enhances security by making hash collisions more challenging:</p>
    <pre class="programlisting code"><code class="hljs-code">salt = <span class="hljs-string">"qIo0foX5"</span>
password = <span class="hljs-string">"myPassword"</span>
</code></pre>
    <p class="normal">Next, we will combine the salt with the password to apply the salting procedure:</p>
    <pre class="programlisting code"><code class="hljs-code">salted_password = salt + password
</code></pre>
    <p class="normal">Then, we will use the <code class="inlineCode">sha512</code> function to create a hash of the salted password:</p>
    <pre class="programlisting code"><code class="hljs-code">sha512_hash = hashlib.sha512()
sha512_hash.update(salted_password.encode())
myHash = sha512_hash.hexdigest()
</code></pre>
    <p class="normal">Let us print <code class="inlineCode">myHash</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">myHash
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">2e367911b87b12f73b135b1a4af9fac193a8064d3c0a52e34b3a52a5422beed2b6276eabf9
5abe728f91ba61ef93175e5bac9a643b54967363ffab0b35133563
</code></pre>
    <p class="normal">Note that when we use the SHA algorithm, the hash generated is 512 bytes. This specific size isn’t arbitrary, but rather a key component of the algorithm’s security features. A larger hash size<a id="_idIndexMarker1411"/> corresponds to an <a id="_idIndexMarker1412"/>increased number of potential combinations, thereby reducing the chances of “collisions”—instances where two different inputs produce the same hash output. Collisions compromise the reliability of a hashing algorithm, and SHA-512’s 512-byte output significantly reduces this risk.</p>
    <h3 id="_idParaDest-507" class="heading-3">An application of the cryptographic hash function</h3>
    <p class="normal">Hash functions are used to check the integrity of a file after making a copy of it. To achieve this, when a <a id="_idIndexMarker1413"/>file is copied from a source to a destination (for example, when downloaded from a web server), a corresponding hash is also copied with it. This original hash, <em class="italic">horiginal</em>, acts as a fingerprint of the original file. After copying the file, we generate the hash again from the copied version of the file—that is, <em class="italic">hcopied</em>. If <em class="italic">horiginal = hcopied</em>—that is, the generated hash matches the original hash—this verifies that the file has not changed and none of the data was lost during the download process. We can use any cryptographic hash function, such as MD5 or SHA, to generate a hash for this purpose.</p>
    <h3 id="_idParaDest-508" class="heading-3">Choosing between MD5 and SHA</h3>
    <p class="normal">Both MD5 and SHA are <a id="_idIndexMarker1414"/>hashing algorithms. MD5 is simple and fast, but it does not provide good security. SHA is complex compared to MD5 and it provides a greater level of security.</p>
    <p class="normal">Now, let’s look at symmetric encryption.</p>
    <h2 id="_idParaDest-509" class="heading-2">Using symmetric encryption</h2>
    <p class="normal">In cryptography, a <a id="_idIndexMarker1415"/>key is a combination of numbers that is used to encode plain text using an algorithm of our choice. In symmetric <a id="_idIndexMarker1416"/>encryption, we use the same key for encryption and decryption. If the key used for symmetric encryption is <em class="italic">K</em>, then for symmetric encryption, the following equation holds:</p>
    <p class="center"><em class="italic">EK(P) = C</em></p>
    <p class="normal">Here, <em class="italic">P</em> is the plain text and <em class="italic">C</em> is the cipher text.</p>
    <p class="normal">For decryption, we use the same key, <em class="italic">K</em>, to convert it back to <em class="italic">P</em>:</p>
    <p class="center"><em class="italic">DK(C) = P</em></p>
    <p class="normal">This process is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.4: Symmetric encryption</p>
    <p class="normal">Now, let’s look at how we can use symmetric encryption with Python.</p>
    <h3 id="_idParaDest-510" class="heading-3">Coding symmetric encryption</h3>
    <p class="normal">In this section, we’ll <a id="_idIndexMarker1417"/>explore how to work with hash functions using Python’s built-in <code class="inlineCode">hashlib</code> library. <code class="inlineCode">hashlib</code> comes pre-installed with Python and provides a wide array of hashing algorithms. First, let us import the <code class="inlineCode">hashlib</code> library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> hashlib
</code></pre>
    <p class="normal">We’ll use the SHA-256 algorithm to create our hash. Other algorithms like MD5, SHA-1, etc., can also be used:</p>
    <pre class="programlisting code"><code class="hljs-code">sha256_hash = hashlib.sha256()
</code></pre>
    <p class="normal">Let’s create a hash for the message <code class="inlineCode">"Ottawa is really cold"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">message = <span class="hljs-string">"</span><span class="hljs-string">Ottawa is really cold"</span>.encode()
sha256_hash.update(message)
</code></pre>
    <p class="normal">The hexadecimal <a id="_idIndexMarker1418"/>representation of the hash can be printed with:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(sha256_hash.hexdigest())
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">b6ee63a201c4505f1f50ff92b7fe9d9e881b57292c00a3244008b76d0e026161
</code></pre>
    <p class="normal">Let’s look at some of the advantages of symmetric encryption.</p>
    <h3 id="_idParaDest-511" class="heading-3">The advantages of symmetric encryption</h3>
    <p class="normal">The following are <a id="_idIndexMarker1419"/>the advantages of symmetric encryption:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Simple</strong>: Encryption and decryption using symmetric encryption are simpler to implement.</li>
      <li class="bulletList"><strong class="keyWord">Fast</strong>: Symmetric encryption is faster than asymmetric encryption.</li>
      <li class="bulletList"><strong class="keyWord">Secure</strong>: One of the most widely used symmetric key encryption systems is the U.S. government-designated <strong class="keyWord">Advanced Encryption Standard</strong> (<strong class="keyWord">AES</strong>). When using a <a id="_idIndexMarker1420"/>secure algorithm such as AES, symmetric encryption is at least as secure as asymmetric encryption.</li>
    </ul>
    <h3 id="_idParaDest-512" class="heading-3">The problems with symmetric encryption</h3>
    <p class="normal">When two users or <a id="_idIndexMarker1421"/>processes plan to use symmetric encryption to communicate, they need to exchange keys using a secure channel. This gives rise to the following two problems:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Key protection</strong>: How to protect the symmetric encryption key</li>
      <li class="bulletList"><strong class="keyWord">Key distribution</strong>: How to share the symmetric encryption key from the source to the destination</li>
    </ul>
    <p class="normal">Now, let’s look at asymmetric encryption.</p>
    <h2 id="_idParaDest-513" class="heading-2">Asymmetric encryption</h2>
    <p class="normal">In the 1970s, asymmetric encryption was devised to address some of the weaknesses of symmetric <a id="_idIndexMarker1422"/>encryption that we discussed in the <a id="_idIndexMarker1423"/>previous section.</p>
    <p class="normal">The first step in asymmetric encryption is to generate two different keys that look totally different but are algorithmically related. One of them is chosen as the private key, <em class="italic">Kpr</em>, and the other one is chosen as the public key, <em class="italic">Kpu</em>. The choice of which one of the two keys is public or private is arbitrary. Mathematically, we can represent this as follows:</p>
    <p class="center"><em class="italic">EKpr(P) = C</em></p>
    <p class="normal">Here, <em class="italic">P</em> is the plain text and <em class="italic">C</em> is the cipher text.</p>
    <p class="normal">We can decrypt it as follows:</p>
    <p class="center"><em class="italic">DKpu(C) = P</em></p>
    <p class="normal">Public keys are supposed to be freely distributed and private keys are kept secret by the owner of the key pair. For instance, in AWS, key pairs are used to secure connections to virtual instances and manage encrypted resources. The public key is used by others to encrypt data or verify signatures, while the private key, securely stored by the owner, is used to decrypt data or sign digital content. By adhering to the principle of keeping the private key secret and the public key accessible, AWS users can ensure secure communication and data integrity within their cloud environment. This separation between public and private keys is a cornerstone in the security and trust mechanisms within AWS and other cloud services.</p>
    <p class="normal">The fundamental principle is that if you encrypt with one of the keys, the only way to decrypt it is by using the other key. For example, if we encrypt the data using the public key, we will need to decrypt it using the other key—that is, the private key. </p>
    <p class="normal">Now, let’s look at one of the fundamental protocols of asymmetric encryption—the <strong class="keyWord">Secure Sockets Layer</strong> (<strong class="keyWord">SSL</strong>)/<strong class="keyWord">Transport Layer Security</strong> (<strong class="keyWord">TLS</strong>) handshake—which is responsible for establishing <a id="_idIndexMarker1424"/>a connection between two nodes using asymmetric encryption.</p>
    <h3 id="_idParaDest-514" class="heading-3">The SSL/TLS handshaking algorithm</h3>
    <p class="normal">SSL was originally <a id="_idIndexMarker1425"/>developed to add security to HTTP. Over time, SSL was replaced with a more efficient and more secure protocol, called TLS. TLS handshakes are the basis of how HTTP creates a secure communication <a id="_idIndexMarker1426"/>session. A TLS handshake occurs between the two participating entities—the client and the server. This process is shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_05.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.5: Secure session between the client and the server</p>
    <p class="normal">A TLS handshake establishes a secure connection between the participating nodes. The following are the <a id="_idIndexMarker1427"/>steps that are involved in this process:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The client sends a <code class="inlineCode">client hello</code> message to the server. The message also contains the following:<ul>
          <li class="bulletList">The version of TLS that is used</li>
          <li class="bulletList">The list of cipher suites supported by the client</li>
          <li class="bulletList">A compression algorithm</li>
          <li class="bulletList">A random byte string, identified by <code class="inlineCode">byte_client</code></li>
        </ul>
      </li>
      <li class="numberedList">The server sends a <code class="inlineCode">server hello</code> message back to the client. The message also contains the following:<ul>
          <li class="bulletList">A cipher suite selected by the server from the list provided by the client.</li>
          <li class="bulletList">A session ID.</li>
          <li class="bulletList">A random byte string, identified by <code class="inlineCode">byte_server</code>.</li>
          <li class="bulletList">A server digital certificate, identified by <code class="inlineCode">cert_server</code>, containing the public key of the server.</li>
          <li class="bulletList">If the server requires a digital certificate for client authentication or a client certificate request, the client-server request also includes the following:<ul>
              <li class="bulletList">The distinguished names of the acceptable CAs</li>
              <li class="bulletList">The types of certificates supported</li>
            </ul>
          </li>
          <li class="bulletList">The client verifies <code class="inlineCode">cert_server</code>.</li>
          <li class="bulletList">The client generates a random byte string, identified by <code class="inlineCode">byte_client2</code>, and encrypts it with the public key of the server provided through <code class="inlineCode">cert_server</code>.</li>
          <li class="bulletList">The client generates a random byte string and identifies and encrypts it with its own private key.</li>
          <li class="bulletList">The server verifies the client certificate.</li>
          <li class="bulletList">The client sends a <code class="inlineCode">finished</code> message to the server, which is encrypted with a secret key.</li>
          <li class="bulletList">To acknowledge this from the server side, the server sends a <code class="inlineCode">finished</code> message to the client, which is encrypted with a secret key.</li>
          <li class="bulletList">The server <a id="_idIndexMarker1428"/>and client have now established a secure channel. They can now exchange messages that are symmetrically encrypted with the shared secret key. The entire methodology is shown as follows:</li>
        </ul>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18046_14_06.png" alt="Chart, timeline  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.6: Secure session between the client and the server</p>
    <p class="normal">Now, let’s discuss how<a id="_idIndexMarker1429"/> we can use asymmetric encryption to create <strong class="keyWord">Public Key Infrastructure</strong> (<strong class="keyWord">PKI</strong>), which is created to meet one or more security goals for an organization.</p>
    <h3 id="_idParaDest-515" class="heading-3">Public key infrastructure</h3>
    <p class="normal">Asymmetric encryption is used to implement PKI. PKI is one of the most popular and reliable ways to manage encryption keys for an organization. All the participants trust a central trusting authority called a <strong class="keyWord">Certification Authority</strong> (<strong class="keyWord">CA</strong>). CAs verify the identity of individuals and <a id="_idIndexMarker1430"/>organizations and then issue them digital <a id="_idIndexMarker1431"/>certificates (a digital certificate contains a <a id="_idIndexMarker1432"/>copy of a person or organization’s public key and its identity), verifying that the public key associated with that individual or organization <a id="_idIndexMarker1433"/>actually belongs to that individual or organization.</p>
    <p class="normal">The way it works is that the CA asks a user to prove their identity. The basic validation is called domain validation, which <a id="_idIndexMarker1434"/>could involve simply verifying ownership of a domain name. The extended validation, if needed, involves a more rigorous process that involves physical proof of identity, depending on the type of digital certificate that a user is trying to obtain. If the CA is satisfied that the user is indeed who they claim to be, the user then provides the CA with their public encryption key over a secure channel. </p>
    <p class="normal">The CA uses this information to create a digital certificate that contains information about the user’s identity and their public key. This certificate is digitally signed by the CA. The certificate is a public entity as the user can then show their certificate to anyone who wants to verify their identity, without having to send it through a secure channel, as the certificate doesn’t contain any sensitive information itself. The person receiving the certificate does not have to verify the user’s identity directly. That person <a id="_idIndexMarker1435"/>can simply verify that the certificate <a id="_idIndexMarker1436"/>is valid by verifying the CA’s digital signature, which validates that the public key contained in the certificate does, in fact, belong to the individual or organization named on the certificate.</p>
    <div class="note">
      <p class="normal">The private key of the CA of an organization is the weakest link in the PKI chain of trust. If an impersonator got hold of Microsoft’s private key, for example, they could install malicious software on millions of computers around the world by impersonating a Windows update.</p>
    </div>
    <h3 id="_idParaDest-516" class="heading-3">Blockchain and cryptography</h3>
    <p class="normal">There is no doubt that in recent years there has been a lot of excitement around blockchain and cryptocurrency. Blockchain is said to be one of the most secure technologies ever <a id="_idIndexMarker1437"/>invented. The excitement about blockchain started <a id="_idIndexMarker1438"/>with Bitcoin and digital currencies. Digital currencies <a id="_idIndexMarker1439"/>were first developed in 1980, but with Bitcoin, they became <a id="_idIndexMarker1440"/>mainstream. The rise of Bitcoin was due to the widespread availability of distributed systems. It has two important characteristics that made it a game-changer:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">It is decentralized by design. It uses a network of miners and a distributed algorithm called blockchain. </li>
      <li class="numberedList">Bitcoin is based on inherent incentives for miners to compete to add a block to the blockchain by attempting to answer a very complex computational puzzle. The winning miner is eligible to claim different bitcoins as a reward for their effort.</li>
    </ol>
    <p class="normal">Although blockchain was developed for Bitcoin, it has found broader use and applications. Blockchain is <a id="_idIndexMarker1441"/>based on a distributed consensus algorithm, using <strong class="keyWord">Distributed Ledger Technology</strong> (<strong class="keyWord">DLT</strong>). It has the following<a id="_idIndexMarker1442"/> characteristics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Decentralization</strong>: It is based on distributed not centralized architecture. There is no central authority. Each node in a blockchain system is involved in maintaining the integrity of the DLT. There is a consensus among all the participating nodes. In this distributed architecture, the transactions are stored on the nodes <a id="_idIndexMarker1443"/>of the constituent nodes, forming a P2P network. 
    <p class="bulletList">Note that the term “P2P” stands for “Peer-to-Peer,” which means that each node, or “peer,” in the network communicates directly with the others without needing to go through a central server or authority. </p></li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Chain-like formations</strong>: All transactions of blockchain are accumulated in a list of blocks. When several blocks are added, it creates a chain-like formation, which is the reason for its name, blockchain. </li>
      <li class="bulletList"><strong class="keyWord">Immutability</strong>: The data is secure, replicated, and stored in immutable blocks. </li>
      <li class="bulletList"><strong class="keyWord">Reliability</strong>: A lineage or history is maintained for each transaction. Each transaction is verified and recorded using cryptographic techniques.</li>
    </ul>
    <p class="normal">Under the hood, blockchain transactions use cryptographic hashes from each of the previous blocks in the <a id="_idIndexMarker1444"/>chain. Hash functions are used to create a one-way fingerprint of an arbitrary <a id="_idIndexMarker1445"/>chunk of data. A Merkle tree or hash tree is used to verify data stored, handled, and transferred between different participating nodes. It uses SHA-2 for hashing. A diagram of a particular transaction is shown below:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_07.png" alt="A diagram of a hashtag  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.7: The Merkle tree of blockchain</p>
    <p class="normal"><em class="italic">Figure 13.7</em> summarizes the workings of blockchain. It shows how transactions get converted into blocks, which are, in turn, converted into chains. On the left-hand side, four transactions, A, B, C, and D, are shown. Next, the Merkle root is created by applying a hash function. The Merkle root can be considered a data structure that forms part of the block header. As <a id="_idIndexMarker1446"/>transactions are immutable, the previously <a id="_idIndexMarker1447"/>recorded transactions cannot be changed. </p>
    <p class="normal">Note that the hash value of the previous block header also becomes part of the <a id="_idIndexMarker1448"/>block, thus incorporating transaction records. This creates<a id="_idIndexMarker1449"/> chain-like processing structures and is the reason for the name blockchain.</p>
    <p class="normal">Each blockchain user is authenticated and authorized using cryptography, eliminating the need for third-party authentication and authorization. Digital signatures are used to secure transactions as well. The receiver of a transaction has a public key. Blockchain technology eliminates the involvement of third parties for transaction validation and relies on cryptographic proof for this. Transactions are secured using a digital signature. Each user has a unique private key that establishes their digital identity in the system.</p>
    <h1 id="_idParaDest-517" class="heading-1">Example: security concerns when deploying a machine learning model</h1>
    <p class="normal">In <em class="chapterRef">Chapter 6</em>, <em class="italic">Unsupervised Machine Learning Algorithms</em>, we looked at the <strong class="keyWord">Cross-Industry Standard Process for Data Mining</strong> (<strong class="keyWord">CRISP-DM</strong>) life cycle, which specifies the different phases of <a id="_idIndexMarker1450"/>training and deploying a machine learning model. Once<a id="_idIndexMarker1451"/> a model is trained and evaluated, the final phase is deployment. If it is a critical machine learning model, then we want to make sure that all of its security goals are met.</p>
    <p class="normal">Let’s analyze the common challenges faced in deploying a model such as this and how we can address those challenges using the concepts discussed in this chapter. We will discuss strategies to protect our trained model against the following three challenges:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Man-in-the-Middle</strong> (<strong class="keyWord">MITM</strong>) attacks</li>
      <li class="bulletList">Masquerading</li>
      <li class="bulletList">Data tempering</li>
    </ul>
    <p class="normal">Let’s look at them one by one.</p>
    <h2 id="_idParaDest-518" class="heading-2">MITM attacks</h2>
    <p class="normal">One of the possible <a id="_idIndexMarker1452"/>attacks that we would want to protect our model against is MITM attacks. A MITM attack occurs <a id="_idIndexMarker1453"/>when an intruder tries to eavesdrop on a supposedly private communication.</p>
    <p class="normal">Let’s try to understand MITM attacks sequentially using an example scenario.</p>
    <p class="normal">Let’s assume that Bob and Alice want to exchange messages using PKI:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Bob is using {<em class="italic">Pr</em><sub class="subscript">Bob</sub>, <em class="italic">Pu</em><sub class="subscript">Bob</sub>} and Alice is using {<em class="italic">Pr</em><sub class="subscript">Alice</sub>, <em class="italic">Pu</em><sub class="subscript">Alice</sub>}. Bob has created a message, <em class="italic">M</em><sub class="subscript">Bob</sub>, and Alice has created a message, <em class="italic">M</em><sub class="subscript">Alice</sub>. They want to exchange these messages with each other in a secure way.</li>
      <li class="numberedList">Initially, they need to exchange their public keys to establish a secure connection with each other. This means that Bob uses <em class="italic">Pu</em><sub class="subscript">Alice</sub> to encrypt <em class="italic">M</em><sub class="subscript">Bob</sub> before sending the message to Alice.</li>
      <li class="numberedList">Let’s assume that we have an eavesdropper, commonly referred to as Eve X, who is using {<em class="italic">Pr</em><sub class="subscript">X</sub>, <em class="italic">Pu</em><sub class="subscript">X</sub>}. The attacker is able to intercept the public key exchanges between Bob and Alice and replace them with its own public certificate.</li>
      <li class="numberedList">Bob sends <em class="italic">M</em><sub class="subscript">Bob</sub> to Alice, encrypting it with <em class="italic">Pu</em><sub class="subscript">X</sub> instead of <em class="italic">Pu</em><sub class="subscript">Alice</sub>, wrongfully thinking that this is Alice’s public certificate. Eavesdropper <em class="italic">X</em> intercepts the communication. It intercepts the <em class="italic">M</em><sub class="subscript">Bob</sub> message and decrypts it using <em class="italic">Pr</em><sub class="subscript">Bob</sub>.</li>
    </ol>
    <p class="normal">This MITM attack is <a id="_idIndexMarker1454"/>shown in the <a id="_idIndexMarker1455"/>following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18046_14_08.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 14.8: MITM attack</p>
    <p class="normal">Now, let’s look at how we can prevent MITM attacks.</p>
    <h3 id="_idParaDest-519" class="heading-3">How to prevent MITM attacks</h3>
    <p class="normal">Let’s explore how we can prevent MITM attacks by introducing a CA to the organization. Let’s say the name of this CA is myTrustCA. The digital certificate has its public key, named <code class="inlineCode">PumyTrustCA</code>, embedded in it. myTrustCA is responsible for signing the certificates for all of the <a id="_idIndexMarker1456"/>people in the organization, including Alice and Bob. This means that both Bob and Alice have their certificates signed by myTrustCA. When signing their certificates, myTrustCA verifies that they are indeed who they claim to be.</p>
    <p class="normal">Now, with this new arrangement in place, let’s revisit the sequential interaction between Bob and Alice:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Bob is using {<em class="italic">Pr</em><sub class="subscript">Bob</sub>, <em class="italic">Pu</em><sub class="subscript">Bob</sub>} and Alice is using {<em class="italic">Pr</em><sub class="subscript">Alice</sub>, <em class="italic">Pu</em><sub class="subscript">Alice</sub>}. Both of their public keys are embedded into their digital certificates, signed by myTrustCA. Bob has created a message, <em class="italic">M</em><sub class="subscript">Bob</sub>, and Alice has created a message, <em class="italic">M</em><sub class="subscript">Alice</sub>. They want to exchange these messages with each other in a secure way.</li>
      <li class="numberedList">They exchange their digital certificates, which contain their public keys. They will only accept the public keys if they are embedded in the certificates signed by the CA they trust. They need to exchange their public keys to establish a secure connection with each other. This means that Bob will use <em class="italic">Pu</em><sub class="subscript">Alice</sub> to encrypt <em class="italic">M</em><sub class="subscript">Bob</sub> before sending the message to Alice.</li>
      <li class="numberedList">Let’s assume that we have an eavesdropper, X, who is using {<em class="italic">Pr</em><sub class="subscript">X</sub>, <em class="italic">Pu</em><sub class="subscript">X</sub>}. The attacker is able to intercept the public key exchanges between Bob and Alice and replace them with its own public certificate, <em class="italic">Pu</em><sub class="subscript">X</sub>.</li>
      <li class="numberedList">Bob rejects <em class="italic">X</em>’s attempt, as the bad guy’s digital certificate is not signed by the CA that Bob trusts. The secure handshake is aborted, the attempted attack is logged with a timestamp and all details, and a security exception is raised.</li>
    </ol>
    <p class="normal">When deploying a <a id="_idIndexMarker1457"/>trained machine learning model, instead of Alice, there is a deployment server. Bob only deploys the model after establishing a secure channel, using the previously mentioned steps.</p>
    <h2 id="_idParaDest-520" class="heading-2">Avoiding masquerading</h2>
    <p class="normal">Attacker X pretends <a id="_idIndexMarker1458"/>to be an authorized user, Bob, and gains access to sensitive data, which is the trained model, in this case. We need to protect the model against any unauthorized changes.</p>
    <p class="normal">One way of protecting our trained model against masquerading is by encrypting the model with an authorized user’s private key. Once encrypted, anyone can read and utilize the model by decrypting it through the public key of the authorized user, which is found in their digital certificate. No one can make any unauthorized changes to the model.</p>
    <h2 id="_idParaDest-521" class="heading-2">Data and model encryption</h2>
    <p class="normal">Once the model is deployed, the real-time unlabeled data that is provided as input to the model can also be <a id="_idIndexMarker1459"/>tampered with. The trained model is used for inference and provides a label for this data. To protect data against tampering, we need to protect the data at rest and in <a id="_idIndexMarker1460"/>communication. To protect the data at rest, symmetric encryption can be used to encode it. </p>
    <p class="normal">To transfer the data, SSL-/TLS-based secure channels can be established to provide a secure tunnel. This secure tunnel can be used to transfer the symmetric key and the data can be decrypted on the server before it is provided to the trained model.</p>
    <p class="normal">This is one of the more efficient and foolproof ways to protect data against tampering.</p>
    <p class="normal">Symmetric encryption can also be used to encrypt a model when it has been trained, before deploying it to a server. This will prevent any unauthorized access to the model before it is deployed.</p>
    <p class="normal">Let’s see how we can encrypt a trained model at the source, using symmetric encryption with the help of the following steps, and then decrypt it at the destination before using it:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Let’s first train a simple model using the Iris dataset:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">from</span> joblib <span class="hljs-keyword">import</span> dump, load
<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris
<span class="hljs-keyword">from</span> cryptography.fernet <span class="hljs-keyword">import</span> Fernet
iris = load_iris()
X = iris.data
y = iris.target
X_train, X_test, y_train, y_test = train_test_split(X, y)
model = LogisticRegression(max_iter=<span class="hljs-number">1000</span>)  <span class="hljs-comment"># Increase max_iter for convergence</span>
model.fit(X_train, y_train)
</code></pre>
      </li>
      <li class="numberedList">Now, let’s define the names of the files that will store the model:
        <pre class="programlisting code"><code class="hljs-code">filename_source = <span class="hljs-string">"unencrypted_model.pkl"</span>
filename_destination = <span class="hljs-string">"decrypted_model.pkl"</span>
filename_sec = <span class="hljs-string">"encrypted_model.pkl"</span>
</code></pre>
      </li>
      <li class="numberedList">Note that <code class="inlineCode">filename_source</code> is the file that will store the trained unencrypted <a id="_idIndexMarker1461"/>model at the source. <code class="inlineCode">filename_destination</code> is the file that will store the <a id="_idIndexMarker1462"/>trained unencrypted model at the destination, and <code class="inlineCode">filename_sec</code> is the encrypted trained model.</li>
      <li class="numberedList">We will use <code class="inlineCode">pickle</code> to store the trained model in a file:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> joblib <span class="hljs-keyword">import</span> dump
dump(model, filename_source)
</code></pre>
      </li>
      <li class="numberedList">Let’s define a function named <code class="inlineCode">write_key()</code> that will generate a symmetric key and store it in a file named <code class="inlineCode">key.key</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">write_key</span>():
     key = Fernet.generate_key()
     <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"</span><span class="hljs-string">key.key"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> key_file:
         key_file.write(key)
</code></pre>
      </li>
      <li class="numberedList">Now, let’s define a function named <code class="inlineCode">load_key()</code> that can read the stored key from the <code class="inlineCode">key.key</code> file:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">load_key</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"key.key"</span>, <span class="hljs-string">"rb"</span>).read()
</code></pre>
      </li>
      <li class="numberedList">Next, let’s define an <code class="inlineCode">encrypt()</code> function that can encrypt and train the model, and store it in a file named <code class="inlineCode">filename_sec</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">filename, key</span>):
     f = Fernet(key)
     <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> file:         
         file_data = file.read() 
     encrypted_data = f.encrypt(file_data)
     <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename_sec,<span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> file:
         file.write(encrypted_data)
</code></pre>
      </li>
      <li class="numberedList">We will use these functions to generate a symmetric key and store it in a file. Then, we will read this key and use it to store our trained model in a file named <code class="inlineCode">filename_sec</code>:
        <pre class="programlisting code"><code class="hljs-code">write_key()
key = load_key()
encrypt(filename_source, key)
</code></pre>
      </li>
    </ol>
    <p class="normal">Now the <a id="_idIndexMarker1463"/>model is encrypted. It will <a id="_idIndexMarker1464"/>be transferred to the destination where it will be used for prediction:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we will define a function named <code class="inlineCode">decrypt()</code> that we can use to decrypt the model from <code class="inlineCode">filename_sec</code> to <code class="inlineCode">filename_destination</code> using the key stored in the <code class="inlineCode">key.key</code> file:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">filename, key</span>):
    f = Fernet(key)
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> file:
        encrypted_data = file.read()        
    decrypted_data = f.decrypt(encrypted_data)
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename_destination, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> file:
        file.write(decrypted_data)
</code></pre>
      </li>
      <li class="numberedList">Now let’s use this function to decrypt the model and store it in a file named <code class="inlineCode">filename_destination</code>:
        <pre class="programlisting code"><code class="hljs-code">decrypt(filename_sec, key)
</code></pre>
      </li>
      <li class="numberedList">Now let’s use this unencrypted file to load the model and use it for predictions:
        <pre class="programlisting code"><code class="hljs-code">loaded model = load(filename_destination)
result = loaded_model.score(X_test, y_test)
<span class="hljs-built_in">print</span>(result)
</code></pre>
        <pre class="programlisting con"><code class="hljs-con">0.9473684210526315
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that we have <a id="_idIndexMarker1465"/>used symmetric encryption to encode the model. The same technique can be used <a id="_idIndexMarker1466"/>to encrypt data as well, if needed.</p>
    <h1 id="_idParaDest-522" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we learned about cryptographic algorithms. We started by identifying the security goals of a problem. We then discussed various cryptographic techniques and also looked at the details of the PKI. Finally, we looked at the different ways of protecting a trained machine learning model against common attacks. Now, you should be able to understand the fundamentals of security algorithms used to protect modern IT infrastructures.</p>
    <p class="normal">In the next chapter, we will look at designing large-scale algorithms. We will study the challenges and trade-offs involved in designing and selecting large algorithms. We will also look at the use of a GPU and clusters to solve complex problems.</p>
    <h1 id="_idParaDest-523" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>