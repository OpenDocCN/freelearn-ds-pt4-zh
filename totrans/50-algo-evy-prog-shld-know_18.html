<html><head></head><body>
  <div id="_idContainer486" class="Basic-Text-Frame">
    <h1 class="chapterNumber">15</h1>
    <h1 id="_idParaDest-524" class="chapterTitle">Large-Scale Algorithms</h1>
    <p class="normal">Large-scale algorithms are specifically designed to tackle sizable and intricate problems. They distinguish themselves by their demand for multiple execution engines due to the sheer volume of data and processing requirements. Examples of such algorithms include <strong class="keyWord">Large Language Models</strong> (<strong class="keyWord">LLMs</strong>) like ChatGPT, which require distributed model training to manage the extensive computational demands inherent to deep learning. The resource-intensive nature of such complex algorithms highlights the requirement for robust, parallel processing techniques critical for training the model.</p>
    <p class="normal">In this chapter, we will start by introducing the concept of large-scale algorithms and then proceed to discuss the efficient infrastructure required to support them. Additionally, we will explore various strategies for managing multi-resource processing. Within this chapter, we will examine the limitations of parallel processing, as outlined by Amdahl’s law, and investigate the use of <strong class="keyWord">Graphics Processing Units</strong> (<strong class="keyWord">GPUs</strong>). Upon completing this chapter, you will have gained a solid foundation in the fundamental strategies essential for designing large-scale algorithms. </p>
    <p class="normal">The topics covered in this chapter include:</p>
    <ul>
      <li class="bulletList">Introduction to large-scale algorithms</li>
      <li class="bulletList">Efficient infrastructure for large-scale algorithms</li>
      <li class="bulletList">Strategizing multi-resource processing</li>
      <li class="bulletList">Using the power of clusters/cloud to run large-scale algorithms</li>
    </ul>
    <p class="normal">Let’s start with the introduction.</p>
    <h1 id="_idParaDest-525" class="heading-1">Introduction to large-scale algorithms</h1>
    <p class="normal">Throughout history, humans have tackled complex problems, from predicting locust swarm locations to discovering the largest prime numbers. Our curiosity and determination have led to continuous innovation in problem-solving methods. The invention of computers was a <a id="_idIndexMarker1467"/>pivotal moment in this journey, giving us the ability to handle intricate algorithms and calculations. Nowadays, computers enable us to process massive datasets, execute complex computations, and simulate various scenarios with remarkable speed and accuracy.</p>
    <p class="normal">However, as we encounter increasingly complex challenges, the resources of a single computer often prove insufficient. This is where large-scale algorithms come into play, harnessing the combined power of multiple computers working together. Large-scale algorithm design constitutes a dynamic and extensive field within computer science, focusing on creating and analyzing algorithms that efficiently utilize the computational resources of numerous machines. These large-scale algorithms allow two types of computing – distributed and parallel. In distributed computing, we divide a single task between multiple computers. They each work on a segment of the task and combine their results at the end. Think of it like assembling a car: different workers handle different parts, but together, they build the entire vehicle. Parallel computing, conversely, involves multiple processors performing multiple tasks simultaneously, similar to an assembly line where every worker does a different job at the same time.</p>
    <p class="normal">LLMs, such as OpenAI’s GPT-4, hold a crucial position in this vast domain, as they represent a form of large-scale algorithms. LLMs are designed to comprehend and generate human-like text by processing extensive amounts of data and identifying patterns within languages. However, training these models is a heavy-duty task. It involves working with billions, sometimes<a id="_idIndexMarker1468"/> trillions, of data units, known as tokens. This training includes steps that need to be done one by one, like getting the data ready. There are also steps that can be done at the same time, like figuring out the changes needed across different layers of the model.</p>
    <p class="normal">It’s not an understatement to say that this is a massive job. Because of this scale, it’s a common practice to train LLMs using multiple computers at once. We call these “distributed systems.” These systems use several GPUs – these are the parts of computers that do the heavy lifting for creating images or processing data. It’s more accurate to say that LLMs are almost always trained on many machines working together to teach a single model.</p>
    <p class="normal">In this context, let us first characterize a well-designed large-scale algorithm, one that can fully harness the potential of modern computing infrastructure, such as cloud computing, clusters, and GPUs/TPUs.</p>
    <h1 id="_idParaDest-526" class="heading-1">Characterizing performant infrastructure for large-scale algorithms</h1>
    <p class="normal">To efficiently run large-scale algorithms, we want performant systems as they are designed to handle increased workloads by adding more computing resources to distribute the processing. Horizontal <a id="_idIndexMarker1469"/>scaling is a key technique for achieving scalability in distributed systems, enabling the system to expand its capacity by allocating tasks to multiple resources. These resources are typically<a id="_idIndexMarker1470"/> hardware (like <strong class="keyWord">Central Processing Units</strong> (<strong class="keyWord">CPUs</strong>) or GPUs) or software elements (like memory, disk space, or network bandwidth) that the system can utilize to perform tasks. For a scalable system to efficiently address computational requirements, it should exhibit elasticity and load balancing, as discussed in the following section.</p>
    <h2 id="_idParaDest-527" class="heading-2">Elasticity</h2>
    <p class="normal">Elasticity refers to the capacity <a id="_idIndexMarker1471"/>of infrastructure to dynamically scale resources according to changing requirements. One common method of implementing this feature is autoscaling, a prevalent strategy in cloud computing platforms such as <strong class="keyWord">Amazon Web Services</strong> (<strong class="keyWord">AWS</strong>). In the context of cloud computing, a server group is a collection of virtual servers or instances that are <a id="_idIndexMarker1472"/>orchestrated to work together to handle specific workloads. These server groups can be organized into clusters to provide high availability, fault tolerance, and load balancing. Each server within a group can be configured with specific resources, such as CPU, memory, and storage, to perform optimally for the intended tasks. Autoscaling allows the server group to adapt to fluctuating demands by modifying the number of nodes (virtual servers) in operation. In an elastic system, resources can be added (scaling out) to accommodate increased demand, and similarly, resources can be released (scaling in) when the demand decreases. This dynamic adjustment allows for efficient use of resources, helping to balance performance needs with cost-effectiveness.</p>
    <p class="normal">AWS provides an autoscaling service, which integrates with other AWS services like <strong class="keyWord">EC2 </strong>(<strong class="keyWord">Elastic Compute Cloud</strong>) and <strong class="keyWord">ELB</strong> (<strong class="keyWord">Elastic Load Balancing</strong>), to automatically<a id="_idIndexMarker1473"/> adjust the number of server instances<a id="_idIndexMarker1474"/> in the group. This ensures optimal resource allocation and consistent performance, even<a id="_idIndexMarker1475"/> during periods of heavy traffic or system failures.</p>
    <h2 id="_idParaDest-528" class="heading-2">Characterizing a well-designed, large-scale algorithm</h2>
    <p class="normal">A well-designed, large-scale algorithm is capable of processing vast amounts of information and is designed to be adaptable, resilient, and efficient. It is resilient and adaptable to accommodate the<a id="_idIndexMarker1476"/> fluctuating dynamics of a large-scale environment. </p>
    <p class="normal">A well-designed, large-scale algorithm has the following two characteristics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Parallelism</strong>: Parallelism is a<a id="_idIndexMarker1477"/> feature that lets an algorithm do several things at<a id="_idIndexMarker1478"/> once. For big computing jobs, an algorithm should be able to divide tasks between many computers. This speeds up calculations because they are happening all at the same time. In the context of large-scale computing, an algorithm should be capable of splitting tasks across multiple machines, thereby expediting computations through simultaneous processing.</li>
      <li class="bulletList"><strong class="keyWord">Fault tolerance</strong>: Given the<a id="_idIndexMarker1479"/> increased risk of system failures<a id="_idIndexMarker1480"/> in large-scale environments due to the sheer number of components, it’s essential that algorithms are built to withstand these faults. They should be able to recover from failures without substantial loss of data or inaccuracies in output.</li>
    </ul>
    <div class="note">
      <p class="normal">The three cloud computing giants, Google, Amazon, and Microsoft, provide highly elastic infrastructures. Due to the gigantic size of their shared resource pools, there are very few companies that have the potential to match the elasticity of the infrastructure of these three companies.</p>
    </div>
    <p class="normal">The performance of a large-scale algorithm is intricately linked to the quality of the underlying infrastructure. This foundation should provide adequate computational resources, extensive storage capacity, high-speed network connectivity, and reliable performance to ensure the algorithm’s optimal operation. Let us characterize a suitable infrastructure for a large-scale algorithm.</p>
    <h3 id="_idParaDest-529" class="heading-3">Load balancing</h3>
    <p class="normal">Load balancing is an essential practice in large-scale distributed computing algorithms. By evenly managing and<a id="_idIndexMarker1481"/> distributing the workload, it prevents resource overload and maintains high system performance. It plays a significant role in ensuring efficient operations, optimal resource usage, and high throughput in the realm of distributed deep learning. </p>
    <p class="normal"><em class="italic">Figure 15.1</em> illustrates this concept visually. It shows a user interacting with a load balancer, which in turn manages the load on multiple nodes. In this case, there are four nodes, <strong class="keyWord">Node 1</strong>, <strong class="keyWord">Node 2</strong>, <strong class="keyWord">Node 3</strong>, and <strong class="keyWord">Node 4</strong>. The load balancer continually monitors the state of all nodes, distributing incoming user requests between them. The decision to assign a task to a specific node depends on the node’s current load and the load balancer’s algorithm. By preventing any single node from being overwhelmed while others remain underutilized, the load balancer ensures optimal system performance:</p>
    <figure class="mediaobject"><img src="../Images/B18046_15_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.1: Load balancing</p>
    <p class="normal">In the broader context of cloud computing, AWS offers a feature called <strong class="keyWord">Elastic Load Balancing</strong> (<strong class="keyWord">ELB</strong>). ELB automatically distributes incoming application traffic across multiple targets within the AWS ecosystem, such as Amazon EC2 instances, IP addresses, or Lambda functions. By doing this, ELB prevents resource overload and maintains high application availability and performance.</p>
    <h3 id="_idParaDest-530" class="heading-3">ELB: Combining elasticity and load balancing</h3>
    <p class="normal">ELB represents an advanced<a id="_idIndexMarker1482"/> technique that combines the elements of elasticity and load balancing into a single solution. It utilizes clusters of server groups to augment the responsiveness, efficiency, and scalability of computing infrastructure. The objective is to maintain a uniform distribution of workloads across all available <a id="_idIndexMarker1483"/>resources, while simultaneously enabling the infrastructure to dynamically adjust its size in response to demand fluctuations.</p>
    <p class="normal"><em class="italic">Figure 15.2</em> shows a load balancer managing four server groups. Note that a server group is a collection of nodes tasked with specific computational functions. A server group here refers to an assembly of nodes, each given a unique computational role to fulfill. </p>
    <p class="normal">One of the key features of<a id="_idIndexMarker1484"/> a server group is its elasticity – its ability to flexibly add or remove nodes depending on the situation:</p>
    <figure class="mediaobject"><img src="../Images/B18046_15_02.png" alt="Graphical user interface, diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.2: Intelligent load balancing server autoscaling</p>
    <p class="normal">Load balancers operate by continuously monitoring workload metrics in real time. When computational tasks become increasingly complex, the requirement for processing power correspondingly increases. To address this spike in demand, the system triggers a “scale-up” operation, integrating additional nodes into the existing server groups. In this context, “scaling up” is the process of increasing the computational capacity to accommodate the expanded workload. Conversely, when the demand decreases, the infrastructure can initiate a “scale-down” operation, in which some nodes are deallocated. This dynamic reallocation of nodes across server groups ensures an optimal resource utilization ratio. By adapting resource allocation to match the prevailing workload, the system prevents resource over-provisioning or under-provisioning. This dynamic resource management strategy results in an enhancement of operational efficiency and cost-effectiveness, while<a id="_idIndexMarker1485"/> maintaining high-caliber performance.</p>
    <h1 id="_idParaDest-531" class="heading-1">Strategizing multi-resource processing</h1>
    <p class="normal">In the early days of strategizing multi-resource processing, large-scale algorithms were executed on powerful machines <a id="_idIndexMarker1486"/>called supercomputers. These<a id="_idIndexMarker1487"/> monolithic machines had a shared memory space, enabling quick communication between different processors and allowing them to access common variables through the same memory. As the demand for running large-scale algorithms grew, supercomputers<a id="_idIndexMarker1488"/> transformed into <strong class="keyWord">Distributed Shared Memory</strong> (<strong class="keyWord">DSM</strong>) systems, where each processing node owned a segment of the physical memory. Subsequently, clusters emerged, constituting loosely connected systems that depend on message passing between processing nodes.</p>
    <p class="normal">Effectively running large-scale algorithms requires multiple execution engines operating in parallel to tackle intricate challenges. Three<a id="_idIndexMarker1489"/> primary strategies can be utilized to achieve this:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Look within</strong>: Exploit the existing resources on a computer by using the hundreds of cores available on a GPU to execute large-scale algorithms. For instance, a data scientist aiming to train an intricate deep learning model could harness the GPU’s power to augment computing capabilities.</li>
      <li class="bulletList"><strong class="keyWord">Look outside</strong>: Implement distributed computing to access supplementary computing resources that can collaboratively address large-scale issues. Examples include cluster computing and cloud computing, which enable running complex, resource-demanding algorithms by leveraging distributed resources.</li>
      <li class="bulletList"><strong class="keyWord">Hybrid strategy</strong>: Merge distributed computing with GPU acceleration on each node to expedite algorithm execution. A scientific research organization processing vast amounts of data and conducting sophisticated simulations might adopt this approach. As illustrated in <em class="italic">Figure 15.3</em>, the computational workload is distributed across multiple nodes (<strong class="keyWord">Node 1</strong>, <strong class="keyWord">Node 2</strong>, and <strong class="keyWord">Node 3</strong>), each equipped with its own GPU. This figure effectively demonstrates the hybrid strategy, showcasing how simulations and computations are accelerated by capitalizing on the advantages of both distributed computing and GPU acceleration within each node:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B18046_15_03.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 15.3: Hybrid strategy for multi-resource processing</p>
    <p class="normal">As we explore the potential of parallel computing in running large-scale algorithms, it is equally important to understand the theoretical limitations that govern its efficiency. </p>
    <p class="normal">In the following section, we<a id="_idIndexMarker1490"/> will delve into the fundamental constraints of parallel computing, shedding light on the factors that influence its performance and the extent to which it can be optimized.</p>
    <h1 id="_idParaDest-532" class="heading-1">Understanding theoretical limitations of parallel computing</h1>
    <p class="normal">It is important to note that parallel algorithms are not a silver bullet. Even the best-designed parallel architectures may not give<a id="_idIndexMarker1491"/> the performance that we may expect. The complexities of parallel computing, such as communication overhead and synchronization, make it challenging to achieve optimal efficiency. One law that has been developed to help navigate these complexities and better understand the potential gains and limitations of parallel algorithms is Amdahl’s law.</p>
    <h2 id="_idParaDest-533" class="heading-2">Amdahl’s law</h2>
    <p class="normal">Gene Amdahl was one of the first people to study parallel processing in the 1960s. He proposed Amdahl’s law, which is still applicable today and is a basis on which to understand the various trade-offs<a id="_idIndexMarker1492"/> involved when designing a parallel computing solution. Amdahl’s law provides a theoretical limit on the maximum improvement in execution time that can be achieved with a parallelized version of an algorithm, given the proportion of the algorithm that can be parallelized. </p>
    <p class="normal">It is based on the concept that in any computing process, not all processes can be executed in parallel. There will be a sequential portion of the process that cannot be parallelized.</p>
    <h2 id="_idParaDest-534" class="heading-2">Deriving Amdahl’s law</h2>
    <p class="normal">Consider an algorithm or task that can be divided into a parallelizable fraction (<em class="italic">f</em>) and a serial fraction (<em class="italic">1 - f</em>). The parallelizable fraction refers to the portion of the task that can be executed simultaneously across multiple resources or processors. These tasks don’t depend on each other <a id="_idIndexMarker1493"/>and can be run in parallel, hence the term “parallelizable.” On the other hand, the serial fraction is part of the task that cannot be divided and must be executed in sequence, one after the other, hence “serial.”</p>
    <p class="normal">Let <em class="italic">Tp(1)</em> represent the time required to process this task on a single processor. This can be expressed as:</p>
    <p class="center"><em class="italic">T</em><sub class="subscript-italic" style="font-style: italic;">p</sub><em class="italic">(1) = N(1 - f)</em><em class="italic">τ</em><sub class="subscript-italic" style="font-style: italic;">p</sub><em class="italic"> + N(f)</em><em class="italic">τ</em><sub class="subscript-italic" style="font-style: italic;">p</sub><em class="italic"> = N</em><em class="italic">τ</em><sub class="subscript-italic" style="font-style: italic;">p</sub></p>
    <p class="normal">In these equations, <em class="italic">N</em> and <em class="italic">τ</em><em class="italic">p</em> denote:</p>
    <ul>
      <li class="bulletList"><em class="italic">N</em>: The total number of tasks or iterations that the algorithm or task must perform, consistent across both single and parallel processors.</li>
      <li class="bulletList"><em class="italic">τ</em><sub class="subscript-italic" style="font-style: italic;">p</sub>: The time taken by a processor to complete a single unit of work, task, or iteration, which remains constant regardless of the number of processors used.</li>
    </ul>
    <p class="normal">The preceding equation calculates the total time taken to process all tasks on a single processor. Now, let’s examine a scenario where the task is executed on <em class="italic">N</em> parallel processors. </p>
    <p class="normal">The time taken for this execution can be represented as <em class="italic">T</em><sub class="subscript-italic" style="font-style: italic;">p</sub><em class="italic">(N)</em>. In the following diagram, on the X-axis, we have <strong class="keyWord">Number of processors</strong>. This represents the number of computing units or cores used to execute our program. As we move right along the X-axis, we are increasing the number of processors used. The Y-axis represents <strong class="keyWord">Speedup</strong>. This is a measure of how much faster <a id="_idIndexMarker1494"/>our program runs with multiple processors compared to using just one. As we move up the Y-axis, the speed of our program increases proportionally, resulting in more efficient task execution.</p>
    <p class="normal">The graph in <em class="italic">Figure 15.4</em> and Amdahl’s law show us that more processors can improve performance, but there’s a limit due to the sequential part of our code. This principle is a classic example of diminishing returns in parallel computing.</p>
    <p class="center"><em class="italic">N = N(1 - f)</em><em class="italic">τ</em><sub class="subscript-italic" style="font-style: italic;">p</sub><em class="italic"> + (f)</em><em class="italic">τ</em><sub class="subscript-italic" style="font-style: italic;">p</sub></p>
    <p class="normal">Here, the first term <a id="_idIndexMarker1495"/>on the <strong class="keyWord">RHS</strong> (<strong class="keyWord">Right Hand Side</strong>) represents the time taken to process the serial part of the task, while the second term denotes the time taken to process the parallel part.</p>
    <p class="normal">The speedup in this case is due to the distribution of the parallel part of the task over <em class="italic">N</em> processors. Amdahl’s law defines the speedup <em class="italic">S(N)</em> achieved by using <em class="italic">N</em> processors as:</p>
    <p class="center"><img src="../Images/B18046_15_001.png" alt="" role="presentation"/></p>
    <p class="normal">For significant speedup, the following condition must be satisfied:</p>
    <p class="center"><em class="italic">1 - f &lt;&lt; f / N (4.4)</em></p>
    <p class="normal">This inequality indicates that the parallel portion (<em class="italic">f</em>) must be very close to unity, especially when <em class="italic">N</em> is large.</p>
    <p class="normal">Now, let’s look at a typical graph that explains Amdahl’s law:</p>
    <figure class="mediaobject"><img src="../Images/B18046_15_04.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.4: Diminishing returns in parallel processing: visualizing Amdahl’s law</p>
    <p class="normal">In <em class="italic">Figure 15.4</em>, the X-axis<a id="_idIndexMarker1496"/> represents the number of processors (<em class="italic">N</em>), corresponding to the computing units or cores used to execute the program. As we move to the right along the X-axis, <em class="italic">N</em> increases. The Y-axis denotes the speedup (<em class="italic">S</em>), a measure of the improvement in the program’s execution time <em class="italic">T</em><sub class="subscript-italic" style="font-style: italic;">p</sub> with multiple processors compared to using just one. Moving up the Y-axis indicates an increase in the program’s execution speed.</p>
    <p class="normal">The graph features four lines, each representing the speedup <em class="italic">S</em> obtained from parallel processing for different percentages of the parallelizable fraction (<em class="italic">f</em>): 50%, 75%, 90%, and 95%:</p>
    <ul>
      <li class="bulletList">50% parallel (<em class="italic">f = 0.5</em>): This line exhibits the smallest speedup <em class="italic">S</em>. Although more processors (<em class="italic">N</em>) are added, half of the program runs sequentially, limiting the speedup to a maximum of 2.</li>
      <li class="bulletList">75% parallel (<em class="italic">f = 0.75</em>): The speedup <em class="italic">S</em> is higher compared to the 50% case. However, 25% of the program still runs sequentially, constraining the overall speedup.</li>
      <li class="bulletList">90% parallel (<em class="italic">f = 0.9</em>): In this case, a significant speedup <em class="italic">S</em> is observed. Nevertheless, the sequential 10% of the program imposes a limit on the speedup.</li>
      <li class="bulletList">95% parallel (<em class="italic">f = 0.95</em>): This line demonstrates the highest speedup <em class="italic">S</em>. Yet, the sequential 5% still imposes an upper limit on the speedup.</li>
    </ul>
    <p class="normal">The graph, in conjunction with Amdahl’s law, highlights that while increasing the number of processors (<em class="italic">N</em>) can enhance performance, there exists an inherent limit due to the sequential part of the code (<em class="italic">1 - f</em>). This principle serves as a classic illustration of diminishing returns in <a id="_idIndexMarker1497"/>parallel computing.</p>
    <p class="normal">Amdahl’s law provides valuable insights into the potential performance gains achievable in multiprocessor systems and the importance of the parallelizable fraction (<em class="italic">f</em>) in determining the system’s overall speedup. After discussing the theoretical limitations of parallel computing, it is crucial to introduce and explore another powerful and widely-used parallel processing technology: the GPU and its associated programming framework, CUDA.</p>
    <h2 id="_idParaDest-535" class="heading-2">CUDA: Unleashing the potential of GPU architectures in parallel computing</h2>
    <p class="normal">GPUs were originally designed for<a id="_idIndexMarker1498"/> graphics processing but have since evolved, exhibiting distinct characteristics that set them apart from CPUs and resulting in an entirely different computation paradigm.</p>
    <p class="normal">Unlike CPUs, which have a limited number of cores, GPUs are composed of thousands of cores. It’s essential to<a id="_idIndexMarker1499"/> recognize, however, that these cores, in isolation, are not as individually powerful as a CPU core. But, GPUs are quite efficient at executing numerous relatively simple computations in parallel.</p>
    <p class="normal">As GPUs were originally designed for graphic processing, GPU architecture is ideal for graphic processing where multiple operations can be executed independently. For example, rendering an image involves the computation of color and brightness for each pixel in the image. These calculations are largely independent of each other and hence can be conducted simultaneously, leveraging the multi-core architecture of the GPU.</p>
    <h3 id="_idParaDest-536" class="heading-3">Bottom of form</h3>
    <p class="normal">This design choice allows GPUs to be extremely efficient at tasks they’re designed for, like rendering graphics and <a id="_idIndexMarker1500"/>processing large datasets. Here is the architecture of GPUs shown in <em class="italic">Figure 15.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B18046_15_05.png" alt="A picture containing table  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.5: Architecture of GPUs</p>
    <p class="normal">This unique architecture is not only beneficial for graphics processing but also significantly advantageous for other types of computational problems. Any problem that can be segmented into smaller, independent tasks can exploit this architecture for faster processing. This includes domains like scientific computing, machine learning, and even cryptocurrency mining, where massive datasets and complex computations are the norm.</p>
    <p class="normal">Soon after GPUs became mainstream, data scientists started exploring them for their potential to efficiently perform parallel operations. As a typical GPU has thousands of <strong class="keyWord">Arithmetic Logic Units</strong> (<strong class="keyWord">ALUs</strong>), it has the potential to <a id="_idIndexMarker1501"/>spawn thousands of concurrent processes. Note that the ALU is the workhorse of the core that performs most of the actual computations. This large number of ALUs makes GPUs well suited to tasks where the same operation needs to be performed on many data points simultaneously, such as vector and matrix operations common in data science and machine learning. Hence, algorithms that can perform parallel computations are best suited to GPUs. For example, an object search in a video is known to be at least 20 times faster in GPUs, compared to CPUs. Graph algorithms, which were discussed in <em class="chapterRef">Chapter 5</em>, <em class="italic">Graph Algorithms</em>, are known to run much faster on GPUs than on CPUs.</p>
    <p class="normal">In 2007, NVIDIA developed the open-source framework called <strong class="keyWord">Compute Unified Device Architecture</strong> (<strong class="keyWord">CUDA</strong>) to enable data scientists to harness the power of GPUs for their algorithms. CUDA abstracts the CPU and GPU as the host and the device, respectively.</p>
    <p class="normal"><strong class="keyWord">Host </strong>refers to the CPU and main memory, responsible for executing the main program and offloading data-parallel<a id="_idIndexMarker1502"/> computations to the GPU.</p>
    <p class="normal"><strong class="keyWord">Device </strong>refers to the GPU and its memory (VRAM), responsible for executing kernels that perform data-parallel computations.</p>
    <p class="normal">In a typical CUDA program, the host allocates memory on the device, transfers input data, and invokes a kernel. The device performs the computation, and the results are stored back in its memory. The host then retrieves the results. This division of labor leverages the strengths of each component, with the CPU handling complex logic and the GPU managing large-scale, data-parallel computations.</p>
    <p class="normal">CUDA runs on NVIDIA GPUs and requires OS kernel support, initially starting with Linux and later extending to Windows. The CUDA Driver API bridges the programming language API and the CUDA driver, with support for C, C++, and Python.</p>
    <h3 id="_idParaDest-537" class="heading-3">Parallel processing in LLMs: A case study in Amdahl’s law and diminishing returns</h3>
    <p class="normal">LLMs, like ChatGPT, are intricate systems that generate text remarkably similar to human-written prose, given an initial prompt. This task involves a series of complex operations, which can be <a id="_idIndexMarker1503"/>broadly divided into sequential and parallelizable tasks.</p>
    <p class="normal">Sequential tasks are those that must occur in a specific order, one after the other. These tasks may include preprocessing steps like tokenizing, where the input text is broken down into smaller pieces, often words or phrases, which the model can understand. It may also encompass post-processing tasks like decoding, where the model’s output, often in the form of token probabilities, is translated back into human-readable text. These sequential tasks are critical to the function of the model, but by nature, they cannot be split up and run concurrently.</p>
    <p class="normal">On the other hand, parallelizable tasks are those that can be broken down and run simultaneously. A key example of this is the forward propagation stage in the model’s neural network. Here, computations for each layer in the network can be performed concurrently. This operation constitutes the vast majority of the model’s computation time, and it is here where the power of parallel processing can be harnessed.</p>
    <p class="normal">Now, assume that we’re working with a GPU that has 1,000 cores. In the context of language models, the parallelizable portion of the task might involve the forward propagation stage, where computations for each layer in the neural network can be performed concurrently. Let’s posit that this constitutes 95% of the total computation time. The remaining 5% of the<a id="_idIndexMarker1504"/> task, which could involve operations like tokenizing and decoding, is sequential and cannot be parallelized.</p>
    <p class="normal">Applying Amdahl’s law to this scenario gives us:</p>
    <p class="center"><em class="italic">Speedup = 1 / ((1 - 0.95) + 0.95/1000) = 1 / (0.05 + 0.00095) = 19.61</em></p>
    <p class="normal">Under ideal circumstances, this indicates that our language processing task could be completed about 19.61 times faster on a 1,000-core GPU than on a single-core CPU.</p>
    <p class="normal">To further illustrate the diminishing returns of parallel computing, let’s adjust the number of cores to 2, 50, and 100:</p>
    <ul>
      <li class="bulletList">For 2 cores: <em class="italic">Speedup = 1 / ((1 - 0.95) + 0.95/2) = 1.67</em></li>
      <li class="bulletList">For 50 cores: <em class="italic">Speedup = 1 / ((1 - 0.95) + 0.95/50) = 14.71</em></li>
      <li class="bulletList">For 100 cores: <em class="italic">Speedup = 1 / ((1 - 0.95) + 0.95/100) = 16.81</em></li>
    </ul>
    <p class="normal">As seen from our calculations, adding more cores to a parallel computing setup doesn’t lead to an equivalent increase in speedup. This is a prime example of the concept of diminishing returns in parallel computing. Despite doubling the number of cores from 2 to 4, or increasing them 50-fold from 2 to 100, the speedup doesn’t double or increase 50 times. Instead, the speedup hits a theoretical limit as per Amdahl’s law.</p>
    <p class="normal">The primary factor behind this diminishing return is the existence of a non-parallelizable portion in the task. In our case, operations like tokenizing and decoding form this sequential part, accounting for 5% of the total computation time. No matter how many cores we add to the system or how efficiently we can carry out the parallelizable part, this sequential portion places an upper limit on the achievable speedup. It will always be there, demanding its share of the computation time.</p>
    <p class="normal">Amdahl’s law elegantly captures this characteristic of parallel computing. It states that the maximum potential speedup using parallel processing is dictated by the non-parallelizable part of the task. The law serves as a reminder to algorithm designers and system architects that while parallelism can dramatically speed up computation, it is not an infinite resource to be tapped for speed. It underscores the importance of identifying and optimizing the sequential components of an algorithm in order to maximize the benefits of parallel processing.</p>
    <p class="normal">This understanding is particularly important in the context of LLMs, where the sheer scale of computations makes efficient resource utilization a key concern. It underlines the need for a balanced approach that combines parallel computing strategies with efforts to optimize the<a id="_idIndexMarker1505"/> performance of the sequential parts of the task.</p>
    <h3 id="_idParaDest-538" class="heading-3">Rethinking data locality</h3>
    <p class="normal">Traditionally, in parallel and distributed<a id="_idIndexMarker1506"/> processing, the data locality principle is pivotal in deciding the optimal resource allocation. It fundamentally suggests that the movement of data should be discouraged in distributed infrastructures. Whenever possible, instead of moving data, it should be processed locally on the node where it resides; otherwise, it reduces the benefit of parallelization and horizontal scaling, where horizontal scaling is the process of increasing a system’s capacity by adding more machines or nodes to distribute the workload, enabling it to handle higher amounts of traffic or data.</p>
    <p class="normal">As networking bandwidth has improved over the years, the limitations imposed by data locality have become less significant. The increased data transfer speeds enable efficient communication between nodes in a distributed computing environment, reducing the reliance on data locality for performance optimization. The network bandwidth can be quantified by the network bisection bandwidth, which is the bandwidth between two equal parts of a network. This is important in distributed computing with resources that are physically distributed. If we draw a line somewhere between two sets of resources in a distributed network, the bisectional bandwidth is the rate of communication at which servers on one side of the line can communicate with servers on the other side, as shown in <em class="italic">Figure 15.6</em>. For distributed computing to work efficiently, this is the most important parameter to consider. If we do not have enough network bisection bandwidth, the benefits gained by the availability of multiple execution engines in distributed computing will be overshadowed by slow communication links.</p>
    <figure class="mediaobject"><img src="../Images/B18046_15_06.png" alt="A picture containing text  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 15.6: Bisection bandwidth</p>
    <p class="normal">A high bisectional bandwidth enables us to process the data where it is without copying it. These days, major cloud computing providers offer exceptional bisection bandwidth. For example, within a Google data center, the bisection bandwidth is as high as 1 petabyte per second. Other major Cloud vendors offer similar bandwidth. In contrast, a typical enterprise network might only provide bisection bandwidth in the range of 1 to 10 gigabytes per second. </p>
    <p class="normal">This vast<a id="_idIndexMarker1507"/> difference in speed demonstrates the remarkable capabilities of modern Cloud infrastructure, making it well suited to large-scale data processing tasks.</p>
    <p class="normal">The increased petabit bisectional bandwidth has opened up new options and design patterns for efficiently storing and processing big data. These new options include alternative methods and design patterns that have become viable due to the increased network capacity, enabling faster and more efficient data processing.</p>
    <h2 id="_idParaDest-539" class="heading-2">Benefiting from cluster computing using Apache Spark</h2>
    <p class="normal">Apache Spark is a widely used platform for managing and leveraging cluster computing. In this context, “cluster computing” involves <a id="_idIndexMarker1508"/>grouping together several machines and making them work together as a single system to solve a problem. Spark <a id="_idIndexMarker1509"/>doesn’t merely implement this; it creates and controls these clusters to achieve high-speed data processing.</p>
    <p class="normal">Within Apache Spark, data undergoes a transformation into what’s known as <strong class="keyWord">Resilient Distributed Datasets</strong> (<strong class="keyWord">RDDs</strong>). These are<a id="_idIndexMarker1510"/> effectively the backbone of Apache Spark’s data abstraction.</p>
    <p class="normal">RDDs are immutable, meaning they can’t be altered once created, and are collections of elements that can be processed in parallel. In other words, different pieces of these datasets can be worked on at the same time, thereby accelerating data processing.</p>
    <p class="normal">When we say “fault-tolerant,” we mean that RDDs have the ability to recover from potential failures or errors during execution. This makes them robust and reliable for big data processing tasks. They’re split into <a id="_idIndexMarker1511"/>smaller chunks known as “partitions,” which are then distributed across various nodes or individual computers in the cluster. The size of these partitions can vary and is primarily determined by the nature of the task and the configuration of the Spark application.</p>
    <p class="normal">Spark’s distributed computing framework allows the tasks to be distributed across multiple nodes, which can significantly improve processing speed and efficiency.</p>
    <p class="normal">The Spark architecture is composed of several main components, including the driver program, executor, worker node, and cluster manager.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Driver program</strong>: The driver program is a key component in a Spark application, functioning much like the control center of operations. It resides in its own separate<a id="_idIndexMarker1512"/> process, often located on a machine known as the driver machine. The driver program’s role is like that of a<a id="_idIndexMarker1513"/> conductor of an orchestra; it runs the primary Spark program and oversees the many tasks within it.
    <p class="normal">Among the main tasks of the driver program are handling and running the SparkSession. The SparkSession is crucial to the Spark application as it wraps around the SparkContext. The SparkContext is like the central nervous system of the Spark application – it’s the gateway for the application to interact with the Spark computational ecosystem.</p>
    <p class="normal">To simplify, imagine the Spark application as an office building. The driver program is like the building manager, responsible for overall operation and maintenance. Within this building, the SparkSession represents an individual office, and the SparkContext is the main entrance to that office. The essence is that these components – the driver program, SparkSession, and SparkContext – work together to coordinate tasks and manage resources within a Spark application. The SparkContext is packed with fundamental functions and context information that is pre-loaded at the start time of the application. Moreover, it carries vital details about the cluster, such as its configuration and status, which are crucial for the application to run and execute tasks effectively.</p></li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Cluster manager</strong>: The driver program<a id="_idIndexMarker1514"/> interacts seamlessly with the cluster manager. The cluster manager is an external service that provides and manages resources across the cluster, such as computing power and memory. The driver program and the cluster manager work hand in hand to identify available resources in the cluster, allocate them effectively, and manage their usage throughout the life cycle of the Spark application.</li>
      <li class="bulletList"><strong class="keyWord">Executors</strong>: An executor refers to<a id="_idIndexMarker1515"/> a dedicated computational process that is spawned specifically for an individual Spark application running on a node within a cluster. Each of these executor processes operates on a worker node, effectively acting as the computational “muscle” behind your Spark application.</li>
      <li class="bulletList">The sharing of both<a id="_idIndexMarker1516"/> memory and global parameters in this way can significantly enhance the speed and efficiency of task execution, making Spark a highly performant framework for big data processing.</li>
      <li class="bulletList"><strong class="keyWord">Worker node</strong>: A worker node, true<a id="_idIndexMarker1517"/> to its name, is charged with carrying out the actual execution of tasks within the distributed Spark system. 
    <p class="bulletList">Each worker node is capable of hosting multiple executors, which in turn can serve numerous Spark applications:</p>
    <figure class="mediaobject"><img src="../Images/B18046_15_07.png" alt="A diagram of a cluster manager  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 15.7: Spark’s distributed architecture</p></li>
    </ul>
    <h1 id="_idParaDest-540" class="heading-1">How Apache Spark empowers large-scale algorithm processing</h1>
    <p class="normal">Apache Spark has emerged as a leading platform for processing and analyzing big data, thanks to its powerful <a id="_idIndexMarker1518"/>distributed computing capabilities, fault-tolerant nature, and ease of use. In this section, we will explore how Apache<a id="_idIndexMarker1519"/> Spark empowers large-scale algorithm processing, making it an ideal choice for complex, resource-intensive tasks.</p>
    <h2 id="_idParaDest-541" class="heading-2">Distributed computing</h2>
    <p class="normal">At the core<a id="_idIndexMarker1520"/> of Apache Spark’s architecture is the concept of data partitioning, which allows data to be divided across multiple nodes in a cluster. This feature enables parallel processing and efficient resource utilization, both of which are crucial for running large-scale algorithms. Spark’s architecture comprises a driver program and multiple executor processes distributed across worker nodes. The driver program is responsible for managing and distributing tasks across the executors, while each executor runs multiple tasks concurrently in separate threads, allowing for high throughput.</p>
    <h2 id="_idParaDest-542" class="heading-2">In-memory processing</h2>
    <p class="normal">One of Spark’s <a id="_idIndexMarker1521"/>standout features is its in-memory processing capability. Unlike traditional disk-based systems, Spark can cache intermediate data in memory, significantly speeding up iterative algorithms that require multiple passes over the data. </p>
    <ul>
      <li class="bulletList">This in-memory <a id="_idIndexMarker1522"/>processing capability is particularly beneficial for large-scale algorithms, as it <a id="_idIndexMarker1523"/>minimizes the time spent on disk I/O, leading to faster computation times and more efficient use of resources.</li>
    </ul>
    <h1 id="_idParaDest-543" class="heading-1">Using large-scale algorithms in cloud computing</h1>
    <p class="normal">The rapid growth of data and the increasing complexity of machine learning models have made distributed model training an essential component of modern deep learning pipelines. Large-scale algorithms <a id="_idIndexMarker1524"/>demand vast amounts of computational resources and necessitate efficient parallelism to optimize their training times. Cloud computing offers an array of services and tools that facilitate distributed model<a id="_idIndexMarker1525"/> training, allowing you to harness the full potential of resource-hungry, large-scale algorithms.</p>
    <p class="normal">Some of the key advantages of using the <a id="_idIndexMarker1526"/>Cloud for distributed model training include:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Scalability</strong>: The Cloud provides virtually unlimited resources, allowing you to scale your model training workloads to meet the demands of large-scale algorithms.</li>
      <li class="bulletList"><strong class="keyWord">Flexibility</strong>: The Cloud supports a wide range of machine learning frameworks and libraries, enabling you to choose the most suitable tools for your specific needs.</li>
      <li class="bulletList"><strong class="keyWord">Cost-effectiveness</strong>: With the Cloud, you can optimize your training costs by selecting the right instance types and leveraging spot instances to reduce expenses.</li>
    </ul>
    <h2 id="_idParaDest-544" class="heading-2">Example</h2>
    <p class="normal">As we delve deeper into machine learning models, especially those dealing with <strong class="keyWord">Natural Language Processing</strong> (<strong class="keyWord">NLP</strong>) tasks, we notice an increasing need for computational resources. For instance, transformers like <a id="_idIndexMarker1527"/> GPT-3 for large-scale language modeling tasks can have billions of parameters, demanding substantial processing power and memory. Training such models on colossal datasets, such as Common Crawl, which contains billions of web pages, further escalates these requirements.</p>
    <p class="normal">Cloud computing <a id="_idIndexMarker1528"/>emerges as a potent solution here. It offers services and tools for distributed model training, enabling us to access an almost infinite pool of resources, scale our workloads, and select the most suitable machine <a id="_idIndexMarker1529"/>learning frameworks. What’s more, cloud computing facilitates cost optimization by providing flexible instance types and spot instances – essentially bidding for spare computing capacity. By delegating these resource-heavy tasks to the cloud, we can concentrate more on innovative work, speeding up the training process, and developing more powerful models.</p>
    <h1 id="_idParaDest-545" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we examined the concepts and principles of large-scale and parallel algorithm design. The pivotal role of parallel computing was analyzed, with particular emphasis on its capacity to effectively distribute computational tasks across multiple processing units. The extraordinary capabilities of GPUs were studied in detail, illustrating their utility in executing numerous threads concurrently. Moreover, we discussed distributed computing platforms, specifically Apache Spark and cloud computing environments. Their importance in facilitating the development and deployment of large-scale algorithms was underscored, providing a robust, scalable, and cost-effective infrastructure for high-performance computations.</p>
    <h1 id="_idParaDest-546" class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/WHLel"><span class="url">https://packt.link/WHLel</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1955211820597889031.png" alt="" role="presentation"/></p>
  </div>
</body></html>