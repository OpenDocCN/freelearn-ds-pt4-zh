<html><head></head><body>
<div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Analyzing and Visualizing Data with Python</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Advanced analytics and data science now play a major role in the majority of businesses. </span><span class="koboSpan" id="kobo.3.2">It supports organizations in tracking, managing, and gathering performance metrics to enhance organizational decision-making. </span><span class="koboSpan" id="kobo.3.3">Business managers can utilize innovative analysis and machine learning to help them decide how to best engage customers, enhance business performance, and increase sales. </span><span class="koboSpan" id="kobo.3.4">Data science and analytics can be utilized to create user-centric products and make wise choices. </span><span class="koboSpan" id="kobo.3.5">This can be achieved by comparing various product aspects and studying consumer feedback and market trends to develop goods and services that can draw clients and keep them around for an </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">extended period.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This book is intended for everyone who wants to have an introduction to the techniques and methods of data science, advanced analytics, and machine learning for studying business cases that have been impacted by the use of these methods. </span><span class="koboSpan" id="kobo.5.2">The cases shown are heavily based on real use cases, with a demonstrated positive impact in various companies of different sectors. </span><span class="koboSpan" id="kobo.5.3">So, anyone who might be considering the application of data science in business operations, regardless of whether they are a seasoned business analyst seeking to enhance their list of skills, or a manager looking for methods that can be applied to maximize certain operations, can benefit from the examples discussed in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will lay down the initial components that will be used throughout this book to manage the data, manipulate it, and visualize it. </span><span class="koboSpan" id="kobo.7.2">Specifically, we will discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">The use of data science in business and the main differences with roles such as business or </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">data analysts</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">The use of statistical programming libraries such as NumPy to apply matrix algebra and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">statical methods</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Storing the data in pandas, a library for data analysis and manipulation that is widely used in the context of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">data science</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Visualization with Seaborn and how the different types of charts can be used in different kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">of situations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Next, we will discuss the technical requirements that you will need to be able to follow the examples presented in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this chapter.</span></span></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To be able to follow the steps in this chapter, you will need to meet the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following requirements:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">A Jupyter notebook instance running Python 3.7 and above. </span><span class="koboSpan" id="kobo.22.2">You can use the Google Colab notebook to run the steps as well if you have a Google </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Drive account.</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">A basic understanding of math and </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">statistical concepts.</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.26.1">Using data science and advanced analytics in business</span></h1>
<p><span class="koboSpan" id="kobo.27.1">Most of the, time</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.28.1"> the question of what differentiates a data scientist from a business analyst arises, as both roles focus on attaining insight from data. </span><span class="koboSpan" id="kobo.28.2">From a certain perspective, it can be considered that data science </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.29.1">involves creating forecasts by analyzing the patterns behind the raw data. </span><span class="koboSpan" id="kobo.29.2">Business intelligence is backward-looking and discovers the previous and current trends, while data science is forward-looking and forecasts </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">future trends.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Business decision-making strongly relies on data science and advanced analytics because they help managers understand how decisions affect outcomes. </span><span class="koboSpan" id="kobo.31.2">As a result, data scientists are increasingly required to integrate common machine learning technologies with knowledge of the underlying causal linkages. </span><span class="koboSpan" id="kobo.31.3">These developments have given rise to positions like that of the decision scientist, a technologist who focuses on using technology to support business and decision-making. </span><span class="koboSpan" id="kobo.31.4">When compared to a different employment description known as a “data scientist” or “big data scientist,” however, the phrase “decision scientist” becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">truly meaningful.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Most times, there might be confusion between the roles of business analysts, data scientists, and data analysts. </span><span class="koboSpan" id="kobo.33.2">Business analysts are more likely to address business problems and </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.34.1">suggest solutions, whereas </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.35.1">data analysts typically work more directly with the data itself. </span><span class="koboSpan" id="kobo.35.2">Both positions are in high demand and are often well paid, but data science is far more engaged in forecasting since it examines the patterns hidden in the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">raw dat</span><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.37.1">a.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.38.1">Using NumPy for statistics and algebra</span></h1>
<p><span class="koboSpan" id="kobo.39.1">NumPy is</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.40.1"> a Python library used for working with arrays. </span><span class="koboSpan" id="kobo.40.2">Additionally, it provides functions for working with matrices, the Fourier transform, and the </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.41.1">area of linear algebra. </span><span class="koboSpan" id="kobo.41.2">Large, multi-dimensional arrays and matrices are now supported by NumPy, along with a wide range of sophisticated mathematical operations that may be performed on these arrays. </span><span class="koboSpan" id="kobo.41.3">They use a huge number of sophisticated mathematical functions to process massive multidimensional arrays and matrices, as well as basic scientific computations in machine learning, which makes them highly helpful. </span><span class="koboSpan" id="kobo.41.4">It gives the n-dimensional array, a straightforward yet effective data structure. </span><span class="koboSpan" id="kobo.41.5">Learning NumPy is the first step on every Python data scientist’s path because it serves as the cornerstone on which nearly all of the toolkit’s capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">are constructed.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">The array, which is a grid of values all of the same type that’s indexed by a tuple of nonnegative integers, is the fundamental building block utilized by NumPy. </span><span class="koboSpan" id="kobo.43.2">Similar to how the dimensions of a matrix are defined in algebra, the array’s rank is determined by its number of dimensions. </span><span class="koboSpan" id="kobo.43.3">A tuple of numbers indicating the size of the array along each dimension makes up the shape of </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">an a</span><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.45.1">rray:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
import numpy </span><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.47.1">as np
arr = np.array([1, 2, 3, 4</span><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.48.1">, 5])
print</span><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.49.1">(arr)
print(type(arr))</span></pre>
<p><span class="koboSpan" id="kobo.50.1">A NumPy array is a </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.51.1">container that can house a certain number of elements, all of which must be of the same type, as was previously specified. </span><span class="koboSpan" id="kobo.51.2">The majority of data structures employ arrays to carry out their algorithms. </span><span class="koboSpan" id="kobo.51.3">Similar to how you can slice a list, you can also slice a NumPy array, but in more than one dimension. </span><span class="koboSpan" id="kobo.51.4">Similar to indexing, slicing a NumPy array returns an array that is a view of the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">original array.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Slicing in </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.54.1">Python means taking elements from one given index to another given index. </span><span class="koboSpan" id="kobo.54.2">We can select certain elements of an array by slicing the array using </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">[start:end]</span></strong><span class="koboSpan" id="kobo.56.1">, where we reference the elements of the array from where we can start and where we want to finish. </span><span class="koboSpan" id="kobo.56.2">We can also define the step </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">[start:end</span><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.59.1">:step]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
print('select elements by index:',</span><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.62.1">arr[0])
print('slice elements of the array:',ar</span><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.63.1">r[1:5])
print('ending point of the array:',a</span><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.64.1">rr[4:])
print('ending point of the array:',arr[:4])</span></pre>
<p><span class="koboSpan" id="kobo.65.1">There</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.66.1"> are three different sorts of indexing techniques: field access, fundamental slicing, and advanced indexing. </span><span class="koboSpan" id="kobo.66.2">Basic slicing is the n-dimensional extension of Python’s fundamental slicing notion. </span><span class="koboSpan" id="kobo.66.3">By passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">start</span></strong><span class="koboSpan" id="kobo.68.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">stop</span></strong><span class="koboSpan" id="kobo.70.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">step</span></strong><span class="koboSpan" id="kobo.72.1"> parameters to the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">slice</span></strong><span class="koboSpan" id="kobo.74.1"> function, a Python slice object is created. </span><span class="koboSpan" id="kobo.74.2">Writing understandable, clear, and succinct code is made possible through slicing. </span><span class="koboSpan" id="kobo.74.3">An iterable element is referred to by its position within the iterable when it is “indexed.” </span><span class="koboSpan" id="kobo.74.4">Getting a subset of elements from an iterable, depending on their indices, is referred to </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">as “slicing.”</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">To combine (concatenate) two arrays, we must copy each element in both arrays to </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">result</span></strong><span class="koboSpan" id="kobo.78.1"> by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">np.concatenate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1"> f</span><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.81.1">unction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
arr1 = np.array([1</span><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.83.1">, 2, 3])
arr2 = np.array([4</span><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.84.1">, 5, 6])
arr = np.concatenate((arr1</span><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.85.1">, arr2))
print(arr)</span></pre>
<p><span class="koboSpan" id="kobo.86.1">Arrays can be joined using NumPy stack methods as well. </span><span class="koboSpan" id="kobo.86.2">We can combine two 1D arrays along the second axis to stack them on top of one another, a process known as stacking. </span><span class="koboSpan" id="kobo.86.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">stack()</span></strong><span class="koboSpan" id="kobo.88.1"> method receives a list of arrays that we wish to connect with </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">t</span><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.90.1">he axis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
arr = np.stack((arr1, arr2),</span><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.92.1"> axis=1)
print(arr)</span></pre>
<p><span class="koboSpan" id="kobo.93.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">axis</span></strong><span class="koboSpan" id="kobo.95.1"> parameter can be used to reference the axis over which we want to make </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">the concat</span><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.97.1">enation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
arr = np.stack((arr1, arr2),</span><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.99.1"> axis=0)
print(arr)</span></pre>
<p><span class="koboSpan" id="kobo.100.1">The </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.101.1">NumPy </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">mean()</span></strong><span class="koboSpan" id="kobo.103.1"> function is used to compute the arithmetic mean along the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">specif</span><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.105.1">ied axis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
np.mean(arr,axis=1)</span></pre>
<p><span class="koboSpan" id="kobo.107.1">You need to use the NumPy </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">mean()</span></strong><span class="koboSpan" id="kobo.109.1"> function with </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">axis=0</span></strong><span class="koboSpan" id="kobo.111.1"> to compute the average by column. </span><span class="koboSpan" id="kobo.111.2">To compute the average by row, you need to </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">us</span><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.113.1">e </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">axis=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
np.mean(arr,axis=0)</span></pre>
<p><span class="koboSpan" id="kobo.117.1">In the next section, we will introduce pandas, a library for data analysis and manipulation. </span><span class="koboSpan" id="kobo.117.2">pandas is one of the most extensively used Python libraries in data science, much like NumPy. </span><span class="koboSpan" id="kobo.117.3">It offers high-performance, simple-to-use data analysis tools. </span><span class="koboSpan" id="kobo.117.4">In contrast to the multi-dimensional array objects provided by the NumPy library, pandas offers an in-memory 2D table object called </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">a D</span><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.119.1">ataFrame.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.120.1">Storing and manipulating data with pandas</span></h1>
<p><span class="koboSpan" id="kobo.121.1">pandas</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.122.1"> is an </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.123.1">open-source toolkit built on top of NumPy that offers Python programmers high-performance, user-friendly data structures, and data analysis capabilities. </span><span class="koboSpan" id="kobo.123.2">It enables quick analysis, data preparation, and cleaning. </span><span class="koboSpan" id="kobo.123.3">It performs and produces at a </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">high level.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">pandas is a</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.126.1"> package for data analysis, and because it includes many built-in auxiliary functions, it is typically </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.127.1">used for financial time series data, economic data, and any form of tabular data. </span><span class="koboSpan" id="kobo.127.2">For scientific computing, NumPy is a quick way to manage huge multidimensional arrays, and it can be used in conjunction with the SciPy and </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">pandas packages.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Constructing a DataFrame from a dictionary is possible by passing this dictionary to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">DataFrame</span><a id="_idTextAnchor041"/></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1"> constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
import</span><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.133.1"> pandas as pd
d = {'col1': [1,5,8, 2], 'col2'</span><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.134.1">: [3,3,7, 4]}
df = pd.Data</span><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.135.1">Frame(data=d)
df</span></pre>
<p><span class="koboSpan" id="kobo.136.1">The </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.137.1">pandas </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">groupby</span></strong><span class="koboSpan" id="kobo.139.1"> function is a powerful and versatile function that allows us to split data into separate groups to perform computations </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.140.1">for </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">b</span><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.142.1">etter analysis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
df = pd.DataFrame({'Animal':</span><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.144.1"> ['Dog', 'Dog',
                              'Rat'</span><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.145.1">, 'Rat','Rat'],
                   'Max Speed': [380., 370.,</span><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.146.1"> 24., 26.,25.],
                   'Max Weight': [10., 8.1,</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.147.1"> .1, .12,.09]})
df</span></pre>
<p><span class="koboSpan" id="kobo.148.1">The </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.149.1">three steps of “split,” “apply,” and “combine” make it the</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.150.1"> simplest to recall what a “groupby” performs. </span><span class="koboSpan" id="kobo.150.2">Split refers to dividing your data into distinct groups based on a particular column. </span><span class="koboSpan" id="kobo.150.3">As an illustration, we can divide our sales </span><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.151.1">data </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">into months:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
df.groupby(['Animal']).mean()</span></pre>
<p><span class="koboSpan" id="kobo.154.1">pandas’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">groupby</span></strong><span class="koboSpan" id="kobo.156.1"> technique is extremely potent. </span><span class="koboSpan" id="kobo.156.2">Using value counts, you can group by one column and count the values of a different column as a function of this column value. </span><span class="koboSpan" id="kobo.156.3">We can count the number of activities each person completed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">groupby</span></strong> <a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.158.1">and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1"> counts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
df.value_counts()</span></pre>
<p><span class="koboSpan" id="kobo.162.1">We can also aggregate data over the rows using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">aggregate()</span></strong><span class="koboSpan" id="kobo.164.1"> method, which allows you to apply a function or a list of function names to be executed along one of the axes of the DataFrame. </span><span class="koboSpan" id="kobo.164.2">The default is 0, which is the index (row) axis. </span><span class="koboSpan" id="kobo.164.3">It’s important to note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">agg()</span></strong><span class="koboSpan" id="kobo.166.1"> method is an alias of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">ag</span><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.168.1">gregate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
df.agg("mean", axis="rows",numeric_only=True)</span></pre>
<p><span class="koboSpan" id="kobo.171.1">We can also pass several functions to be used in each of the </span><a id="_idTextAnchor053"/><span class="No-Break"><span class="koboSpan" id="kobo.172.1">selected columns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
df.agg({'Max Speed' : ['sum', 'min'], 'Max Weight' : ['mean', 'max']})</span></pre>
<p><span class="koboSpan" id="kobo.174.1">The quantile of the values on a given axis is determined via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">quantile()</span></strong><span class="koboSpan" id="kobo.176.1"> method. </span><span class="koboSpan" id="kobo.176.2">The row-level axis is the default. </span><span class="koboSpan" id="kobo.176.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">quantile()</span></strong><span class="koboSpan" id="kobo.178.1"> method calculates the quantile </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.179.1">column-wise and returns the mean value for each </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.180.1">row when the column axis is specified (</span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">axis='columns'</span></strong><span class="koboSpan" id="kobo.182.1">). </span><span class="koboSpan" id="kobo.182.2">The following line will give us the 10% quantile across th</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.183.1">e </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">entire DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.185.1">
df.quantile(.1)</span></pre>
<p><span class="koboSpan" id="kobo.186.1">We can also pass a</span><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.187.1"> list </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">of quantiles:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
df.quantile([.1, .5])</span></pre>
<p><span class="koboSpan" id="kobo.190.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">pivot()</span></strong><span class="koboSpan" id="kobo.192.1"> function is used to reshape a given DataFrame structured by supplied index or </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.193.1">column values and is one of the different types of functions that we can use to change the data. </span><span class="koboSpan" id="kobo.193.2">Data aggregation is not supported by</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.194.1"> this function; multiple values produce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Multi</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.196.1">Index</span></strong><span class="koboSpan" id="kobo.197.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the column</span><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.199.1">s:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
df = pd.DataFrame(
{'type': ['one', 'one', 'one', '</span><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.201.1">two', 'two',  'two'],
 'cat': ['A', 'B',</span><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.202.1"> 'C', 'A', 'B', 'C'],
'val'</span><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.203.1">: [1, 2, 3, 4, 5, 6],
'letter': ['x', 'y', </span><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.204.1">'z', 'q', 'w', 't']})
df.pivot(index='type', columns='cat', values='val')</span></pre>
<p><span class="koboSpan" id="kobo.205.1">Pivot tables are one of pandas’ most powerful features. </span><span class="koboSpan" id="kobo.205.2">A pivot table allows us to draw insights from data. </span><span class="koboSpan" id="kobo.205.3">pandas provides a similar function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">pivot_table()</span></strong><span class="koboSpan" id="kobo.207.1">. </span><span class="koboSpan" id="kobo.207.2">It is a simple function but can produce a very powerful analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">very quickly.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">The next step for us will be to learn how to visualize the data to create proper storytelling and </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">appropr</span><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.211.1">iate interpretations.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.212.1">Visualizing patterns with Seaborn</span></h1>
<p><span class="koboSpan" id="kobo.213.1">Seaborn is a</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.214.1"> Python data visualization library based on Matplotlib. </span><span class="koboSpan" id="kobo.214.2">It offers a </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.215.1">sophisticated drawing tool for creating eye-catching and educational </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">statistical visuals.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">The primary distinction between Seaborn and Matplotlib is how well Seaborn handles pandas DataFrames. </span><span class="koboSpan" id="kobo.217.2">Beautiful graphics are provided in Python by using simple sets of functions. </span><span class="koboSpan" id="kobo.217.3">When dealing with DataFrames and arrays, Matplotlib performs well. </span><span class="koboSpan" id="kobo.217.4">It views axes and figures as objects. </span><span class="koboSpan" id="kobo.217.5">There are several stateful plotting APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Here, we</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.220.1"> will start our examples using the “tips” dataset, which contains a mixture of numeric an</span><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.221.1">d </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">categorical variable</span><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.223.1">s:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
import seaborn as sns
import m</span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.225.1">atplotlib.pyplot as plt
tips = </span><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.226.1">sns.load_dataset("tips")
f, ax = plt.s</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.227.1">ubplots(figsize=(12, 6))
sns.scatterplot(data=tips, x="total_bill", y="tip", hue="time")</span></pre>
<p><span class="koboSpan" id="kobo.228.1">In the </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.229.1">preceding code snippet, we have imported Seaborn and Matplotlib; the latter allows users to control certain aspects of the plots created, such as the figure size, which we defined as a 12 by 6 inches size. </span><span class="koboSpan" id="kobo.229.2">This creates the layout in which Seaborn will place </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">the visualization.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">We are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">scatterplot()</span></strong><span class="koboSpan" id="kobo.233.1"> function to create a visualization of points where the </span><em class="italic"><span class="koboSpan" id="kobo.234.1">X</span></em><span class="koboSpan" id="kobo.235.1">-axis refers to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">total_bill</span></strong><span class="koboSpan" id="kobo.237.1"> variable and the </span><em class="italic"><span class="koboSpan" id="kobo.238.1">Y</span></em><span class="koboSpan" id="kobo.239.1">-axis refers to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">tip</span></strong><span class="koboSpan" id="kobo.241.1"> variable. </span><span class="koboSpan" id="kobo.241.2">Here, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">hue</span></strong><span class="koboSpan" id="kobo.243.1"> parameter to color the different dots according to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">time</span></strong><span class="koboSpan" id="kobo.245.1"> categorical variable, which allows us to plot numerical data with a </span><a id="_idTextAnchor069"/><span class="No-Break"><span class="koboSpan" id="kobo.246.1">categorical dimension:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.247.1"><img alt="Figure 1.1: Seaborn scatterplot with the color depending on the categorical variable " src="image/B19026_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Figure 1.1: Seaborn scatterplot with the color depending on the categorical variable</span></p>
<p><span class="koboSpan" id="kobo.249.1">This</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.250.1"> generated figure shows the distribution </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.251.1">of the data according to the color codes that we have specified, which in our case are the tips that were received, their relationship with the total bill amount, and whether it was during lunch </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">or dinner.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">The interpretation that we can make is that there might be a linear relationship between the total amount of the bill and the tip received. </span><span class="koboSpan" id="kobo.253.2">But if we look closer, we can see that the highest total bill amounts are placed during dinner, also leading to the highest values </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">in tips.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">This information can be really useful in the context of business, but it first needs to be validated with proper hypothesis testing approaches, which can be a t-test to validate these hypotheses, plus a linear regression analysis to conclude that there is a relationship between the total amount and the tip distribution, accounting for the differences in the time in which this occurred. </span><span class="koboSpan" id="kobo.255.2">We will look into these analyses in the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">We can now see how a simple exploration graph can help us construct the hypothesis over which we can base decisions to better improve business products </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">or services.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">We can </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.260.1">also assign hue and style to different variables that will vary colors and markers independently. </span><span class="koboSpan" id="kobo.260.2">This allows us to introduce another categorical dimension in the </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.261.1">same graph, which in the case of Seaborn can be used with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">style</span></strong><span class="koboSpan" id="kobo.263.1"> parameter, which will assign different types of markers according to our refe</span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.264.1">renced </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">categorical variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
f, ax = p</span><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.267.1">lt.subplots(figsize=(12, 6))
sns.scatterplot(data=tips, x="total_bill", y="tip", hue="day", style="time")</span></pre>
<p><span class="koboSpan" id="kobo.268.1">The preceding code snippet will create a layout that’s 12 x 6 inches and will add information about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">time</span></strong><span class="koboSpan" id="kobo.270.1"> categorical variable, as show</span><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.271.1">n in the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">following graph:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 1.2: Seaborn scatterplot with color and shape depending on the categorical variable " src="image/B19026_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 1.2: Seaborn scatterplot with color and shape depending on the categorical variable</span></p>
<p><span class="koboSpan" id="kobo.275.1">This kind of graph allows us to pack a lot of information into a single plot, which can be beneficial but also can lead to a cluttering of information that can be difficult to digest at once. </span><span class="koboSpan" id="kobo.275.2">It is important to always account for the understanding of the information that we want to show, making it easier for the stakeholders to be able to see the relationships at </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">a glance.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Here, it is </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.278.1">much more difficult to see any kind of interpretation of the days of the week at first glance. </span><span class="koboSpan" id="kobo.278.2">This is because a lot of information is already being shown. </span><span class="koboSpan" id="kobo.278.3">These differences that cannot be obtained by simply looking at a graph can be achieved through other kinds of analysis, such as statistical tests, correlations, </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">and causations.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Another </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.281.1">way to add more dimensions to the graphics created with Seaborn is to represent numerical variables as the size of the points in the scatterplot. </span><span class="koboSpan" id="kobo.281.2">Numerical variables can be assigned to </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">size</span></strong><span class="koboSpan" id="kobo.283.1"> to apply a semantic mapping to the areas of </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the points.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">We can control the range of marker areas with sizes, and set the legend parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">full</span></strong><span class="koboSpan" id="kobo.287.1"> to force every unique v</span><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.288.1">alue to appear in </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the legend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
f, ax = </span><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.291.1">plt.subplots(figs</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.292.1">ize=(12, 6))
sns.scatterplot(
    data=tips, x="total_bill", y="t</span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.293.1">ip", hue="size", 
    size="size", s</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.294.1">izes=(20, 200), legend="full"
)</span></pre>
<p><span class="koboSpan" id="kobo.295.1">The preceding code snippet creates a scatterplot where the points have a size and color that depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">size</span></strong><span class="koboSpan" id="kobo.297.1"> variable. </span><span class="koboSpan" id="kobo.297.2">This can be useful to pack another numerical dimension </span><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.298.1">into these kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">of plots:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.300.1"><img alt="Figure 1.3: Seaborn scatterplot with size depending on a third variable " src="image/B19026_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.301.1">Figure 1.3: Seaborn scatterplot with size depending on a third variable</span></p>
<p><span class="koboSpan" id="kobo.302.1">Another</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.303.1"> important way to represent data is by looking at </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.304.1">time series information. </span><span class="koboSpan" id="kobo.304.2">We can use the Seaborn package to display time series data without the need to give the data any </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">special treatment.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">In the following example, we are creating a pandas DataFrame with dates, using Matplotlib to create a figure that’s 15 x 8 inches, and then using the Seaborn </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">lineplot</span></strong><span class="koboSpan" id="kobo.308.1"> functio</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.309.1">n to display </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the information:</span></span><a id="_idTextAnchor080"/></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
df = pd.DataFrame({"Dates":
['01/01/2019','01/02/20</span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.312.1">19','01/03/2019','01/04/2019',
'01/05/2019','01/06/201</span><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.313.1">9','01/07/2019','01/08/2019'],
"Count": [727,</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.314.1">716,668,710,718,732,694,755]}</span><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.315.1">)
plt.figure(figsize = (15,8))
sns.lineplot(x = 'Dates', y = 'Count',data = df)</span></pre>
<p><span class="koboSpan" id="kobo.316.1">The preceding example creates a wonderful plot with the dates on the </span><em class="italic"><span class="koboSpan" id="kobo.317.1">x</span></em><span class="koboSpan" id="kobo.318.1"> axis and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">co</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.320.1">unt</span></strong><span class="koboSpan" id="kobo.321.1"> variable on the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.322.1">y</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.323.1"> axis:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 1.4: Seaborn line plot with a time-based axis " src="image/B19026_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 1.4: Seaborn line plot with a time-based axis</span></p>
<p><span class="koboSpan" id="kobo.326.1">For the</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.327.1"> following example, we will load a pre-defined dataset </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.328.1">from Seaborn known as the FMRI dataset, which contains time </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">series data.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">First, we will load an example dataset with long-form data and then plot the responses for different events and regions. </span><span class="koboSpan" id="kobo.330.2">To do this, we will create a 15 x 8 inches Matplotlib figure and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">lineplot</span></strong><span class="koboSpan" id="kobo.332.1"> function to show the information, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">hue</span></strong><span class="koboSpan" id="kobo.334.1"> parameter to display categorical information about the region, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">style</span></strong><span class="koboSpan" id="kobo.336.1"> parameter to show categorical infor</span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.337.1">mation about the type </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">of event:</span></span></p>
<pre class="source-code">
<a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.339.1">fmri = sns.load_dataset("fmri")
f, ax </span><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.340.1">= plt.subplots(figsize=(15, 8))
sns.lineplot(x="timepoint", y="signal", hue="region", style="event",data=fmri)</span></pre>
<p><span class="koboSpan" id="kobo.341.1">The preceding code snippet creates a display of the information that allows us to study how the variables move through time according to the different cate</span><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.342.1">gorical aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">the data:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.344.1"><img alt="Figure 1.5: Seaborn line plot with confidence intervals " src="image/B19026_01_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1">Figure 1.5: Seaborn line plot with confidence intervals</span></p>
<p><span class="koboSpan" id="kobo.346.1">One of </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.347.1">the features of the Seaborn </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">lineplot</span></strong><span class="koboSpan" id="kobo.349.1"> function </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.350.1">is that it shows us the confidence intervals of all points within a range of 95% confidence; the solid line represents the main. </span><span class="koboSpan" id="kobo.350.2">This way of showing us the information can be really useful when showing time series data that contains multiple data points for each point in time. </span><span class="koboSpan" id="kobo.350.3">Trends can be visualized by the mean as well as to give us a sense of the degree of dispersion, which is something that can be important when analyzing </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">behavior patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">One of the ways we can visualize data is through bar plots. </span><span class="koboSpan" id="kobo.352.2">Seaborn uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">barpl</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.354.1">ot</span></strong><span class="koboSpan" id="kobo.355.1"> function to create </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">bar plots:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
f, ax</span><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.358.1"> = plt.subplots(figsize=(12, 6))
ax = sns.barplot(x="day", y="total_bill", data=tips,ci=.9)</span></pre>
<p><span class="koboSpan" id="kobo.359.1">The preceding code uses Matplotlib to create a 12 x 6 inches figure where the Seaborn bar plot is created. </span><span class="koboSpan" id="kobo.359.2">Here, we will display the days on the </span><em class="italic"><span class="koboSpan" id="kobo.360.1">x</span></em><span class="koboSpan" id="kobo.361.1"> axis and the total bill on the </span><em class="italic"><span class="koboSpan" id="kobo.362.1">y</span></em><span class="koboSpan" id="kobo.363.1"> axis, showing the confidence bars as whiskers above the bars. </span><span class="koboSpan" id="kobo.363.2">The preceding code g</span><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.364.1">enerates the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">following graph:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.366.1"><img alt="Figure 1.6: Seaborn bar plot " src="image/B19026_01_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.367.1">Figure 1.6: Seaborn bar plot</span></p>
<p><span class="koboSpan" id="kobo.368.1">In the </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.369.1">preceding graph, we cannot see the whiskers in </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.370.1">detail as the data has a very small amount of dispersion. </span><span class="koboSpan" id="kobo.370.2">We can see this in better detail by drawing a set of vertical bars whil</span><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.371.1">e grouping them by </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">two variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
f, a</span><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.374.1">x = plt.subplots(figsize=(12, 6))
ax = sns.barplot(x="day", y="total_bill", hue="sex", data=tips)</span></pre>
<p><span class="koboSpan" id="kobo.375.1">The preceding code snippet creates a bar plot on a 12 x 6-inch Matplotlib figure. </span><span class="koboSpan" id="kobo.375.2">The difference is that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">hue</span></strong><span class="koboSpan" id="kobo.377.1"> paramet</span><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.378.1">er to show </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">gender differences:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.380.1"><img alt="Figure 1.7: Seaborn bar plot with categorical data " src="image/B19026_01_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.381.1">Figure 1.7: Seaborn bar plot with categorical data</span></p>
<p><span class="koboSpan" id="kobo.382.1">One of </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.383.1">the conclusions that can be extracted</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.384.1"> from this graph is that females get to have total bills that are lower than males on average, with Saturday being the only day when there’s a difference between the means, though there’s a much lower basepoint for </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">the dispersion.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">We can add another categorical dimension to the visualization using </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">catplot</span></strong><span class="koboSpan" id="kobo.388.1"> to combine a </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">barplot</span></strong><span class="koboSpan" id="kobo.390.1"> with a FacetGrid to create multiple plots. </span><span class="koboSpan" id="kobo.390.2">This allows us to group within additional categorical variables. </span><span class="koboSpan" id="kobo.390.3">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">catplot</span></strong><span class="koboSpan" id="kobo.392.1"> is safer than using FacetGrid to create multiple graphs as it ensures synchronization of varia</span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.393.1">ble order across </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">different facets:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
sns.catplot(x="sex", y="total_bill",hue="smoker", col="time",data=tips, kind="bar",height=6, aspect=.7)</span></pre>
<p><span class="koboSpan" id="kobo.396.1">The preceding code snippet generates a categorical plot that contains the different bar plots. </span><span class="koboSpan" id="kobo.396.2">Note that the size of the graph is controlled using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">height</span></strong><span class="koboSpan" id="kobo.398.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">aspect</span></strong><span class="koboSpan" id="kobo.400.1"> variables inst</span><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.401.1">ead of via a </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">Matplotlib figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.403.1"><img alt="Figure 1.8: Seaborn bar plot with two categorical variables " src="image/B19026_01_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.404.1">Figure 1.8: Seaborn bar plot with two categorical variables</span></p>
<p><span class="koboSpan" id="kobo.405.1">Here, we</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.406.1"> can see an interesting trend during lunch, where </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.407.1">the mean of the male smokers is lower than the non-smokers, while the female smoker’s mean is higher than those of non-smokers. </span><span class="koboSpan" id="kobo.407.2">This tendency is inverted during dinner when there are more male smokers on average than </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">female smokers.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Analyzing trends using histograms is a wonderful tool to be used while analyzing patterns. </span><span class="koboSpan" id="kobo.409.2">We can use them with the Searbon </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">hisplot</span></strong><span class="koboSpan" id="kobo.411.1"> function. </span><span class="koboSpan" id="kobo.411.2">Here, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">penguins</span></strong><span class="koboSpan" id="kobo.413.1"> dataset and create a Matp</span><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.414.1">lotlib figure that’s 12 x </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">6 inches:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
peng</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.417.1">uins = sns.load_dataset("penguins")
f,</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.418.1"> ax = plt.subplots(figsize=(12, 6))
sns.histplot(data=penguins, x="flipper_length_mm", bins=30)</span></pre>
<p><span class="koboSpan" id="kobo.419.1">The preceding code creates a histogram of the flipper </span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.420.1">length grouping data in </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">30 bins:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.422.1"><img alt="Figure 1.9: Seaborn histogram plot " src="image/B19026_01_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.423.1">Figure 1.9: Seaborn histogram plot</span></p>
<p><span class="koboSpan" id="kobo.424.1">Here, we </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.425.1">can add a kernel density line estimate, which </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.426.1">softens the histogram, providing more information about the shape of the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">data distribution.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The following code adds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">kde</span></strong><span class="koboSpan" id="kobo.430.1"> para</span><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.431.1">meter set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">True</span></strong><span class="koboSpan" id="kobo.433.1"> to show </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">this line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
f</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.436.1">, ax = plt.subplots(figsize=(12, 6))
sns.histplot(data=penguins,</span><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.437.1"> x="flipper_length_mm", kde=True)</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.438.1"><img alt="Figure 1.10: Seaborn histogram plot with KDE estimated density " src="image/B19026_01_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.439.1">Figure 1.10: Seaborn histogram plot with KDE estimated density</span></p>
<p><span class="koboSpan" id="kobo.440.1">Here, we</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.441.1"> can see that the data approaches some </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.442.1">superimposed standard distribution, which can mean that we are looking at different kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">of data.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">We can also add more dimensions to the graph by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">hue</span></strong><span class="koboSpan" id="kobo.446.1"> parameter</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.447.1"> on the categorical </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">species</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.449.1"> variable:</span></span></p>
<pre class="source-code">
<a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.450.1">f, ax = plt.subplots(figsize=(12, 6))
sns.histplot(data=penguins, x="</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.451.1">flipper_length_mm", hue="species")</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.452.1"><img alt="Figure 1.11: Seaborn histogram plot with categorical data " src="image/B19026_01_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.453.1">Figure 1.11: Seaborn histogram plot with categorical data</span></p>
<p><span class="koboSpan" id="kobo.454.1">As </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.455.1">suspected, we were looking at the superposition </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.456.1">of different species of penguins, each of which has a normal distribution, though some of them are more skewed </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">than others.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">pairplot</span></strong><span class="koboSpan" id="kobo.460.1"> function can be used to plot several paired bivariate distributions in a dataset. </span><span class="koboSpan" id="kobo.460.2">The diagonal plots are the univariate plots, and this displays the relationship for the (n, 2) combination of variables in a DataFrame as a matrix of plots. </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">pairplot</span></strong><span class="koboSpan" id="kobo.462.1"> is used to determine the most distinct clusters or the best combination of features to explain the relationship between two variables. </span><span class="koboSpan" id="kobo.462.2">Constructing a linear separation or some simple lines in our dataset also helps to cr</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.463.1">eate some basic </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">classification models:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
sns.pairplot(penguins,height=3)</span></pre>
<p><span class="koboSpan" id="kobo.466.1">The preceding line of code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">pairplot</span></strong><span class="koboSpan" id="kobo.468.1"> of the data where</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.469.1"> each box has a height of </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">3 inches:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 1.12: Variable relationship and histogram of selected features " src="image/B19026_01_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 1.12: Variable relationship and histogram of selected features</span></p>
<p><span class="koboSpan" id="kobo.473.1">The variable names are shown on the matrix’s outer borders, making it easy to comprehend. </span><span class="koboSpan" id="kobo.473.2">The density plot for each variable is shown in the boxes along the diagonals. </span><span class="koboSpan" id="kobo.473.3">The</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.474.1"> scatterplot between each variable is </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.475.1">displayed in the boxes in the lower </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">left corner.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">We can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">hue</span></strong><span class="koboSpan" id="kobo.479.1"> parameter to add categ</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.480.1">orical dimensions to </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">the visualization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
sns.pairplot(penguins, hue="s</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.483.1">pecies", diag_kind="hist",height=3)</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.484.1"><img alt="Figure 1.13: Variable relationship and histogram with categorical labels " src="image/B19026_01_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.485.1">Figure 1.13: Variable relationship and histogram with categorical labels</span></p>
<p><span class="koboSpan" id="kobo.486.1">Although </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.487.1">incredibly useful, this graph can be very</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.488.1"> computationally expensive, which can be solved by looking only at some of the variables instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">whole dataset.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">We can reduce the time required to render the visualization by reducing the number of graphs shown. </span><span class="koboSpan" id="kobo.490.2">We can do this by specifying the types of variables we want to show in </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.491.1">each axis,</span><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.492.1"> as shown in t</span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.493.1">he following </span><a id="_idIndexMarker055"/><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.494.1">block </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
sns.pairplot(
    penguins,
    x_vars=["bill_length_m</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.497.1">m", "bill_depth_mm", 
           "flipper_length_mm"],
    y</span><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.498.1">_vars=["bill_</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.499.1">lengt</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.500.1">h_mm", "bill_depth_mm"],
    height=3
)</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.501.1"><img alt="Figure 1.14: Variable relationship and histogram of selected features " src="image/B19026_01_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.502.1">Figure 1.14: Variable relationship and histogram of selected features</span></p>
<p><span class="koboSpan" id="kobo.503.1">A box plot, sometimes referred to as a box-and-whisker plot in descriptive statistics, is a type of </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.504.1">chart that is frequently used in explanatory data analysis. </span><span class="koboSpan" id="kobo.504.2">Box plots use the data’s quartiles (or percentiles) and averages to visually depict the distribution of </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.505.1">numerical data </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">and skewness.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">We can use them in Seaborn</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.508.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">boxplot</span></strong><span class="koboSpan" id="kobo.510.1"> function, as </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">shown </span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.512.1">here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
f, ax = plt.subplots(figsize=(12, 6))
ax = sns.boxpl</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.514.1">ot(x="day", y="total_bill", data=tips)</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.515.1"><img alt="Figure 1.15: Seaborn box plot " src="image/B19026_01_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.516.1">Figure 1.15: Seaborn box plot</span></p>
<p><span class="koboSpan" id="kobo.517.1">The seaborn box plot has a very simple structure. </span><span class="koboSpan" id="kobo.517.2">Distributions are represented visually using box plots. </span><span class="koboSpan" id="kobo.517.3">When you want to compare data between two groups, they are helpful. </span><span class="koboSpan" id="kobo.517.4">A box plot may also be referred to as a box-and-whisker plot. </span><span class="koboSpan" id="kobo.517.5">Any box displays the dataset’s quartiles, and the whiskers extend to display the remainder of </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">the distribution.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">Here, we can specify a type of categorical variable we might want to show using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">hue</span></strong><span class="koboSpan" id="kobo.521.1"> parameter, as </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.522.1">well as specify the palette of colors we </span><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.523.1">want to use from Seaborn’s </span><a id="_idIndexMarker059"/><span class="No-Break"><span class="koboSpan" id="kobo.524.1">default op</span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.525.1">tions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
f, ax = plt.subplots(figsize=(12, 6))
ax = sns.boxplot(x="day", y="total_bill",</span><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.527.1"> hue="smoker",data=tips, palette="Set3")</span></pre>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.528.1"><img alt="Figure 1.16: Seaborn box plot with categorical data " src="image/B19026_01_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.529.1">Figure 1.16: Seaborn box plot with categorical data</span></p>
<p><span class="koboSpan" id="kobo.530.1">There is always the question of when you would use a box plot. </span><span class="koboSpan" id="kobo.530.2">Box plots are used to display the distributions of numerical data values, particularly when comparing them across various groups. </span><span class="koboSpan" id="kobo.530.3">They are designed to give high-level information at a glance and provide details like the symmetry, ske</span><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.531.1">w, variance, and outliers of a set </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">of data.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.533.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.534.1">In this chapter, we introduced the initial concepts of how we can store and manipulate data with pandas and NumPy, and how to visualize data patterns using Seaborn. </span><span class="koboSpan" id="kobo.534.2">These elements are used not only to explore the data but to be able to create visual narratives that allow us to understand patterns in the data and to be able to communicate simply </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">and practically.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">In the next chapter, we will build upon this to understand how machine learning and descriptive statistics can be used to validate hypotheses, study correlations and causations, as well as to make </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">predictive models.</span></span></p>
</div>
</body></html>