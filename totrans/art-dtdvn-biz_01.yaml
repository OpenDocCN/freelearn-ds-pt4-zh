- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing and Visualizing Data with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced analytics and data science now play a major role in the majority of
    businesses. It supports organizations in tracking, managing, and gathering performance
    metrics to enhance organizational decision-making. Business managers can utilize
    innovative analysis and machine learning to help them decide how to best engage
    customers, enhance business performance, and increase sales. Data science and
    analytics can be utilized to create user-centric products and make wise choices.
    This can be achieved by comparing various product aspects and studying consumer
    feedback and market trends to develop goods and services that can draw clients
    and keep them around for an extended period.
  prefs: []
  type: TYPE_NORMAL
- en: This book is intended for everyone who wants to have an introduction to the
    techniques and methods of data science, advanced analytics, and machine learning
    for studying business cases that have been impacted by the use of these methods.
    The cases shown are heavily based on real use cases, with a demonstrated positive
    impact in various companies of different sectors. So, anyone who might be considering
    the application of data science in business operations, regardless of whether
    they are a seasoned business analyst seeking to enhance their list of skills,
    or a manager looking for methods that can be applied to maximize certain operations,
    can benefit from the examples discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will lay down the initial components that will be used
    throughout this book to manage the data, manipulate it, and visualize it. Specifically,
    we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of data science in business and the main differences with roles such
    as business or data analysts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of statistical programming libraries such as NumPy to apply matrix algebra
    and statical methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the data in pandas, a library for data analysis and manipulation that
    is widely used in the context of data science
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualization with Seaborn and how the different types of charts can be used
    in different kinds of situations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss the technical requirements that you will need to be able
    to follow the examples presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to follow the steps in this chapter, you will need to meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A Jupyter notebook instance running Python 3.7 and above. You can use the Google
    Colab notebook to run the steps as well if you have a Google Drive account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of math and statistical concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data science and advanced analytics in business
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the, time the question of what differentiates a data scientist from
    a business analyst arises, as both roles focus on attaining insight from data.
    From a certain perspective, it can be considered that data science involves creating
    forecasts by analyzing the patterns behind the raw data. Business intelligence
    is backward-looking and discovers the previous and current trends, while data
    science is forward-looking and forecasts future trends.
  prefs: []
  type: TYPE_NORMAL
- en: Business decision-making strongly relies on data science and advanced analytics
    because they help managers understand how decisions affect outcomes. As a result,
    data scientists are increasingly required to integrate common machine learning
    technologies with knowledge of the underlying causal linkages. These developments
    have given rise to positions like that of the decision scientist, a technologist
    who focuses on using technology to support business and decision-making. When
    compared to a different employment description known as a “data scientist” or
    “big data scientist,” however, the phrase “decision scientist” becomes truly meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Most times, there might be confusion between the roles of business analysts,
    data scientists, and data analysts. Business analysts are more likely to address
    business problems and suggest solutions, whereas data analysts typically work
    more directly with the data itself. Both positions are in high demand and are
    often well paid, but data science is far more engaged in forecasting since it
    examines the patterns hidden in the raw data.
  prefs: []
  type: TYPE_NORMAL
- en: Using NumPy for statistics and algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy is a Python library used for working with arrays. Additionally, it provides
    functions for working with matrices, the Fourier transform, and the area of linear
    algebra. Large, multi-dimensional arrays and matrices are now supported by NumPy,
    along with a wide range of sophisticated mathematical operations that may be performed
    on these arrays. They use a huge number of sophisticated mathematical functions
    to process massive multidimensional arrays and matrices, as well as basic scientific
    computations in machine learning, which makes them highly helpful. It gives the
    n-dimensional array, a straightforward yet effective data structure. Learning
    NumPy is the first step on every Python data scientist’s path because it serves
    as the cornerstone on which nearly all of the toolkit’s capabilities are constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array, which is a grid of values all of the same type that’s indexed by
    a tuple of nonnegative integers, is the fundamental building block utilized by
    NumPy. Similar to how the dimensions of a matrix are defined in algebra, the array’s
    rank is determined by its number of dimensions. A tuple of numbers indicating
    the size of the array along each dimension makes up the shape of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A NumPy array is a container that can house a certain number of elements, all
    of which must be of the same type, as was previously specified. The majority of
    data structures employ arrays to carry out their algorithms. Similar to how you
    can slice a list, you can also slice a NumPy array, but in more than one dimension.
    Similar to indexing, slicing a NumPy array returns an array that is a view of
    the original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing in Python means taking elements from one given index to another given
    index. We can select certain elements of an array by slicing the array using `[start:end]`,
    where we reference the elements of the array from where we can start and where
    we want to finish. We can also define the step using `[start:end:step]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three different sorts of indexing techniques: field access, fundamental
    slicing, and advanced indexing. Basic slicing is the n-dimensional extension of
    Python’s fundamental slicing notion. By passing `start`, `stop`, and `step` parameters
    to the built-in `slice` function, a Python slice object is created. Writing understandable,
    clear, and succinct code is made possible through slicing. An iterable element
    is referred to by its position within the iterable when it is “indexed.” Getting
    a subset of elements from an iterable, depending on their indices, is referred
    to as “slicing.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'To combine (concatenate) two arrays, we must copy each element in both arrays
    to `result` by using the `np.concatenate()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can be joined using NumPy stack methods as well. We can combine two
    1D arrays along the second axis to stack them on top of one another, a process
    known as stacking. The `stack()` method receives a list of arrays that we wish
    to connect with the axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `axis` parameter can be used to reference the axis over which we want to
    make the concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The NumPy `mean()` function is used to compute the arithmetic mean along the
    specified axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to use the NumPy `mean()` function with `axis=0` to compute the average
    by column. To compute the average by row, you need to use `axis=1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will introduce pandas, a library for data analysis and
    manipulation. pandas is one of the most extensively used Python libraries in data
    science, much like NumPy. It offers high-performance, simple-to-use data analysis
    tools. In contrast to the multi-dimensional array objects provided by the NumPy
    library, pandas offers an in-memory 2D table object called a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and manipulating data with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pandas is an open-source toolkit built on top of NumPy that offers Python programmers
    high-performance, user-friendly data structures, and data analysis capabilities.
    It enables quick analysis, data preparation, and cleaning. It performs and produces
    at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: pandas is a package for data analysis, and because it includes many built-in
    auxiliary functions, it is typically used for financial time series data, economic
    data, and any form of tabular data. For scientific computing, NumPy is a quick
    way to manage huge multidimensional arrays, and it can be used in conjunction
    with the SciPy and pandas packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing a DataFrame from a dictionary is possible by passing this dictionary
    to the `DataFrame` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The pandas `groupby` function is a powerful and versatile function that allows
    us to split data into separate groups to perform computations for better analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The three steps of “split,” “apply,” and “combine” make it the simplest to
    recall what a “groupby” performs. Split refers to dividing your data into distinct
    groups based on a particular column. As an illustration, we can divide our sales
    data into months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas’ `groupby` technique is extremely potent. Using value counts, you can
    group by one column and count the values of a different column as a function of
    this column value. We can count the number of activities each person completed
    using `groupby` and `value` counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also aggregate data over the rows using the `aggregate()` method, which
    allows you to apply a function or a list of function names to be executed along
    one of the axes of the DataFrame. The default is 0, which is the index (row) axis.
    It’s important to note that the `agg()` method is an alias of the `aggregate()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass several functions to be used in each of the selected columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The quantile of the values on a given axis is determined via the `quantile()`
    method. The row-level axis is the default. The `quantile()` method calculates
    the quantile column-wise and returns the mean value for each row when the column
    axis is specified (`axis=''columns''`). The following line will give us the 10%
    quantile across the entire DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass a list of quantiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pivot()` function is used to reshape a given DataFrame structured by supplied
    index or column values and is one of the different types of functions that we
    can use to change the data. Data aggregation is not supported by this function;
    multiple values produce a `MultiIndex` in the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pivot tables are one of pandas’ most powerful features. A pivot table allows
    us to draw insights from data. pandas provides a similar function called `pivot_table()`.
    It is a simple function but can produce a very powerful analysis very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The next step for us will be to learn how to visualize the data to create proper
    storytelling and appropriate interpretations.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing patterns with Seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seaborn is a Python data visualization library based on Matplotlib. It offers
    a sophisticated drawing tool for creating eye-catching and educational statistical
    visuals.
  prefs: []
  type: TYPE_NORMAL
- en: The primary distinction between Seaborn and Matplotlib is how well Seaborn handles
    pandas DataFrames. Beautiful graphics are provided in Python by using simple sets
    of functions. When dealing with DataFrames and arrays, Matplotlib performs well.
    It views axes and figures as objects. There are several stateful plotting APIs
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will start our examples using the “tips” dataset, which contains a
    mixture of numeric and categorical variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have imported Seaborn and Matplotlib; the
    latter allows users to control certain aspects of the plots created, such as the
    figure size, which we defined as a 12 by 6 inches size. This creates the layout
    in which Seaborn will place the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the `scatterplot()` function to create a visualization of points
    where the *X*-axis refers to the `total_bill` variable and the *Y*-axis refers
    to the `tip` variable. Here, we are using the `hue` parameter to color the different
    dots according to the `time` categorical variable, which allows us to plot numerical
    data with a categorical dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Seaborn scatterplot with the color depending on the categorical
    variable ](img/B19026_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Seaborn scatterplot with the color depending on the categorical
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: This generated figure shows the distribution of the data according to the color
    codes that we have specified, which in our case are the tips that were received,
    their relationship with the total bill amount, and whether it was during lunch
    or dinner.
  prefs: []
  type: TYPE_NORMAL
- en: The interpretation that we can make is that there might be a linear relationship
    between the total amount of the bill and the tip received. But if we look closer,
    we can see that the highest total bill amounts are placed during dinner, also
    leading to the highest values in tips.
  prefs: []
  type: TYPE_NORMAL
- en: This information can be really useful in the context of business, but it first
    needs to be validated with proper hypothesis testing approaches, which can be
    a t-test to validate these hypotheses, plus a linear regression analysis to conclude
    that there is a relationship between the total amount and the tip distribution,
    accounting for the differences in the time in which this occurred. We will look
    into these analyses in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can now see how a simple exploration graph can help us construct the hypothesis
    over which we can base decisions to better improve business products or services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also assign hue and style to different variables that will vary colors
    and markers independently. This allows us to introduce another categorical dimension
    in the same graph, which in the case of Seaborn can be used with the `style` parameter,
    which will assign different types of markers according to our referenced categorical
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will create a layout that’s 12 x 6 inches and will
    add information about the `time` categorical variable, as shown in the following
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Seaborn scatterplot with color and shape depending on the categorical
    variable ](img/B19026_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Seaborn scatterplot with color and shape depending on the categorical
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: This kind of graph allows us to pack a lot of information into a single plot,
    which can be beneficial but also can lead to a cluttering of information that
    can be difficult to digest at once. It is important to always account for the
    understanding of the information that we want to show, making it easier for the
    stakeholders to be able to see the relationships at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it is much more difficult to see any kind of interpretation of the days
    of the week at first glance. This is because a lot of information is already being
    shown. These differences that cannot be obtained by simply looking at a graph
    can be achieved through other kinds of analysis, such as statistical tests, correlations,
    and causations.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to add more dimensions to the graphics created with Seaborn is to
    represent numerical variables as the size of the points in the scatterplot. Numerical
    variables can be assigned to `size` to apply a semantic mapping to the areas of
    the points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can control the range of marker areas with sizes, and set the legend parameter
    to `full` to force every unique value to appear in the legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet creates a scatterplot where the points have a size
    and color that depends on the `size` variable. This can be useful to pack another
    numerical dimension into these kinds of plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Seaborn scatterplot with size depending on a third variable ](img/B19026_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Seaborn scatterplot with size depending on a third variable'
  prefs: []
  type: TYPE_NORMAL
- en: Another important way to represent data is by looking at time series information.
    We can use the Seaborn package to display time series data without the need to
    give the data any special treatment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a pandas DataFrame with dates, using
    Matplotlib to create a figure that’s 15 x 8 inches, and then using the Seaborn
    `lineplot` function to display the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example creates a wonderful plot with the dates on the *x* axis
    and the `count` variable on the *y* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Seaborn line plot with a time-based axis ](img/B19026_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Seaborn line plot with a time-based axis'
  prefs: []
  type: TYPE_NORMAL
- en: For the following example, we will load a pre-defined dataset from Seaborn known
    as the FMRI dataset, which contains time series data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will load an example dataset with long-form data and then plot the
    responses for different events and regions. To do this, we will create a 15 x
    8 inches Matplotlib figure and use the `lineplot` function to show the information,
    using the `hue` parameter to display categorical information about the region,
    and the `style` parameter to show categorical information about the type of event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet creates a display of the information that allows
    us to study how the variables move through time according to the different categorical
    aspects of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Seaborn line plot with confidence intervals ](img/B19026_01_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Seaborn line plot with confidence intervals'
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of the Seaborn `lineplot` function is that it shows us the
    confidence intervals of all points within a range of 95% confidence; the solid
    line represents the main. This way of showing us the information can be really
    useful when showing time series data that contains multiple data points for each
    point in time. Trends can be visualized by the mean as well as to give us a sense
    of the degree of dispersion, which is something that can be important when analyzing
    behavior patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the ways we can visualize data is through bar plots. Seaborn uses the
    `barplot` function to create bar plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses Matplotlib to create a 12 x 6 inches figure where the
    Seaborn bar plot is created. Here, we will display the days on the *x* axis and
    the total bill on the *y* axis, showing the confidence bars as whiskers above
    the bars. The preceding code generates the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Seaborn bar plot ](img/B19026_01_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Seaborn bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding graph, we cannot see the whiskers in detail as the data has
    a very small amount of dispersion. We can see this in better detail by drawing
    a set of vertical bars while grouping them by two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet creates a bar plot on a 12 x 6-inch Matplotlib figure.
    The difference is that we use the `hue` parameter to show gender differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7: Seaborn bar plot with categorical data ](img/B19026_01_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Seaborn bar plot with categorical data'
  prefs: []
  type: TYPE_NORMAL
- en: One of the conclusions that can be extracted from this graph is that females
    get to have total bills that are lower than males on average, with Saturday being
    the only day when there’s a difference between the means, though there’s a much
    lower basepoint for the dispersion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add another categorical dimension to the visualization using `catplot`
    to combine a `barplot` with a FacetGrid to create multiple plots. This allows
    us to group within additional categorical variables. Using `catplot` is safer
    than using FacetGrid to create multiple graphs as it ensures synchronization of
    variable order across different facets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet generates a categorical plot that contains the different
    bar plots. Note that the size of the graph is controlled using the `height` and
    `aspect` variables instead of via a Matplotlib figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: Seaborn bar plot with two categorical variables ](img/B19026_01_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Seaborn bar plot with two categorical variables'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see an interesting trend during lunch, where the mean of the male
    smokers is lower than the non-smokers, while the female smoker’s mean is higher
    than those of non-smokers. This tendency is inverted during dinner when there
    are more male smokers on average than female smokers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analyzing trends using histograms is a wonderful tool to be used while analyzing
    patterns. We can use them with the Searbon `hisplot` function. Here, we will use
    the `penguins` dataset and create a Matplotlib figure that’s 12 x 6 inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a histogram of the flipper length grouping data
    in 30 bins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: Seaborn histogram plot ](img/B19026_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Seaborn histogram plot'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can add a kernel density line estimate, which softens the histogram,
    providing more information about the shape of the data distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code adds the `kde` parameter set to `True` to show this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.10: Seaborn histogram plot with KDE estimated density ](img/B19026_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: Seaborn histogram plot with KDE estimated density'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the data approaches some superimposed standard distribution,
    which can mean that we are looking at different kinds of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add more dimensions to the graph by using the `hue` parameter on
    the categorical `species` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.11: Seaborn histogram plot with categorical data ](img/B19026_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Seaborn histogram plot with categorical data'
  prefs: []
  type: TYPE_NORMAL
- en: As suspected, we were looking at the superposition of different species of penguins,
    each of which has a normal distribution, though some of them are more skewed than
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pairplot` function can be used to plot several paired bivariate distributions
    in a dataset. The diagonal plots are the univariate plots, and this displays the
    relationship for the (n, 2) combination of variables in a DataFrame as a matrix
    of plots. `pairplot` is used to determine the most distinct clusters or the best
    combination of features to explain the relationship between two variables. Constructing
    a linear separation or some simple lines in our dataset also helps to create some
    basic classification models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code creates a `pairplot` of the data where each box
    has a height of 3 inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Variable relationship and histogram of selected features ](img/B19026_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Variable relationship and histogram of selected features'
  prefs: []
  type: TYPE_NORMAL
- en: The variable names are shown on the matrix’s outer borders, making it easy to
    comprehend. The density plot for each variable is shown in the boxes along the
    diagonals. The scatterplot between each variable is displayed in the boxes in
    the lower left corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `hue` parameter to add categorical dimensions to the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.13: Variable relationship and histogram with categorical labels
    ](img/B19026_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Variable relationship and histogram with categorical labels'
  prefs: []
  type: TYPE_NORMAL
- en: Although incredibly useful, this graph can be very computationally expensive,
    which can be solved by looking only at some of the variables instead of the whole
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reduce the time required to render the visualization by reducing the
    number of graphs shown. We can do this by specifying the types of variables we
    want to show in each axis, as shown in the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.14: Variable relationship and histogram of selected features ](img/B19026_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Variable relationship and histogram of selected features'
  prefs: []
  type: TYPE_NORMAL
- en: A box plot, sometimes referred to as a box-and-whisker plot in descriptive statistics,
    is a type of chart that is frequently used in explanatory data analysis. Box plots
    use the data’s quartiles (or percentiles) and averages to visually depict the
    distribution of numerical data and skewness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use them in Seaborn using the `boxplot` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.15: Seaborn box plot ](img/B19026_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Seaborn box plot'
  prefs: []
  type: TYPE_NORMAL
- en: The seaborn box plot has a very simple structure. Distributions are represented
    visually using box plots. When you want to compare data between two groups, they
    are helpful. A box plot may also be referred to as a box-and-whisker plot. Any
    box displays the dataset’s quartiles, and the whiskers extend to display the remainder
    of the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can specify a type of categorical variable we might want to show using
    the `hue` parameter, as well as specify the palette of colors we want to use from
    Seaborn’s default options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.16: Seaborn box plot with categorical data ](img/B19026_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Seaborn box plot with categorical data'
  prefs: []
  type: TYPE_NORMAL
- en: There is always the question of when you would use a box plot. Box plots are
    used to display the distributions of numerical data values, particularly when
    comparing them across various groups. They are designed to give high-level information
    at a glance and provide details like the symmetry, skew, variance, and outliers
    of a set of data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the initial concepts of how we can store and
    manipulate data with pandas and NumPy, and how to visualize data patterns using
    Seaborn. These elements are used not only to explore the data but to be able to
    create visual narratives that allow us to understand patterns in the data and
    to be able to communicate simply and practically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build upon this to understand how machine learning
    and descriptive statistics can be used to validate hypotheses, study correlations
    and causations, as well as to make predictive models.
  prefs: []
  type: TYPE_NORMAL
