- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Product Recommendation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Product recommendation is essentially a filtering system that aims to anticipate
    and present the goods that a user would be interested in buying. It is used to
    generate recommendations that keep users engaged with your product and service
    and provides relevant suggestions to them. In this chapter, we will learn how
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect clients who are reducing their sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target clients with personalized product suggestions for products that they
    are not yet buying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create specific product recommendations based on already bought products using
    market basket analysis and the Apriori algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s determine what will be the requirements to understand the steps and follow
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Targeting decreasing returning buyers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding product recommendation systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Apriori algorithm for product bundling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to follow the steps in this chapter, you will need to meet
    the next requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a Jupyter notebook instance running Python 3.7 and above. You can also
    use the Google Colab notebook to run the steps if you have a Google Drive account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an understanding of basic math and statistical concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting decreasing returning buyers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important aspect of businesses is that recurring customers always buy more
    than new ones, so it’s important to keep an eye on them and act if we see that
    they are changing their behavior. One of the things that we can do is identify
    the clients with decreasing buying patterns and offer them new products that they
    are not yet buying. In this case, we will look at consumer goods distribution
    center data to identify these customers with decreasing purchases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the necessary libraries, which are the following: pandas
    for data manipulation, NumPy for masking and NaNs handling, and scikit-surprise
    for collaborative filtering product recommendation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will explore the data to determine the right strategy to normalize the data
    into the right format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the data is structured, we will set up a linear regression to determine
    the clients with a negative slope to identify the ones with decreasing consumption
    patterns. This information will allow us to create specific actions for these
    clients and avoid customer churn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s get started with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first stage will be to load these packages and install the `scikit-surprise`
    package for collaborative filtering, which is a method to filter out items that
    a user might like based on the ratings of similar users. It works by linking the
    behaviors of a smaller set of users with tastes similar to a particular user product
    recommendations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For readability purposes, we will limit the maximum number of rows to be shown
    to 20, set the limit of maximum columns to 50, and show the floats with 2 digits
    of precision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can load the data to be analyzed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next figure, we show the historical sales of sold goods by period, details
    of both the client and product, and the quantity sold:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Data of consumer goods transactions ](img/B19026_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Data of consumer goods transactions'
  prefs: []
  type: TYPE_NORMAL
- en: The data consists of buy orders from different clients, for different products
    and different periods. The data has a period column with information about both
    the year and the month when the buy was made.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can keep exploring the data by taking a look at the columns list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s look at the total number of clients to analyze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we have almost 12,000 clients. For the demonstration purposes
    of this chapter, we will focus on the most important clients, based on the criteria
    of who are the ones that consume the most.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will find the clients that have been reducing sales. We will gauge
    the information to get the list of clients that have the highest total number
    of kilograms of products purchased to determine the best customers. We will use
    the `groupby` method with the sum by period to get the kilograms bought per client
    and period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next figure, we can see the total kilograms of goods sold by client
    and `period`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Aggregate sum of goods in kg by client and period ](img/B19026_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Aggregate sum of goods in kg by client and period'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the list of total clients, we will characterize them by the
    number of purchases per period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next DataFrame, we can see the count of purchases by client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Data of users per number of purchases ](img/B19026_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Data of users per number of purchases'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will filter top clients by the number of purchases, keeping the ones
    with at least five purchases of the total 8 periods we have. This limit is arbitrary
    in this case to find the clients that are mostly regular clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can check the total number of clients again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, most of the clients have more than 5 periods of purchases, so
    we have reduced around 30% of the total users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will list the total kgs of goods sold in all of the periods, filtering
    the clients that have less than 5 periods of buys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to get the total number of kgs sold in all of the periods, we will use
    the `groupby` method and sort the values in ascending order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the next step and only for visualization and demonstration, we will limit
    the clients to the top 25 clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then see the top 25 clients by total kgs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Clients with the highest kgs bought ](img/B19026_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Clients with the highest kgs bought'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the information about the top clients in terms of kgs sold,
    we can create a histogram to understand their consumption patterns. We will be
    using the `plot` method to create a bar chart for the pandas Dataframe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Chart of clients with the highest amount of kgs sold ](img/B19026_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Chart of clients with the highest amount of kgs sold'
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture the clients that have been decreasing their level of expenditure,
    we will create a mask that filters all but the top clients, to visualize the kgs
    bought per client and period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the filtered data after filtering the top clients by weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Kgs sold by period and client ](img/B19026_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Kgs sold by period and client'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will pivot the DataFrame for visualization, and we will fill the
    NaN values with 0 as this is an indication that the client did not buy anything
    for this period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next DataFrame has the data pivoted and is better encoded for working with
    machine learning models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Pivoted data ](img/B19026_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Pivoted data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can visualize the consumption throughout the periods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The line plot allows us to see at first glance the clients with the biggest
    sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Line plot of kgs sold by client and period ](img/B19026_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Line plot of kgs sold by client and period'
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify the curves with a decreasing trend, we will determine the slope
    and the standard deviation in terms of sales per month. This will allow us to
    identify the clients with decreasing consumer behavior by looking at the slope
    as well as to identify users with high consumption variability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see in the prints that some of the clients have a negative slope, which
    indicates that their consumer patterns show a decline in monthly purchases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Slope of clients buying trends ](img/B19026_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Slope of clients buying trends'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the values are shown in absolutes, but it would be even better
    to show it as a percentage of the median purchase of each client to keep the consistency.
    You can apply this change and evaluate the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will store the results in a DataFrame and use it to visualize the
    results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The DataFrame shows us the clients, along with the parameter estimated by the
    regression model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Final slope and standard deviation ](img/B19026_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Final slope and standard deviation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our information is neatly structured, we can create a seaborn heatmap
    to visualize the resulting data more graphically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Slope and deviation heatmap ](img/B19026_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Slope and deviation heatmap'
  prefs: []
  type: TYPE_NORMAL
- en: From the data, we can see some clients that show a marked decline in their monthly
    purchases, and some of them have been increasingly buying more. It is also helpful
    to look at the standard deviation to find how varying the purchases that this
    client does are.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the performance of each one of the clients, we can act
    on the clients with a pattern of declining sales by offering them tailor-made
    recommendations. In the next section, we will train recommender systems based
    on the purchase pattern of the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding product recommendation systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have identified the customers with decreasing consumption, we can
    create specific product recommendations for them. How do you recommend products?
    In most cases, we can do this with a recommender system, which is a filtering
    system that attempts to forecast and display the products that a user would like
    to purchase as what makes up a product suggestion. The k-nearest neighbor method
    and latent factor analysis, which is a statistical method to find groups of correlated
    variables, are the two algorithms utilized in collaborative filtering. Additionally,
    with collaborative filters, the system learns the likelihood that two or more
    things will be purchased collectively. A recommender system’s goal is to make
    user-friendly recommendations for products in the same way that you like. Collaborative
    filtering approaches and content-based methods are the two main categories of
    techniques available to accomplish this goal.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of having relevant products being recommended to the clients
    is critical, as businesses can personalize client experience with the recommended
    system by recommending the products that make the most sense to them based on
    their consumption patterns. To provide pertinent product recommendations, a recommendation
    engine also enables companies to examine the customer’s past and present website
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: There are many applications for recommender systems, with some of the most well-known
    ones including playlist makers for video and audio services, product recommenders
    for online shops, content recommenders for social media platforms, and open web
    content recommenders.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, recommendation engines provide personalized, direct recommendations
    that are based on the requirements and interests of each client. Machine learning
    is being used to improve online searches as well as it provides suggestions based
    on a user’s visual preferences rather than product descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a recommender system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first step to train our recommender system is to capture the consumption
    patterns of the clients. In the following example, we will focus on the products
    that the customers bought throughout the periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Products bought by client ](img/B19026_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Products bought by client'
  prefs: []
  type: TYPE_NORMAL
- en: We will train the recommender with a rating scale between 0 and 1 so we need
    to scale these values. Now we can see that some clients have consistently bought
    some products, so we will use the `sklearn` min max scaler to adjust the scale.
  prefs: []
  type: TYPE_NORMAL
- en: In machine learning, we normalize the data by generating new values, maintaining
    the general distribution, and adjusting the ratio in the data; normalization prevents
    the use of raw data and numerous dataset issues. Utilizing a variety of methods
    and algorithms also enhances the efficiency and accuracy of machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: The `MinMaxScaler` from scikit-learn can be applied to scale the variables within
    a range. It’s important to note that the distribution of the variables should
    be normal. The original distribution’s shape is preserved by `MinMaxScaler` making
    sure that the information present in the original data is not materially altered.
    Keep in mind that `MinMaxScaler` does not lessen the significance of outliers
    and that the resulting feature has a default range of 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Which scaler—`MinMaxScaler` or `StandardScaler`—is superior? For features that
    follow a normal distribution, `StandardScaler` is helpful. When the upper and
    lower boundaries are well defined from domain knowledge, `MinMaxScaler` may be
    employed (pixel intensities that go from 0 to 255 in the RGB color range).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have standardized the values, we can start working on the recommender
    system. Here, we will be using the SVDpp algorithm, which is an extension of SVD
    that takes into account implicit ratings. SVD is employed as a collaborative filtering
    mechanism in the recommender system. Each row in the matrix symbolizes a user,
    and each column is a piece of merchandise. The ratings that users provide for
    items make up the matrix’s elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general formula of SVD is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*M=UΣV**ᵗ*'
  prefs: []
  type: TYPE_NORMAL
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: M is the original matrix we want to decompose, which is the dense matrix of
    users and products they bought
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: U is the left singular matrix (columns are left singular vectors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Σ is a diagonal matrix containing singular eigenvalues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V is the right singular matrix (columns are right singular vectors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.13: Collaborative filtering factorization matrix ](img/B19026_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Collaborative filtering factorization matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `scikit-surprise` package efficiently implements the SVD algorithm. Without
    having to reinvent the wheel, we can quickly construct rating-based recommender
    systems using the simple-to-use Python module called `SurpriseSVD`. When utilizing
    models such as SVD, `SurpriseSVD` also gives us access to the matrix factors,
    which enables us to visually see how related the objects in our dataset are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by importing the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will initiate the reader for which we will set the scale between 0
    and 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can load the data with the `Dataset` method from the DataFrame with
    standardized value counts of products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can instantiate the SVD algorithm and train it on the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The training process should take a couple of minutes depending on the hardware
    specs that you have, but once it is finished, we can start using it to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by taking a particular user and filtering up all the products
    that they are still not buying to offer them the ones that are more recommended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have determined the products that the user is not buying, let’s
    see how the algorithm rates them to this specific user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will iterate over the products in the following data and
    create a DataFrame with the products that have the highest recommendation value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next DataFrame shows us the recommended products for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: Client-recommended products ](img/B19026_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Client-recommended products'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have determined this for a single user, we can extrapolate this
    to the rest of the clients. We will keep only the first 20 recommendations, as
    the number of products is too extensive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script will allow us to loop through our clients and generate a list of
    recommendations for each one of them. In this case, we are looking into a specific
    analysis, but this could be implemented into a pipeline delivering these results
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have data that allows us to target each one of our clients with tailor-made
    product recommendations for products that they are not buying yet. We can also
    offer products that are complementary to the ones they are already buying, and
    this is what we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Apriori algorithm for product bundling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we have focused on clients that are decreasing their purchases to create
    specific offers for them for products that they are not buying, but we can also
    improve the results for those that are already loyal customers. We can improve
    the number of products that they are buying by doing a market basket analysis
    and offering products that relate to their patterns of consumption. For this,
    we can use several algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular methods for association rule learning is the Apriori
    algorithm. It recognizes the things in a data collection and expands them to ever-larger
    groupings of items. Apriori is employed in association rule mining in datasets
    to search for several often-occurring sets of things. It expands on the itemsets’
    connections and linkages. This is the implementation of the “You may also like”
    suggestions that you frequently see on recommendation sites are the result of
    an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Apriori is an algorithm for association rule learning and frequent item set
    mining in relational databases. As long as such item sets exist in the database
    frequently enough, it moves forward by detecting the frequent individual items
    and extending them to larger and larger item sets. The Apriori algorithm is generally
    used with transactional databases that are mined for frequent item sets and association
    rules using the Apriori method. “Support”, “Lift”, and “confidence” are utilized
    as parameters, where support is the likelihood that an item will occur, and confidence
    is a conditional probability. An item set is made up of the items in a transaction.
    This algorithm uses two steps, “join” and “prune,” to reduce the search space.
    It is an iterative approach to discovering the most frequent itemsets. In association
    rule learning, the items in a dataset are identified, and the dataset is expanded
    to include ever-larger groupings of things.
  prefs: []
  type: TYPE_NORMAL
- en: The Apriori method is a common algorithm used in market basket analysis and
    is a well-known and widely used association rule algorithm. It aids in the discovery
    of frequent itemsets in transactions and pinpoints the laws of association between
    these items.
  prefs: []
  type: TYPE_NORMAL
- en: Performing market basket analysis with Apriori
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this analysis, we will use separate data found in the UCI ML repository
    ([http://archive.ics.uci.edu/ml/datasets/Online+Retail](http://archive.ics.uci.edu/ml/datasets/Online+Retail)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the analysis by importing the packages and loading the data. Remember
    to install the `mlxtend` module prior to running this block of code, otherwise,
    we will have a **Module Not** **Found** error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.15: Online retail data ](img/B19026_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Online retail data'
  prefs: []
  type: TYPE_NORMAL
- en: This international data collection includes every transaction made by a UK-based,
    registered non-store internet retailer between December 1, 2010, and December
    9, 2011\. The company primarily offers one-of-a-kind gifts for every occasion.
    The company has a large number of wholesalers as clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin exploring the columns of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The data contains transactional sales data with information about codes and
    dates that we will not use now. Instead, we will focus on the description, quantity,
    and price.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at the statistical summary of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.16: Descriptive statistical summary ](img/B19026_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Descriptive statistical summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to assess the categorical variables, we use the `describe` method
    focused on object columns in the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.17: Descriptive categorical summary ](img/B19026_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Descriptive categorical summary'
  prefs: []
  type: TYPE_NORMAL
- en: This information shows us some of the counts for each object column and shows
    us that the most common country is the UK, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also explore the different regions of transactions to gain some understanding
    of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.18: Markets in the data ](img/B19026_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Markets in the data'
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm that the vast majority of transactions are in the UK, followed
    by Germany and France.
  prefs: []
  type: TYPE_NORMAL
- en: 'For readability, we will be stripping extra spaces in the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will drop rows with NaNs in the invoice number and convert them into
    strings for categorical treatment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For now, we will focus on noncredit transactions, so we will be dropping all
    transactions that were done on credit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will begin the analysis by looking at the UK association rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.19: UK market basket ](img/B19026_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: UK market basket'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the dense matrix of products bought on each invoice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do the same with the transactions done in France:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will do the same for the data for Germany:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will be defining the hot encoding function to make the data suitable
    for the concerned libraries as they need discrete values (either 0 or 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have encoded the results into a one hot encoder, we can start to build
    the models for each market:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the model is built, we can look at the found association rules for the
    UK market:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.20: UK association rules ](img/B19026_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: UK association rules'
  prefs: []
  type: TYPE_NORMAL
- en: If the rules for the UK transactions are examined in more detail, it becomes
    clear that the British bought variously colored tea plates collectively. This
    may be due to the fact that the British often enjoy tea very much and frequently
    collect various colored tea dishes for various occasions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now do the same for the data for France:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.21: France association rules ](img/B19026_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: France association rules'
  prefs: []
  type: TYPE_NORMAL
- en: It is clear from this data that paper plates, glasses, and napkins are frequently
    purchased together in France. This is due to the French habit of gathering with
    friends and family at least once every week. Additionally, since the French government
    has outlawed the use of plastic in the nation, citizens must purchase replacements
    made of paper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will build the model for the German data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 6.22: Germany association rules ](img/B19026_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Germany association rules'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding data shows us that most of the items are associated with costs
    of delivery, so it might be an indication that German transactions are mostly
    made of single items.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned to identify the clients that have a decreasing
    number of sales in order to offer them specific product recommendations based
    on their consumption patterns. We have identified the decreasing sales by looking
    at the slope in the historical sales in the given set of periods, and we used
    the SVD collaborative filtering algorithm to create personalized recommendations
    for products that customers are not buying.
  prefs: []
  type: TYPE_NORMAL
- en: As the next step and to improve the loyalty of existing customers, we have explored
    the use of the Apriori algorithm to run a market basket analysis and to be able
    to offer product recommendations based on specific products being bought.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into how we identify the common traits of
    customers that churn in order to complement these approaches with a deeper understanding
    of our customer churn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Operation and Pricing Optimization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final part of the book will cover how to optimize business operations. We
    will move away from understanding the market and customers, and dive into how
    we can adjust the operations to improve the revenue margin. This will be done
    by improving the pricing strategies, optimizing the use of promotions, and finally,
    improving the digital marketing strategies to reach more possible customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part covers the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19026_07.xhtml#_idTextAnchor881), *Predicting Customer Churn*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19026_08.xhtml#_idTextAnchor1010), *Grouping Users with Customer
    Segmentation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19026_09.xhtml#_idTextAnchor1188), *Using Historical Markdown
    Data to Predict Sales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19026_10.xhtml#_idTextAnchor1316), *Web Analytics Optimization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19026_11.xhtml#_idTextAnchor1469), *Creating a Data-Driven
    Culture in Business*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
