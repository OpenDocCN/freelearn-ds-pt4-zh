- en: '*Chapter 7*: The AzureML Python SDK'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will understand how the AzureML Python **Software Development
    Kit** (**SDK**) is structured and how to work with it, something that is key for
    the DP-100 exam. You will learn how to work with the **Notebooks** experience
    that is built into the AzureML Studio web portal, a tool that boosts coding productivity.
    Using the notebook editor, you will write some Python code to gain a better understanding
    of how to manage the compute targets, datastores, and datasets that are registered
    in the workspace. Finally, you are going to revisit the Azure CLI we looked at
    in [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026), *Deploying Azure
    Machine Learning Workspace Resources*, to perform workspace management actions
    using the AzureML extension. This will allow you to script and automate your workspace
    management activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Python SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with AzureML notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic coding with the AzureML SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the AzureML CLI extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have access to an Azure subscription. Within that subscription,
    you will need a `packt-azureml-rg`. You will need to have either a `Contributor`
    or `Owner` `packt-learning-mlw`, as described in [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026),
    *Deploying Azure Machine Learning Workspace Resources*.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to have a basic understanding of the **Python** language.
    The code snippets in this chapter target Python version 3.6 or later. You should
    know the basics of how a Jupyter notebook works and how the variables that you
    defined in one cell exist in the execution context of others.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the notebooks and code snippets for this chapter on GitHub
    at [http://bit.ly/dp100-ch07](http://bit.ly/dp100-ch07).
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Python SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AzureML **SDK** is a Python library that allows you to interact with the
    AzureML services. It also provides you with data science modules that will assist
    you in your machine learning journey. The AzureML SDK is available in the R programming
    language through a Python to R interoperability package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SDK consists of several packages that group different types of modules
    you can import into your code base. All the Microsoft-supported modules are placed
    within packages that start with `azureml`, such as `azureml.core` and `azureml.train.hyperdrive`.
    The following diagram offers a broad overview of the AzureML SDK''s most frequently
    used packages, as well as the key modules that you will see in this book and the
    exam:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The AzureML SDK modules and important classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – The AzureML SDK modules and important classes
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all the key classes that exist in the `azureml.core` package can
    also be imported from the corresponding child module. For example, the `Experiment`
    class can be imported in either way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both snippets will load the same class and you only need to use one of them.
    The first one loads the class from the `azureml.core` package, while the second
    one loads it from the `experiment` module (a file named `experiment.py`), which
    is part of the `azureml.core` package. Do not be surprised if you notice this
    type of difference in various code samples you may read through.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For exam purposes, you will not need to memorize the packages, but you will
    have to select the appropriate one from a drop-down list. For example, you may
    be asked to complete some code that refers to `AutoMLConfig`, and you may have
    to select between the `azureml.automl` package and the `azureml.pipeline` one,
    a choice that will become even more obvious when you finish reading the next few
    chapters. The code samples throughout this book import all the required packages
    on top of the script to help you become familiar with the location of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will focus on the SDK classes that allow you to control
    the AzureML workspace, as well as the compute resources that are deployed in the
    workspace, the datastores, and the datasets that you can register in the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to utilize the **Notebooks** experience
    that is built into AzureML Studio to write Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Working in AzureML notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AzureML Studio offers integration with a couple of code editors that allow
    you to edit notebooks and Python scripts. These editors are powered by the **compute
    instance** you provisioned in [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053),
    *Configuring the Workspace*. If you have stopped that compute instance to save
    on costs, navigate to **Manage** | **Compute** and start it. From this view, you
    can open all third-party coding editors AzureML Studio integrates with, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – List of third-party code editor experiences Azure Studio integrates
    with'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – List of third-party code editor experiences Azure Studio integrates
    with
  prefs: []
  type: TYPE_NORMAL
- en: 'The most widely known open source data science editors are Jupyter Notebook
    and its newer sibling, JupyterLab. You can open those editing environments by
    clicking on the respective links shown in the preceding screenshot. This will
    open a new browser tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – JupyterLab and Jupyter editing experiences provided by the compute
    instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – JupyterLab and Jupyter editing experiences provided by the compute
    instance
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides these third-party code editing experiences, AzureML Studio offers a
    built-in enhanced notebook editor that allows you to edit, share, and collaborate
    within the Studio interface, as shown in the following screenshot. This editor
    is created on top of the Jupyter Notebook service but offers a much more improved
    code editing experience, such as inline error highlighting, automatic code completion,
    popups with parameter information for the method you are about to invoke, and
    other features that are referred to as **IntelliSense**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The enhanced Notebooks experience built into AzureML Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The enhanced Notebooks experience built into AzureML Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'The notebook editor comes with an embedded sample library that contains an
    up-to-date catalog of notebooks that demonstrate almost all the capabilities of
    the latest AzureML SDK. Once you have found a related notebook, you can review
    its contents and if you want to modify it, you can clone it in your workspace,
    an action that will copy both the Jupyter notebook and the accompanying scripts
    and data that relate to that notebook, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Sample notebooks to help you ramp up the AzureML SDK''s capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Sample notebooks to help you ramp up the AzureML SDK's capabilities
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: These notebooks are up to date with the latest version of the AzureML SDK. The
    code repository where these notebooks are hosted can be found on GitHub at [https://github.com/Azure/MachineLearningNotebooks/](https://github.com/Azure/MachineLearningNotebooks/).
    You can use GitHub to file an issue or search for a code snippet using GitHub's
    search experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every AzureML workspace comes with a storage account, as mentioned in [*Chapter
    2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026), *Deploying Azure Machine
    Learning Workspace Resources*. This storage account contains a **file share**
    prefixed with **code-** that hosts all the notebooks and scripts available within
    the workspace, as shown in the following screenshot. The files in that folder
    share location are the ones that you saw previously within the Studio experience,
    in the **Files** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The Azure portal view of the file share that hosts all'
  prefs: []
  type: TYPE_NORMAL
- en: the code files in the AzureML workspace
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – The Azure portal view of the file share that hosts all the code
    files in the AzureML workspace
  prefs: []
  type: TYPE_NORMAL
- en: Each user gets a separate folder under the **Users** folder where they can organize
    their files. All the files can be accessed by all users that have access to the
    specific AzureML workspace. This makes sharing code very easy. You can point to
    someone who has access to the AzureML workspace to a file by opening the file
    in your browser; then, you can share the URL from the browser navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will create a notebook where you will write and execute
    the code snippets in this chapter. To work with your files, navigate to the `chapter07`
    and then create a notebook named `chapter07.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the three dots next to your username, as shown in the following screenshot.
    From there, you can create folder structures and upload files from your local
    computer. Click on the **Create new folder** option, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The Create new folder option in the Notebooks experience area
    of AzureML Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – The Create new folder option in the Notebooks experience area of
    AzureML Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the pop-up dialog that appears to create a folder named `chapter07`.
    Select that folder and click on the three dots. Then, select the `Users/<username>/chapter07`,
    which means that this file will be placed in the newly created folder. Regarding
    `chapter07.ipynb` and click on the **Create** button, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Creating a notebook to write and execute this chapter''s Python
    scripts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Creating a notebook to write and execute this chapter's Python
    scripts
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create two files in your folder: the notebook file, which will open
    in the editor pane, and a `.amlignore` file, a file you will read about in [*Chapter
    8*](B16777_08_Final_VK_ePub.xhtml#_idTextAnchor117), *Experimenting with Python
    Code*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Editing a notebook within AzureML Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Editing a notebook within AzureML Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the left-hand side of the preceding screenshot, the Notebooks
    experience offers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Files** explorer, where you can create or upload new files and delete,
    download, rename, or move existing files you or your colleagues have created in
    this workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the open file. Note that if you see an asterisk next to the name
    – for example, *** chapter07.ipynb** – this means that the file hasn't been saved
    yet. You can save the file by using the *Ctrl* + *S* shortcut for Windows and
    Linux or the *Cmd* + *S* shortcut for macOS. Alternatively, you can select the
    **Save** option from the **File options** menu, which you will read about next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **File options** menu, where you have options such as the **Save** operation
    and **Focus mode**, which expands the editor pane to occupy most of the browser
    tab space. This is a dynamic menu that's based on the file type you are currently
    editing. In the preceding screenshot, a notebook is open, and the menu is offering
    additional operations such as clearing outputs, restarting the Python kernel,
    or examining the variables that are currently loaded in the Python kernel. You
    can also edit the same file in Jupyter or JupyterLab by clicking on the menu icon,
    which is the icon with the four vertical lines, and selecting the corresponding
    editor from the **Editors** option. Especially for VS Code, a very popular free
    cross-platform code editor, the **Edit in VS Code** option is available in the
    main bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ability to manage the compute instance where you are currently editing the
    specific file. From this section, you can quickly create a new compute instance
    or start/stop an existing one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ability to select the environment to execute the notebook in. By default,
    the AzureML Python kernel is selected, which is the environment where the AzureML
    SDK is already installed. You can change the kernel to an R one if you are editing
    an R file, or you can create your own kernels if you want to customize the environment
    you are working in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main editor pane. This is where you can modify the selected file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your case, the editor pane will be empty, and a single empty cell will be
    visible, as shown in the following screenshot. Each cell can either contain **Markdown**-formatted
    text or Python code. You can convert a cell into a code one by clicking on the
    pop-up menu and selecting the **M****↓** icon:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.10 – An empty code cell'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16777_07_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.10 – An empty code cell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the **M****↓** icon and then hit the **edit** icon to add the following
    Markdown text in the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hit *Shift* + *Enter* on your keyboard to finish editing, execute the cell,
    which in this case will render the formatted text, and move the cursor to the
    next cell. By default, the next cell will be a code one. Add the following Python
    code inside the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that while you start typing, a popup will appear containing code suggestions
    that you can select using the arrow keys. You can confirm your selection by hitting
    the *Enter* button on your keyboard. The list is an intelligent one in that it
    shows classes that start with what you have typed. It also shows frequently used
    classes that you may have misspelled or forgot to type some letters in for. For
    example, the following screenshot shows the `PermissionError` class because you
    may have forgotten to type the `print` statement is incomplete, a wavy underline
    will indicate a syntax error in that portion of the code. To execute a code cell,
    you can hit the *Shift* + *Enter* key combo, or you can click on the round button
    on the left-hand side of the cell:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.11 – IntelliSense suggesting methods and classes that fit the current
    script''s scope'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – IntelliSense suggesting methods and classes that fit the current
    script's scope
  prefs: []
  type: TYPE_NORMAL
- en: 'If an error occurs in the code cell you are executing, the error message will
    appear at the bottom of the cell and the Traceback will appear in the output section
    of the cell, as shown in the following screenshot. You can update the cell''s
    content and rerun the cell to fix this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Script error during notebook cell execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Script error during notebook cell execution
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to use the built-in Notebooks experience to
    author Python scripts. In the next section, you will start writing code fragments
    that utilize the AzureML SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Basic coding with the AzureML SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first class you will work with is the AzureML `Workspace`, a class that
    gives you access to all the resources within your workspace. To create a reference
    to your workspace, you will need the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ab05ab05-ab05-ab05-ab05-ab05ab05ab05`. You can find this ID in the Azure portal
    in the **Properties** tab of the subscription you are using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource group name**: The resource group that contains the AzureML workspace
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workspace name**: The name of the AzureML workspace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can store this information in variables by running the following assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first approach to creating the reference to the workspace is to instantiate
    the `Workspace` class, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the code snippet that you saw in [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053),
    *Configuring the Workspace*, when you created a dataset and explored the **Consume**
    tab of that dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes that you will be writing the code in the notebook you created
    in the previous section, and that you will be editing the notebook using the `azureml-sdk`
    package by issuing the `pip instal azureml-sdk` command. In that case, you will
    be prompted to authenticate your device using an interactive authentication, something
    you will read about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach to creating the reference to the AzureML workspace is to use
    the `get()` method of the `Workspace` class, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, regarding the `ws` variable, you assigned a reference to the AzureML workspace
    that matches the `name`, `subscription_id`, and `resource_group` values that you
    specified in the `workspace_name`, `subscription_id`, and `resource_group` variables
    at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you can invoke functions by passing arguments either by name or by
    position. In the previous examples, we invoked `Workspace.get()`by passing arguments
    by name – that is, we explicitly specified that for the `name` argument, we are
    passing the `workspace_name` variable as its value. When using this approach,
    the order of the arguments is not important. In the example before that, we instantiated
    the `Workspace` class by passing arguments by position. You did not use the `workspace_name=workspace_name`
    assignment. This means that you assigned values to the parameters of the `Workspace`
    class's constructor based on the order they were declared in. In this book, as
    well as in the exam, you will see both ways of performing assignments.
  prefs: []
  type: TYPE_NORMAL
- en: The previous two ways of getting the AzureML workspace reference are identical.
    The main issue with them, however, is that they hardcode the workspace where the
    script is connecting to. Imagine that you want to share a notebook with a friend,
    and you have hardcoded the subscription ID, resource name, and workspace name
    in that notebook. Your friend would have to manually go and edit that cell. This
    problem becomes even more obvious when you want to write a script that runs in
    multiple environments, such as the development environment, the quality assurance
    environment, and the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Workspace` class offers the `from_config()` method to address this issue.
    This method searches the folder tree structure for the `config.json` file, which
    is in the following format and includes all the information that was mentioned
    at the beginning of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the compute instance, this file is located in the root folder
    (`/config.json`) and was automatically created there when you provisioned the
    compute instance within the AzureML workspace. If you want to run the same script
    from your local computer, you can create a similar file, place it next to the
    Python script you are editing, and write the following code to get a reference
    to the AzureML workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to spin up a new AzureML workspace, you can provision one using
    the `Workspace.create()` method. The following code snippet creates an AzureML
    workspace in the West Europe region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This snippet will create an AzureML workspace named `packt-azureml-sdk-mlw`,
    in the subscription with the ID specified by the `subscription_id` variable. This
    resource will be deployed in the `packt-azureml-sdk-rg` resource group, which
    will be created if it does not already exist.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the workspace you just deployed, you can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code deletes the workspace being referenced by the `new_ws` variable and
    removes the dependent resources, which are the storage account, the key vault,
    and the Application Insights resources that were deployed with the AzureML workspace.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to get a reference to and manipulate the workspace
    resource through Python code. This section assumed that you have been using the
    built-in notebook editor of the studio web UI, so you did not have to authenticate.
    If you wanted to run the same code on your computer, you would have to authenticate
    to be able to access the resources, which is something we will look at in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating from your device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In March 2020, the **Notebooks** experience in AzureML Studio requests you
    to authenticate to the compute instance. This is a process you have to do only
    once and it is as simple as clicking the **Authenticate** button that will be
    visible in the Notebooks experience. If you are running the same code from your
    local computer, or if you are trying to execute a Python script within a terminal
    in a compute instance for the very first time, you must run an AzureML SDK command.
    A prompt will ask you to authenticate, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Interactive authentication requested during the first command''s
    execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Interactive authentication requested during the first command's
    execution
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see this message, navigate to the link provided, where you will be asked
    to input the request code displayed in the prompt. In this case, this is **MYRNDCODE**.
    This code is a unique identifier for a request to log in using your identity from
    your computer''s location. Select the account you are planning to use to access
    the various Azure resources, including the AzureML workspace. The following figure
    shows the overall interactive authentication flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Using interactive login to authenticate in a compute instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – Using interactive login to authenticate in a compute instance
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The request code is a short-lived one and it expires in 15 minutes. If you fail
    to complete the process within that time frame, an error will occur, and you will
    have to start over.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your account has access to multiple **Azure Active Directories** (**AADs**),
    for example, your personal AAD from the trial subscription and your company''s
    one, you may need to manually indicate which AAD tenant to authenticate to. This
    can be done by invoking the interactive authentication process manually using
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code initiates the device authentication flow shown in the preceding figure.
    `<AAD tenant id>` is a GUID that you can get from the Azure portal by visiting
    the AAD resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about interactive authentication, which allows
    you to access your AzureML workspace from any device. This authentication method
    should be used when you try to execute a script on a remote computer or if you
    are trying to execute an Azure CLI command. Once authenticated, a token is stored
    within the computer you are executing `InteractiveLoginAuthentication` on and
    you will not be prompted for another login until that token has expired.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will start using the authenticated reference to your
    workspace to deploy compute targets you can use to execute scripts remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Working with compute targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053),
    *Configuring the Workspace*, in the *Provisioning compute resources* section,
    compute resources are machines that allow you to execute scripts remotely. The
    AzureML SDK allows you to list the existing compute targets you may have in your
    workspace or provision new ones if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enumerate the compute targets that you have provisioned or attached to your
    workspace, you can use the reference to the AzureML workspace that you assigned
    to the `ws` variable using `ws = Workspace.from_config()`. The workspace object
    has an attribute named `compute_targets`. This is a Python dictionary that has
    all the compute instance names as keys and a reference to that compute instance
    as a value. To enumerate and print out this list, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output should list at least the `ComputeInstance` area where you are executing
    the script and potentially the `AmlCompute` cluster you created in [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053),
    *Configuring the Workspace*. You will notice that all the compute types are defined
    within the modules of the `azureml.core.compute` package.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This code assumes that you have initialized the `ws` variable, something you
    did earlier on the notebook by following the instructions in the *Basic coding
    with the AzureML SDK* section. If you close the compute instance, the kernel will
    stop, and all the variables you defined by executing the notebook cells will be
    lost. If you want to continue working on a notebook, the easiest approach is to
    rerun all the cells, which will ensure that you have initialized all the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to get a reference to a compute target is to use the `ComputeTarget`
    constructor. You need to pass in the `Workspace` reference and the name of the
    compute target you are looking for. If the target does not exist, a `ComputeTargetException`
    exception will be raised that you have to handle in your code base, as shown in
    the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `ComputeTarget` class offers the `create()` method, which allows you to
    provision various compute targets, including compute instances (the `ComputeInstance`
    class), compute clusters (the `AmlCompute` class), and Azure Kubernetes Service
    (the `AKSCompute` class) targets.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are deploying a compute instance or compute cluster from the AzureML
    Studio web UI, the Azure CLI, or the SDK, the compute target will be provisioned
    in the same resource group and the same Azure Region that your machine learning
    workspace is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provision a compute target, you will need to create a configuration object
    that inherits from the `ComputeTargetProvisioningConfiguration` abstract class.
    In the following example, the script is trying to locate a compute cluster named
    `cpu-sm-cluster`. If the cluster exists, it assigns a reference to the cluster
    to the `cluster` variable. If the cluster does not exist, the script creates an
    instance of the `AmlComputeProvisioningConfiguration` class, which is assigned
    to the `config` variable. This instance is created through the `provisioning_configuration()`
    method of the `AmlCompute` class. This `config` is used to create the cluster
    and wait for the registration in the workspace to complete, showing the creation
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This script specifies the virtual machine's size (the `vm_size` argument). The
    virtual machine is going to be `Standard_D1`, which is a `Standard_NC6`, `Standard_NV24s_v3`,
    and `Standard_ND40rs_v2`. Notice how all the sizes start with **N**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is only specifying the maximum nodes (the `max_nodes` argument)
    that the compute cluster will have. If you do not specify the minimum nodes (the
    `min_nodes` argument), the argument will be the default value of 0\. This means
    that by default, the cluster will scale down to 0 nodes, inflicting no compute
    costs when no job is running. You can find all the default values for all the
    arguments of the `provisioning_configuration()` method on Microsoft''s official
    Python SDK reference page, as shown in the following screenshot, or by using the
    Python `help` command by executing `help(AmlCompute.provisioning_configuration)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Documentation for the provisioning_configuration method of
    the AmlCompute class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Documentation for the provisioning_configuration method of the
    AmlCompute class
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the drawbacks of having 0 minimum nodes in a compute cluster is that
    you will have to wait for the compute nodes to be allocated before the job you
    submitted gets executed. To save this slack time, it is common to scale up the
    minimum and even the maximum nodes of the cluster during workdays, and then change
    those values after business hours to save on costs. To change the number of nodes
    of a compute cluster, you can use the AzureML Studio web UI or the Azure CLI,
    or even update the `min_nodes` attribute of the compute cluster using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Changing the number of minimum and maximum nodes of a compute cluster can be
    done through the AzureML Studio web portal, the CLI, the SDK, and ARM templates.
    Before October 2020, you could also change the number of nodes through the Azure
    portal, a functionality that has been removed since.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to create or get a reference to a compute target
    that you can use to execute scripts. In the next section, you will learn how to
    attach to various data sources through the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Defining datastores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053),
    *Configuring the Workspace*, in the *Connecting to datastores* section, datastores
    are the engines where your data resides and provide access to anyone authorized
    to do so. The AzureML SDK allows you to attach existing datastores to access the
    underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you are going to attach the blob container of a storage account
    to your workspace. Imagine that you have a storage account named **mydatastg**.
    This storage account has a blob container named **existing-container** that contains
    the CSV files you want to analyze and then train models against, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – The container in the mydatastg storage account, as seen in
    the Azure portal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – The container in the mydatastg storage account, as seen in the
    Azure portal
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning new storage accounts and adding containers from the Azure portal
    is an easy task and is outside the scope of the exam. Note that storage accounts
    have unique names. This means that you will probably not be able to provision
    a storage account named **mydatastg** because it belongs to someone else. You
    can use the existing storage account that was provisioned with your AzureML workspace
    to follow these steps. You can add the **existing-container** container to that
    storage account through the Azure portal or you can use the **azureml** container
    that already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register this container as a new datastore in your AzureML workspace, you
    will need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Before going into your notebook, you will need the storage account name and
    the account key. This information is located in the Azure portal, in the **Settings**
    | **Access keys** tab of the storage account resource, as shown in the following
    screenshot:![Figure 7.17 – Storage account name and key required to connect to
    the storage account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16777_07_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.17 – Storage account name and key required to connect to the storage
    account
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to your `chapter07.ipynb` notebook and in a new code cell, assign that information
    to the following Python variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To register the blob container as a new datastore named `my_data_store`, you
    can use the `register_azure_blob_container()` method of the `Datastore` class,
    as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As expected, the method requires a reference to the `Workspace` area where the
    new datastore will be created as an argument. Also, note that the `create_if_not_exists`
    argument is set to `False`, something that will make the method raise an `AzureMissingResourceHttpError`
    exception with an error code of `ContainerNotFound` if that the blob container
    does not exist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similar to the blob container, you can register all supported data storage
    types through the AzureML SDK''s `Datastore` class, as shown in the following
    screenshot. For example, you can use the `register_azure_data_lake_gen2()` method
    to connect to an Azure Data Lake Generation 2 datastore or the `register_azure_sql_database()`
    method to connect to an Azure SQL database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Supported data storage service types from the official documentation
    page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16777_07_018.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.18 – Supported data storage service types from the official documentation
    page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get a reference to the connected datastore, you can use the `Datastore`
    class constructor, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053), *Configuring
    the Workspace*, in the list of datastores, you learn how to set one of the registered
    datastores to the default one for the AzureML workspace. The `Workspace` class
    offers a shortcut that gives a reference to that store using the `get_default_datastore()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the rest of this book, you will be using the default datastore to store data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Datastores that refer to Azure blob containers (the `AzureBlobDatastore` class)
    or Azure file shares (the `AzureFileDatastore` class) can upload and download
    files through the SDK. The following snippet loads the `DataFrame`, which is then
    stored as a local CSV file. Once the file has been stored, the script gets a reference
    to the default datastore of the `Workspace` area, which is referenced in the `ws`
    variable, and uploads that file to `/samples/diabetes/v1/rawdata.csv` using the
    `upload()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This file will appear in the storage account that was created with your AzureML
    workspace. You can find it in the Azure portal by navigating to the storage account,
    selecting the blob container with the name that starts with **azureml-blobstore-**,
    and navigating through the **samples / diabetes / v1** folders, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Uploaded data in the blob container that is registered as the
    default datastore'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – Uploaded data in the blob container that is registered as the
    default datastore
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to attach an existing Azure blob container
    to a new datastore within your AzureML workspace. You also learned how to easily
    get a reference to the workspace's default datastore, and then you uploaded a
    CSV file to that datastore. In the next section, you will learn how to define
    datasets, a construct that will help you work with your data independently from
    where it's stored.
  prefs: []
  type: TYPE_NORMAL
- en: Working with datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in [*Chapter 4*](B16777_04_Final_VK_ePub.xhtml#_idTextAnchor053),
    *Configuring the Workspace*, in the *Working with datasets* section, datasets
    are an abstraction layer on top of the data that you use for training and inference.
    They contain references to the physical data''s location and provide a series
    of metadata that helps you understand their shape and statistical properties.
    They *do not copy* the data that resides within the datastores. AzureML offers
    two types of datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileDataset` allows you to reference a single file or multiple files in one
    or multiple datastores. A common example of `FileDataset` is images that are being
    used to train a computer vision model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TabularDataset` allows you to reference tabular structured data that can be
    stored in a single file or multiple files within datastores or may be stored directly
    in relational datastores such as SQL servers. The diabetes `DataFrame` that you
    loaded in the previous section is a typical tabular dataset. You can create `TabularDataset`
    by parsing various files, including CSV, TSV, Parquet, and JSON files. If your
    data contains a column/feature that has a timestamp, or the files are stored in
    a folder structure that contains a date pattern such as `/<year>/<month>/file.csv`,
    you can enable the time series trait of `TabularDataset`, something that allows
    you to perform time-based filtering of the dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get some hands-on experience with this, you can define a `FileDataset` that
    references the CSV file you uploaded in the default datastore in the previous
    section. Although CSV represents tabular data, it is also a file, something that
    `FileDataset` can referenc:.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new cell in your notebook, type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, there is a reference to the default datastore of the workstation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you can create an array of tuples of `Datastore` and its relative paths.
    Each tuple references a file or a folder within a specific `Datastore`. In this
    case, you are referencing the `samples/diabetes/v1` folder within the default
    `Datastore`. You can use the wildcard character, `*`, to load multiple subfolders
    or partial filenames if you want. For example, the following array of tuples loads
    all the CSV files of all the months in 2021 of the weather data that''s stored
    in `/weather/<year>/<month>/<day>.csv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you wanted to explicitly load the data for the first day (`01.csv`) of January
    (`01`), February (`02`), and March (`03`) only, then you would use the following
    array of tuples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is advised to keep the array's size to less than 100 data path references
    per dataset for performance reasons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returning to the code snippet at the beginning of this section, you can now
    create an unregistered `FileDataset` using the `from_files()` method. Here, you
    must pass the array of data paths as an argument. You must also validate whether
    the data can be loaded or not via the method. If the folder did not exist or the
    datastore was protected with private endpoints and was not directly accessible
    from the compute that is executing the code, you will get `DatasetValidationError`.
    The default value of the `validate` argument is `True`, and you can disable that
    validation by passing `False` in that argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created `FileDataset`, you can get a list of files that were referenced
    by invoking the `to_path()` method. The output of these two prints should look
    as follows:![Figure 7.20 – Unregistered FileDataset referencing a single CSV file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16777_07_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.20 – Unregistered FileDataset referencing a single CSV file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the CSV files, a far better approach would be to define a `TabularDataset`
    that could parse the file and provide us with a pandas `DataFrame`. To do so,
    copy the following code in a new cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this snippet, you are reusing the `file_paths` properties that you used while
    creating `FileDataset`. This time, you are creating an unregistered `TabularDataset`
    using the `from_delimited_files()` method. Also, note that you explicitly skip
    the validation so that the data can be loaded from the current compute (`validate=False`),
    speeding up the declaration process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DataFrame`, and assign it to the `df` variable when you invoke the `to_pandas_dataframe()`
    method. Upon calling the `len()` method, you get the number of rows that `DataFrame`
    has.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far, the datasets that you have created have been unregistered, meaning
    that they did not register within the AzureML workspace, nor were they listed
    in the `register()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you have already registered a dataset with the same name, you will not be
    able to rerun this cell. To register a new version of the dataset you must use
    the `create_new_version` argument as follows: `tabular_dataset.register(workspace=ws,
    name="diabetes", create_new_version=True)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This method requires you to specify the workspace where you want to register
    `TabularDataset` and the name of the registration. Optionally, you can pass a
    description, tags, and whether to create a new version of the dataset with the
    specific name that is already registered in the workspace. Once the dataset has
    been registered, you can review the registration information in the Studio web
    UI, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Registered tabular dataset in the workspace'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16777_07_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.21 – Registered tabular dataset in the workspace
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If, instead of `TabularDataset`, you have a pandas `DataFrame` that you want
    to register, you can use the `register_pandas_dataframe()` method, as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that in this snippet, you are passing the `df` pandas `DataFrame` reference
    and that you are requesting to store that `DataFrame` in the default datastore
    that is referenced by the `dstore` variable, in the `/samples/diabetes` folder.
    This method will create a new folder with a GUID name and store the data in Parquet
    file format. Since the dataset has already been registered and points to a different
    path, the command will create a new version of the dataset. In the Studio experience,
    you will notice that **Version 2** of the dataset was registered. This version
    has a different **relative path**, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.22 – New version of the diabetes dataset, registered directly from
    a pandas DataFrame'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16777_07_022.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.22 – New version of the diabetes dataset, registered directly from
    a pandas DataFrame
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the Parquet file format is a compressed one, which leads to smaller
    files compared to the CSV file you used for the first version of the dataset.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have registered a dataset, either `FileDataset` or `TabularDataset`,
    you can retrieve it using the `get_by_name()` method of the `Dataset` class using
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, you can specify the `version` argument, which is `latest` by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code snippet returns an instance of a `TabularDataset` class,
    but the data hasn''t been loaded yet. You can load the dataset partially using
    various methods of the `TabularDataset` class, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`partial_dataset` is a `TabularDataset` instance that was created from `diabetes_dataset`.
    This dataset skips the first 10 rows of `diabetes_dataset`, keeps two rows, and
    then drops all the columns other than the columns named `0` and `target`. No data
    was loaded during the execution of this multiline statement. Having this unregistered
    `partial_dataset` dataset defined, you can load the data into a pandas `DataFrame`
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display a small table that consists of two rows and two columns,
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Small DataFrame loaded from a sliced tabular dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.23 – Small DataFrame loaded from a sliced tabular dataset
  prefs: []
  type: TYPE_NORMAL
- en: This lazy loading capability of the AzureML dataset classes gives you the flexibility
    to slice and dice huge datasets without having to load them in memory.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned how to work with the Python SDK to deploy compute targets,
    define datastores, and create datasets. In the next section, you will learn how
    to perform similar actions using the Azure CLI tool you saw in [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026),
    *Deploying Azure Machine Learning Workspace Resources*, in the *Using the Azure
    CLI* section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the AzureML CLI extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026), *Deploying
    Azure Machine Learning Workspace Resources*, you learned how to use the Azure
    CLI and how to install the `azure-cli-ml` extension. This extension uses the Python
    SDK you saw in this chapter to perform various operations. To work with the Azure
    CLI, you can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the cloud shell in the Azure portal, as you did in [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026),
    *Deploying Azure Machine Learning Workspace Resources*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal in the compute instance you have been working on in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the shell assignment feature of Jupyter notebooks, which allows you to execute
    commands using the underlying shell by using an exclamation mark (**!**), also
    known as **bang**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this section, you will use the notebook, something that will allow you to
    store the steps and repeat them if you need them in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will need to do is install the `azure-cli-ml` extension
    in the Azure CLI of the compute instance you are currently working on. Create
    a new code cell in the notebook you have been editing so far and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that in [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026),
    *Deploying Azure Machine Learning Workspace Resources*, you executed the same
    command, without the exclamation prefix. The output of this command should be
    similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Installing the AzureML extension'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16777_07_024.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.24 – Installing the AzureML extension
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, you will need to log in using the `az login` command. This command will
    trigger a device authentication process, similar to the one you used at the beginning
    of this chapter when you first tried to connect to the workspace through the SDK.
    Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have access to multiple Azure subscriptions, you will need to select
    the one you are targeting using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From this point on, you can use the AzureML CLI to perform operations against
    the workspace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have multiple AzureML workspaces within your subscription, you will need
    to specify which workspace and in which resource group you are targeting each
    AzureML CLI command. To do that, you will need to use the `-g` and `-w` parameters,
    which we looked at in [*Chapter 2*](B16777_02_Final_VK_ePub.xhtml#_idTextAnchor026),
    *Deploying Azure Machine Learning Workspace Resources*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To list all the compute targets in your workspace, use the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then update `cpu-sm-cluster` so that it has 0 minimum nodes using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the default datastore that is registered in the workspace, you can use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can list the datasets registered in the workspace using the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results of this command should be similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Table-formatted output of the datasets listing within the AzureML
    CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16777_07_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.25 – Table-formatted output of the datasets listing within the AzureML
    CLI
  prefs: []
  type: TYPE_NORMAL
- en: The AzureML CLI offers full access to the SDK options, including the ability
    to create and detach compute targets, datastores, and even define datasets. For
    the exam, you won't need to memorize the commands, so long as you have understood
    that the CLI is using the SDK under the hood and that most of the things you can
    do with the SDK have an equivalent CLI command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how the AzureML Python SDK is structured. You also
    discovered the AzureML notebook editor, which allows you to code Python scripts.
    You then worked with the SDK. You started your coding journey by managing the
    compute targets that are attached to the AzureML workspace. You then attached
    new datastores and got a reference to existing ones, including the default datastore
    for the workspace. Then, you worked with various files and tabular-based datasets
    and learned how to reuse them by registering them in the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you worked with the AzureML CLI extension, which is a client that utilizes
    the Python SDK you explored in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will build on top of this knowledge and learn how to
    use the AzureML SDK during the data science experimentation phase. You will also
    learn how to track metrics on your data science experiments, as well as how to
    scale your training into bigger computes, by running scripts in compute clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please answer the following questions to check your knowledge of the topics
    that were discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the default minimum number of nodes for an AzureML compute cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Equal to the maximum number of nodes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You upload a CSV file to the default datastore that contains credit card transaction
    details. Which of the following methods should you use to create a dataset reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `Dataset.File.from_files()`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. `Dataset.Tabular.from_delimited_files()`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. `Workspace.from_csv_files()`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. `Datastore.from_csv_files()`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How can you force the creation of a blob container during the registration process
    of an Azure blob-based datastore?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Pass the `force_create=True` parameter to the `Datastore.register_azure_blob_container()`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Pass the `create_if_not_exists=True` parameter to the `Datastore.register_azure_blob_container()`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Pass the `force_create=True` parameter to the `Datastore.register_container()`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Pass the `create_if_not_exists=True` parameter to the `Datastore.register_container()`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section offers a list of useful web resources that will help you augment
    your knowledge of the AzureML SDK and the various third-party libraries that were
    used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Supported data storage service types in AzureML: [https://docs.microsoft.com/en-us/azure/machine-learning/how-to-access-data#supported-data-storage-service-types](https://docs.microsoft.com/en-us/azure/machine-learning/how-to-access-data#supported-data-storage-service-types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reference to the `DataFrame` API: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reference to the diabetes dataset that was loaded from the scikit-learn library:
    [https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_diabetes.html](https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_diabetes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AzureML SDK Python API browser, which lists all packages, classes, and methods:
    [https://docs.microsoft.com/en-us/Python/api/?view=azure-ml-py](https://docs.microsoft.com/en-us/Python/api/?view=azure-ml-py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reference to the AzureML CLI extension: [https://docs.microsoft.com/cli/azure/ml(v1)?view=azure-cli-latest](https://docs.microsoft.com/cli/azure/ml(v1)?view=azure-cli-latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Free e-book – Learn Python Programming – Second Edition: [https://www.packtpub.com/free-ebook/learn-Python-programming-second-edition/9781788996662](https://www.packtpub.com/free-ebook/learn-Python-programming-second-edition/9781788996662)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
