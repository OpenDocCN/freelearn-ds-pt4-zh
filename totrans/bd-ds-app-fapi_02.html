<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer009">&#13;
			<h1 id="_idParaDest-14" class="chapter-number"><a id="_idTextAnchor024"/>1</h1>&#13;
			<h1 id="_idParaDest-15"><a id="_idTextAnchor025"/>Python Development Environment Setup</h1>&#13;
			<p>Before we can go through our FastAPI journey, we need to configure a Python environment following the best practices and conventions Python developers use daily to run their projects. By the end of this chapter, you’ll be able to run Python projects and install third-party dependencies in a contained environment that won’t raise conflicts if you happen to work on another project that uses different versions of the Python language <span class="No-Break">or dependencies.</span></p>&#13;
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Installing a Python distribution <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">pyenv</strong></span></li>&#13;
				<li>Creating a Python <span class="No-Break">virtual environment</span></li>&#13;
				<li>Installing Python packages <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pip</strong></span></li>&#13;
				<li>Installing the HTTPie <span class="No-Break">command-line utility</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-16"><a id="_idTextAnchor026"/>Technical requirements</h1>&#13;
			<p>Throughout this book, we’ll assume you have access to a Unix-based environment, such as a Linux distribution <span class="No-Break">or macOS.</span></p>&#13;
			<p>If you haven’t done so already, macOS <a id="_idIndexMarker000"/>users should install the <em class="italic">Homebrew</em> package (<a href="https://brew.sh">https://brew.sh</a>), which helps a lot in installing <span class="No-Break">command-line tools.</span></p>&#13;
			<p>If you are a Windows user, you should <a id="_idIndexMarker001"/>enable <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) (<a href="https://docs.microsoft.com/windows/wsl/install-win10">https://docs.microsoft.com/windows/wsl/install-win10</a>) and install a Linux distribution (such as Ubuntu) that will run alongside the Windows environment, which should give you access to all the required tools. There are currently two versions of WSL: WSL and WSL2. Depending on your Windows version, you might not be able to install the newest version. However, we do recommend using WSL2 if your Windows installation <span class="No-Break">supports it.</span></p>&#13;
			<h1 id="_idParaDest-17"><a id="_idTextAnchor027"/>Installing a Python distribution using pyenv</h1>&#13;
			<p>Python is <a id="_idIndexMarker002"/>already bundled with most Unix environments. To <a id="_idIndexMarker003"/>ensure this is the case, you can run this command in a command line to show the Python version <span class="No-Break">currently installed:</span></p>&#13;
			<pre class="source-code">&#13;
  $ python3 --version</pre>			<p>The output version displayed will vary depending on your system. You may think that this is enough to get started, but it poses an important issue: <em class="italic">you can’t choose the Python version for your project</em>. Each Python version introduces new features and breaking changes. Thus, it’s important to be able to switch to a recent version for new projects to take advantage of the new features but still be able to run older projects that may not be compatible. This is why we <span class="No-Break">need </span><span class="No-Break"><strong class="source-inline">pyenv</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The <strong class="bold">pyenv</strong> tool (<a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a>) helps you manage and switch between multiple <a id="_idIndexMarker004"/>Python versions on your system. It allows you to set a default Python version for your whole system but also <span class="No-Break">per project.</span></p>&#13;
			<p>Beforehand, you need to install several build dependencies on your system to allow <strong class="source-inline">pyenv</strong> to compile Python on your system. The official documentation provides clear guidance on this (<a href="https://github.com/pyenv/pyenv/wiki#suggested-%20build-environment">https://github.com/pyenv/pyenv/wiki#suggested- build-environment</a>), but here are the commands you <span class="No-Break">should run:</span></p>&#13;
			<ol>&#13;
				<li>Install the <span class="No-Break">build dependencies:</span><ul><li>For macOS users, use <span class="No-Break">the following:</span><pre class="source-code">&#13;
<strong class="bold">$ brew install openssl readline sqlite3 xz zlib tcl-tk</strong></pre></li><li>For Ubuntu users, use <span class="No-Break">the following:</span><pre class="source-code"><strong class="bold">$ sudo apt update; sudo apt install make build-essential libssl-dev zlib1g-dev \</strong><strong class="bold">libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \</strong><strong class="bold">libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev</strong></pre></li></ul></li>			</ol>&#13;
			<p class="callout-heading">Package managers</p>&#13;
			<p class="callout"><strong class="source-inline">brew</strong><strong class="source-inline"><a id="_idIndexMarker005"/></strong><strong class="source-inline"> and apt</strong><a id="_idIndexMarker006"/> are what are commonly known as package managers. Their role is to automate the installation and management of software on your system. Thus, you don’t have to worry about where to download them from and how to install and uninstall them. Those commands just tell the package manager<a id="_idIndexMarker007"/> to update its internal package index and then install the list of <span class="No-Break">required packages.</span></p>&#13;
			<ol>&#13;
				<li value="2"><span class="No-Break">Install </span><span class="No-Break"><strong class="source-inline">pyenv</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
<strong class="bold">$ curl https://pyenv.run | bash</strong></pre></li>			</ol>&#13;
			<p class="callout-heading">Tip for macOS users</p>&#13;
			<p class="callout">If you are a macOS user, you can also install it with Homebrew: <strong class="source-inline">brew </strong><span class="No-Break"><strong class="source-inline">install pyenv</strong></span><span class="No-Break">.</span></p>&#13;
			<ol>&#13;
				<li value="3">This <a id="_idIndexMarker008"/>will download and execute an installation <a id="_idIndexMarker009"/>script that will handle everything for you. At the end, it’ll prompt you with some instructions to add some lines to your shell scripts so that <strong class="source-inline">pyenv</strong> is discovered properly by <span class="No-Break">your shell:</span><ul><li>If your shell is <strong class="source-inline">bash</strong> (the default for most Linux distributions and older versions of macOS), run the <span class="No-Break">following commands:</span><pre class="source-code">&#13;
<strong class="bold">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bashrc</strong><strong class="bold">echo 'command -v pyenv &gt;/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bashrc</strong><strong class="bold">echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.bashrc</strong></pre></li><li>If your shell is <strong class="source-inline">zsh</strong> (the default in the latest version of macOS), run the <span class="No-Break">following commands:</span><pre class="source-code"><strong class="bold">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.zshrc</strong><strong class="bold">echo 'command -v pyenv &gt;/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.zshrc</strong><strong class="bold">echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.zshrc</strong></pre></li></ul></li>			</ol>&#13;
			<p class="callout-heading">What is a shell and how do I know the one I’m using?</p>&#13;
			<p class="callout">The shell <a id="_idIndexMarker010"/>is the underlying program running when you start a command line. It’s responsible for interpreting and running your commands. Several variants of those programs have been developed over time, such as <strong class="source-inline">bash</strong> and <strong class="source-inline">zsh</strong>. Even though they have their differences, in particular the names of their configuration files, they are mostly inter-compatible. To find out which shell you’re using, you can run the <strong class="source-inline">echo $</strong><span class="No-Break"><strong class="source-inline">SHELL</strong></span><span class="No-Break"> command.</span></p>&#13;
			<ol>&#13;
				<li value="4">Reload <a id="_idIndexMarker011"/>your shell configuration to apply <span class="No-Break">those</span><span class="No-Break"><a id="_idIndexMarker012"/></span><span class="No-Break"> changes:</span><pre class="source-code">&#13;
<strong class="bold">$ exec "$SHELL"</strong></pre></li>				<li>If everything went well, you should now be able to invoke the <span class="No-Break"><strong class="source-inline">pyenv</strong></span><span class="No-Break"> tool:</span><pre class="source-code">&#13;
<strong class="bold">$ pyenv</strong><strong class="bold">&gt;&gt;&gt; pyenv 2.3.6</strong><strong class="bold">&gt;&gt;&gt; Usage: pyenv &lt;command&gt; [&lt;args&gt;]</strong></pre></li>				<li>We can now install the Python distribution of our choice. Even though FastAPI is compatible with Python 3.7 and later, we’ll use Python 3.10 throughout this book, which has a more mature handling of the asynchronous paradigm and type hinting. All the examples in the book were tested with this version but should work flawlessly with newer versions. Let’s install <span class="No-Break">Python 3.10:</span><pre class="source-code">&#13;
<strong class="bold">$ pyenv install 3.10</strong></pre></li>			</ol>&#13;
			<p>This may take a few minutes since your system will have to compile Python from the source.</p>&#13;
			<p class="callout-heading">What about Python 3.11?</p>&#13;
			<p class="callout">You might wonder why we use Python 3.10 here while <a id="_idIndexMarker013"/>Python 3.11 is already released and is available. At the time of writing, not every library we’ll use throughout this book officially supports this newest version. That’s why we prefer to stick with a more mature version. Don’t worry, though: what you’ll learn here will still be relevant to future versions <span class="No-Break">of Python.</span></p>&#13;
			<ol>&#13;
				<li value="7">Finally, you can set the default Python version with the <span class="No-Break">following command:</span><pre class="source-code">&#13;
<strong class="bold">$ pyenv global 3.10</strong></pre></li>			</ol>&#13;
			<p>This will tell your system to always use Python 3.10 by default unless specified otherwise in a specific project.</p>&#13;
			<ol>&#13;
				<li value="8">To make sure everything is in order, run the following command to check the Python version that is invoked <span class="No-Break">by default:</span><pre class="source-code">&#13;
<strong class="bold">$ python --version</strong><strong class="bold">Python 3.10.8</strong></pre></li>			</ol>&#13;
			<p>Congratulations! You can <a id="_idIndexMarker014"/>now handle any version of Python on<a id="_idIndexMarker015"/> your system and switch it whenever <span class="No-Break">you like!</span></p>&#13;
			<p class="callout-heading">Why does it show 3.10.8 instead of just 3.10?</p>&#13;
			<p class="callout">The 3.10 version<a id="_idIndexMarker016"/> corresponds to a major version of Python. The Python core team regularly publishes major versions with new features, depreciations, and sometimes breaking changes. However, when a new major version is published, previous versions are not forgotten: they continue to receive bug and security fixes. It’s the purpose of the third part of <span class="No-Break">the version.</span></p>&#13;
			<p class="callout">It’s very possible by the time you’re reading this book that you’ve installed a more recent version of Python 3.10, such as 3.10.9. It just means that fixes have been published. You can find more information about how the Python life cycle works and how long the Python core team plans to support previous versions in this official <span class="No-Break">document: </span><a href="https://devguide.python.org/versions/"><span class="No-Break">https://devguide.python.org/versions/</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-18"><a id="_idTextAnchor028"/>Creating a Python virtual environment</h1>&#13;
			<p>As for many programming<a id="_idIndexMarker017"/> languages of today, the power of Python comes from the vast ecosystem of third-party libraries, including FastAPI, of course, that help you build complex and high-quality software very quickly. The <strong class="bold">Python Package Index</strong> (<strong class="bold">PyPi</strong>) (<a href="https://pypi.org">https://pypi.org</a>) is the public <a id="_idIndexMarker018"/>repository that hosts all those packages. This is the default repository that will be used by the built-in Python package <span class="No-Break">manager, </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">.</span></p>&#13;
			<p>By default, when you install a third-party package with <strong class="source-inline">pip</strong>, it will install it for the <em class="italic">whole system</em>. This is different from some other languages, such as Node.js’ <strong class="source-inline">npm</strong>, which by default creates a local directory for the current project to install those dependencies. Obviously, this may cause issues when you work on several Python projects with dependencies having conflicting versions. It also makes it difficult to retrieve only the dependencies necessary to deploy a project properly on <span class="No-Break">a server.</span></p>&#13;
			<p>This is why Python developers generally <a id="_idIndexMarker019"/>use <strong class="bold">virtual environments</strong>. Basically, a virtual environment is just a directory in your project containing a copy of your Python installation and the dependencies of your project. This pattern is so common that the tool to create them is bundled <span class="No-Break">with Python:</span></p>&#13;
			<ol>&#13;
				<li>Create a directory that will contain <span class="No-Break">your project:</span><pre class="source-code">&#13;
<strong class="bold">$ mkdir fastapi-data-science</strong><strong class="bold">$ cd fastapi-data-science</strong></pre></li>			</ol>&#13;
			<p class="callout-heading">Tip for Windows with WSL users</p>&#13;
			<p class="callout">If you are on Windows with WSL, we recommend that you create your working folder on the Windows drive rather than the virtual filesystem of the Linux distribution. It’ll allow you to edit your source code files in Windows with your favorite text editor or <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) while running<a id="_idIndexMarker020"/> them <span class="No-Break">in Linux.</span></p>&#13;
			<p class="callout">To do this, you can access your <strong class="source-inline">C:</strong> drive in the Linux command line through <strong class="source-inline">/mnt/c</strong>. You can thus access your personal documents using the usual Windows path, for example, <span class="No-Break"><strong class="source-inline">cd /mnt/c/Users/YourUsername/Documents</strong></span><span class="No-Break">.</span></p>&#13;
			<ol>&#13;
				<li value="2">You can now create a <span class="No-Break">virtual environment:</span><pre class="source-code">&#13;
<strong class="bold">$ python -m venv venv</strong></pre></li>			</ol>&#13;
			<p>Basically, this command tells Python to run the <strong class="source-inline">venv</strong> package of the standard library to create a virtual environment in the <strong class="source-inline">venv</strong> directory. The name of this directory is a convention, but you can choose another name if you wish.</p>&#13;
			<ol>&#13;
				<li value="3">Once this is done, you have to activate this virtual environment. It’ll tell your shell session to use the Python interpreter and the dependencies in the local directory instead of the global ones. Run the <span class="No-Break">following command:</span><pre class="source-code">&#13;
<strong class="bold">$ source venv/bin/activatee</strong></pre></li>			</ol>&#13;
			<p>After doing this, you may notice the prompt adds the name of the virtual environment:</p>&#13;
			<pre class="source-code">&#13;
<strong class="bold">(venv) $</strong></pre>			<p>Remember that the<a id="_idIndexMarker021"/> activation of this virtual environment is only available for the <em class="italic">current session</em>. If you close it or open other command prompts, you’ll have to activate it again. This is quite easy to forget, but it will become natural after some practice <span class="No-Break">with Python.</span></p>&#13;
			<p>You are now ready to install Python packages safely in <span class="No-Break">your project!</span></p>&#13;
			<h1 id="_idParaDest-19"><a id="_idTextAnchor029"/>Installing Python packages with pip</h1>&#13;
			<p>As we <a id="_idIndexMarker022"/>said earlier, <strong class="source-inline">pip</strong> is the built-in Python package manager<a id="_idIndexMarker023"/> that will help us install <span class="No-Break">third-party libraries.</span></p>&#13;
			<p class="callout-heading">A word on alternate package managers such as Poetry, Pipenv, and Conda</p>&#13;
			<p class="callout">While exploring the Python community, you may hear about alternate package managers such as <a id="_idIndexMarker024"/>Poetry, Pipenv, and Conda<a id="_idIndexMarker025"/>. These managers were created to solve some issues<a id="_idIndexMarker026"/> posed by <strong class="source-inline">pip</strong>, especially around sub-dependencies management. While they are very good tools, we’ll see in <a href="B19528_10.xhtml#_idTextAnchor694"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Deploying a FastAPI Project</em>, that most cloud hosting platforms expect dependencies to be managed with the standard <strong class="source-inline">pip</strong> command. Therefore, they may not be the best choice for a <span class="No-Break">FastAPI application.</span></p>&#13;
			<p>To get started, let’s install FastAPI <span class="No-Break">and Uvicorn:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install fastapi "uvicorn[standard]"</pre>			<p>We’ll talk about it in later chapters, but Uvicorn is required to run a <span class="No-Break">FastAPI project.</span></p>&#13;
			<p class="callout-heading">What does “standard” stand for after “uvicorn”?</p>&#13;
			<p class="callout">You probably noticed the <strong class="source-inline">standard</strong> word inside square brackets just after <strong class="source-inline">uvicorn</strong>. Sometimes, some libraries have sub-dependencies that are not required to make the library work. Usually, they are needed for optional features or specific project requirements. The square brackets are here to indicate that we want to install the standard sub-dependencies <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">uvicorn</strong></span><span class="No-Break">.</span></p>&#13;
			<p>To make<a id="_idIndexMarker027"/> sure the installation worked, we can open a<a id="_idIndexMarker028"/> Python interactive shell and try to import the <span class="No-Break"><strong class="source-inline">fastapi</strong></span><span class="No-Break"> package:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ python&gt;&gt;&gt; from fastapi import FastAPI</pre>&#13;
			<p>If it passes without any errors, congratulations, FastAPI is installed and ready <span class="No-Break">to use!</span></p>&#13;
			<h1 id="_idParaDest-20"><a id="_idTextAnchor030"/>Installing the HTTPie command-line utility</h1>&#13;
			<p>Before getting to the <a id="_idIndexMarker029"/>heart of the topic, there is one last tool that we’ll install. FastAPI<a id="_idIndexMarker030"/> is, as you <a id="_idIndexMarker031"/>probably know, mainly about building <strong class="bold">REST APIs</strong>. Thus, we need a tool to make HTTP requests to our API. To do so, we have <span class="No-Break">several options:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">FastAPI </strong><span class="No-Break"><strong class="bold">automatic documentation</strong></span></li>&#13;
				<li><strong class="bold">Postman</strong>: A GUI <a id="_idIndexMarker032"/>tool to perform <span class="No-Break">HTTP requests</span></li>&#13;
				<li><strong class="bold">cURL</strong>: The <a id="_idIndexMarker033"/>well-known and widely used command-line tool to perform <span class="No-Break">network requests</span></li>&#13;
			</ul>&#13;
			<p>Even if visual tools such as FastAPI automatic documentation and Postman are nice and easy to use, they sometimes lack some flexibility and may not be as productive as command-line tools. On the other hand, cURL is a very powerful tool with thousands of options, but it can be complex and verbose for testing simple <span class="No-Break">REST APIs.</span></p>&#13;
			<p>This is why we’ll introduce <strong class="bold">HTTPie</strong>, a command-line tool aimed at making HTTP requests. Compared to cURL, its syntax is much more approachable and easier to remember, so you can run complex requests off the top of your head. Besides, it comes with built-in JSON support and syntax highlighting. Since it’s a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) tool, we keep all the benefits of the command line: for example, we can directly pipe a JSON file and send it as the body of an HTTP request. It’s available to install from most <span class="No-Break">package managers:</span></p>&#13;
			<ul>&#13;
				<li>macOS users can <span class="No-Break">use this:</span><pre class="source-code">&#13;
<strong class="bold">$ brew install httpie</strong></pre></li>				<li>Ubuntu users can <span class="No-Break">use this:</span><pre class="source-code">&#13;
<strong class="bold">$ sudo apt-get update &amp;&amp; sudo apt-get install httpie</strong></pre></li>			</ul>&#13;
			<p>Let’s see how to <a id="_idIndexMarker034"/>perform simple requests on a <span class="No-Break">dummy API:</span></p>&#13;
			<ol>&#13;
				<li>First, let’s retrieve <span class="No-Break">the data:</span><pre class="source-code">&#13;
<strong class="bold">$ http GET https://603cca51f4333a0017b68509.mockapi.io/todos</strong><strong class="bold">&gt;&gt;&gt;</strong><strong class="bold">HTTP/1.1 200 OK</strong><strong class="bold">Access-Control-Allow-Headers: X-Requested-With,Content-Type,Cache-Control,access_token</strong><strong class="bold">Access-Control-Allow-Methods: GET,PUT,POST,DELETE,OPTIONS</strong><strong class="bold">Access-Control-Allow-Origin: *</strong><strong class="bold">Connection: keep-alive</strong><strong class="bold">Content-Length: 58</strong><strong class="bold">Content-Type: application/json</strong><strong class="bold">Date: Tue, 08 Nov 2022 08:28:30 GMT</strong><strong class="bold">Etag: "1631421347"</strong><strong class="bold">Server: Cowboy</strong><strong class="bold">Vary: Accept-Encoding</strong><strong class="bold">Via: 1.1 vegur</strong><strong class="bold">X-Powered-By: Express</strong><strong class="bold">[</strong><strong class="bold">    {</strong><strong class="bold">        "id": "1",</strong><strong class="bold">        "text": "Write the second edition of the book"</strong><strong class="bold">    }</strong><strong class="bold">]</strong></pre></li>			</ol>&#13;
			<p>As you can see, you <a id="_idIndexMarker035"/>can invoke HTTPie with the <strong class="source-inline">http</strong> command and simply type the HTTP method and the URL. It outputs both the HTTP headers and the JSON body in a clean and formatted way.</p>&#13;
			<ol>&#13;
				<li value="2">HTTPie also <a id="_idIndexMarker036"/>supports sending JSON data in a request body very quickly without having to format the <span class="No-Break">JSON yourself:</span><pre class="source-code">&#13;
<strong class="bold">$ http -v POST https://603cca51f4333a0017b68509.mockapi.io/todos text="My new task"</strong><strong class="bold">POST /todos HTTP/1.1</strong><strong class="bold">Accept: application/json, */*;q=0.5</strong><strong class="bold">Accept-Encoding: gzip, deflate</strong><strong class="bold">Connection: keep-alive</strong><strong class="bold">Content-Length: 23</strong><strong class="bold">Content-Type: application/json</strong><strong class="bold">Host: 603cca51f4333a0017b68509.mockapi.io</strong><strong class="bold">User-Agent: HTTPie/3.2.1</strong><strong class="bold">{</strong><strong class="bold">    </strong><strong class="bold">"text": "My new task"</strong><strong class="bold">}</strong><strong class="bold">HTTP/1.1 201 Created</strong><strong class="bold">Access-Control-Allow-Headers: X-Requested-With,Content-Type,Cache-Control,access_token</strong><strong class="bold">Access-Control-Allow-Methods: GET,PUT,POST,DELETE,OPTIONS</strong><strong class="bold">Access-Control-Allow-Origin: *</strong><strong class="bold">Connection: keep-alive</strong><strong class="bold">Content-Length: 31</strong><strong class="bold">Content-Type: application/json</strong><strong class="bold">Date: Tue, 08 Nov 2022 08:30:10 GMT</strong><strong class="bold">Server: Cowboy</strong><strong class="bold">Vary: Accept-Encoding</strong><strong class="bold">Via: 1.1 vegur</strong><strong class="bold">X-Powered-By: Express</strong><strong class="bold">{</strong><strong class="bold">    "id": "2",</strong><strong class="bold">    "text": "My new task"</strong><strong class="bold">}</strong></pre></li>			</ol>&#13;
			<p>By simply typing the property name and its value separated by <strong class="source-inline">=</strong>, HTTPie will understand that it’s part of the request body in JSON. Notice here that we specified the <strong class="source-inline">-v</strong> option, which tells HTTPie to <em class="italic">output the request</em> before the response, which is very useful to check that we properly specified the request.</p>&#13;
			<ol>&#13;
				<li value="3">Finally, let’s see <a id="_idIndexMarker037"/>how we can specify <span class="No-Break"><em class="italic">request headers</em></span><span class="No-Break">:</span><pre class="source-code">&#13;
<strong class="bold">$ http -v GET https://603cca51f4333a0017b68509.mockapi.io/todos "My-Header: My-Header-Value"</strong><strong class="bold">GET /todos HTTP/1.1</strong><strong class="bold">Accept: */*</strong><strong class="bold">Accept-Encoding: gzip, deflate</strong><strong class="bold">Connection: keep-alive</strong><strong class="bold">Host: 603cca51f4333a0017b68509.mockapi.io</strong><strong class="bold">My-Header: My-Header-Value</strong><strong class="bold">User-Agent: HTTPie/3.2.1</strong><strong class="bold">HTTP/1.1 200 OK</strong><strong class="bold">Access-Control-Allow-Headers: X-Requested-With,Content-Type,Cache-Control,access_token</strong><strong class="bold">Access-Control-Allow-Methods: GET,PUT,POST,DELETE,OPTIONS</strong><strong class="bold">Access-Control-Allow-Origin: *</strong><strong class="bold">Connection: keep-alive</strong><strong class="bold">Content-Length: 90</strong><strong class="bold">Content-Type: application/json</strong><strong class="bold">Date: Tue, 08 Nov 2022 08:32:12 GMT</strong><strong class="bold">Etag: "1849016139"</strong><strong class="bold">Server: Cowboy</strong><strong class="bold">Vary: Accept-Encoding</strong><strong class="bold">Via: 1.1 vegur</strong><strong class="bold">X-Powered-By: Express</strong><strong class="bold">[</strong><strong class="bold">    {</strong><strong class="bold">        "id": "1",</strong><strong class="bold">        "text": "Write the second edition of the book"</strong><strong class="bold">    },</strong><strong class="bold">    {</strong><strong class="bold">        "id": "2",</strong><strong class="bold">        "text": "My new task"</strong><strong class="bold">    }</strong><strong class="bold">]</strong></pre></li>			</ol>&#13;
			<p>That’s it! Just type <a id="_idIndexMarker038"/>your header name and value separated by a colon to tell HTTPie it’s <span class="No-Break">a header.</span></p>&#13;
			<h1 id="_idParaDest-21"><a id="_idTextAnchor031"/>Summary</h1>&#13;
			<p>You now have all the tools and setup required to confidently run the examples of this book and all your future Python projects. Understanding how to work with <strong class="source-inline">pyenv</strong> and virtual environments is a key skill to ensure everything goes smoothly when you switch to another project or when you have to work on somebody else’s code. You also learned how to install third-party Python libraries using <strong class="source-inline">pip</strong>. Finally, you saw how to use HTTPie, a simple and efficient way to run HTTP queries that will make you more productive while testing your <span class="No-Break">REST APIs.</span></p>&#13;
			<p>In the next chapter, we’ll highlight some of Python’s peculiarities as a programming language and grasp what it means <em class="italic">to </em><span class="No-Break"><em class="italic">be Pythonic</em></span><span class="No-Break">.</span></p>&#13;
		</div>&#13;
	</div></body></html>