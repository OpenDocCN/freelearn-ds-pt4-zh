<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer012">&#13;
			<h1 id="_idParaDest-22" class="chapter-number"><a id="_idTextAnchor032"/>2</h1>&#13;
			<h1 id="_idParaDest-23"><a id="_idTextAnchor033"/>Python Programming Specificities</h1>&#13;
			<p>The Python language was designed to emphasize code readability. As such, it provides syntaxes and constructs that allow developers to quickly express complex concepts in a few readable lines. This makes it quite different from other <span class="No-Break">programming languages.</span></p>&#13;
			<p>The goal of this chapter is thus to get you acquainted with its specificities, but we expect you already have some experience with programming. We’ll first get started with the basics of the language, the standard types, and the flow control syntaxes. You’ll also be introduced to the list comprehension and generator concepts, which are very powerful ways to go through and transform sequences of data. You’ll also see that Python can be used as an object-oriented language, still through a very lightweight yet powerful syntax. Before moving on, we’ll also review the concepts of type hinting and asynchronous I/O, which are quite new in Python but are at the core of the <span class="No-Break"><strong class="bold">FastAPI</strong></span><span class="No-Break"> framework.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Basics of <span class="No-Break">Python programming</span></li>&#13;
				<li>List comprehensions <span class="No-Break">and generators</span></li>&#13;
				<li>Classes <span class="No-Break">and objects</span></li>&#13;
				<li>Type hinting and type checking <span class="No-Break">with mypy</span></li>&#13;
				<li><span class="No-Break">Asynchronous I/O</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-24"><a id="_idTextAnchor034"/>Technical requirements</h1>&#13;
			<p>You’ll need a Python virtual environment, as we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>You’ll find all the code examples of this chapter in the book’s dedicated GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter02"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter02</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-25"><a id="_idTextAnchor035"/>Basics of Python programming</h1>&#13;
			<p>First of all, let’s review some of the key aspects <span class="No-Break">of Python:</span></p>&#13;
			<ul>&#13;
				<li>It’s an <strong class="bold">interpreted language</strong>. Contrary to languages such as C or Java, it doesn’t need to be compiled, which <a id="_idIndexMarker039"/>allows us to run Python <span class="No-Break">code interactively.</span></li>&#13;
				<li>It’s <strong class="bold">dynamically typed</strong>. The type of values is determined <span class="No-Break">at runtime.</span></li>&#13;
				<li>It supports several <strong class="bold">programming paradigms</strong>: procedural, object-oriented, and <span class="No-Break">functional programming.</span></li>&#13;
			</ul>&#13;
			<p>This makes Python quite a versatile language, from simple automation scripts to complex data <span class="No-Break">science projects.</span></p>&#13;
			<p>Let’s now write and run <span class="No-Break">some Python!</span></p>&#13;
			<h2 id="_idParaDest-26"><a id="_idTextAnchor036"/>Running Python scripts</h2>&#13;
			<p>As we said, Python is<a id="_idIndexMarker040"/> an interpreted language. Hence, the simplest and<a id="_idIndexMarker041"/> quickest way to run some Python code is to launch an interactive shell. Just run the following command to start <span class="No-Break">a session:</span></p>&#13;
			<pre class="source-code">&#13;
$ pythonPython 3.10.8 (main, Nov    8 2022, 08:55:03) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin&#13;
Type "help", "copyright", "credits" or "license" for more information.&#13;
&gt;&gt;&gt;</pre>&#13;
			<p>This shell makes it very easy to run some simple statements and do <span class="No-Break">some experiments:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; 1 + 12&#13;
&gt;&gt;&gt; x = 100&#13;
&gt;&gt;&gt; x * 2&#13;
200</pre>&#13;
			<p>To exit the shell, use the <em class="italic">Ctrl</em> + <em class="italic">D</em> <span class="No-Break">keyboard shortcut.</span></p>&#13;
			<p>Obviously, this can become tedious when you start to have more statements or if you just wish to keep your work to reuse it later. Python scripts are saved in files with the <strong class="source-inline">.py</strong> extension. Let’s <a id="_idIndexMarker042"/>create a file named <strong class="source-inline">chapter2_basics_01.py</strong> in our project directory and add <span class="No-Break">this code:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_01.py</p>&#13;
			<pre class="source-code">&#13;
print("Hello world!")x = 100&#13;
print(f"Double of {x} is {x * 2}")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_01.py</a></p>&#13;
			<p>Quite simply, this script prints <strong class="source-inline">Hello world</strong> on the console, assigns the value <strong class="source-inline">100</strong> to a variable named <strong class="source-inline">x</strong>, and prints a string with the value of <strong class="source-inline">x</strong> and its double. To run it, simply add the path of your <a id="_idIndexMarker043"/>script as a parameter of the <span class="No-Break">Python command:</span></p>&#13;
			<pre class="source-code">&#13;
$ python chapter2_basics_01.pyHello world!&#13;
Double of 100 is 200</pre>&#13;
			<p class="callout-heading">f-strings</p>&#13;
			<p class="callout">You have probably noticed <a id="_idIndexMarker044"/>the string starting with <strong class="source-inline">f</strong>. This syntax, called <em class="italic">f-strings</em>, is a very convenient and neat way to perform string interpolation. Within, you can simply insert variables between curly braces; they will automatically be converted into strings to build the resulting string. We’ll use it quite often in <span class="No-Break">our examples.</span></p>&#13;
			<p>That’s it! You are now able to write and run simple Python scripts. Let’s now dive deeper into the <span class="No-Break">Python syntax.</span></p>&#13;
			<h2 id="_idParaDest-27"><a id="_idTextAnchor037"/>Indentation matters</h2>&#13;
			<p>One of the most iconic aspects of Python is that code blocks are not defined using curly braces like many other<a id="_idIndexMarker045"/> programming languages, but rather with <strong class="bold">whitespace indentation</strong>. This may sound a bit strange, but it’s at the heart of<a id="_idIndexMarker046"/> the readability philosophy of Python. Let’s see how you can write a script that finds the even numbers in <span class="No-Break">a list:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_02.py</p>&#13;
			<pre class="source-code">&#13;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]even = []&#13;
for number in numbers:&#13;
        if number % 2 == 0:&#13;
                even.append(number)&#13;
print(even)    # [2, 4, 6, 8, 10]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py</a></p>&#13;
			<p>In this script, we define <strong class="source-inline">numbers</strong>, a list of numbers from 1 to 10, and <strong class="source-inline">even</strong>, an empty list that will contain the <span class="No-Break">even numbers.</span></p>&#13;
			<p>Then, we define a <strong class="source-inline">for</strong> loop statement to go through each element of <strong class="source-inline">numbers</strong>. As you see, we open a block with a colon, <strong class="source-inline">:</strong>, break a line, and start writing the next statement with <span class="No-Break">an indentation.</span></p>&#13;
			<p>The next line is a conditional statement to check the parity of the current number. Once again, we open a block with a colon, <strong class="source-inline">:</strong>, and write the next statement with an additional indentation level. This statement adds the even number to the <span class="No-Break">even list.</span></p>&#13;
			<p>After that, the next statements are not intended. This means that we are out of the <strong class="source-inline">for</strong> loop block; they should be executed after the iteration <span class="No-Break">is finished.</span></p>&#13;
			<p>Let’s <span class="No-Break">run it:</span></p>&#13;
			<pre class="source-code">&#13;
$ python chapter02_basics_02.py[2, 4, 6, 8, 10]</pre>&#13;
			<p class="callout-heading">Indentation style and size</p>&#13;
			<p class="callout">You can choose the indentation style (tabs or spaces) and size (2, 4, 6...) you prefer; the only constraint is that you should be consistent <em class="italic">within</em> a block. However, by convention, Python developers usually go for a <span class="No-Break"><em class="italic">four-space indentation</em></span><span class="No-Break">.</span></p>&#13;
			<p>This aspect of Python <a id="_idIndexMarker047"/>may sound weird but with some practice, you’ll find that it enforces clear formatting and greatly improves the readability of <span class="No-Break">your scripts.</span></p>&#13;
			<p>We’ll now review the built-in types and <span class="No-Break">data structures.</span></p>&#13;
			<h2 id="_idParaDest-28"><a id="_idTextAnchor038"/>Working with built-in types</h2>&#13;
			<p>Python is quite<a id="_idIndexMarker048"/> conventional regarding scalar types. There are<a id="_idIndexMarker049"/> six <span class="No-Break">of them:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">int</strong>, to store <strong class="bold">integer</strong> values, such as <strong class="source-inline">x = 1</strong></li>&#13;
				<li><strong class="source-inline">float</strong>, for <strong class="bold">floating-point numbers</strong>, such as <strong class="source-inline">x = </strong><span class="No-Break"><strong class="source-inline">1.5</strong></span></li>&#13;
				<li><strong class="source-inline">complex</strong>, for <strong class="bold">complex numbers</strong>, such as <strong class="source-inline">x = 1 + </strong><span class="No-Break"><strong class="source-inline">2j</strong></span></li>&#13;
				<li><strong class="source-inline">bool</strong>, for <strong class="bold">Boolean</strong> values, either <strong class="source-inline">True</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">False</strong></span></li>&#13;
				<li><strong class="source-inline">str</strong>, for <strong class="bold">string</strong> values, such as <strong class="source-inline">x = "</strong><span class="No-Break"><strong class="source-inline">abc"</strong></span></li>&#13;
				<li><strong class="source-inline">NoneType</strong>, to indicate <strong class="bold">null</strong> values, such as <strong class="source-inline">x = </strong><span class="No-Break"><strong class="source-inline">None</strong></span></li>&#13;
			</ul>&#13;
			<p>It’s worth noting that Python is <strong class="bold">strongly typed</strong>, meaning that the interpreter will limit implicit type conversions. For example, trying to add an <strong class="source-inline">int</strong> value and a <strong class="source-inline">str</strong> value will raise an error, as you can see in the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; 1 + "abc"Traceback (most recent call last):&#13;
    File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: unsupported operand type(s) for +: 'int' and 'str'</pre>&#13;
			<p>Still, adding an <strong class="source-inline">int</strong> value and a <strong class="source-inline">float</strong> value will automatically upcast the result <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">float</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; 1 + 1.52.5</pre>&#13;
			<p>As you may have <a id="_idIndexMarker050"/>noticed, Python is quite traditional <a id="_idIndexMarker051"/>regarding those standard types. Let’s see now how basic data structures <span class="No-Break">are handled.</span></p>&#13;
			<h2 id="_idParaDest-29"><a id="_idTextAnchor039"/>Working with data structures – lists, tuples, dictionaries, and sets</h2>&#13;
			<p>Besides the<a id="_idIndexMarker052"/> scalar types, Python also provides handy data structures: an array structure, of course, called a <em class="italic">list</em> in Python, but also <em class="italic">tuples</em>, <em class="italic">dictionaries</em>, and <em class="italic">sets</em>, which are very convenient in lots of cases. Let’s start <span class="No-Break">with lists.</span></p>&#13;
			<h3>Lists</h3>&#13;
			<p>Lists are the equivalent in<a id="_idIndexMarker053"/> Python of the classic array structure. Defining a list is <a id="_idIndexMarker054"/><span class="No-Break">quite straightforward:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l = [1, 2, 3, 4, 5]</pre>			<p>As you see, wrapping a suite of<a id="_idIndexMarker055"/> elements in <strong class="bold">square brackets</strong> denotes a list. You can, of course, access single elements <span class="No-Break">by index:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[0]1&#13;
&gt;&gt;&gt; l[2]&#13;
3</pre>&#13;
			<p>It also<a id="_idIndexMarker056"/> supports <strong class="bold">negative indexing</strong>, which allows you to retrieve elements from the end of the list: the <strong class="source-inline">-1</strong> index is the last element, <strong class="source-inline">-2</strong> is the second last element, and <span class="No-Break">so on:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[-1]5&#13;
&gt;&gt;&gt; l[-4]&#13;
2</pre>&#13;
			<p>Another useful syntax is slicing, which quickly allows you to retrieve <span class="No-Break">a sub-list:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[1:3][2, 3]</pre>&#13;
			<p>The first number is the<a id="_idIndexMarker057"/> start index (inclusive) and the second one is the end index (exclusive), separated by a colon. You can omit the first one; in this case, <strong class="source-inline">0</strong> <span class="No-Break">is assumed:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[:3][1, 2, 3]</pre>&#13;
			<p>You can also omit the second one; in this case, the length of the list <span class="No-Break">is assumed:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[1:][2, 3, 4, 5]</pre>&#13;
			<p>Finally, this syntax also supports a third argument to specify the step size. It can be useful to select every second element of <span class="No-Break">the list:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[::2][1, 3, 5]</pre>&#13;
			<p>A useful trick with this syntax is to use <strong class="source-inline">-1</strong> to reverse <span class="No-Break">the list:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[::-1][5, 4, 3, 2, 1]</pre>&#13;
			<p>Lists are <strong class="bold">mutable</strong>. This means that you <a id="_idIndexMarker058"/>can reassign elements or add <span class="No-Break">new ones:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l[1] = 10&gt;&gt;&gt; l&#13;
[1, 10, 3, 4, 5]&#13;
&gt;&gt;&gt; l.append(6)&#13;
[1, 10, 3, 4, 5, 6]</pre>&#13;
			<p>This is<a id="_idIndexMarker059"/> different from their <a id="_idIndexMarker060"/>cousins, the tuples, which <span class="No-Break">are </span><span class="No-Break"><strong class="bold">immutable</strong></span><span class="No-Break">.</span></p>&#13;
			<h3>Tuples</h3>&#13;
			<p>Tuples are very similar to<a id="_idIndexMarker061"/> lists. Instead of square brackets, they are defined <a id="_idIndexMarker062"/><span class="No-Break">using parentheses:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; t = (1, 2, 3, 4, 5)</pre>			<p>They support the same syntax as lists to access elements <span class="No-Break">or slicing:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; t[2]3&#13;
&gt;&gt;&gt; t[1:3]&#13;
(2, 3)&#13;
&gt;&gt;&gt; t[::-1]&#13;
(5, 4, 3, 2, 1)</pre>&#13;
			<p>However, tuples are immutable. You can’t reassign elements or add new ones. Trying to do so will raise <span class="No-Break">an error:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; t[1] = 10Traceback (most recent call last):&#13;
    File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: 'tuple' object does not support item assignment&#13;
&gt;&gt;&gt; t.append(6)&#13;
Traceback (most recent call last):&#13;
    File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
AttributeError: 'tuple' object has no attribute 'append'</pre>&#13;
			<p>A common way to use them is for functions that have multiple return values. In the following example, we <a id="_idIndexMarker063"/>define a function to compute and return both the quotient and<a id="_idIndexMarker064"/> remainder of the <span class="No-Break">Euclidean division:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_03.py</p>&#13;
			<pre class="source-code">&#13;
def euclidean_division(dividend, divisor):        quotient = dividend // divisor&#13;
        remainder = dividend % divisor&#13;
        return (quotient, remainder)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py</a></p>&#13;
			<p>This function simply returns the quotient and remainder wrapped in a tuple. Let’s now compute the Euclidean division of <strong class="source-inline">3</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_03.py</p>&#13;
			<pre class="source-code">&#13;
t = euclidean_division(3, 2)print(t[0])    # 1&#13;
print(t[1])    # 1</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py</a></p>&#13;
			<p>In this case, we assign the result to a tuple named <strong class="source-inline">t</strong> and simply retrieve the quotient and remainder <em class="italic">by index</em>. However, we can do something better than that. Let’s compute the Euclidean division of <strong class="source-inline">42</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_03.py</p>&#13;
			<pre class="source-code">&#13;
q, r = euclidean_division(42, 4)print(q)    # 10&#13;
print(r)    # 2</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py</a></p>&#13;
			<p>You can see here that we <a id="_idIndexMarker065"/>directly assign the quotient and remainder to the <strong class="source-inline">q</strong> and <strong class="source-inline">r variables</strong>, respectively. This<a id="_idIndexMarker066"/> syntax is called <strong class="bold">unpacking</strong> and is very<a id="_idIndexMarker067"/> convenient for assigning variables from lists or tuple elements. It’s worth noting that since <strong class="source-inline">t</strong> is a tuple, it’s immutable, so you can’t reassign the values. On the other hand, <strong class="source-inline">q</strong> and <strong class="source-inline">r</strong> are new variables and therefore <span class="No-Break">are mutable.</span></p>&#13;
			<h3>Dictionaries</h3>&#13;
			<p>A dictionary is also a widely used <a id="_idIndexMarker068"/>data structure in Python, used to map keys to <a id="_idIndexMarker069"/>values. One is defined using curly braces, with a list of keys and values separated by <span class="No-Break">a colon:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; d = {"a": 1, "b": 2, "c": 3}</pre>			<p>Elements can be accessed <span class="No-Break">by key:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; d["a"]1</pre>&#13;
			<p>Dictionaries are mutable, so you can reassign or add elements in <span class="No-Break">the mapping:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; d["a"] = 10&gt;&gt;&gt; d&#13;
{'a': 10, 'b': 2, 'c': 3}&#13;
&gt;&gt;&gt; d["d"] = 4&#13;
&gt;&gt;&gt; d&#13;
{'a': 10, 'b': 2, 'c': 3, 'd': 4}</pre>&#13;
			<h3>Sets</h3>&#13;
			<p>A set is a<a id="_idIndexMarker070"/> convenient data structure for storing a collection of unique items. It is<a id="_idIndexMarker071"/> defined using <span class="No-Break">curly braces:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; s = {1, 2, 3, 4, 5}</pre>			<p>Elements can be added to the set, but the structure ensures elements appear <span class="No-Break">only once:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; s.add(1)&gt;&gt;&gt; s&#13;
{1, 2, 3, 4, 5}&#13;
&gt;&gt;&gt; s.add(6)&#13;
{1, 2, 3, 4, 5, 6}</pre>&#13;
			<p>Convenient methods are also provided to perform operations such as unions or intersections on <span class="No-Break">two sets:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; s.union({4, 5, 6}){1, 2, 3, 4, 5, 6}&#13;
&gt;&gt;&gt; s.intersection({4, 5, 6})&#13;
{4, 5}</pre>&#13;
			<p>That’s all for this <a id="_idIndexMarker072"/>overview of the Python data structures. You’ll probably use them quite often in your programs, so<a id="_idIndexMarker073"/> take some time to get acquainted with them. Obviously, we didn’t cover all of their methods and specificities, but you can have a look<a id="_idIndexMarker074"/> at the official Python documentation for exhaustive <span class="No-Break">information: </span><a href="https://docs.python.org/3/library/stdtypes.html"><span class="No-Break">https://docs.python.org/3/library/stdtypes.html</span></a><span class="No-Break">.</span></p>&#13;
			<p>Let’s now talk about the different types of operators available in Python that will allow us to perform some logic on <span class="No-Break">this data.</span></p>&#13;
			<h2 id="_idParaDest-30"><a id="_idTextAnchor040"/>Performing Boolean logic and a few other operators</h2>&#13;
			<p>Predictably, Python<a id="_idIndexMarker075"/> provides operators to perform Boolean logic. However, we’ll also see that there are other operators that are less common but make Python a very efficient language to <span class="No-Break">work with.</span></p>&#13;
			<h3>Performing Boolean logic</h3>&#13;
			<p>Boolean logic is <a id="_idIndexMarker076"/>performed with the <strong class="source-inline">and</strong>, <strong class="source-inline">or</strong>, and <strong class="source-inline">not</strong> keywords. Let’s review some <span class="No-Break">simple examples:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; x = 10&gt;&gt;&gt; x &gt; 0 and x &lt; 100&#13;
True&#13;
&gt;&gt;&gt; x &gt; 0 or (x % 2 == 0)&#13;
True&#13;
&gt;&gt;&gt; not (x &gt; 0)&#13;
False</pre>&#13;
			<p>You’ll probably use them <a id="_idIndexMarker077"/>quite often in your programs, especially with conditional blocks. Let’s now review the <span class="No-Break">identity operators.</span></p>&#13;
			<h3>Checking whether two variables are the same</h3>&#13;
			<p>The <strong class="source-inline">is</strong> and <strong class="source-inline">is not</strong> identity <a id="_idIndexMarker078"/>operators check whether two variables <em class="italic">refer</em> to the same object. This is different from the comparison operators, <strong class="source-inline">==</strong> and <strong class="source-inline">!=</strong>, which check whether two variables have the <span class="No-Break">same </span><span class="No-Break"><em class="italic">value</em></span><span class="No-Break">.</span></p>&#13;
			<p>Internally, Python stores variables in pointers. The goal of the identity operators is thus to check whether two variables actually point to the same object in memory. Let’s review <span class="No-Break">some examples:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [1, 2, 3]&#13;
&gt;&gt;&gt; a is b&#13;
False</pre>&#13;
			<p>Even though the <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> lists are identical, they’re not the same object in memory, so <strong class="source-inline">a is b</strong> is false. However, <strong class="source-inline">a == b</strong> is true. Let’s see what happens if we assign <strong class="source-inline">a</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&#13;
&gt;&gt;&gt; a is b&#13;
True</pre>&#13;
			<p>In this case, the <strong class="source-inline">b</strong> variable will now refer to the same object as <strong class="source-inline">a</strong>, that is, the same list in memory. Thus, the identity operator <span class="No-Break">is true.</span></p>&#13;
			<p class="callout-heading">“is None” or “== None”?</p>&#13;
			<p class="callout">To check whether a variable is null, you could write <strong class="source-inline">a == None</strong>. While it <a id="_idIndexMarker079"/>will work most of the time, it’s<a id="_idIndexMarker080"/> generally advised to write <strong class="source-inline">a </strong><span class="No-Break"><strong class="source-inline">is None</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout">Why? In Python, classes can implement custom comparison operators, so the result of <strong class="source-inline">a == None</strong> may be unpredictable in some cases, since a class can choose to attach a special meaning to the <span class="No-Break"><strong class="source-inline">None</strong></span><span class="No-Break"> value.</span></p>&#13;
			<p>We’ll now review the<a id="_idIndexMarker081"/> <span class="No-Break">membership operators.</span></p>&#13;
			<h3>Checking whether a value is present in a data structure</h3>&#13;
			<p>The membership operators, <strong class="source-inline">in</strong> and <strong class="source-inline">not in</strong>, are very useful for checking whether an element is present in <a id="_idIndexMarker082"/>data structures such as lists or dictionaries. They are idiomatic in Python and make this operation very efficient and easy to write. Let’s review <span class="No-Break">some examples:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; l = [1, 2, 3]&gt;&gt;&gt; 2 in l&#13;
True&#13;
&gt;&gt;&gt; 5 not in l&#13;
True</pre>&#13;
			<p>With the membership operators, we can check in one statement whether an element is present or not in a list. It also works with tuples <span class="No-Break">and sets:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; t = (1, 2, 3)&gt;&gt;&gt; 2 in t&#13;
True&#13;
&gt;&gt;&gt; s = {1, 2, 3}&#13;
&gt;&gt;&gt; 2 in s&#13;
True</pre>&#13;
			<p>Finally, it also works with dictionaries. In this case, the membership operators check whether the <em class="italic">key</em> is present, not <span class="No-Break">the value:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; d = {"a": 1, "b": 2, "c": 3}&gt;&gt;&gt; "b" in d&#13;
True&#13;
&gt;&gt;&gt; 3 in d&#13;
False</pre>&#13;
			<p>We are now clear about<a id="_idIndexMarker083"/> those common operations. We’ll now put them to use with <span class="No-Break">conditional statements.</span></p>&#13;
			<h2 id="_idParaDest-31"><a id="_idTextAnchor041"/>Controlling the flow of a program</h2>&#13;
			<p>A <a id="_idIndexMarker084"/>programming language would not be a programming language without its control flow statements. Once again, you’ll see that Python is a bit different from other languages. Let’s start with <span class="No-Break">conditional statements.</span></p>&#13;
			<h3>Executing operations conditionally – if, elif, and else</h3>&#13;
			<p>Classically, these statements are<a id="_idIndexMarker085"/> here for performing some logic based on some Boolean conditions. In the following example, we’ll consider a situation where we have a <a id="_idIndexMarker086"/>dictionary containing information<a id="_idIndexMarker087"/> about an e-commerce website order. We’ll write a function that will change the order status to the next step given the <span class="No-Break">current status:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_04.py</p>&#13;
			<pre class="source-code">&#13;
def forward_order_status(order):        if order["status"] == "NEW":&#13;
                order["status"] = "IN_PROGRESS"&#13;
        elif order["status"] == "IN_PROGRESS":&#13;
                order["status"] = "SHIPPED"&#13;
        else:&#13;
                order["status"] = "DONE"&#13;
        return order</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_04.py</a></p>&#13;
			<p>The first condition is noted as <strong class="source-inline">if</strong>, followed by a Boolean condition. We then open an indented block, as we explained in the <em class="italic">Indentation matters</em> section of <span class="No-Break">this chapter.</span></p>&#13;
			<p>The alternate<a id="_idIndexMarker088"/> conditions are noted as <strong class="source-inline">elif</strong> (not <strong class="source-inline">else if</strong>) and the fallback<a id="_idIndexMarker089"/> block is noted as <strong class="source-inline">else</strong>. Of course, those are <em class="italic">optional</em> if you don’t need alternate or <span class="No-Break">fallback conditions.</span></p>&#13;
			<p>It’s also worth noting that, contrary<a id="_idIndexMarker090"/> to many other languages, Python does not provide a <span class="No-Break"><strong class="source-inline">switch</strong></span><span class="No-Break"> statement.</span></p>&#13;
			<h3>Repeating operations over an iterator – the for loop statement</h3>&#13;
			<p>We’ll now move on to another classic <a id="_idIndexMarker091"/>control flow statement: the <strong class="source-inline">for</strong> loop. You can repeat operations over a sequence<a id="_idIndexMarker092"/> using the <strong class="source-inline">for</strong> <span class="No-Break">loop statement.</span></p>&#13;
			<p>We already saw an example of the <strong class="source-inline">for</strong> loop in action in the <em class="italic">Indentation matters</em> section of this chapter. As you probably understood, this statement is useful for repeating the execution of a <span class="No-Break">code block.</span></p>&#13;
			<p>You also may have noticed that it works a bit differently from other languages. Usually, programming languages define <strong class="source-inline">for</strong> loops like this: <strong class="source-inline">for (i = 0; i &lt;= 10; i++)</strong>. They give you the responsibility to define and control the variable used for <span class="No-Break">the iteration.</span></p>&#13;
			<p>Python doesn’t work this way. Instead, it expects <a id="_idIndexMarker093"/>you to feed the loop with an <strong class="bold">iterator</strong>. An iterator can be seen as a sequence of elements that you can retrieve one by one. Lists, tuples, dictionaries, and sets can behave like an iterator and be used in a <strong class="source-inline">for</strong> loop. Let’s see <span class="No-Break">some examples:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; for i in [1,2,3]:...         print(i)&#13;
...&#13;
1&#13;
2&#13;
3&#13;
&gt;&gt;&gt; for k in {"a": 1, "b": 2, "c": 3}:&#13;
...         print(k)&#13;
...&#13;
a&#13;
b&#13;
c</pre>&#13;
			<p>But what if you just wish to iterate a certain number of times? Thankfully, Python has built-in functions that generate some useful iterators. The most well known is <strong class="source-inline">range</strong>, which precisely creates a sequence of numbers. Let’s see how <span class="No-Break">it works:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; for i in range(3):...         print(i)&#13;
...&#13;
0&#13;
1&#13;
2</pre>&#13;
			<p><strong class="source-inline">range</strong> will generate a<a id="_idIndexMarker094"/> sequence of the size you provided in the first argument, starting <span class="No-Break">with zero.</span></p>&#13;
			<p>You could also be more precise by specifying two arguments: the start index (inclusive) and the last <span class="No-Break">index (exclusive):</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; for i in range(1, 3):...         print(i)&#13;
...&#13;
1&#13;
2</pre>&#13;
			<p>Finally, you may even provide a step as a <span class="No-Break">third argument:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; for i in range(0, 5, 2):...         print(i)&#13;
...&#13;
0&#13;
2&#13;
4</pre>&#13;
			<p>Note that this syntax<a id="_idIndexMarker095"/> is quite similar to the slicing syntax we saw earlier in this chapter in the sections dedicated to <em class="italic">lists</em> <span class="No-Break">and </span><span class="No-Break"><em class="italic">tuples</em></span><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">range output is not a list</p>&#13;
			<p class="callout">A common misconception is to think <strong class="source-inline">range</strong> returns a <em class="italic">list</em>. It’s actually a <strong class="source-inline">Sequence</strong> object that only stores the <em class="italic">start</em>, <em class="italic">end</em>, and <em class="italic">step</em> arguments. That’s why you could write <strong class="source-inline">range(1000000000)</strong> without blowing up your system’s memory: the billions of elements are not assigned to memory all <span class="No-Break">at once.</span></p>&#13;
			<p>As you see, the <strong class="source-inline">for</strong> loop syntax in Python is quite straightforward to understand and emphasizes readability. We’ll now have a word about its cousin, the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop.</span></p>&#13;
			<h3>Repeating operations until a condition is met – the while loop statement</h3>&#13;
			<p>The classical <strong class="source-inline">while</strong> loop is also available in Python. At the risk of disappointing you, there is nothing truly special <a id="_idIndexMarker096"/>about this one. Classically, this statement allows you to repeat instructions until a condition is met. We’ll review an example in which we use a <strong class="source-inline">while</strong> loop to retrieve paginated elements until we reach <span class="No-Break">the end:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_05.py</p>&#13;
			<pre class="source-code">&#13;
def retrieve_page(page):        if page &gt; 3:&#13;
                return {"next_page": None, "items": []}&#13;
        return {"next_page": page + 1, "items": ["A", "B", "C"]}&#13;
items = []&#13;
page = 1&#13;
while page is not None:&#13;
        page_result = retrieve_page(page)&#13;
        items += page_result["items"]&#13;
        page = page_result["next_page"]&#13;
print(items)    # ["A", "B", "C", "A", "B", "C", "A", "B", "C"]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_05.py</a></p>&#13;
			<p>The <strong class="source-inline">retrieve_page</strong> function<a id="_idIndexMarker097"/> is a dummy function that returns a dictionary with the items for the page passed in an argument and the next page number or <strong class="source-inline">None</strong> if we reached the last page. <em class="italic">A priori</em>, we don’t know how many pages there are. Thus, we repeatedly call <strong class="source-inline">retrieve_page</strong> until the page is <strong class="source-inline">None</strong>. At each iteration, we save the current page items in an <span class="No-Break">accumulator, </span><span class="No-Break"><strong class="source-inline">items</strong></span><span class="No-Break">.</span></p>&#13;
			<p>This kind of use case is quite common when you are dealing with third-party REST APIs and you wish to retrieve all items available, and <strong class="source-inline">while</strong> loops perfectly help <span class="No-Break">with this.</span></p>&#13;
			<p>Finally, there are cases where you wish to prematurely end the loop or skip an iteration. To solve this, Python<a id="_idIndexMarker098"/> implements the classic <strong class="source-inline">break</strong> and <span class="No-Break"><strong class="source-inline">continue</strong></span><span class="No-Break"> statements.</span></p>&#13;
			<h2 id="_idParaDest-32"><a id="_idTextAnchor042"/>Defining functions</h2>&#13;
			<p>Now that we know how to use<a id="_idIndexMarker099"/> the common operators and <a id="_idIndexMarker100"/>control the flow of our program, let’s put it in reusable logic. As you may have guessed, we’ll look at <strong class="bold">functions</strong> and how to define them. We already saw them in some of our previous examples, but let’s introduce them <span class="No-Break">more formally.</span></p>&#13;
			<p>In Python, functions are defined using the <strong class="source-inline">def</strong> keyword followed by the name of the function. Then, you have the list of supported arguments in parentheses, before a colon that indicates the start of the function body. Let’s see a <span class="No-Break">simple example:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; def f(a):...         return a&#13;
...&#13;
&gt;&gt;&gt; f(2)&#13;
2</pre>&#13;
			<p>That’s it! Python also supports default values <span class="No-Break">on arguments:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; def f(a, b = 1):...         return a, b&#13;
...&#13;
&gt;&gt;&gt; f(2)&#13;
(2, 1)&#13;
&gt;&gt;&gt; f(2, 3)&#13;
(2, 3)</pre>&#13;
			<p>When calling a function, you can specify the value of arguments using <span class="No-Break">their name:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; f(a=2, b=3)(2, 3)</pre>&#13;
			<p>Those arguments <a id="_idIndexMarker101"/>are called <em class="italic">keyword arguments</em>. They are<a id="_idIndexMarker102"/> especially <a id="_idIndexMarker103"/>useful if you have several default arguments but only wish to set one <span class="No-Break">of them:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; def f(a = 1, b = 2, c = 3):...         return a, b, c&#13;
...&#13;
&gt;&gt;&gt; f(c=1)&#13;
(1, 2, 1)</pre>&#13;
			<p class="callout-heading">Function naming</p>&#13;
			<p class="callout">By <a id="_idIndexMarker104"/>convention, functions should be named using <strong class="bold">snake case</strong>: <strong class="source-inline">my_wonderful_function</strong> but <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">MyWonderfulFunction</strong></span><span class="No-Break">.</span></p>&#13;
			<p>But there is more! You<a id="_idIndexMarker105"/> can actually define functions accepting a dynamic number <span class="No-Break">of arguments.</span></p>&#13;
			<h3>Accepting arguments dynamically with *args and **kwargs</h3>&#13;
			<p>Sometimes, you may<a id="_idIndexMarker106"/> need a function that supports a dynamic number of arguments. Those arguments are then handled in your function<a id="_idIndexMarker107"/> logic at runtime. To do this, you have to use the <strong class="source-inline">*args</strong> and <strong class="source-inline">**kwargs</strong> syntax. Let’s <a id="_idIndexMarker108"/>define a function that uses this syntax and prints the value of <span class="No-Break">those arguments:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; def f(*args, **kwargs):...         print("args", args)&#13;
...         print("kwargs", kwargs)&#13;
...&#13;
&gt;&gt;&gt; f(1, 2, 3, a=4, b=5)&#13;
args (1, 2, 3)&#13;
kwargs {'a': 4, 'b': 5}</pre>&#13;
			<p>As you can see, standard arguments are placed in a <em class="italic">tuple</em>, in the same order as they were called. Keyword arguments, on the other hand, have been placed in a <em class="italic">dictionary</em>, with the key being the<a id="_idIndexMarker109"/> name of the argument. It’s up to you then to use this<a id="_idIndexMarker110"/> data to perform <span class="No-Break">your logic!</span></p>&#13;
			<p>Interestingly, you can mix both<a id="_idIndexMarker111"/> approaches so that you have hardcoded arguments and <span class="No-Break">dynamic ones:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; def f(a, *args):...         print("a", a)&#13;
...         print("arg", args)&#13;
...&#13;
&gt;&gt;&gt; f(1, 2, 3)&#13;
a 1&#13;
arg (2, 3)</pre>&#13;
			<p>Well done! You have learned how to write functions in Python to organize the logic of your program. The next step now is to organize those functions into modules and import them into other modules to take advantage <span class="No-Break">of them!</span></p>&#13;
			<h2 id="_idParaDest-33"><a id="_idTextAnchor043"/>Writing and using packages and modules</h2>&#13;
			<p>You probably already know that, apart from small scripts, your source code shouldn’t live in one big file with thousands of lines. Instead, you should split it into logical blocks of reasonable size that are easy to maintain. That’s exactly what <a id="_idIndexMarker112"/>packages and modules <a id="_idIndexMarker113"/>are for! We’ll see how they work and how you can define <span class="No-Break">your own.</span></p>&#13;
			<p>First of all, Python <a id="_idIndexMarker114"/>comes with its own set of modules, the standard library, which are directly importable in <span class="No-Break">a program:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.date.today()&#13;
datetime.date(2022, 12, 1)</pre>&#13;
			<p>With just the <strong class="source-inline">import</strong> keyword, you can use the <strong class="source-inline">datetime</strong> module and access all its content by referring to its namespace, <strong class="source-inline">datetime.date</strong>, which is the built-in class to work with dates. However, you may sometimes wish to explicitly import a part of <span class="No-Break">this module:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.today()&#13;
datetime.date(2022, 12, 1)</pre>&#13;
			<p>Here, we explicitly import the <strong class="source-inline">date</strong> class to use it directly. The same principles apply to third-party packages installed with <strong class="source-inline">pip</strong>, such <span class="No-Break">as FastAPI.</span></p>&#13;
			<p>Using existing packages and modules is nice but writing your own is even better. In Python, a <strong class="bold">module</strong> is a single file <a id="_idIndexMarker115"/>containing declarations but can also contain<a id="_idIndexMarker116"/> instructions that will be executed when the module is first imported. You’ll find the definition of a very simple module in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_module.py</p>&#13;
			<pre class="source-code">&#13;
def module_function():        return "Hello world"&#13;
print("Module is loaded")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_module.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_module.py</a></p>&#13;
			<p>This module only contains a function, <strong class="source-inline">module_function</strong>, and a <strong class="source-inline">print</strong> statement. Create a file containing this code at the root of your project directory and name it <strong class="source-inline">module.py</strong>. Then, open a Python interpreter and run <span class="No-Break">this command:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; import moduleModule is loaded</pre>&#13;
			<p>Notice that the <strong class="source-inline">print</strong> statement was executed when you imported it. You can now use <span class="No-Break">the function:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; module.module_function()'Hello world'</pre>&#13;
			<p>Congratulations! You’ve just <a id="_idIndexMarker117"/>written your first <span class="No-Break">Python module!</span></p>&#13;
			<p>Now, let’s see how to <a id="_idIndexMarker118"/>structure a <strong class="bold">package</strong>. A package is a<a id="_idIndexMarker119"/> way to organize modules in a hierarchy, which you can then import using <span class="No-Break">their namespace.</span></p>&#13;
			<p>At the root of your project, create a directory named <strong class="source-inline">package</strong>. Inside, create another directory named <strong class="source-inline">subpackage</strong> and move <strong class="source-inline">module.py</strong> into it. Your project structure should look like the one shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer010" class="IMG---Figure">&#13;
					<img src="Images/Figure_2.1_B19528.jpg" alt="Figure 2.1 – Python package sample hierarchy" width="581" height="339"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Python package sample hierarchy</p>&#13;
			<p>You can then import your module using the <span class="No-Break">full namespace:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; import package.subpackage.moduleModule is loaded</pre>&#13;
			<p>It works! However, to define a proper Python package, it’s <em class="italic">strongly recommended</em> to create an empty <strong class="source-inline">__init__.py</strong> file at the root of each package and sub-package. In older Python versions, it was compulsory <a id="_idIndexMarker120"/>to make a package recognizable<a id="_idIndexMarker121"/> by the interpreter. This became optional in more recent versions, but there are actually some subtle differences between a package with an <strong class="source-inline">__init__.py</strong> file (a package) and one without (a <strong class="bold">namespace package</strong>). We won’t explain it further in this book, but you could check the documentation <a id="_idIndexMarker122"/>about namespace packages here if you wish to learn more <span class="No-Break">details: </span><a href="https://packaging.python.org/en/latest/guides/packaging-namespace-packages/"><span class="No-Break">https://packaging.python.org/en/latest/guides/packaging-namespace-packages/</span></a><span class="No-Break">.</span></p>&#13;
			<p>Therefore, you generally always should create <strong class="source-inline">__init__.py</strong> files. In our example, our project structure would finally look <span class="No-Break">like this:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer011" class="IMG---Figure">&#13;
					<img src="Images/Figure_2.2_B19528.jpg" alt="Figure 2.2 – Python package hierarchy with __init__.py files" width="611" height="496"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Python package hierarchy with __init__.py files</p>&#13;
			<p>It’s worth noting that even if empty <strong class="source-inline">__init__.py</strong> files are perfectly fine, you can actually write some code<a id="_idIndexMarker123"/> in them. In this case, it is executed the first time you import the package or one of its sub-modules. It’s useful to perform <a id="_idIndexMarker124"/>some initialization logic for your package. You now have a good overview of how to write some Python code. Feel free to write some small scripts to get acquainted with its peculiar syntax. We’ll now explore more advanced topics about the language that will prove useful during our journey <span class="No-Break">with FastAPI.</span></p>&#13;
			<h1 id="_idParaDest-34"><a id="_idTextAnchor044"/>Operating over sequences – list comprehensions and generators</h1>&#13;
			<p>In this section, we’ll cover what are probably the most idiomatic constructions in Python: list comprehensions and generators. You’ll see that they are very useful for reading and transforming sequences of data with <span class="No-Break">minimal syntax.</span></p>&#13;
			<h2 id="_idParaDest-35"><a id="_idTextAnchor045"/>List comprehensions</h2>&#13;
			<p>In programming, a very<a id="_idIndexMarker125"/> common task is to transform a <a id="_idIndexMarker126"/>sequence (let’s say, a <em class="italic">list</em>) into another, for example, to filter out or transform elements. Usually, you would write such an operation as we did in one of the previous examples of <span class="No-Break">this chapter:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_basics_02.py</p>&#13;
			<pre class="source-code">&#13;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]even = []&#13;
for number in numbers:&#13;
        if number % 2 == 0:&#13;
                even.append(number)&#13;
print(even)    # [2, 4, 6, 8, 10]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py</a></p>&#13;
			<p>With this approach, we simply iterate over each element, check a condition, and add the element in an accumulator if it passes <span class="No-Break">this condition.</span></p>&#13;
			<p>To go further in its<a id="_idIndexMarker127"/> readability philosophy, Python supports a neat syntax to perform this operation in only one statement: <strong class="bold">list comprehensions</strong>. Let’s see what our previous example looks like with <span class="No-Break">this syntax:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_01.py</p>&#13;
			<pre class="source-code">&#13;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<strong class="bold">even = [number for number in numbers if number % 2 == 0]</strong>&#13;
print(even)    # [2, 4, 6, 8, 10]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_01.py</a></p>&#13;
			<p>That’s it! Basically, a list comprehension works by <em class="italic">packing</em> a <strong class="source-inline">for</strong> loop and wrapping it with square brackets. The element to add to the result list appears first, followed by the iteration. Optionally, we can add a condition, as we did here, to filter some elements of the <span class="No-Break">list input.</span></p>&#13;
			<p>Actually, the result element can be any <a id="_idIndexMarker128"/>valid Python expression. In the following example, we use the <strong class="source-inline">randint</strong> function of the <strong class="source-inline">random</strong> standard module to generate a list of <span class="No-Break">random integers:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_02.py</p>&#13;
			<pre class="source-code">&#13;
from random import randint, seedseed(10)    # Set random seed to make examples reproducible&#13;
<strong class="bold">random_elements = [randint(1, 10) for I in range(5)]</strong>&#13;
print(random_elements)    # [10, 1, 7, 8, 10]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_02.py</a></p>&#13;
			<p>This syntax is widely <a id="_idIndexMarker129"/>used by Python programmers and you’ll probably grow quite fond of it. The nice thing about this syntax is that it also works for <em class="italic">sets</em> and <em class="italic">dictionaries</em>. Quite simply, just replace the square brackets with curly braces to generate <span class="No-Break">a set:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_03.py</p>&#13;
			<pre class="source-code">&#13;
from random import randint, seedseed(10)    # Set random seed to make examples reproducible&#13;
<strong class="bold">random_unique_elements = {randint(1, 10) for i in range(5)}</strong>&#13;
print(random_unique_elements)    # {8, 1, 10, 7}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_03.py</a></p>&#13;
			<p>To<a id="_idIndexMarker130"/> create a dictionary, specify both <a id="_idIndexMarker131"/>the key and the value separated by <span class="No-Break">a colon:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_04.py</p>&#13;
			<pre class="source-code">&#13;
from random import randint, seedseed(10)    # Set random seed to make examples reproducible&#13;
<strong class="bold">random_dictionary = {i: randint(1, 10) for i in range(5)}</strong>&#13;
print(random_dictionary)    # {0: 10, 1: 1, 2: 7, 3: 8, 4: 10}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_04.py</a>eee</p>&#13;
			<h2 id="_idParaDest-36"><a id="_idTextAnchor046"/>Generators</h2>&#13;
			<p>You might think that if you replace the square brackets with parentheses, you could obtain a tuple. Actually, you get a <strong class="bold">generator</strong> object. The main difference between generators and list <a id="_idIndexMarker132"/>comprehensions is that elements are generated <em class="italic">on demand</em> and not <a id="_idIndexMarker133"/>computed and stored all at once in memory. You could see a generator as a recipe to <span class="No-Break">generate values.</span></p>&#13;
			<p>As we said, a generator can be defined simply by using the same syntax as list comprehensions, <span class="No-Break">with parentheses:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_05.py</p>&#13;
			<pre class="source-code">&#13;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<strong class="bold">even_generator = (number for number in numbers if number % 2 == 0)</strong>&#13;
even = list(even_generator)&#13;
even_bis = list(even_generator)&#13;
print(even)    # [2, 4, 6, 8, 10]&#13;
print(even_bis)    # []</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_05.py</a></p>&#13;
			<p>In this example, we define <strong class="source-inline">even_generator</strong> to output the even number of the <strong class="source-inline">numbers</strong> list. Then, we call the <strong class="source-inline">list</strong> constructor with this generator and assign it to the variable named <strong class="source-inline">even</strong>. This constructor will exhaust the iterator passed in the argument and build a proper list. We do it a second time and assign it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">even_bis</strong></span><span class="No-Break">.</span></p>&#13;
			<p>As you can see, <strong class="source-inline">even</strong> is a list with all the even numbers. However, <strong class="source-inline">even_bis</strong> is an <em class="italic">empty</em> list. This simple example is here to show you that a generator can be used <em class="italic">only once</em>. Once all the values have been produced, <span class="No-Break">it’s over.</span></p>&#13;
			<p>This can be useful because you can start to iterate on the generator, stop to do something else, and <span class="No-Break">resume iterating.</span></p>&#13;
			<p>Another way to create<a id="_idIndexMarker134"/> generators is to define <strong class="bold">generator functions</strong>. In the following example, we’ll define a<a id="_idIndexMarker135"/> generator<a id="_idIndexMarker136"/> function that outputs even numbers from <strong class="source-inline">2</strong> to the limit passed in <span class="No-Break">an argument:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_06.py</p>&#13;
			<pre class="source-code">&#13;
def even_numbers(max):        for i in range(2, max + 1):&#13;
                if i % 2 == 0:&#13;
                        <strong class="bold">yield i</strong>&#13;
even = list(even_numbers(10))&#13;
print(even)    # [2, 4, 6, 8, 10]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_06.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_06.py</a></p>&#13;
			<p>As you can see in this function, we use the <strong class="source-inline">yield</strong> keyword instead of <strong class="source-inline">return</strong>. When the interpreter reaches this statement, it <em class="italic">pauses</em> the function execution and <em class="italic">yields</em> the value to the generator consumer. When the main program asks for another value, the function is resumed in order to <span class="No-Break">yield again.</span></p>&#13;
			<p>This allows us to implement complex <a id="_idIndexMarker137"/>generators, even ones that will output different types of values over their course. Another interesting property of generator functions is that they allow us to execute some instructions when they have finished generating values. Let’s add a <strong class="source-inline">print</strong> statement at the end of the function we <span class="No-Break">just reviewed:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_list_comprehensions_07.py</p>&#13;
			<pre class="source-code">&#13;
def even_numbers(max):        for i in range(2, max + 1):&#13;
                if i % 2 == 0:&#13;
                        yield i&#13;
        print("Generator exhausted")&#13;
even = list(even_numbers(10))&#13;
print(even)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_07.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_07.py</a></p>&#13;
			<p>If you execute it in a Python<a id="_idIndexMarker138"/> interpreter, you’ll <a id="_idIndexMarker139"/>get <span class="No-Break">this output:</span></p>&#13;
			<pre class="source-code">&#13;
$ python chapter02_list_comprehensions_07.pyGenerator exhausted&#13;
[2, 4, 6, 8, 10]</pre>&#13;
			<p>We get <strong class="source-inline">Generator exhausted</strong> in the output, which means that our code <em class="italic">after</em> the last <strong class="source-inline">yield</strong> statement is <span class="No-Break">well executed.</span></p>&#13;
			<p>This is especially useful when you want to perform some <em class="italic">cleanup operations</em> after your generator has been exhausted: close a connection, remove temporary files, and <span class="No-Break">so on.</span></p>&#13;
			<h1 id="_idParaDest-37"><a id="_idTextAnchor047"/>Writing object-oriented programs</h1>&#13;
			<p>As we said in the<a id="_idIndexMarker140"/> first section of this chapter, Python is a multi-paradigm language, and<a id="_idIndexMarker141"/> one of those paradigms is <strong class="bold">object-oriented programming</strong>. In this section, we’ll review how you can define classes and how you can instantiate and use objects. You’ll see that Python syntax is once again <span class="No-Break">very lightweight.</span></p>&#13;
			<h2 id="_idParaDest-38"><a id="_idTextAnchor048"/>Defining a class</h2>&#13;
			<p>Defining a class in<a id="_idIndexMarker142"/> Python is straightforward: use the <strong class="source-inline">class</strong> keyword, type the name of your class, and begin a new block. You can then define methods under it just like you would for regular functions. Let’s review <span class="No-Break">an example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_01.py</p>&#13;
			<pre class="source-code">&#13;
class Greetings:        def greet(self, name):&#13;
                return f"Hello, {name}"&#13;
c = Greetings()&#13;
print(c.greet("John"))    # "Hello, John"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_01.py</a></p>&#13;
			<p>Notice that the first argument of each method must be <strong class="source-inline">self</strong>, which is a reference to the current object instance (the equivalent of <strong class="source-inline">this</strong> in <span class="No-Break">other languages).</span></p>&#13;
			<p>To instantiate a class, simply call the <a id="_idIndexMarker143"/>class as you would for a function and assign it to a variable. You can then access the methods using <span class="No-Break">dot notation.</span></p>&#13;
			<p class="callout-heading">Class and method naming</p>&#13;
			<p class="callout">By convention, classes<a id="_idIndexMarker144"/> should be named using <strong class="bold">camel case</strong>: <strong class="source-inline">MyWonderfulClass</strong> but not <strong class="source-inline">my_wonderful_class</strong>. Methods should use snake case, like <span class="No-Break">regular functions.</span></p>&#13;
			<p>Obviously, you can<a id="_idIndexMarker145"/> also set <strong class="bold">class properties</strong>. To do this, we’ll implement the <strong class="source-inline">__init__</strong> method, whose goal is to <span class="No-Break">initialize values:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_02.py</p>&#13;
			<pre class="source-code">&#13;
class Greetings:        def __init__(self, default_name):&#13;
                self.default_name = default_name&#13;
        def greet(self, name=None):&#13;
                return f"Hello, {name if name else self.default_name}"&#13;
c = Greetings("Alan")&#13;
print(c.default_name)    # "Alan"&#13;
print(c.greet())    # "Hello, Alan"&#13;
print(c.greet("John"))    # "Hello, John"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_02.py</a></p>&#13;
			<p>In this example, <strong class="source-inline">__init__</strong> allows us to set a <strong class="source-inline">default_name</strong> property, which will be used by the <strong class="source-inline">greet</strong> method if no name is provided in the argument. As you can see, you can simply access this property through <span class="No-Break">dot notation.</span></p>&#13;
			<p>Be careful though: <strong class="source-inline">__init__</strong> is not a<a id="_idIndexMarker146"/> constructor. In typical object-oriented languages, a constructor is a method to actually create the object in memory. In Python, when <strong class="source-inline">__ init__</strong> is called, the object is already created in memory (notice we have access to the <strong class="source-inline">self</strong> instance). Actually, there is a method to define the constructor, <strong class="source-inline">__new__</strong>, but it’s rarely used in common <span class="No-Break">Python programs.</span></p>&#13;
			<p class="callout-heading">Private methods and properties</p>&#13;
			<p class="callout">In Python, there is no such<a id="_idIndexMarker147"/> thing as <em class="italic">private</em> methods or properties. Everything will always be accessible from the outside. However, by convention, you can prefix your private methods and properties with an underscore to <em class="italic">suggest</em> that they should be considered <span class="No-Break">private: </span><span class="No-Break"><strong class="source-inline">_private_method</strong></span><span class="No-Break">.</span></p>&#13;
			<p>You now have the basics of object-oriented programming in Python! We’ll now focus on magic methods, which will allow us to do clever things <span class="No-Break">with objects.</span></p>&#13;
			<h2 id="_idParaDest-39"><a id="_idTextAnchor049"/>Implementing magic methods</h2>&#13;
			<p>Magic methods are<a id="_idIndexMarker148"/> a set of predefined methods that bear a special meaning in the language. They are easy to recognize as they start and end with two underscores. Actually, we already saw one of those <a id="_idIndexMarker149"/>magic methods: <strong class="source-inline">__init__</strong>! Those methods are not called directly but are used by the interpreter when using other constructs such as standard functions <span class="No-Break">or operators.</span></p>&#13;
			<p>To understand how they are useful, we’ll review the most used ones. Let’s start with <strong class="source-inline">__repr__</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">__str__</strong></span><span class="No-Break">.</span></p>&#13;
			<h3>Object representations – __repr__ and __str__</h3>&#13;
			<p>When you define a class, it’s generally useful to be able to get a readable and clear string representation of an instance. For this purpose, Python provides two magic methods: <strong class="source-inline">__repr__</strong> and <strong class="source-inline">__str__</strong>. Let’s<a id="_idIndexMarker150"/> see how they work on a class representing a<a id="_idIndexMarker151"/> temperature in either degrees Celsius or <span class="No-Break">degrees Fahrenheit:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_03.py</p>&#13;
			<pre class="source-code">&#13;
class Temperature:        def __init__(self, value, scale):&#13;
                self.value = value&#13;
                self.scale = scale&#13;
        def __repr__(self):&#13;
                return f"Temperature({self.value}, {self.scale!r})"&#13;
        def __str__(self):&#13;
                return f"Temperature is {self.value} °{self.scale}"&#13;
t = Temperature(25, "C")&#13;
print(repr(t))    # "Temperature(25, 'C')"&#13;
print(str(t))    # "Temperature is 25 °C"&#13;
print(t)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_03.py</a></p>&#13;
			<p>If you run this example, you’ll <a id="_idIndexMarker152"/>notice that <strong class="source-inline">print(t)</strong> prints the same thing as <strong class="source-inline">print(str(t))</strong>. Through <strong class="source-inline">print</strong>, the interpreter called the <strong class="source-inline">__str__</strong> method to get the string representation of our object. This is what <strong class="source-inline">__str__</strong> is for: giving a <em class="italic">nice string representation</em> of an object for the <span class="No-Break">end user.</span></p>&#13;
			<p>On the other hand, you saw that even<a id="_idIndexMarker153"/> though they’re very similar, we implemented <strong class="source-inline">__repr__</strong> in a different way. The purpose of this method is to give an <em class="italic">internal representation</em> of the object that is unambiguous. By convention, this should give the exact statement that would allow us to recreate the very <span class="No-Break">same object.</span></p>&#13;
			<p>Now that we can represent temperatures with our class, what would happen if we tried to <span class="No-Break">compare them?</span></p>&#13;
			<h3>Comparison methods – __eq__, __gt__, __lt__, and so on</h3>&#13;
			<p>Of course, comparing two <a id="_idIndexMarker154"/>temperatures with different units would lead to <a id="_idIndexMarker155"/>unexpected results. Fortunately, magic methods <a id="_idIndexMarker156"/>allow us to overload the default operators to perform meaningful comparisons. Let’s expand on our <span class="No-Break">previous example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_04.py</p>&#13;
			<pre class="source-code">&#13;
class Temperature:        def __init__(self, value, scale):&#13;
                self.value = value&#13;
                self.scale = scale&#13;
                if scale == "C":&#13;
                        self.value_kelvin = value + 273.15&#13;
                elif scale == "F":&#13;
                        self.value_kelvin = (value–- 32) * 5 / 9 + 273.15</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py</a></p>&#13;
			<p>In the <strong class="source-inline">__init__</strong> method, we<a id="_idIndexMarker157"/> convert the temperature value into Kelvin given <a id="_idIndexMarker158"/>the current scale. This will help us to make <a id="_idIndexMarker159"/>comparisons. Then, let’s define <strong class="source-inline">__eq__</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">__lt__</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_04.py</p>&#13;
			<pre class="source-code">&#13;
        def __eq__(self, other):                return self.value_kelvin == other.value_kelvin&#13;
        def __lt__(self, other):&#13;
                return self.value_kelvin &lt; other.value_kelvin</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py</a></p>&#13;
			<p>As you can see, those methods simply accept another argument, which is the other object instance to compare with. We then just have to perform our comparison logic. By doing this, we can perform comparison just as we would for <span class="No-Break">any variable:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_04.py</p>&#13;
			<pre class="source-code">&#13;
tc = Temperature(25, "C")tf = Temperature(77, "F")&#13;
tf2 = Temperature(100, "F")&#13;
print(tc == tf)    # True&#13;
print(tc &lt; tf2)    # True</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py</a></p>&#13;
			<p>That’s it! If you wish to have all the<a id="_idIndexMarker160"/> comparison operators available, you should<a id="_idIndexMarker161"/> also implement all the other comparison <a id="_idIndexMarker162"/>magic methods: <strong class="source-inline">__le__</strong>, <strong class="source-inline">__gt__</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">__ge__</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">The type of the other instance is not guaranteed</p>&#13;
			<p class="callout">In this example, we assumed the <strong class="source-inline">other</strong> variable was also a <strong class="source-inline">Temperature</strong> object. In the real world, however, this is not guaranteed and developers could try to compare <strong class="source-inline">Temperature</strong> with another object, which would likely lead to errors or weird behaviors. To prevent this, you should check the type of the <strong class="source-inline">other</strong> variable using <strong class="source-inline">isinstance</strong> to ensure we handle <strong class="source-inline">Temperature</strong>, or raise a proper <span class="No-Break">exception otherwise.</span></p>&#13;
			<h3>Operators – __add__, __sub__, __mul__, and so on</h3>&#13;
			<p>Similarly, you could also define what <a id="_idIndexMarker163"/>would happen when trying to add or multiply two <strong class="source-inline">Temperature</strong> objects. We won’t go into much detail here as it works exactly like the <span class="No-Break">comparison operators.</span></p>&#13;
			<h3>Callable object – __call__</h3>&#13;
			<p>The last magic <a id="_idIndexMarker164"/>method we’ll review is <strong class="source-inline">__call__</strong>. This one is a bit special because it enables you to call your object instance like a <em class="italic">regular function</em>. Let’s take <span class="No-Break">an example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_05.py</p>&#13;
			<pre class="source-code">&#13;
class Counter:        def __init__(self):&#13;
                self.counter = 0&#13;
        def __call__(self, inc=1):&#13;
                self.counter += inc&#13;
c = Counter()&#13;
print(c.counter)    # 0&#13;
c()&#13;
print(c.counter)    # 1&#13;
c(10)&#13;
print(c.counter)    # 11</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_05.py</a></p>&#13;
			<p>The <strong class="source-inline">__call__</strong> method can be defined like any other method, with any argument you wish. The only difference is how you call it: you just pass the argument directly on the object instance variable as you would do for a <span class="No-Break">regular function.</span></p>&#13;
			<p>This pattern can be <a id="_idIndexMarker165"/>useful if you want to define a function that maintains some kind of local state, as we did here in our example, or in cases where you need to provide a <strong class="bold">callable</strong> object but have to set some parameters. Actually, this is the use case we’ll encounter when defining class dependencies <span class="No-Break">for FastAPI.</span></p>&#13;
			<p>As we saw, magic methods are an excellent way to implement operations for our custom classes and make them easy to use in a purely object-oriented way. We haven’t covered every magic method available but you can find the complete list in the official <span class="No-Break">documentation: </span><a href="https://docs.python.org/3/reference/datamodel.html#special-method-names"><span class="No-Break">https://docs.python.org/3/reference/datamodel.html#special-method-names</span></a><span class="No-Break">.</span></p>&#13;
			<p>We’ll now focus on<a id="_idIndexMarker166"/> another essential characteristic of object-oriented <span class="No-Break">programming: inheritance.</span></p>&#13;
			<h2 id="_idParaDest-40"><a id="_idTextAnchor050"/>Reusing logic and avoiding repetition with inheritance</h2>&#13;
			<p>Inheritance is one of the<a id="_idIndexMarker167"/> core concepts of object-oriented programming: it allows you to derive a new class from existing ones, enabling you to reuse some logic and overload the parts that are specific to this <a id="_idIndexMarker168"/>new class. Of course, this is supported in Python. We’ll take very simple examples to understand the <span class="No-Break">mechanism underneath.</span></p>&#13;
			<p>First of all, let’s take an example of very <span class="No-Break">simple inheritance:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_06.py</p>&#13;
			<pre class="source-code">&#13;
class A:        def f(self):&#13;
                return "A"&#13;
class Child(A):&#13;
        pass</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_06.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_06.py</a></p>&#13;
			<p>The <strong class="source-inline">Child</strong> class inherits <a id="_idIndexMarker169"/>from the <strong class="source-inline">A</strong> class. The syntax is simple: the class we want to inherit from is specified between parentheses after the child <span class="No-Break">class name.</span></p>&#13;
			<p class="callout-heading">The pass statement</p>&#13;
			<p class="callout"><strong class="source-inline">pass</strong> is a statement that <em class="italic">does nothing</em>. Since Python relies only on indentation to denote blocks, it’s a useful statement<a id="_idIndexMarker170"/> to create an <em class="italic">empty block</em>, as you would do with curly braces in other <span class="No-Break">programming languages.</span></p>&#13;
			<p class="callout">In this example, we don’t want to add some logic to the <strong class="source-inline">Child</strong> class, so we just <span class="No-Break">write </span><span class="No-Break"><strong class="source-inline">pass</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout">Another way to do it is to add a docstring just below the <span class="No-Break">class definition.</span></p>&#13;
			<p>If you wish to overload a method <a id="_idIndexMarker171"/>but still want to get the result of the parent method, you can call the <span class="No-Break"><strong class="source-inline">super</strong></span><span class="No-Break"> function:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_07.py</p>&#13;
			<pre class="source-code">&#13;
class A:        def f(self):&#13;
                return "A"&#13;
class Child(A):&#13;
        def f(self):&#13;
                parent_result = super().f()&#13;
                return f"Child {parent_result}"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_07.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_07.py</a></p>&#13;
			<p>You now know how to<a id="_idIndexMarker172"/> use basic inheritance in Python. But there is more: we can also have <span class="No-Break">multiple inheritance!</span></p>&#13;
			<h3>Multiple inheritance</h3>&#13;
			<p>As its name suggests, multiple<a id="_idIndexMarker173"/> inheritance allows you to derive a child class from multiple classes. This way, you can combine the logic of several classes into one. Let’s take <span class="No-Break">an example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_08.py</p>&#13;
			<pre class="source-code">&#13;
class A:        def f(self):&#13;
                return "A"&#13;
class B:&#13;
        def g(self):&#13;
                return "B"&#13;
class Child(A, B):&#13;
        pass</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_08.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_08.py</a></p>&#13;
			<p>Once again, the syntax is quite <a id="_idIndexMarker174"/>straightforward: just list all the parent classes with a comma. Now, the <strong class="source-inline">Child</strong> class can call both methods, <strong class="source-inline">f</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">g</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">Mixins</p>&#13;
			<p class="callout">Mixins are common<a id="_idIndexMarker175"/> patterns in Python that take advantage of the multiple inheritance feature. Basically, mixins are short classes containing a single feature that you often want to reuse. You can then compose concrete classes by <span class="No-Break">combining mixins.</span></p>&#13;
			<p>However, what would happen if both <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> classes implemented a method named <strong class="source-inline">f</strong>? Let’s try <span class="No-Break">it out:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_classes_objects_09.py</p>&#13;
			<pre class="source-code">&#13;
class A:        def f(self):&#13;
                return "A"&#13;
class B:&#13;
        def f(self):&#13;
                return "B"&#13;
class Child(A, B):&#13;
        pass</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_09.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_09.py</a></p>&#13;
			<p>If you call the <strong class="source-inline">f</strong> method of <strong class="source-inline">Child</strong>, you’ll get the value <strong class="source-inline">"A"</strong>. In this simple case, Python will consider the first <a id="_idIndexMarker176"/>matching method following the order of the parent classes. However, for more complex hierarchies, the resolution may not be<a id="_idIndexMarker177"/> so obvious: this is the purpose of the <strong class="bold">Method Resolution Order</strong> (<strong class="bold">MRO</strong>) algorithm. We won’t go into much detail here but you can have a look at the official document explaining the algorithm implemented by <span class="No-Break">Python: </span><a href="https://www.python.org/download/releases/2.3/mro/"><span class="No-Break">https://www.python.org/download/releases/2.3/mro/</span></a><span class="No-Break">.</span></p>&#13;
			<p>If you are confused about the MRO of your class, you can call the <strong class="source-inline">mro</strong> method on your class to get a list of considered classes <span class="No-Break">in order:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; Child.mro()[&lt;class 'chapter2_classes_objects_09.Child'&gt;, &lt;class 'chapter2_classes_objects_09.A'&gt;, &lt;class 'chapter2_classes_objects_09.B'&gt;, &lt;class 'object'&gt;]</pre>&#13;
			<p>Well done! You now have a good overview of object-oriented programming in Python. Those concepts will be helpful when defining dependencies <span class="No-Break">in FastAPI.</span></p>&#13;
			<p>We’ll now review some of the most recent and trending features in Python, upon which FastAPI relies heavily. We’ll start with <span class="No-Break"><strong class="bold">type hinting</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-41"><a id="_idTextAnchor051"/>Type hinting and type checking with mypy</h1>&#13;
			<p>In the first section of this chapter, we said that Python was a dynamically typed language: the interpreter doesn’t check types at compile time but rather at runtime. This makes the language a bit more flexible and the developer a bit more efficient. However, if you are experienced with that kind of language, you probably know that it’s easy to produce errors and bugs in this context: forgetting arguments, type mismatches, and <span class="No-Break">so on.</span></p>&#13;
			<p>This is why Python introduced type hinting starting in <em class="italic">version 3.5</em>. The goal is to provide a syntax to annotate the source <a id="_idIndexMarker178"/>code with <strong class="bold">type annotations</strong>: each variable, function, and class can be annotated to give indications about the types they expect. This <em class="italic">doesn’t mean</em> that Python becomes a statically typed language. Those annotations remain completely <em class="italic">optional</em> and are <em class="italic">ignored</em> by the interpreter. However, those annotations can be<a id="_idIndexMarker179"/> used by <strong class="bold">static type checkers</strong>, which will check whether your code is valid and consistent following the annotations. Hence, it greatly helps you to<a id="_idIndexMarker180"/> reduce errors and write self-explanatory code. One of<a id="_idIndexMarker181"/> those tools, <strong class="source-inline">mypy</strong>, is widely used by the community in <span class="No-Break">this context.</span></p>&#13;
			<h2 id="_idParaDest-42"><a id="_idTextAnchor052"/>Getting started</h2>&#13;
			<p>To understand how <a id="_idIndexMarker182"/>type annotations work, we’ll review a simple <span class="No-Break">annotated function:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_01.py</p>&#13;
			<pre class="source-code">&#13;
def greeting(name: str) -&gt; str:        return f"Hello, {name}"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_01.py</a></p>&#13;
			<p>As you can see here, we simply added the type of the <strong class="source-inline">name</strong> argument after a colon. We also specified the <strong class="bold">return type</strong> after an arrow. For built-in types, such as <strong class="source-inline">str</strong> or <strong class="source-inline">int</strong>, we can simply use them as type annotations. We’ll see a little later in this section how to annotate more complex types such as lists <span class="No-Break">or dictionaries.</span></p>&#13;
			<p>We’ll now install <strong class="source-inline">mypy</strong> to perform a type check on this file. This can be done like any other <span class="No-Break">Python package:</span></p>&#13;
			<pre class="source-code">&#13;
$ pip install mypy</pre>			<p>Then, you can run a type check on your <span class="No-Break">source file:</span></p>&#13;
			<pre class="source-code">&#13;
$ mypy chapter02_type_hints_01.pySuccess: no issues found in 1 source file</pre>&#13;
			<p>As you can see, <strong class="source-inline">mypy</strong> tells us that everything is good with our typing. Let’s try to modify our code a bit to provoke a <span class="No-Break">type error:</span></p>&#13;
			<pre class="source-code">&#13;
def greeting(name: str) -&gt; int:        return f"Hello, {name}"</pre>&#13;
			<p>Quite simply, we just said that the return type of our function is now <strong class="source-inline">int</strong>, but we are still returning a string. If you run this code, it’ll execute perfectly well: as we said, the interpreter ignores type annotations. However, let’s see what <strong class="source-inline">mypy</strong> tells us <span class="No-Break">about it:</span></p>&#13;
			<pre class="source-code">&#13;
$ mypy chapter02_type_hints_01.pychapter02_type_hints_01.py:2: error: Incompatible return value type (got "str", expected "int")    [return-value]&#13;
Found 1 error in 1 file (checked 1 source file)</pre>&#13;
			<p>This time, it <a id="_idIndexMarker183"/>complains. It clearly<a id="_idIndexMarker184"/> tells us what is wrong here: the return value is a<a id="_idIndexMarker185"/> string, while an integer <span class="No-Break">was expected!</span></p>&#13;
			<p class="callout-heading">Code editors and IDE integration</p>&#13;
			<p class="callout">Having type checking is good, but it <a id="_idIndexMarker186"/>may be a bit tedious to run <strong class="source-inline">mypy</strong> manually on the<a id="_idIndexMarker187"/> command line. Fortunately, it integrates well with the most popular code editors and IDEs. Once configured, it’ll perform type checking while you type and show you errors directly on faulty lines. Type annotations also help the IDE to perform clever things such <span class="No-Break">as </span><span class="No-Break"><em class="italic">auto-completion</em></span><span class="No-Break">.</span></p>&#13;
			<p class="callout">You can check in the official <a id="_idIndexMarker188"/>documentation of <strong class="source-inline">mypy</strong> how to set it up for your favorite <span class="No-Break">editor: </span><a href="https://github.com/python/mypy#integrations"><span class="No-Break">https://github.com/python/mypy#integrations</span></a><span class="No-Break">.</span></p>&#13;
			<p>You understand the basics of type hinting in Python. We’ll now review more advanced examples, especially with <span class="No-Break">non-scalar types.</span></p>&#13;
			<h2 id="_idParaDest-43"><a id="_idTextAnchor053"/>Type data structures</h2>&#13;
			<p>So far, we’ve seen how to annotate <a id="_idIndexMarker189"/>variables for scalar types such as <strong class="source-inline">str</strong> or <strong class="source-inline">int</strong>. But we’ve seen that there are data structures such as lists and dictionaries that are widely used in Python. In the following example, we’ll show how to type-hint the basic data structures <span class="No-Break">in Python:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_02.py</p>&#13;
			<pre class="source-code">&#13;
l: list[int] = [1, 2, 3, 4, 5]t: tuple[int, str, float] = (1, "hello", 3.14)&#13;
s: set[int] = {1, 2, 3, 4, 5}&#13;
d: dict[str, int] = {"a": 1, "b": 2, "c": 3}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_02.py</a></p>&#13;
			<p>You can see here that we can use the <strong class="source-inline">list</strong>, <strong class="source-inline">tuple</strong>, <strong class="source-inline">set</strong>, and <strong class="source-inline">dict</strong> standard classes as type hints. However, they<a id="_idIndexMarker190"/> expect you to provide the type of the values composing your structure. It’s the<a id="_idIndexMarker191"/> well-known concept of <strong class="bold">generics</strong> in object-oriented programming. In Python, they are defined using <span class="No-Break">square brackets.</span></p>&#13;
			<p>Of course, there are more complex use cases. For example, having a list with elements of different types is perfectly valid in Python. To make this work with type checkers, we can simply use the <strong class="source-inline">|</strong> notation to specify several <span class="No-Break">allowed types:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_03.py</p>&#13;
			<pre class="source-code">&#13;
l: list[int | float] = [1, 2.5, 3.14, 5]</pre>			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_03.py</a></p>&#13;
			<p>In this case, our list will accept either integers or floating-point numbers. Of course, <strong class="source-inline">mypy</strong> will complain if you try to add an element in this list that is neither an <strong class="source-inline">int</strong> nor a <span class="No-Break"><strong class="source-inline">float</strong></span><span class="No-Break"> type.</span></p>&#13;
			<p>There is also another case where this is useful: quite often, you’ll have function arguments or return types that either return a value or <strong class="source-inline">None</strong>. Thus, you could write something <span class="No-Break">like this:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_04.py</p>&#13;
			<pre class="source-code">&#13;
def greeting(name: str | None = None) -&gt; str:        return f"Hello, {name if name else 'Anonymous'}"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_04.py</a></p>&#13;
			<p>The allowed value is<a id="_idIndexMarker192"/> either a string <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">None</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">Type annotations were different before Python 3.9</p>&#13;
			<p class="callout">Before Python 3.9, it wasn’t possible to annotate lists, tuples, sets, and dictionaries using the standard class. We needed to import special classes from the <strong class="source-inline">typing</strong> module: <strong class="source-inline">l: List[int] = [1, 2, 3, </strong><span class="No-Break"><strong class="source-inline">4, 5]</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout">The <strong class="source-inline">|</strong> notation wasn’t available either. We needed to use a special <strong class="source-inline">Union</strong> class from <strong class="source-inline">typing</strong>: <strong class="source-inline">l: List[Union[int, float]] = [1, 2.5, </strong><span class="No-Break"><strong class="source-inline">3.14, 5]</strong></span></p>&#13;
			<p class="callout">This way of annotating is now deprecated, but you may still find it in older <span class="No-Break">code bases.</span></p>&#13;
			<p>When dealing with complex types, it may be useful to <em class="italic">alias</em> and reuse them at will without the need to rewrite them each time. To do this, you can simply assign them as you would do for <span class="No-Break">any variable:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_05.py</p>&#13;
			<pre class="source-code">&#13;
IntStringFloatTuple = tuple[int, str, float]t: IntStringFloatTuple = (1, "hello", 3.14)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_05.py</a></p>&#13;
			<p>By convention, types should be named using camel case, like classes. Talking about classes, let’s see how type hinting works <span class="No-Break">with them:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_06.py</p>&#13;
			<pre class="source-code">&#13;
class Post:        def __init__(self, title: str) -&gt; None:&#13;
                self.title = title&#13;
        def __str__(self) -&gt; str:&#13;
                return self.title&#13;
posts: list[Post] = [Post("Post A"), Post("Post B")]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_06.py</p>&#13;
			<p>Actually, there is <a id="_idIndexMarker193"/>nothing special about classes’ type hinting. You just annotate the methods as you would for a regular function. If you need to use your class in an annotation, like here for a list of posts, you just have to use the <span class="No-Break">class name.</span></p>&#13;
			<p>Sometimes, you’ll have to write a function or method that accepts another function in an argument. In this case, you’ll need to give the <strong class="bold">type signature</strong> of <span class="No-Break">this function.</span></p>&#13;
			<h2 id="_idParaDest-44"><a id="_idTextAnchor054"/>Type function signatures with Callable</h2>&#13;
			<p>A more advanced use case is to be<a id="_idIndexMarker194"/> able to have types for function<a id="_idIndexMarker195"/> signatures. For example, it can be useful when you need to pass functions as arguments of other functions. For this task, we can use the <strong class="source-inline">Callable</strong> class, available in the <strong class="source-inline">collections.abc</strong> module. In the following example, we’ll implement a function called <strong class="source-inline">filter_list</strong> expecting as arguments a list of integers and a function returning a Boolean given <span class="No-Break">an integer:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_07.py</p>&#13;
			<pre class="source-code">&#13;
from collections.abc import CallableConditionFunction = Callable[[int], bool]&#13;
def filter_list(l: list[int], condition: ConditionFunction) -&gt; list[int]:&#13;
        return [i for i in l if condition(i)]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py</a></p>&#13;
			<p class="callout-heading">What is the collections.abc module?</p>&#13;
			<p class="callout"><strong class="source-inline">collections.abc</strong> is a<a id="_idIndexMarker196"/> module from the standard Python library providing abstract base classes for the common objects we use daily in Python: iterators, generators, callables, sets, mappings, and so on. They are mainly useful in advanced use cases where we need to implement new custom objects that should behave <em class="italic">like</em> an iterator, generator, and so on. Here, we only use them as <span class="No-Break">type hints.</span></p>&#13;
			<p>You can see here that we<a id="_idIndexMarker197"/> define a type alias, <strong class="source-inline">ConditionFunction</strong>, thanks to <strong class="source-inline">Callable</strong>. Once again, this is a generic class that expects two things: first, the list of argument types and then the return type. Here, we expect a single integer <a id="_idIndexMarker198"/>argument and the return type is <span class="No-Break">a Boolean.</span></p>&#13;
			<p>We can then use this type in the annotation of the <strong class="source-inline">filter_list</strong> function. <strong class="source-inline">mypy</strong> will then ensure that the condition function passed in the argument conforms to this signature. For example, we could write a simple function to check the parity of an integer, as shown in the <span class="No-Break">next sample:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_07.py</p>&#13;
			<pre class="source-code">&#13;
def is_even(i: int) -&gt; bool:        return i % 2 == 0&#13;
filter_list([1, 2, 3, 4, 5], is_even)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py</a></p>&#13;
			<p>It’s worth noting, however, that there is<a id="_idIndexMarker199"/> no syntax to indicate optional or <a id="_idIndexMarker200"/>keyword arguments. In this case, you can write <strong class="source-inline">Callable[..., bool]</strong>, the ellipsis (<strong class="source-inline">...)</strong> here meaning <em class="italic">any number </em><span class="No-Break"><em class="italic">of arguments</em></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-45"><a id="_idTextAnchor055"/>Any and cast</h2>&#13;
			<p>In some situations, the code is so dynamic or complicated that it won’t be possible to annotate it correctly or the type checker may not correctly infer the type. For this, we can use <strong class="source-inline">Any</strong> and <strong class="source-inline">cast</strong>. They are available in the <strong class="source-inline">typing</strong> module, which was introduced by Python to help with more specific use cases and constructs regarding <span class="No-Break">type hints.</span></p>&#13;
			<p><strong class="source-inline">Any</strong> is a type <a id="_idIndexMarker201"/>annotation telling the type checker the variable or argument can be anything. In this case, any type of value will be valid for the <span class="No-Break">type checker:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_08.py</p>&#13;
			<pre class="source-code">&#13;
from typing import Anydef f(x: Any) -&gt; Any:&#13;
        return x&#13;
f("a")&#13;
f(10)&#13;
f([1, 2, 3])</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_08.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_08.py</a></p>&#13;
			<p>The second one, <strong class="source-inline">cast</strong>, is a function <a id="_idIndexMarker202"/>that lets you override the type inferred by the type checker. It’ll force the type checker to consider the type <span class="No-Break">you specify:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_type_hints_09.py</p>&#13;
			<pre class="source-code">&#13;
from typing import Any, castdef f(x: Any) -&gt; Any:&#13;
        return x&#13;
a = f("a")    # inferred type is "Any"&#13;
a = cast(str, f("a"))    # forced type to be "str"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_09.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_09.py</a></p>&#13;
			<p>Be careful though: the <strong class="source-inline">cast</strong> function is <a id="_idIndexMarker203"/>only meaningful for type checkers. As for every other type of annotation, the interpreter completely ignores it and <em class="italic">doesn’t</em> perform a <span class="No-Break">real cast.</span></p>&#13;
			<p>While convenient, try to refrain from using those utilities too often. If everything is <strong class="source-inline">Any</strong> or cast to a different type, you completely miss the benefits of static <span class="No-Break">type checking.</span></p>&#13;
			<p>As we have seen, type hinting and type checking are really helpful in reducing errors while developing and maintaining high-quality code. But that’s not all. Actually, Python allows you to retrieve type annotations at runtime and perform some logic based on them. This enables you to do clever things<a id="_idIndexMarker204"/> such as <strong class="bold">dependency injection</strong>: just by type hinting an argument in a function, a library can automatically interpret it and inject the corresponding value at runtime. This concept is at the heart <span class="No-Break">of FastAPI.</span></p>&#13;
			<p>Another key approach in FastAPI is <strong class="bold">asynchronous I/O</strong>. This will be the last subject we’ll cover in <span class="No-Break">this chapter.</span></p>&#13;
			<h1 id="_idParaDest-46"><a id="_idTextAnchor056"/>Working with asynchronous I/O</h1>&#13;
			<p>If you have already worked <a id="_idIndexMarker205"/>with JavaScript and Node.js, you have probably come across the concepts of <em class="italic">promises</em> and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords, which are characteristic of the asynchronous I/O paradigm. Basically, this is a way to make I/O operations non-blocking and allow the program to perform other tasks while the read or write operation is ongoing. The main motivation behind this is that I/O operations are <em class="italic">slow</em>: reading from disk, network requests are <em class="italic">million</em> times slower than reading from RAM or processing instructions. In the following example, we have a simple script that reads a file <span class="No-Break">on disk:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_asyncio_01.py</p>&#13;
			<pre class="source-code">&#13;
with open(__file__) as f:        data = f.read()&#13;
# The program will block here until the data has been read&#13;
print(data)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_01.py</a></p>&#13;
			<p>We see that the script will block until we have retrieved the data from the disk and, as we said, this can be a long time. 99% percent of the execution time of the program is spent on waiting for the disk. Usually, it’s not an issue for simple scripts like this because you probably won’t have to perform other operations in <span class="No-Break">the meantime.</span></p>&#13;
			<p>However, in other situations, it could be an opportunity to perform other tasks. The typical case that is of great interest in this book is web servers. Imagine we have a first user making a request that <a id="_idIndexMarker206"/>performs a 10-second-long database query before sending the response. If a second user makes another request in the meantime, they’ll have to wait for the first response to finish before getting <span class="No-Break">their answer.</span></p>&#13;
			<p>To solve this, traditional Python web servers based on the <strong class="bold">Web Server Gateway Interface</strong> (<strong class="bold">WSGI</strong>), such as<a id="_idIndexMarker207"/> Flask or Django, spawn several <strong class="bold">workers</strong>. Those are sub-processes of the web server that are all able to answer requests. If one is busy processing a long request, others can answer <span class="No-Break">new requests.</span></p>&#13;
			<p>With asynchronous I/O, a single process won’t block when processing a request with a long I/O operation. While it waits for this operation to finish, it can answer other requests. When the I/O operation is done, it resumes the request logic and can finally answer <span class="No-Break">the request.</span></p>&#13;
			<p>Technically, this is achieved through<a id="_idIndexMarker208"/> the concept of an <strong class="bold">event loop</strong>. Think of it as a conductor that will manage all the asynchronous tasks you send to it. When data is available or when the write operation is done for one of those tasks, it’ll ping the main program so that it can perform the next operations. Underneath, it relies upon the operating system <strong class="source-inline">select</strong> and <strong class="source-inline">poll</strong> calls, which are precisely there to ask for events about I/O operations at the operating system level. You can read very interesting details about this in the article <em class="italic">Async IO on Linux: select, poll, and epoll</em> by Julia <span class="No-Break">Evans: </span><a href="https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll"><span class="No-Break">https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll</span></a><span class="No-Break">.</span></p>&#13;
			<p>Python first implemented asynchronous I/O in version 3.4 and it has since greatly evolved, notably with the introduction of the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords in version 3.6. All the utilities to manage this paradigm are available through the standard <strong class="source-inline">asyncio</strong> module. Not long after, the<a id="_idIndexMarker209"/> spiritual successor of WSGI for asynchronous-enabled web servers, <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>), was introduced. FastAPI relies on this, and this is one of the reasons why it shows such <span class="No-Break"><em class="italic">great performance</em></span><span class="No-Break">.</span></p>&#13;
			<p>We’ll now review the basics of asynchronous programming in Python. The following example is a simple <em class="italic">Hello world</em> script <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">asyncio</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_asyncio_02.py</p>&#13;
			<pre class="source-code">&#13;
import asyncioasync def main():&#13;
        print("Hello ...")&#13;
        await asyncio.sleep(1)&#13;
        print("... World!")&#13;
asyncio.run(main())</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_02.py</a></p>&#13;
			<p>When you wish to define an asynchronous function, you just have to add the <strong class="source-inline">async</strong> keyword before <strong class="source-inline">def</strong>. This allows you<a id="_idIndexMarker210"/> to use the <strong class="source-inline">await</strong> keyword inside it. Such async functions are <span class="No-Break">called </span><span class="No-Break"><strong class="bold">coroutines</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Inside it, we first call the <strong class="source-inline">print</strong> function and then call the <strong class="source-inline">asyncio.sleep</strong> coroutine. This is the <strong class="source-inline">async</strong> equivalent of <strong class="source-inline">time.sleep</strong>, which blocks the program for a given number of seconds. Notice that we prefixed the call with the <strong class="source-inline">await</strong> keyword. This means that we want to wait for <a id="_idIndexMarker211"/>this coroutine to finish before proceeding. This is the main benefit of <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords: writing code that <em class="italic">looks like</em> synchronous code. If we omitted <strong class="source-inline">await</strong>, the coroutine object would have been created but <span class="No-Break">never executed.</span></p>&#13;
			<p>Finally, notice that we use the <strong class="source-inline">asyncio.run</strong> function. This is the machinery that will create a new event loop, execute your coroutine, and return its result. It should be the main entry point of your <span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break"> program.</span></p>&#13;
			<p>This example is nice but <a id="_idIndexMarker212"/>not very interesting from an asynchronous point of view: since we are waiting for only one operation, this is not very impressive. Let’s see an example where we execute two <span class="No-Break">coroutines concurrently:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter02_asyncio_03.py</p>&#13;
			<pre class="source-code">&#13;
import asyncioasync def printer(name: str, times: int) -&gt; None:&#13;
        for i in range(times):&#13;
                print(name)&#13;
                await asyncio.sleep(1)&#13;
async def main():&#13;
        await asyncio.gather(&#13;
                printer("A", 3),&#13;
                printer("B", 3),&#13;
        )&#13;
asyncio.run(main())</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_03.py</a></p>&#13;
			<p>Here, we have a <strong class="source-inline">printer</strong> coroutine that prints its name a given number of times. Between each print, it sleeps for <span class="No-Break">1 second.</span></p>&#13;
			<p>Then, our main coroutine<a id="_idIndexMarker213"/> uses the <strong class="source-inline">asyncio.gather</strong> utility, which schedules several coroutines for concurrent execution. If you run this script, you’ll get the <span class="No-Break">following result:</span></p>&#13;
			<pre class="source-code">&#13;
$ python chapter02_asyncio_03.pyA&#13;
B&#13;
A&#13;
B&#13;
A&#13;
B</pre>&#13;
			<p>We get a succession of <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>. It means our coroutines were executed concurrently and that we didn’t wait for the first one to finish before starting the <span class="No-Break">second one.</span></p>&#13;
			<p>You might wonder why we added the <strong class="source-inline">asyncio.sleep</strong> call in this example. Actually, if we removed it, we would have obtained <span class="No-Break">this result:</span></p>&#13;
			<pre class="source-code">&#13;
AA&#13;
A&#13;
B&#13;
B&#13;
B</pre>&#13;
			<p>That doesn’t look very concurrent, and indeed, it’s not. This is one of the main pitfalls of <strong class="source-inline">asyncio</strong>: writing code in a coroutine <em class="italic">doesn’t necessarily mean</em> that it won’t block. Regular operations such as <a id="_idIndexMarker214"/>computations <em class="italic">are</em> blocking and <em class="italic">will</em> block the event loop. Usually, this is not a problem since those operations are fast. The only operations that won’t block are proper I/O operations that are <em class="italic">designed</em> to work asynchronously. This is different from <strong class="bold">multiprocessing</strong> where operations are executed on child processes, which, by nature, doesn’t block the <span class="No-Break">main one.</span></p>&#13;
			<p>Because of this, you’ll have to be careful when choosing a third-party library for interacting with databases, APIs, and so on. Some have been adapted to work asynchronously and some alternatives have been developed in parallel with the standard ones. We’ll see some of them in the<a id="_idIndexMarker215"/> following chapters, especially when working <span class="No-Break">with databases.</span></p>&#13;
			<p>We’ll end this quick introduction to asynchronous I/O here. There are some other subtleties underneath but, generally, the basics we’ve seen here will allow you to leverage the power of <strong class="source-inline">asyncio</strong> <span class="No-Break">with FastAPI.</span></p>&#13;
			<h1 id="_idParaDest-47"><a id="_idTextAnchor057"/>Summary</h1>&#13;
			<p>Congratulations! In this chapter, you discovered the basics of the Python language, a very clean and efficient language to work with. You were introduced to the more advanced concepts of list comprehensions and generators, which are idiomatic ways of handling sequences of data. Python is also a multi-paradigm language and you saw how to leverage the <span class="No-Break">object-oriented syntax.</span></p>&#13;
			<p>Finally, you discovered some of the most recent features of the language: type hinting, which allows static type checking to reduce errors and speed up development, and asynchronous I/O, a set of new tools and syntax to maximize performance and allow concurrency while doing <span class="No-Break">I/O-bound operations.</span></p>&#13;
			<p>You’re now ready to begin your journey with FastAPI! You’ll see that the framework takes advantage of all those Python features to propose a fast and enjoyable development experience. In the next chapter, you’ll learn how to write your very first REST API <span class="No-Break">with FastAPI.</span></p>&#13;
		</div>&#13;
	</div></body></html>