<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer016">&#13;
			<h1 id="_idParaDest-48" class="chapter-number"><a id="_idTextAnchor058"/>3</h1>&#13;
			<h1 id="_idParaDest-49"><a id="_idTextAnchor059"/>Developing a RESTful API with FastAPI</h1>&#13;
			<p>Now it’s time to begin <a id="_idIndexMarker216"/>learning about <strong class="bold">FastAPI</strong>! In this chapter, we’ll cover the basics of FastAPI. We’ll go through very simple and focused examples that will demonstrate the different features of FastAPI. Each example will lead to a working API endpoint that you’ll be able to test yourself using HTTPie. In the final section of this chapter, we’ll show you a more complex FastAPI project, with routes split across several files. It will give you an overview of how you can structure your <span class="No-Break">own application.</span></p>&#13;
			<p>By the end of this chapter, you’ll know how to start a FastAPI application and how to write an API endpoint. You’ll also be able to handle request data and build a response according to your own logic. Finally, you’ll learn a way to structure a FastAPI project into several modules that will be easier to maintain and work with in the <span class="No-Break">long term.</span></p>&#13;
			<p>In this chapter, we’ll cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Creating the first endpoint and running <span class="No-Break">it locally</span></li>&#13;
				<li>Handling <span class="No-Break">request parameters</span></li>&#13;
				<li>Customizing <span class="No-Break">the response</span></li>&#13;
				<li>Structuring a bigger project with <span class="No-Break">multiple routers</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-50"><a id="_idTextAnchor060"/>Technical requirements</h1>&#13;
			<p>You’ll need a Python virtual environment, as we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>You’ll find all the code examples of this chapter in the dedicated GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03</span></a><span class="No-Break">.</span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-51"><a id="_idTextAnchor061"/>Creating a first endpoint and running it locally</h1>&#13;
			<p>FastAPI<a id="_idIndexMarker217"/> is a framework that is easy to use and quick to write. In the following example, you’ll realize that this is not just a promise. In fact, creating an API endpoint involves just a<a id="_idIndexMarker218"/> <span class="No-Break">few lines:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_first_endpoint_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIapp = FastAPI()&#13;
@app.get("/")&#13;
async def hello_world():&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_first_endpoint_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_first_endpoint_01.py</a></p>&#13;
			<p>In this example, we define a <strong class="source-inline">GET</strong> endpoint at the root path, which always returns the <strong class="source-inline">{"hello": "world"}</strong> JSON response. To do this, we first instantiate a FastAPI object, <strong class="source-inline">app</strong>. It will be the main application object that will wire all the <span class="No-Break">API routes.</span></p>&#13;
			<p>Then, we simply define a coroutine that contains <a id="_idIndexMarker219"/>our route logic, the <strong class="bold">path operation function</strong>. Its return value is automatically handled by FastAPI to produce a proper HTTP response with a <span class="No-Break">JSON payload.</span></p>&#13;
			<p>Here, the most important part of this code is probably the line starting with <strong class="source-inline">@</strong>, which can be found above the coroutine <a id="_idIndexMarker220"/>definition, the <strong class="bold">decorator</strong>. In Python, a decorator is a syntactic sugar that allows you to wrap a function or class with common logic without compromising readability. It’s roughly equivalent <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">app.get("/")(hello_world)</strong></span><span class="No-Break">.</span></p>&#13;
			<p>FastAPI exposes <em class="italic">one decorator per HTTP method</em> to add new routes to the application. The one shown here adds a <strong class="source-inline">GET</strong> endpoint with <a id="_idIndexMarker221"/>the <strong class="bold">path</strong> as the <span class="No-Break">first argument.</span></p>&#13;
			<p>Now, let’s run this API. Copy the <a id="_idIndexMarker222"/>example to the root of your project and run the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
$ uvicorn chapter03_first_endpoint_01:appINFO:     Started server process [21654]&#13;
INFO:     Waiting for application startup.&#13;
INFO:     Application startup complete.&#13;
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)</pre>&#13;
			<p>As we mentioned in <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specificities</em>, in the <em class="italic">Asynchronous I/O</em> section, FastAPI exposes an <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>)-compatible application. To run it, we require a web server compatible with this <a id="_idIndexMarker223"/>protocol. Uvicorn<a id="_idIndexMarker224"/> is a good option to use. It gives a command to quickly start a web server. In the first argument, it expects the <em class="italic">dotted namespace</em> of the Python module, which contains your app instance, followed by a colon, <strong class="source-inline">:</strong>, and, finally, the variable name of your ASGI app instance (in our example, this is <strong class="source-inline">app</strong>). Afterward, it takes care of instantiating the application and exposing it on your <span class="No-Break">local machine.</span></p>&#13;
			<p>Let’s try our endpoint with HTTPie. Open another terminal and run the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
$ http http://localhost:8000HTTP/1.1 200 OK&#13;
content-length: 17&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 07:52:36 GMT&#13;
server: uvicorn&#13;
{&#13;
    "hello": "world"&#13;
}</pre>&#13;
			<p>It works! As you can see, we did get a JSON response with the payload we wanted, using just a few lines of Python and <span class="No-Break">a command!</span></p>&#13;
			<p>One of the most<a id="_idIndexMarker225"/> beloved features of FastAPI is the <em class="italic">automatic interactive documentation</em>. If you open the <strong class="source-inline">http://localhost:8000/docs</strong> URL in your browser, you should get a web interface that looks similar to the <span class="No-Break">following screenshot:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer013" class="IMG---Figure">&#13;
					<img src="Images/Figure_3.1_B19528.jpg" alt="Figure 3.1 – The FastAPI automatic interactive documentation" width="1369" height="1595"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The FastAPI automatic interactive documentation</p>&#13;
			<p>FastAPI will automatically list all your defined endpoints and provide documentation about the expected inputs and outputs. You can even try each endpoint directly in this web interface. Under the hood, it relies on the OpenAPI specification and the associated tools from Swagger. You can read more<a id="_idIndexMarker226"/> about this on its official website <span class="No-Break">at </span><a href="https://swagger.io/"><span class="No-Break">https://swagger.io/</span></a><span class="No-Break">.</span></p>&#13;
			<p>That’s it! You’ve created your very first API with FastAPI. Of course, this is just a very simple example, but next, you’ll learn how to handle input data and start making <span class="No-Break">meaningful things!</span></p>&#13;
			<p class="callout-heading">On the shoulder of giants</p>&#13;
			<p class="callout">It’s worth noting that FastAPI is built upon two main Python<a id="_idIndexMarker227"/> libraries: Starlette, a low-level ASGI web framework (<a href="https://www.starlette.io/">https://www.starlette.io/</a>), and Pydantic, a data validation<a id="_idIndexMarker228"/> library based on type <span class="No-Break">hints (</span><a href="https://pydantic-docs.helpmanual.io/"><span class="No-Break">https://pydantic-docs.helpmanual.io/</span></a><span class="No-Break">).</span></p>&#13;
			<h1 id="_idParaDest-52"><a id="_idTextAnchor062"/>Handling request parameters</h1>&#13;
			<p>The main goal of a <strong class="bold">representational state transfer</strong> (<strong class="bold">REST</strong>) API<a id="_idIndexMarker229"/> is to provide a structured way to interact with data. As such, it’s crucial for the end user to send some information to tailor the response they need, such as path <a id="_idIndexMarker230"/>parameters, query parameters, body payloads, headers, and <span class="No-Break">so on.</span></p>&#13;
			<p>Web frameworks usually ask you to manipulate a request object to retrieve the parts you are interested in and manually apply validation to handle them. However, that’s not necessary with FastAPI! Indeed, it allows you to define all of your parameters declaratively. Then, it’ll automatically retrieve them in the request and apply validation based on the type hints. This is why we introduced type hinting in <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specificities</em>: it’s used by FastAPI to perform <span class="No-Break">data validation!</span></p>&#13;
			<p>Next, we’ll explore how you can use this feature to retrieve and validate this input data from different parts of <span class="No-Break">the request.</span></p>&#13;
			<h2 id="_idParaDest-53"><a id="_idTextAnchor063"/>Path parameters</h2>&#13;
			<p>The <a id="_idIndexMarker231"/>API path is the main thing<a id="_idIndexMarker232"/> that the end user will interact with. Therefore, it’s a good spot for dynamic parameters. A typical example is to put the unique identifier of an object we want to retrieve, such as <strong class="source-inline">/users/123</strong>. Let’s examine how to define this <span class="No-Break">with FastAPI:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIapp = FastAPI()&#13;
@app.get("/users/{id}")&#13;
async def get_user(id: int):&#13;
    return {"id": id}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_01.py</a></p>&#13;
			<p>In this <a id="_idIndexMarker233"/>example, we defined an API that expects an integer in<a id="_idIndexMarker234"/> the last part of its path. We did this by putting the parameter name in the path around curly braces. Then, we defined this same parameter as an argument for our path operation function. Notice that we add a type hint to specify that the parameter is <span class="No-Break">an integer.</span></p>&#13;
			<p>Let’s run this example. You can refer to the previous <em class="italic">Creating a first endpoint and running it locally</em> section, to learn how to run a FastAPI app <span class="No-Break">with Uvicorn.</span></p>&#13;
			<p>First, we’ll try to make a request that omits our <span class="No-Break">path parameter:</span></p>&#13;
			<pre class="source-code">&#13;
$ http http://localhost:8000/usersHTTP/1.1 404 Not Found&#13;
content-length: 22&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 08:20:51 GMT&#13;
server: uvicorn&#13;
{&#13;
    "detail": "Not Found"&#13;
}</pre>&#13;
			<p>We get a response with a <strong class="source-inline">404</strong> status. That’s expected: our route awaits a parameter after <strong class="source-inline">/users</strong>, so if we omit it, it simply doesn’t match <span class="No-Break">any pattern.</span></p>&#13;
			<p>Let’s now try with a proper <span class="No-Break">integer parameter:</span></p>&#13;
			<pre class="source-code">&#13;
http http://localhost:8000/users/123HTTP/1.1 200 OK&#13;
content-length: 10&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 08:21:27 GMT&#13;
server: uvicorn&#13;
{&#13;
    "id": 123&#13;
}</pre>&#13;
			<p>It works! We get a <strong class="source-inline">200</strong> status, and the response does contain the integer we passed in the parameter. Notice that it has been properly <em class="italic">cast</em> as <span class="No-Break">an integer.</span></p>&#13;
			<p>So, what<a id="_idIndexMarker235"/> happens if we pass a value that’s not a valid integer? Let’s<a id="_idIndexMarker236"/> <span class="No-Break">find out:</span></p>&#13;
			<pre class="source-code">&#13;
$ http http://localhost:8000/users/abcHTTP/1.1 422 Unprocessable Entity&#13;
content-length: 99&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 08:22:35 GMT&#13;
server: uvicorn&#13;
{&#13;
    "detail": [&#13;
        {&#13;
            "loc": [&#13;
                "path",&#13;
                "id"&#13;
            ],&#13;
            "msg": "value is not a valid integer",&#13;
            "type": "type_error.integer"&#13;
        }&#13;
    ]&#13;
}</pre>&#13;
			<p>We get a response with a <strong class="source-inline">422</strong> status! Since <strong class="source-inline">abc</strong> is not a valid integer, the validation fails and outputs an error. Notice that we have a very detailed and structured error response telling us exactly which element caused the error and why. All we need to do to trigger this validation is to <em class="italic">type hint</em> <span class="No-Break">our parameter!</span></p>&#13;
			<p>Of course, you <a id="_idIndexMarker237"/>are not limited to just one path parameter. You can <a id="_idIndexMarker238"/>have as many as you want, with different types. In the following example, we’ve added a <strong class="source-inline">type</strong> parameter of the <span class="No-Break">string type:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_02.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIapp = FastAPI()&#13;
@app.get("/users/{type}/{id}")&#13;
async def get_user(type: str, id: int):&#13;
    return {"type": type, "id": id}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_02.py</a></p>&#13;
			<p>This <a id="_idIndexMarker239"/>works well, but the <a id="_idIndexMarker240"/>endpoint will accept any string as the <span class="No-Break"><strong class="source-inline">type</strong></span><span class="No-Break"> parameter.</span></p>&#13;
			<h3>Limiting allowed values</h3>&#13;
			<p>So, what if we <a id="_idIndexMarker241"/>just want to accept a limited set of values? Once again, we’ll lean on type hinting. Python has a very useful class for this: <strong class="source-inline">Enum</strong>. An enumeration is a way to list all the valid values for a specific kind of data. Let’s define an <strong class="source-inline">Enum</strong> class that will list the different types <span class="No-Break">of users:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_03.py</p>&#13;
			<pre class="source-code">&#13;
class UserType(str, Enum):    STANDARD = "standard"&#13;
    ADMIN = "admin"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py</a></p>&#13;
			<p>To define a string enumeration, we inherit from both the <strong class="source-inline">str</strong> type and the <strong class="source-inline">Enum</strong> class. Then, we simply list the allowed values as class properties: the property name and its actual string value. Finally, we only have to type hint the <strong class="source-inline">type</strong> argument with <span class="No-Break">this class:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_03.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/users/{type}/{id}")async def get_user(type: UserType, id: int):&#13;
    return {"type": type, "id": id}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_03.py</a></p>&#13;
			<p>If you run this example and call the endpoint with a type that is not in the enumeration, you’ll get the <span class="No-Break">following response:</span></p>&#13;
			<pre class="source-code">&#13;
$ http http://localhost:8000/users/hello/123HTTP/1.1 422 Unprocessable Entity&#13;
content-length: 184&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 08:33:36 GMT&#13;
server: uvicorn&#13;
{&#13;
    "detail": [&#13;
        {&#13;
            "ctx": {&#13;
                "enum_values": [&#13;
                    "standard",&#13;
                    "admin"&#13;
                ]&#13;
            },&#13;
            "loc": [&#13;
                "path",&#13;
                "type"&#13;
            ],&#13;
            "msg": "value is not a valid enumeration member; permitted: 'standard', 'admin'",&#13;
            "type": "type_error.enum"&#13;
        }&#13;
    ]&#13;
}</pre>&#13;
			<p>As you <a id="_idIndexMarker242"/>can see, you get a nice validation error with the allowed values for <span class="No-Break">this parameter!</span></p>&#13;
			<h3>Advanced validation</h3>&#13;
			<p>We<a id="_idIndexMarker243"/> can take one step further by defining more advanced validation rules, particularly for numbers and strings. In this case, the type of hint is no longer enough. We’ll rely on the functions provided by FastAPI, allowing us to set some options on each of our parameters. For path parameters, the function is named <strong class="source-inline">Path</strong>. In the following example, we’ll only allow an <strong class="source-inline">id</strong> argument that is greater than or equal <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_04.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, Pathapp = FastAPI()&#13;
@app.get("/users/{id}")&#13;
async def get_user(id: int = Path(..., ge=1)):&#13;
    return {"id": id}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_04.py</a></p>&#13;
			<p>There are several things to pay attention to here: the result of <strong class="source-inline">Path</strong> is used as a <em class="italic">default value</em> for the <strong class="source-inline">id</strong> argument in the path <span class="No-Break">operation function.</span></p>&#13;
			<p>Additionally, you <a id="_idIndexMarker244"/>can see that we use the <strong class="bold">ellipsis</strong> syntax<a id="_idIndexMarker245"/> as the first parameter of <strong class="source-inline">Path</strong>. Indeed, it expects the default value for the parameter as the first argument. In this scenario, we don’t want a default value: the parameter is required. Therefore, ellipses are here to tell FastAPI that we don’t want a <span class="No-Break">default value.</span></p>&#13;
			<p class="callout-heading">Ellipsis doesn’t always mean this in Python</p>&#13;
			<p class="callout">Using the ellipsis symbol to specify that a parameter is required, as we show here, is specific to FastAPI: it’s the choice of FastAPI creators to use it like this. In other Python programs, this symbol could be used for <span class="No-Break">another means.</span></p>&#13;
			<p>Then, we can add the keyword arguments we are interested in. In our example, we use <strong class="source-inline">ge</strong>, greater than or equal to, and its associated value. Here is the list of available keywords to <span class="No-Break">validate numbers:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">gt</strong>: <span class="No-Break">Greater than</span></li>&#13;
				<li><strong class="source-inline">ge</strong>: Greater than or <span class="No-Break">equal to</span></li>&#13;
				<li><strong class="source-inline">lt</strong>: <span class="No-Break">Less than</span></li>&#13;
				<li><strong class="source-inline">le</strong>: Less than or <span class="No-Break">equal to</span></li>&#13;
			</ul>&#13;
			<p>There are also validation<a id="_idIndexMarker246"/> options for string values, which are based on <em class="italic">length</em> and <em class="italic">regular expression</em>. In the following example, we want to define a path parameter that accepts license plates in the form of AB-123-CD (French license plates). A first approach would be to force the string to be a length of <strong class="source-inline">9</strong> (that is, two letters, a dash, three digits, a dash, and <span class="No-Break">two letters):</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_05.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/license-plates/{license}")async def get_license_plate(license: str = Path(..., min_length=9, max_length=9)):&#13;
    return {"license": license}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_05.py</a></p>&#13;
			<p>Now we just have to define the <strong class="source-inline">min_length</strong> and <strong class="source-inline">max_length</strong> keyword arguments, just as we did for the number of validations. Of course, a better solution for this use case is to use a regular expression to validate the license <span class="No-Break">plate number:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_path_parameters_06.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/license-plates/{license}")async def get_license_plate(license: str = Path(..., regex=r"^\w{2}-\d{3}-\w{2}$")):&#13;
    return {"license": license}</pre>&#13;
			<p><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_06.py"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_path_parameters_06.py</span></a></p>&#13;
			<p>Thanks to this regular expression, we only accept strings that exactly match the license plate format. Notice that the regular expression is prefixed with <strong class="source-inline">r</strong>. Just like <strong class="source-inline">f-strings</strong>, this is a Python syntax that is used to indicate that t<a id="_idTextAnchor064"/>he following string should be considered a<a id="_idIndexMarker247"/> <span class="No-Break">regular expression.</span></p>&#13;
			<p class="callout-heading">Parameter metadata</p>&#13;
			<p class="callout">Data validation is not the only option accepted by the parameter function. You can also set options that will add information about the parameter in the automatic documentation, such as <strong class="source-inline">title</strong>, <strong class="source-inline">description</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">deprecated</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Now you should be able to define path parameters and apply some validation to them. Other useful parameters to put inside the URL are <strong class="bold">query parame<a id="_idTextAnchor065"/>ters</strong>. We’ll discuss <span class="No-Break">the<a id="_idTextAnchor066"/>m next.</span></p>&#13;
			<h2 id="_idParaDest-54">Que<a id="_idTextAnchor067"/>ry parameters</h2>&#13;
			<p>Query parameters are a <a id="_idIndexMarker248"/>common way to add some dynamic parameters to a URL. You<a id="_idIndexMarker249"/> can find them at the end of the URL in the following form: <strong class="source-inline">?param1=foo&amp;param2=bar</strong>. In a REST API, they are commonly used on read endpoints to apply pagination, a filter, a sorting order, or <span class="No-Break">selecting fields.</span></p>&#13;
			<p>You’ll discover that they are quite straightforward to define with FastAPI. In fact, they use the exact same syntax as <span class="No-Break">path parameters:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_query_parameters_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/users")async def get_user(page: int = 1, size: int = 10):&#13;
    return {"page": page, "size": size}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_01.py</a></p>&#13;
			<p>You <a id="_idIndexMarker250"/>simply have to declare them as arguments of your path operation <a id="_idIndexMarker251"/>function. If they don’t appear in the path pattern, as they do for path parameter<a id="_idTextAnchor068"/>s, F<a id="_idTextAnchor069"/>astAPI automatically considers them to be query parameters. Let’s <span class="No-Break">try it:</span></p>&#13;
			<pre class="source-code">&#13;
$ http "http://localhost:8000/users?page=5&amp;size=50"HTTP/1.1 200 OK&#13;
content-length: 20&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 09:35:05 GMT&#13;
server: uvicorn&#13;
{&#13;
    "page": 5,&#13;
    "size": 50&#13;
}</pre>&#13;
			<p>Here, you can see that we have defined a default value for those arguments, which means they are <em class="italic">optional</em> when calling the API. Of course, if you wish to define a <em class="italic">required</em> query<a id="_idIndexMarker252"/> parameter, simply <a id="_idIndexMarker253"/>leave out the <span class="No-Break">default value:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_query_parameters_02.py</p>&#13;
			<pre class="source-code">&#13;
from enum import Enumfrom fastapi import FastAPI&#13;
class UsersFormat(str, Enum):&#13;
    SHORT = "short"&#13;
    FULL = "full"&#13;
app = FastAPI()&#13;
@app.get("/users")&#13;
async def get_user(format: UsersFormat):&#13;
    return {"format": format}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter0<span id="_idTextAnchor070"/>3_query_parameters_02.py</a></p>&#13;
			<p>Now, if you <a id="_idIndexMarker254"/>omit t<a id="_idTextAnchor071"/>he <strong class="source-inline">format</strong> parameter in the URL, you’ll get a 422 error <a id="_idIndexMarker255"/>response. Additionally, notice that, in this example, we defined a <strong class="source-inline">UsersFormat</strong> enumeration to limit the number of allowed values for this parameter; this is exactly what we did in the previous section for <span class="No-Break">path parameters.</span></p>&#13;
			<p>We also have access to more advanced validations through the <strong class="source-inline">Query</strong> function. It works in the same way that we demonstrated in the <em class="italic">Path </em><span class="No-Break"><em class="italic">parameters</em></span><span class="No-Break"> section:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_query_parameters_03.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, Queryapp = FastAPI()&#13;
@app.get("/users")&#13;
async def get_user(page: int = Query(1, gt=0), size: int = Query(10, &#13;
le=100)):&#13;
    return {"page": page, "size": size}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_query_parameters_03.py</a></p>&#13;
			<p>Here, we force the <a id="_idIndexMarker256"/>page to be <em class="italic">greater than 0</em> and the size to be <em class="italic">less than or equal to 100</em>. Notice <a id="_idIndexMarker257"/>how the default parameter value is the first argument of the <span class="No-Break"><strong class="source-inline">Query</strong></span><span class="No-Break"> function.</span></p>&#13;
			<p>Naturally, when it comes to sending request data, t<a id="_idTextAnchor072"/>he most obvious way is to use the request body. Let’s examin<a id="_idTextAnchor073"/>e how <span class="No-Break">i<a id="_idTextAnchor074"/>t works.</span></p>&#13;
			<h2 id="_idParaDest-55"><a id="_idTextAnchor075"/>The request body</h2>&#13;
			<p>The body is the part of the <a id="_idIndexMarker258"/>HTTP request that contains raw data representing documents, files, or form submissions. In a REST API, it’s usually encoded in JSON and used to create structured objects in <span class="No-Break">a database.</span></p>&#13;
			<p>For the simplest cases, retrieving data from the body works exactly like query parameters. The only difference is that you always have to use the <strong class="source-inline">Body</strong> function; otherwise, FastAPI will look for it inside the query parameters by default. Let’s explore a simple example where we want to post some <span class="No-Break">user data:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_request_body_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/users")async def create_user(name: str = Body(...), age: int = Body(...)):&#13;
    return {"name": name, "age": age}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_01.py</a></p>&#13;
			<p>In the same way as query parameters, we define each argument with a type hint along with the <strong class="source-inline">Body</strong> function with no default value to make them required. Let’s try the <span class="No-Break">following endpoint:</span></p>&#13;
			<pre class="source-code">&#13;
$ http -v POST http://localhost:8000/users name="John" age=30POST /users HTTP/1.1&#13;
Accept: application/json, */*;q=0.5&#13;
Accept-Encoding: gzip, deflate&#13;
Connection: keep-alive&#13;
Content-Length: 29&#13;
Content-Type: application/json&#13;
Host: localhost:8000&#13;
User-Agent: HTTPie/3.2.1&#13;
{&#13;
    "age": "30",&#13;
    "name": "John"&#13;
}&#13;
HTTP/1.1 200 OK&#13;
content-length: 24&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 09:42:24 GMT&#13;
server: uvicorn&#13;
{&#13;
  <a id="_idTextAnchor076"/>  "age": 30,&#13;
    "name": "John"&#13;
}</pre>&#13;
			<p>Here, we used the <strong class="source-inline">-v</strong> option of HTTPie so that you can clearly see the JSON payload we sent. FastAPI successfully retrieves the data for each field from the payload. If you send a request with a missing or invalid<a id="_idIndexMarker259"/> field, you’ll get a <strong class="source-inline">422</strong> status <span class="No-Break">error response.</span></p>&#13;
			<p>You also have access to more advanced validation through the <strong class="source-inline">Body</strong> function. It works in the same way as we demonstrated in the <em class="italic">Path </em><span class="No-Break"><em class="italic">parameters</em></span><span class="No-Break"> section.</span></p>&#13;
			<p>However, defining payload validations such as this has some major drawbacks. First, it’s quite verbose and makes the path operation function prototype huge, especially for bigger models. Second, usually, you’ll need to reuse the data structure on other endpoints or in other parts of <span class="No-Break">your application.</span></p>&#13;
			<p>This is why FastAPI uses <strong class="bold">Pydantic models</strong> for <a id="_idIndexMarker260"/>data validation. Pydantic is a Python library for <em class="italic">data validation</em> and is based on classes and type hints. In fact, the <strong class="source-inline">Path</strong>, <strong class="source-inline">Query</strong>, and <strong class="source-inline">Body</strong> functions that we’ve learned about so far u<a id="_idTextAnchor077"/>se Pydantic under <span class="No-Break">the hood!</span></p>&#13;
			<p>By definin<a id="_idTextAnchor078"/>g your<a id="_idIndexMarker261"/> own Pydantic models and using them as type hints in your path arguments, FastAPI will automatically instantiate a model instance and validate the data. Let’s rewrite our previous example using <span class="No-Break">this method:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_request_body_02.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIfrom pydantic import BaseModel&#13;
class User(BaseModel):&#13;
    name: str&#13;
    age: int&#13;
app = FastAPI()&#13;
@app.post("/users")&#13;
async def create_user(user: User):&#13;
    return user</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_02.py</a></p>&#13;
			<p>First, we import <strong class="source-inline">BaseModel</strong> from <strong class="source-inline">pydantic</strong>. This is the base class that <em class="italic">every</em> model should inherit from. Then, we define our <strong class="source-inline">User</strong> class and list all of the properties as <em class="italic">class properties</em>. Each one of them should have a proper type hint: this is how Pydantic will be able to validate the type of <span class="No-Break">the field.</span></p>&#13;
			<p>Finally, we just declare <strong class="source-inline">user</strong> as an argument for our path operation function with the <strong class="source-inline">User</strong> class as a type hint. FastAPI automatically understands that the user data can be found in the request payload. Inside the function, you have access to a proper <strong class="source-inline">user</strong> object instance, where you can access individual properties by simply using the dot<a id="_idTextAnchor079"/> notation, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">user.name</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Notice that if <a id="_idTextAnchor080"/>you just <a id="_idIndexMarker262"/>return the object, FastAPI is smart enough to convert it automatically into JSON to produce the <span class="No-Break">HTTP response.</span></p>&#13;
			<p>In the following chapter, <a href="B19528_04.xhtml#_idTextAnchor176"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Managing Pydantic Data Models in FastAPI</em>, we’ll explore, in more detail, the possibilities of Pydantic, particularly in terms <span class="No-Break">o<a id="_idTextAnchor081"/>f validation.</span></p>&#13;
			<h3>Multiple objects</h3>&#13;
			<p>Sometimes, you<a id="_idIndexMarker263"/> might have several objects that you wish to send in the same payload all at once. For example, both <strong class="source-inline">user</strong> and <strong class="source-inline">company</strong>. In this scenario, you can simply add several arguments that have been type hinted by a Pydantic model, and FastAPI will automatically understand that there are several objects. In this configuration, it will expect a body containing each object <em class="italic">indexed by its </em><span class="No-Break"><em class="italic">argument name</em></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_request_body_03.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/users")async def create_user(user: User, company: Company):&#13;
    return {"user": user, "company": company}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_03.py</a></p>&#13;
			<p>Here, <strong class="source-inline">Company</strong> is a simple Pydantic model with a single string <strong class="source-inline">name</strong> property. In this configuration, FastAPI expects a payload that looks similar to <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
{    "user": {&#13;
        "name": "John",&#13;
        "age": 30&#13;
    },&#13;
    "comp<a id="_idTextAnchor082"/>any": {&#13;
        "name": "ACME"&#13;
    }&#13;
}</pre>&#13;
			<p>For more complex <a id="_idIndexMarker264"/>JSON structures, it’s advised that you <em class="italic">pipe</em> a formatted JSON into HTTPie rather than use parameters. Let’s try this <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
$ echo '{"user": {"name": "John", "age": 30}, "company": {"name": "ACME"}}' | http POST http://localhost:8000/usersHTTP/1.1 200 OK&#13;
content-length: 59&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 09:52:12 GMT&#13;
server: uvicorn&#13;
{&#13;
    "company": {&#13;
        "name": "ACME"&#13;
    },&#13;
    "user": {&#13;
        "age": 30,&#13;
        "n<a id="_idTextAnchor083"/>ame": "John"&#13;
    }&#13;
}</pre>&#13;
			<p>And <span class="No-Break">that’s it!</span></p>&#13;
			<p>You can <a id="_idIndexMarker265"/>even add <strong class="bold">singular body values</strong> with the <strong class="source-inline">Body</strong> function, just as we saw at the beginning of this <a id="_idIndexMarker266"/>section. This is useful if you <a id="_idTextAnchor084"/>wish to have a single property that’s not part of <span class="No-Break">any model:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_request_body_04.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/users")async def create_user(user: User, priority: int = Body(..., ge=1, le=3)):&#13;
    return {"user": user, "priority": priority}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_body_04.py</a></p>&#13;
			<p>The <strong class="source-inline">priority</strong> property is an integer between 1 and 3, which is expected <em class="italic">beside</em> the <span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break"> object:</span></p>&#13;
			<pre class="source-code">&#13;
$ echo '{"user": {"name": "John", "age": 30}, "priority": 1}' | http POST http://localhost:8000/usersHTTP/1.1 200 OK&#13;
content-length: 46&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 09:53:51 GMT&#13;
server: uvicorn&#13;
{&#13;
    "priority": 1,&#13;
    "user": {&#13;
        "age": 30,&#13;
        "name": "John"&#13;
    }&#13;
}</pre>&#13;
			<p>You now have a good overview of how to han<a id="_idTextAnchor085"/>dle JSON payload data. However, sometimes, you’ll find that you need to accept more traditional-form data or even <a id="_idTextAnchor086"/>file uploads. Let’s find out how t<a id="_idTextAnchor087"/>o do <a id="_idTextAnchor088"/><span class="No-Break">this next!</span></p>&#13;
			<h2 id="_idParaDest-56"><a id="_idTextAnchor089"/>Form data and file uploads</h2>&#13;
			<p>Even if REST APIs work most of the time with JSON, sometimes, you might have to handle form-encoded data or file uploads, which have been encoded either as <strong class="source-inline">application/x-www-form-urlencoded</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">multipart/form-data</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Once again, FastAPI allows you to implement this case very easily. However, you’ll need an additional Python dependency, <strong class="source-inline">python-multipart</strong>, to handle this kind of data. As usual, you can install it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
$ pip install python-multipart</pre>			<p>Then, you can use the FastAPI features that are dedicated to form data. First, let’s take a look at how you can<a id="_idTextAnchor090"/> handle simple <span class="No-Break">form data.</span></p>&#13;
			<h3>Form data</h3>&#13;
			<p>The method to retrieve<a id="_idIndexMarker267"/> form data fields is similar to the one we discussed in the <em class="italic">The request body</em> section to retrieve singular JSON properties. The following example is roughly the same as the one you explored there. However, this example expects form-encoded data instead <span class="No-Break">of JSON:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_form_data_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/users")async def create_user(name: str = Form(...), age: int = Form(...)):&#13;
    return {"name": name, "age": age}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_form_data_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree<span id="_idTextAnchor091"/>/main/chapter03/chapter03_form_data_01.py</a></p>&#13;
			<p>The only difference here is that we use the <strong class="source-inline">Form</strong> function <a id="_idIndexMarker268"/>instead of <strong class="source-inline">Body</strong>. You can try this endpoint with HTTPie and the <strong class="source-inline">--form</strong> option to force the data to <span class="No-Break">be form-encoded:</span></p>&#13;
			<pre class="source-code">&#13;
$ http -v --form POST http://localhost:8000/users name=John age=30POST /users HTTP/1.1&#13;
Accept: */*&#13;
Accept-Encoding: gzip, deflate&#13;
Connection: keep-alive&#13;
Content-Length: 16&#13;
Content-Type: application/x-www-form-urlencoded; charset=utf-8&#13;
Host: localhost:8000&#13;
User-Agent: HTTPie/3.2.1&#13;
name=John&amp;age=30&#13;
HTTP/1.1 200 OK&#13;
content-length: 24&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 09:56:28 GMT&#13;
server: uvicorn&#13;
<a id="_idTextAnchor092"/>&#13;
{&#13;
    "age": 30,&#13;
    "name": "John"&#13;
}</pre>&#13;
			<p>Pay attention to how the <strong class="source-inline">Content-Type</strong> header and the body data representation have changed in the request. You can also see that the response is still provided in JSON. Unless specified otherwise, FastAPI will always output a JSON response by default, no matter the form of the <span class="No-Break">input data.</span></p>&#13;
			<p>Of course, the validation options we saw for <strong class="source-inline">Path</strong>, <strong class="source-inline">Query</strong>, and <strong class="source-inline">Body</strong> are still available. You can find a description for each of them in the <em class="italic">Path </em><span class="No-Break"><em class="italic">parameters</em></span><span class="No-Break"> section.</span></p>&#13;
			<p>It’s worth noting that, contrary to JSON payloads, FastAPI doesn’t <a id="_idIndexMarker269"/>allow you to define Pydantic models to validate form data. Instead, you have to manually define each field as an argument for the path <span class="No-Break">operation function.</span></p>&#13;
			<p>Now, let’s go on to discuss how<a id="_idTextAnchor093"/> to handle <span class="No-Break">file uploads.</span></p>&#13;
			<h3>File uploads</h3>&#13;
			<p>Uploading<a id="_idIndexMarker270"/> files is a common requirement for web applications, whether this is images or documents. FastAPI provides a parameter function, <strong class="source-inline">File</strong>, that <span class="No-Break">enables this.</span></p>&#13;
			<p>Let’s take a look at a simple example where you can directly retrieve a file as a <span class="No-Break"><strong class="source-inline">bytes</strong></span><span class="No-Break"> object:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_file_uploads_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, Fileapp = FastAPI()&#13;
@app.post("/files")&#13;
async def upload_file(file: bytes = File(...)):&#13;
    return {"file_size": len(file)}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_01.py</a></p>&#13;
			<p>Once again, you can see that the approach is still the same: we define an argument for the path operation function, <strong class="source-inline">file</strong>, add a type hint, <strong class="source-inline">bytes</strong>, and then we use the <strong class="source-inline">File</strong> function as a default value for this argument<a id="_idTextAnchor094"/>. By doing this, FastAPI understands that it will have to retrieve raw data in a part of the body named <strong class="source-inline">file</strong> and return it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">bytes</strong></span><span class="No-Break">.</span></p>&#13;
			<p>We simply return the size of this file by calling the <strong class="source-inline">len</strong> function on this <span class="No-Break"><strong class="source-inline">bytes</strong></span><span class="No-Break"> object.</span></p>&#13;
			<p>In the code example repository, you should be able to find a picture of a <span class="No-Break">cat: </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg</span></a><span class="No-Break">.</span></p>&#13;
			<p>Let’s upload it on our endpoint using HTTPie. To upload a file, type in the name of the file upload field (here, it is <strong class="source-inline">file</strong>), followed by <strong class="source-inline">@</strong> and the path of the file you want to upload. Don’t<a id="_idIndexMarker271"/> forget to set the <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> option:</span></p>&#13;
			<pre class="source-code">&#13;
$ http --form POST http://localhost:8000/files file@./assets/cat.jpgHTTP/1.1 200 OK&#13;
content-length: 19&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:00:38 GMT&#13;
server: uvicorn&#13;
{&#13;
    "file_size": 71457&#13;
}</pre>&#13;
			<p>It works! We have correctly got the size of the file <span class="No-Break">in bytes.</span></p>&#13;
			<p>One drawback to this approach is that the uploaded file is entirely stored <em class="italic">in memory</em>. So, while it’ll work for small files, it is likely that you’ll run into issues for larger files. Besides, manipulating a <strong class="source-inline">bytes</strong> object is not always convenient for <span class="No-Break">file handling.</span></p>&#13;
			<p>To fix this<a id="_idIndexMarker272"/> problem, FastAPI provides an <strong class="source-inline">UploadFile</strong> class. This class will store the data in memory up to a certain threshold and, after this, will automatically store it <em class="italic">on disk</em> in a temporary location. This allows you to accept much larger files without running out of memory. Furthermore, the exposed object instance exposes useful metadata, such as the<a id="_idIndexMarker273"/> content type, and a <strong class="bold">file-like</strong> interface. This means that you can manipulate it as a regular file in Python and fe<a id="_idTextAnchor095"/>ed it to any function that expects <span class="No-Break">a file.</span></p>&#13;
			<p>To use it, you simply have to specify it as a type hint instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">bytes</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_file_uploads_02.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, File, UploadFileapp = FastAPI()&#13;
@app.post("/files")&#13;
async def upload_file(file: UploadFile = File(...)):&#13;
    return {"file_name": file.filename, "content_type": file.content_type}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_02.py</a></p>&#13;
			<p>Notice that, here, we return the <strong class="source-inline">filename</strong> and <strong class="source-inline">content_type</strong> properties. The content type is especially useful for <em class="italic">checking the type</em> of the uploaded file and possibly rejecting it if it’s not one of the types <span class="No-Break">you expect.</span></p>&#13;
			<p>Here is the result <span class="No-Break">with HTTPie:</span></p>&#13;
			<pre class="source-code">&#13;
$ http --form POST http://localhost:8000/files file@./assets/cat.jpgHTTP/1.1 200 OK&#13;
content-length: 51&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:04:22 GMT&#13;
server: uvicorn&#13;
{&#13;
    "content_type":<a id="_idTextAnchor096"/> "image/jpeg",&#13;
    "file_name": "cat.jpg"&#13;
}</pre>&#13;
			<p>You can <a id="_idIndexMarker274"/>even accept multiple files by type hinting the argument as a list <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">UploadFile</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_file_uploads_03.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/files")async def upload_multiple_files(files: list[UploadFile] = File(...)):&#13;
    return [&#13;
        {"file_name": file.filename, "content_type": file.content_type}&#13;
        for file in files&#13;
    ]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_file_uploads_03.py</a></p>&#13;
			<p>To upload several files with HTTPie, simply repeat the argument. It should appear <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
$ http --form POST http://localhost:8000/files files@./assets/cat.jpg files@./assets/cat.jpgHTTP/1.1 200 OK&#13;
content-length: 105&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:06:09 GMT&#13;
server: uvicorn&#13;
[&#13;
    {&#13;
        "content_type": "image/jpeg",&#13;
        "file_name": "cat.jpg"&#13;
    },&#13;
    {&#13;
        "content_type": "im<a id="_idTextAnchor097"/>age/jpeg",&#13;
        "file_name": "cat.jpg"&#13;
    }&#13;
]</pre>&#13;
			<p>Now, you<a id="_idIndexMarker275"/> should be able to handle form data and file uploads in a FastAPI application. So far, you’ve learned how to manage user-facing data. However, there are also very interesting pieces of informatio<a id="_idTextAnchor098"/>n that are less visible: <strong class="bold">header<a id="_idTextAnchor099"/>s</strong>. W<a id="_idTextAnchor100"/>e’ll explore <span class="No-Break">them next.</span></p>&#13;
			<h2 id="_idParaDest-57"><a id="_idTextAnchor101"/>Headers and cookies</h2>&#13;
			<p>Besides the URL and the body, another major part of the HTTP request are the <a id="_idIndexMarker276"/>headers. They contain all sorts of metadata that can be useful when handling requests. A common usage is to use them for authentication, for <a id="_idIndexMarker277"/>example, via the <span class="No-Break">famous </span><span class="No-Break"><strong class="bold">cookies</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Once again, retrieving them in FastAPI only involves a type hint and a parameter function. Let’s take a look at a simple example where we want to retrieve a header <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Hello</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_headers_cookies_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/")async def get_header(hello: str = Header(...)):&#13;
    return {"hello": hello}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_01.py</a></p>&#13;
			<p>Here, you can see that we simply<a id="_idIndexMarker278"/> have to use the <strong class="source-inline">Header</strong> function as a default value for the <strong class="source-inline">hello</strong> argument. The name of the argument determines the <em class="italic">key of the header</em> that we want to retrieve. Let’s see this <span class="No-Break">in action:</span></p>&#13;
			<pre class="source-code">&#13;
$ http GET http://localhost:8000 'Hello: World'HTTP/1.1 200 OK&#13;
content-length: 17&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:10:12 GMT&#13;
server: uvicorn&#13;
{&#13;
    "hello": "World"&#13;
}</pre>&#13;
			<p>FastAPI was able to retrieve the header value. Since there was no default value specified (we put in an ellipsis), the header is required. If it’s missing, once again, you’ll get a <strong class="source-inline">422</strong> status <span class="No-Break">error response.</span></p>&#13;
			<p>Additionally, notice that FastAPI automatically converts the header name into <em class="italic">lowercase</em>. Besides that, since header names are usually separated by a hyphen, <strong class="source-inline">-</strong>, it also automatically converts it into snake c<a id="_idTextAnchor102"/>ase. Therefore, it works out of the box with any valid Py<a id="_idTextAnchor103"/>thon variable name. The following <a id="_idIndexMarker279"/>example shows this behavior by retrieving the <span class="No-Break"><strong class="source-inline">User-Agent</strong></span><span class="No-Break"> header:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_headers_cookies_02.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/")async def get_header(user_agent: str = Header(...)):&#13;
    return {"user_agent": user_agent}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_02.py</a></p>&#13;
			<p>Now, let’s make a very simple request. We’ll keep the default user agent of HTTPie to see <span class="No-Break">what happens:</span></p>&#13;
			<pre class="source-code">&#13;
$ http -v GET http://localhost:8000GET / HTTP/1.1&#13;
Accept: */*&#13;
Accept-Encoding: gzip, deflate&#13;
Connection: keep-alive&#13;
Host: localhost:8000&#13;
User-Agent: HTTPie/3.2.1&#13;
HTTP/1.1 200 OK&#13;
content-length: 29&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:12:17 GMT&#13;
server: uvicorn&#13;
{&#13;
    "user_agent": "HTTPie/3.2.1"&#13;
}</pre>&#13;
			<p class="callout-heading">What is a user agent?</p>&#13;
			<p class="callout">The user agent<a id="_idIndexMarker280"/> is an HTTP header added automatically by most HTTP clients, such as HTTPie or cURL and web browsers. It’s a way for web servers to identify which kind of application made the request. In some cases, web servers c<a id="_idTextAnchor104"/>an use this information to adapt <span class="No-Break">the response.</span></p>&#13;
			<p>One<a id="_idTextAnchor105"/> very special case of the header is cookies. You could retrieve them by parsing the <strong class="source-inline">Cookie</strong> header <a id="_idIndexMarker281"/>yourself, but that would be a bit tedious. FastAPI provides another parameter function that automatically does it <span class="No-Break">for you.</span></p>&#13;
			<p>The following example simply retrieves a cookie <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">hello</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_headers_cookies_03.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/")async def get_cookie(hello: str | None = Cookie(None)):&#13;
    return {"hello": hello}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_headers_cookies_03.py</a></p>&#13;
			<p>Notice that we type hinted the argument as <strong class="source-inline">str | None</strong>, and we set a default value of <strong class="source-inline">None</strong> to the <strong class="source-inline">Cookie</strong> function. This way, even if the cookie is not set in the request, FastAPI will proceed and not generate a <strong class="source-inline">422</strong> status <span class="No-Break">error response.</span></p>&#13;
			<p>Headers and cookies can be very useful tools for implementing authentication features. In <a href="B19528_07.xhtml#_idTextAnchor448"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Managing Authentication and Security in FastAPI</em>, you’ll learn that there are built-in security functions that can help you to implement<a id="_idTextAnchor106"/> common <span class="No-Break">authentication schemes.</span></p>&#13;
			<h2 id="_idParaDest-58"><a id="_idTextAnchor107"/>The request object</h2>&#13;
			<p>Sometimes, you might find that you<a id="_idIndexMarker282"/> need to access a raw request object with all of the data associated with it. That’s possible. Simply declare an argument on your path operation function type hinted with the <span class="No-Break"><strong class="source-inline">Request</strong></span><span class="No-Break"> class:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_request_object_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, Requestapp = FastAPI()&#13;
@app.get("/")&#13;
async def get_request_object(request: Request):&#13;
    return {"path": request.url.path}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_object_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_request_object_01.py</a></p>&#13;
			<p>Under the hood, this is the <strong class="source-inline">Request</strong> object from Starlette, which is a library that provides all the core server logic for FastAPI. You can view a complete description of the methods and properties of this object in the official<a id="_idIndexMarker283"/> documentation of <span class="No-Break">Starlette (</span><a href="https://www.starlette.io/requests/"><span class="No-Break">https://www.starlette.io/requests/</span></a><span class="No-Break">).</span></p>&#13;
			<p>Congratulations! You have now learned all of the basics regarding how to handle request data in FastAPI. As you learned, the logic is the same no matter what part of the HTTP request you want to <a id="_idIndexMarker284"/>look at. Simply name the argument you want to retrieve, add a type hint, and use a parameter function to tell FastAPI where it should look. You can even add some <span class="No-Break">validation logic!</span></p>&#13;
			<p>In the next section, we<a id="_idTextAnchor108"/>’ll explore the other side of a REST API<a id="_idTextAnchor109"/> job: returning <span class="No-Break">a response.</span></p>&#13;
			<h1 id="_idParaDest-59"><a id="_idTextAnchor110"/>Customizing the response</h1>&#13;
			<p>In the previous sections, you learned that directly <a id="_idIndexMarker285"/>returning a dictionary or a Pydantic object in your path operation function was enough for FastAPI to return a <span class="No-Break">JSON response.</span></p>&#13;
			<p>Most of the time, you’ll want to customize this response a bit further; for instance, by changing the status code, raising validation errors, and setting cookies. FastAPI offers different ways to do this, from the simplest case to the most advanced one. First, we’ll learn how to cust<a id="_idTextAnchor111"/>omize the response declarativ<a id="_idTextAnchor112"/>ely by using path <span class="No-Break">operation parameters.</span></p>&#13;
			<h2 id="_idParaDest-60">Path operation parameters<a id="_idTextAnchor113"/></h2>&#13;
			<p>In the <em class="italic">Creating a first endpoint and running it locally</em> section, you learned that in order to create a new endpoint, you had to put a decorator on top of the path<a id="_idIndexMarker286"/> operation function. This decorator accepts a lot of option<a id="_idTextAnchor114"/>s, including ones<a id="_idTextAnchor115"/> to customize <span class="No-Break">the response.</span></p>&#13;
			<h3>The status code</h3>&#13;
			<p>The most obvious thing to <a id="_idIndexMarker287"/>customize in an HTTP response is the <strong class="bold">status code</strong>. By default, FastAPI will always set a <strong class="source-inline">200</strong> status when everything goes well during<a id="_idIndexMarker288"/> your path operation <span class="No-Break">function execution.</span></p>&#13;
			<p>Sometimes, it might be useful to change this status. For example, it’s good practice in a REST API to return a <strong class="source-inline">201 Created</strong> status when the execution of the endpoint ends up in the creation of a <span class="No-Break">new object.</span></p>&#13;
			<p>To set this, simply specify the <strong class="source-inline">status_code</strong> argument on the <span class="No-Break">path decorator:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_path_parameters_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, statusfrom pydantic import BaseModel&#13;
class Post(BaseModel):&#13;
    title: str&#13;
app = FastAPI()&#13;
@app.post("/posts", status_code=status.HTTP_201_CREATED)&#13;
async def create_post(post: Post):&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tre<span id="_idTextAnchor116"/>e/main/ch<span id="_idTextAnchor117"/>apter03/chapter03_response_path_parameters_01.py</a></p>&#13;
			<p>The decorator <a id="_idIndexMarker289"/>arguments come right after the path as keyword arguments. The <strong class="source-inline">status_code</strong> option simply expects an integer representing the status code. We could have written <strong class="source-inline">status_code=201</strong>, but FastAPI provides a useful list in the <strong class="source-inline">status</strong> sub-module that improves code comprehensiveness, as you can <span class="No-Break">see here.</span></p>&#13;
			<p>We can try this endpoint to obtain the resulting <a id="_idIndexMarker290"/><span class="No-Break">status code:</span></p>&#13;
			<pre class="source-code">&#13;
$ http POST http://localhost:8000/posts title="Hello"HTTP/1.1 201 Created&#13;
content-length: 17&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:24:24 GMT&#13;
server: uvicorn&#13;
{&#13;
    "title": "Hello"&#13;
}</pre>&#13;
			<p>We got our <strong class="source-inline">201</strong> <span class="No-Break">status code.</span></p>&#13;
			<p>It’s important to understand that this option to override the status code is only useful <em class="italic">when everything goes well</em>. If your input data was invalid, you would still get a <strong class="source-inline">422</strong> status <span class="No-Break">error response.</span></p>&#13;
			<p>Another interesting <a id="_idIndexMarker291"/>scenario for this option is when you have nothing to return, such as when you delete an object. In this case, the <strong class="source-inline">204 No content</strong> status code is a good fit. In t<a id="_idTextAnchor118"/>he following exa<a id="_idTextAnchor119"/>mple, we implement a simple <strong class="source-inline">delete</strong> endpoint that sets this response <span class="No-Break">status code:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_path_parameters_02.py</p>&#13;
			<pre class="source-code">&#13;
# Dummy databaseposts = {&#13;
    1: Post(title="Hello", nb_views=100),&#13;
}&#13;
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)&#13;
async def delete_post(id: int):&#13;
    posts.pop(id, None)&#13;
    return None</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_02.py</a></p>&#13;
			<p>Notice that you can very well return <strong class="source-inline">None</strong> in your path operation function. FastAPI will take care of it and return a response with an <span class="No-Break">empty body.</span></p>&#13;
			<p>In the <em class="italic">Setting the status code dynamically</em> section, you’ll learn how to customize the status<a id="_idTextAnchor120"/> code dynamic<a id="_idTextAnchor121"/>ally inside the path <span class="No-Break">operation logic.</span></p>&#13;
			<h3>The response model</h3>&#13;
			<p>With FastAPI, the <a id="_idIndexMarker292"/>main use case is to directly return a Pydantic model that automatically gets turned into properly formatted JSON. However, quite often, you’ll find that there are some differences between the input data, the data you store in your database, and the data you want to show to the end user. For instance, perhaps some fields are private or only for internal use, or perhaps some fields are only useful during the creation process and then <span class="No-Break">discarded afterward.</span></p>&#13;
			<p>Now, let’s consider a simple example. Assume you have a database containing blog posts. Those blog posts have several properties, such as a title, content, or creation date. Additionally, you store the number of views of each one, but you don’t want the end user to <span class="No-Break">see it.</span></p>&#13;
			<p>You could take the<a id="_idIndexMarker293"/> standard approach <span class="No-Break">as follows:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_path_parameters_03.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIfrom pydantic import BaseModel&#13;
class Post(BaseModel):&#13;
    title: str&#13;
    nb_views: int&#13;
app = FastAPI()&#13;
# Dummy database&#13;
posts = {&#13;
    1: Post(title="Hello", nb_views=100),&#13;
}&#13;
@app.get("/posts/{id}")&#13;
async def get_post(id: int):&#13;
    return posts[id]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-<span id="_idTextAnchor122"/>Edition/tr<span id="_idTextAnchor123"/>ee/main/chapter03/chapter03_response_path_parameters_03.py</a></p>&#13;
			<p>And then call<a id="_idIndexMarker294"/> <span class="No-Break">this endpoint:</span></p>&#13;
			<pre class="source-code">&#13;
$ http GET http://localhost:8000/posts/1HTTP/1.1 200 OK&#13;
content-length: 32&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:29:33 GMT&#13;
server: uvicorn&#13;
{&#13;
    "nb_views": 100,&#13;
    "title": "Hello"&#13;
}</pre>&#13;
			<p>The <strong class="source-inline">nb_views</strong> property is in the output. However, we don’t want this. This is exactly what the <strong class="source-inline">response_model</strong> option is for, to specify another model that only outputs the properties we want. First, let’s define another Pydantic model with only the <span class="No-Break"><strong class="source-inline">title</strong></span><span class="No-Break"> property:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_path_parameters_04.py</p>&#13;
			<pre class="source-code">&#13;
class PublicPost(BaseModel):    title: str</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py</a></p>&#13;
			<p>Then, the only<a id="_idIndexMarker295"/> change is to add the <strong class="source-inline">response_model</strong> option as a keyword argument for the <span class="No-Break">path decorator:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_path_parameters_04.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/posts/{id}", response_model=PublicPost)async def get_post(id: int):&#13;
    return posts[id]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_path_parameters_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-<span id="_idTextAnchor124"/>Edition/tree<span id="_idTextAnchor125"/>/main/chapter03/chapter03_response_path_parameters_04.py</a></p>&#13;
			<p>Now, let’s try to call <span class="No-Break">this endpoint:</span></p>&#13;
			<pre class="source-code">&#13;
$ http GET http://localhost:8000/posts/1HTTP/1.1 200 OK&#13;
content-length: 17&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:31:43 GMT&#13;
server: uvicorn&#13;
{&#13;
    "title": "Hello"&#13;
}</pre>&#13;
			<p>The <strong class="source-inline">nb_views</strong> property is no longer there! Thanks to the <strong class="source-inline">response_model</strong> option, FastAPI automatically converted our <strong class="source-inline">Post</strong> instance into a <strong class="source-inline">PublicPost</strong> instance before serializing it. Now our private data <span class="No-Break">is safe!</span></p>&#13;
			<p>The good thing is th<a id="_idTextAnchor126"/>at this option<a id="_idIndexMarker296"/> i<a id="_idTextAnchor127"/>s also considered by the interactive documentation, which will show the correct output schema to the end user, as you can see in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer014" class="IMG---Figure">&#13;
					<img src="Images/Figure_3.2_B19528.jpg" alt="Figure 3.2 – The response model schema in the interactive documentation" width="766" height="661"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The response model schema in the interactive documentation</p>&#13;
			<p>So far, you’ve looked at options that can help you quickly customize the response generated by FastAP<a id="_idTextAnchor128"/>I. Now, we’ll introduce another appr<a id="_idTextAnchor129"/>oach that will open up <span class="No-Break">more possibilities.</span></p>&#13;
			<h2 id="_idParaDest-61"><a id="_idTextAnchor130"/>The response parameter</h2>&#13;
			<p>The body and status code are not the <a id="_idIndexMarker297"/>only interesting parts of an HTTP response. Sometimes, it might be useful to return some custom headers or set cookies. This can be done dynamically using FastAPI directly within the path operation logic<a id="_idTextAnchor131"/>. How so? By injecting the <strong class="source-inline">Response</strong> objec<a id="_idTextAnchor132"/>t as an argument of the path <span class="No-Break">operation function.</span></p>&#13;
			<h3>Setting headers</h3>&#13;
			<p>As usual, this only involves <a id="_idIndexMarker298"/>setting the proper type hinting to the argument. The following example shows you how to set a <span class="No-Break">custom header:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_parameter_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, Responseapp = FastAPI()&#13;
@app.get("/")&#13;
async def custom_header(response: Response):&#13;
    response.headers["Custom-Header"] = "Custom-Header-Value"&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_01.py</a></p>&#13;
			<p>The <strong class="source-inline">Response</strong> object gives you access to a set of properties, including <strong class="source-inline">headers</strong>. It’s a simple dictionary where the key is the name of the header, and the value is its associated value. Therefore, it’s relatively straightforward to set your own <span class="No-Break">custom header.</span></p>&#13;
			<p>Also, notice that you <em class="italic">don’t have to return</em> the <strong class="source-inline">Response</strong> object. You can still return JSON-encodable data, and FastAPI will take care of forming a proper response, including the headers you’ve set. Therefore, the <strong class="source-inline">response_model</strong> and <strong class="source-inline">status_code</strong> options we discussed in the <em class="italic">Path operation parameters</em> section are <span class="No-Break">still honored.</span></p>&#13;
			<p>Let’s view <span class="No-Break">the result:</span></p>&#13;
			<pre class="source-code">&#13;
$ http GET http://localhost:8000HTTP/1.1 200 OK&#13;
content-length: 17&#13;
content-type: application/json&#13;
custom-header: Custom-Header-Value&#13;
date: Thu, 10 Nov 2022 10:35:11 GMT&#13;
server: u<a id="_idTextAnchor133"/>vicorn&#13;
{&#13;
    "hello": "world"&#13;
}</pre>&#13;
			<p>Our custom header is part of <span class="No-Break">the response.</span></p>&#13;
			<p>As we mentioned earlier, the good thing about this approach is that it’s within your path operation logic. That means <a id="_idIndexMarker299"/>you can dynamically set headers <a id="_idTextAnchor134"/>depending on what’s happening in your <span class="No-Break">business logic.</span></p>&#13;
			<h3>Setting cookies</h3>&#13;
			<p>Cookies can also<a id="_idIndexMarker300"/> be particularly useful when you want to maintain the user’s state within the browser between each of <span class="No-Break">their visits.</span></p>&#13;
			<p>To prompt the browser to save some cookies in your response, you could, of course, build your own <strong class="source-inline">Set-Cookie</strong> header and set it in the <strong class="source-inline">headers</strong> dictionary, just as we saw in the preceding command block. However, since this can be quite tricky to do, the <strong class="source-inline">Response</strong> object exposes a convenient <span class="No-Break"><strong class="source-inline">set_cookie</strong></span><span class="No-Break"> method:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_parameter_02.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/")async def custom_cookie(response: Response):&#13;
    response.set_cookie("cookie-name", "cookie-value", max_age=86400)&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_02.py</a></p>&#13;
			<p>Here, <a id="_idTextAnchor135"/>we simply set a cookie, named <strong class="source-inline">cookie-name</strong>, with the value of <strong class="source-inline">cookie-value</strong>. It’ll be valid for 86,400 seconds before the browser <span class="No-Break">removes it.</span></p>&#13;
			<p>Let’s <span class="No-Break">try it:</span></p>&#13;
			<pre class="source-code">&#13;
$ http GET http://localhost:8000HTTP/1.1 200 OK&#13;
content-length: 17&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:37:47 GMT&#13;
server: uvicorn&#13;
Set-Cookie: cookie-name=cookie-value; Max-Age=86400; Path=/; SameSite=lax&#13;
{&#13;
    "hello": "world"&#13;
}</pre>&#13;
			<p>Here, you can see that we have a nice <strong class="source-inline">Set-Cookie</strong> header with all of the properties of <span class="No-Break">our cookie.</span></p>&#13;
			<p>As you may know, cookies have a lot more options than the ones we have shown here; for instance, path, domain, and HTTP-only. The <strong class="source-inline">set_cookie</strong> method supports all of them. You can read about the full list of options in the official Starlette documentation (since <strong class="source-inline">Response</strong> is also borrowed from Starlette) <span class="No-Break">at </span><a href="https://www.starlette.io/responses/#set-cookie"><span class="No-Break">https://www.starlette.io/responses/#set-cookie</span></a><span class="No-Break">.</span></p>&#13;
			<p>If you’re not familiar<a id="_idIndexMarker301"/> with the <strong class="source-inline">Set-Cookie</strong> header, we also recommend that you refer to <em class="italic">MDN Web Docs</em>, which can be accessed <span class="No-Break">at </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie"><span class="No-Break"><span id="_idTextAnchor136"/>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie</span></a><span class="No-Break">.</span></p>&#13;
			<p>Of course, if you need to set several cookies, you can call this method <span class="No-Break">several times.</span></p>&#13;
			<h3>Setting the status code dynamically</h3>&#13;
			<p>In the <em class="italic">P<a id="_idTextAnchor137"/>ath operation parameters</em> section, we discussed a way to declaratively set the status code of the response. The drawback to this approach is that it’ll always be the same no matter <a id="_idIndexMarker302"/>what’s <span class="No-Break">happening inside.</span></p>&#13;
			<p>Let’s assume that we have an endpoint that updates an object in the database or creates it if it doesn’t exist. A good approach would be to return a <strong class="source-inline">200 OK</strong> status when the object already exists or a <strong class="source-inline">201 Created</strong> status when the object has to <span class="No-Break">be created.</span></p>&#13;
			<p>To do this, you can simply set the <strong class="source-inline">status_code</strong> property on the <span class="No-Break"><strong class="source-inline">Response</strong></span><span class="No-Break"> object:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_response_parameter_03.py</p>&#13;
			<pre class="source-code">&#13;
# Dummy databaseposts = {&#13;
    1: Post(title="Hello"),&#13;
}&#13;
@app.put("/posts/{id}")&#13;
async def update_or_create_post(id: int, post: Post, response: Response):&#13;
    if id not in posts:&#13;
        response.status_code = status.HTTP_201_CREATED&#13;
    posts[id] = post&#13;
    return posts[id]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_response_parameter_03.py</a></p>&#13;
			<p>First, we check whether the ID in the path exists in the database. If not, we change the statu<a id="_idTextAnchor138"/>s code to <strong class="source-inline">201</strong>. Then, we simply assign the post to this ID in <span class="No-Break">the database.</span></p>&#13;
			<p>Let’s try with an existing <span class="No-Break">post first:</span></p>&#13;
			<pre class="source-code">&#13;
$ http PUT http://localhost:8000/posts/1 title="Updated title"HTTP/1.1 200 OK&#13;
content-length: 25&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:41:47 GMT&#13;
server: uvicorn&#13;
{&#13;
    "title": "Updated title"&#13;
}</pre>&#13;
			<p>The post with an<a id="_idIndexMarker303"/> ID of <strong class="source-inline">1</strong> already exists, so we get a <strong class="source-inline">200</strong> status. Now, let’s try with a <span class="No-Break">non-existing ID:</span></p>&#13;
			<pre class="source-code">&#13;
$ http PUT http://localhost:8000/posts/2 title="New title"HTTP/1.1 201 Created&#13;
content-length: 21&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:42:20 GMT&#13;
server: uvicorn&#13;
{&#13;
    "title": "New title"&#13;
}</pre>&#13;
			<p>We get a <span class="No-Break"><strong class="source-inline">201</strong></span><span class="No-Break"> status!</span></p>&#13;
			<p>Now you have a way to dynamically set the status code in your logic. Bear in mind, though, that they <em class="italic">won’t be detected by the automatic documentation</em>. Therefore, they won’t appear as a possible response status code <span class="No-Break">in it.</span></p>&#13;
			<p>You might be <a id="_idIndexMarker304"/>tempted to use this approach to set <em class="italic">error status codes</em>, such as <strong class="source-inline">400 Bad <a id="_idTextAnchor139"/>Request</strong> or <strong class="source-inline">404 Not Found</strong>. In fa<a id="_idTextAnchor140"/>ct, you <em class="italic">shouldn’t do that</em>. FastAPI <a id="_idTextAnchor141"/>provides a dedicated way to do <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">HTTPException</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-62"><a id="_idTextAnchor142"/>Raising HTTP errors</h2>&#13;
			<p>When calling a <a id="_idIndexMarker305"/>REST API, quite frequently, you might find that things don’t go very well; you might come across the wrong parameters, invalid payloads, or objects that don’t exist anymore. Errors can happen for a lot <span class="No-Break">of reasons.</span></p>&#13;
			<p>That’s why it’s critical to detect them and raise a clear and unambiguous error message to the end user so that they can correct their mistake. In a REST API, there are two very important things that you can use to return an informative message: the status code and <span class="No-Break">the payload.</span></p>&#13;
			<p>The status code can give you a precious hint about the nature of the error. Since HTTP protocols provide a wide range of error status codes, your end user might not even need to read the payload to understand <span class="No-Break">what’s wrong.</span></p>&#13;
			<p>Of course, it’s always better to provide a clear error message at the same time in order to give further details and add some useful information regarding how the end user can solve <span class="No-Break">the issue.</span></p>&#13;
			<p class="callout-heading">Error status codes are crucial</p>&#13;
			<p class="callout">Some APIs choose to always return a <strong class="source-inline">200</strong> status code with the payload containing a property stating whether the request was successful or not, such as <strong class="source-inline">{"success": false}</strong>. Don’t do that. The RESTful philosophy encourages you to use the HTTP semantics to give meaning to the data. Having to parse the output and look for a property to determine whether the call was successful is a <span class="No-Break">bad design.</span></p>&#13;
			<p>To raise an HTTP error in FastAPI, you’ll have to raise a Python exception, <strong class="source-inline">HTTPException</strong>. This exception class will allow us to set a status code and an error message. It is caught by FastAPI error handlers that take care of forming a proper <span class="No-Break">HTTP response.</span></p>&#13;
			<p>In the following e<a id="_idTextAnchor143"/>xample, we’ll raise a <strong class="source-inline">400 Bad Request</strong> error if the <strong class="source-inline">password</strong> and <strong class="source-inline">password_confirm</strong> payload properties <span class="No-Break">don’t match:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_raise_errors_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/password")async def check_password(password: str = Body(...), password_confirm: str = Body(...)):&#13;
    if password != password_confirm:&#13;
        raise HTTPException(&#13;
            status.HTTP_400_BAD_REQUEST,&#13;
            detail="Passwords don't match.",&#13;
        )&#13;
    return {"message": "Passwords match."}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_01.py</a></p>&#13;
			<p>As you can see here, if the <a id="_idIndexMarker306"/>passwords are not equal, we directly raise <strong class="source-inline">HTTPException</strong>. The first argument is the status code, and the <strong class="source-inline">detail</strong> keyword argument lets us write an <span class="No-Break">error message.</span></p>&#13;
			<p>Let’s examine how <span class="No-Break">it works:</span></p>&#13;
			<pre class="source-code">&#13;
$ http POST http://localhost:8000/password password="aa" password_confirm="bb"HTTP/1.1 400 Bad Request&#13;
content-length: 35&#13;
content-type: application/json&#13;
date: Thu, 10 Nov 2022 10:46:36 GMT&#13;
server: uvicorn&#13;
{&#13;
    "detail": "Passwords don't match."&#13;
}</pre>&#13;
			<p>Here, we do get a <strong class="source-inline">400</strong> status code, and our error message has been wrapped nicely in a JSON object with the <strong class="source-inline">detail</strong> key. This is how FastAPI handles errors <span class="No-Break">by default.</span></p>&#13;
			<p>In fact, you a<a id="_idTextAnchor144"/>re not limited to<a id="_idIndexMarker307"/> a simple string for the error message: you can return a dictionary or a list in order to get structured information about the error. For example, take a look at the following <span class="No-Break">code snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_raise_errors_02.py</p>&#13;
			<pre class="source-code">&#13;
        raise HTTPException(            status.HTTP_400_BAD_REQUEST,&#13;
            detail={&#13;
                "message": "Passwords don't match.",&#13;
                "hints": [&#13;
                    "Check the caps lock on your keyboard",&#13;
                    "Try to make the password visible by clicking on the eye icon to check your typing",&#13;
                ],&#13;
            },&#13;
        )</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_raise_errors_02.py</a></p>&#13;
			<p>And that’s it! You now have the power to raise errors and give meaningful information about them to the <span class="No-Break">end user.</span></p>&#13;
			<p>So far, the methods you have seen should cover the majority of cases you’ll en<a id="_idTextAnchor145"/>counter during the development of an API. Sometimes, however, you’ll have scenarios where you’ll <a id="_idTextAnchor146"/>need to build a <a id="_idIndexMarker308"/>complete HTTP respons<a id="_idTextAnchor147"/>e yourself. This is the subject of the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-63"><a id="_idTextAnchor148"/>Building a custom response</h2>&#13;
			<p>Most of the time, you’ll let FastAPI <a id="_idIndexMarker309"/>take care of building an HTTP response by simply providing it with some data <a id="_idTextAnchor149"/>to serialize. Under the hood, FastAPI uses a subclass of <strong class="source-inline">Response</strong> called <strong class="source-inline">JSONResponse</strong>. Quite predictably, this response class takes care of serializing some data to JSON and adding the correct <span class="No-Break"><strong class="source-inline">Content-Type</strong></span><span class="No-Break"> header.</span></p>&#13;
			<p>However, there are other response classes that cover <span class="No-Break">common cases:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">HTMLResponse</strong>: This can be used to return an <span class="No-Break">HTML response</span></li>&#13;
				<li><strong class="source-inline">PlainTextResponse</strong>: This can be used to return <span class="No-Break">raw text</span></li>&#13;
				<li><strong class="source-inline">RedirectResponse</strong>: This can be used to make <span class="No-Break">a redirection</span></li>&#13;
				<li><strong class="source-inline">StreamingResponse</strong>: This can be used to stream a flow <span class="No-Break">of bytes</span></li>&#13;
				<li><strong class="source-inline">FileResponse</strong>: This can be used to automatically build a proper file response given the path of a file on the <span class="No-Break">local disk</span></li>&#13;
			</ul>&#13;
			<p>You have two ways of using them: either setting the <strong class="source-inline">response_class</strong> argument on the path decora<a id="_idTextAnchor150"/>tor or directly returning a <span class="No-Break">respons<a id="_idTextAnchor151"/>e instance.</span></p>&#13;
			<h3>Using the response_class argument</h3>&#13;
			<p>This is the <a id="_idIndexMarker310"/>simplest and most straightforward way to return a custom response. Indeed, by doing this, you won’t even have to create a class instanc<a id="_idTextAnchor152"/>e: yo<a id="_idTextAnchor153"/>u’ll just have to return the data as you usually do for standard <span class="No-Break">JSON responses.</span></p>&#13;
			<p>This is well suited for <strong class="source-inline">HTMLResponse</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">PlainTextResponse</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_custom_response_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIfrom fastapi.responses import HTMLResponse, PlainTextResponse&#13;
app = FastAPI()&#13;
@app.get("/html", response_class=HTMLResponse)&#13;
async def get_html():&#13;
    return """&#13;
        &lt;html&gt;&#13;
            &lt;head&gt;&#13;
                &lt;title&gt;Hello world!&lt;/title&gt;&#13;
            &lt;/head&gt;&#13;
            &lt;body&gt;&#13;
                &lt;h1&gt;Hello world!&lt;/h1&gt;&#13;
            &lt;/body&gt;&#13;
        &lt;/html&gt;&#13;
    """&#13;
@app.get("/text", response_class=PlainTextResponse)&#13;
async def text():&#13;
    return "Hello world!"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_01.py</a></p>&#13;
			<p>By setting the <strong class="source-inline">response_class</strong> argument <a id="_idIndexMarker311"/>on the decorator, you can change the class that will be used by FastAPI to build the response. Then, you can simply return valid data for this kind of response. Notice that the response classes are imported through the <span class="No-Break"><strong class="source-inline">fastapi.responses</strong></span><span class="No-Break"> module.</span></p>&#13;
			<p>The nice thing about this is that you can combine this option with the ones we saw in the <em class="italic">Path operation parameters</em> section. Using the <strong class="source-inline">Respon<a id="_idTextAnchor154"/>se</strong> parameter that we described in <em class="italic">The response<a id="_idTextAnchor155"/> parameter</em> section also <span class="No-Break">works perfectly!</span></p>&#13;
			<p>For the other response<a id="_idIndexMarker312"/> classes, h<a id="_idTextAnchor156"/>owever, you’ll have to build the instance yourself and then <span class="No-Break">return it.</span></p>&#13;
			<h3>Making a redirection</h3>&#13;
			<p>As mentioned<a id="_idIndexMarker313"/> earlier, <strong class="source-inline">RedirectResponse</strong> is a class that helps you build an HTTP redirection, which simply is an HTTP response with a <strong class="source-inline">Location</strong> header pointing to the new URL and a status code in the <em class="italic">3xx range</em>. It simply expects the URL you wish to redirect to as the <span class="No-Break">first argument:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_custom_response_02.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/redirect")async def redirect():&#13;
    return RedirectResponse("/new-url")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_02.py</a></p>&#13;
			<p>By default, it’ll use the <strong class="source-inline">307 Temporary Redirect</strong> status code, but you can change this through the <span class="No-Break"><strong class="source-inline">status_code</strong></span><span class="No-Break"> argument:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_custom_response_03.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/redirect")async def redirect():&#13;
    return RedirectResponse("/new-url", status_code=status.HTTP_301_MOVED_PERMANENTLY)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-Fast<span id="_idTextAnchor157"/>API-Second-Edition/tree/main/chapter03/chapter03_custom_response_03.py</a></p>&#13;
			<h3>erving a file</h3>&#13;
			<p>Now, let’s examine <a id="_idIndexMarker314"/>how <strong class="source-inline">FileResponse</strong> works. This is useful if you wish to propose some files to download. This response class will automatically take care of opening the file on disk and streaming the bytes along with the proper <span class="No-Break">HTTP headers.</span></p>&#13;
			<p>Let’s take a look at how we can use an endpoint to download a picture of a cat. You’ll find this in the code examples repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/assets/cat.jpg</span></a><span class="No-Break">.</span></p>&#13;
			<p>We just need to return an instance of <strong class="source-inline">FileResponse</strong> with the path of the file we want to serve as the <span class="No-Break">first argument:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_custom_response_04.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/cat")async def get_cat():&#13;
    root_directory = Path(__file__).parent.parent&#13;
    picture_path = root_directory / "assets" / "cat.jpg"&#13;
    return FileResponse(picture_path)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_04.py</a></p>&#13;
			<p class="callout-heading">The pathlib module</p>&#13;
			<p class="callout">Python provides a module to help you work with file paths, <strong class="source-inline">pathlib</strong>. It’s the recommended way to manipulate paths, as it takes care of handling them correctly, depending on the operating system you are running. You can read about the functions of this modul<a id="_idTextAnchor158"/>e in the official documentation <span class="No-Break">at </span><a href="https://docs.python.org/3/library/pathlib.html"><span class="No-Break">https://docs.python.org/3/library/pathlib.html</span></a><span class="No-Break">.</span></p>&#13;
			<p>Let’s examine what the HTTP response <span class="No-Break">looks like:</span></p>&#13;
			<pre class="source-code">&#13;
$ http GET http://localhost:8000/catHTTP/1.1 200 OK&#13;
content-length: 71457&#13;
content-type: image/jpeg&#13;
date: Thu, 10 Nov 2022 11:00:10 GMT&#13;
etag: c69cf2514977e3f18251f1bcf1433d0a&#13;
last-modified: Fri, 16 Jul 2021 07:08:42 GMT&#13;
server: uvicorn&#13;
+-----------------------------------------+&#13;
| NOTE: binary data not shown in terminal |&#13;
+-----------------------------------------+</pre>&#13;
			<p>As you can see, we <a id="_idIndexMarker315"/>have the right <strong class="source-inline">Content-Length</strong> and <strong class="source-inline">Content-Type</strong> headers for our image. The response even sets the <strong class="source-inline">Etag</strong> and <strong class="source-inline">Last-Modified</strong> headers so that the browser can properly cache the resource. HTTPie doesn’t show the binary data in the body; however, if <a id="_idTextAnchor159"/>you open the endpoint in your browser, you’ll see the <span class="No-Break">cat appear!</span></p>&#13;
			<h3>Custom responses</h3>&#13;
			<p>Finally, if you <a id="_idIndexMarker316"/>really have a case that’s not covered by the provided classes, you always have the option to use the <strong class="source-inline">Response</strong> class to build exactly what you need. With this class, you can set everything, including the body content and <span class="No-Break">the headers.</span></p>&#13;
			<p>The following example shows you how to return an <span class="No-Break">XML response:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter03_custom_response_05.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/xml")async def get_xml():&#13;
    content = """&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
        &lt;Hello&gt;World&lt;/Hello&gt;&#13;
    """&#13;
    return Response(content=content, media_type="application/xml")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03/chapter03_custom_response_05.py</a></p>&#13;
			<p>You can view the complete list of arguments in the Starlette documentation <span class="No-Break">at </span><a href="https://www.starlette.io/responses/#response"><span class="No-Break">https://www.starlette.io/responses/#response</span></a><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">Path operation parameters and response parameters won’t have any effect</p>&#13;
			<p class="callout">Bear in mind that when you directly return a <strong class="source-inline">Response</strong> class (or one of its subclasses), the parameters you set on the decorator or the operations you make on the injected <strong class="source-inline">Response</strong> object won’t have any effect. They are completely overridden by the <strong class="source-inline">Response</strong> object you return. If you need to customize the status code or the headers, then use the <strong class="source-inline">status_code</strong> and <strong class="source-inline">headers</strong> arguments when instantiating <span class="No-Break">your class.</span></p>&#13;
			<p>Well done! Now you have all the knowledge required to create the response you need for your REST API. You’ve learned that FastAPI comes with sensible defaults that can help you create proper JSON responses in no time. At the same time, it also gives you access to more advanced<a id="_idIndexMarker317"/> objects and options to allow you to make <span class="No-Break">custom responses.</span></p>&#13;
			<p>So far, all of the examples we’ve looked at have been quite short and simple. However, when you’re developing a real application, you’ll probably have dozens of endpoints an<a id="_idTextAnchor160"/>d models. In the final section of thi<a id="_idTextAnchor161"/>s chapter, we’ll examine how to organize such projects <a id="_idTextAnchor162"/>to make them modular and easier <span class="No-Break">to maintain.</span></p>&#13;
			<h1 id="_idParaDest-64">S<a id="_idTextAnchor163"/>tructuring a bigger project with multiple routers</h1>&#13;
			<p>When building a real-world web application, you’re likely to have a lot of code and logic: data models, API endpoints, and services. Of course, all of those can’t live in a single file; we <a id="_idTextAnchor164"/>have to structure the project so that it’s easy to maintain <span class="No-Break">and evolve.</span></p>&#13;
			<p>FastAPI supports the concept <a id="_idIndexMarker318"/>of <strong class="bold">routers</strong>. They are “sub-parts” of your API and are usually dedicated to a single type of object, such as users or posts, which are defined in their own files. You can then include them in your main FastAPI app so that it can route <span class="No-Break">it accordingly.</span></p>&#13;
			<p>In this section, we’ll explore how to use routers and how you can structure a FastAPI project. While this structure is one way to do it and works quite well, it’s not a golden rule and can be adapted to your <span class="No-Break">own needs.</span></p>&#13;
			<p>In the code examples <a id="_idIndexMarker319"/>repository, there is a folder named <strong class="source-inline">chapter03_project</strong>, which contains a sample project with this <span class="No-Break">structure: </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project</span></a></p>&#13;
			<p>Here is the <span class="No-Break">project structure:</span></p>&#13;
			<pre class="source-code">&#13;
.└── chapter03_project/&#13;
    ├── schemas/&#13;
    │   ├── __init__.py&#13;
    │   ├── post.py&#13;
    │   └── user.py&#13;
    ├── routers/&#13;
    │   ├── __init__.py&#13;
  <a id="_idTextAnchor165"/>  │   ├── posts.py&#13;
    │   └── users<a id="_idTextAnchor166"/>.py&#13;
    ├── __init__.py&#13;
    ├── app.py&#13;
    └── db.py</pre>&#13;
			<p>Here, you can see that we chose to have packages that contain Pydantic models on one side and routers on the other side. At the root of the project, we have a file named <strong class="source-inline">app.py</strong>, <strong class="source-inline">which</strong> will expose the main FastAPI application. The <strong class="source-inline">db.py</strong> file defines a dummy database for the sake of <span class="No-Break">the example.</span></p>&#13;
			<p>The <strong class="source-inline">__init__.py</strong> files are there to properly define our directories as Python packages. You can read more details about this in <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specificities</em>, in the <em class="italic">Packages, modules, and </em><span class="No-Break"><em class="italic">imports</em></span><span class="No-Break"> section.</span></p>&#13;
			<p>First, let’s examine what a<a id="_idIndexMarker320"/> FastAPI router <span class="No-Break">looks like:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">users.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import APIRouter, HTTPException, statusfrom chapter03_project.db import db&#13;
from chapter03_project.schemas.user import User, UserCreate&#13;
router = APIRouter()&#13;
@router.get("/")&#13;
async def all() -&gt; list[User]:&#13;
    return list(db.users.values())</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/users.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/users.py</a></p>&#13;
			<p>As you can see here, instead of instantiating the <strong class="source-inline">FastAPI</strong> class, you instantiate the <strong class="source-inline">APIRouter</strong> cl<a id="_idTextAnchor167"/>ass. Then, you can use it e<a id="_idTextAnchor168"/>xactly the same way to decorate your path <span class="No-Break">operation functions.</span></p>&#13;
			<p>Also, notice that we import the Pydantic models from the relevant module in the <span class="No-Break"><strong class="source-inline">schemas</strong></span><span class="No-Break"> package.</span></p>&#13;
			<p>We won’t go into detail about the logic of the endpoints, but we invite you to read about it. It uses all the FastAPI features that we’ve explored <span class="No-Break">so far.</span></p>&#13;
			<p>Now, let’s take a look at how to import this router and include it within a <span class="No-Break">FastAPI application:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPIfrom chapter03_project.routers.posts import router as posts_router&#13;
from chapter03_project.routers.users import router as users_router&#13;
app = FastAPI()&#13;
app.include_router(posts_router, prefix="/posts", tags=["posts"])&#13;
app.include_router(users_router, prefix="/users", tags=["users"])</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter03_project/routers/app.py</a></p>&#13;
			<p>As usual, we instantiate the <strong class="source-inline">FastAPI</strong> class. Then, we use the <strong class="source-inline">include_router</strong> method to add our sub-router. You can see that we simply imported the r<a id="_idTextAnchor169"/>outer from its relevant module and use<a id="_idTextAnchor170"/>d it as the first argument of <strong class="source-inline">include_router</strong>. Notice that we used the <strong class="source-inline">as</strong> syntax while importing. Since bot<a id="_idTextAnchor171"/>h <strong class="source-inline">users</strong> and <strong class="source-inline">posts</strong> routers are named the same inside their <a id="_idIndexMarker321"/>module, this syntax allows us to alias their name and, thus, avoid <span class="No-Break"><strong class="bold">name collision</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Additionally, you can see that we set the <strong class="source-inline">prefix</strong> keyword argument. This allows us to prefix the path of all the endpoints of this router. This way, you don’t have to hardcode it into the router logic and can easily change it for the whole router. It can also be used to provide versioned paths of your API, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/v1</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Finally, the <strong class="source-inline">tags</strong> argument helps you to group endpoints in the interactive documentation for better readability. By doing this, the <strong class="source-inline">posts</strong> and <strong class="source-inline">users</strong> endpoints will be clearly separated in <span class="No-Break">the documentation.</span></p>&#13;
			<p>And that’s all you need to do! You can run this whole application, as usual, <span class="No-Break">with Uvicorn:</span></p>&#13;
			<pre class="source-code">&#13;
$ uvicorn chapter03_project.app:app</pre>			<p>If you open the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong>, you’ll see that all the routes are there, grouped by<a id="_idIndexMarker322"/> the tags we specified w<a id="_idTextAnchor172"/>hen including <span class="No-Break">the router:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer015" class="IMG---Figure">&#13;
					<img src="Images/Figure_3.3_B19528.jpg" alt="Figure 3.3 – Tagged routers in the interactive documentation" width="965" height="1295"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 <a id="_idTextAnchor173"/>– Tagged routers in the interactive documentation</p>&#13;
			<p>Once again, you can see that FastAPI is both powerful and very lightweight to use. The good thing about routers is that you can even nest them and include sub-routers in routers that include ot<a id="_idTextAnchor174"/>her routers themselves. Therefore, you can have a quite complex routing hierarchy with very <span class="No-Break">low effort.</span></p>&#13;
			<h1 id="_idParaDest-65"><a id="_idTextAnchor175"/>Summary</h1>&#13;
			<p>Well done! You’re now acquainted with all the basic features of FastAPI. Throughout this chapter, you learned how to create and run API endpoints where you can validate and retrieve data from all parts of an HTTP request: the path, the query, the parameters, the headers, and, of course, the body. You also learned how to tailor the HTTP response to your needs, whether it is a simple JSON response, an error, or a file to download. Finally, you looked at how to define separate API routers and include them in your main application to keep a clean and maintainable <span class="No-Break">project structure.</span></p>&#13;
			<p>You have enough knowledge now to start building your own API with FastAPI. In the next chapter, we’ll focus on Pydantic models. You now know that they are at the core of the data validation features of FastAPI, so it’s crucial to fully understand how they work and how to manipulate <span class="No-Break">them efficiently.</span></p>&#13;
		</div>&#13;
	</div></body></html>