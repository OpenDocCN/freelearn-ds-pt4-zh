<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer017">&#13;
			<h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor176"/>4</h1>&#13;
			<h1 id="_idParaDest-67"><a id="_idTextAnchor177"/>Managing Pydantic Data Models in FastAPI</h1>&#13;
			<p>This chapter will cover in detail the definition of a data model with Pydantic, the underlying data validation library used by FastAPI. We’ll explain how to implement variations of the same model without repeating the same code again and again, thanks to class inheritance. Finally, we’ll show how to implement custom data validation logic into <span class="No-Break">Pydantic models.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Defining models and their field types <span class="No-Break">with Pydantic</span></li>&#13;
				<li>Creating model variations with <span class="No-Break">class inheritance</span></li>&#13;
				<li>Adding custom data validation <span class="No-Break">with Pydantic</span></li>&#13;
				<li>Working with <span class="No-Break">Pydantic objects</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-68"><a id="_idTextAnchor178"/>Technical requirements</h1>&#13;
			<p>To run the code examples, you’ll need a Python virtual environment, which we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>You’ll find all the code examples for this chapter in the dedicated GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-69"><a id="_idTextAnchor179"/>Defining models and their field types with Pydantic</h1>&#13;
			<p>Pydantic is a <a id="_idTextAnchor180"/>powerful library <a id="_idIndexMarker323"/>for<a id="_idTextAnchor181"/> defining data models<a id="_idTextAnchor182"/> using Python classes and type hints. This approach makes those classes completely compatible with static type checking. Besides, since there are regular Python classes, we can use inheritance and also define our very own methods to add <span class="No-Break">custom logic.</span></p>&#13;
			<p>In <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI</em>, you learned the basics of defining a<a id="_idTextAnchor183"/> data model<a id="_idTextAnchor184"/> with Pydantic: you have to define a class inheriting from <strong class="source-inline">BaseModel</strong> and list all the fields as<a id="_idTextAnchor185"/> class properties, each one with a type hint to enforce <span class="No-Break">their type.</span></p>&#13;
			<p>In this section, we’ll focus on model definition and see all the possibilities we have for defining <span class="No-Break">the fields.</span><a id="_idTextAnchor186"/></p>&#13;
			<h2 id="_idParaDest-70"><a id="_idTextAnchor187"/>Standard field types</h2>&#13;
			<p>We’ll begin by<a id="_idTextAnchor188"/> <a id="_idIndexMarker324"/>defining fields with standard types, which only involve simple type hints. Let’s review a simple model representing information about a person. You can see this in the following <span class="No-Break">code snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_01.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModelclass Person(BaseModel):&#13;
    first_name: str&#13;
    last_name: str&#13;
    age: int</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py</a></p>&#13;
			<p>As we said, you just have to write the names of the fields and type-hint them with the intended type. Of course, we are not limited to scalar types: we can use compound types, such as lists and tuples, or classes such as datetime and enum. In the following example, you can see a model using those more <span class="No-Break">complex types:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_02.py</p>&#13;
			<pre class="source-code">&#13;
from datetime import datefrom enum import Enum&#13;
from pydantic import BaseModel, ValidationError&#13;
class Gender(str, Enum):&#13;
    MALE = "MALE"&#13;
    FEMALE = "FEMALE"&#13;
    NON_BINARY = "NON_BINARY"&#13;
class Person(BaseModel):&#13;
    first_name: str&#13;
    last_name: str&#13;
    gender: Gender&#13;
    birthdate: date&#13;
    interests: list[str]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py</a></p>&#13;
			<p>There ar<a id="_idTextAnchor189"/>e three things to notice in <span class="No-Break">this example.</span></p>&#13;
			<p>First, we used <a id="_idIndexMarker325"/>the standard Python <strong class="source-inline">Enum</strong> class as a type for the <strong class="source-inline">gender</strong> field. This allows us to specify a set of valid values. If we input a value that’s not in this enumeration, Pydantic will raise an error, as illustrated in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_02.py</p>&#13;
			<pre class="source-code">&#13;
# Invalid gendertry:&#13;
    Person(&#13;
        first_name="John",&#13;
        last_name="Doe",&#13;
        gender="INVALID_VALUE",&#13;
        birthdate="1991-01-01",&#13;
        interests=["travel", "sports"],&#13;
    )&#13;
except ValidationError as e:&#13;
    print(str(e))</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py</a></p>&#13;
			<p>If you run t<a id="_idTextAnchor190"/>he preceding example, you’ll get <span class="No-Break">this output:</span></p>&#13;
			<pre class="source-code">&#13;
1 validation error for Persongender&#13;
  value is not a valid enumeration member; permitted: 'MALE', 'FEMALE', 'NON_BINARY' (type=type_error.enum; enum_values=[&lt;Gender.MALE: 'MALE'&gt;, &lt;Gender.FEMALE: 'FEMALE'&gt;, &lt;Gender.NON_BINARY: 'NON_BINARY'&gt;])</pre>&#13;
			<p>Actually, this is <a id="_idIndexMarker326"/>exactly what we did in <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI</em>, to limit the allowed values of the <span class="No-Break"><strong class="source-inline">path</strong></span><span class="No-Break"> parameter.</span></p>&#13;
			<p>Then, we used the <strong class="source-inline">date</strong> Python class as a type for the <strong class="source-inline">birthdate</strong> field. Pydantic is able to automatically parse dates and times given as ISO for<a id="_idTextAnchor191"/>mat strings or timestamp integers and instantiate a proper <strong class="source-inline">date</strong> or <strong class="source-inline">datetime</strong> object. Of course, if the parsing fails, you’ll also get an error. You can experiment with this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_02.py</p>&#13;
			<pre class="source-code">&#13;
# Invalid birthdatetry:&#13;
    Person(&#13;
        first_name="John",&#13;
        last_name="Doe",&#13;
        gender=Gender.MALE,&#13;
        birthdate="1991-13-42",&#13;
        interests=["travel", "sports"],&#13;
    )&#13;
except ValidationError as e:&#13;
    print(str(e))</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py</a></p>&#13;
			<p>And here is <a id="_idTextAnchor192"/><span class="No-Break">the output:</span></p>&#13;
			<pre class="source-code">&#13;
1 validation error for Personbirthdate&#13;
  invalid date format (type=value_error.date)</pre>&#13;
			<p>Finally, we defined <strong class="source-inline">interests</strong> as a list of strings. Once again, Pydantic will check whether the field is a valid list <span class="No-Break">of strings.</span></p>&#13;
			<p>Obviously, if everything <a id="_idIndexMarker327"/>is okay, we get a <strong class="source-inline">Person</strong> instance and have access to the properly parsed fields. This is what we show in the following <span class="No-Break">code snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_02.py</p>&#13;
			<pre class="source-code">&#13;
# Validperson = Person(&#13;
    first_name="John",&#13;
    last_name="Doe",&#13;
    gender=Gender.MALE,&#13;
    birthdate="1991-01-01",&#13;
    interests=["travel", "sports"],&#13;
)&#13;
# first_name='John' last_name='Doe' gender=&lt;Gender.MALE: 'MALE'&gt; birthdate=datetime.date(1991, 1, 1) interests=['travel', 'sports']&#13;
print(person)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py</a></p>&#13;
			<p>As you can <a id="_idIndexMarker328"/>see, th<a id="_idTextAnchor193"/>is is quite powerful, and we can have quite complex field types. But that’s not all: <em class="italic">fields can be Pydantic models themselves</em>, allowing you to have sub-objects! In the following code example, we expand the previous snippet to add an <span class="No-Break"><strong class="source-inline">address</strong></span><span class="No-Break"> field:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_03.py</p>&#13;
			<pre class="source-code">&#13;
class Address(BaseModel):    street_address: str&#13;
    postal_code: str&#13;
    city: str&#13;
    country: str&#13;
class Person(BaseModel):&#13;
    first_name: str&#13;
    last_name: str&#13;
    gender: Gender&#13;
    birthdate: date&#13;
    interests: list[str]&#13;
    address: Address</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py</a></p>&#13;
			<p>We just ha<a id="_idTextAnchor194"/>ve to define another Pydantic model and use it as a type hint. Now, you can either instantiate a <strong class="source-inline">Person</strong> instance with an already valid <strong class="source-inline">Address</strong> instance or, even better, with a <a id="_idIndexMarker329"/>dictionary. In this case, Pydantic will automatically parse it and validate it against the <span class="No-Break">address model.</span></p>&#13;
			<p>In the following code snippet, we try to input an <span class="No-Break">invalid address:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_03.py</p>&#13;
			<pre class="source-code">&#13;
# Invalid addresstry:&#13;
    Person(&#13;
        first_name="John",&#13;
        last_name="Doe",&#13;
        gender=Gender.MALE,&#13;
        birthdate="1991-01-01",&#13;
        interests=["travel", "sports"],&#13;
        address={&#13;
            "street_address": "12 Squirell Street",&#13;
            "postal_code": "424242",&#13;
            "city": "Woodtown",&#13;
            # Missing country&#13;
        },&#13;
    )&#13;
except ValidationError as e:&#13;
    print(str(e))</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py</a></p>&#13;
			<p>This will generate the following <span class="No-Break">validation error:</span></p>&#13;
			<pre class="source-code">&#13;
1 validation error for Personaddress -&gt; country&#13;
  field required (type=value_error.missing)</pre>&#13;
			<p>Pydantic clearly <a id="_idIndexMarker330"/>sh<a id="_idTextAnchor195"/>ows the missing field in the sub-object. Once again, if everything goes well, we get a <strong class="source-inline">Person</strong> instance and its associated <strong class="source-inline">Address</strong>, as you can see in the <span class="No-Break">following extract:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_standard_field_types_03.py</p>&#13;
			<pre class="source-code">&#13;
# Validperson = Person(&#13;
    first_name="John",&#13;
    last_name="Doe",&#13;
    gender=Gender.MALE,&#13;
    birthdate="1991-01-01",&#13;
    interests=["travel", "sports"],&#13;
    address={&#13;
        "street_address": "12 Squirell Street",&#13;
        "postal_code": "424242",&#13;
        "city": "Woodtown",&#13;
        "country": "US",&#13;
    },&#13;
)&#13;
print(person)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_type<span id="_idTextAnchor196"/>s_03.py</a></p>&#13;
			<h2 id="_idParaDest-71"><a id="_idTextAnchor197"/>Optional fields and default values</h2>&#13;
			<p>Up to now<a id="_idTextAnchor198"/>, we’ve assumed that each field had to be provid<a id="_idTextAnchor199"/>ed when instantiating the model. Quite <a id="_idIndexMarker331"/>often, however, there are values that we want to be optional because <a id="_idIndexMarker332"/>they may not be relevant to each object instance. Sometimes, we also wish to set a default value for a field when it’s <span class="No-Break">not specified.</span></p>&#13;
			<p>As you may have guessed, this is done quite simply, with the <strong class="source-inline">| None</strong> typing annotation, as illustrated in the following <span class="No-Break">code snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_optional_fields_default_values_01.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModelclass UserProfile(BaseModel):&#13;
    nickname: str&#13;
    location: str | None = None&#13;
    subscribed_newsletter: bool = True</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py</a></p>&#13;
			<p>When defining a field with the <strong class="source-inline">| None</strong> type hint, it accepts a <strong class="source-inline">None</strong> value. As you can see in the preceding code, the default value can be simply assigned by putting the value after an <span class="No-Break">equals sign.</span></p>&#13;
			<p>Be careful, though: <em class="italic">don<a id="_idTextAnchor200"/>’t assign default values such as<a id="_idTextAnchor201"/> this for dynamic types</em> such as datetimes. If you do, the datetime instantiation will be evaluated only once when the model is imported. The effect of this is that all the objects you instantiate will then share the same value instead of having a fresh value. You can observe this behavior in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_optional_fields_default_values_02.py</p>&#13;
			<pre class="source-code">&#13;
class Model(BaseModel):    # Don't do this.&#13;
    # This example shows you why it doesn't work.&#13;
    d: datetime = datetime.now()&#13;
o1 = Model()&#13;
print(o1.d)&#13;
time.sleep(1)  # Wait for a second&#13;
o2 = Model()&#13;
print(o2.d)&#13;
print(o1.d &lt; o2.d)  # False</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py</a></p>&#13;
			<p>Even though we <a id="_idIndexMarker333"/>waited for 1 second between the instantiation of <strong class="source-inline">o1</strong> and <strong class="source-inline">o2</strong>, the <strong class="source-inline">d</strong> datetime <a id="_idIndexMarker334"/>is the same! This means that the datetime is evaluated only once when the class <span class="No-Break">is imported.</span></p>&#13;
			<p>You can have the same kind of problem if you want to have a default list, such as <strong class="source-inline">l: list[str] = ["a", "b", "c"]</strong>. Notice that this is true for every Python object, not only Pydantic models, so you should bear this <span class="No-Break">in mind.</span></p>&#13;
			<p>So, how d<a id="_idTextAnchor202"/>o we assign dynamic default values? Fortunatel<a id="_idTextAnchor203"/>y, Pydantic provides a <strong class="source-inline">Field</strong> function that allows us to set some advanced options on our fields, including one to set a factory for creating dynamic values. Before showing you this, we’ll first introduce the <span class="No-Break"><strong class="source-inline">Field</strong></span><span class="No-Break"> function.</span></p>&#13;
			<p>In <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI<a id="_idTextAnchor204"/></em>, we showed how to apply some validation to the request parameters to check whether a number was in a certain ra<a id="_idTextAnchor205"/>nge or whether a string matched a regular expression. Actually, these options directly come from Pydantic! We can use the same techniques to apply validation to the fields of <span class="No-Break">a model.</span></p>&#13;
			<p>To do this, we’ll use the <strong class="source-inline">Field</strong> function from Pydantic and use its result as the default value of the field. In the following <a id="_idIndexMarker335"/>example, we define a <strong class="source-inline">Person</strong> model <a id="_idIndexMarker336"/>with the <strong class="source-inline">first_name</strong> and <strong class="source-inline">last_name</strong> required properties, which should be at least three characters long, and an optional <strong class="source-inline">age</strong> property, which should be an integer between <strong class="source-inline">0</strong> and <strong class="source-inline">120</strong>. We show the implementation of this model in the following <span class="No-Break">code snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_fields_validation_01.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModel, Field, ValidationErrorclass Person(BaseModel):&#13;
    first_name: str = Field(..., min_length=3)&#13;
    last_name: str = Field(..., min_length=3)&#13;
    age: int | None = Field(None, ge=0, le=120)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py</a></p>&#13;
			<p>As<a id="_idTextAnchor206"/> you can see, the syntax is very similar to the one we saw for <strong class="source-inline">Path</strong>, <strong class="source-inline">Query</strong>, and <strong class="source-inline">Body</strong>. The first positional argument defines the <em class="italic">default value</em> for the field. If the field is required, we use an ellipsis, <strong class="source-inline">...</strong>. Then, the keyword arguments are there to set options for the field, including some <span class="No-Break">basic validation.</span></p>&#13;
			<p>You can view <a id="_idIndexMarker337"/>a complete list of the arguments accepted by <strong class="source-inline">Field</strong> in the official Pydantic documentation, <span class="No-Break">at </span><a href="https://pydantic-docs.helpmanual.io/usage/schema/#field-customization"><span class="No-Break">https://pydantic-docs.helpmanual.io/usage/schema/#field-customization</span></a><span class="No-Break">.</span></p>&#13;
			<h3>Dynamic default values</h3>&#13;
			<p>In the previo<a id="_idTextAnchor207"/>us <a id="_idIndexMarker338"/>section, we warned you about setting dynamic values as defaults. Fortunately, Pydantic provides the <strong class="source-inline">default_factory</strong> argument on the <strong class="source-inline">Field</strong> function to cover this use case. This argument expects you to pass a function that will be called during model instantiation. Thus, the resulting object will be evaluated at runtime each time you create a new object. You can see how to use it in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_fields_validation_02.py</p>&#13;
			<pre class="source-code">&#13;
from datetime import datetimefrom pydantic import BaseModel, Field&#13;
def list_factory():&#13;
    return ["a", "b", "c"]&#13;
class Model(BaseModel):&#13;
    l: list[str] = Field(default_factory=list_factory)&#13;
    d: datetime = Field(default_factory=datetime.now)&#13;
    l2: list[str] = Field(default_factory=list)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py</a></p>&#13;
			<p>You<a id="_idTextAnchor208"/> simply have to pass a function to this argument. Don’t put arguments on it: it’ll be Pydantic that will automatically call the function for you when instantiating a new object. If you need to call a function with specific arguments, you’ll have to wrap it into your own function, as we did <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">list_factory</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Notice also that <a id="_idIndexMarker339"/>the first positional argument used for the default value (such as <strong class="source-inline">None</strong> or <strong class="source-inline">...</strong>) is completely omitted here. This makes sense: it’s not consistent to have both a default value and a factory. Pydantic will raise an error if you set those two <span class="No-Break">arg<a id="_idTextAnchor209"/>uments together.</span></p>&#13;
			<h2 id="_idParaDest-72"><a id="_idTextAnchor210"/>Validating email addresses and URLs with Pydantic types</h2>&#13;
			<p>For conve<a id="_idTextAnchor211"/>nience, Pydantic provides some classes to use as field types <a id="_idTextAnchor212"/>to validate some common <a id="_idIndexMarker340"/>patterns, such as email addresse<a id="_idTextAnchor213"/>s <a id="_idIndexMarker341"/><span class="No-Break">or URLs.</span></p>&#13;
			<p>In the <a id="_idIndexMarker342"/>following example, we’ll use <strong class="source-inline">EmailStr</strong> and <a id="_idTextAnchor214"/><strong class="source-inline">HttpUrl</strong> t<a id="_idTextAnchor215"/>o <a id="_idIndexMarker343"/>validate an email address and an <span class="No-Break">HTTP URL.</span></p>&#13;
			<p>For <strong class="source-inline">EmailStr</strong> to work, you’ll need an optional dependency, <strong class="source-inline">email-validator</strong>, which you can install with the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv)$ pip install email-validator</pre>			<p>Those classes work like any other type or class: just use them as a type hint for your field. You can see this in the <span class="No-Break">following extract:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_pydantic_types_01.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModel, EmailStr, HttpUrl, ValidationErrorclass User(BaseModel):&#13;
    email: EmailStr&#13;
    website: HttpUrl</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydanti<span id="_idTextAnchor216"/>c_types_01.py</a></p>&#13;
			<p>In the followi<a id="_idTextAnchor217"/>ng exampl<a id="_idTextAnchor218"/>e, we check that <a id="_idTextAnchor219"/>the email address is <span class="No-Break">correctly validated:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_pydantic_types_01.py</p>&#13;
			<pre class="source-code">&#13;
# Invalid emailtry:&#13;
    User(email="jdoe", website="https://www.example.com")&#13;
except ValidationError as e:&#13;
    print(str(e))</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py</a></p>&#13;
			<p>You <a id="_idIndexMarker344"/>will see the <a id="_idIndexMarker345"/><span class="No-Break">following output:</span></p>&#13;
			<pre class="source-code">&#13;
1 validation error for Useremail&#13;
  value is not a valid email address (type=value_error.email)</pre>&#13;
			<p>We also <a id="_idIndexMarker346"/>check that the URL is correctly parsed, <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker347"/></span><span class="No-Break">follows:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_pydantic_types_01.py</p>&#13;
			<pre class="source-code">&#13;
# Invalid URLtry:&#13;
    User(email="jdoe@example.com", website="jdoe")&#13;
except ValidationError as e:&#13;
    print(str(e))</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py</a></p>&#13;
			<p>You will see the <span class="No-Break">following output:</span></p>&#13;
			<pre class="source-code">&#13;
1 validation error for Userwebsite&#13;
  invalid or missing URL scheme (type=value_<a id="_idTextAnchor220"/>error.url.scheme)</pre>&#13;
			<p>If you have a look at a valid example<a id="_idTextAnchor221"/>, shown next, yo<a id="_idTextAnchor222"/>u’ll see that the URL is parse<a id="_idTextAnchor223"/>d into an object, giving you access to the different parts of it, such as the scheme <span class="No-Break">or hostname:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_pydantic_types_01.py</p>&#13;
			<pre class="source-code">&#13;
# Validuser = User(email="jdoe@example.com", website="https://www.example.com")&#13;
# email='jdoe@example.com' website=HttpUrl('https://www.example.com', scheme='https', host='www.example.com', tld='com', host_type='domain')&#13;
print(user)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py</a></p>&#13;
			<p>Pydantic provides quite a big set of types that can help you in various situations. We invite you to <a id="_idIndexMarker348"/>review the full list of them in the official documentation <span class="No-Break">at </span><a href="https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types"><span class="No-Break">https://pydantic-docs.helpmanual.io/usage/types/#pydan<span id="_idTextAnchor224"/>tic-types</span></a><span class="No-Break">.</span></p>&#13;
			<p>You now <a id="_idIndexMarker349"/>have a better idea of how to <a id="_idIndexMarker350"/>define you<a id="_idTextAnchor225"/>r Pydantic models finely <a id="_idIndexMarker351"/>by using more advanced types or leveraging <a id="_idIndexMarker352"/>the validation features. As we <a id="_idTextAnchor226"/>said, those models are at the heart of FastAPI, and you’ll probably have to define several variations for the same entity to account for several situations. In the next section, we’ll show how to do <a id="_idTextAnchor227"/>that with <span class="No-Break">minimum repetition.</span></p>&#13;
			<h1 id="_idParaDest-73"><a id="_idTextAnchor228"/>Creating model variations with class inheritance</h1>&#13;
			<p>In <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI</em>, we saw a c<a id="_idTextAnchor229"/>ase where we needed to <a id="_idIndexMarker353"/>define two var<a id="_idTextAnchor230"/>iations of <a id="_idIndexMarker354"/>a Pydantic model in order to split the data we want to store in the backend and the data we want to show to the user. This is a common pattern in FastAPI: you define one model for creation, one for the response, and one for the data to store in <span class="No-Break">the database.</span></p>&#13;
			<p>We show <a id="_idIndexMarker355"/>this basic approach <a id="_idIndexMarker356"/>in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_model_inheritance_01.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModelclass PostCreate(BaseModel):&#13;
    title: str&#13;
    content: str&#13;
class PostRead(BaseModel):&#13;
    id: int&#13;
    title: str&#13;
    content: str&#13;
class Post(BaseModel):&#13;
    id: int&#13;
    title: str&#13;
    content: str&#13;
    nb_views: int = 0</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_mode<span id="_idTextAnchor231"/>l_inheritance_01.py</a></p>&#13;
			<p>We have three models here, covering <span class="No-Break">three situations:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">PostCreate</strong> will be used for a <strong class="source-inline">POST</strong> endpoint to create a new post. We expect the user to give the title and the content; however, the <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) will be automatically determined by <span class="No-Break">the database.</span></li>&#13;
				<li><strong class="source-inline">PostRead</strong> will be used when we retrieve the data of a post. We want its title and content, of course, but also its associated ID in <span class="No-Break">the database.</span></li>&#13;
				<li><strong class="source-inline">Post</strong> will carry all the data we wish to store in the database. Here, we also want to store the number of views, but we want to keep this secret to make our own <span class="No-Break">statistics internally.</span></li>&#13;
			</ul>&#13;
			<p>You can see here that we are repeating ourselves quite a lot, especially with the <strong class="source-inline">title</strong> and <strong class="source-inline">content</strong> fields. In bigger examples with lots of fields and lots of validation options, this could quickly <span class="No-Break">become unman<a id="_idTextAnchor232"/>ageable.</span></p>&#13;
			<p>The way to avoid this is t<a id="_idTextAnchor233"/>o leverage model inheritance. The approach is simple: identify the fields that are <a id="_idIndexMarker357"/>common to every variation <a id="_idIndexMarker358"/>and put them in a model, which will be used as a base for every other. Then, you only have to inherit from that model to create your variations and add the specific fields. In the following example, we see what our previous example looks like with <span class="No-Break">this method:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_model_inheritance_02.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModelclass PostBase(BaseModel):&#13;
    title: str&#13;
    content: str&#13;
class PostCreate(PostBase):&#13;
    pass&#13;
class PostRead(PostBase):&#13;
    id: int&#13;
class Post(PostBase):&#13;
    id: int&#13;
    nb_views: int = 0</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py</a></p>&#13;
			<p>Now, whenever you need to add a field for the whole entity, all you have to do is to add it to the <strong class="source-inline">PostBase</strong> model as shown in the following <span class="No-Break">code sn<a id="_idTextAnchor234"/>ippet.</span></p>&#13;
			<p>It’s also very <a id="_idIndexMarker359"/>conv<a id="_idTextAnchor235"/>enient if you wish to define <a id="_idIndexMarker360"/>methods on your model. Remember that Pydantic models are regular Python classes, so you can implement as many methods as <span class="No-Break">you wish!</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_model_inheritance_03.py</p>&#13;
			<pre class="source-code">&#13;
class PostBase(BaseModel):    title: str&#13;
    content: str&#13;
    def excerpt(self) -&gt; str:&#13;
        return f"{self.content[:140]}..."</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py</a></p>&#13;
			<p>Defining the <strong class="source-inline">excerpt</strong> method on <strong class="source-inline">PostBase</strong> means it’ll be available in every <span class="No-Break">model variation.</span></p>&#13;
			<p>While it’s not strictly required, this inheritance approach greatly helps to prevent code duplication and, ultimately, bugs. We’ll see in the next section that it’ll make even more <a id="_idTextAnchor236"/>sense with custom <span class="No-Break">validation methods.</span></p>&#13;
			<h1 id="_idParaDest-74">Adding custom data validatio<a id="_idTextAnchor237"/>n with Pydantic</h1>&#13;
			<p>Up <a id="_idTextAnchor238"/>to now, we’ve seen how to apply basic validation to our models through <strong class="source-inline">Field</strong> arguments <a id="_idIndexMarker361"/>or the custom types provided <a id="_idIndexMarker362"/>by Pydantic. In a real-world project, though, you’ll probably need to add your own custom validation logic <a id="_idTextAnchor239"/>for your specific case. Pydantic allows this by defining <strong class="bold">validators</strong>, which are methods on the model that can be applied <a id="_idTextAnchor240"/>at the field level or the <span class="No-Break">object level.</span></p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor241"/>Applying validation at the field level</h2>&#13;
			<p>This is the most <a id="_idIndexMarker363"/>common case: having a validation rule for a single field. To define a vali<a id="_idTextAnchor242"/>dation rule in Pydantic, we just have to write a static method on our model and decorate it with the <strong class="source-inline">validator</strong> <a id="_idTextAnchor243"/>decorator. As a reminder, decorators are syntactic sugar, allowing the wrapping of a function or a class with common logic without <span class="No-Break">compromising readability.</span></p>&#13;
			<p>The following example checks a birth date by verifying that the person is not more than 120 <span class="No-Break">years old:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_custom_validation_01.py</p>&#13;
			<pre class="source-code">&#13;
from datetime import datefrom pydantic import BaseModel, ValidationError, validator&#13;
class Person(BaseModel):&#13;
    first_name: str&#13;
    last_name: str&#13;
    birthdate: date&#13;
    @validator("birthdate")&#13;
    def valid_birthdate(cls, v: date):&#13;
        delta = date.today() - v&#13;
        age = delta.days / 365&#13;
        if age &gt; 120:&#13;
            raise ValueError("You seem a bit too old!")&#13;
        return v</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validat<span id="_idTextAnchor244"/>ion_01.py</a></p>&#13;
			<p>As you can see, <strong class="source-inline">validator</strong> is a static class method (the first argument, <strong class="source-inline">cls</strong>, is the class itself), with the <strong class="source-inline">v</strong> ar<a id="_idTextAnchor245"/>gument being the value to validate. It’s decorated by the <strong class="source-inline">validator</strong> decorator, which expects the name of the argument to validate to be its <span class="No-Break">first argument.</span></p>&#13;
			<p>Pydantic expects two things for this method, <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>If the value is <a id="_idIndexMarker364"/>not valid according to your logic, you should raise a <strong class="source-inline">ValueError</strong> error with an explicit <span class="No-Break">error message.</span></li>&#13;
				<li>Otherwise, you should return the value that will be assigned to the model. Notice that it doesn’t need to be the same as the input value: you can easily change it to fit your needs. That’s actually what we’ll do in an upcoming section, <em class="italic">App<a id="_idTextAnchor246"/>lying validation before </em><span class="No-Break"><em class="italic">Pydantic parsing</em></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-76">Applying valida<a id="_idTextAnchor247"/>tion at the object level</h2>&#13;
			<p>Quite often, the validation of one field is dependent on another—for example, when checking wh<a id="_idTextAnchor248"/>ether <a id="_idIndexMarker365"/>a password confirmation matches the password or enforcing a field to be required in certain circumstances. To allow this kind of validation, we need to access the whole object data. To do this, Pydantic provides the <strong class="source-inline">root_validator</strong> decorator, which is illustrated in the following <span class="No-Break">code example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_custom_validation_02.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModel, EmailStr, ValidationError, root_validatorclass UserRegistration(BaseModel):&#13;
    email: EmailStr&#13;
    password: str&#13;
    password_confirmation: str&#13;
    @root_validator()&#13;
    def passwords_match(cls, values):&#13;
        password = values.get("password")&#13;
        password_confirmation = values.get("password_confirmation")&#13;
        if password != password_confirmation:&#13;
            raise ValueError("Passwords don't match")&#13;
        return values</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04<span id="_idTextAnchor249"/>_custom_validation_02.py</a></p>&#13;
			<p>The usage of this decorator is similar to the <strong class="source-inline">validator</strong> decorator. The static class method is called <a id="_idIndexMarker366"/>along with the <strong class="source-inline">values<a id="_idTextAnchor250"/></strong> argument, which is a <em class="italic">dictionary</em> containing all the fields. Thus, you can retrieve each of them and implement <span class="No-Break">your logic.</span></p>&#13;
			<p>Once again, Pydantic expects two things for this method, <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>If the values <a id="_idIndexMarker367"/>are not valid according to your logic, you should raise a <strong class="source-inline">ValueError</strong> error with an explicit <span class="No-Break">error message.</span></li>&#13;
				<li>Otherwise, you should return a <strong class="source-inline">values</strong> dictionary that will be assigned to the model. Notice that you can change some <a id="_idTextAnchor251"/>values in this dictionary to fit <span class="No-Break">your needs.</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-77">Applying validat<a id="_idTextAnchor252"/>ion before Pydantic parsing</h2>&#13;
			<p>By default<a id="_idTextAnchor253"/>, your validators are run after Pydantic has done its parsing work. This means that the value <a id="_idIndexMarker368"/>you get already conforms to the type of field you specified. If the type is incorrect, Pydantic raises an error without calling <span class="No-Break">your validator.</span></p>&#13;
			<p>However, you may sometimes wish to provide some custom parsing logic that allows you to transform input values that would have been incorrect for the type you set. In that case, you would need to run your validator before the Pydantic parser: this is the purpose of the <strong class="source-inline">pre</strong> argume<a id="_idTextAnchor254"/>nt <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">validator</strong></span><span class="No-Break">.</span></p>&#13;
			<p>In the <a id="_idTextAnchor255"/>following example, we show how to transform a string with values separated by commas into <span class="No-Break">a list:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_custom_validation_03.py</p>&#13;
			<pre class="source-code">&#13;
from pydantic import BaseModel, validatorclass Model(BaseModel):&#13;
    values: list[int]&#13;
    @validator("values", pre=True)&#13;
    def split_string_values(cls, v):&#13;
        if isinstance(v, str):&#13;
            return v.split(",")&#13;
        return v&#13;
m = Model(values="1,2,3")&#13;
print(m.values)  # [1, 2, 3]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py</a></p>&#13;
			<p>You can see here that our validator first checks whether we have a s<a id="_idTextAnchor256"/>tring. If we do, we split the <a id="_idIndexMarker369"/>comma-separated strin<a id="_idTextAnchor257"/>g and return the resulting list; otherwise, we directly return the value. Pydantic will run its parsing logic afterward, so you can still be sure that an <a id="_idTextAnchor258"/>error will be raised if <strong class="source-inline">v</strong> is an <span class="No-Break">inv<a id="_idTextAnchor259"/>alid value.</span></p>&#13;
			<h1 id="_idParaDest-78"><a id="_idTextAnchor260"/>Working with Pydantic objects</h1>&#13;
			<p>When<a id="_idTextAnchor261"/> developing API endpoints with FastAPI, you’ll probably get a lot of Pydantic model instances to <a id="_idIndexMarker370"/>handle. It’s then up to you to implement the logic to make a link between those objects and your services, such as your database or your machine learning model. Fortunately, Pydantic provides methods that make this very easy. We’ll review common use cases <a id="_idTextAnchor262"/>that will be useful for you <span class="No-Break">during development.</span></p>&#13;
			<h2 id="_idParaDest-79">Converti<a id="_idTextAnchor263"/>ng an object into a dictionary</h2>&#13;
			<p>This is <a id="_idIndexMarker371"/>probably the action you’ll perform the <a id="_idIndexMarker372"/>most on a Pydantic object: convert it into a raw dictionary t<a id="_idTextAnchor264"/>hat’ll be easy to send to another API or use in a database, for example. You just have to call the <strong class="source-inline">dict</strong> method on the <span class="No-Break">object instance.</span></p>&#13;
			<p>The following example reuses the <strong class="source-inline">Person</strong> and <strong class="source-inline">Address</strong> models we saw in the <em class="italic">Standard field types</em> section of <span class="No-Break">this chapter:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_01.py</p>&#13;
			<pre class="source-code">&#13;
person = Person(    first_name="John",&#13;
    last_name="Doe",&#13;
    gender=Gender.MALE,&#13;
    birthdate="1991-01-01",&#13;
    interests=["travel", "sports"],&#13;
    address={&#13;
        "street_address": "12 Squirell Street",&#13;
        "postal_code": "424242",&#13;
        "city": "Woodtown",&#13;
        "country": "US",&#13;
    },&#13;
)&#13;
person_dict = person.dict()&#13;
print(person_dict["first_name"])  # "John"&#13;
print(person_dict["address"]["street_address"])  # "12 Squirell Street"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_object<span id="_idTextAnchor265"/>s_01.py</a></p>&#13;
			<p>As you can see, calling <a id="_idTextAnchor266"/><strong class="source-inline">dict</strong> is enough to transform the whole data into a dictionary. Sub-objects are also recursively converted: the <strong class="source-inline">address</strong> key points to a dictionary with the <span class="No-Break">address properties.</span></p>&#13;
			<p>Interestingly, the <strong class="source-inline">dict</strong> method supports some arguments, allowing you to select a subset of <a id="_idIndexMarker373"/>properties to be converted. You can either <a id="_idIndexMarker374"/>state the ones you want to be included or the ones you want to exclude, as you can see in the <span class="No-Break">following snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_02.py</p>&#13;
			<pre class="source-code">&#13;
person_include = person.dict(include={"first_name", "last_name"})print(person_include)  # {"first_name": "John", "last_name": "Doe"}&#13;
person_exclude = person.dict(exclude={"birthdate", "interests"})&#13;
print(person_exclude)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py</a></p>&#13;
			<p>The <strong class="source-inline">include</strong> and <strong class="source-inline">exclude</strong> arguments expect a set with the keys of th<a id="_idTextAnchor267"/>e fields you want to include <span class="No-Break">or exclude.</span></p>&#13;
			<p>For ne<a id="_idTextAnchor268"/>sted <a id="_idIndexMarker375"/>structures such as <strong class="source-inline">address</strong>, you can <a id="_idIndexMarker376"/>also use a dictionary to specify which sub-field you want to include or exclude, as illustrated in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_02.py</p>&#13;
			<pre class="source-code">&#13;
person_nested_include = person.dict(    include={&#13;
        "first_name": ...,&#13;
        "last_name": ...,&#13;
        "address": {"city", "country"},&#13;
    }&#13;
)&#13;
# {"first_name": "John", "last_name": "Doe", "address": {"city": "Woodtown", "country": "US"}}&#13;
print(person_nested_include)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py</a></p>&#13;
			<p>The resulting <strong class="source-inline">address</strong> dictionary only contains the city and the country. Notice that when using this syntax, scalar fields such as <strong class="source-inline">first_name</strong> and <strong class="source-inline">last_name</strong> have to be associated with the <span class="No-Break">ellipsis, </span><span class="No-Break"><strong class="source-inline">...</strong></span><span class="No-Break">.</span></p>&#13;
			<p>If you use a <a id="_idIndexMarker377"/>conversion quite often, it can be useful <a id="_idIndexMarker378"/>to <a id="_idTextAnchor269"/>put it in a method so that yo<a id="_idTextAnchor270"/>u can reuse it at will, as illustrated in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_03.py</p>&#13;
			<pre class="source-code">&#13;
class Person(BaseModel):    first_name: str&#13;
    last_name: str&#13;
    gender: Gender&#13;
    birthdate: date&#13;
    interests: list[str]&#13;
    address: Address&#13;
    def name_dict(self):&#13;
        return self.dict(include={"first_name", "last_name"})</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/<span id="_idTextAnchor271"/>main/chapter04/chapter04_working_pydantic_objects_03.py</a></p>&#13;
			<h2 id="_idParaDest-80"><a id="_idTextAnchor272"/>Creating an instance from a sub-class object</h2>&#13;
			<p>In the <em class="italic">Creating model variations with clas<a id="_idTextAnchor273"/>s inheritance</em> section, we studi<a id="_idTextAnchor274"/>ed the common <a id="_idIndexMarker379"/>pattern of having specific model classes, depending on the situation. In particular, you’ll have a model dedicated to the creation endpoint, with only the required fields for creation, and a database model with all the fields we want <span class="No-Break">to store.</span></p>&#13;
			<p>Let’s look at the <strong class="source-inline">Post</strong> <span class="No-Break">example again:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_04.py</p>&#13;
			<pre class="source-code">&#13;
class PostBase(BaseModel):    title: str&#13;
    content: str&#13;
class PostCreate(PostBase):&#13;
    pass&#13;
class PostRead(PostBase):&#13;
    id: int&#13;
class Post(PostBase):&#13;
    id: int&#13;
    nb_views: int = 0</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py</a></p>&#13;
			<p>Suppose we have an API that creates endpoints. In this context, we would get a <strong class="source-inline">PostCreate</strong> instance with only <strong class="source-inline">title</strong> and <strong class="source-inline">content</strong>. However, we need to build a proper <strong class="source-inline">Post</strong> instance before storing it in <span class="No-Break">the database.</span></p>&#13;
			<p>A convenient <a id="_idIndexMarker380"/>way to do this is to jointly use the <strong class="source-inline">dict</strong> method and the unpacking syntax. In the following example, we implemented a creation endpoint using <span class="No-Break">this approach:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_04.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/posts", status_code=status.HTTP_201_CREATED, response_model=PostRead)async def create(post_create: PostCreate):&#13;
    new_id = max(db.posts.keys() or (0,)) + 1&#13;
    post = Post(id=new_id, **post_create.dict())&#13;
    db.posts[new_id] = post&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py</a></p>&#13;
			<p>As you can see, the path operation function gives us a valid <strong class="source-inline">PostCreate</strong> object. Then, we wa<a id="_idTextAnchor275"/>nt to transform it into a <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> object.</span></p>&#13;
			<p>W<a id="_idTextAnchor276"/>e first determine the missing <strong class="source-inline">id</strong> property, which is given to us by the database. Here, we use a dummy database based on a dictionary, so we simply take the highest key that’s already present in the database and increment it. In a real-world situation, this would have been automatically determined by <span class="No-Break">the database.</span></p>&#13;
			<p>The most interesting line here is the <strong class="source-inline">Post</strong> instantiation. You can see that we first assign the missing <a id="_idIndexMarker381"/>fields using keyword arguments and then unpack the dictionary representation of <strong class="source-inline">post_create</strong>. As a reminder, the effect of <strong class="source-inline">**</strong> in a function call is to transform a dictionary such as <strong class="source-inline">{"title": "Foo", "content": "Bar"}</strong> into keyword arguments such as this: <strong class="source-inline">title="Foo", content="Bar"</strong>. It’s a very convenient and dynamic approach to set all the fields we already have into our <span class="No-Break">new model.</span></p>&#13;
			<p>Notice that we also set the <strong class="source-inline">response_model</strong> argument on the path operation decorator. We explained this in <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI</em>, but b<a id="_idTextAnchor277"/>asically, it prompts FastAPI to build a JSON response with only the fields of <strong class="source-inline">PostRead</strong>, even th<a id="_idTextAnchor278"/>ough we return a <strong class="source-inline">Post</strong> instance at the end of <span class="No-Break">the function.</span><a id="_idTextAnchor279"/></p>&#13;
			<h2 id="_idParaDest-81"><a id="_idTextAnchor280"/>Updating an instance partially</h2>&#13;
			<p>In some <a id="_idIndexMarker382"/>situations, you’ll want to allow partial updates. In other words, you’ll allow the end user to only send the fields they want to change to your API and omit the ones that shouldn’t change. This is the usual way of implementing a <span class="No-Break"><strong class="source-inline">PATCH</strong></span><span class="No-Break"> endpoint.</span></p>&#13;
			<p>To do this, you would first need a special Pydantic model with all the fields marked as optional so that no error is raised when a field is missing. Let’s see what this looks like with our <strong class="source-inline">Post</strong> example, <span class="No-Break">as follows:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_05.py</p>&#13;
			<pre class="source-code">&#13;
class PostBase(BaseModel):    title: str&#13;
    content: str&#13;
class PostPartialUpdate(BaseModel):&#13;
    title: str | None = None&#13;
    content: str | None = None</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/<span id="_idTextAnchor281"/>chapter04_working_pydantic_objects_05.py</a></p>&#13;
			<p>We are now able to implement an endpoint that will accept a subset of our <strong class="source-inline">Post</strong> fields. Since it’s an update, we’ll retrieve an existing post in the database thanks to its ID. Then, we’ll have to find <a id="_idIndexMarker383"/>a way to only update the fields in the payload and keep the others untouched. Fortunately, Pydantic once again has this covered, with handy methods <span class="No-Break">and options.</span></p>&#13;
			<p>Let’s see how the implementation of such an endpoint could look in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter04_working_pydantic_objects_05.py</p>&#13;
			<pre class="source-code">&#13;
@app.patch("/posts/{id}", response_model=PostRead)async def partial_update(id: int, post_update: PostPartialUpdate):&#13;
    try:&#13;
        post_db = db.posts[id]&#13;
        updated_fields = post_update.dict(exclude_unset=True)&#13;
        updated_post = post_db.copy(update=updated_fields)&#13;
        db.posts[id] = updated_post&#13;
        return updated_post&#13;
    except KeyError:&#13;
        raise HTTPException(status.HTTP_404_NOT_FOUND)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py</a></p>&#13;
			<p>Our path operation function takes two arguments: the <strong class="source-inline">id</strong> property (from the path) and a <strong class="source-inline">PostPartial<a id="_idTextAnchor282"/>Update</strong> instance (from <span class="No-Break">the body).</span></p>&#13;
			<p>The first thing to do is to check whether this <strong class="source-inline">id</strong> property exists in the database. Since we use a dictionary for our dummy database, accessing a key that doesn’t exist will raise a <strong class="source-inline">KeyError</strong>. If this happens, we simply raise an <strong class="source-inline">HTTPException</strong> with the <strong class="source-inline">404</strong> <span class="No-Break">status code.</span></p>&#13;
			<p>Now for the interesting part: updating an existing object. You can see that the first thing to do is transform <strong class="source-inline">PostPartialUpdate</strong> into a dictionary with the <strong class="source-inline">dict</strong> method. This time, however, we set the <strong class="source-inline">exclude_unset</strong> argument to <strong class="source-inline">True</strong>. The effect of this is that <em class="italic">Pydantic won’t output the fields that were not provided</em> in the resulting dictionary: we only get the fields that the user sent in <span class="No-Break">the payload.</span></p>&#13;
			<p>Then, on our existing <strong class="source-inline">post_db</strong> database instance, we call the <strong class="source-inline">copy</strong> method. This is a useful method for cloning a Pydantic object into another instance. The nice thing about this method is <a id="_idIndexMarker384"/>that it even accepts an <strong class="source-inline">update</strong> argument. This argument expects a dictionary with all the fields that should be updated during the copy: that’s exactly what we want to do with our <span class="No-Break"><strong class="source-inline">updated_fields</strong></span><span class="No-Break"> dictionary!</span></p>&#13;
			<p>And that’s it! We now have an updated <strong class="source-inline">post</strong> instance with only the changes required in the payload. You’ll probably use the <strong class="source-inline">exclude_unset</strong> argument and the <strong class="source-inline">copy</strong> method quite often while developing with FastAPI, so <a id="_idTextAnchor283"/>be sure to keep them in mind — they’ll make your <span class="No-Break">life easier!</span></p>&#13;
			<h1 id="_idParaDest-82"><a id="_idTextAnchor284"/>Summary</h1>&#13;
			<p>Congratulations! You’ve learned about another important aspect of FastAPI: designing and managing data models with Pydantic. You should now be confident about creating models and applying validation at the field level, with built-in options and types, and also by implementing your own validation methods. You also know how to apply validation at the object level to check consistency between several fields. You also learned how to leverage model inheritance to prevent code duplication and repetition while defining your model variations. Finally, you learned how to correctly work with Pydantic model instances in order to transform and update them in an efficient and <span class="No-Break">readable way.</span></p>&#13;
			<p>You know almost all the features of FastAPI by now. There is one last very powerful feature for you to learn about: <strong class="bold">dependency injection</strong>. This allows you to define your own logic and values and directly inject them into your path operation functions, as you do for path parameters and payload objects, which you’ll be able to reuse everywhere in your project. That’s the subject of the <span class="No-Break">next chapter.</span></p>&#13;
		</div>&#13;
	</div></body></html>