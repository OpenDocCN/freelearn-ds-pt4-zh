["```py\n\nfrom pydantic import BaseModelclass Person(BaseModel):\n    first_name: str\n    last_name: str\n    age: int\n```", "```py\n\nfrom datetime import datefrom enum import Enum\nfrom pydantic import BaseModel, ValidationError\nclass Gender(str, Enum):\n    MALE = \"MALE\"\n    FEMALE = \"FEMALE\"\n    NON_BINARY = \"NON_BINARY\"\nclass Person(BaseModel):\n    first_name: str\n    last_name: str\n    gender: Gender\n    birthdate: date\n    interests: list[str]\n```", "```py\n\n# Invalid gendertry:\n    Person(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        gender=\"INVALID_VALUE\",\n        birthdate=\"1991-01-01\",\n        interests=[\"travel\", \"sports\"],\n    )\nexcept ValidationError as e:\n    print(str(e))\n```", "```py\n\n1 validation error for Persongender\n  value is not a valid enumeration member; permitted: 'MALE', 'FEMALE', 'NON_BINARY' (type=type_error.enum; enum_values=[<Gender.MALE: 'MALE'>, <Gender.FEMALE: 'FEMALE'>, <Gender.NON_BINARY: 'NON_BINARY'>])\n```", "```py\n\n# Invalid birthdatetry:\n    Person(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        gender=Gender.MALE,\n        birthdate=\"1991-13-42\",\n        interests=[\"travel\", \"sports\"],\n    )\nexcept ValidationError as e:\n    print(str(e))\n```", "```py\n\n1 validation error for Personbirthdate\n  invalid date format (type=value_error.date)\n```", "```py\n\n# Validperson = Person(\n    first_name=\"John\",\n    last_name=\"Doe\",\n    gender=Gender.MALE,\n    birthdate=\"1991-01-01\",\n    interests=[\"travel\", \"sports\"],\n)\n# first_name='John' last_name='Doe' gender=<Gender.MALE: 'MALE'> birthdate=datetime.date(1991, 1, 1) interests=['travel', 'sports']\nprint(person)\n```", "```py\n\nclass Address(BaseModel):    street_address: str\n    postal_code: str\n    city: str\n    country: str\nclass Person(BaseModel):\n    first_name: str\n    last_name: str\n    gender: Gender\n    birthdate: date\n    interests: list[str]\n    address: Address\n```", "```py\n\n# Invalid addresstry:\n    Person(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        gender=Gender.MALE,\n        birthdate=\"1991-01-01\",\n        interests=[\"travel\", \"sports\"],\n        address={\n            \"street_address\": \"12 Squirell Street\",\n            \"postal_code\": \"424242\",\n            \"city\": \"Woodtown\",\n            # Missing country\n        },\n    )\nexcept ValidationError as e:\n    print(str(e))\n```", "```py\n\n1 validation error for Personaddress -> country\n  field required (type=value_error.missing)\n```", "```py\n\n# Validperson = Person(\n    first_name=\"John\",\n    last_name=\"Doe\",\n    gender=Gender.MALE,\n    birthdate=\"1991-01-01\",\n    interests=[\"travel\", \"sports\"],\n    address={\n        \"street_address\": \"12 Squirell Street\",\n        \"postal_code\": \"424242\",\n        \"city\": \"Woodtown\",\n        \"country\": \"US\",\n    },\n)\nprint(person)\n```", "```py\n\nfrom pydantic import BaseModelclass UserProfile(BaseModel):\n    nickname: str\n    location: str | None = None\n    subscribed_newsletter: bool = True\n```", "```py\n\nclass Model(BaseModel):    # Don't do this.\n    # This example shows you why it doesn't work.\n    d: datetime = datetime.now()\no1 = Model()\nprint(o1.d)\ntime.sleep(1)  # Wait for a second\no2 = Model()\nprint(o2.d)\nprint(o1.d < o2.d)  # False\n```", "```py\n\nfrom pydantic import BaseModel, Field, ValidationErrorclass Person(BaseModel):\n    first_name: str = Field(..., min_length=3)\n    last_name: str = Field(..., min_length=3)\n    age: int | None = Field(None, ge=0, le=120)\n```", "```py\n\nfrom datetime import datetimefrom pydantic import BaseModel, Field\ndef list_factory():\n    return [\"a\", \"b\", \"c\"]\nclass Model(BaseModel):\n    l: list[str] = Field(default_factory=list_factory)\n    d: datetime = Field(default_factory=datetime.now)\n    l2: list[str] = Field(default_factory=list)\n```", "```py\n\n(venv)$ pip install email-validator\n```", "```py\n\nfrom pydantic import BaseModel, EmailStr, HttpUrl, ValidationErrorclass User(BaseModel):\n    email: EmailStr\n    website: HttpUrl\n```", "```py\n\n# Invalid emailtry:\n    User(email=\"jdoe\", website=\"https://www.example.com\")\nexcept ValidationError as e:\n    print(str(e))\n```", "```py\n\n1 validation error for Useremail\n  value is not a valid email address (type=value_error.email)\n```", "```py\n\n# Invalid URLtry:\n    User(email=\"jdoe@example.com\", website=\"jdoe\")\nexcept ValidationError as e:\n    print(str(e))\n```", "```py\n\n1 validation error for Userwebsite\n  invalid or missing URL scheme (type=value_error.url.scheme)\n```", "```py\n\n# Validuser = User(email=\"jdoe@example.com\", website=\"https://www.example.com\")\n# email='jdoe@example.com' website=HttpUrl('https://www.example.com', scheme='https', host='www.example.com', tld='com', host_type='domain')\nprint(user)\n```", "```py\n\nfrom pydantic import BaseModelclass PostCreate(BaseModel):\n    title: str\n    content: str\nclass PostRead(BaseModel):\n    id: int\n    title: str\n    content: str\nclass Post(BaseModel):\n    id: int\n    title: str\n    content: str\n    nb_views: int = 0\n```", "```py\n\nfrom pydantic import BaseModelclass PostBase(BaseModel):\n    title: str\n    content: str\nclass PostCreate(PostBase):\n    pass\nclass PostRead(PostBase):\n    id: int\nclass Post(PostBase):\n    id: int\n    nb_views: int = 0\n```", "```py\n\nclass PostBase(BaseModel):    title: str\n    content: str\n    def excerpt(self) -> str:\n        return f\"{self.content[:140]}...\"\n```", "```py\n\nfrom datetime import datefrom pydantic import BaseModel, ValidationError, validator\nclass Person(BaseModel):\n    first_name: str\n    last_name: str\n    birthdate: date\n    @validator(\"birthdate\")\n    def valid_birthdate(cls, v: date):\n        delta = date.today() - v\n        age = delta.days / 365\n        if age > 120:\n            raise ValueError(\"You seem a bit too old!\")\n        return v\n```", "```py\n\nfrom pydantic import BaseModel, EmailStr, ValidationError, root_validatorclass UserRegistration(BaseModel):\n    email: EmailStr\n    password: str\n    password_confirmation: str\n    @root_validator()\n    def passwords_match(cls, values):\n        password = values.get(\"password\")\n        password_confirmation = values.get(\"password_confirmation\")\n        if password != password_confirmation:\n            raise ValueError(\"Passwords don't match\")\n        return values\n```", "```py\n\nfrom pydantic import BaseModel, validatorclass Model(BaseModel):\n    values: list[int]\n    @validator(\"values\", pre=True)\n    def split_string_values(cls, v):\n        if isinstance(v, str):\n            return v.split(\",\")\n        return v\nm = Model(values=\"1,2,3\")\nprint(m.values)  # [1, 2, 3]\n```", "```py\n\nperson = Person(    first_name=\"John\",\n    last_name=\"Doe\",\n    gender=Gender.MALE,\n    birthdate=\"1991-01-01\",\n    interests=[\"travel\", \"sports\"],\n    address={\n        \"street_address\": \"12 Squirell Street\",\n        \"postal_code\": \"424242\",\n        \"city\": \"Woodtown\",\n        \"country\": \"US\",\n    },\n)\nperson_dict = person.dict()\nprint(person_dict[\"first_name\"])  # \"John\"\nprint(person_dict[\"address\"][\"street_address\"])  # \"12 Squirell Street\"\n```", "```py\n\nperson_include = person.dict(include={\"first_name\", \"last_name\"})print(person_include)  # {\"first_name\": \"John\", \"last_name\": \"Doe\"}\nperson_exclude = person.dict(exclude={\"birthdate\", \"interests\"})\nprint(person_exclude)\n```", "```py\n\nperson_nested_include = person.dict(    include={\n        \"first_name\": ...,\n        \"last_name\": ...,\n        \"address\": {\"city\", \"country\"},\n    }\n)\n# {\"first_name\": \"John\", \"last_name\": \"Doe\", \"address\": {\"city\": \"Woodtown\", \"country\": \"US\"}}\nprint(person_nested_include)\n```", "```py\n\nclass Person(BaseModel):    first_name: str\n    last_name: str\n    gender: Gender\n    birthdate: date\n    interests: list[str]\n    address: Address\n    def name_dict(self):\n        return self.dict(include={\"first_name\", \"last_name\"})\n```", "```py\n\nclass PostBase(BaseModel):    title: str\n    content: str\nclass PostCreate(PostBase):\n    pass\nclass PostRead(PostBase):\n    id: int\nclass Post(PostBase):\n    id: int\n    nb_views: int = 0\n```", "```py\n\n@app.post(\"/posts\", status_code=status.HTTP_201_CREATED, response_model=PostRead)async def create(post_create: PostCreate):\n    new_id = max(db.posts.keys() or (0,)) + 1\n    post = Post(id=new_id, **post_create.dict())\n    db.posts[new_id] = post\n    return post\n```", "```py\n\nclass PostBase(BaseModel):    title: str\n    content: str\nclass PostPartialUpdate(BaseModel):\n    title: str | None = None\n    content: str | None = None\n```", "```py\n\n@app.patch(\"/posts/{id}\", response_model=PostRead)async def partial_update(id: int, post_update: PostPartialUpdate):\n    try:\n        post_db = db.posts[id]\n        updated_fields = post_update.dict(exclude_unset=True)\n        updated_post = post_db.copy(update=updated_fields)\n        db.posts[id] = updated_post\n        return updated_post\n    except KeyError:\n        raise HTTPException(status.HTTP_404_NOT_FOUND)\n```"]