- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Pydantic Data Models in FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover in detail the definition of a data model with Pydantic,
    the underlying data validation library used by FastAPI. We’ll explain how to implement
    variations of the same model without repeating the same code again and again,
    thanks to class inheritance. Finally, we’ll show how to implement custom data
    validation logic into Pydantic models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining models and their field types with Pydantic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating model variations with class inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom data validation with Pydantic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Pydantic objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code examples, you’ll need a Python virtual environment, which we
    set up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development*
    *Environment Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find all the code examples for this chapter in the dedicated GitHub repository
    at [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Defining models and their field types with Pydantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pydantic is a powerful library for defining data models using Python classes
    and type hints. This approach makes those classes completely compatible with static
    type checking. Besides, since there are regular Python classes, we can use inheritance
    and also define our very own methods to add custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, you learned the basics of defining a data model with Pydantic:
    you have to define a class inheriting from `BaseModel` and list all the fields
    as class properties, each one with a type hint to enforce their type.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll focus on model definition and see all the possibilities
    we have for defining the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Standard field types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll begin by defining fields with standard types, which only involve simple
    type hints. Let’s review a simple model representing information about a person.
    You can see this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said, you just have to write the names of the fields and type-hint them
    with the intended type. Of course, we are not limited to scalar types: we can
    use compound types, such as lists and tuples, or classes such as datetime and
    enum. In the following example, you can see a model using those more complex types:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: There are three things to notice in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we used the standard Python `Enum` class as a type for the `gender`
    field. This allows us to specify a set of valid values. If we input a value that’s
    not in this enumeration, Pydantic will raise an error, as illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding example, you’ll get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Actually, this is exactly what we did in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058),
    *Developing a RESTful API with FastAPI*, to limit the allowed values of the `path`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we used the `date` Python class as a type for the `birthdate` field.
    Pydantic is able to automatically parse dates and times given as ISO format strings
    or timestamp integers and instantiate a proper `date` or `datetime` object. Of
    course, if the parsing fails, you’ll also get an error. You can experiment with
    this in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we defined `interests` as a list of strings. Once again, Pydantic will
    check whether the field is a valid list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, if everything is okay, we get a `Person` instance and have access
    to the properly parsed fields. This is what we show in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this is quite powerful, and we can have quite complex field
    types. But that’s not all: *fields can be Pydantic models themselves*, allowing
    you to have sub-objects! In the following code example, we expand the previous
    snippet to add an `address` field:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_03.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
  prefs: []
  type: TYPE_NORMAL
- en: We just have to define another Pydantic model and use it as a type hint. Now,
    you can either instantiate a `Person` instance with an already valid `Address`
    instance or, even better, with a dictionary. In this case, Pydantic will automatically
    parse it and validate it against the address model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we try to input an invalid address:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_03.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate the following validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Pydantic clearly shows the missing field in the sub-object. Once again, if
    everything goes well, we get a `Person` instance and its associated `Address`,
    as you can see in the following extract:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_standard_field_types_03.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Optional fields and default values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now, we’ve assumed that each field had to be provided when instantiating
    the model. Quite often, however, there are values that we want to be optional
    because they may not be relevant to each object instance. Sometimes, we also wish
    to set a default value for a field when it’s not specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, this is done quite simply, with the `| None` typing
    annotation, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_optional_fields_default_values_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: When defining a field with the `| None` type hint, it accepts a `None` value.
    As you can see in the preceding code, the default value can be simply assigned
    by putting the value after an equals sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, though: *don’t assign default values such as this for dynamic types*
    such as datetimes. If you do, the datetime instantiation will be evaluated only
    once when the model is imported. The effect of this is that all the objects you
    instantiate will then share the same value instead of having a fresh value. You
    can observe this behavior in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_optional_fields_default_values_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we waited for 1 second between the instantiation of `o1` and `o2`,
    the `d` datetime is the same! This means that the datetime is evaluated only once
    when the class is imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have the same kind of problem if you want to have a default list, such
    as `l: list[str] = ["a", "b", "c"]`. Notice that this is true for every Python
    object, not only Pydantic models, so you should bear this in mind.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we assign dynamic default values? Fortunately, Pydantic provides
    a `Field` function that allows us to set some advanced options on our fields,
    including one to set a factory for creating dynamic values. Before showing you
    this, we’ll first introduce the `Field` function.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, we showed how to apply some validation to the request parameters
    to check whether a number was in a certain range or whether a string matched a
    regular expression. Actually, these options directly come from Pydantic! We can
    use the same techniques to apply validation to the fields of a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we’ll use the `Field` function from Pydantic and use its result
    as the default value of the field. In the following example, we define a `Person`
    model with the `first_name` and `last_name` required properties, which should
    be at least three characters long, and an optional `age` property, which should
    be an integer between `0` and `120`. We show the implementation of this model
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_fields_validation_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the syntax is very similar to the one we saw for `Path`, `Query`,
    and `Body`. The first positional argument defines the *default value* for the
    field. If the field is required, we use an ellipsis, `...`. Then, the keyword
    arguments are there to set options for the field, including some basic validation.
  prefs: []
  type: TYPE_NORMAL
- en: You can view a complete list of the arguments accepted by `Field` in the official
    Pydantic documentation, at [https://pydantic-docs.helpmanual.io/usage/schema/#field-customization](https://pydantic-docs.helpmanual.io/usage/schema/#field-customization).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we warned you about setting dynamic values as defaults.
    Fortunately, Pydantic provides the `default_factory` argument on the `Field` function
    to cover this use case. This argument expects you to pass a function that will
    be called during model instantiation. Thus, the resulting object will be evaluated
    at runtime each time you create a new object. You can see how to use it in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_fields_validation_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You simply have to pass a function to this argument. Don’t put arguments on
    it: it’ll be Pydantic that will automatically call the function for you when instantiating
    a new object. If you need to call a function with specific arguments, you’ll have
    to wrap it into your own function, as we did for `list_factory`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that the first positional argument used for the default value (such
    as `None` or `...`) is completely omitted here. This makes sense: it’s not consistent
    to have both a default value and a factory. Pydantic will raise an error if you
    set those two arguments together.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating email addresses and URLs with Pydantic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For convenience, Pydantic provides some classes to use as field types to validate
    some common patterns, such as email addresses or URLs.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we’ll use `EmailStr` and `HttpUrl` to validate an
    email address and an HTTP URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `EmailStr` to work, you’ll need an optional dependency, `email-validator`,
    which you can install with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Those classes work like any other type or class: just use them as a type hint
    for your field. You can see this in the following extract:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_pydantic_types_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we check that the email address is correctly validated:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_pydantic_types_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also check that the URL is correctly parsed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_pydantic_types_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a look at a valid example, shown next, you’ll see that the URL
    is parsed into an object, giving you access to the different parts of it, such
    as the scheme or hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_pydantic_types_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic provides quite a big set of types that can help you in various situations.
    We invite you to review the full list of them in the official documentation at
    [https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types](https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types).
  prefs: []
  type: TYPE_NORMAL
- en: You now have a better idea of how to define your Pydantic models finely by using
    more advanced types or leveraging the validation features. As we said, those models
    are at the heart of FastAPI, and you’ll probably have to define several variations
    for the same entity to account for several situations. In the next section, we’ll
    show how to do that with minimum repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating model variations with class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, we saw a case where we needed to define two variations of a Pydantic
    model in order to split the data we want to store in the backend and the data
    we want to show to the user. This is a common pattern in FastAPI: you define one
    model for creation, one for the response, and one for the data to store in the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We show this basic approach in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_model_inheritance_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three models here, covering three situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostCreate` will be used for a `POST` endpoint to create a new post. We expect
    the user to give the title and the content; however, the **identifier** (**ID**)
    will be automatically determined by the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostRead` will be used when we retrieve the data of a post. We want its title
    and content, of course, but also its associated ID in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Post` will carry all the data we wish to store in the database. Here, we also
    want to store the number of views, but we want to keep this secret to make our
    own statistics internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see here that we are repeating ourselves quite a lot, especially with
    the `title` and `content` fields. In bigger examples with lots of fields and lots
    of validation options, this could quickly become unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to avoid this is to leverage model inheritance. The approach is simple:
    identify the fields that are common to every variation and put them in a model,
    which will be used as a base for every other. Then, you only have to inherit from
    that model to create your variations and add the specific fields. In the following
    example, we see what our previous example looks like with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_model_inheritance_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever you need to add a field for the whole entity, all you have to
    do is to add it to the `PostBase` model as shown in the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also very convenient if you wish to define methods on your model. Remember
    that Pydantic models are regular Python classes, so you can implement as many
    methods as you wish!
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_model_inheritance_03.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the `excerpt` method on `PostBase` means it’ll be available in every
    model variation.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s not strictly required, this inheritance approach greatly helps to
    prevent code duplication and, ultimately, bugs. We’ll see in the next section
    that it’ll make even more sense with custom validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom data validation with Pydantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we’ve seen how to apply basic validation to our models through `Field`
    arguments or the custom types provided by Pydantic. In a real-world project, though,
    you’ll probably need to add your own custom validation logic for your specific
    case. Pydantic allows this by defining **validators**, which are methods on the
    model that can be applied at the field level or the object level.
  prefs: []
  type: TYPE_NORMAL
- en: Applying validation at the field level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most common case: having a validation rule for a single field.
    To define a validation rule in Pydantic, we just have to write a static method
    on our model and decorate it with the `validator` decorator. As a reminder, decorators
    are syntactic sugar, allowing the wrapping of a function or a class with common
    logic without compromising readability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example checks a birth date by verifying that the person is not
    more than 120 years old:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_custom_validation_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `validator` is a static class method (the first argument, `cls`,
    is the class itself), with the `v` argument being the value to validate. It’s
    decorated by the `validator` decorator, which expects the name of the argument
    to validate to be its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pydantic expects two things for this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value is not valid according to your logic, you should raise a `ValueError`
    error with an explicit error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, you should return the value that will be assigned to the model.
    Notice that it doesn’t need to be the same as the input value: you can easily
    change it to fit your needs. That’s actually what we’ll do in an upcoming section,
    *Applying validation before* *Pydantic parsing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying validation at the object level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite often, the validation of one field is dependent on another—for example,
    when checking whether a password confirmation matches the password or enforcing
    a field to be required in certain circumstances. To allow this kind of validation,
    we need to access the whole object data. To do this, Pydantic provides the `root_validator`
    decorator, which is illustrated in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_custom_validation_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The usage of this decorator is similar to the `validator` decorator. The static
    class method is called along with the `values` argument, which is a *dictionary*
    containing all the fields. Thus, you can retrieve each of them and implement your
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, Pydantic expects two things for this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the values are not valid according to your logic, you should raise a `ValueError`
    error with an explicit error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, you should return a `values` dictionary that will be assigned to
    the model. Notice that you can change some values in this dictionary to fit your
    needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying validation before Pydantic parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, your validators are run after Pydantic has done its parsing work.
    This means that the value you get already conforms to the type of field you specified.
    If the type is incorrect, Pydantic raises an error without calling your validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you may sometimes wish to provide some custom parsing logic that allows
    you to transform input values that would have been incorrect for the type you
    set. In that case, you would need to run your validator before the Pydantic parser:
    this is the purpose of the `pre` argument on `validator`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we show how to transform a string with values separated
    by commas into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_custom_validation_03.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py)'
  prefs: []
  type: TYPE_NORMAL
- en: You can see here that our validator first checks whether we have a string. If
    we do, we split the comma-separated string and return the resulting list; otherwise,
    we directly return the value. Pydantic will run its parsing logic afterward, so
    you can still be sure that an error will be raised if `v` is an invalid value.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Pydantic objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing API endpoints with FastAPI, you’ll probably get a lot of Pydantic
    model instances to handle. It’s then up to you to implement the logic to make
    a link between those objects and your services, such as your database or your
    machine learning model. Fortunately, Pydantic provides methods that make this
    very easy. We’ll review common use cases that will be useful for you during development.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an object into a dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is probably the action you’ll perform the most on a Pydantic object: convert
    it into a raw dictionary that’ll be easy to send to another API or use in a database,
    for example. You just have to call the `dict` method on the object instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example reuses the `Person` and `Address` models we saw in the
    *Standard field types* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_01.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, calling `dict` is enough to transform the whole data into a
    dictionary. Sub-objects are also recursively converted: the `address` key points
    to a dictionary with the address properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the `dict` method supports some arguments, allowing you to select
    a subset of properties to be converted. You can either state the ones you want
    to be included or the ones you want to exclude, as you can see in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The `include` and `exclude` arguments expect a set with the keys of the fields
    you want to include or exclude.
  prefs: []
  type: TYPE_NORMAL
- en: 'For nested structures such as `address`, you can also use a dictionary to specify
    which sub-field you want to include or exclude, as illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_02.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting `address` dictionary only contains the city and the country. Notice
    that when using this syntax, scalar fields such as `first_name` and `last_name`
    have to be associated with the ellipsis, `...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a conversion quite often, it can be useful to put it in a method
    so that you can reuse it at will, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_03.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance from a sub-class object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Creating model variations with class inheritance* section, we studied
    the common pattern of having specific model classes, depending on the situation.
    In particular, you’ll have a model dedicated to the creation endpoint, with only
    the required fields for creation, and a database model with all the fields we
    want to store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `Post` example again:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_04.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have an API that creates endpoints. In this context, we would get
    a `PostCreate` instance with only `title` and `content`. However, we need to build
    a proper `Post` instance before storing it in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A convenient way to do this is to jointly use the `dict` method and the unpacking
    syntax. In the following example, we implemented a creation endpoint using this
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_04.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the path operation function gives us a valid `PostCreate` object.
    Then, we want to transform it into a `Post` object.
  prefs: []
  type: TYPE_NORMAL
- en: We first determine the missing `id` property, which is given to us by the database.
    Here, we use a dummy database based on a dictionary, so we simply take the highest
    key that’s already present in the database and increment it. In a real-world situation,
    this would have been automatically determined by the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting line here is the `Post` instantiation. You can see that
    we first assign the missing fields using keyword arguments and then unpack the
    dictionary representation of `post_create`. As a reminder, the effect of `**`
    in a function call is to transform a dictionary such as `{"title": "Foo", "content":
    "Bar"}` into keyword arguments such as this: `title="Foo", content="Bar"`. It’s
    a very convenient and dynamic approach to set all the fields we already have into
    our new model.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we also set the `response_model` argument on the path operation
    decorator. We explained this in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058),
    *Developing a RESTful API with FastAPI*, but basically, it prompts FastAPI to
    build a JSON response with only the fields of `PostRead`, even though we return
    a `Post` instance at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an instance partially
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some situations, you’ll want to allow partial updates. In other words, you’ll
    allow the end user to only send the fields they want to change to your API and
    omit the ones that shouldn’t change. This is the usual way of implementing a `PATCH`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you would first need a special Pydantic model with all the fields
    marked as optional so that no error is raised when a field is missing. Let’s see
    what this looks like with our `Post` example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_05.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py)'
  prefs: []
  type: TYPE_NORMAL
- en: We are now able to implement an endpoint that will accept a subset of our `Post`
    fields. Since it’s an update, we’ll retrieve an existing post in the database
    thanks to its ID. Then, we’ll have to find a way to only update the fields in
    the payload and keep the others untouched. Fortunately, Pydantic once again has
    this covered, with handy methods and options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the implementation of such an endpoint could look in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter04_working_pydantic_objects_05.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our path operation function takes two arguments: the `id` property (from the
    path) and a `PostPartialUpdate` instance (from the body).'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to check whether this `id` property exists in the database.
    Since we use a dictionary for our dummy database, accessing a key that doesn’t
    exist will raise a `KeyError`. If this happens, we simply raise an `HTTPException`
    with the `404` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the interesting part: updating an existing object. You can see that
    the first thing to do is transform `PostPartialUpdate` into a dictionary with
    the `dict` method. This time, however, we set the `exclude_unset` argument to
    `True`. The effect of this is that *Pydantic won’t output the fields that were
    not provided* in the resulting dictionary: we only get the fields that the user
    sent in the payload.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, on our existing `post_db` database instance, we call the `copy` method.
    This is a useful method for cloning a Pydantic object into another instance. The
    nice thing about this method is that it even accepts an `update` argument. This
    argument expects a dictionary with all the fields that should be updated during
    the copy: that’s exactly what we want to do with our `updated_fields` dictionary!'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We now have an updated `post` instance with only the changes
    required in the payload. You’ll probably use the `exclude_unset` argument and
    the `copy` method quite often while developing with FastAPI, so be sure to keep
    them in mind — they’ll make your life easier!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You’ve learned about another important aspect of FastAPI:
    designing and managing data models with Pydantic. You should now be confident
    about creating models and applying validation at the field level, with built-in
    options and types, and also by implementing your own validation methods. You also
    know how to apply validation at the object level to check consistency between
    several fields. You also learned how to leverage model inheritance to prevent
    code duplication and repetition while defining your model variations. Finally,
    you learned how to correctly work with Pydantic model instances in order to transform
    and update them in an efficient and readable way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You know almost all the features of FastAPI by now. There is one last very
    powerful feature for you to learn about: **dependency injection**. This allows
    you to define your own logic and values and directly inject them into your path
    operation functions, as you do for path parameters and payload objects, which
    you’ll be able to reuse everywhere in your project. That’s the subject of the
    next chapter.'
  prefs: []
  type: TYPE_NORMAL
