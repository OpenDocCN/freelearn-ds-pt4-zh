<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer019">&#13;
			<h1 id="_idParaDest-83" class="chapter-number"><a id="_idTextAnchor285"/>5</h1>&#13;
			<h1 id="_idParaDest-84"><a id="_idTextAnchor286"/>Dependency Injection in FastAPI</h1>&#13;
			<p>In this chapter, we’ll focus on one of the most interesting parts of FastAPI: <strong class="bold">dependency injection</strong>. You’ll <a id="_idIndexMarker385"/>see that it is a powerful and readable approach to reusing logic across your project. Indeed, it will allow you to create complex building blocks for your project, which you’ll be able to use everywhere in your logic. An authentication system, a query parameter validator, or a rate limiter are typical use cases for dependencies. In FastAPI, a dependency injection can even call another one recursively, allowing you to build high-level blocks from basic features. By the end of this chapter, you’ll be able to create your own dependencies for FastAPI and use them at several levels of <span class="No-Break">your project.</span><a id="_idTextAnchor287"/></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>What is <span class="No-Break">dependency injection?</span></li>&#13;
				<li>Creating and using a <span class="No-Break">function dependency</span></li>&#13;
				<li>Creating and using a parameterized dependency with <span class="No-Break">a class</span></li>&#13;
				<li>Using dependencies at the path, router, and <span class="No-Break">global level</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-85"><a id="_idTextAnchor288"/>Technical requirements</h1>&#13;
			<p>To run the code examples, you’ll need a Python virtual environment, which we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>You’ll find all the code examples for this chapter in the dedicated GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05</span></a><span class="No-Break">.</span><a id="_idTextAnchor289"/></p>&#13;
			<h1 id="_idParaDest-86"><a id="_idTextAnchor290"/>What is dependency injection?</h1>&#13;
			<p>Generally<a id="_idTextAnchor291"/> <a id="_idIndexMarker386"/>speaking, <strong class="bold">dependency injection</strong> is a system to automatically instantiate objects and the ones they depend on. The responsibility of developers is then to only provide a declaration of how an object should be created, and let the system resolve all the dependency chains and create the actual objects <span class="No-Break">at runtime.</span></p>&#13;
			<p>FastA<a id="_idTextAnchor292"/>PI allows you t<a id="_idTextAnchor293"/>o declare only the objects and variables you wish to have at hand by declaring them in the path operation function arguments. Actually, we already used dependency injection in the previous chapters. In the following example, we use the <strong class="source-inline">Header</strong> function to<a id="_idIndexMarker387"/> retrieve the <span class="No-Break"><strong class="source-inline">user-agent</strong></span><span class="No-Break"> header:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_what_is_dependency_injection_01.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, Headerapp = FastAPI()&#13;
@app.get("/")&#13;
async def header(user_agent: str = Header(...)):&#13;
    return {"user_agent": user_agent}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_what_is_dependency_injection_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_what_is_dependency_injection_01.py</a></p>&#13;
			<p>Internally, the <strong class="source-inline">Header</strong> function has some logic to automatically get the <strong class="source-inline">request</strong> object, check for the required header, return its value, or raise an error if it’s not present. From the developer’s perspective, however, we don’t know how it handled the required objects for this operation: we just ask for the value we need. <em class="italic">That’s </em><span class="No-Break"><em class="italic">dependency injection</em></span><span class="No-Break">.</span></p>&#13;
			<p>Admittedly, you could reproduce this example quite easily in the function body by picking the <strong class="source-inline">user-agent</strong> property in the <strong class="source-inline">headers</strong> dictionary of the <strong class="source-inline">request</strong> object. However, the dependency injection approach has numerous advanta<a id="_idTextAnchor294"/>ges <span class="No-Break">over this:</span></p>&#13;
			<ul>&#13;
				<li>The <em class="italic">intent is clear</em>: you know what the endpoint expects in the request data without reading the <span class="No-Break">function’s code.</span></li>&#13;
				<li>You have a <em class="italic">clear separation of concerns between the logic of the endpoint and the more generic logic</em>: the header retrieval and the associated error-handling doesn’t pollute the rest of the logic; it’s self-contained in the dependency function. Besides, it can be reused easily in <span class="No-Break">other endpoints.</span></li>&#13;
				<li>In the case <a id="_idTextAnchor295"/>of FastAPI, it’s used to <em class="italic">generate the OpenAPI schema</em> so that the automatic documentation can clearly show which parameters are expected for <span class="No-Break">this endpoint.</span></li>&#13;
			</ul>&#13;
			<p>Put another way, whenever you need utility logic to retrieve or validate data, make security checks, or call external logic that you’ll need several times across your application, a dependency is an <span class="No-Break">ideal choice.</span></p>&#13;
			<p>FastAPI relies heavily on this dependency injection system and encourages developers to use it to implement their building blocks. It may be a bit puzzling if you come from other web frameworks such as<a id="_idIndexMarker388"/> Flask or Express, but you’ll surely be quickly convinced by its power <span class="No-Break">and relevance.</span></p>&#13;
			<p>To convince you, we’ll now see how you can create and use your very own dependency, in the form of a function to <span class="No-Break">begin wi<a id="_idTextAnchor296"/>th.</span></p>&#13;
			<h1 id="_idParaDest-87"><a id="_idTextAnchor297"/>Creating and using a function dependency</h1>&#13;
			<p>In FastAPI, a depend<a id="_idTextAnchor298"/>ency<a id="_idIndexMarker389"/> can be defined either as a function or as a callable class. In this section, we’ll focus on the functions, which are the ones you’ll probably work with most of <span class="No-Break">the time.</span></p>&#13;
			<p>As we said, a dependency is a way to wrap some logic that will retrieve some sub-values or sub-objects, make something with them, and finally, return a value that will be injected into the endpoint <span class="No-Break">calling it.</span></p>&#13;
			<p>Let’s look at the f<a id="_idTextAnchor299"/>irst example where we define a <a id="_idIndexMarker390"/>function dependency to retrieve pagination query parameters, <strong class="source-inline">skip</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">limit</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_function_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
async def pagination(skip: int = 0, limit: int = 10) -&gt; tuple[int, int]:    return (skip, limit)&#13;
@app.get("/items")&#13;
async def list_items(p: tuple[int, int] = Depends(pagination)):&#13;
    skip, limit = p&#13;
    return {"skip": skip, "limit": limit}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py</a></p>&#13;
			<p>There ar<a id="_idTextAnchor300"/>e<a id="_idIndexMarker391"/> two parts to <span class="No-Break">this example:</span></p>&#13;
			<ul>&#13;
				<li>First, we ha<a id="_idTextAnchor301"/>ve the dependency definition, with the <strong class="source-inline">pagination</strong> function. You see that we define two arguments, <strong class="source-inline">skip</strong> and <strong class="source-inline">limit</strong>, which are integers with default values. Those will be the query parameters on our endpoint. We define them exactly like we would have done on a path operation function. That’s the beauty of this approach: FastAPI will recursively handle the arguments on the dependency and match them with the request data, such as query parameters or headers <span class="No-Break">if needed.</span></li>&#13;
			</ul>&#13;
			<p>We simply return those values as a tuple.</p>&#13;
			<ul>&#13;
				<li>Second, we have the path operation function, <strong class="source-inline">list_items</strong>, which uses the <strong class="source-inline">pagination</strong> dependency. You see here that the usage is quite similar to what we have done for header or body values: we define the name of our resulting argument and we use a function result as a default value. In the case of a dependency, we use the <strong class="source-inline">Depends</strong> function. Its role is to take a function in the argument and execute it when the endpoint is called. The sub-dependencies are automatically discovered <span class="No-Break">and executed.</span></li>&#13;
			</ul>&#13;
			<p>In the endpoint, we have the pagination directly in the form of <span class="No-Break">a tuple.</span></p>&#13;
			<p>Let’s run this example with the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
$ uvicorn chapter05_function_dependency_01:app</pre>			<p>Now, we’ll try to <a id="_idIndexMarker392"/>call the <strong class="source-inline">/items</strong> endpoint and see whether it’s able to retrieve the query paramete<a id="_idTextAnchor302"/>rs. You can try this with the followin<a id="_idTextAnchor303"/>g <span class="No-Break">HTTPie command:</span></p>&#13;
			<pre class="source-code">&#13;
$ http "http://localhost:8000/items?limit=5&amp;skip=10"HTTP/1.1 200 OK&#13;
content-length: 21&#13;
content-type: application/json&#13;
date: Tue, 15 Nov 2022 08:33:46 GMT&#13;
server: uvicorn&#13;
{&#13;
    "limit": 5,&#13;
    "skip": 10&#13;
}</pre>&#13;
			<p>The <strong class="source-inline">limit</strong> and <strong class="source-inline">skip</strong> query parameters have correctly been retrieved thanks to our function dependency. You can also try to call the endpoint without the query parameter and notice that it will return the <span class="No-Break">default values.</span></p>&#13;
			<p class="callout-heading">Type hint of a dependency return value</p>&#13;
			<p class="callout">You may have noti<a id="_idTextAnchor304"/>ced that we had to type hint the result of our dependency in the path operation arguments, even though we already type hinted the dependency function itself. Unfortunately, this is a limitation of FastAPI and its <strong class="source-inline">Depends</strong> function, which isn’t able to forward the type of the dependency function. Therefore, we have to type hint the result by hand, as we <span class="No-Break">did here.</span></p>&#13;
			<p>And that’s it! As you see, it’s very simple and straightforward to create and use a dependency in FastAPI. Of course, you can now reuse it at will in several endpoints, as you can see in the rest of <span class="No-Break">the example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_function_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/things")async def list_things(p: tuple[int, int] = Depends(pagination)):&#13;
    skip, limit = p&#13;
    return {"skip": skip, "limit": limit}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_01.py</a></p>&#13;
			<p>We<a id="_idTextAnchor305"/> can do more complex<a id="_idIndexMarker393"/> things in those dependencies, j<a id="_idTextAnchor306"/>ust like we would in a regular path operation function. In the following example, we add some validation to those pagination parameters and cap the limit <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">100</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_function_dependency_02.py</p>&#13;
			<pre class="source-code">&#13;
async def pagination(    skip: int = Query(0, ge=0),&#13;
    limit: int = Query(10, ge=0),&#13;
) -&gt; tuple[int, int]:&#13;
    capped_limit = min(100, limit)&#13;
    return (skip, capped_limit)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_02.py</a></p>&#13;
			<p>As you can see, our dependency starts to become <span class="No-Break">more complex:</span></p>&#13;
			<ul>&#13;
				<li>We added the <strong class="source-inline">Query</strong> function to our arguments to add a validation constraint; now, a <strong class="source-inline">422</strong> error will be raised if <strong class="source-inline">skip</strong> or <strong class="source-inline">limit</strong> are <span class="No-Break">negative integers.</span></li>&#13;
				<li>We ensure that the limit is, at <span class="No-Break">most, </span><span class="No-Break"><strong class="source-inline">100.</strong></span></li>&#13;
			</ul>&#13;
			<p>The co<a id="_idTextAnchor307"/>de on our path <a id="_idIndexMarker394"/>operation functions doesn’t have to change; <a id="_idTextAnchor308"/>we have a clear separation of concerns between the logic of the endpoint and the more generic logic for the <span class="No-Break">pagination parameters.</span></p>&#13;
			<p>Let’s see another typical use of dependencies: get an object or raise a <span class="No-Break"><strong class="source-inline">4<a id="_idTextAnchor309"/>04</strong></span><span class="No-Break"> error.</span></p>&#13;
			<h2 id="_idParaDest-88"><a id="_idTextAnchor310"/>Getting an object or raising a 404 error</h2>&#13;
			<p>In a REST AP<a id="_idTextAnchor311"/>I, you’ll typically have <a id="_idIndexMarker395"/>endpoints to get, update, an<a id="_idTextAnchor312"/>d delete a single object given its identifier in the path. On each one, you’ll likely have the same logic: try to retrieve this object in the database or raise a <strong class="source-inline">404</strong> error if it doesn’t exist. That’s a perfect use case for a dependency! In the following example, you’ll see how to <span class="No-Break">implement it:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_function_dependency_03.py</p>&#13;
			<pre class="source-code">&#13;
async def get_post_or_404(id: int) -&gt; Post:    try:&#13;
        return db.posts[id]&#13;
    except KeyError:&#13;
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py</a></p>&#13;
			<p>The dependency definition is simple: it takes, in an argument, the ID of the post we want to retrieve. It will be pulled from the corresponding path parameter. Then, we check whether it exists in our dummy dictionary database: if it does, we return it; otherwise, we raise an HTTP exception with a <strong class="source-inline">404</strong> <span class="No-Break">status code.</span></p>&#13;
			<p>That’s the key takeaway of this example: <em class="italic">you can raise errors in your dependencies</em>. It’s extremely useful to check for some pre-conditions before your endpoint logic is executed. Another typical example of this is authentication: if the endpoint requires a user to be authenticated, we can raise a <strong class="source-inline">401</strong> error in the dependency by checking for the token or <span class="No-Break">the cookie.</span></p>&#13;
			<p>Now, we c<a id="_idTextAnchor313"/>an use this dependency in each of our API endpoin<a id="_idTextAnchor314"/>ts, as you can see in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_function_dependency_03.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/posts/{id}")async def get(post: Post = Depends(get_post_or_404)):&#13;
    return post&#13;
@app.patch("/posts/{id}")&#13;
async def update(post_update: PostUpdate, post: Post = Depends(get_post_or_404)):&#13;
    updated_post = post.copy(update=post_update.dict())&#13;
    db.posts[post.id] = updated_post&#13;
    return updated_post&#13;
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)&#13;
async def delete(post: Post = Depends(get_post_or_404)):&#13;
    db.posts.pop(post.id)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_function_dependency_03.py</a></p>&#13;
			<p>As you can see, we <a id="_idIndexMarker396"/>just had to define the <strong class="source-inline">post</strong> argument and use the <strong class="source-inline">Depends</strong> function on our <strong class="source-inline">get_post_or_404</strong> dependency. Then, within the path operation logic, we are guaranteed to have our <strong class="source-inline">post</strong> object at hand and we can focus on our core logic, which is now very concise. The <strong class="source-inline">get</strong> endpoint, for example, just has to return <span class="No-Break">the object.</span></p>&#13;
			<p>In this ca<a id="_idTextAnchor315"/>se, the only point of attention is to not forget the I<a id="_idTextAnchor316"/>D parameter in the path of those endpoints. According to the rules of FastAPI, if you don’t set this parameter in the path, it will automatically be regarded as a query parameter, which is not what we want here. You can find more <a id="_idIndexMarker397"/>details about this in the <em class="italic">Path parameters</em> section of <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API </em><span class="No-Break"><em class="italic">with FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<p>That’s all for the function dependencies. As we said, those are the main building blocks of a FastAPI project. In some cases, however, you’ll need to have some parameters on those dependencies – for example, with values coming from environment variables. For this, we can define <span class="No-Break">class d<a id="_idTextAnchor317"/>ependencies.</span></p>&#13;
			<h1 id="_idParaDest-89"><a id="_idTextAnchor318"/>Creating and using a parameterized dependency  with a class</h1>&#13;
			<p>In the previous<a id="_idTextAnchor319"/><a id="_idIndexMarker398"/> section, we defined dependencies as regular functions, which work well in most cases. Still, you may need to set some parameters on a dependency to finely tune its behavior. Since the arguments of the function are set by the dependency injection system, we can’t add an argument to <span class="No-Break">the function.</span></p>&#13;
			<p>In the pagination example, we added some logic to cap the limit value at <strong class="source-inline">100</strong>. If we wanted to set this maximum limit dynamically, how would we <span class="No-Break">do that?</span></p>&#13;
			<p>The solution is to create a class that will be used as a dependency. This way, we can set class properties – with the <strong class="source-inline">__init__</strong> method, for example – and use them in the logic of the dependency itself. This logic will be defined in the <strong class="source-inline">__call__</strong> method of the class. If you remember what we learned in the <em class="italic">Callable object</em> section of <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specificities</em>, you know that it makes the object callable, meaning it can be called like a regular function. Actually, that is all that <strong class="source-inline">Depends</strong> requires for a dependency: being callable. We’ll use this property to create a parameterized <a id="_idIndexMarker399"/>dependency thanks to <span class="No-Break">a class.</span></p>&#13;
			<p>In the followi<a id="_idTextAnchor320"/>ng example, we reimplemented the pagination example with a class, allowing us to set the maximum <span class="No-Break">limit dynamically:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_class_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
class Pagination:    def __init__(self, maximum_limit: int = 100):&#13;
        self.maximum_limit = maximum_limit&#13;
    async def __call__(&#13;
        self,&#13;
        skip: int = Query(0, ge=0),&#13;
        limit: int = Query(10, ge=0),&#13;
    ) -&gt; tuple[int, int]:&#13;
        capped_limit = min(self.maximum_limit, limit)&#13;
        return (skip, capped_limit)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py</a></p>&#13;
			<p>As you can see, the <a id="_idIndexMarker400"/>logic in the <strong class="source-inline">__call__</strong> method is the same as in the function we defined in the previous example. The only difference here is that we can pull our maximum limit from our class properties, which we can set at the <span class="No-Break">object initialization.</span></p>&#13;
			<p>Then, you can simply create an instance of this class and use it as a dependency with <strong class="source-inline">Depends</strong> on your path operation function, as you can see in the following <span class="No-Break">code block:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_class_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
pagination = Pagination(maximum_limit=50)@app.get("/items")&#13;
async def list_items(p: tuple[int, int] = Depends(pagination)):&#13;
    skip, limit = p&#13;
    return {"skip": skip, "limit": limit}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_01.py</a></p>&#13;
			<p>Here, <a id="_idTextAnchor321"/>we hardcoded the <strong class="source-inline">50</strong> value, but we could very well pull it from a configuration file or an <span class="No-Break">environment variable.</span></p>&#13;
			<p>The other advantage of <a id="_idIndexMarker401"/>a class dependency is that it can maintain local values in memory. This property can be very useful if we have to make some heavy initialization logic, such as loading a machine learning model, for example, which we want to do only once at startup. Then, the callable part just has to call the loaded model to make the prediction, which shoul<a id="_idTextAnchor322"/>d be <span class="No-Break">quite fast.</span></p>&#13;
			<h2 id="_idParaDest-90"><a id="_idTextAnchor323"/>Using class methods as dependencies</h2>&#13;
			<p>Even if the <strong class="source-inline">__<a id="_idTextAnchor324"/>call__</strong> method is the <a id="_idIndexMarker402"/>most straightforw<a id="_idTextAnchor325"/>ard way to make <a id="_idIndexMarker403"/>a class dependency, you can directly pass a method to <strong class="source-inline">Depends</strong>. Indeed, as we said, it simply expects a callable as an argument, and a class method is a perfectly <span class="No-Break">valid callable!</span></p>&#13;
			<p>This approach can be very useful if you have common parameters or logic that you need to reuse in slightly different cases. For example, you could have one pre-trained machine learning model made with scikit-learn. Before applying the decision function, you may want to apply different preprocessing steps, depending on the <span class="No-Break">input data.</span></p>&#13;
			<p>To do this, simply write your logic in a class method and pass it to the <strong class="source-inline">Depends</strong> function through the <span class="No-Break">dot notation.</span></p>&#13;
			<p>You can see this in the following example, where we implement another style for our pagination dependency, with <strong class="source-inline">page</strong> and <strong class="source-inline">size</strong> parameters instead of <strong class="source-inline">skip</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">limit</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_class_dependency_02.py</p>&#13;
			<pre class="source-code">&#13;
class Pagination:    def __init__(self, maximum_limit: int = 100):&#13;
        self.maximum_limit = maximum_limit&#13;
    async def skip_limit(&#13;
        self,&#13;
        skip: int = Query(0, ge=0),&#13;
        limit: int = Query(10, ge=0),&#13;
    ) -&gt; tuple[int, int]:&#13;
        capped_limit = min(self.maximum_limit, limit)&#13;
        return (skip, capped_limit)&#13;
    async def page_size(&#13;
        self,&#13;
        page: int = Query(1, ge=1),&#13;
        size: int = Query(10, ge=0),&#13;
    ) -&gt; tuple[int, int]:&#13;
        capped_size = min(self.maximum_limit, size)&#13;
        return (page, capped_size)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.<span id="_idTextAnchor326"/>py</a></p>&#13;
			<p>The logic of the two methods is quit<a id="_idTextAnchor327"/>e<a id="_idIndexMarker404"/> similar. We just look at different query<a id="_idIndexMarker405"/> parameters. Then, on our path operation functions, we set the <strong class="source-inline">/items</strong> endpoint to work with the <strong class="source-inline">skip</strong>/<strong class="source-inline">limit</strong> style, while the <strong class="source-inline">/things</strong> endpoint will work with the <span class="No-Break"><strong class="source-inline">page</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">size</strong></span><span class="No-Break"> style:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_class_dependency_02.py</p>&#13;
			<pre class="source-code">&#13;
pagination = Pagination(maximum_limit=50)@app.get("/items")&#13;
async def list_items(p: tuple[int, int] = Depends(pagination.skip_limit)):&#13;
    skip, limit = p&#13;
    return {"skip": skip, "limit": limit}&#13;
@app.get("/things")&#13;
async def list_things(p: tuple[int, int] = Depends(pagination.page_size)):&#13;
    page, size = p&#13;
    return {"page": page, "size": size}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_class_dependency_02.py</a><a id="_idTextAnchor328"/></p>&#13;
			<p>As you can see, we only have t<a id="_idTextAnchor329"/>o pass the method we want through the dot notation on the <span class="No-Break"><strong class="source-inline">pagination</strong></span><span class="No-Break"> object.</span></p>&#13;
			<p>To sum up, the class dependency approach is more advanced than the function approach but can be very useful for cases when you need to set parameters dynamically, perform <a id="_idIndexMarker406"/>heavy initialization logic, or reuse common logic <a id="_idIndexMarker407"/>on <span class="No-Break">several dependencies.</span></p>&#13;
			<p>Until now, we’ve assumed that we care about the return value of the dependency. While this will probably be the case most of the time, you may occasionally need to call a dependency to check for some conditions but don’t really need the returned value. FastAPI allows such use cases, and that<a id="_idTextAnchor330"/>’s what we’ll <span class="No-Break">see now.</span></p>&#13;
			<h1 id="_idParaDest-91"><a id="_idTextAnchor331"/>Using dependencies at the path, router, and global level</h1>&#13;
			<p>As we said, dependencies are the recommended way to create building blocks in a FastAPI project, allowing you to reuse logic across endpoints while maintaining maximum code readability. Until now, we’ve applied them to a single endpoint, but couldn’t we expand this approach to a whole router? Or even a whole FastAPI application? Actually, <span class="No-Break">we can!</span></p>&#13;
			<p>The main motivation for this is to be able to apply some global request validation or perform side logic on several routes without the need to add a dependency on each endpoint. Typically, an authentication method or a rate limiter could be very good candidates for this <span class="No-Break">use case.</span></p>&#13;
			<p>To show you how it works, we’ll implement a simple dependency that we will use across all the following examples. You can see it in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_path_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
def secret_header(secret_header: str | None = Header(None)) -&gt; None:    if not secret_header or secret_header != "SECRET_VALUE":&#13;
        raise HTTPException(status.HTTP_403_FORBIDDEN)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py</a></p>&#13;
			<p>This dependency will simply look for a header in the request named <strong class="source-inline">Secret-Header</strong>. If it’s missing or not equal to <strong class="source-inline">SECRET_VALUE</strong>, it will raise a <strong class="source-inline">403</strong> error. Please note that this approach is only for the sake of the example; there are better ways to secure your API, which we’ll cover in <a href="B19528_07.xhtml#_idTextAnchor448"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Managing Authentication an<a id="_idTextAnchor332"/>d Security </em><span class="No-Break"><em class="italic">in FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-92">Using a dependency on a path deco<a id="_idTextAnchor333"/>rator</h2>&#13;
			<p>Until now, we’ve assumed that we <a id="_idIndexMarker408"/>w<a id="_idTextAnchor334"/>ere always interested in the return value of the dependency. As our <strong class="source-inline">secret_header</strong> dependency clearly shows here, this is not always the case. This is why you can add a dependency on a path operation decorator instead of the arguments. You can see how in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_path_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/protected-route", dependencies=[Depends(secret_header)])async def protected_route():&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_path_dependency_01.py</a></p>&#13;
			<p>The path operation decorator accepts an argument, <strong class="source-inline">dependencies</strong>, which expects a list of dependencies. You see that, just like for dependencies you pass in arguments, you need to wrap your function (or callable) with the <span class="No-Break"><strong class="source-inline">Depends</strong></span><span class="No-Break"> function.</span></p>&#13;
			<p>Now, whenever the <strong class="source-inline">/protected-route</strong> route is called, the dependency will be called and will check for the <span class="No-Break">required header.</span></p>&#13;
			<p>As you may have guessed, since <strong class="source-inline">dependencies</strong> is a list, you can add as many dependencies as <span class="No-Break">you need.</span></p>&#13;
			<p>That’s interesting, but<a id="_idIndexMarker409"/> what if we want to protect a whole set of endpoints? It would be a bit cumbersome and error-prone to add it manually to each one. Fortunately, FastAPI pr<a id="_idTextAnchor335"/>ovides a way to <span class="No-Break">do that.</span></p>&#13;
			<h2 id="_idParaDest-93">Using a dependency <a id="_idTextAnchor336"/>on a whole router</h2>&#13;
			<p>If you recall the <em class="italic">Structuring a bigger project with multiple routers</em> section in <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI</em>, you know that you can create several routers in your project <a id="_idIndexMarker410"/>to clearly split the different parts of your API and “wire” them to your main FastAPI application. This is done with the <strong class="source-inline">APIRouter</strong> class and the <strong class="source-inline">include_router</strong> method of the <span class="No-Break"><strong class="source-inline">FastAPI</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p>With this approach, it can be interesting to inject a dependency into the whole ro<a id="_idTextAnchor337"/>uter, so that it’s called for every route of this router. You have two ways of <span class="No-Break">doing this:</span></p>&#13;
			<ul>&#13;
				<li>Set the <strong class="source-inline">dependencies</strong> argument on the <strong class="source-inline">APIRouter</strong> class, as you can see in the <span class="No-Break">following example:</span></li>&#13;
			</ul>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_router_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
router = APIRouter(dependencies=[Depends(secret_header)])@router.get("/route1")&#13;
async def router_route1():&#13;
    return {"route": "route1"}&#13;
@router.get("/route2")&#13;
async def router_route2():&#13;
    return {"route": "route2"}&#13;
app = FastAPI()&#13;
app.include_router(router, prefix="/router")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_01.py</a></p>&#13;
			<ul>&#13;
				<li>Set the <strong class="source-inline">dependencies</strong> argument on the <strong class="source-inline">include_router</strong> meth<a id="_idTextAnchor338"/>od, as you can see in the<a id="_idIndexMarker411"/> <span class="No-Break">following example:</span></li>&#13;
			</ul>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_router_dependency_02.py</p>&#13;
			<pre class="source-code">&#13;
router = APIRouter()@router.get("/route1")&#13;
async def router_route1():&#13;
    return {"route": "route1"}&#13;
@router.get("/route2")&#13;
async def router_route2():&#13;
    return {"route": "route2"}&#13;
app = FastAPI()&#13;
app.include_router(router, prefix="/router", dependencies=[Depends(secret_header)])</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_02.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_router_dependency_02.py</a></p>&#13;
			<p>In both cases, the <strong class="source-inline">dependencies</strong> argument expects a list of dependencies. You can see that, just like for dependencies you pass in arguments, you need to wrap your function (or callable) with the <strong class="source-inline">Depends</strong> function. Of course, since it’s a list, you can add several dependencies if <span class="No-Break">you need.</span></p>&#13;
			<p>Now, how to choose <a id="_idIndexMarker412"/>between the two approaches? In both cases, the effect will be exactly the same, so we could say it doesn’t really matter. Philosophically, we could say that we should declare a dependency on the <strong class="source-inline">APIRouter</strong> class if it’s needed in the context of this router. Put another way, we could ask ourselves the question, <em class="italic">Does this router work without this dependency if we run it independently</em>? If the answer to this question is <em class="italic">no</em>, then you should probably set the dependency on the <strong class="source-inline">APIRouter<a id="_idTextAnchor339"/></strong> class. Otherwise, declaring it in the <strong class="source-inline">include_router</strong> method may make more sense. But again, this is an intellectual choice that won’t change the functionality of your API, so feel free to choose the one you’re more <span class="No-Break">comfortable with.</span></p>&#13;
			<p>We are now able to set dependencies for a whole router. In some cases, it could also be interesting to declare th<a id="_idTextAnchor340"/>em for a <span class="No-Break">whole application!</span></p>&#13;
			<h2 id="_idParaDest-94">Using a dependency on a who<a id="_idTextAnchor341"/>le application</h2>&#13;
			<p>If you have a dependency that <a id="_idIndexMarker413"/>implements some logging or rate-limiting functionality, for example, it could be interesting to execute it for every endpoint of your API. Fortunately, FastAPI allows this, as you can see in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter05_global_dependency_01.py</p>&#13;
			<pre class="source-code">&#13;
app = FastAPI(dependencies=[Depends(secret_header)])@app.get("/route1")&#13;
async def route1():&#13;
    return {"route": "route1"}&#13;
@app.get("/route2")&#13;
async def route2():&#13;
    return {"route": "route2"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_global_dependency_01.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter05/chapter05_global_dependency_01.py</a></p>&#13;
			<p>Once again, you only<a id="_idIndexMarker414"/> have to set the <strong class="source-inline">dependencies</strong> argument directly on the main <strong class="source-inline">FastAPI</strong> class. Now, the dependency is applied to every endpoint <a id="_idTextAnchor342"/>in <span class="No-Break">your API!</span></p>&#13;
			<p>In <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em>, we propose a simple decision tree to determine at which level you should inject <span class="No-Break">your dependency:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer018" class="IMG---Figure">&#13;
					<img src="Images/Figure_5.1_B19528.jpg" alt="Figure 5.1 – At which level should I inject my dependency?" width="811" height="622"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – At which level sh<a id="_idTextAnchor343"/>ould I inject my dependency?</p>&#13;
			<h1 id="_idParaDest-95"><a id="_idTextAnchor344"/>Summary</h1>&#13;
			<p>Well done! You should now be comfortable with one of the most iconic features of FastAPI: dependency injection. By implementing your own dependencies, you’ll be able to keep common logic that you wish to reuse across your API separate from the endpoints’ logic. This will make your project clean and maintainable while retaining maximum readability; dependencies just need to be declared as arguments of the path operation functions, which will help you to understand the intent without having to read the body of <span class="No-Break">the function.</span></p>&#13;
			<p>Those dependencies can be both simple wrappers to retrieve and validate request parameters, or complex services performing machine learning tasks. Thanks to the class-based approach, you can indeed set dynamic parameters or keep a local state for your most <span class="No-Break">advanced tasks.</span></p>&#13;
			<p>Finally, those dependencies can also be used at a router or global level, allowing you to perform common logic or checks for a set of routes or a <span class="No-Break">whole application.</span></p>&#13;
			<p>That’s the end of the first part of this book! You’re now acquainted with the main features of FastAPI and should now be able to write clean and performant REST APIs with <span class="No-Break">the framework.</span></p>&#13;
			<p>In the next part, we’ll take your knowledge to the next level and show you how you can implement and deploy a robust, secure, and tested web backend. The first chapter will be dedicated to databases, a must-have for most APIs to be able to read and <span class="No-Break">write data.</span></p>&#13;
		</div>&#13;
	</div></body></html>