["```py\n\nfrom fastapi import FastAPI, Headerapp = FastAPI()\n@app.get(\"/\")\nasync def header(user_agent: str = Header(...)):\n    return {\"user_agent\": user_agent}\n```", "```py\n\nasync def pagination(skip: int = 0, limit: int = 10) -> tuple[int, int]:    return (skip, limit)\n@app.get(\"/items\")\nasync def list_items(p: tuple[int, int] = Depends(pagination)):\n    skip, limit = p\n    return {\"skip\": skip, \"limit\": limit}\n```", "```py\n\n$ uvicorn chapter05_function_dependency_01:app\n```", "```py\n\n$ http \"http://localhost:8000/items?limit=5&skip=10\"HTTP/1.1 200 OK\ncontent-length: 21\ncontent-type: application/json\ndate: Tue, 15 Nov 2022 08:33:46 GMT\nserver: uvicorn\n{\n    \"limit\": 5,\n    \"skip\": 10\n}\n```", "```py\n\n@app.get(\"/things\")async def list_things(p: tuple[int, int] = Depends(pagination)):\n    skip, limit = p\n    return {\"skip\": skip, \"limit\": limit}\n```", "```py\n\nasync def pagination(    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=0),\n) -> tuple[int, int]:\n    capped_limit = min(100, limit)\n    return (skip, capped_limit)\n```", "```py\n\nasync def get_post_or_404(id: int) -> Post:    try:\n        return db.posts[id]\n    except KeyError:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n```", "```py\n\n@app.get(\"/posts/{id}\")async def get(post: Post = Depends(get_post_or_404)):\n    return post\n@app.patch(\"/posts/{id}\")\nasync def update(post_update: PostUpdate, post: Post = Depends(get_post_or_404)):\n    updated_post = post.copy(update=post_update.dict())\n    db.posts[post.id] = updated_post\n    return updated_post\n@app.delete(\"/posts/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete(post: Post = Depends(get_post_or_404)):\n    db.posts.pop(post.id)\n```", "```py\n\nclass Pagination:    def __init__(self, maximum_limit: int = 100):\n        self.maximum_limit = maximum_limit\n    async def __call__(\n        self,\n        skip: int = Query(0, ge=0),\n        limit: int = Query(10, ge=0),\n    ) -> tuple[int, int]:\n        capped_limit = min(self.maximum_limit, limit)\n        return (skip, capped_limit)\n```", "```py\n\npagination = Pagination(maximum_limit=50)@app.get(\"/items\")\nasync def list_items(p: tuple[int, int] = Depends(pagination)):\n    skip, limit = p\n    return {\"skip\": skip, \"limit\": limit}\n```", "```py\n\nclass Pagination:    def __init__(self, maximum_limit: int = 100):\n        self.maximum_limit = maximum_limit\n    async def skip_limit(\n        self,\n        skip: int = Query(0, ge=0),\n        limit: int = Query(10, ge=0),\n    ) -> tuple[int, int]:\n        capped_limit = min(self.maximum_limit, limit)\n        return (skip, capped_limit)\n    async def page_size(\n        self,\n        page: int = Query(1, ge=1),\n        size: int = Query(10, ge=0),\n    ) -> tuple[int, int]:\n        capped_size = min(self.maximum_limit, size)\n        return (page, capped_size)\n```", "```py\n\npagination = Pagination(maximum_limit=50)@app.get(\"/items\")\nasync def list_items(p: tuple[int, int] = Depends(pagination.skip_limit)):\n    skip, limit = p\n    return {\"skip\": skip, \"limit\": limit}\n@app.get(\"/things\")\nasync def list_things(p: tuple[int, int] = Depends(pagination.page_size)):\n    page, size = p\n    return {\"page\": page, \"size\": size}\n```", "```py\n\ndef secret_header(secret_header: str | None = Header(None)) -> None:    if not secret_header or secret_header != \"SECRET_VALUE\":\n        raise HTTPException(status.HTTP_403_FORBIDDEN)\n```", "```py\n\n@app.get(\"/protected-route\", dependencies=[Depends(secret_header)])async def protected_route():\n    return {\"hello\": \"world\"}\n```", "```py\n\nrouter = APIRouter(dependencies=[Depends(secret_header)])@router.get(\"/route1\")\nasync def router_route1():\n    return {\"route\": \"route1\"}\n@router.get(\"/route2\")\nasync def router_route2():\n    return {\"route\": \"route2\"}\napp = FastAPI()\napp.include_router(router, prefix=\"/router\")\n```", "```py\n\nrouter = APIRouter()@router.get(\"/route1\")\nasync def router_route1():\n    return {\"route\": \"route1\"}\n@router.get(\"/route2\")\nasync def router_route2():\n    return {\"route\": \"route2\"}\napp = FastAPI()\napp.include_router(router, prefix=\"/router\", dependencies=[Depends(secret_header)])\n```", "```py\n\napp = FastAPI(dependencies=[Depends(secret_header)])@app.get(\"/route1\")\nasync def route1():\n    return {\"route\": \"route1\"}\n@app.get(\"/route2\")\nasync def route2():\n    return {\"route\": \"route2\"}\n```"]