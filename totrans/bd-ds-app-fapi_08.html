<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer028">&#13;
			<h1 id="_idParaDest-97" class="chapter-number"><a id="_idTextAnchor346"/>6</h1>&#13;
			<h1 id="_idParaDest-98"><a id="_idTextAnchor347"/>Databases and Asynchronous ORMs</h1>&#13;
			<p><a id="_idTextAnchor348"/>The main goal of a REST API is, of course, to read and write data. So far, we’ve solely worked with the tools given by Python and FastAPI, allowing us to build reliable endpoints to process and answer requests. However, we haven’t been able to effectively retrieve and persist that information: we don’t have <span class="No-Break">a </span><span class="No-Break"><strong class="bold">database</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The goal of this chapter is to show you how you can interact with different types of databases and related libraries inside FastAPI. It’s worth noting that FastAPI is completely agnostic regarding databases: you can use any system you want and it’s your responsibility to integrate it. This is why we’ll review two different approaches to integrating a database: using an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) system for SQL databases and using a <span class="No-Break">NoSQL database.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>An overview of relational and <span class="No-Break">NoSQL databases</span></li>&#13;
				<li>Communicating with a SQL database with <span class="No-Break">SQLAlchemy ORM</span></li>&#13;
				<li>Communicating with a MongoDB database <span class="No-Break">using Motor</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-99"><a id="_idTextAnchor349"/>Technical requirements</h1>&#13;
			<p>For this chapter, you’ll require a Python virtual environment, just as we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>For the <em class="italic">Communicating with a MongoDB database using Motor</em> section, you’ll need a running MongoDB server on your local computer. The easiest way to do this is to run it as a Docker container. If you’ve never used Docker before, we recommend that you refer to the <em class="italic">Getting started</em> tutorial in the official documentation at <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>. Once you have done this, you’ll be able to run a MongoDB server using this <span class="No-Break">simple command:</span></p>&#13;
			<pre class="source-code">&#13;
$ docker run -d --name fastapi-mongo -p 27017:27017 mongo:6.0</pre>			<p>The MongoDB server instance will then be available on your local computer at <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">27017</strong></span><span class="No-Break">.</span></p>&#13;
			<p>You can find all the code examples for this chapter in this book’s dedicated GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-100"><a id="_idTextAnchor350"/>An overview of relational and NoSQL databases</h1>&#13;
			<p>The role of a database is to <a id="_idTextAnchor351"/>store data in a structured way, preserve the integrity of the data, and offer a query language that enables you to retrieve this data when an application <span class="No-Break">needs it.</span></p>&#13;
			<p>Nowadays, when it comes to choosing a database for your web project, you have two main choices: <strong class="bold">relational databases</strong>, with <a id="_idIndexMarker415"/>their associated SQL query language, and <strong class="bold">NoSQL databases</strong>, named in<a id="_idTextAnchor352"/><a id="_idIndexMarker416"/> opposition to the <span class="No-Break">first category.</span></p>&#13;
			<p>Selecting the right technology for your project is left up to you as it greatly depends on your needs and requirements. In this section, we’ll outline the main characteristics and features of those two database families and try to give you some insights into choosing the right one for <span class="No-Break">your project<a id="_idTextAnchor353"/><a id="_idTextAnchor354"/>.</span></p>&#13;
			<h2 id="_idParaDest-101"><a id="_idTextAnchor355"/>Relational databases</h2>&#13;
			<p>Relational databases hav<a id="_idTextAnchor356"/>e existed <a id="_idIndexMarker417"/>since the 1970s, and they have proved to be very performant and reliable over time. They are almost inseparable from SQL, which has become the de facto standard for querying such databases. Even if there are a few differences between one database engine and another, most of the syntax is common, simple to understand, and flexible enough to express <span class="No-Break">complex queries.</span></p>&#13;
			<p>Relational databases implement the relational model: each entity, or object, of the application is stored in <strong class="bold">tables</strong>. For example, if<a id="_idIndexMarker418"/> we consider a blog application, we could have tables that represent <em class="italic">users</em>, <em class="italic">posts</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">comments</em></span><span class="No-Break">.</span></p>&#13;
			<p>Each of those tables will have several <strong class="bold">columns</strong> representing <a id="_idIndexMarker419"/>the attributes of the entity. If we consider posts, we could have a <em class="italic">title</em>, a <em class="italic">publication date</em>, and <em class="italic">content</em>. In those tables, there will be several rows, each one representing a single entity of this type; each post will have its <span class="No-Break">own row.</span></p>&#13;
			<p>One of the key points of relational databases is, as their<a id="_idIndexMarker420"/> name suggests, <em class="italic">relationships</em>. Each table can be in a relationship with others, with rows referring to other rows in other tables. In our example, a post could be related to the user who wrote it. In the same way, a comment could be linked to the post that it <span class="No-Break">relates to.</span></p>&#13;
			<p>The main motivation behind this is to <em class="italic">avoid duplication</em>. Indeed, it wouldn’t be very efficient to repeat the user’s name or email on each post. If it needs to be modified at some point, we would have to go through each post, which is error-prone and puts data consistency at risk. This is why we prefer to <em class="italic">reference</em> the user in the posts. So, how can we <span class="No-Break">do this?</span></p>&#13;
			<p>Usually, each row<a id="_idTextAnchor357"/> in a <a id="_idIndexMarker421"/>relational database has an identifier, called <a id="_idIndexMarker422"/>a <strong class="bold">primary key</strong>. <a id="_idTextAnchor358"/>This is unique in the table and allows you to uniquely identify this row. Therefore, it’s possible to use this key in another table to reference<a id="_idTextAnchor359"/> it. We call this a <strong class="bold">foreign key</strong>: the key is foreign <a id="_idIndexMarker423"/>in the sense that it refers to <span class="No-Break">another table.</span></p>&#13;
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em> shows a representation of such a database schema using an entity-relationship diagram. Note that each table has its own primary key, named <strong class="source-inline">id</strong>. The <strong class="source-inline">Post</strong> table refers to a user, through the <strong class="source-inline">user_id</strong> foreign key. Similarly, the <strong class="source-inline">Comment</strong> table refers to both a post and a user through the <strong class="source-inline">user_id</strong> and <strong class="source-inline">post_id</strong> <span class="No-Break">foreign keys:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer024" class="IMG---Figure">&#13;
					<img src="Images/B19528_06_01.jpg" alt="Figure 6.1 – A relational database schema example for a blog application" width="1147" height="786"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A relational database schema example for a blog application</p>&#13;
			<p>In an application,<a id="_idTextAnchor360"/> you’ll likely<a id="_idIndexMarker424"/> want to retrieve a post, along with the comments and the users associated with them. To d<a id="_idTextAnchor361"/>o so, we can perform<a id="_idIndexMarker425"/> a <strong class="bold">join query</strong>, which will return all the relevant records based on the foreign keys. Relational databases are designed to perform such tasks efficiently; however, those operations can become expensive if the schema is more complex. This is why it’s important to carefully design a relational schema and <span class="No-Break">its<a id="_idTextAnchor362"/> queries.</span></p>&#13;
			<h2 id="_idParaDest-102"><a id="_idTextAnchor363"/>NoSQL databases</h2>&#13;
			<p>All databas<a id="_idTextAnchor364"/>e engines that are not <a id="_idIndexMarker426"/>relational fall back into the NoSQL category. This is a quite vague denomination that regroups different families of databases: key-value stores, such as Redis; graph databases, such as Neo4j; and document-oriented databases, such as MongoDB. That said, most of the time, when we talk about “NoSQL databases,” we are implicitly referring to document-oriented databases. They are the ones we’re <span class="No-Break">interested in.</span></p>&#13;
			<p>Document-oriented databases<a id="_idIndexMarker427"/> move away from the relational architecture and try to store all the information of a given object inside a<a id="_idIndexMarker428"/> single <strong class="bold">document</strong>. As such, performing a join query is much rarer and usually <span class="No-Break">more difficult.</span></p>&#13;
			<p>Those documents are stored <a id="_idIndexMarker429"/>in <strong class="bold">collections</strong>. Contrary to relational databases, documents in a collection might not have all of the same attributes: while tables in relational databases have a defined schema, collections accept any kind <span class="No-Break">of document.</span></p>&#13;
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em> shows a representation of our previous blog example, which has been adapted into a document-oriented database structure. In this configuration, we have chosen to have a collection for users and another one for posts. However, notice that the comments are now part <a id="_idIndexMarker430"/>of a post, directly included as <span class="No-Break">a list:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer025" class="IMG---Figure">&#13;
					<img src="Images/B19528_06_02.jpg" alt="Figure 6.2 — A document-oriented schema example for a blog application" width="1028" height="745"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 — A document-oriented schema example for a blog application</p>&#13;
			<p>To retrieve a post <a id="_idIndexMarker431"/>and all of its comments, you don’t need to perform a join query: all the data comes in one query. This was the main motivation behind the development of document-oriented databases: increase query performance by limiting the n<a id="_idTextAnchor365"/>eed to look at several collections. In particular, they proved to be useful for applications with huge data scales and less structured data, such as <span class="No-Break">so<a id="_idTextAnchor366"/>cial networks.</span></p>&#13;
			<h2 id="_idParaDest-103"><a id="_idTextAnchor367"/>Which one should you choose?</h2>&#13;
			<p>As we<a id="_idIndexMarker432"/> m<a id="_idTextAnchor368"/>entioned in the introduction to this section, your choice of database engine greatly depends on your application and needs. A deta<a id="_idTextAnchor369"/>iled comparison between relational and document-oriented databases is beyond the scope of this book, but let’s look at some elements for you to <span class="No-Break">think about.</span></p>&#13;
			<p>Relational databases are <a id="_idIndexMarker433"/>very good for storing structured data with a lot of relationships between entities. Besides, they maintain data consistency at all costs, even in the event of errors or hardware failures. However, you’ll have to precisely define your schema and consider a migration system to update your schema if your <span class="No-Break">needs evolve.</span></p>&#13;
			<p>On the other hand, document-oriented databases<a id="_idIndexMarker434"/> don’t require you to define a schema: they accept any document structure, so they can be convenient if your data is highly variable or if your project is not mature enough. The downside of this is that they are far less picky in terms of data consistency, which could result in data loss <span class="No-Break">or inconsistencies.</span></p>&#13;
			<p>For small and medium-sized applications, the choice doesn’t matter too much: both relational databases and document-oriented databases are very optimized and will deliver awesome performance at <span class="No-Break">such scales.</span></p>&#13;
			<p>Next, we’ll show you how to work with these different kinds of databases using FastAPI. When we introduced asynchronous I/O in <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specificities</em>, we mentioned that it was important to carefully select the libraries you use to perform I/O operations. Of course, databases are particularly important in <span class="No-Break">this context!</span></p>&#13;
			<p>While working with classic <a id="_idIndexMarker435"/>non-async libraries is perfectly possible in FastAPI, you could miss out on one of the key aspects of the framework and might not reach the best performance it can offer. That’s why, in this chapter, we’ll only focus o<a id="_idTextAnchor370"/>n <span class="No-Break">async libraries.</span></p>&#13;
			<h1 id="_idParaDest-104"><a id="_idTextAnchor371"/>Communicating with a SQL database with SQLAlchemy ORM</h1>&#13;
			<p>To begin, we’ll <a id="_idIndexMarker436"/>discuss how to work with a relational database using the SQLAlchemy library. SQLAlchemy has been around for years and is the most popular library in Python when you wish to work with SQL databases. Since version 1.4, it also natively <span class="No-Break">supports async.</span></p>&#13;
			<p>The key thing to understand about this library is that it’s composed of <span class="No-Break">two parts:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">SQLAlchemy Core</strong>, which<a id="_idIndexMarker437"/> provides all the fundamental features to read and write data to <span class="No-Break">SQL databases</span></li>&#13;
				<li><strong class="bold">SQLAlchemy ORM</strong>, which <a id="_idIndexMarker438"/>provides a powerful abstraction over <span class="No-Break">SQL concepts</span></li>&#13;
			</ul>&#13;
			<p>While you can choose to only use SQLAlchemy Core, it’s generally more convenient to use ORM. The goal of ORM is to abstract away the SQL concepts of tables and columns so that you only have to deal with Python objects. The role of ORM is to <em class="italic">map</em> those objects to the tables and columns they belong to and generate the corresponding SQL <span class="No-Break">queries automatically.</span></p>&#13;
			<p>The first step is to install <span class="No-Break">this library:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install "sqlalchemy[asyncio,mypy]"</pre>			<p>Notice that we added two optional dependencies: <strong class="source-inline">asyncio</strong> and <strong class="source-inline">mypy</strong>. The first one ensures the tools for async support <span class="No-Break">are installed.</span></p>&#13;
			<p>The second one is a special plugin for mypy that provides special support for SQLAlchemy. ORM does a lot of magic things under the hood, which are hard for type checkers to understand. With this plugin, mypy learns to recognize <span class="No-Break">those constructs.</span></p>&#13;
			<p>As we said in the introduction, numerous SQL engines exist. You have probably heard of PostgreSQL and MySQL, which are among the most popular. Another interesting choice is SQLite, a tiny engine that stores all the data inside a single file on your computer, without the need for complex server software. It’s ideal for testing and experimenting. To allow SQLAlchemy to talk to those engines, you’ll need to install the corresponding <strong class="bold">driver</strong>. Here are the async drivers you’ll need to install, depending on <span class="No-Break">your engine:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">PostgreSQL:</span><pre class="source-code">&#13;
<strong class="bold">(venv) $ pip install asyncpg</strong></pre></li>				<li><span class="No-Break">MySQL:</span><pre class="source-code">&#13;
<strong class="bold">(venv) $ pip install aiomysql</strong></pre></li>				<li><span class="No-Break">SQLite:</span><pre class="source-code">&#13;
<strong class="bold">(venv) $ pip install aiosqlite</strong></pre></li>			</ul>&#13;
			<p>For the rest of<a id="_idIndexMarker439"/> this section, we’ll work with SQLite databases. We’ll show you, step by step, how to set up a complete database interaction<a id="_idTextAnchor372"/>. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.4</em> shows the structure of <span class="No-Break">the project:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer026" class="IMG---Figure">&#13;
					<img src="Images/B19528_06_03.jpg" alt="Figure 6.3 – The FastAPI and SQLAlchemy project structure" width="352" height="400"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The FastAPI and SQLAlchemy project structure</p>&#13;
			<h2 id="_idParaDest-105"><a id="_idTextAnchor373"/>Creating ORM models</h2>&#13;
			<p>First, you need to define your <a id="_idIndexMarker440"/>ORM models. Each one is a Python class whose attributes represent the columns of your table. The actual entities of your database will be instances of this class, giving you access to its data, just like any other object. Under the hood, the role of SQLAlchemy ORM is to link this Python object and the row in the database. Let’s<a id="_idIndexMarker441"/> take a look at the definition of our blog <span class="No-Break">post model:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
from datetime import datetimefrom sqlalchemy import DateTime, Integer, String, Text&#13;
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column&#13;
class Base(DeclarativeBase):&#13;
    pass&#13;
class Post(Base):&#13;
    __tablename__ = "posts"&#13;
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)&#13;
    publication_date: Mapped[datetime] = mapped_column(&#13;
        DateTime, nullable=False, default=datetime.now&#13;
    )&#13;
    title: Mapped[str] = mapped_column(String(255), nullable=False)&#13;
    content: Mapped[str] = mapped_column(Text, nullable=False)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/models.py%0D">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/models.py</a></p>&#13;
			<p>The first step is to create a <strong class="source-inline">Base</strong> class that inherits from <strong class="source-inline">DeclarativeBase</strong>. <em class="italic">All our models will inherit from this class</em>. Internally, SQLAlchemy uses it to keep all the information about your database schema together. This is why you should create it only once in your whole project and always use the same <span class="No-Break">one throughout.</span></p>&#13;
			<p>Next, we must define our <strong class="source-inline">Post</strong> class. Once again, notice how it inherits from <strong class="source-inline">Base</strong>. Inside this class, we can define each of our columns in the form of class properties. They are assigned thanks to the <strong class="source-inline">mapped_column</strong> function, which helps us define the type of the column and its related properties. For example, we define our <strong class="source-inline">id</strong> column as an integer primary key with auto-increment, which is quite common in a <span class="No-Break">SQL database.</span></p>&#13;
			<p>Note that we won’t go through all the types and options provided by SQLAlchemy. Just know that they closely follow the ones that are usually provided by SQL databases. You can check the complete list in <a id="_idIndexMarker442"/>the official documentation, <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>You can find <a id="_idIndexMarker443"/>the list of types <span class="No-Break">at </span><a href="https://docs.sqlalchemy.org/en/20/core/type_basics.html#generic-camelcase-types%0D"><span class="No-Break">https://docs.sqlalchemy.org/en/20/core/type_basics.html#generic-camelcase-types</span></a></li>&#13;
				<li>You can find the list of <strong class="source-inline">mapped_column</strong> arguments<a id="_idIndexMarker444"/> <span class="No-Break">at </span><a href="https://docs.sqlalchemy.org/en/20/orm/mapping_api.html#sqlalchemy.orm.mapped_column%0D"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/mapping_api.html#sqlalchemy.orm.mapped_column</span></a></li>&#13;
			</ul>&#13;
			<p>Another interesting thing to notice here is that we added type hints to each property, which correspond to the Python type of our columns. This will greatly help us during development: for example, if we try to get the <strong class="source-inline">title</strong> property of a post object, the type checker will know it’s a string. For this to work, notice that we wrap each type with the <strong class="source-inline">Mapped</strong> class. This is a special class provided by SQLAlchemy so that the type checker can understand the underlying type of the data when we assign it a <span class="No-Break"><strong class="source-inline">MappedColumn</strong></span><span class="No-Break"> object.</span></p>&#13;
			<p class="callout-heading">This is how you declare models in SQLAlchemy 2.0</p>&#13;
			<p class="callout">The way we’ll show you to declare models in this section is the newest way to do so, as introduced in <span class="No-Break">SQLAlchemy 2.0.</span></p>&#13;
			<p class="callout">If you look at older tutorials or documentation on the web, you’ll probably come across a slightly different way where we assign properties to a <strong class="source-inline">Column</strong> object. While this older style still works in SQLAlchemy 2.0, it should be <span class="No-Break">considered deprecated.</span></p>&#13;
			<p>We now have a <a id="_idIndexMarker445"/>model that will help us read and write post data to our database. However, as you’re now aware, with FastAPI, we’ll also need Pydantic models so that we can validate input data and output the right representation in our API. If you need a refresher about this, you can check <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API </em><span class="No-Break"><em class="italic">with FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-106"><a id="_idTextAnchor374"/>Defining Pydantic models</h2>&#13;
			<p>As we said, if we want to correctly <a id="_idIndexMarker446"/>validate the data coming in and out of our FastAPI application, we’ll need Pydantic models. In an ORM context, they will help us <em class="italic">go back and forth with the ORM model</em>. That’s the key takeaway of this section: we’ll use Pydantic models to validate and serialize the data, but the database communication will be done with the <span class="No-Break">ORM model.</span></p>&#13;
			<p>To avoid confusion, we’ll now refer to Pydantic models <a id="_idIndexMarker447"/>as <strong class="bold">schemas</strong>. When we talk about models, we’ll be referring to the <span class="No-Break">ORM model.</span></p>&#13;
			<p>That’s why the definitions of those schemas are placed in the <strong class="source-inline">schemas.py</strong> module, which can be <span class="No-Break">seen here:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">schemas.py</p>&#13;
			<pre class="source-code">&#13;
from datetime import datetimefrom pydantic import BaseModel, Field&#13;
class PostBase(BaseModel):&#13;
    title: str&#13;
    content: str&#13;
    publication_date: datetime = Field(default_factory=datetime.now)&#13;
    class Config:&#13;
        orm_mode = True&#13;
class PostPartialUpdate(BaseModel):&#13;
    title: str | None = None&#13;
    content: str | None = None&#13;
class PostCreate(PostBase):&#13;
    pass&#13;
class PostRead(PostBase):&#13;
    id: int</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/schemas.py%0D">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/schemas.py</a></p>&#13;
			<p>The<a id="_idIndexMarker448"/> preceding code corresponds to the pattern we explained in <a href="B19528_04.xhtml#_idTextAnchor176"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Managing Pydantic Data Models </em><span class="No-Break"><em class="italic">in FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<p>There is a new thing, though: you probably noticed the <strong class="source-inline">Config</strong> subclass, which is defined in <strong class="source-inline">PostBase</strong>. It’s a way to add some configuration options to Pydantic schemas. Here, we set the <strong class="source-inline">orm_mode</strong> option to <strong class="source-inline">True</strong>. As its name suggests, it’s an option to make Pydantic work better with ORM. In a standard setting, Pydantic is designed to parse data from dictionaries: if it wants to parse the <strong class="source-inline">title</strong> property, it’ll use <strong class="source-inline">d["title"]</strong>. With ORM, however, we access the properties like an object – that is, by using dot notation (<strong class="source-inline">o.title</strong>). Enabling ORM mode allo<a id="_idTextAnchor375"/>ws Pydantic to use <span class="No-Break">this style.</span></p>&#13;
			<h2 id="_idParaDest-107">Connect<a id="_idTextAnchor376"/>ing to a database</h2>&#13;
			<p>Now that <a id="_idIndexMarker449"/>our model and schemas are ready, we have to set up the connection between our FastAPI app and the database engine. For this, we’ll create a <strong class="source-inline">database.py</strong> module where we’ll put the objects we need for <span class="No-Break">this task:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">database.py</p>&#13;
			<pre class="source-code">&#13;
from collections.abc import AsyncGeneratorfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine&#13;
from chapter06.sqlalchemy.models import Base&#13;
DATABASE_URL = "sqlite+aiosqlite:///chapter06_sqlalchemy.db"&#13;
engine = create_async_engine(DATABASE_URL)&#13;
async_session_maker = async_sessionmaker(engine, expire_on_commit=False)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py%0D">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py</a></p>&#13;
			<p>Here, you can see that we have set our connection string inside the <strong class="source-inline">DATABASE_URL</strong> variable. Generally, it consists of <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>The database engine. Here, we <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">sqlite</strong></span><span class="No-Break">.</span></li>&#13;
				<li>Optionally, the driver, after a plus sign. Here, we set <strong class="source-inline">aiosqlite</strong>. In an async context, it’s necessary to specify the async driver we want to use. Otherwise, SQLAlchemy will fall back to a standard, <span class="No-Break">synchronous driver.</span></li>&#13;
				<li>Optionally, the <span class="No-Break">authentication information.</span></li>&#13;
				<li>The hostname of the database server. In the case of SQLite, we simply have to specify the path of the file that will store all <span class="No-Break">the data.</span></li>&#13;
			</ul>&#13;
			<p>You can find an overview of this format in the official SQLAlchemy documentation <span class="No-Break">at </span><a href="https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls"><span class="No-Break">https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls</span></a><span class="No-Break">.</span></p>&#13;
			<p>Then, we create an engine using the <strong class="source-inline">create_async_engine</strong> function and this URL. An engine is an object where SQLAlchemy will manage the connection with your database. At this point, it’s important to understand that no connection is being made: we are just <span class="No-Break">declaring things.</span></p>&#13;
			<p>We then have a more cryptic line to define the <strong class="source-inline">async_session_maker</strong> variable. We won’t go too much into the details of the <strong class="source-inline">async_sessionmaker</strong> function. Just know that it returns a <a id="_idIndexMarker450"/>function so that we can <a id="_idIndexMarker451"/>generate <strong class="bold">sessions</strong> tied to our <span class="No-Break">database engine.</span></p>&#13;
			<p>What is a session? It’s a<a id="_idIndexMarker452"/> concept defined by ORM. A session will establish an actual connection with the database and represent a <em class="italic">zone</em> where it’ll store all the objects you’ve read from the database and all the ones you’ve defined that’ll be written to the database. It’s the proxy between the ORM concepts and the fundamental <span class="No-Break">SQL queries.</span></p>&#13;
			<p>When building HTTP servers, we usually <em class="italic">open a fresh session when the request starts</em> and <em class="italic">close it when we answered the request</em>. Therefore, each HTTP request represents a unit of work with the database. That’s why we must define a FastAPI dependency whose role is to yield us a <span class="No-Break">fresh session:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">database.py</p>&#13;
			<pre class="source-code">&#13;
async def get_async_session() -&gt; AsyncGenerator[AsyncSession, None]:    async with async_session_maker() as session:&#13;
        yield session</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py</a></p>&#13;
			<p>Having it as a dependency will greatly help us when implementing our path <span class="No-Break">operation functions.</span></p>&#13;
			<p>So far, we haven’t had<a id="_idIndexMarker453"/> the opportunity to talk about the <strong class="source-inline">with</strong> synta<a id="_idTextAnchor377"/>x. In Python, this is what’s called a <strong class="bold">context manager</strong>. Simply <a id="_idIndexMarker454"/>put, it’s a convenient syntax for objects that need to execute <em class="italic">setup logic</em> when they are used and <em class="italic">teardown logic</em> when they are not needed anymore. When you <em class="italic">enter</em> the <strong class="source-inline">with</strong> block, the object automatically executes the setup logic. When you <em class="italic">exit</em> the block, it executes its teardown logic. You can read more about context managers in the Python <span class="No-Break">documentation: </span><a href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers"><span class="No-Break">https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers</span></a><span class="No-Break">.</span></p>&#13;
			<p>In our case, <strong class="source-inline">async_session_maker</strong> works as a context manager. Among other things, it takes care of opening a connection to <span class="No-Break">the database.</span></p>&#13;
			<p>Notice that we define a generator here by using <strong class="source-inline">yield</strong>. This is important because it ensures that the <em class="italic">session remains open until the end of the request</em>. If we were to use a simple <strong class="source-inline">return</strong> statement, the context manager would close immediately. With <strong class="source-inline">yield</strong>, we make sure we only get out of the context manager when the request and our endpoint logic have been fully handled <span class="No-Break">by FastAPI.</span></p>&#13;
			<p class="callout-heading">Using a dependency to retrieve a database instance</p>&#13;
			<p class="callout">You might be wondering why we don’t just call <strong class="source-inline">async_session_maker</strong> directly in our path operation functions rather than using a dependency. This would work, but it would make our life very hard when we try to implement unit tests. Indeed, it would be very difficult to replace this instance with a mock or test database. With a dependency, FastAPI makes it very easy to swap it with another function. We’ll see this in more detail in <a href="B19528_09.xhtml#_idTextAnchor618"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Testing an API Asynchronously with pytest </em><span class="No-Break"><em class="italic">and HTTPX</em></span><span class="No-Break">.</span></p>&#13;
			<p>The last thing we <a id="_idIndexMarker455"/>must define in this module is the <strong class="source-inline">create_all_tables</strong> function. Its goal is to create the table’s schema inside our database. If we don’t do that, our database will be empty and we wouldn’t be able to save or retrieve data. <a id="_idIndexMarker456"/>Creating a schema like this is a simple approach that’s only suitable for simple examples and experiments. In a real-world application, you should have a proper migration system whose role is to make sure your database schema is in sync. We’ll learn how to set one up for SQLAlchemy later in <span class="No-Break">this chapter.</span></p>&#13;
			<p>To make sure our schema is created when our application starts, we must call this function the <strong class="bold">lifespan handler</strong> of FastAPI. This is useful to execute some logic when the application is started and stopped. That's what we'll do in our <span class="No-Break"><strong class="source-inline">app.py</strong></span><span class="No-Break"> module:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@contextlib.asynccontextmanagerasync def lifespan(app: FastAPI):&#13;
    await create_all_tables()&#13;
    yield</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition<span id="_idTextAnchor378"/>/tree/main/chapter06/sqlalchemy/app.py</a></p>&#13;
			<h2 id="_idParaDest-108">Cre<a id="_idTextAnchor379"/>ating objects</h2>&#13;
			<p>Let’s start by inserting <a id="_idIndexMarker457"/>new objects inside our database. The main challenge is to take a Pydantic schema as input, transform it into a SQLAlchemy model, and save it in the database. Let’s review this process, which is shown in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post(    "/posts", response_model=schemas.PostRead, status_code=status.HTTP_201_CREATED&#13;
)&#13;
async def create_post(&#13;
    post_create: schemas.PostCreate, session: AsyncSession = Depends(get_async_session)&#13;
) -&gt; Post:&#13;
    post = Post(**post_create.dict())&#13;
    session.add(post)&#13;
    await session.commit()&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/ch<span id="_idTextAnchor380"/>apter06/sqlalchemy/app.py</a></p>&#13;
			<p>Here, we have our <strong class="source-inline">POST</strong> endpoint, which accepts our <strong class="source-inline">PostCreate</strong> schema. Notice that we inject a fresh SQLAlchemy session using our <strong class="source-inline">get_async_session</strong> dependency. The core logic consists of <span class="No-Break">two operations.</span></p>&#13;
			<p>First, we transform <strong class="source-inline">post_create</strong> into a full <strong class="source-inline">Post</strong> model object. For this, we can simply call the <strong class="source-inline">dict</strong> method of Pydantic and <em class="italic">unpack</em> it with <strong class="source-inline">**</strong> to directly assign the properties. At this point, the post is not in the database yet: we need to tell the session <span class="No-Break">about it.</span></p>&#13;
			<p>The first step is to <em class="italic">add it in the session</em>, through the <strong class="source-inline">add</strong> method. Now, the post is in the session memory, but not in the database yet. By calling the <strong class="source-inline">commit</strong> method, we tell the session to generate the appropriate SQL queries and execute them on the database. As we might expect, we see that we need to <em class="italic">await</em> this method: we perform an I/O operation on the database, so it’s an <span class="No-Break">async operation.</span></p>&#13;
			<p>Finally, we can just<a id="_idIndexMarker458"/> return the <strong class="source-inline">post</strong> object. You may be surprised that we directly return a SQLAlchemy ORM object rather than a Pydantic schema. How could FastAPI correctly serialize it with the properties we specified? If you pay attention, you’ll see that we set the <strong class="source-inline">response_model</strong> property in the path operation decorator. As you may recall from the <em class="italic">Response model</em> section of <a href="B19528_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing a RESTful API with FastAPI</em>, you’ll understand what is going on: FastAPI will automatically take care of transforming the ORM object into the specified schema. And that’s exactly why we need to enable <strong class="source-inline">orm_mode</strong> of Pydantic, as shown in the <span class="No-Break">previous section!</span></p>&#13;
			<p>From this, you can see that the implementation is quite straightforward. Now, let’s retrieve <span class="No-Break">this data!</span></p>&#13;
			<h2 id="_idParaDest-109">Getting a<a id="_idTextAnchor381"/>nd filtering objects</h2>&#13;
			<p>U<a id="_idTextAnchor382"/>sually, a REST API provides two <a id="_idIndexMarker459"/>types of endpoints to read data: one to list objects and one to get a specific <a id="_idIndexMarker460"/>object. This is exactly what we’ll <span class="No-Break">review next!</span></p>&#13;
			<p>In the following example, you can see how we implemented the endpoint to <span class="No-Break">list objects:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/posts", response_model=list[schemas.PostRead])async def list_posts(&#13;
    pagination: tuple[int, int] = Depends(pagination),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
) -&gt; Sequence[Post]:&#13;
    skip, limit = pagination&#13;
    select_query = select(Post).offset(skip).limit(limit)&#13;
    result = await session.execute(select_query)&#13;
    return result.scalars().all()</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py</a></p>&#13;
			<p>The operation is performed in two steps. First, we build a query. The <strong class="source-inline">select</strong> function of SQLAlchemy allows us to begin defining a query. Conveniently, we can directly pass it the <strong class="source-inline">model</strong> class: it’ll automatically understand which table we are talking about. From there, we can apply various methods and filters, which are a mirror of what we could expect in pure SQL. Here, we’re able to apply our pagination parameters through <strong class="source-inline">offset</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">limit</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Then, we execute this query using the <strong class="source-inline">execute</strong> method of a fresh session object (which was, once again, injected by our dependency). Since we read data from the database, it’s an <span class="No-Break">async operation.</span></p>&#13;
			<p>From this, we get a <strong class="source-inline">result</strong> object. This object is an instance of the <strong class="source-inline">Result</strong> class of SQLAlchemy. It’s not directly our list of posts, but rather a set representing the results of the SQL query. That’s why we need to call <strong class="source-inline">scalars</strong> and <strong class="source-inline">all</strong>. The first one will make sure we get actual <strong class="source-inline">Post</strong> objects, while the second will return them as <span class="No-Break">a sequence.</span></p>&#13;
			<p>Once again, we can <a id="_idIndexMarker461"/>directly return those SQLAlchemy ORM objects: FastAPI will transform them into the <a id="_idIndexMarker462"/>correct schema thanks to the <span class="No-Break"><strong class="source-inline">response_model</strong></span><span class="No-Break"> setting.</span></p>&#13;
			<p>Now, let’s see how we can retrieve a single post <span class="No-Break">by ID:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/posts/{id}", response_model=schemas.PostRead)async def get_post(post: Post = Depends(get_post_or_404)) -&gt; Post:&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sql<span id="_idTextAnchor383"/>alchemy/app.py</a></p>&#13;
			<p>This is a simple <strong class="source-inline">GET</strong> endpoint that expects the ID of the post <a id="_idTextAnchor384"/>in the path parameter. The implementation is very light: we just return the post. Most of the logic is in the <strong class="source-inline">get_post_or_404</strong> dependency, which we’ll reuse often in our application. Here is <span class="No-Break">its implementation:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def get_post_or_404(    id: int, session: AsyncSession = Depends(get_async_session)&#13;
) -&gt; Post:&#13;
    select_query = select(Post).where(Post.id == id)&#13;
    result = await session.execute(select_query)&#13;
    post = result.scalar_one_or_none()&#13;
    if post is None:&#13;
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py</a></p>&#13;
			<p>As you can see, it’s quite similar to what we’ve seen for the list endpoint. We also start by building a select query, but this time, we add a <strong class="source-inline">where</strong> clause so that we can retrieve only the post matching the desired ID. The clause itself might <span class="No-Break">look strange.</span></p>&#13;
			<p>First, we must set the actual column we want to compare. Indeed, when you access the properties of the <strong class="source-inline">model</strong> class directly, such as <strong class="source-inline">Post.id</strong>, SQLAlchemy automatically understands that you are referring to <span class="No-Break">the column.</span></p>&#13;
			<p>Then, we use the <a id="_idIndexMarker463"/>equality operator to compare the column with our actual <strong class="source-inline">id</strong> variable. It looks like a standard comparison that would result in a Boolean, not a SQL statement! In a general Python context, it would. However, SQLAlchemy developers have done something clever here: they overloaded the standard operators so that they produce SQL expressions instead of comparing objects. This is exactly what we saw in the <em class="italic">Magic methods</em> section of <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python </em><span class="No-Break"><em class="italic">Programming Specificities</em></span><span class="No-Break">.</span></p>&#13;
			<p>Now, we can simply<a id="_idIndexMarker464"/> execute the query and call <strong class="source-inline">scalar_one_or_none</strong> on the result set. It’s a convenient shortcut that tells SQLAlchemy to return a single object if it exists, or <span class="No-Break"><strong class="source-inline">None</strong></span><span class="No-Break"> otherwise.</span></p>&#13;
			<p>If the result is <strong class="source-inline">None</strong>, we can raise a <strong class="source-inline">404</strong> error: no post is matching this<a id="_idTextAnchor385"/> ID. Otherwise, we can simply return <span class="No-Break">the post.</span><a id="_idTextAnchor386"/></p>&#13;
			<h2 id="_idParaDest-110">Updating an<a id="_idTextAnchor387"/>d deleting objects</h2>&#13;
			<p>We’ll finish by<a id="_idIndexMarker465"/> showing <a id="_idIndexMarker466"/>you how to update and delete existing objects. You’ll see it’s just a matter of manipulating the ORM object and calling the right method <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">session</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Check out the following code and review the implementation of the <span class="No-Break"><strong class="source-inline">update</strong></span><span class="No-Break"> endpoint:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.patch("/posts/{id}", response_model=schemas.PostRead)async def update_post(&#13;
    post_update: schemas.PostPartialUpdate,&#13;
    post: Post = Depends(get_post_or_404),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
) -&gt; Post:&#13;
    post_update_dict = post_update.dict(exclude_unset=True)&#13;
    for key, value in post_update_dict.items():&#13;
        setattr(post, key, value)&#13;
    session.add(post)&#13;
    await session.commit()&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py</a></p>&#13;
			<p>Here, the <a id="_idIndexMarker467"/>main point of attention is that we’ll operate directly on the post we want to modify. This is one of the <a id="_idIndexMarker468"/>key aspects when working with ORM: entities are objects that can be modified as you wish. When you are happy with the data, you can persist it in the database. This is exactly what we are doing here: we get a fresh representation of our post thanks to <strong class="source-inline">get_post_or_404</strong>. Then, we transform the <strong class="source-inline">post_update</strong> schema into a dictionary, and we iterate over the properties to set them on our ORM object. Finally, we can save it in the session and commit it to the database, as we did <span class="No-Break">for creation.</span></p>&#13;
			<p>The same <a id="_idIndexMarker469"/>concept is <a id="_idIndexMarker470"/>applied when you wish to delete an object: when you have an instance, you can pass it to the <strong class="source-inline">delete</strong> method of <strong class="source-inline">session</strong> so that it can schedule it for removal. You can view this in action in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)async def delete_post(&#13;
    post: Post = Depends(get_post_or_404),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
):&#13;
    await session.delete(post)&#13;
    await session.commit()</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py</a></p>&#13;
			<p>Throughout these examples, you’ve seen that we always call <strong class="source-inline">commit</strong> after a write operation: your changes must be written in the database. Otherwise, <a id="_idTextAnchor388"/>they’ll just stay in the session memory and <a id="_idTextAnchor389"/><span class="No-Break">be lost.</span></p>&#13;
			<h2 id="_idParaDest-111"><a id="_idTextAnchor390"/>Adding relationships</h2>&#13;
			<p>As we<a id="_idIndexMarker471"/> mentioned at the beginning of this chapter, relational databases are all about data and its relationships. Quite often, you’ll need to create entities that are linked to others. For example, in a blog application, comments are linked to the post they relate to. In this section, we’ll examine how you can set up such relationships with <span class="No-Break">SQLAlchemy ORM.</span></p>&#13;
			<p>First, we need <a id="_idIndexMarker472"/>to define a new model for comments. This new model must be placed above <strong class="source-inline">Post</strong> in the code. We’ll explain why this matters later. You can view its definition in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
class Comment(Base):    __tablename__ = "comments"&#13;
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)&#13;
    post_id: Mapped[int] = mapped_column(ForeignKey("posts.id"), nullable=False)&#13;
    publication_date: Mapped[datetime] = mapped_column(&#13;
        DateTime, nullable=False, default=datetime.now&#13;
    )&#13;
    content: Mapped[str] = mapped_column(Text, nullable=False)&#13;
    post: Mapped["Post"] = relationship("Post", back_populates="comments")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06<span id="_idTextAnchor391"/>/sqlalchemy_relationship/models.py</a></p>&#13;
			<p>The important point here is the <strong class="source-inline">post_id</strong> column, which is of the <strong class="source-inline">ForeignKey</strong> type. This is a special type that tells SQLAlchemy to automatically handle the type of the column and the associated constraint. We simply have to give the table and column names it <span class="No-Break">refers to.</span></p>&#13;
			<p>But that’s only the SQL part of the definition. We now need to tell ORM that our <strong class="source-inline">Comment</strong> object has a relationship with a <strong class="source-inline">Post</strong> object. This is the purpose of the <strong class="source-inline">post</strong> property, which is assigned to the <strong class="source-inline">relationship</strong> function. It’s a special function exposed by SQLAlchemy ORM to <em class="italic">define how models relate to each other</em>. It won’t create a new column in the SQL definition – that’s the role of the <strong class="source-inline">ForeignKey</strong> column – but it’ll allow us to directly get the <strong class="source-inline">Post</strong> object linked to a comment by using <strong class="source-inline">comment.post</strong>. You can also see that we define the <strong class="source-inline">back_populates</strong> argument. It allows us to do the opposite operation – that is, get the list of comments from a post. The name of this <a id="_idIndexMarker473"/>option determines the name of the property we’ll use to access the comment. Here, this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">post.comments</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">Forward reference type hint</p>&#13;
			<p class="callout">If you look at the type hint of the post property, you will see that we correctly set it to the <strong class="source-inline">Post</strong> class. However, we put it inside quotes: <strong class="source-inline">post: "Post" = …</strong>.</p>&#13;
			<p class="callout">This is what is called a <strong class="bold">forward reference</strong>. In some <a id="_idIndexMarker474"/>cases, the type hint we want is not yet defined. That’s our case here since <strong class="source-inline">Post</strong> is defined after <strong class="source-inline">Comment</strong>. If we forget the quotes, Python will complain because we are trying to access something that doesn’t exist yet. To solve this, we can put it inside quotes. Type checkers are smart enough to understand what you are <span class="No-Break">referring to.</span></p>&#13;
			<p>Now, if you look at the <strong class="source-inline">Post</strong> model, as follows, you’ll see that we added <span class="No-Break">one thing:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
class Post(Base):    __tablename__ = "posts"&#13;
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)&#13;
    publication_date: Mapped[datetime] = mapped_column(&#13;
        DateTime, nullable=False, default=datetime.now&#13;
    )&#13;
    title: Mapped[str] = mapped_column(String(255), nullable=False)&#13;
    content: Mapped[str] = mapped_column(Text, nullable=False)&#13;
    comments: Mapped[list[Comment]] = relationship("Comment", cascade="all, delete")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py</a></p>&#13;
			<p>We also <a id="_idIndexMarker475"/>defined the mirror relationship, taking care of <em class="italic">naming with the same name we chose for </em><strong class="source-inline">back_populates</strong>. This time, we also set the <strong class="source-inline">cascade</strong> argument, which allows us to define the behavior of ORM when we delete a post: should we implicitly delete the comments as well? Or should we keep them as orphans? In this case, we chose to delete them. Note that it’s <em class="italic">not the same thing</em> as the <strong class="source-inline">CASCADE DELETE</strong> construct of SQL: it has the same effect, but it will be handled by ORM in the Python code, not by the <span class="No-Break">SQL database.</span></p>&#13;
			<p>There are a lot of options regarding relationships, all of which you can find in the official <span class="No-Break">documentation: </span><a href="https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship%0D"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship</span><span class="No-Break">.</span></a></p>&#13;
			<p>Once again, adding this <strong class="source-inline">comments</strong> property doesn’t change the SQL definition: it’s just a way to wire things for ORM, on the <span class="No-Break">Python side.</span></p>&#13;
			<p>Now, we can define the Pydantic schemas for our comment entity. They are quite straightforward, so we won’t go into the details. However, notice how we added the <strong class="source-inline">comments</strong> property to the <span class="No-Break"><strong class="source-inline">PostRead</strong></span><span class="No-Break"> schema:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">schemas.py</p>&#13;
			<pre class="source-code">&#13;
class PostRead(PostBase):    id: int&#13;
    comments: list[CommentRead]</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/schemas.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/schemas.py</a></p>&#13;
			<p>Indeed, in a <a id="_idIndexMarker476"/>REST API, there are some cases where it makes sense to automatically retrieve the associated objects of an entity. Here, it’ll be convenient to get the comments of a post in a single request. This schema will allow us to <em class="italic">serialize the comments, <a id="_idTextAnchor392"/>along with the </em><span class="No-Break"><em class="italic">post data</em></span><span class="No-Break">.</span></p>&#13;
			<p>Now, we’ll implement an endpoint to create a new comment. This is shown in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post(    "/posts/{id}/comments",&#13;
    response_model=schemas.CommentRead,&#13;
    status_code=status.HTTP_201_CREATED,&#13;
)&#13;
async def create_comment(&#13;
    comment_create: schemas.CommentCreate,&#13;
    post: Post = Depends(get_post_or_404),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
) -&gt; Comment:&#13;
    comment = Comment(**comment_create.dict(), post=post)&#13;
    session.add(comment)&#13;
    await session.commit()&#13;
    return comment</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py</a></p>&#13;
			<p>This endpoint is defined, so we need to set the post ID directly in the path. It allows us to reuse the <strong class="source-inline">get_post_or_404</strong> dependency and automatically have a <strong class="source-inline">404</strong> error occur if we try to add a comment to a <span class="No-Break">non-existing post.</span></p>&#13;
			<p>Other than that, it’s very similar to what we saw in the <em class="italic">Creating objects</em> section of this chapter. The only point of attention here is that we manually set the <strong class="source-inline">post</strong> property on this new <strong class="source-inline">comment</strong> object. Thanks to the relationship definition, we can directly assign the <strong class="source-inline">post</strong> object, and ORM will automatically set the right value in the <span class="No-Break"><strong class="source-inline">post_id</strong></span><span class="No-Break"> column.</span></p>&#13;
			<p>Earlier, we <a id="_idIndexMarker477"/>mentioned that we wanted to retrieve a post and its comments at the same time. To do this, we’ll have to tweak our queries a bit when getting posts. The following sample shows what we did for the <strong class="source-inline">get_post_or_404</strong> function, but the same goes for the <span class="No-Break">list endpoint:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def get_post_or_404(    id: int, session: AsyncSession = Depends(get_async_session)&#13;
) -&gt; Post:&#13;
    select_query = (&#13;
        select(Post).options(selectinload(Post.comments)).where(Post.id == id)&#13;
    )&#13;
    result = await session.execute(select_query)&#13;
    post = result.scalar_one_or_none()&#13;
    if post is None:&#13;
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py</a></p>&#13;
			<p>As you can see, we<a id="_idIndexMarker478"/> added a call to <strong class="source-inline">options</strong> with a <strong class="source-inline">selectinload</strong> construct. This is a way to tell ORM to automatically retrieve the associated comments of the post when performing the query. If we don’t do this, we’ll get an error. Why? Because of the async nature of our queries. But let’s start from <span class="No-Break">the beginning.</span></p>&#13;
			<p>In a classic synchronous ORM context, you can <span class="No-Break">do this:</span></p>&#13;
			<pre class="source-code">&#13;
comments = post.comments</pre>			<p>If <strong class="source-inline">comments</strong> was not loaded in the first request, synchronous ORM will implicitly perform a new query on the SQL database. It’s invisible to the user, but an I/O operation is performed. This is <a id="_idIndexMarker479"/>called <strong class="bold">lazy loading</strong>, and it’s the default behavior for relationships <span class="No-Break">in SQLAlchemy.</span></p>&#13;
			<p>However, in an async context, I/O operations can’t be done implicitly: we have to <em class="italic">await</em> them. This is why you will get an error if you forget to explicitly load the relationship into the first query. When Pydantic tries to serialize the <strong class="source-inline">PostRead</strong> schema, it’ll try to reach <strong class="source-inline">post.comments</strong>, but SQLAlchemy can’t perform this <span class="No-Break">implicit query.</span></p>&#13;
			<p>So, when working with async, you need to <a id="_idIndexMarker480"/>perform <strong class="bold">eager loading</strong> on the relationships you want to access directly from the ORM object. Admittedly, this is way less convenient than its sync counterpart. However, it has a massive advantage: you <em class="italic">finely control which queries are made</em>. Indeed, with a synchronous ORM, it’s quite usual to have bad performance on an endpoint because the code performs dozens of implicit queries. With an asynchronous ORM, you can make sure you load everything in a single or few queries. It’s a trade-off that can pay in the <span class="No-Break">long run.</span></p>&#13;
			<p class="callout-heading">Eager loading can be configured on the relationship</p>&#13;
			<p class="callout">If you’re sure that you’ll always need to load the related objects of an entity, regardless of the context, you can define the eager loading strategy directly on the <strong class="source-inline">relationship</strong> function. This way, you won’t need to set it on each query. You can read more about this in the official <span class="No-Break">documentation: </span><a href="https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy</span></a><span class="No-Break">.</span></p>&#13;
			<p>Essentially, that’s it<a id="_idIndexMarker481"/> for working with relationships with SQLAlchemy ORM. You’ve seen that the key thing is to correctly define the relations<a id="_idTextAnchor393"/>hip so that ORM can understand how objects are <span class="No-Break">linked tog<a id="_idTextAnchor394"/>ether.</span></p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor395"/>Setting up a database migration system with Alembic</h2>&#13;
			<p>Whe<a id="_idTextAnchor396"/>n developing<a id="_idIndexMarker482"/> an application, you’ll li<a id="_idTextAnchor397"/>kely make changes to your database schema to add new tables, add new columns, or modify existing ones. Of course, if your application is already in production, you don’t want to erase all your data to recreate the schema from scratch: you want it to be migrated to the new schema. Tools for this task have been developed, and in this section, we’ll learn how to set up <em class="italic">Alembic</em>, from the creators of SQLAlchemy. Let’s install <span class="No-Break">this library:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install alembic</pre>			<p>Once you’ve done this, you’ll have access to the <strong class="source-inline">alembic</strong> command to manage this migration system. When starting a new project, the first thing you must do is initialize the migration environment, which includes a set of files and directories where Alembic will store its configuration and migration files. At the root of your project, ru<a id="_idTextAnchor398"/>n the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ alembic init alembic</pre>			<p>This will cre<a id="_idTextAnchor399"/>ate a directory, named <a id="_idTextAnchor400"/><strong class="source-inline">alembic</strong>, at the root of your project. You can view the result of this command in the example repository shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer027" class="IMG---Figure">&#13;
					<img src="Images/B19528_06_04.jpg" alt="Figure 6.4 – The Alembic migration environment structure" width="504" height="761"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The Alembic migration environment structure</p>&#13;
			<p>This folder will<a id="_idIndexMarker483"/> contain all the configurations for your migrations and your migration scripts themselves. It should be committed along with your code so that you have a record of the versions of <span class="No-Break">those files.</span></p>&#13;
			<p>Additionally, note that it created an <strong class="source-inline">alembic.ini</strong> file, which contains all the configuration options of Alembic. We’ll review one important setting in this file: <strong class="source-inline">sqlalchemy.url</strong>. This can be seen in the <span class="No-Break">following code:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">alembic.ini</p>&#13;
			<pre class="source-code">&#13;
sqlalchemy.url = sqlite:///chapter06_sqlalchemy_relationship.db</pre>			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic.ini">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic.ini</a></p>&#13;
			<p>Predictably, this is<a id="_idIndexMarker484"/> the connection string of your database that will receive the migration queries. It follows the same convention that we saw earlier. Here, we set our SQLite database. However, note that we don’t set the <strong class="source-inline">aiosqlite</strong> driver: Alembic will only work with synchronous drivers. It’s not a big deal since it’ll only run in dedicated scripts to <span class="No-Break">perform migrations.</span></p>&#13;
			<p>Next, we’ll focus on the <strong class="source-inline">env.py</strong> file. This is a Python script that contains all the logic executed by Alembic to initialize the migration engine and execute the migrations. Being a Python script, it allows us to finely customize the execution of Alembic. For the time being, we’ll keep the default one, except for one thing: we’ll import our <strong class="source-inline">Base</strong> object. You can view this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">env.py</p>&#13;
			<pre class="source-code">&#13;
from chapter06.sqlalchemy_relationship.models import Base# this is the Alembic Config object, which provides&#13;
# access to the values within the .ini file in use.&#13;
config = context.config&#13;
# Interpret the config file for Python logging.&#13;
# This line sets up loggers basically.&#13;
if config.config_file_name is not None:&#13;
    fileConfig(config.config_file_name)&#13;
# add your model's MetaData object here&#13;
# for 'autogenerate' support&#13;
# from myapp import mymodel&#13;
# target_metadata = mymodel.Base.metadata&#13;
target_metadata = Base.metadata</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/env.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main<span id="_idTextAnchor401"/>/chapter06/sqlalchemy_relationship/alembic/env.py</a></p>&#13;
			<p>By def<a id="_idTextAnchor402"/>ault, the file defines<a id="_idTextAnchor403"/> a variable named <strong class="source-inline">target_metadata</strong>, which is set to <strong class="source-inline">None</strong>. Here, we changed it so that it refers to the <strong class="source-inline">Base.metadata</strong> object we imported from our <strong class="source-inline">models</strong> module. But why do we do that? Well, recall that <strong class="source-inline">Base</strong> is a SQLAlchemy object that contains all the information about your database schema. By providing it to Alembic, the migration system will be able to <em class="italic">automatically generate the migration scripts</em> just by looking at your schema! This way, you won’t have to write them <span class="No-Break">from scratch.</span></p>&#13;
			<p>Once you have <a id="_idIndexMarker485"/>made changes to your database schema, you can run the following command to generate a new <span class="No-Break">migration script:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ alembic revision --autogenerate -m "Initial migration<a id="_idTextAnchor404"/>"</pre>			<p>This will create a<a id="_idTextAnchor405"/> new script in the <strong class="source-inline">versions</strong> directory with the commands reflecting your schema changes. This file defines two functions: <strong class="source-inline">upgrade</strong> and <strong class="source-inline">downgrade</strong>. You can view <strong class="source-inline">upgrade</strong> in the <span class="No-Break">following snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">eabd3f9c5b64_initial_migration.py</p>&#13;
			<pre class="source-code">&#13;
def upgrade() -&gt; None:    # ### commands auto generated by Alembic - please adjust! ###&#13;
    op.create_table(&#13;
        "posts",&#13;
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),&#13;
        sa.Column("publication_date", sa.DateTime(), nullable=False),&#13;
        sa.Column("title", sa.String(length=255), nullable=False),&#13;
        sa.Column("content", sa.Text(), nullable=False),&#13;
        sa.PrimaryKeyConstraint("id"),&#13;
    )&#13;
    op.create_table(&#13;
        "comments",&#13;
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),&#13;
        sa.Column("post_id", sa.Integer(), nullable=False),&#13;
        sa.Column("publication_date", sa.DateTime(), nullable=False),&#13;
        sa.Column("content", sa.Text(), nullable=False),&#13;
        sa.ForeignKeyConstraint(&#13;
            ["post_id"],&#13;
            ["posts.id"],&#13;
        ),&#13;
        sa.PrimaryKeyConstraint("id"),&#13;
    )&#13;
    # ### end Alembic commands ###</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py</a></p>&#13;
			<p>This function<a id="_idIndexMarker486"/> is executed when we <em class="italic">apply the migration</em>. It describes the requ<a id="_idTextAnchor406"/>ired operations to create our <strong class="source-inline">posts</strong> and <strong class="source-inline">comments</strong> table, with all of their columns <span class="No-Break">and constraints.</span></p>&#13;
			<p>Now, let’s examine the other function in this <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">downgrade</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">eabd3f9c5b64_initial_migration.py</p>&#13;
			<pre class="source-code">&#13;
def downgrade() -&gt; None:    # ### commands auto generated by Alembic - please adjust! ###&#13;
    op.drop_table("comments")&#13;
    op.drop_table("posts")&#13;
    # ### end Alembic commands ###</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py</a></p>&#13;
			<p>This function describes the operations to <em class="italic">roll back the migration</em> so that the databases go back to their previous states. This is very important because if something goes wrong during the migration, or if you need to revert to an older version of your application, you’ll be able to do so without breaking <span class="No-Break">your data.</span></p>&#13;
			<p class="callout-heading">Autogeneration doesn’t detect everything</p>&#13;
			<p class="callout">Bear in mind that, even though autogeneration is very helpful, it’s not always accurate, and sometimes, it’s not able to detect ambiguous changes. For example, if you rename a column, it will delete the old one and create another. As a result, the data for this column will be lost! This is why you should always carefully review the migration scripts a<a id="_idTextAnchor407"/>nd make the required changes for edge cases <span class="No-Break">like this.</span></p>&#13;
			<p>Finally, you can apply the migrations to your database using the <span class="No-Break">fol<a id="_idTextAnchor408"/>lowing command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ <a id="_idTextAnchor409"/>alembic upgrade head</pre>			<p>This will run all the migrations that have not yet been applied to your database until the latest. It’s interesting to know that, in the process, Alembic creates a table in your database so that it can remember all the migrations it has applied: this is how it detects which scripts <span class="No-Break">to run.</span></p>&#13;
			<p>Generally speaking, you should be <em class="italic">extremely careful</em> when you run such commands on your database, especially on a production one. Very bad things can happen if you make a mistake, and you can lose precious data. You should always test your migrations in a test environment and have fresh and working backups before running them on your <span class="No-Break">production database.</span></p>&#13;
			<p>This was a very quick introduction to Alembic and its powerful migration system. We strongly encourage you to go through its documentation to understand all of its mechanisms, especially regarding <a id="_idIndexMarker487"/>migration script operations. Please refer <span class="No-Break">to </span><a href="https://alembic.sqlalchemy.org/en/latest/index.html"><span class="No-Break">https://alembic.sqlalchemy.org/en/latest/index.html</span></a><span class="No-Break">.</span></p>&#13;
			<p>That’s it for the SQLAlchemy part of this chapter! It’s a complex but powerful library for working with SQL databases. We’ll now leave the world of relational databases to<a id="_idTextAnchor410"/> explore how we can work with a document-oriented <span class="No-Break">databa<a id="_idTextAnchor411"/>se, MongoDB.</span></p>&#13;
			<h1 id="_idParaDest-113"><a id="_idTextAnchor412"/>Communicating with a MongoDB database using Motor</h1>&#13;
			<p>As we <a id="_idIndexMarker488"/>mentioned at the beginning of this chapter, working <a id="_idIndexMarker489"/>with a document-oriented database, such as MongoDB, is quite different from a relational database. First and foremost, you don’t need to configure a schema upfront: it follows the structure of the data that you insert into it. In the case of FastAPI, it makes our life slightly easier since we only have to work with Pydantic models. However, there are some subtleties around the document identifiers that we need to take into account. We’ll review <span class="No-Break">this next.</span></p>&#13;
			<p>To begin, we’ll install Motor, which is a library that is used to communicate asynchronously with MongoDB and is officially supported by the MongoDB organization. Run the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker490"/></span><span class="No-Break">command:</span></p>&#13;
			<pre class="source-code">&#13;
<a id="_idTextAnchor413"/>(venv) $ pip install motor</pre>			<p>Once you’ve done this, we can <span class="No-Break">start working!</span><a id="_idTextAnchor414"/></p>&#13;
			<h2 id="_idParaDest-114">Creating models that are compatible with MongoDB<a id="_idTextAnchor415"/> ID</h2>&#13;
			<p>As we <a id="_idIndexMarker491"/>mentioned i<a id="_idTextAnchor416"/>n the introduction to this section, there are some difficulties with the identifiers that MongoDB uses to store documents. Indeed, by default, MongoDB assigns every document an <strong class="source-inline">_id</strong> property that acts as a unique identifier in a collection. This causes <span class="No-Break">two issues:</span></p>&#13;
			<ul>&#13;
				<li>In a Pydantic model, if a property starts with an underscore, it’s considered to be private and thus, is not used as a data field for <span class="No-Break">our model.</span></li>&#13;
				<li><strong class="source-inline">_id</strong> is encoded as a binary object, called <strong class="source-inline">ObjectId</strong>, instead of a simple integer or string. It’s usually represented in the form of a string such as <strong class="source-inline">608d1ee317c3f035100873dc</strong>. This type of object is not supported out of the box by Pydantic <span class="No-Break">or FastAPI.</span></li>&#13;
			</ul>&#13;
			<p>This is why we’ll need some boilerplate code to ensure those identifiers work with Pydantic and FastAPI. To begin, in the following example, we have created a <strong class="source-inline">MongoBaseModel</strong> base class that takes care of defining the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> field:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
class MongoBaseModel(BaseModel):    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")&#13;
    class Config:&#13;
        json_encoders = {ObjectId: str}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/models.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/models.py</a></p>&#13;
			<p>First, we need to define an <strong class="source-inline">id</strong> field, which is of the <strong class="source-inline">PyObjectId</strong> type. This is a custom type that was defined in the preceding code. We won’t go into the details of its implementation but just know that it’s a class that makes <strong class="source-inline">ObjectId</strong> a compatible type for Pydantic. We define this same class as a default factory for this field. Interestingly, this kind of identifier allows us to generate them on the client side, contrary to traditional auto-incremented integer<a id="_idTextAnchor417"/>s of relational databases, which could be useful in <span class="No-Break">some cases.</span></p>&#13;
			<p>The most interesting argument is <strong class="source-inline">alias</strong>. It’s a Pydantic option that allows us to <em class="italic">cha<a id="_idTextAnchor418"/>nge the name of the field d<a id="_idTextAnchor419"/>uring serialization</em>. In this example, when we call the <strong class="source-inline">dict</strong> method on an instance of <strong class="source-inline">MongoBaseModel</strong>, the identifier will be set on the <strong class="source-inline">_id</strong> key, which is the name expected by MongoDB. That solves the <span class="No-Break">first issue.</span></p>&#13;
			<p>Then, we add the <strong class="source-inline">Config</strong> subclass and set the <strong class="source-inline">json_encoders</strong> option. By default, Pydantic is completely unaware of our <strong class="source-inline">PyObjectId</strong> type, so it won’t be able to correctly serialize it to JSON. This option allows us to <em class="italic">map custom types with a function that will be called to serialize them</em>. Here, we simply transform it into a string (this works because <strong class="source-inline">ObjectId</strong> implements the <strong class="source-inline">__str__</strong> magic method). That solves the second issue <span class="No-Break">for Pydantic.</span></p>&#13;
			<p>Our base model for <a id="_idIndexMarker492"/>Pydantic is complete! We can now use it as a <strong class="source-inline">base</strong> class instead of <strong class="source-inline">BaseModel</strong> for our actual data models. Notice, however, that the <strong class="source-inline">PostPartialUpdate</strong> doesn’t inherit from it. Indeed, we don’t want the <strong class="source-inline">id</strong> field in this model; otherwise, a <strong class="source-inline">PATCH</strong> request might be <a id="_idTextAnchor420"/>able to replace the ID of the document<a id="_idTextAnchor421"/>, which could lead to <span class="No-Break">weird issues.</span></p>&#13;
			<h2 id="_idParaDest-115"><a id="_idTextAnchor422"/>Connecting to a database</h2>&#13;
			<p>Now that our <a id="_idIndexMarker493"/>models are ready, we can set up the connection with a MongoDB server. This is quite easy and only involves a class instantiation, as shown in the <span class="No-Break"><strong class="source-inline">database.py</strong></span><span class="No-Break"> module:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">database.py</p>&#13;
			<pre class="source-code">&#13;
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase# Connection to the whole server&#13;
motor_client = AsyncIOMotorClient("mongodb://localhost:27017")&#13;
# Single database instance&#13;
database = motor_client["chapter06_mongo"]&#13;
def get_database() -&gt; AsyncIOMotorDatabase:&#13;
    return database</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/database.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-Fa<span id="_idTextAnchor423"/>stAPI-Second-Edition/tree/main/chapter06/mongodb/database.py</a></p>&#13;
			<p>Here, you <a id="_idIndexMarker494"/>can see that <strong class="source-inline">AsyncIOMotorClient</strong> simply expects a connection string to your database. Generally, it consists of the scheme, followed by authentication information, and the hostname of the database server. You can find an overview of this format in the official MongoDB documentation <span class="No-Break">at </span><a href="https://docs.mongodb.com/manual/reference/connection-string/"><span class="No-Break">https://docs.mongodb.com/manual/reference/connection-string/</span></a><span class="No-Break">.</span></p>&#13;
			<p>However, be careful. Contrary to the libraries we’ve discussed so far, the client that’s instantiated here is not bound to any database – that is, it’s only a connection to a whole server. That’s why we need the second line: by accessing the <strong class="source-inline">chapter06_mongo</strong> key, we get a database instance. It’s worth noting that MongoDB doesn’t require you to create the database upfront: it’ll create it automatically if it <span class="No-Break">doesn’t exist.</span></p>&#13;
			<p>Then, we create a simple function to return this database instance. We’ll use this function as a <a id="_idIndexMarker495"/>dependency to retrieve this instance in our path operation functions. We explained the benefits of this pattern in the <em class="italic">Communicating with a SQL database with<a id="_idTextAnchor424"/> SQLAlchemy </em><span class="No-Break"><em class="italic">ORM</em></span><span class="No-Break"> section.</span></p>&#13;
			<p>That’s it!<a id="_idTextAnchor425"/> We can now make queries to <span class="No-Break">our database!</span></p>&#13;
			<h2 id="_idParaDest-116"><a id="_idTextAnchor426"/>Inserting documents</h2>&#13;
			<p>We’ll start <a id="_idIndexMarker496"/>by demonstrating how to implement an endpoint to create posts. Essentially, we just have to insert our transformed Pydantic model into <span class="No-Break">a dictionary:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/posts", response_model=Post, status_code=status.HTTP_201_CREATED)async def create_post(&#13;
    post_create: PostCreate, database: AsyncIOMotorDatabase = Depends(get_database)&#13;
) -&gt; Post:&#13;
    post = Post(**post_create.dict())&#13;
    await database["posts"].insert_one(post.dict(by_alias=True))&#13;
    post = await get_post_or_404(post.id, database)&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Ed<span id="_idTextAnchor427"/>ition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>Classically, this is a <strong class="source-inline">POST</strong> endpoint that accepts a payload in the form of a <strong class="source-inline">PostCreate</strong> model. Additionally, we inject the database instance with the dependency we <span class="No-Break">wrote earlier.</span></p>&#13;
			<p>In the path operation itself, you can see that we start by instantiating a <strong class="source-inline">Post</strong> from the <strong class="source-inline">PostCreate</strong> data. This is usually a good practice if you have fields that only appear in <strong class="source-inline">Post</strong> that need to <span class="No-Break">be initialized.</span></p>&#13;
			<p>Then, we have <a id="_idIndexMarker497"/>the query. To retrieve a collection in our MongoDB database, we simply have to get it by name, like a dictionary. Once again, MongoDB will take care of creating it if it doesn’t exist. As you can see, document-oriented databases are much more lightweight regarding schema than relational databases! In this collection, we can call the <strong class="source-inline">insert_one</strong> method to insert a single document. It expects a dictionary to map fields to their values. Therefore, the <strong class="source-inline">dict</strong> method of Pydantic objects is once again our friend. However, here, we can see something new: we call it with the <strong class="source-inline">by_alias</strong> argument set to <strong class="source-inline">True</strong>. By default, Pydantic will serialize the object with the real field name, not the alias name. However, we do need the <strong class="source-inline">_id</strong> identifier in our MongoDB database. Using this option, Pydantic will use the alias as a key in <span class="No-Break">the dictionary.</span></p>&#13;
			<p>To ensure we have a true and fresh representation of our document in the dictionary, we can retrie<a id="_idTextAnchor428"/>ve one from the database thanks to our <strong class="source-inline">get_post_or_404</strong> function. We’ll examine how this works in the <span class="No-Break">next section.</span></p>&#13;
			<p class="callout-heading">Dependencies are like functions</p>&#13;
			<p class="callout">In this section, we used <strong class="source-inline">get_post_or_404</strong> as a regular function to retrieve our newly created blog post. This is perfectly okay: dependencies don’t have hidden or magic logic inside them, so you can reuse them at will. The only thing to remember is that you have to provide ever<a id="_idTextAnchor429"/>y argument manually since you are outsid<a id="_idTextAnchor430"/>e of the dependency <span class="No-Break">injection context.</span></p>&#13;
			<h2 id="_idParaDest-117"><a id="_idTextAnchor431"/>Getting documents</h2>&#13;
			<p>Of course, retrieving <a id="_idIndexMarker498"/>the data from the database is an important part of the job of a REST API. In this section, we’ll demonstrate how to implement two classic endpoints – that is, to list posts and get a single post. Let’s start with the first one and take a look at <span class="No-Break">its implementation:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/posts", response_model=list[Post])async def list_posts(&#13;
    pagination: tuple[int, int] = Depends(pagination),&#13;
    database: AsyncIOMotorDatabase = Depends(get_database),&#13;
) -&gt; list[Post]:&#13;
    skip, limit = pagination&#13;
    query = database["posts"].find({}, skip=skip, limit=limit)&#13;
    results = [Post(**raw_post) async for raw_post in query]&#13;
    return results</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>The most interesting <a id="_idIndexMarker499"/>part is the second line, which is where we define the query. After retrieving the <strong class="source-inline">posts</strong> collection, we call the <strong class="source-inline">find</strong> method. The first argument should be the filtering query, following the MongoDB syntax. Since we want every document, we leave it empty. Then, we have keyword arguments that allow us to apply our <span class="No-Break">pagination parameters.</span></p>&#13;
			<p>MongoDB returns a result in the form of a list of dictionaries, which maps fields to their values. This is why we added a list comprehension construct to transform them back i<a id="_idTextAnchor432"/>nto <strong class="source-inline">Post</strong> instances – so that FastAPI can serialize <span class="No-Break">them properly.</span></p>&#13;
			<p>You might have noticed something quite surprising here: contrary to what we do usually, we didn’t wait for the query directly. Instead, w<a id="_idTextAnchor433"/>e added the <strong class="source-inline">async</strong> keyword to our list comprehension. Indeed, in this case, Motor <a id="_idIndexMarker500"/>returns <strong class="bold">an asynchronous generator</strong>. It’s the asynchronous counterpart of the classic generator. It works in the same way, aside from the <strong class="source-inline">async</strong> keyword, which we have to add when iterating <span class="No-Break">over it.</span></p>&#13;
			<p>Now, let’s take a look at the endpoint that retrieves a single post. The following example shows <span class="No-Break">its implementation:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/posts/{id}", response_model=Post)async def get_post(post: Post = Depends(get_post_or_404)) -&gt; Post:&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>As you can see, it’s a<a id="_idIndexMarker501"/> simple <strong class="source-inline">GET</strong> endpoint that accepts the <strong class="source-inline">id</strong> post as a path parameter. Most of the logic’s implementation is in the reusable <strong class="source-inline">get_post_or_404</strong> dependency. You can view what it looks <span class="No-Break">like here:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def get_post_or_404(    id: ObjectId = Depends(get_object_id),&#13;
    database: AsyncIOMotorDatabase = Depends(get_database),&#13;
) -&gt; Post:&#13;
    raw_post = await database["posts"].find_one({"_id": id})&#13;
    if raw_post is None:&#13;
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)&#13;
    return Post(**raw_post)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-Fa<span id="_idTextAnchor434"/>stAPI-Second-Edition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>The logic is quite similar to what we saw for the list endpoint. This time, however, we call the <strong class="source-inline">find_one</strong> method with a query to match the post identifier: the key is the name of the document attribute we want to filter on, and the value is the one we are <span class="No-Break">looking for.</span></p>&#13;
			<p>This method returns the document in the form of a dictionary or <strong class="source-inline">None</strong> if it doesn’t exist. In this case, we raise a proper <span class="No-Break"><strong class="source-inline">404</strong></span><span class="No-Break"> error.</span></p>&#13;
			<p>Finally, we transform it back into a <strong class="source-inline">Post</strong> model before <span class="No-Break">returning it.</span></p>&#13;
			<p>You might have<a id="_idIndexMarker502"/> noticed that we got <strong class="source-inline">id</strong> through a dependency, <strong class="source-inline">get_object_id</strong>. Indeed, FastAPI will return a string from the path parameter. If we try to make a query with <strong class="source-inline">id</strong> in the form of a string, MongoDB will not match with the actual binary IDs. That’s why we use another dependency that transforms the identifier, represented as a string (such as <strong class="source-inline">608d1ee317c3f035100873dc</strong>), into a <span class="No-Break">proper </span><span class="No-Break"><strong class="source-inline">ObjectId</strong></span><span class="No-Break">.</span></p>&#13;
			<p>As a side note, here’s a very nice example of <em class="italic">nested dependencies</em>: endpoints use the <strong class="source-inline">get_post_or_404</strong> dependency, which itself gets a value from <strong class="source-inline">get_object_id</strong>. You can view the implementation of this dependency in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def get_object_id(id: str) -&gt; ObjectId:    try:&#13;
        return ObjectId(id)&#13;
    except (errors.InvalidId, TypeError):&#13;
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applicat<span id="_idTextAnchor435"/>ions-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>Here, we simply retrieve the <strong class="source-inline">id</strong> string from the path parameters and try to instantiate it back into an <strong class="source-inline">ObjectId</strong>. If it’s not<a id="_idIndexMarker503"/> a valid value, we catch the corresponding errors and consider it a <span class="No-Break"><strong class="source-inline">404</strong></span><span class="No-Break"> error.</span></p>&#13;
			<p>With this, we have solved every challenge posed by th<a id="_idTextAnchor436"/>e MongoDB identifiers format. Now, let’s d<a id="_idTextAnchor437"/>iscuss how to update and <span class="No-Break">delete documents.</span></p>&#13;
			<h2 id="_idParaDest-118"><a id="_idTextAnchor438"/>Updating and deleting documents</h2>&#13;
			<p>We’ll now <a id="_idIndexMarker504"/>review the endpoin<a id="_idTextAnchor439"/>ts for <a id="_idIndexMarker505"/>updating and deleting documents. The logic is still the same and only involves building the proper query from the <span class="No-Break">request payload.</span></p>&#13;
			<p>Let’s start with the <strong class="source-inline">PATCH</strong> endpoint, which you can view in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.patch("/posts/{id}", response_model=Post)async def update_post(&#13;
    post_update: PostPartialUpdate,&#13;
    post: Post = Depends(get_post_or_404),&#13;
    database: AsyncIOMotorDatabase = Depends(get_database),&#13;
) -&gt; Post:&#13;
    await database["posts"].update_one(&#13;
        {"_id": post.id}, {"$set": post_update.dict(exclude_unset=True)}&#13;
    )&#13;
    post = await get_post_or_404(post.id, database)&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>Here, we used the <strong class="source-inline">update_one</strong> method to update one document. The first a<a id="_idTextAnchor440"/>rgument is the filtering query, while the second one is the actual operation to apply to the document. Once again, it follows the MongoDB syntax: the <strong class="source-inline">$set</strong> operation allows us to only modify the fields we want to change by passing the <span class="No-Break"><strong class="source-inline">update</strong></span><span class="No-Break"> dictionary.</span></p>&#13;
			<p>The <strong class="source-inline">DELETE</strong> endpoint is<a id="_idIndexMarker506"/> even simpler; it’s just a single query, as you can see in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)async def delete_post(&#13;
    post: Post = Depends(get_post_or_404),&#13;
    database: AsyncIOMotorDatabase = Depends(get_database),&#13;
):&#13;
    await database["posts"].delete_one({"_id": post.id})</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py</a></p>&#13;
			<p>The <strong class="source-inline">delete_one</strong> method <a id="_idIndexMarker507"/>expects the filtering query as the <span class="No-Break">first argument.</span></p>&#13;
			<p>That’s it! Of course, here, we’ve only demonstrated the simplest type of query, but MongoDB has a very powerful query <a id="_idTextAnchor441"/>language that allows you to do more complex things. If you’re not familiar with this, we recommend that you read the <a id="_idTextAnchor442"/>nice introduction from the official<a id="_idTextAnchor443"/> <a id="_idIndexMarker508"/><span class="No-Break">documentation: </span><a href="https://docs.mongodb.com/manual/crud"><span class="No-Break">https://docs.mongodb.com/manual/crud</span></a><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-119"><a id="_idTextAnchor444"/>Nesting documents</h2>&#13;
			<p>At the beginning<a id="_idIndexMarker509"/> of this chapter, we mentioned that document-based databases, contrary to relational databases, aim to store all the data related to an entity in a single document. In our current example, if we wish to store the comments along with the post, we simply have to add a list where each item is the <span class="No-Break">comment data.</span></p>&#13;
			<p>In this section, we’ll implement this behavior. You’ll see that the functioning of MongoDB makes <span class="No-Break">this straightforward.</span></p>&#13;
			<p>We’ll start by adding a new <strong class="source-inline">comments</strong> attribute to our <strong class="source-inline">Post</strong> model. You can view this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
class Post(PostBase):    comments: list[Comment] = Field(default_factory=list)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/models.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/models.py</a></p>&#13;
			<p>This field is simply a list of <strong class="source-inline">Comment</strong>. We won’t go into the details of the comment models since they are quite straightforward. Notice that we use the <strong class="source-inline">list</strong> function as the default factory for this attribute. This instantiates an empty list by default when we create a <strong class="source-inline">Post</strong> without setting <span class="No-Break">any comments.</span></p>&#13;
			<p>Now that we have our models, we can implement an endpoint to create a new comment. You can view it in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post(    "/posts/{id}/comments", response_model=Post, status_code=status.HTTP_201_CREATED&#13;
)&#13;
async def create_comment(&#13;
    comment: CommentCreate,&#13;
    post: Post = Depends(get_post_or_404),&#13;
    database: AsyncIOMotorDatabase = Depends(get_database),&#13;
) -&gt; Post:&#13;
    await database["posts"].update_one(&#13;
        {"_id": post.id}, {"$push": {"comments": comment.dict()}}&#13;
    )&#13;
    post = await get_post_or_404(post.id, database)&#13;
    return post</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/app.py</a></p>&#13;
			<p>As we did before, we nest the endpoints under the path of a single post. Thus, we can reuse <strong class="source-inline">get_post_or_404</strong> to retrieve the post we want to add a comment to if <span class="No-Break">it exists.</span></p>&#13;
			<p>Then, we<a id="_idIndexMarker510"/> trigger an <strong class="source-inline">update_one</strong> query: this time, using the <strong class="source-inline">$push</strong> operation. This is a useful operator for adding elements to a list attribute. Operators that remove elements from a list are also available. You can find a description of every <strong class="source-inline">update</strong> operator in the official doc<a id="_idTextAnchor445"/>umentation <span class="No-Break">at </span><a href="https://docs.mongodb.com/manual/reference/operator/update/"><span class="No-Break">https://docs.mongodb.com/manual/reference/operator/update/</span></a><span class="No-Break">.</span></p>&#13;
			<p>And that’s it! We don’t even have to modify the rest of our code. Because the comments are included in the whole document, we’ll always retrieve them when querying for a post in the database. Besides, our <strong class="source-inline">Post</strong> model now expects a <strong class="source-inline">comments</strong> attribute, so Pydantic will take care of serializing <span class="No-Break">them automatically.</span></p>&#13;
			<p>That concludes this part regarding MongoDB. You’ve seen that it can be integrat<a id="_idTextAnchor446"/>ed into a FastAPI application very quickly, especially because of its very <span class="No-Break">flexible schema.</span></p>&#13;
			<h1 id="_idParaDest-120"><a id="_idTextAnchor447"/>Summary</h1>&#13;
			<p>Congratulations! You’ve reached another big milestone in mastering how to build a REST API with FastAPI. As you know, databases are an essential part of every system; they allow you to save data in a structured way and retrieve it precisely and reliably thanks to powerful query languages. You are now able to leverage their power in FastAPI, whether they are relational databases or <span class="No-Break">document-oriented databases.</span></p>&#13;
			<p>Serious things can now happen; users can send and retrieve data to and from your system. However, this poses a new challenge to tackle: this data needs to be protected so that it can remain private and secure. This is exactly what we’ll discuss in the next chapter: how to authenticate users and set up FastAPI for <span class="No-Break">maximum security.</span></p>&#13;
		</div>&#13;
	</div></body></html>