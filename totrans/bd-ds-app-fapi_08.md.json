["```py\n\n$ docker run -d --name fastapi-mongo -p 27017:27017 mongo:6.0\n```", "```py\n\n(venv) $ pip install \"sqlalchemy[asyncio,mypy]\"\n```", "```py\n\n    (venv) $ pip install asyncpg\n    ```", "```py\n\n    (venv) $ pip install aiomysql\n    ```", "```py\n\n    (venv) $ pip install aiosqlite\n    ```", "```py\n\nfrom datetime import datetimefrom sqlalchemy import DateTime, Integer, String, Text\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nclass Base(DeclarativeBase):\n    pass\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    publication_date: Mapped[datetime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    title: Mapped[str] = mapped_column(String(255), nullable=False)\n    content: Mapped[str] = mapped_column(Text, nullable=False)\n```", "```py\n\nfrom datetime import datetimefrom pydantic import BaseModel, Field\nclass PostBase(BaseModel):\n    title: str\n    content: str\n    publication_date: datetime = Field(default_factory=datetime.now)\n    class Config:\n        orm_mode = True\nclass PostPartialUpdate(BaseModel):\n    title: str | None = None\n    content: str | None = None\nclass PostCreate(PostBase):\n    pass\nclass PostRead(PostBase):\n    id: int\n```", "```py\n\nfrom collections.abc import AsyncGeneratorfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine\nfrom chapter06.sqlalchemy.models import Base\nDATABASE_URL = \"sqlite+aiosqlite:///chapter06_sqlalchemy.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, expire_on_commit=False)\n```", "```py\n\nasync def get_async_session() -> AsyncGenerator[AsyncSession, None]:    async with async_session_maker() as session:\n        yield session\n```", "```py\n\n@contextlib.asynccontextmanagerasync def lifespan(app: FastAPI):\n    await create_all_tables()\n    yield\n```", "```py\n\n@app.post(    \"/posts\", response_model=schemas.PostRead, status_code=status.HTTP_201_CREATED\n)\nasync def create_post(\n    post_create: schemas.PostCreate, session: AsyncSession = Depends(get_async_session)\n) -> Post:\n    post = Post(**post_create.dict())\n    session.add(post)\n    await session.commit()\n    return post\n```", "```py\n\n@app.get(\"/posts\", response_model=list[schemas.PostRead])async def list_posts(\n    pagination: tuple[int, int] = Depends(pagination),\n    session: AsyncSession = Depends(get_async_session),\n) -> Sequence[Post]:\n    skip, limit = pagination\n    select_query = select(Post).offset(skip).limit(limit)\n    result = await session.execute(select_query)\n    return result.scalars().all()\n```", "```py\n\n@app.get(\"/posts/{id}\", response_model=schemas.PostRead)async def get_post(post: Post = Depends(get_post_or_404)) -> Post:\n    return post\n```", "```py\n\nasync def get_post_or_404(    id: int, session: AsyncSession = Depends(get_async_session)\n) -> Post:\n    select_query = select(Post).where(Post.id == id)\n    result = await session.execute(select_query)\n    post = result.scalar_one_or_none()\n    if post is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    return post\n```", "```py\n\n@app.patch(\"/posts/{id}\", response_model=schemas.PostRead)async def update_post(\n    post_update: schemas.PostPartialUpdate,\n    post: Post = Depends(get_post_or_404),\n    session: AsyncSession = Depends(get_async_session),\n) -> Post:\n    post_update_dict = post_update.dict(exclude_unset=True)\n    for key, value in post_update_dict.items():\n        setattr(post, key, value)\n    session.add(post)\n    await session.commit()\n    return post\n```", "```py\n\n@app.delete(\"/posts/{id}\", status_code=status.HTTP_204_NO_CONTENT)async def delete_post(\n    post: Post = Depends(get_post_or_404),\n    session: AsyncSession = Depends(get_async_session),\n):\n    await session.delete(post)\n    await session.commit()\n```", "```py\n\nclass Comment(Base):    __tablename__ = \"comments\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    post_id: Mapped[int] = mapped_column(ForeignKey(\"posts.id\"), nullable=False)\n    publication_date: Mapped[datetime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    content: Mapped[str] = mapped_column(Text, nullable=False)\n    post: Mapped[\"Post\"] = relationship(\"Post\", back_populates=\"comments\")\n```", "```py\n\nclass Post(Base):    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    publication_date: Mapped[datetime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    title: Mapped[str] = mapped_column(String(255), nullable=False)\n    content: Mapped[str] = mapped_column(Text, nullable=False)\n    comments: Mapped[list[Comment]] = relationship(\"Comment\", cascade=\"all, delete\")\n```", "```py\n\nclass PostRead(PostBase):    id: int\n    comments: list[CommentRead]\n```", "```py\n\n@app.post(    \"/posts/{id}/comments\",\n    response_model=schemas.CommentRead,\n    status_code=status.HTTP_201_CREATED,\n)\nasync def create_comment(\n    comment_create: schemas.CommentCreate,\n    post: Post = Depends(get_post_or_404),\n    session: AsyncSession = Depends(get_async_session),\n) -> Comment:\n    comment = Comment(**comment_create.dict(), post=post)\n    session.add(comment)\n    await session.commit()\n    return comment\n```", "```py\n\nasync def get_post_or_404(    id: int, session: AsyncSession = Depends(get_async_session)\n) -> Post:\n    select_query = (\n        select(Post).options(selectinload(Post.comments)).where(Post.id == id)\n    )\n    result = await session.execute(select_query)\n    post = result.scalar_one_or_none()\n    if post is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    return post\n```", "```py\n\ncomments = post.comments\n```", "```py\n\n(venv) $ pip install alembic\n```", "```py\n\n(venv) $ alembic init alembic\n```", "```py\n\nsqlalchemy.url = sqlite:///chapter06_sqlalchemy_relationship.db\n```", "```py\n\nfrom chapter06.sqlalchemy_relationship.models import Base# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n```", "```py\n\n(venv) $ alembic revision --autogenerate -m \"Initial migration\"\n```", "```py\n\ndef upgrade() -> None:    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"posts\",\n        sa.Column(\"id\", sa.Integer(), autoincrement=True, nullable=False),\n        sa.Column(\"publication_date\", sa.DateTime(), nullable=False),\n        sa.Column(\"title\", sa.String(length=255), nullable=False),\n        sa.Column(\"content\", sa.Text(), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_table(\n        \"comments\",\n        sa.Column(\"id\", sa.Integer(), autoincrement=True, nullable=False),\n        sa.Column(\"post_id\", sa.Integer(), nullable=False),\n        sa.Column(\"publication_date\", sa.DateTime(), nullable=False),\n        sa.Column(\"content\", sa.Text(), nullable=False),\n        sa.ForeignKeyConstraint(\n            [\"post_id\"],\n            [\"posts.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    # ### end Alembic commands ###\n```", "```py\n\ndef downgrade() -> None:    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"comments\")\n    op.drop_table(\"posts\")\n    # ### end Alembic commands ###\n```", "```py\n\n(venv) $ alembic upgrade head\n```", "```py\n\n(venv) $ pip install motor\n```", "```py\n\nclass MongoBaseModel(BaseModel):    id: PyObjectId = Field(default_factory=PyObjectId, alias=\"_id\")\n    class Config:\n        json_encoders = {ObjectId: str}\n```", "```py\n\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase# Connection to the whole server\nmotor_client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n# Single database instance\ndatabase = motor_client[\"chapter06_mongo\"]\ndef get_database() -> AsyncIOMotorDatabase:\n    return database\n```", "```py\n\n@app.post(\"/posts\", response_model=Post, status_code=status.HTTP_201_CREATED)async def create_post(\n    post_create: PostCreate, database: AsyncIOMotorDatabase = Depends(get_database)\n) -> Post:\n    post = Post(**post_create.dict())\n    await database[\"posts\"].insert_one(post.dict(by_alias=True))\n    post = await get_post_or_404(post.id, database)\n    return post\n```", "```py\n\n@app.get(\"/posts\", response_model=list[Post])async def list_posts(\n    pagination: tuple[int, int] = Depends(pagination),\n    database: AsyncIOMotorDatabase = Depends(get_database),\n) -> list[Post]:\n    skip, limit = pagination\n    query = database[\"posts\"].find({}, skip=skip, limit=limit)\n    results = [Post(**raw_post) async for raw_post in query]\n    return results\n```", "```py\n\n@app.get(\"/posts/{id}\", response_model=Post)async def get_post(post: Post = Depends(get_post_or_404)) -> Post:\n    return post\n```", "```py\n\nasync def get_post_or_404(    id: ObjectId = Depends(get_object_id),\n    database: AsyncIOMotorDatabase = Depends(get_database),\n) -> Post:\n    raw_post = await database[\"posts\"].find_one({\"_id\": id})\n    if raw_post is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n    return Post(**raw_post)\n```", "```py\n\nasync def get_object_id(id: str) -> ObjectId:    try:\n        return ObjectId(id)\n    except (errors.InvalidId, TypeError):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n```", "```py\n\n@app.patch(\"/posts/{id}\", response_model=Post)async def update_post(\n    post_update: PostPartialUpdate,\n    post: Post = Depends(get_post_or_404),\n    database: AsyncIOMotorDatabase = Depends(get_database),\n) -> Post:\n    await database[\"posts\"].update_one(\n        {\"_id\": post.id}, {\"$set\": post_update.dict(exclude_unset=True)}\n    )\n    post = await get_post_or_404(post.id, database)\n    return post\n```", "```py\n\n@app.delete(\"/posts/{id}\", status_code=status.HTTP_204_NO_CONTENT)async def delete_post(\n    post: Post = Depends(get_post_or_404),\n    database: AsyncIOMotorDatabase = Depends(get_database),\n):\n    await database[\"posts\"].delete_one({\"_id\": post.id})\n```", "```py\n\nclass Post(PostBase):    comments: list[Comment] = Field(default_factory=list)\n```", "```py\n\n@app.post(    \"/posts/{id}/comments\", response_model=Post, status_code=status.HTTP_201_CREATED\n)\nasync def create_comment(\n    comment: CommentCreate,\n    post: Post = Depends(get_post_or_404),\n    database: AsyncIOMotorDatabase = Depends(get_database),\n) -> Post:\n    await database[\"posts\"].update_one(\n        {\"_id\": post.id}, {\"$push\": {\"comments\": comment.dict()}}\n    )\n    post = await get_post_or_404(post.id, database)\n    return post\n```"]