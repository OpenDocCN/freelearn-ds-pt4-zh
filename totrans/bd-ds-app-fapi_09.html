<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer037">&#13;
			<h1 id="_idParaDest-121" class="chapter-number"><a id="_idTextAnchor448"/>7</h1>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor449"/>Managing Authentication and Security in FastAPI</h1>&#13;
			<p>Most of the time, you don’t want everyone on the internet to have access to your API, without any restrictions on the data they can create or read. That’s why you’ll need to at least protect your application with a private token or have a proper authentication system to manage the rights given to each user. In this chapter, we’ll see how FastAPI provides security dependencies to help us retrieve credentials by following different standards that are directly integrated into the automatic documentation. We’ll also build a basic user registration and authentication system to secure our <span class="No-Break">API endpoints.</span></p>&#13;
			<p>Finally, we’ll cover the security challenges you must tackle when you want to call your API from a web application in a browser – in particular, the risks of CORS and <span class="No-Break">CSRF attacks.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Security dependencies <span class="No-Break">in FastAPI</span></li>&#13;
				<li>Retrieving a user and generating an <span class="No-Break">access token</span></li>&#13;
				<li>Securing API endpoints for <span class="No-Break">authenticated users</span></li>&#13;
				<li>Securing endpoints with <span class="No-Break">access tokens</span></li>&#13;
				<li>Configuring CORS and protecting against <span class="No-Break">CSRF attacks</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-123"><a id="_idTextAnchor450"/>Technical requirements</h1>&#13;
			<p>For this chapter, you’ll require a Python virtual environment, just as we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>You’ll find all the code examples of this chapter in the dedicated GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-124"><a id="_idTextAnchor451"/>Security dependencies in FastAPI</h1>&#13;
			<p>To <a id="_idIndexMarker511"/>protec<a id="_idTextAnchor452"/>t<a id="_idTextAnchor453"/> <a id="_idIndexMarker512"/>REST APIs, and HTTP endpoints more generally, lots of standards have been proposed. Here is a non-exhaustive list of the most <span class="No-Break">common ones:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Basic HTTP authentication</strong>: In this<a id="_idIndexMarker513"/> scheme, user credentials (usually, an identifier such as an email address and password) are put into an HTTP header called <strong class="source-inline">Authorization</strong>. The value consists of the <strong class="source-inline">Basic</strong> keyword, followed by the user credentials encoded in <strong class="source-inline">Base64</strong>. This is a very simple scheme to implement but not very secure since the password appears in <span class="No-Break">every request.</span></li>&#13;
				<li><strong class="bold">Cookies</strong>: Cookies are <a id="_idIndexMarker514"/>a useful way to store static data on the client side, usually on web browsers, that is sent in each request to the server. Typically, a cookie contains a session token that can be verified by the server and linked to a <span class="No-Break">specific user.</span></li>&#13;
				<li><strong class="bold">Tokens</strong> in<a id="_idIndexMarker515"/> the <strong class="source-inline">Authorization</strong> header: Probably the most used header in a REST API context, this simply consists of sending a token in an HTTP <strong class="source-inline">Authorization</strong> header. The token is often prefixed by a method keyword, such as <strong class="source-inline">Bearer</strong>. On the server side, this token can be verified and linked to a <span class="No-Break">specific user.</span></li>&#13;
			</ul>&#13;
			<p>Each standard has its pros and cons and is suitable for a specific <span class="No-Break">use case.</span></p>&#13;
			<p>As you already know, FastAPI is mainly about dependency injection and callables that are automatically detected and called at runtime. Authentication methods are no exception: FastAPI provides most of them out of the box as <span class="No-Break">security dependencies.</span></p>&#13;
			<p>First, let’s learn how to retrieve an access token in an arbitrary header. For this, we can use the <strong class="source-inline">ApiKeyHeader</strong> dependency, as shown in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter07_api_key_header.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import Depends, FastAPI, HTTPException, statusfrom fastapi.security import APIKeyHeader&#13;
API_TOKEN = "SECRET_API_TOKEN"&#13;
app = FastAPI()&#13;
api_key_header = APIKeyHeader(name="Token")&#13;
@app.get("/protected-route")&#13;
async def protected_route(token: str = Depends(api_key_header)):&#13;
    if token != API_TOKEN:&#13;
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/chapter07_api_key_header.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/chapter07_api_key_header.py</a></p>&#13;
			<p>In<a id="_idTextAnchor454"/> this si<a id="_idTextAnchor455"/>mple<a id="_idIndexMarker516"/> example, we hardcoded a token, <strong class="source-inline">API_TOKEN</strong>, and checked <a id="_idIndexMarker517"/>whether the token passed in the header was equal to this token, before authorizing the endpoint to be called. To do this, we used the <strong class="source-inline">APIKeyHeader</strong> security dependency, which is designed to retrieve a value from a header. It’s a class dependency that can be instantiated with arguments. In particular, it accepts the <strong class="source-inline">name</strong> argument, which holds the name of the header it’ll <span class="No-Break">look for.</span></p>&#13;
			<p>Then, in our endpoint, we injected this dependency to get the token’s value. If it’s equal to our token constant, we proceed with the endpoint logic. Otherwise, we raise a <span class="No-Break"><strong class="source-inline">403</strong></span><span class="No-Break"> error.</span></p>&#13;
			<p>Our example from the <em class="italic">Path, router, and global dependencies</em> section of <a href="B19528_05.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Dependency Injection in FastAPI</em>, is not very different from this one. We are simply retrieving a value from an arbitrary header and making an equality check. So, why bother with a dedicated dependency? There are <span class="No-Break">two reasons:</span></p>&#13;
			<ul>&#13;
				<li>First, the logic to check whether the header exists and retrieve its value is included in <strong class="source-inline">APIKeyHeader</strong>. When you reach the endpoint, you are sure that a token value was retrieved; otherwise, a <strong class="source-inline">403</strong> error will <span class="No-Break">be thrown.</span></li>&#13;
				<li>The second, and<a id="_idIndexMarker518"/> probably most important, thing is that it’s detected by the OpenAPI schema and included in its interactive documentation. This means that endpoints using this dependency will display a lock icon, showing that it’s a protected endpoint. Furthermore, you’ll have access to an interface to input your token, as shown in the following screenshot. The token will then be automa<a id="_idTextAnchor456"/>tically <a id="_idIndexMarker519"/>included in the requests you ar<a id="_idTextAnchor457"/>e making from <span class="No-Break">the documentation:</span></li>&#13;
			</ul>&#13;
			<div>&#13;
				<div id="_idContainer029" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.1_B19528.jpg" alt="Figure 7.1 – Token authorization in interactive documentation" width="1650" height="1022"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Token authorization in interactive documentation</p>&#13;
			<p>Of course, you can wrap the logic that checks the token value in its own dependency to reuse it across your endpoints, as shown in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter07_api_key_header_dependency.py</p>&#13;
			<pre class="source-code">&#13;
async def api_token(token: str = Depends(APIKeyHeader(name="Token"))):    if token != API_TOKEN:&#13;
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)&#13;
@app.get("/protected-route", dependencies=[Depends(api_token)])&#13;
async def protected_route():&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/chapter07_api_key_header.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/chapter07_api_key_header.py</a></p>&#13;
			<p>These kinds of <a id="_idIndexMarker520"/>dependencies are <a id="_idTextAnchor458"/>very good candidates to be used as routers or global dependencies to protect whole sets of routes, as we saw in <a href="B19528_05.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Dependency Injection </em><span class="No-Break"><em class="italic">in FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<p>This is a very <a id="_idIndexMarker521"/>basic example of adding authorization to your API. In this example, we don’t have any user management; we are only checking that a token corresponds to a constant value. While it could be useful for private microservices that are not intended to be called by end users, this approach should not be considered <span class="No-Break">very secure.</span></p>&#13;
			<p>First, make sure your API is always served using HTTPS to ensure your token is not exposed in the headers. Then, if it’s a private microservice, you should also consider not exposing it publicly on the internet and making sure only trusted servers can call it. Since you don’t need users to make requests to this service, it’s much safer than a simple token key that could <span class="No-Break">be stolen.</span></p>&#13;
			<p>Of course, most of the time, you’ll want to authenticate real users with their own individual access tokens with which they can access their own data. You have probably already used a service that implements this very <span class="No-Break">typical pattern:</span></p>&#13;
			<ul>&#13;
				<li>First, you must register an account on this service, usually by providing your email address and <span class="No-Break">a password.</span></li>&#13;
				<li>Next, you can log in to the service using the same email address and password. The service checks whether the email address exists and that the password <span class="No-Break">is valid.</span></li>&#13;
				<li>In exchange, the service provides you with a session token that can be used on subsequent<a id="_idIndexMarker522"/> requests to authenticate yourself. This way, you <a id="_idIndexMarker523"/>don’t have to provide your email address and password on each request, which would be annoying and dangerous. Usually, such session tokens have a limited lifetime, which m<a id="_idTextAnchor459"/>eans you’ll have to log in again after som<a id="_idTextAnchor460"/>e time. This mitigates any security risks if the session token <span class="No-Break">is stolen.</span></li>&#13;
			</ul>&#13;
			<p>In the next section, you’ll learn how to implement suc<a id="_idTextAnchor461"/>h <span class="No-Break">a system.</span></p>&#13;
			<h1 id="_idParaDest-125"><a id="_idTextAnchor462"/>Storing a user and their password securely in a database</h1>&#13;
			<p>St<a id="_idTextAnchor463"/>oring a<a id="_idIndexMarker524"/> user entity in a database is no different from storing any other entity, and you can implement this in the same way as in <a href="B19528_06.xhtml#_idTextAnchor346"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Databases and Asynchronous ORMs</em>. The only thing you must be extremely cautious about is password storage. You must not store the password as plain text in your database. Why? If, unfortunately, a malicious person manages to get into your database, they’ll be able to get the passwords of all your users. Since many people use the same password multiple times, the security of their accounts on other applications and websites would be <span class="No-Break">seriously compromised.</span></p>&#13;
			<p>To avoid a disaster like<a id="_idTextAnchor464"/> this, we can<a id="_idIndexMarker525"/> apply <strong class="bold">cryptographic hash functions</strong> to the password. The goal of those functions is to transform the password string into a hash value. This is designed to make it near impossible to retrieve the original data from the hash. Hence, even if your database is compromised, the passwords are <span class="No-Break">still safe.</span></p>&#13;
			<p>When users try to log in, we simply compute the hash of the password they input and compare it with the hash we have in our database. If they match, this means it’s the <span class="No-Break">right password.</span></p>&#13;
			<p>Now, let’s learn how to implement such a system with FastAPI and <span class="No-Break">SQLAlchemy ORM.</span></p>&#13;
			<h2 id="_idParaDest-126">Cr<a id="_idTextAnchor465"/>eating models</h2>&#13;
			<p>We start by<a id="_idIndexMarker526"/> creating the SQLAlchemy ORM model for a <a id="_idIndexMarker527"/>user, as shown in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
class User(Base):    __tablename__ = "users"&#13;
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)&#13;
    email: Mapped[str] = mapped_column(&#13;
        String(1024), index=True, unique=True, nullable=False&#13;
    )&#13;
    hashed_password: Mapped[str] = mapped_column(String(1024), nullable=False)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/models.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/models.py</a></p>&#13;
			<p>To keep this example simple, we’re only considering the ID, email address, and password in our mod<a id="_idTextAnchor466"/>el. Note that we added a unique constraint to the <strong class="source-inline">email</strong> column to ensure we can’t have duplicate emails in <span class="No-Break">our database.</span></p>&#13;
			<p>Next, we can implement the corresponding <span class="No-Break">Pydantic schemas:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">schemas.py</p>&#13;
			<pre class="source-code">&#13;
class UserBase(BaseModel):    email: EmailStr&#13;
    class Config:&#13;
        orm_mode = True&#13;
class UserCreate(UserBase):&#13;
    password: str&#13;
class User(UserBase):&#13;
    id: int&#13;
    hashed_password: str&#13;
class UserRead(UserBase):&#13;
    id: int</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/schemas.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/schemas.py</a></p>&#13;
			<p>As you can see, there is a<a id="_idIndexMarker528"/> major difference between <strong class="source-inline">UserCreate</strong> and <strong class="source-inline">User</strong>: the former accepts the plain text password we’ll hash during registration, while the second will only keep the hashed password in the database. We also take care to not include <strong class="source-inline">hashed_password</strong> in <strong class="source-inline">UserRead</strong>, so the hash doesn’t appear in API responses. Even though hashed data should be indecipherable, it’s generally not adv<a id="_idTextAnchor467"/>ised to <span class="No-Break">leak it.</span></p>&#13;
			<h2 id="_idParaDest-127"><a id="_idTextAnchor468"/>Hashing passwords</h2>&#13;
			<p>B<a id="_idTextAnchor469"/>efore we<a id="_idIndexMarker529"/> look at the registration endpoint, let’s implement some important utility functions for hashing passwords. Fortunately, libraries exist that provide the most secure and efficient algorithms for this task. Here, we’ll use <strong class="source-inline">passlib</strong>. You can install it along with <strong class="source-inline">argon2_cffi</strong>, which is one of the safest hash functions at the time <span class="No-Break">of writing:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install passlib argon2_cffi</pre>			<p>Now, we’ll just instantiate the <strong class="source-inline">passlib</strong> classes and wrap some of their functions to make our <span class="No-Break">lives easier:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">password.py</p>&#13;
			<pre class="source-code">&#13;
from passlib.context import CryptContextpwd_context = CryptContext(schemes=["argon2"], deprecated="auto")&#13;
def get_password_hash(password: str) -&gt; str:&#13;
    return pwd_context.hash(password)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/password.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/password.py</a></p>&#13;
			<p><strong class="source-inline">CryptContext</strong> is a very useful<a id="_idIndexMarker530"/> class since it allows us to work with different hash algorithms. If, one day, a better algorithm than <strong class="source-inline">argon2</strong> emerges, we can just add<a id="_idTextAnchor470"/> it to our allowed schemas. New passwords will be hashed using the new algorithm, but existing passwords will still be recognized (and optionally upgraded to t<a id="_idTextAnchor471"/>he <span class="No-Break">new algorithm).</span></p>&#13;
			<h2 id="_idParaDest-128">Implementing registration <a id="_idTextAnchor472"/>routes</h2>&#13;
			<p>Now, we<a id="_idIndexMarker531"/> have all the elements to create a proper registration route. Once again, it’ll be very similar to what we saw earlier. The only thing we must remember is to hash the password before inserting it into <span class="No-Break">our database.</span></p>&#13;
			<p>Let’s look at <span class="No-Break">the implementation:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post(    "/register", status_code=status.HTTP_201_CREATED, response_model=schemas.UserRead&#13;
)&#13;
async def register(&#13;
    user_create: schemas.UserCreate, session: AsyncSession = Depends(get_async_session)&#13;
) -&gt; User:&#13;
    hashed_password = get_password_hash(user_create.password)&#13;
    user = User(&#13;
        *user_create.dict(exclude={"password"}), hashed_password=hashed_password&#13;
    )&#13;
    try:&#13;
        session.add(user)&#13;
        await session.commit()&#13;
    except exc.IntegrityError:&#13;
        raise HTTPException(&#13;
            status_code=status.HTTP_400_BAD_REQUEST, detail="Email already exists"&#13;
        )&#13;
    return user</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/app.py</a></p>&#13;
			<p>As you<a id="_idIndexMarker532"/> can see, we are calling <strong class="source-inline">get_password_hash</strong> on the input password before inserting the user into the database. Note that we are catching a possible <strong class="source-inline">exc.IntegrityError</strong> exception, which means we’re trying to insert an email that <span class="No-Break">already exist<a id="_idTextAnchor473"/>s.</span></p>&#13;
			<p>Also, notice that we took care to set <strong class="source-inline">response_model</strong> to <strong class="source-inline">UserRead</strong>. By doing this, we’re ensuring that <strong class="source-inline">hashed_password</strong> is not part of <span class="No-Break">the output.</span></p>&#13;
			<p>Great! We now have a proper user model and users can create a new account with our API. The next step is to allow them to log in and give t<a id="_idTextAnchor474"/>hem an <span class="No-Break">access token.</span></p>&#13;
			<h1 id="_idParaDest-129"><a id="_idTextAnchor475"/>Retrieving a user and generating an access token</h1>&#13;
			<p>After <a id="_idIndexMarker533"/>successful registration, the next step is being able to log in: the user will send their credentials and receive an authentication token to access the API. In this section, we’ll <a id="_idIndexMarker534"/>implement the endpoint that allows this. Basically, we’ll get the credentials from the request payload, retrieve the user with the given email, and verify their password. If the user exists and their password is valid, we’ll generate an access token and retu<a id="_idTextAnchor476"/>rn it in <span class="No-Break">the response.</span></p>&#13;
			<h2 id="_idParaDest-130">Implementing a database access t<a id="_idTextAnchor477"/>oken</h2>&#13;
			<p>First, let’s <a id="_idIndexMarker535"/>think about the nature of this access token. It should be a data string that uniquely identifies a user that is impossible to forge by a malicious third party. In this example, we will take a simple but reliable approach: we’ll generate a random string and store it in a dedicated table in our database, with a foreign key referring to <span class="No-Break">the user.</span></p>&#13;
			<p>This way, when an authenticated request arrives, we simply have to check whether it exists in the database and look for the corresponding user. The advantage of this approach is that tokens are centralized and can easily be invalidated if they are compromised; we only need to delete them from <span class="No-Break">the database.</span></p>&#13;
			<p>The first step is to implement the SQLAlchemy ORM model for this <span class="No-Break">new entity:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">models.py</p>&#13;
			<pre class="source-code">&#13;
class AccessToken(Base):    __tablename__ = "access_tokens"&#13;
    access_token: Mapped[str] = mapped_column(&#13;
        String(1024), primary_key=True, default=generate_token&#13;
    )&#13;
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)&#13;
    expiration_date: Mapped[datetime] = mapped_column(&#13;
        DateTime, nullable=False, default=get_expiration_date&#13;
    )&#13;
    user: Mapped[User] = relationship("User", lazy="joined")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/models.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/models.py</a></p>&#13;
			<p>We define<a id="_idIndexMarker536"/> <span class="No-Break">three columns:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">access_token</strong>: This is the string that will be passed in the requests to authenticate them. Notice that we defined the <strong class="source-inline">generate_token</strong> function as the default factory; it’s a simple function defined previously that generates a random secure passphrase. Under the hood, it relies on the standard <span class="No-Break"><strong class="source-inline">secrets</strong></span><span class="No-Break"> module.</span></li>&#13;
				<li><strong class="source-inline">user_id</strong>:  A foreign key referring to the <strong class="source-inline">users</strong> table that identifies the user corresponding to <span class="No-Break">this token.</span></li>&#13;
				<li><strong class="source-inline">expiration_date</strong>: The date and time when the access token will expire and won’t be valid anymore. It’s always a good idea to give access tokens an expiry date to mitigate the risk if they are stolen. Here, the <strong class="source-inline">get_expiration_date</strong> factory sets a default validity of <span class="No-Break">24 hours.</span></li>&#13;
			</ul>&#13;
			<p>We also don’t forget to define the relationship so we can directly access the user entity from an access token object. Notice we set an eager loading strategy by default, so we always retrieve the user when querying for an access token. If you need the rationale behind this, check the <em class="italic">Adding relationships</em> section of <a href="B19528_06.xhtml#_idTextAnchor346"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Databases and </em><span class="No-Break"><em class="italic">Asynchronous ORMs</em></span><span class="No-Break">.</span></p>&#13;
			<p>We won’t need Pydantic schemas here, as access tokens will be created and serialized t<a id="_idTextAnchor478"/>hrough <span class="No-Break">specific methods.</span></p>&#13;
			<h2 id="_idParaDest-131">Implementing a login <a id="_idTextAnchor479"/>endpoint</h2>&#13;
			<p>Now, let<a id="_idTextAnchor480"/>’s<a id="_idIndexMarker537"/> think about the login endpoint. Its goal is to take credentials in the request payload, retrieve the corresponding user, check the password, and generate a new access token. Its implementation is quite straightforward, apart from one thing: the model that’s used to handle the request. You’ll see why thanks to the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/token")async def create_token(&#13;
    form_data: OAuth2PasswordRequestForm = Depends(OAuth2PasswordRequestForm),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
):&#13;
    email = form_data.username&#13;
    password = form_data.password&#13;
    user = await authenticate(email, password, session)&#13;
    if not user:&#13;
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)&#13;
    token = await create_access_token(user, session)&#13;
    return {"access_token": token.access_token, "token_type": "bearer"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authent<span id="_idTextAnchor481"/>ication/app.py</a></p>&#13;
			<p>As you can se<a id="_idTextAnchor482"/>e, we retrieve the request data thanks to the <strong class="source-inline">OAuth2PasswordRequestForm</strong> module, which is provided by FastAPI in its security module. It expects several fields, especially <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>, in a form encoding rather <span class="No-Break">than JSON.</span></p>&#13;
			<p>Why do we<a id="_idIndexMarker538"/> use this class? The main benefit of using this class is that it’s completely integrated into the OpenAPI schema. This means that the interactive documentation will be able to automatically detect it and present a proper authentication form behind the <strong class="bold">Authorize</strong> button, as shown in the <span class="No-Break">following screenshot:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer030" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.2_B19528.jpg" alt="Figure 7.2 – OAuth2 authorization in interactive documentation" width="1650" height="1055"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – OAuth2 authorization in interactive documentation</p>&#13;
			<p>B<a id="_idTextAnchor483"/>ut that’s not all: it will<a id="_idTextAnchor484"/> be able to automatically retrieve the returned access token and set the proper authorization header in subsequent requests. The authentication process is handled transparently by the <span class="No-Break">interactive documentation.</span></p>&#13;
			<p>This class follows the OAuth2 protocol, which means you also have fields for the client ID and secret. We won’t learn how to implement the complete OAuth2 protocol here, but note that FastAPI provides all the tools needed to do so properly. For our project, we’ll just stick with a username and a password. Notice that, following the protocol, the field is named <em class="italic">username</em>, regardless of whether we are using an email address to identify the user. This isn’t a big deal; we just have to remember it while <span class="No-Break">retrieving it.</span></p>&#13;
			<p>The rest of the <a id="_idIndexMarker539"/>path operation function is quite simple: first, we try to retrieve a user from this email and password. If no corresponding user is found, we raise a <strong class="source-inline">401</strong> error. Otherwise, we generate a new access token before returning it. Notice that the response structure also includes the <strong class="source-inline">token_type</strong> property. This allows the interactive documentation to automatically set the <span class="No-Break">authorization headers.</span></p>&#13;
			<p>In the following example, we’ll look at the implementation of the <strong class="source-inline">authenticate</strong> and <strong class="source-inline">create_acces<a id="_idTextAnchor485"/>s_token</strong> functions. We won’t go into too much det<a id="_idTextAnchor486"/>ail here as they are <span class="No-Break">quite simple:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">authentication.py</p>&#13;
			<pre class="source-code">&#13;
async def authenticate(email: str, password: str, session: AsyncSession) -&gt; User | None:    query = select(User).where(User.email == email)&#13;
    result = await session.execute(query)&#13;
    user: User | None = result.scalar_one_or_none()&#13;
    if user is None:&#13;
        return None&#13;
    if not verify_password(password, user.hashed_password):&#13;
        return None&#13;
    return user&#13;
async def create_access_token(user: User, session: AsyncSession) -&gt; AccessToken:&#13;
    access_token = AccessToken(user=user)&#13;
    session.add(access_token)&#13;
    await session.commit()&#13;
    return access_token</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/authentication.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/authentication.py</a></p>&#13;
			<p>Notice that <a id="_idIndexMarker540"/>we defined a function called <strong class="source-inline">verify_password</strong> to check the validity of the password. Once again, it uses <strong class="source-inline">passlib</strong> under the hood, which takes care of comparing the hashes of <span class="No-Break">the passwords.</span></p>&#13;
			<p class="callout-heading">Password hash upgrade</p>&#13;
			<p class="callout">To keep this example simple, we implemented a simple password comparison. Usually, it’s good practice to implement a mechanism to upgrade the password hash at this stage. Imagine that a new and more robust hash algorithm has been introduced. We can take this opportunity to hash the password with this new algorithm and store it in a database. <strong class="source-inline">passlib</strong> includes a function for verifying and upgrading the hash in one operation. You can learn more about this in the following <span class="No-Break">documentation: </span><a href="https://passlib.readthedocs.io/en/stable/narr/context-tutorial.html#integrating-hash-migration"><span class="No-Break">https://passlib.readthedocs.io/en/stable/narr/context-tutorial.html#integrating-<span id="_idTextAnchor487"/>hash-migration</span></a><span class="No-Break">.</span></p>&#13;
			<p>We’ve almost achi<a id="_idTextAnchor488"/>eved our goal! Users can now log in and get a new access token. All we need to do now is implement a dependency to retrieve the <strong class="source-inline">Authorization</strong> he<a id="_idTextAnchor489"/>ader and verify <span class="No-Break">this token!</span></p>&#13;
			<h1 id="_idParaDest-132">Securing endpoints with a<a id="_idTextAnchor490"/>ccess tokens</h1>&#13;
			<p>Previously, w<a id="_idTextAnchor491"/>e <a id="_idIndexMarker541"/>learned how to implement a simple <a id="_idIndexMarker542"/>dependency to protect an endpoint with a header. Here, we’ll also retrieve a token from a request header, but then, we’ll have to check the database to see whether it’s valid. If it is, we’ll return the <span class="No-Break">corresponding user.</span></p>&#13;
			<p>Let’s see what <a id="_idIndexMarker543"/>our dependency <span class="No-Break">looks like:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def get_current_user(    token: str = Depends(OAuth2PasswordBearer(tokenUrl="/token")),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
) -&gt; User:&#13;
    query = select(AccessToken).where(&#13;
        AccessToken.access_token == token,&#13;
        AccessToken.expiration_date &gt;= datetime.now(tz=timezone.utc),&#13;
    )&#13;
    result = await session.execute(query)&#13;
    access_token: AccessToken | None = result.scalar_one_or_none()&#13;
    if access_token is None:&#13;
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)&#13;
    return access_token.user</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/a<span id="_idTextAnchor492"/>uthentica<span id="_idTextAnchor493"/>tion/app.py</a></p>&#13;
			<p>The first thing <a id="_idIndexMarker544"/>to notice is that we used the <strong class="source-inline">OAuth2PasswordBearer</strong> dependency from FastAPI. It goes hand in hand with <strong class="source-inline">OAuth2PasswordRequestForm</strong>, which we saw in the previous section. It not only checks for the access token in the <strong class="source-inline">Authorization</strong> header, but it also informs the OpenAPI schema that the endpoint to get a fresh token is <strong class="source-inline">/token</strong>. This is the purpose of the <strong class="source-inline">tokenUrl</strong> argument. This is how the automatic documentation can automatically call the access token endpoint in the login form we <span class="No-Break">saw earlier.</span></p>&#13;
			<p>Then we <a id="_idIndexMarker545"/>performed a database query with SQLAlchemy. We <a id="_idIndexMarker546"/>applied two clauses: one to match the token we got and another to ensure that the expiration date is in the future. If no corresponding record is found in the database, we raise a <strong class="source-inline">401</strong> error. Otherwise, we return the user related to the <span class="No-Break">access token.</span></p>&#13;
			<p>And that’s it! Our whole authentication system is complete. Now, we can protect our endpoints simply by injecting this dependency. We even have access to the user data so that we can tailor the response according to the current user. You can see this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.get("/protected-route", response_model=schemas.UserRead)async def protected_route(user: User = Depends(get_current_user)):&#13;
    return user</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/authentication/app.py</a></p>&#13;
			<p>With that, you’ve learned how to implement a whole registration and authentication system from scratch. We voluntarily kept it simple to focus on the most important points, but it’s a good base on which you <span class="No-Break">can expand.</span></p>&#13;
			<p>The patterns we showed here are good candidates for a REST A<a id="_idTextAnchor494"/>PI, w<a id="_idTextAnchor495"/>hich is called externally by other client programs. However, you may wish to call your API from a very common piece of software: the browser. In this case, there are some additional security co<a id="_idTextAnchor496"/>nsiderations to be taken <span class="No-Break">care of.</span></p>&#13;
			<h1 id="_idParaDest-133"><a id="_idTextAnchor497"/>Configuring CORS and protecting against CSRF attacks</h1>&#13;
			<p>Nowadays, numerous<a id="_idIndexMarker547"/> pieces of software are designed<a id="_idTextAnchor498"/> to be used in a browser through an interface built with HTML, CSS, and JavaScript. Traditionally, web servers were responsible for handling browser requests and returning an HTML response to be shown to the user. This is a common use case for frameworks such <span class="No-Break">as Django.</span></p>&#13;
			<p>For a few<a id="_idIndexMarker548"/> years now, there has been a shift underway in that pattern. With the emergence of JavaScript frameworks such as Angular, React, and Vue, we tend to have a clear separation between the frontend, a highly interactive user interface powered by JavaScript, and the backend. Thus, those backends are now only responsible for data storage and retrieving and executing business logic. This is a task that REST APIs are very good at! From the JavaScript code, the user interface can then just spawn requests to your API and handle the result to <span class="No-Break">present it.</span></p>&#13;
			<p>However, we must still handle authentication: we want our user to be able to log in to the frontend application and make authenticated requests to the API. While an <strong class="source-inline">Authorization</strong> header, as we’ve seen so far, could work, there is a better way to handle authentication when working in <span class="No-Break">browsers: </span><span class="No-Break"><strong class="bold">cookies</strong></span><span class="No-Break">!</span></p>&#13;
			<p>Cookies are designed<a id="_idIndexMarker549"/> to store user information in browser memory and are sent automatically in every request made to your server. They have been supported for years, and browsers integrate lots of mechanisms to make them safe <span class="No-Break">and reliable.</span></p>&#13;
			<p>However, this comes with some security challenges. Websites are very common targets for hackers and lots of attacks have eme<a id="_idTextAnchor499"/>rged over <span class="No-Break">the years.</span></p>&#13;
			<p>One of the most<a id="_idIndexMarker550"/> typical is <strong class="bold">Cross-Site Request Forgery </strong>(<strong class="bold">CSRF</strong>). In this scenario, an attacker on another website tries to trick a user who is currently authenticated with your application to perform a request on your server. Since browsers tend to send cookies with every request, your server wouldn’t be able to tell that the request was actually forged. Since it’s the users themselves who unintentionally launched the malicious request, these kinds of attacks don’t aim to steal data<a id="_idTextAnchor500"/> but to execute operations that change the state<a id="_idTextAnchor501"/> of the application, such as changing an email address or making a <span class="No-Break">money transfer.</span></p>&#13;
			<p>Obviously, we should be prepared for these kinds of risks and hav<a id="_idTextAnchor502"/>e measures in place to <span class="No-Break">mitigate them.</span></p>&#13;
			<h2 id="_idParaDest-134">Understanding CORS a<a id="_idTextAnchor503"/>nd conf<a id="_idTextAnchor504"/>iguring it in FastAPI</h2>&#13;
			<p>When <a id="_idTextAnchor505"/><a id="_idIndexMarker551"/>you have a clearly separated frontend application and a REST API backend, they are not typically served from the same subdomain. For <a id="_idIndexMarker552"/>example, the frontend may be available from <a href="http://www.myapplication.com">www.myapplication.com</a>, while the REST API is available from <strong class="source-inline">api.myapplication.com</strong>. As we mentioned in the introduction, we would like to make requests to this API from our frontend appli<a id="_idTextAnchor506"/>cation <span class="No-Break">in JavaScript.</span></p>&#13;
			<p>However, browsers don’t <a id="_idIndexMarker553"/>allow <strong class="bold">cross-origin </strong><strong class="bold">resource sharing (CORS)</strong><strong class="bold"> HTTP requests</strong>, meaning domain A can’t make requests to domain B. This follows w<a id="_idTextAnchor507"/>hat is called a <strong class="bold">same-origin policy</strong>. This <a id="_idIndexMarker554"/>is a good thing in general as it’s the first barrier to preventing <span class="No-Break">CSRF attacks.</span></p>&#13;
			<p>To experience this behavior, we’ll run a simple example. In our example repository, the <strong class="source-inline">chapter07/cors</strong> folder contains a FastAPI app called <strong class="source-inline">app_without_cors.py</strong> and a simple HTML file called <strong class="source-inline">index.html</strong> that contains some JavaScript for performing <span class="No-Break">HTTP requests.</span></p>&#13;
			<p>First, let’s run the FastAPI application using the usual <span class="No-Break"><strong class="source-inline">uvicorn</strong></span><span class="No-Break"> command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ uvicorn chapter07.cors.app_without_cors:app</pre>			<p>This will launch the FastAPI application on port <strong class="source-inline">8000</strong> by default. On another terminal, we’ll serve the HTML file using the built-in Python HTTP server. It’s a simple server, but it’s ideal for quickly serving static files. We can launch it on port <strong class="source-inline">9000</strong> thanks to the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ python -m http.server --directory chapter07/cors 9000</pre>			<p class="callout-heading">Starting several terminals</p>&#13;
			<p class="callout">On Linux and macOS, you should be able to simply start a new Terminal by creating a new window or tab. On Windows and WSL, you can also have several tabs if you’re using the Windows Terminal <span class="No-Break">application: </span><a href="https://apps.microsoft.com/store/detail/windows-terminal/9N0DX20HK701"><span class="No-Break">https://apps.microsoft.com/store/detail/windows-terminal/9N0DX20HK701</span></a><span class="No-Break">.</span></p>&#13;
			<p class="callout">Otherwise, you can simply click on the Ubuntu shortcut in your <strong class="bold">Start</strong> menu to start <span class="No-Break">another terminal.</span></p>&#13;
			<p>We now have two<a id="_idIndexMarker555"/> running servers – one on <strong class="source-inline">localhos<a id="_idTextAnchor508"/>t:8000</strong> and one on <strong class="source-inline">localhost:9000</strong>. Strictly speaking, since they are<a id="_idTextAnchor509"/> on different por<a id="_idTextAnchor510"/>ts, they are of different origins; so, it’s a good setup to try out cross-origin <span class="No-Break">HTTP requests.</span></p>&#13;
			<p>In your<a id="_idIndexMarker556"/> browser, go to <strong class="source-inline">http://localhost:9000</strong>. You’ll see the simple application implemented in <strong class="source-inline">index.html</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer031" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.3_B19528.jpg" alt="Figure 7.3 – Simple application to try CORS policies" width="1650" height="687"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Simple <a id="_idTextAnchor511"/>appl<a id="_idTextAnchor512"/>ication to try CORS policies</p>&#13;
			<p>There <a id="_idTextAnchor513"/>are two buttons that initiate GET and POST requests to our FastAPI application on port <strong class="source-inline">8000</strong>. If you click on either of those, you’ll get a message in the error area stating <strong class="bold">Failed to fetch</strong>. If you look at the browser console in the development tools section, you’ll see that the request failed because there isn’t a CORS policy, as shown in the following screenshot. That’s what we wanted – by default, browsers block cross-origin <span class="No-Break">HTTP requests:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer032" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.4_B19528.jpg" alt="Figure 7.4 – CORS error in browser console" width="1650" height="426"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 –<a id="_idTextAnchor514"/> COR<a id="_idTextAnchor515"/>S error in browser console</p>&#13;
			<p>However<a id="_idTextAnchor516"/>, if <a id="_idIndexMarker557"/>you <a id="_idIndexMarker558"/>look at the terminal running the FastAPI application, you’ll see an output similar to <span class="No-Break">the following:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer033" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.5_B19528.jpg" alt="Figure 7.5 – Uvicorn output when performing simple requests" width="1056" height="381"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Uvicorn output whe<a id="_idTextAnchor517"/>n performing simple requests</p>&#13;
			<p>Clearly, both<a id="_idIndexMarker559"/> the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> re<a id="_idTextAnchor518"/>quest<a id="_idTextAnchor519"/>s have been received<a id="_idIndexMarker560"/> and processed: we even returned a <strong class="source-inline">200</strong> status. So, what does this mean? In this case, the browser does send the request to the server. The lack of a CORS policy only forbids it to read the response; the request is <span class="No-Break">still executed.</span></p>&#13;
			<p>This is the case for requests that the browser considers <strong class="bold">simple requests</strong>. In essence, simple requests are those using the <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, or <strong class="source-inline">HEAD</strong> methods that don’t set custom headers or unusual content types. You can learn more about simple requests and their conditions by going to the following MDN page about <span class="No-Break">CORS: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests</span></a><span class="No-Break">.</span></p>&#13;
			<p>This means that, for simple requests, the same-origin policy is not enough to protect us against <span class="No-Break">CSRF attacks.</span></p>&#13;
			<p>You may have noticed that our simple web application has a toggle for <strong class="bold">Enable JSON content-type</strong>. Enable this and perform the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests again. On your FastAPI terminal, you should have an output similar to <span class="No-Break">the following:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer034" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.6_B19528.jpg" alt="Figure 7.6 – Uvicorn output when receiving preflight requests" width="1055" height="409"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Uvicorn outp<a id="_idTextAnchor520"/>ut <a id="_idTextAnchor521"/>when receiving preflight requests</p>&#13;
			<p>As <a id="_idTextAnchor522"/>you can <a id="_idIndexMarker561"/>see, our <a id="_idIndexMarker562"/>server received two strange <a id="_idTextAnchor523"/>requests with the <strong class="source-inline">OPTIONS</strong> method. This is what we <a id="_idIndexMarker563"/>call <strong class="bold">preflight requests</strong> in the context of CORS policies. Those requests are initiated by the browser before it performs the actual request when it doesn’t consider it as a simple request. Here, we added the <strong class="source-inline">Content-Type</strong> header with a value of <strong class="source-inline">application/json</strong>, which is against the conditions of <span class="No-Break">simple requests.</span></p>&#13;
			<p>By performing this preflight request, the browser expects the server to provide information about what it is and isn’t allowed to do in terms of cross-origin HTTP requests. Since we’ve not implemented anything here, our server can’t provide a response to this preflight request. Hence, the browser stops there and doesn’t proceed with the <span class="No-Break">actual request.</span></p>&#13;
			<p>And that’s basically CORS: the server answers preflight queries with a set of HTTP headers that provide information to the browser about whether it’s allowed to make the request or not. In that<a id="_idIndexMarker564"/> sense, CORS doesn’t make your application more secure, it’s quite the contrary: it allows the relaxation of some rules so that a frontend application can make requests <a id="_idIndexMarker565"/>to a backend residing on another domain. That’s why it’s crucial to configure CORS properly, so it doesn’t expose you to <span class="No-Break">dangerous attacks.</span></p>&#13;
			<p>Fortunately, it’s fairly easy to do this with FastAPI. All we need<a id="_idTextAnchor524"/> to do is import and add the <strong class="source-inline">CORSMiddleware</strong> class provid<a id="_idTextAnchor525"/>ed by St<a id="_idTextAnchor526"/>arlette. You can see what this looks like in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app_with_cors.py</p>&#13;
			<pre class="source-code">&#13;
app.add_middleware(    CORSMiddleware,&#13;
    allow_origins=["http://localhost:9000"],&#13;
    allow_credentials=True,&#13;
    allow_methods=["*"],&#13;
    allow_headers=["*"],&#13;
    max_age=-1,  # Only for the sake of the example. Remove this in your own project.&#13;
)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/cors/app_with_cors.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/cors/app_with_cors.py</a></p>&#13;
			<p>A middleware is a special class that adds global logic to an <strong class="bold">Asynchronous Server Gateway Interface (ASGI)</strong> application performing things before the request is handled by your path operation functions, and also after to possibly alter the response. FastAPI provides the <strong class="source-inline">add_middleware</strong> method for wiring such middleware into <span class="No-Break">your application.</span></p>&#13;
			<p>Here, <strong class="source-inline">CORSMiddleware</strong> will catch preflight requests sent by the browser and return the appropriate response with the CORS headers corresponding to your configuration. You can see that there are options to finely tune the CORS policy to <span class="No-Break">your needs.</span></p>&#13;
			<p>The most important one is probably <strong class="source-inline">allow_origins</strong>, which is the list of origins allowed to make requests to your API. Since our HTML application is served from <strong class="source-inline">http://localhost:9000</strong>, this is what we put here in this argument. If the browser tries to make requests from any other origin, it will stop as it’s not authorized to do so by <span class="No-Break">CORS headers.</span></p>&#13;
			<p>The other<a id="_idIndexMarker566"/> interesting argument is <strong class="source-inline">allow_credentials</strong>. By <a id="_idIndexMarker567"/>default, browsers don’t send cookies for cross-origin HTTP requests. If we wish to make authenticated requests to our API, we need to allow this via <span class="No-Break">this option.</span></p>&#13;
			<p>We can also finely tune the allowed methods and headers that are sent in the request. You can find a complete list of arguments for this middleware in the official Starlette <span class="No-Break">documentation: </span><a href="https://www.starlette.io/middleware/#corsmiddleware"><span class="No-Break">https://www.star<span id="_idTextAnchor527"/>lette<span id="_idTextAnchor528"/>.io/middleware/#corsmiddleware</span></a><span class="No-Break">.</span></p>&#13;
			<p>Le<a id="_idTextAnchor529"/>t’s quickly talk about the <strong class="source-inline">max_age</strong> parameter. This parameter allows you to control the cache duration of the CORS responses. Having to perform a preflight request before the actual one is an expensive operation. To improve performance, browsers can cache the response so that they don’t have to do this every time. Here, we are disabling caching with a value of <strong class="source-inline">-1</strong> to make sure you see the behavior of the browser in this example. In your projects, you can remove this argument so that you have a proper <span class="No-Break">cache value.</span></p>&#13;
			<p>Now, let’s see how our web application behaves with this CORS-enabled application. Stop the previous FastAPI app and run this one using the <span class="No-Break">usual command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ uvicorn chapter07.cors.app_with_cors:app</pre>			<p>Now, if you try to perform the requests from the HTML application, you should see a working response in each case, both with and without a JSON content type. If you look at the FastAPI terminal, you should see an output similar to <span class="No-Break">the following:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer035" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.7_B19528.jpg" alt="Figure 7.7 – Uvicorn output with CORS headers" width="1059" height="514"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7<a id="_idTextAnchor530"/> – Uvico<a id="_idTextAnchor531"/>rn output with CORS headers</p>&#13;
			<p>The two<a id="_idIndexMarker568"/> first<a id="_idIndexMarker569"/> requests are the “sim<a id="_idTextAnchor532"/>ple requests,” which don’t need a preflight request according to the browser rules. Then, we can see the requests that were performed with the JSON content type enabled. Before the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests, an <strong class="source-inline">OPTIONS</strong> request was performed: the <span class="No-Break">preflight request!</span></p>&#13;
			<p>Thanks to this configuration, you can now make cross-origin HTTP requests between your frontend application and your backend living on another origin. Once again, it’s not something that’ll improve the security of your application, but it allows you to make this specific scenario work while keeping it secure from the rest of <span class="No-Break">the web.</span></p>&#13;
			<p>Even if those policies can be a first layer of defense against CSRF, this doesn’t mitigate the risk completely. Indeed, the “simple requests” are still an issue: <strong class="source-inline">POST</strong> requests are allowed and, even if the response cannot be read, it’s actually executed on <span class="No-Break">the server.</span></p>&#13;
			<p>Now, let’s learn how to implement a pattern so that we’re completel<a id="_idTextAnchor533"/>y safe from such attacks: the <span class="No-Break"><strong class="bold">double-submit cookie</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-135">Implementing double-sub<a id="_idTextAnchor534"/>mit cookies to prevent CSRF attacks</h2>&#13;
			<p><a id="_idTextAnchor535"/>As <a id="_idIndexMarker570"/>we mentioned previously, when relying on cookies to store user credentials, we are exposed to CSRF attacks since browsers will automatically send the cookies to your server. This is especially<a id="_idIndexMarker571"/> true for what the browser considers “simple requests,” which don’t enforce the CORS policy before the request is executed. There are also other attack vectors involving traditional HTML form submissions or even the <strong class="source-inline">src</strong> attribute of the <span class="No-Break">image tag.</span></p>&#13;
			<p>For all these reasons, we need to have another layer of security to mitigate this risk. Once again, this is only necessary if you plan to use your API from a browser application and use cookies <span class="No-Break">for authentication.</span></p>&#13;
			<p>To help you understand this, we’ve built a new example application that uses a cookie to store the user access token. It’s very similar to the one we saw at the beginning of this chapter; we only modified it so that it looks for the access token in a cookie rather than in <span class="No-Break">a header.</span></p>&#13;
			<p>To make this example work, you’ll have to install the <strong class="source-inline">starlette-csrf</strong> library. We’ll explain what it does a bit later in this section. For now, just run the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install starlette-csrf</pre>			<p>In the following example, you can see the login endpoint that sets a cookie with the access <span class="No-Break">token value:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/login")async def login(&#13;
    response: Response,&#13;
    email: str = Form(...),&#13;
    password: str = Form(...),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
):&#13;
    user = await authenticate(email, password, session)&#13;
    if not user:&#13;
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)&#13;
    token = await create_access_token(user, session)&#13;
    response.set_cookie(&#13;
        TOKEN_COOKIE_NAME,&#13;
        token.access_token,&#13;
        max_age=token.max_age(),&#13;
        secure=True,&#13;
        httponly=True,&#13;
        samesite="lax",&#13;
    )</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/csrf/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Secon<span id="_idTextAnchor536"/>d-E<span id="_idTextAnchor537"/>dition/tree/main/chapter07/csrf/app.py</a></p>&#13;
			<p>Notice<a id="_idIndexMarker572"/> that we used the <strong class="source-inline">Secure</strong> and <strong class="source-inline">HttpOnly</strong> flags for the resulting cookie. This ensures that it’s sent <a id="_idIndexMarker573"/>only over HTTPS and that its value can’t be read from JavaScript, respectively. While this is not enough to prevent every kind of attack, it’s crucial for such <span class="No-Break">sensitive information.</span></p>&#13;
			<p>Besides that, we also set the <strong class="source-inline">SameSite</strong> flag to <strong class="source-inline">lax</strong>. It’s a quite recent flag that allows us to control how the cookie is sent in a cross-origin context. <strong class="source-inline">lax</strong> is the default value in most browsers and allows the cookie to be sent to subdomains of the cookie domain but prevents it for other sites. In a sense, it’s designed to be the standard, built-in protection against CSRF. However, other CSRF mitigation techniques, such as the one we’ll implement here, are still needed currently. Indeed, older browsers that are not compatible with the <strong class="source-inline">SameSite</strong> flag are <span class="No-Break">still vulnerable.</span></p>&#13;
			<p>Now, when<a id="_idIndexMarker574"/> checking for <a id="_idIndexMarker575"/>the authenticated user, we’ll just have to retrieve the token from the cookie that was sent in the request. Once again, FastAPI provides a security dependency to help with this, called <strong class="source-inline">APIKeyCookie</strong>. You can see it in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def get_current_user(    token: str = Depends(APIKeyCookie(name=TOKEN_COOKIE_NAME)),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
) -&gt; User:&#13;
    query = select(AccessToken).where(&#13;
        AccessToken.access_token == token,&#13;
        AccessToken.expiration_date &gt;= datetime.now(tz=timezone.utc),&#13;
    )&#13;
    result = await session.execute(query)&#13;
    access_token: AccessToken | None = result.scalar_one_or_none()&#13;
    if access_token is None:&#13;
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)&#13;
    return access_token.user</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/csrf/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-<span id="_idTextAnchor538"/>Second-Edition/tr<span id="_idTextAnchor539"/>ee/main/chapter07/csrf/app.py</a></p>&#13;
			<p>And that’s basically it! The rest of the code remains the same. Now, let’s implement an endpoint that allows us to update the email address of the authenticated user. You can see this in the<a id="_idIndexMarker576"/> <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker577"/></span><span class="No-Break"> example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.post("/me", response_model=schemas.UserRead)async def update_me(&#13;
    user_update: schemas.UserUpdate,&#13;
    user: User = Depends(get_current_user),&#13;
    session: AsyncSession = Depends(get_async_session),&#13;
):&#13;
    user_update_dict = user_update.dict(exclude_unset=True)&#13;
    for key, value in user_update_dict.items():&#13;
        setattr(user, key, value)&#13;
    session.add(user)&#13;
    await session.commit()&#13;
    return user</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/csrf/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/csrf/app.py</a></p>&#13;
			<p>The implementation is not very surprising and follows what we’ve seen so far. However, it exposes us to a CSRF threat. As you c<a id="_idTextAnchor540"/>an see, it uses t<a id="_idTextAnchor541"/>he <strong class="source-inline">POST</strong> method. If we make a request in the browser to this endpoint without any special header, it will consider it as a simple request and execute it. Therefore, an attacker could change the email of a currently authenticated user, which is a <span class="No-Break">major threat.</span></p>&#13;
			<p>This is exactly<a id="_idIndexMarker578"/> why we need CSRF protection here. In the context of a REST API, the most straightforward technique is the double-submit cookie pattern. Here is how <span class="No-Break">it works:</span></p>&#13;
			<ol>&#13;
				<li>The user makes a first request with a method that’s considered safe. Typically, this is a <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> request.</span></li>&#13;
				<li>In response, it receives a cookie containing a secret random value – that is, the <span class="No-Break">CSRF token.</span></li>&#13;
				<li>When making an unsafe request, such as <strong class="source-inline">POST</strong>, the user will read the CSRF token in the cookies and put the exact same value in a header. Since the browser also sends the cookies it has in memory, t<a id="_idTextAnchor542"/>he request will contain the token both in the cookie and the header. That’s why it’s called <span class="No-Break"><strong class="bold">double submit</strong></span><span class="No-Break">.</span></li>&#13;
				<li>Before <a id="_idIndexMarker579"/>processing the request, the server will compare the CSRF token provided in the header with the one present in the cookie. If they match, it will proceed to process the request. Otherwise, it’ll throw <span class="No-Break">an error.</span></li>&#13;
			</ol>&#13;
			<p>This is safe for <span class="No-Break">two reasons:</span></p>&#13;
			<ul>&#13;
				<li>An attacker targeting a third-party website can’t read the cookies for a domain they don’t own. Thus, they have no way of retrieving the CSRF <span class="No-Break">token value.</span></li>&#13;
				<li>Adding a custom header is against the conditions of “simple requests.” Hence, the browser will have to make a preflight request before sending the request, enforcing the <span class="No-Break">CORS policy.</span></li>&#13;
			</ul>&#13;
			<p>This is a widely used pattern that works well to prevent such risks. This is why we installed <strong class="source-inline">starlette-csrf</strong> at the beginning of this section: it provides<a id="_idTextAnchor543"/> a piece of mid<a id="_idTextAnchor544"/>dleware for <span class="No-Break">implementing it.</span></p>&#13;
			<p>We can use it just like any other middleware, as shown in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
app.add_middleware(    CSRFMiddleware,&#13;
    secret=CSRF_TOKEN_SECRET,&#13;
    sensitive_cookies={TOKEN_COOKIE_NAME},&#13;
    cookie_domain="localhost",&#13;
)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/csrf/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter07/csrf/app.py</a></p>&#13;
			<p>We set several<a id="_idIndexMarker580"/> important arguments here. First, we have the secret, which should be a strong passphrase that’s<a id="_idIndexMarker581"/> used to sign the CSRF token. Then, we have <strong class="source-inline">sensitive_cookies</strong>, which is a set of cookie names that should trigger the CSRF protection. If no cookie is present or if the provided ones are not critical, we can bypass the CSRF check. It’s also useful if you have other authentication methods available that don’t rely on cookies, such as Authorization headers, which are not vulnerable to CSRF. Finally, setting a cookie domain will allow you to retrieve the cookie containing the CSRF token, even if you are on a different subdomain; this is necessary in a <span class="No-Break">cross-origin situation.</span></p>&#13;
			<p>That’s all you need to have the necessary protection ready. To ease the process of getting a fresh CSRF token, we implemented a minimal GET endpoint called <strong class="source-inline">/csrf</strong>. Its sole purpose is to provide us with a simple way to set the CSRF token cookie. We can call it directly when we load our <span class="No-Break">frontend application.</span></p>&#13;
			<p>Now, let’s try it out in our situation. As we did in the previous section, we’ll run the FastAPI application and the simple HTML application on two different ports. To do this, just run the <span class="No-Break">following commands:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ uvicorn chapter07.csrf.app:app</pre>			<p>This will run the FastAPI application on port <strong class="source-inline">8000</strong>. Now, run the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pyt<a id="_idTextAnchor545"/>hon -m http.server <a id="_idTextAnchor546"/>--directory chapter07/csrf 9000</pre>			<p>The frontend application is now live on <strong class="source-inline">http://localhost:9000</strong>. Open it in your browser. You should see an interface similar to <span class="No-Break">the following:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer036" class="IMG---Figure">&#13;
					<img src="Images/Figure_7.8_B19528.jpg" alt="Figure 7.8 – Simple application to try a CSRF-protected API" width="1441" height="1182"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Simple application to try a CSRF-protected API</p>&#13;
			<p>Here, we’ve<a id="_idIndexMarker582"/> added forms to interact with our API endpoints: register, log in get authenticated user, and update the endpoints. If <a id="_idIndexMarker583"/>you try them out, they should work without any issue. If you have a look at the requests that were sent in the <strong class="bold">Network</strong> tab of the development tools section, you’ll see that the CSRF token is present in the cookies and in a header <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">x-csrftoken</strong></span><span class="No-Break">.</span></p>&#13;
			<p>At the top, there is a toggle to prevent the application from sending the CSRF token in the header. If you disable it, you’ll see that all <strong class="source-inline">POST</strong> operations will result in <span class="No-Break">an error.</span></p>&#13;
			<p>Great! We are now safe from CSRF attacks! Most of the work here is done by the middleware, but it’s interesting to understand how it works under the hood and how it protects your application. Bear in mind, however, that it comes with a drawback: it will break the interactive documentati<a id="_idTextAnchor547"/>on. Indeed, it’s no<a id="_idTextAnchor548"/>t designed to retrieve the CSRF token from the cookie and put it in the headers in each request. Unless you plan on authenticating in another way (through a token in a header, for example), you won<a id="_idTextAnchor549"/>’t be able to directly call your endpoints in <span class="No-Break">the documentation.</span></p>&#13;
			<h1 id="_idParaDest-136"><a id="_idTextAnchor550"/>Summary</h1>&#13;
			<p>That’s all for this chapter, which covered authentication and security in FastAPI. We saw that implementing a basic authentication system is quite easy thanks to the tools provided by FastAPI. We’ve shown you one way to do this, but there are plenty of other good patterns out there to tackle this challenge. However, when working on this matter, always keep security in mind and be sure that you don’t expose your application and your users’ data to dangerous threats. In particular, you’ve seen that CSRF attacks have to be taken care of when designing a REST API that will be used in a browser application. A good source to understand all the security risks involved in a web application is the OWASP Cheat Sheet <span class="No-Break">Series: </span><a href="https://cheatsheetseries.owasp.org"><span class="No-Break">https://cheatsheetseries.owasp.org</span></a><span class="No-Break">.</span></p>&#13;
			<p>With that, we’ve covered most of the important subjects concerning FastAPI application development. In the next chapter, we’ll learn how to work with a recent technology that’s integrated with FastAPI and that allows real-time, two-way communication between the client and the <span class="No-Break">server: </span><span class="No-Break">WebSockets</span><span class="No-Break">.</span></p>&#13;
		</div>&#13;
	</div></body></html>