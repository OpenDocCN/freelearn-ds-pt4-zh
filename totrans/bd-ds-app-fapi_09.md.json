["```py\n\nfrom fastapi import Depends, FastAPI, HTTPException, statusfrom fastapi.security import APIKeyHeader\nAPI_TOKEN = \"SECRET_API_TOKEN\"\napp = FastAPI()\napi_key_header = APIKeyHeader(name=\"Token\")\n@app.get(\"/protected-route\")\nasync def protected_route(token: str = Depends(api_key_header)):\n    if token != API_TOKEN:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)\n    return {\"hello\": \"world\"}\n```", "```py\n\nasync def api_token(token: str = Depends(APIKeyHeader(name=\"Token\"))):    if token != API_TOKEN:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)\n@app.get(\"/protected-route\", dependencies=[Depends(api_token)])\nasync def protected_route():\n    return {\"hello\": \"world\"}\n```", "```py\n\nclass User(Base):    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    email: Mapped[str] = mapped_column(\n        String(1024), index=True, unique=True, nullable=False\n    )\n    hashed_password: Mapped[str] = mapped_column(String(1024), nullable=False)\n```", "```py\n\nclass UserBase(BaseModel):    email: EmailStr\n    class Config:\n        orm_mode = True\nclass UserCreate(UserBase):\n    password: str\nclass User(UserBase):\n    id: int\n    hashed_password: str\nclass UserRead(UserBase):\n    id: int\n```", "```py\n\n(venv) $ pip install passlib argon2_cffi\n```", "```py\n\nfrom passlib.context import CryptContextpwd_context = CryptContext(schemes=[\"argon2\"], deprecated=\"auto\")\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n```", "```py\n\n@app.post(    \"/register\", status_code=status.HTTP_201_CREATED, response_model=schemas.UserRead\n)\nasync def register(\n    user_create: schemas.UserCreate, session: AsyncSession = Depends(get_async_session)\n) -> User:\n    hashed_password = get_password_hash(user_create.password)\n    user = User(\n        *user_create.dict(exclude={\"password\"}), hashed_password=hashed_password\n    )\n    try:\n        session.add(user)\n        await session.commit()\n    except exc.IntegrityError:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST, detail=\"Email already exists\"\n        )\n    return user\n```", "```py\n\nclass AccessToken(Base):    __tablename__ = \"access_tokens\"\n    access_token: Mapped[str] = mapped_column(\n        String(1024), primary_key=True, default=generate_token\n    )\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"), nullable=False)\n    expiration_date: Mapped[datetime] = mapped_column(\n        DateTime, nullable=False, default=get_expiration_date\n    )\n    user: Mapped[User] = relationship(\"User\", lazy=\"joined\")\n```", "```py\n\n@app.post(\"/token\")async def create_token(\n    form_data: OAuth2PasswordRequestForm = Depends(OAuth2PasswordRequestForm),\n    session: AsyncSession = Depends(get_async_session),\n):\n    email = form_data.username\n    password = form_data.password\n    user = await authenticate(email, password, session)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n    token = await create_access_token(user, session)\n    return {\"access_token\": token.access_token, \"token_type\": \"bearer\"}\n```", "```py\n\nasync def authenticate(email: str, password: str, session: AsyncSession) -> User | None:    query = select(User).where(User.email == email)\n    result = await session.execute(query)\n    user: User | None = result.scalar_one_or_none()\n    if user is None:\n        return None\n    if not verify_password(password, user.hashed_password):\n        return None\n    return user\nasync def create_access_token(user: User, session: AsyncSession) -> AccessToken:\n    access_token = AccessToken(user=user)\n    session.add(access_token)\n    await session.commit()\n    return access_token\n```", "```py\n\nasync def get_current_user(    token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"/token\")),\n    session: AsyncSession = Depends(get_async_session),\n) -> User:\n    query = select(AccessToken).where(\n        AccessToken.access_token == token,\n        AccessToken.expiration_date >= datetime.now(tz=timezone.utc),\n    )\n    result = await session.execute(query)\n    access_token: AccessToken | None = result.scalar_one_or_none()\n    if access_token is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n    return access_token.user\n```", "```py\n\n@app.get(\"/protected-route\", response_model=schemas.UserRead)async def protected_route(user: User = Depends(get_current_user)):\n    return user\n```", "```py\n\n(venv) $ uvicorn chapter07.cors.app_without_cors:app\n```", "```py\n\n(venv) $ python -m http.server --directory chapter07/cors 9000\n```", "```py\n\napp.add_middleware(    CORSMiddleware,\n    allow_origins=[\"http://localhost:9000\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n    max_age=-1,  # Only for the sake of the example. Remove this in your own project.\n)\n```", "```py\n\n(venv) $ uvicorn chapter07.cors.app_with_cors:app\n```", "```py\n\n(venv) $ pip install starlette-csrf\n```", "```py\n\n@app.post(\"/login\")async def login(\n    response: Response,\n    email: str = Form(...),\n    password: str = Form(...),\n    session: AsyncSession = Depends(get_async_session),\n):\n    user = await authenticate(email, password, session)\n    if not user:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n    token = await create_access_token(user, session)\n    response.set_cookie(\n        TOKEN_COOKIE_NAME,\n        token.access_token,\n        max_age=token.max_age(),\n        secure=True,\n        httponly=True,\n        samesite=\"lax\",\n    )\n```", "```py\n\nasync def get_current_user(    token: str = Depends(APIKeyCookie(name=TOKEN_COOKIE_NAME)),\n    session: AsyncSession = Depends(get_async_session),\n) -> User:\n    query = select(AccessToken).where(\n        AccessToken.access_token == token,\n        AccessToken.expiration_date >= datetime.now(tz=timezone.utc),\n    )\n    result = await session.execute(query)\n    access_token: AccessToken | None = result.scalar_one_or_none()\n    if access_token is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n    return access_token.user\n```", "```py\n\n@app.post(\"/me\", response_model=schemas.UserRead)async def update_me(\n    user_update: schemas.UserUpdate,\n    user: User = Depends(get_current_user),\n    session: AsyncSession = Depends(get_async_session),\n):\n    user_update_dict = user_update.dict(exclude_unset=True)\n    for key, value in user_update_dict.items():\n        setattr(user, key, value)\n    session.add(user)\n    await session.commit()\n    return user\n```", "```py\n\napp.add_middleware(    CSRFMiddleware,\n    secret=CSRF_TOKEN_SECRET,\n    sensitive_cookies={TOKEN_COOKIE_NAME},\n    cookie_domain=\"localhost\",\n)\n```", "```py\n\n(venv) $ uvicorn chapter07.csrf.app:app\n```", "```py\n\n(venv) $ python -m http.server --directory chapter07/csrf 9000\n```"]