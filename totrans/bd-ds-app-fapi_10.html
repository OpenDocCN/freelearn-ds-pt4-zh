<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer045">&#13;
			<h1 id="_idParaDest-137" class="chapter-number"><a id="_idTextAnchor551"/>8<a id="_idTextAnchor552"/></h1>&#13;
			<h1 id="_idParaDest-138"><a id="_idTextAnchor553"/>Defining WebSockets for Two-Way Interactive Communication in FastAPI</h1>&#13;
			<p>HTTP is a simple yet powerful technique for sending data to and receiving data from a server. As we’ve seen, the principles of request and response are at the core of this protocol: when developing our API, our goal is to process the incoming request and build a response for the client. Thus, in order to get data from the server, the client always has to initiate a request first. In some contexts, however, this may not be very convenient. Imagine a typical chat application: when a user receives a new message, we would like them to be notified immediately by the server. Working only with HTTP, we would have to make requests every second to check whether new messages had arrived, which would be a massive waste of resources. This is why a new protocol has emerged: <strong class="bold">WebSocket</strong>. The goal of this protocol is to open a communication channel between a client and a server so that they can exchange data in real time, in <span class="No-Break">both directions.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Understanding the principles of two-way communication <span class="No-Break">with WebSockets</span></li>&#13;
				<li>Creating a WebSocket <span class="No-Break">with FastAPI</span></li>&#13;
				<li>Handling multiple WebSocket connections and <span class="No-Break">broadcasting messages</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor554"/>Technical requirements</h1>&#13;
			<p>For this chapter, you’ll require a Python virtual environment, just as we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>For the <em class="italic">Handling multiple WebSocket connections and broadcasting messages</em> section, you’ll need a running Redis server on your local computer. The easiest way is to run it as a Docker container. If you’ve never used Docker before, we recommend you read the <em class="italic">Getting started</em> tutorial in the official documentation at <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>. Once done, you’ll be able to run a Redis server with this <span class="No-Break">simple command:</span></p>&#13;
			<pre class="source-code">&#13;
$ docker run -d --name fastapi-redis -p 6379:6379 redis</pre>			<p>You’ll find all the code examples for this chapter in the dedicated GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter08"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter08</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-140"><a id="_idTextAnchor555"/>Understanding the principles of two-way communication with WebSockets</h1>&#13;
			<p>You have<a id="_idIndexMarker584"/> probably noticed that the name WebSockets is a direct reference to the traditional<a id="_idTextAnchor556"/> <a id="_idIndexMarker585"/>concept of <strong class="bold">sockets</strong> in Unix systems. While technically unrelated, they achieve the same goal: to open a <em class="italic">communication channel between two applications</em>. As w<a id="_idTextAnchor557"/>e said in the introduction, HTTP works only on a request-response principle, which makes the implementati<a id="_idTextAnchor558"/>on of applications that need real-time communication between the client and the server difficult <span class="No-Break">and inefficient.</span></p>&#13;
			<p>WebSockets try<a id="_idIndexMarker586"/> to solve that by opening a full-duplex communication channel, meaning that messag<a id="_idTextAnchor559"/>es can be sent in both directions and possibly at the same time. Once the channel is opened, the server can send messages to the client without having to wait for a request from <span class="No-Break">the client.</span></p>&#13;
			<p>Even if HTTP and WebSocket are different protocols, WebSockets have been designed to work with HTTP. Indeed, when opening a WebSocket, the connection is first initiated using an HTTP request and then upgraded to a WebSocket tunnel. This makes it compatible out of the box with the traditional ports <strong class="source-inline">80</strong> and <strong class="source-inline">443</strong>, which is extremely convenient because we can easily add this feature over existing web servers without the need for an <span class="No-Break">extra process.</span></p>&#13;
			<p>WebSockets also share another similarity with HTTP: URIs. As wi<a id="_idTextAnchor560"/>th HTTP, WebSockets are identifi<a id="_idTextAnchor561"/>ed through classic URIs, with a host, a path, and query parameters. Furthermore, we also have two schemes: <strong class="source-inline">ws</strong> (WebSocket) for insecu<a id="_idTextAnchor562"/>re connections and <strong class="source-inline">wss</strong> (WebSocket Secure) for <span class="No-Break">SSL-/TLS-encrypted connections.</span></p>&#13;
			<p>Finally, this protocol is well supported in browsers nowadays, and opening a connection with a server involves just a few lines of JavaScript, as we’ll see in <span class="No-Break">this chapter.</span></p>&#13;
			<p>However, handling<a id="_idIndexMarker587"/> this two-way communication channel is quite different from handling traditional HTTP requests. Since things happen in real time and in both directions, we’ll see<a id="_idIndexMarker588"/> that we have to think differently from what we are used to. In FastAPI, the asynchronous nature of the WebSocket implementation will greatly help us in finding our way <span class="No-Break">through t<a id="_idTextAnchor563"/>hat.</span></p>&#13;
			<h1 id="_idParaDest-141"><a id="_idTextAnchor564"/>Creating a WebSocket with FastAPI</h1>&#13;
			<p>Thanks to<a id="_idIndexMarker589"/> Starlette, FastAPI has built-in support for WebSockets. As we’ll see, defining a WebS<a id="_idTextAnchor565"/>ocket endpoint is quick and easy, and we’ll be <a id="_idIndexMarker590"/>able to get started in minutes. However, things will get more complex as we try to ad<a id="_idTextAnchor566"/>d more features to our endpoint logic. Let’s start simple, with a WebSocket that waits for messages and simply echoes <span class="No-Break">them back.</span></p>&#13;
			<p>In the following example, you’ll see the implementation of such a <span class="No-Break">simple case:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
from fastapi import FastAPI, WebSocketfrom starlette.websockets import WebSocketDisconnect&#13;
app = FastAPI()&#13;
@app.websocket("/ws")&#13;
async def websocket_endpoint(websocket: WebSocket):&#13;
    await websocket.accept()&#13;
    try:&#13;
        while True:&#13;
            data = await websocket.receive_text()&#13;
            await websocket.send_text(f"Message text was: {data}")&#13;
    except WebSocketDisconnect:&#13;
        pass</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/echo/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/echo/app.py</a></p>&#13;
			<p>The c<a id="_idTextAnchor567"/>ode is quite understandable by itself, but let’s focus on the important parts that differ from classic <span class="No-Break">HTTP endpoints.</span></p>&#13;
			<p>First of <a id="_idIndexMarker591"/>all, you see that FastAPI provides a special <strong class="source-inline">websocket</strong> decorator to create a We<a id="_idTextAnchor568"/>bSocket endpoint. As with regular endpoints, it takes<a id="_idIndexMarker592"/> the path at which it’ll be available as an argument. However, other arguments that don’t make sense in this context, such as the status code or response model, are <span class="No-Break">not available.</span></p>&#13;
			<p>Then, in the path operation function, we can inject a <strong class="source-inline">WebSocket</strong> object, which will provide us with all the methods to work with the WebSocket, as <span class="No-Break">we’ll see.</span></p>&#13;
			<p>The first method we are calling in the implementation is <strong class="source-inline">accept</strong>. This method should be called first as it tells the client that we agree to open <span class="No-Break">the tunnel.</span></p>&#13;
			<p>After that, you can see that we start an infinite loop. That’s the main difference with an HTTP endpoint: since we are opening a communication channel, it’ll remain open until the client or the server decides to close it. While it’s open, they can exchange as many messages as they need; hence, the infinite loop is here to remain open and repeat the logic until the tunnel <span class="No-Break">is closed.</span></p>&#13;
			<p>Inside the loop, we make the first call to the <strong class="source-inline">receive_text</strong> method. As you may have guessed, this returns the data sent by the client in plain text format. It’s important here to understand that <em class="italic">this method will block until data is received from the client</em>. Until that event, we won’t proceed with the rest of <span class="No-Break">the logic.</span></p>&#13;
			<p>We can see here the importance of asynchronous input/output, as we presented in <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specifici<a id="_idTextAnchor569"/>ties</em>. By creating an infinite loop waiting for incoming data, we could have blocked the whole server process in a traditional blocking paradigm. Here, thanks to the event loop, the process is able to answer other requests made by other clients while we are waiting for <span class="No-Break">this one.</span></p>&#13;
			<p>When data is received, the method returns the text data and we can proceed with the next line. <a id="_idTextAnchor570"/>Here, we simply send back the message to the client thanks to the <strong class="source-inline">send_text</strong> method. Once done, we are going bac<a id="_idTextAnchor571"/>k to the beginning of the loop to wait for <span class="No-Break">another message.</span></p>&#13;
			<p>You probably <a id="_idIndexMarker593"/>noticed that the whole loop is wrapped inside a <strong class="source-inline">try...except</strong> statement. This is necessary to <em class="italic">handle client disconnection</em>. Indeed, most <a id="_idIndexMarker594"/>of the time, our server will be blocked at the <strong class="source-inline">receive_text</strong> line, waiting for client data. If the client decides to disconnect, the tunnel will be closed and the <strong class="source-inline">receive_text</strong> call will fail, with a <strong class="source-inline">WebSocketDisconnect</strong> exception. That’s why it’s important to catch it to break the loop and properly finish <span class="No-Break">the function.</span></p>&#13;
			<p>Let’s try it! You can run the FastAPI application, as usual, thanks to the Uvicorn server. Here’s the command <span class="No-Break">you’ll need:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ uvicorn chapter08.echo.app:app</pre>			<p>Our client will be a simple HTML page with some <a id="_idTextAnchor572"/>JavaScript code to interact with the WebSocket. We’ll quickly go through this code after the demonstration. To run it, we can simply serve it with the built-in Python server, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ python -m http.server --directory chapter08/echo 9000</pre>			<p class="callout-heading">Starting several terminals</p>&#13;
			<p class="callout">On Linux and macOS, you should be able to simply start a new Terminal by creating a new window or tab. On Windows and WSL, you can also have several tabs if you’re using the Windows terminal <span class="No-Break">application: </span><a href="https://apps.microsoft.com/store/detail/windows-terminal/9N0DX20HK701"><span class="No-Break">https://apps.microsoft.com/store/detail/windows-terminal/9N0DX20HK701</span></a><span class="No-Break">.</span></p>&#13;
			<p class="callout">Otherwise, you can simply click on the Ubuntu shortcut in your <strong class="bold">Start</strong> menu to start <span class="No-Break">another terminal.</span></p>&#13;
			<p>This will serve our HTML page on port <strong class="source-inline">9000</strong> of your local machine. If you open the <strong class="source-inline">http://localhost:9000</strong> address, you’ll see a simple interface like the one <span class="No-Break">shown here:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer038" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.1_B19528.jpg" alt="Figure 8.1 – Simple application for trying the WebSocket" width="1650" height="572"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Simple application for trying the WebSocket</p>&#13;
			<p>You have a <a id="_idIndexMarker595"/>simple input form, allowing you to send messages to the server through the WebSo<a id="_idTextAnchor573"/>cket. They appear in green in the list, as seen in the screenshot. The <a id="_idIndexMarker596"/>server echoes back your messages, which then appear in yellow in <span class="No-Break">the list.</span></p>&#13;
			<p>You can see what’s happening under the hood by opening the <strong class="bold">Network</strong> tab in the developer to<a id="_idTextAnchor574"/>ols of your browser. Reload the page to force the WebSocket to reconnect. You should then see a row for the WebSocket connection. If you click on it, you’ll see a <strong class="bold">Messages</strong> tab where you can see all the messages passing through the WebSocket. You can see this interface in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>&#13;
			<div>&#13;
				<div id="_idContainer039" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.2_B19528.jpg" alt="Figure 8.2 – WebSocket messages visualization within the browser developer tools" width="1650" height="570"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – WebSocket messages visualization within the browser developer tools</p>&#13;
			<p>In the<a id="_idIndexMarker597"/> following example, you’ll see the JavaScript code used to<a id="_idIndexMarker598"/> open the WebSocket connection and to send and <span class="No-Break">receive messages:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">script.js</p>&#13;
			<pre class="source-code">&#13;
  const socket = new WebSocket('ws://localhost:8000/ws');  // Connection opened&#13;
  socket.addEventListener('open', function (event) {&#13;
    // Send message on form submission&#13;
    document.getElementById('form').addEventListener('submit', (event) =&gt; {&#13;
      event.preventDefault();&#13;
      const message = document.getElementById('message').value;&#13;
      addMessage(message, 'client');&#13;
      socket.send(message);&#13;
      event.target.reset();&#13;
    });&#13;
  });&#13;
  // Listen for messages&#13;
  socket.addEventListener('message', function (event) {&#13;
    addMessage(event.data, 'server');&#13;
  });</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/echo/script.js">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/echo/script.js</a></p>&#13;
			<p>As you <a id="_idIndexMarker599"/>ca<a id="_idTextAnchor575"/>n see, modern browsers provide a ve<a id="_idTextAnchor576"/>ry simple API to interact<a id="_idIndexMarker600"/> with WebSockets.<a id="_idTextAnchor577"/> You just have to instantiate a new <strong class="source-inline">WebSocket</strong> object with the URL of your endpoint and wire some event listeners: <strong class="source-inline">open</strong> when the connection is ready and <strong class="source-inline">message</strong> when data is received from the server. Finally, the <strong class="source-inline">send</strong> method allows you to send data to the server<a id="_idTextAnchor578"/>. You can view more details on the WebSocket API in the <span class="No-Break">MDN documentation:</span></p>&#13;
			<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/W<span id="_idTextAnchor579"/>ebSockets_API</span></a><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-142"><a id="_idTextAnchor580"/>Handling concurrency</h2>&#13;
			<p>In the<a id="_idIndexMarker601"/> prev<a id="_idTextAnchor581"/>ious example, we assumed that the client was always sending a message first: we wait for its message before sending it back. Once again, it’s the client that takes the initiative in <span class="No-Break">the conversation.</span></p>&#13;
			<p>However, in<a id="_idIndexMarker602"/> usual scenarios, the server can have data to send to the client without being at the initiative. In a chat application, another user can typically send one or several messages that we want to forward to the first user immediately. In this context, the blocking call to <strong class="source-inline">receive_text</strong> we showed in the previous example is a problem: while we are waiting, the server could have messages to forward to <span class="No-Break">the client.</span></p>&#13;
			<p>To solve this, we’ll rely on more advanced tools of the <strong class="source-inline">asyncio</strong> module. Indeed, it provides functions that allow us to schedule several coroutines concurrently and wait until one of them is complete. In our context, we can have a coroutine that waits for client messages and another one that sends data to it when it arrives. The first one that is fulfilled wins and we can start again with another <span class="No-Break">loop iteration.</span></p>&#13;
			<p>To make this clearer, let’s build another example, in which the server will once again echo the message of the client. Besides that, it’ll regularly send the current time to the client. You can see the implementation in the following <span class="No-Break">code snippet:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
async def echo_message(websocket: WebSocket):    data = await websocket.receive_text()&#13;
    await websocket.send_text(f"Message text was: {data}")&#13;
async def send_time(websocket: WebSocket):&#13;
    await asyncio.sleep(10)&#13;
    await websocket.send_text(f"It is: {datetime.utcnow().isoformat()}")&#13;
@app.websocket("/ws")&#13;
async def websocket_endpoint(websocket: WebSocket):&#13;
    await websocket.accept()&#13;
    try:&#13;
        while True:&#13;
            echo_message_task = asyncio.create_task(echo_message(websocket))&#13;
            send_time_task = asyncio.create_task(send_time(websocket))&#13;
            done, pending = await asyncio.wait(&#13;
                {echo_message_task, send_time_task},&#13;
                return_when=asyncio.FIRST_COMPLETED,&#13;
            )&#13;
            for task in pending:&#13;
                task.cancel()&#13;
            for task in done:&#13;
                task.result()&#13;
    except WebSocketDisconnect:&#13;
        await websocket.close()</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/concurrency/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/concurrency/app.py</a></p>&#13;
			<p>As you can <a id="_idIndexMarker603"/>see, we defined two coroutines: the first one, <strong class="source-inline">echo_message</strong>, waits for text messages from the client and sends them back, while the <a id="_idIndexMarker604"/>second one, <strong class="source-inline">send_time</strong>, waits for 10 seconds before sending the current time to the client. Bot<a id="_idTextAnchor582"/>h of them expect a WebSocket instance in <span class="No-Break">the argument.</span></p>&#13;
			<p>The most interesting part lives under the infinite loop: as you can see, we call our two functions, wrapped by the <strong class="source-inline">create_task</strong> function of <strong class="source-inline">asyncio</strong>. This transforms the coroutine into a <strong class="source-inline">task</strong> object. Under the hood, a task is how the event loop manages the execution of the coroutine. Put more simply, it gives us full control over the execution of the coroutine – we can retrieve its result or even <span class="No-Break">cancel it.</span></p>&#13;
			<p>Those <strong class="source-inline">task</strong> objects are necessary to work with <strong class="source-inline">asyncio.wait</strong>. This function is especially useful for <a id="_idIndexMarker605"/>running tasks concurrently. It expects a set of tasks to run in the first argument. By default, this function will block until all given tasks are completed. However, we can control that thanks to the <strong class="source-inline">return_when</strong> argument: in our case, we want it to block until one of the tasks is completed, which corresponds to the <strong class="source-inline">FIRST_COMPLETED</strong> value. The effect is the following: our server will launch the coroutines concurrently. The first one will block waiting for a client message, while the other one <a id="_idIndexMarker606"/>will block for 10 seconds. If the client sends a message before 10 seconds have passed, it’ll send the message back and complete. Otherwise, the <strong class="source-inline">send_time</strong> coroutine will send the current time <span class="No-Break">and complete.</span></p>&#13;
			<p>At that point, <strong class="source-inline">asyncio.wait</strong> will return us two sets: the first one, <strong class="source-inline">done</strong>, contains a set of completed tasks, while the other one, <strong class="source-inline">pending</strong>, contains a set of tasks not <span class="No-Break">yet completed.</span></p>&#13;
			<p>We want to now go back to the start of the loop to start again. However, we need to first cancel all the tasks that have not been completed; otherwise, they would pile up at each iteration, hence the iteration over the <strong class="source-inline">pending</strong> set to <strong class="source-inline">cancel</strong> <span class="No-Break">those tasks.</span></p>&#13;
			<p>Finally, we also make an iteration over the <strong class="source-inline">done</strong> tasks and call the <strong class="source-inline">result</strong> method on them. This method returns the result of the coroutine but also re-raises an exception that could have been raised inside. This is especially useful for once again handling the disconnection of the client: when waiting for client data, if the tunnel is closed, an exception is raised. Thus, our <strong class="source-inline">try...except</strong> statement can catch it to properly terminate <span class="No-Break">the function.</span></p>&#13;
			<p>If you try this example as we did previously, you’ll see that the server will regularly send you the current time but is also able to echo the messages <span class="No-Break">you send.</span></p>&#13;
			<p>This <strong class="source-inline">send_time</strong> example shows you how you can implement a process to send data to the client when an event happens on the server: new data is available in the database, an external process has finished a long computation, and so on. In the next section, we’ll see how we can properly handle the case of multiple clients sending messages to t<a id="_idTextAnchor583"/>he server, which then broadcasts them to all <span class="No-Break">the clients.</span></p>&#13;
			<p>That’s basically how you can handle concurrency with <strong class="source-inline">asyncio</strong>’s  tools. So far, everyone is able to connect to those WebSocket endpoints without any restriction. Of course, as with classic HTTP endpoints, you’ll likely need to authenticate a user before ope<a id="_idTextAnchor584"/>ning <span class="No-Break">the connection.</span></p>&#13;
			<h2 id="_idParaDest-143"><a id="_idTextAnchor585"/>Using dependencies</h2>&#13;
			<p>Just as <a id="_idIndexMarker607"/>with regular endpoints, you can use dependencies in <a id="_idIndexMarker608"/>WebSocket endpoints. They basically work the same way, as FastAPI is able to adapt its behavior to a <span class="No-Break">WebSocket context.</span></p>&#13;
			<p>The only drawback is that can’t use security dependencies, as we showed in <a href="B19528_07.xhtml#_idTextAnchor448"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Managing Authentication and Security in FastAPI</em>. Indeed, under the hood, most of them work by injecting the <strong class="source-inline">Request</strong> object, which only works for HTTP requests (we saw that WebSockets are injected in a <strong class="source-inline">WebSocket</strong> object instead). Trying to inject those dependencies in a WebSocket context will result in <span class="No-Break">an error.</span></p>&#13;
			<p>However, basic dependencies such as <strong class="source-inline">Query</strong>, <strong class="source-inline">Header</strong>, or <strong class="source-inline">Cookie</strong> work transparently. Let’s try them in our next example. In this one, we’ll inject two dependencies, <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>A <strong class="source-inline">username</strong> query parameter, which we’ll use to greet the user <span class="No-Break">on connection.</span></li>&#13;
				<li>A <strong class="source-inline">token</strong> cookie, which we’ll compare with a static value to keep the example simple. Of course, a proper strategy would be to have a proper user lookup, as we implemented in <a href="B19528_07.xhtml#_idTextAnchor448"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Managing Authentication and Security in FastAPI</em>. If t<a id="_idTextAnchor586"/>his cookie doesn’t have the required value, we’ll raise <span class="No-Break">an error.</span></li>&#13;
			</ul>&#13;
			<p>Let’s see the implementation in the <span class="No-Break">following sample:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.websocket("/ws")async def websocket_endpoint(&#13;
    websocket: WebSocket, username: str = "Anonymous", token: str = Cookie(...)&#13;
):&#13;
    if token != API_TOKEN:&#13;
        raise WebSocketException(status.WS_1008_POLICY_VIOLATION)&#13;
    await websocket.accept()&#13;
    await websocket.send_text(f"Hello, {username}!")&#13;
    try:&#13;
        while True:&#13;
            data = await websocket.receive_text()&#13;
            await websocket.send_text(f"Message text was: {data}")&#13;
    except WebSocketDisconnect:&#13;
        pass</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/dependencies/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/dependencies/app.py</a></p>&#13;
			<p>As you can see, injecting dependencies is no different from standard <span class="No-Break">HTTP endpoints.</span></p>&#13;
			<p>Then, we can <a id="_idIndexMarker609"/>have our dummy authentication logic. If it fails, we can raise a <strong class="source-inline">WebSocketException</strong>. It’s the WebSocket equivalent of <strong class="source-inline">HTTPException,</strong> which we<a id="_idIndexMarker610"/> saw in previous sections. Under the hood, FastAPI will handle this exception by closing the WebSocket with the specified status code. WebSockets have their own set of status codes. You can view a complete list of these on this MDN documentation page: <a href="https://developer.mozilla.org/fr/docs/Web/API/CloseEvent">https://developer.mozilla.org/fr/docs/Web/API/CloseEvent</a>. The most generic one when an error occurs <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1008</strong></span><span class="No-Break">.</span></p>&#13;
			<p>If it passes, we can start our classic echo server. Notice that we can use the <strong class="source-inline">username</strong> value as we wish in our logic. Here, we send a first message to greet the user on connection. If you try this with the HTML application, you’ll see this message first, as shown in the <span class="No-Break">following screenshot:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer040" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.3_B19528.jpg" alt="Figure 8.3 – Greeting message on connection" width="1650" height="763"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Greeting message on connection</p>&#13;
			<p>With the <a id="_idIndexMarker611"/>browser<a id="_idIndexMarker612"/> WebSocket API, query parameters can be passed into the URL and the browser automatically forwards the cookies. However, there is <em class="italic">no way to pass custom headers</em>. This means that if you rely on headers for authentication, you’ll have to either<a id="_idTextAnchor587"/> add one using cookies or implement an authentication message mechanism in the WebSocket logic itself. However, if you don’t plan to use your WebSocket with a browser, you can still rely on headers since most WebSocket clients <span class="No-Break">support them.</span></p>&#13;
			<p>You now have a good overview of how to add WebSockets to your FastAPI application. As we said, they are generally useful when several users are involved in real time and we need to broadcast messages to all of them. We’ll see in the next section how to impleme<a id="_idTextAnchor588"/>nt this <span class="No-Break">pattern reliably.</span></p>&#13;
			<h1 id="_idParaDest-144"><a id="_idTextAnchor589"/>Handling multiple WebSocket connections and broadcasting messages</h1>&#13;
			<p>As we<a id="_idIndexMarker613"/> said in the introduction to this chapter, a typical use case for WebSockets<a id="_idTextAnchor590"/> is to implement real-time communication across <a id="_idIndexMarker614"/>multiple clients, such as a<a id="_idIndexMarker615"/> chat application. In<a id="_idTextAnchor591"/> this configuration, several clients have an open WebSocket tunnel with the server. Thus, the role of the server is to <em class="italic">manage all the client connections and broadcast messages to all of them</em>: when a user sends a message, the server has to send it to all other clients in their WebSockets. We show you a schema of this <span class="No-Break">principle here:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer041" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.4_B19528.jpg" alt="Figure 8.4 – Multiple clients connected through a WebSocket to a server" width="1637" height="1069"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Multiple clients connected through a WebSocket to a server</p>&#13;
			<p>A first approach could be simply to keep a list of all WebSocket connections and iterate through them to broadcast messages. This would work but would<a id="_idTextAnchor592"/> quickly become problematic in a production environment. Indeed, most of the time, server processes run multiple workers when deployed. This means that instead of having only one proce<a id="_idTextAnchor593"/>ss serving requests, we can have several ones so that we can answer more requests<a id="_idIndexMarker616"/> concurrently. We could also think of deployments on multiple servers spread over several <span class="No-Break">data centers.</span></p>&#13;
			<p>Hence, nothing<a id="_idIndexMarker617"/> guarantees you that two clients opening a WebSocket are served by the same process. Our simple<a id="_idIndexMarker618"/> approach would fail in this configuration: since connections are kept in the process memory, the process receiving the message would not be able to broadcast the message to clients served by another process. We schematize this problem in the <span class="No-Break">following diagram:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer042" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.5_B19528.jpg" alt="Figure 8.5 – Multiple server workers without a message broker" width="1321" height="1013"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Multiple server workers without a mes<a id="_idTextAnchor594"/>sage broker</p>&#13;
			<p>To solve this, we generally rely<a id="_idIndexMarker619"/> on <strong class="bold">message brokers</strong>. Message <a id="_idTextAnchor595"/>brokers are pieces of software whose role is to receive messages published by a first program and broadcast them to programs that are subscribed to it. Usually, this <strong class="bold">publish-subscribe</strong> (<strong class="bold">pub-sub</strong>) pattern<a id="_idIndexMarker620"/> is organized into diff<a id="_idTextAnchor596"/>erent channels so that messages are clearly organized following their topic or usage. Some of the best-known message broker software includes Apache Kafka, RabbitMQ, and <a id="_idIndexMarker621"/>cloud-based implementations from <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), and <a id="_idIndexMarker622"/>Microsoft Azure: Amazon MQ, Cloud Pub/Sub, and Serv<a id="_idTextAnchor597"/>ice <span class="No-Break">Bus, respectively.</span></p>&#13;
			<p>Hence, our<a id="_idIndexMarker623"/> message broker will be <a id="_idIndexMarker624"/>unique in our architecture, and several <a id="_idIndexMarker625"/>server processes will connect to it to either publish or subscribe to messages. This architecture is schematized in the <span class="No-Break">following diagram:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer043" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.6_B19528.jpg" alt="Figure 8.6 – Multiple server workers with a message broker" width="1403" height="1013"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Multiple server w<a id="_idTextAnchor598"/>orkers with a message broker</p>&#13;
			<p>In this chapter, we’ll see how to set up a simple system using the <strong class="source-inline">broadcaster</strong> library from Encode (the crea<a id="_idTextAnchor599"/>tors of Starlette) and <em class="italic">Redis</em>, which will act as a <span class="No-Break">message broker.</span></p>&#13;
			<p class="callout-heading">A word on Redis</p>&#13;
			<p class="callout">At its core, Redis<a id="_idIndexMarker626"/> is a data store designed to achieve maximum performance. <a id="_idTextAnchor600"/>It’s widely used in the industry for storing temporary data that we want to access very quickly, such as caches or distributed locks. It also supports a<a id="_idTextAnchor601"/> basic pub/sub paradigm, which makes it a good candidate to be used as a message broker. You can learn more about this technology at its official <a id="_idIndexMarker627"/><span class="No-Break">website: </span><a href="https://redis.io"><span class="No-Break">https://redis.io</span></a><span class="No-Break">.</span></p>&#13;
			<p>First of all, let’s install the library with the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip inst<a id="_idTextAnchor602"/>all "broadcaster[redis]"</pre>			<p>This library <a id="_idIndexMarker628"/>will abstract away all the <a id="_idIndexMarker629"/>complexities of publishing and subsc<a id="_idTextAnchor603"/>ribing with Redis <span class="No-Break">for us.</span></p>&#13;
			<p>Let’s see<a id="_idIndexMarker630"/> the details of the implementation. In the following example, you’ll see the instantiation of the <span class="No-Break"><strong class="source-inline">Broadcaster</strong></span><span class="No-Break"> object:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
broadcast = Broadcast("redis://localhost:6379")CHANNEL = "CHAT"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/broadcast/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/broadcast/app.py</a></p>&#13;
			<p>As you can see, it only expects a URL to our Redis server. Notice also that we define a <strong class="source-inline">CHANNEL</strong> constant. This will be the name of the channel to publish and subscribe to messages. We choose a static value here for the sake of the example, but you could have dynamic channel names in a real-world application—to support several chat rooms, <span class="No-Break">for example.</span></p>&#13;
			<p>Then, we define two functions: one to subscribe to new messages and send them to the client and <a id="_idIndexMarker631"/>another one to publish messages received in the <a id="_idIndexMarker632"/>WebSocket. You can see these functions in<a id="_idIndexMarker633"/> the <span class="No-Break">following sample:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
class MessageEvent(BaseModel):    username: str&#13;
    message: str&#13;
async def receive_message(websocket: WebSocket, username: str):&#13;
    async with broadcast.subscribe(channel=CHANNEL) as subscriber:&#13;
        async for event in subscriber:&#13;
            message_event = MessageEvent.parse_raw(event.message)&#13;
            # Discard user's own messages&#13;
            if message_event.username != username:&#13;
                await websocket.send_json(message_event.dict())&#13;
async def send_message(websocket: WebSocket, username: str):&#13;
    data = await websocket.receive_text()&#13;
    event = MessageEvent(username=username, message=data)&#13;
    await broadcast.publish(channel=CHANNEL, message=event.json())</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/broadcast/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chap<span id="_idTextAnchor604"/>ter08/br<span id="_idTextAnchor605"/>oadcast/app.py</a></p>&#13;
			<p>First of all, notice that we defined a <a id="_idIndexMarker634"/>Pydantic model, <strong class="source-inline">MessageEvent</strong>, to help us structure the data contained in a message. Instead of just passing raw strings as we’ve been doing up to now, we have an object bearing both the message and <span class="No-Break">the username.</span></p>&#13;
			<p>The first function, <strong class="source-inline">receive_message</strong>, subscribes to the broadcast channel and waits for messages called <strong class="source-inline">event</strong>. The data of the message contains serialized JSON that we deserialize <a id="_idTextAnchor606"/>to instantiate a <strong class="source-inline">MessageEvent</strong> object. Notice that we use the <strong class="source-inline">parse_raw</strong> method of the Pydantic model, allowing us to parse the JSON string into an object in <span class="No-Break">one operation.</span></p>&#13;
			<p>Then, we check<a id="_idIndexMarker635"/> whether the message username is different from the current username. Indeed, since all users are subscribed to the channel, they will also receive the messages they sent themselves. That’s why we discard them based on the username to avoid this. Of course, in a real-world applic<a id="_idTextAnchor607"/>ation, you’ll likely want to rely on a unique user ID rather than a <span class="No-Break">simple username.</span></p>&#13;
			<p>Finally, we<a id="_idIndexMarker636"/> can send the message through the WebSocket thanks to the <strong class="source-inline">send_json</strong> method, which takes care of seria<a id="_idTextAnchor608"/>lizing the <span class="No-Break">dictionary automatically.</span><a id="_idTextAnchor609"/></p>&#13;
			<p>The second<a id="_idIndexMarker637"/> function, <strong class="source-inline">send_message</strong>, is there to publish a message to the broker. Quite simply, it waits for new data in the socket, structures it into a <strong class="source-inline">MessageEvent</strong> object, and then <span class="No-Break">publishes it.</span></p>&#13;
			<p>That’s about it for the <strong class="source-inline">broadcaster</strong> part. We then have the WebSocket implementation in itself, which is very similar to what we saw in the previous sections. You can see it in the <span class="No-Break">following sample:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@app.websocket("/ws")async def websocket_endpoint(websocket: WebSocket, username: str = "Anonymous"):&#13;
    await websocket.accept()&#13;
    try:&#13;
        while True:&#13;
            receive_message_task = asyncio.create_task(&#13;
                receive_message(websocket, username)&#13;
            )&#13;
            send_message_task = asyncio.create_task(send_message(websocket, username))&#13;
            done, pending = await asyncio.wait(&#13;
                {receive_message_task, send_message_task},&#13;
                return_when=asyncio.FIRST_COMPLETED,&#13;
            )&#13;
            for task in pending:&#13;
                task.cancel()&#13;
            for task in done:&#13;
                task.result()&#13;
    except WebSocketDisconnect:&#13;
        pass</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/broadcast/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/m<span id="_idTextAnchor610"/>ain/chapter08/broadcast/app.py</a></p>&#13;
			<p>Finally, we <a id="_idIndexMarker638"/>need to tell FastAPI to open the connection with the br<a id="_idTextAnchor611"/>oker when it <a id="_idIndexMarker639"/>starts<a id="_idIndexMarker640"/> the application and to close it when exiting, as you can see in the <span class="No-Break">following extract:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.py</p>&#13;
			<pre class="source-code">&#13;
@contextlib.asynccontextmanagerasync def lifespan(app: FastAPI):&#13;
    await broadcast.connect()&#13;
    yield&#13;
    await broadcast.disconnect()&#13;
app = FastAPI(lifespan=lifespan)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter08/broadcast/app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edit<span id="_idTextAnchor612"/>ion/blob/main/chapter08/broadcast/app.py</a></p>&#13;
			<p>Let’s now try this application! First, we’ll run the Uvicorn se<a id="_idTextAnchor613"/>rver. Be sure that your Redis container is running before starting, as we explained in the <em class="italic">Technical requirements</em> section. Here’s the command <span class="No-Break">you’ll need:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ uvicorn chapter08.broadcast.app:app</pre>			<p>We also provided <a id="_idIndexMarker641"/>a simple HTML client in the examples. To run it, we can simply serve it with the built-in Python server, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ python -m http.server --directory chapter08/broadcast 9000</pre>			<p>You can now<a id="_idIndexMarker642"/> access it through <strong class="source-inline">http://localhost:9000</strong>. If you open it twice in your browser, in two different windows, you<a id="_idIndexMarker643"/> can see whether the broadcasting is working. Input a username in the first window and click on <strong class="bold">Connect</strong>. Do the same in the second window with a different username. You can now send messages and see that they are broadcast to the other client, as depicted in the <span class="No-Break">following screenshot:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer044" class="IMG---Figure">&#13;
					<img src="Images/Figure_8.7_B19528.jpg" alt="Figure 8.7 – Multiple WebSockets clients broadcasting messages" width="1642" height="491"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Multiple WebSockets clients broadcasting messages</p>&#13;
			<p>That was a<a id="_idIndexMarker644"/> very quick overview of<a id="_idTextAnchor614"/> how you can implement broadcasting systems involving message brokers. Of course, we only covered<a id="_idTextAnchor615"/> the basics here, and much more complex things<a id="_idIndexMarker645"/> can be done with those<a id="_idIndexMarker646"/> powerful technologies. Once again, we see that FastAPI gives us access to powerful building bricks without locking us inside specific technologies or patterns: it’s very eas<a id="_idTextAnchor616"/>y to include new libraries to expand <span class="No-Break">our possibilities.</span></p>&#13;
			<h1 id="_idParaDest-145"><a id="_idTextAnchor617"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to work with one of the latest web technologies available: WebSockets. You are now able to open a two-way communication channel between a client and a server, allowing you to implement applications with real-time constraints. As you’ve seen, FastAPI makes it very easy to add such endpoints. Still, the way of thinking inside WebSockets logic is quite different from traditional HTTP endpoints: managing an infinite loop and handling several tasks at a time are completely new challenges. Fortunately, the asynchronous nature of the framework makes our life easier in this matter and helps us write concurrent code that is <span class="No-Break">easily understandable.</span></p>&#13;
			<p>Finally, we also had a quick overview of the challenges to solve when handling multiple clients that share messages between them. You saw that message broker software such as Redis is necessary to make this use case reliable across several <span class="No-Break">server processes.</span></p>&#13;
			<p>You are now acquainted with all the features of FastAPI. Up to now, we’ve shown very simple examples focused on a specific point. In the real world, however, you’ll likely develop big applications that can do a lot of things and grow larger over time. To make them reliable and maintainable and keep high-quality code, it’s necessary to test them to make sure they behave as intended and that you don’t introduce bugs when adding <span class="No-Break">new things.</span></p>&#13;
			<p>In the next chapter, you’ll see how to set up an efficient test environment <span class="No-Break">for FastAPI.</span></p>&#13;
		</div>&#13;
	</div></body></html>