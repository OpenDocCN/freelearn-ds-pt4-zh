<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer047">&#13;
			<h1 id="_idParaDest-146" class="chapter-number"><a id="_idTextAnchor618"/>9</h1>&#13;
			<h1 id="_idParaDest-147"><a id="_idTextAnchor619"/>Testing an API Asynchronously with pytest and HTTPX</h1>&#13;
			<p>In software development, a significant part of the developer’s work should be dedicated to writing tests. At first, you may be tempted to manually test your application by running it, making a few requests, and arbitrarily deciding that “everything works.” However, this approach is flawed and can’t guarantee that your program works in every circumstance and that you didn’t break things along <span class="No-Break">the way.</span></p>&#13;
			<p>That’s why several disciplines have emerged regarding software testing: unit tests, integration tests, end-to-end tests, acceptance tests, and others. These techniques aim to validate the functionality of software from a micro level, where we test single functions (unit tests), to a macro level, where we test a global feature that delivers value to the user (acceptance tests). In this chapter, we’ll focus on the first level: <span class="No-Break">unit testing.</span></p>&#13;
			<p>Unit tests are short programs designed to verify that our code behaves the way it should in every circumstance. You may think that tests are time-consuming to write and that they don’t add value to your software, but this will save you time in the long run: first of all, tests can be run automatically in a few seconds, ensuring that all your software works, without you needing to manually go over every feature. Secondly, when you introduce new features or refactor the code, you’re ensuring that you don’t introduce bugs to existing parts of the software. In conclusion, tests are just as important as the program itself, and they help you deliver reliable and <span class="No-Break">high-quality software.</span></p>&#13;
			<p>In this chapter, you’ll learn how to write tests for your FastAPI application, both for HTTP endpoints and WebSockets. To help with this, you’ll learn how to configure pytest, a well-known Python test framework, and HTTPX, an asynchronous HTTP client <span class="No-Break">for Python.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>An introduction to unit testing <span class="No-Break">with pytest</span></li>&#13;
				<li>Setting up the testing tools for FastAPI <span class="No-Break">with HTTPX</span></li>&#13;
				<li>Writing tests for REST <span class="No-Break">API endpoints</span></li>&#13;
				<li>Writing tests for <span class="No-Break">WebSocket endpoints</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-148"><a id="_idTextAnchor620"/>Technical requirements</h1>&#13;
			<p>For this chapter, you’ll require a Python virtual environment, just as we set up in <a href="B19528_01.xhtml#_idTextAnchor024"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Python Development </em><span class="No-Break"><em class="italic">Environment Setup</em></span><span class="No-Break">.</span></p>&#13;
			<p>For the <em class="italic">Communicating with a MongoDB database using Motor</em> section, you’ll need a running MongoDB server on your local computer. The easiest way to do this is to run it as a Docker container. If you’ve never used Docker before, we recommend that you refer to the <em class="italic">Getting started</em> tutorial in the official documentation at <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>. Once you have done this, you’ll be able to run a MongoDB server using this <span class="No-Break">simple command:</span></p>&#13;
			<pre class="source-code">&#13;
$ docker run -d --name fastapi-mongo -p 27017:27017 mongo:6.0</pre>			<p>The MongoDB server instance will then be available on your local computer at <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">27017</strong></span><span class="No-Break">.</span></p>&#13;
			<p>You’ll find all the code examples of this chapter in the dedicated GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09"><span class="No-Break">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-149"><a id="_idTextAnchor621"/>An introduction to unit testing with pytest</h1>&#13;
			<p>As we<a id="_idTextAnchor622"/> mentioned<a id="_idIndexMarker647"/> in the introduction, writing unit tests is an essential task in software<a id="_idTextAnchor623"/> development to deliver high-quality software. To help us be productive and efficient, a lot of libraries exist that provide tools and shortcuts dedicated to testing. In the<a id="_idIndexMarker648"/> Python standard library, a module exists for unit testing called <strong class="source-inline">unittest</strong>. Even though it’s quite common in Python code bases, many Python developers tend to prefer pytest, which provides a more lightweight syntax and powerful tools for advanced <span class="No-Break">use cases.</span></p>&#13;
			<p>In the following examples, we’ll write a unit test for a function called <strong class="source-inline">add</strong>, both with <strong class="source-inline">unittest</strong> and pytest, so that you can see how they compare on a basic use case. First, we’ll <span class="No-Break">install pytest:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install pytest</pre>			<p>Now, let’s see our simple <strong class="source-inline">add</strong> function, which simply performs <span class="No-Break">an addition:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_introduction.py</p>&#13;
			<pre class="source-code">&#13;
def add(a: int, b: int) -&gt; int:    return a + b</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction.py</a></p>&#13;
			<p>Now, let’s implement a<a id="_idIndexMarker649"/> test that checks that <em class="italic">2 + 3</em> is indeed equal to <em class="italic">5</em> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">unittest</strong></span><span class="No-Break">:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_introduction_unittest.py</p>&#13;
			<pre class="source-code">&#13;
import unittestfrom chapter09.chapter09_introduction import add&#13;
class TestChapter09Introduction(unittest.TestCase):&#13;
    def test_add(self):&#13;
        self.assertEqual(add(2, 3), 5)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_unittest.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_unittest.py</a></p>&#13;
			<p>As y<a id="_idTextAnchor624"/>ou can see, <strong class="source-inline">unittest</strong> expects us to define a class inheriti<a id="_idTextAnchor625"/>ng from <strong class="source-inline">TestCase</strong>. Then, each test lives in its own method. To assert that two values are equal, we must use the <span class="No-Break"><strong class="source-inline">assertEqual</strong></span><span class="No-Break"> method.</span></p>&#13;
			<p>To run this test, we can call the <strong class="source-inline">unittest</strong> module from the command line and pass it through the dotted path to our <span class="No-Break">test module:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ python -m unittest chapter09.chapter09_introduction_unittest.&#13;
----------------------------------------------------------------------&#13;
Ran 1 test in 0.000s&#13;
OK</pre>&#13;
			<p>In the output, each successful test is represented by a dot. If one or several tests are not successful, you will get a detailed error report for each, highlighting the failing assertion. You can try it by <a id="_idIndexMarker650"/>changing the assertion in <span class="No-Break">the test.</span></p>&#13;
			<p>Now, let’s write the same test <span class="No-Break">with pytest:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_introduction_pytest.py</p>&#13;
			<pre class="source-code">&#13;
from chapter09.chapter09_introduction import adddef test_add():&#13;
    assert add(2, 3) == 5</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest.py</a></p>&#13;
			<p>As you<a id="_idTextAnchor626"/> can see, it’s much shorter! Indeed, with pytest, you do<a id="_idTextAnchor627"/>n’t necessarily have to define a class: a simple function is enough. The only constraint to making it work is that the function name has to start with <strong class="source-inline">test_</strong>. This way, pytest can automatically discover the test functions. Secondly, it relies on the built-in <strong class="source-inline">assert</strong> statement instead of specific methods, allowing you to write comparisons <span class="No-Break">more naturally.</span></p>&#13;
			<p>To run this test, we must simply call the <strong class="source-inline">pytest</strong> executable with the path to our <span class="No-Break">test file:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pytest chapter09/chapter09_introduction_pytest.py=============== test session starts ===============&#13;
platform darwin -- Python 3.10.8, pytest-7.2.0, pluggy-1.0.0&#13;
rootdir: /Users/fvoron/Development/Building-Data-Science-Applications-with-FastAPI-Second-Edition, configfile: pyproject.toml&#13;
plugins: asyncio-0.20.2, cov-4.0.0, anyio-3.6.2&#13;
asyncio: mode=strict&#13;
collected 1 item&#13;
chapter09/chapter09_introduction_pytest.py .                      [100%]&#13;
================ 1 passed in 0.01s ===============</pre>&#13;
			<p>Once again, the output represents each successful test with a dot. Of course, if you change the test to make it fail, you’ll get a detailed error for the <span class="No-Break">failing assertion.</span></p>&#13;
			<p>It’s worth no<a id="_idTextAnchor628"/>ting that if you run pytest without any arguments, it<a id="_idTextAnchor629"/>’ll automatically discover all the tests living in your project, as long as their name starts <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">test_</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Here, we made a small <a id="_idIndexMarker651"/>comparison between <strong class="source-inline">unittest</strong> and pytest. For the rest of this chapter, we’ll stick with pytest, which should give you a more productive experience while <span class="No-Break">writing tests.</span></p>&#13;
			<p>Before focusing on FastAPI testing, let’s review two of the most powerful features of pytest: <strong class="source-inline">parametrize</strong> <span class="No-Break">and fixtu<a id="_idTextAnchor630"/>res.</span></p>&#13;
			<h2 id="_idParaDest-150"><a id="_idTextAnchor631"/>Generating tests with parametrize</h2>&#13;
			<p>In our prev<a id="_idTextAnchor632"/>ious<a id="_idIndexMarker652"/> example, with the <strong class="source-inline">add</strong> function, we <a id="_idIndexMarker653"/>only <a id="_idTextAnchor633"/>tested one addition test, <em class="italic">2 + 3</em>. Most of the time, we’ll want to check for more cases to ensure our function<a id="_idIndexMarker654"/> works in every circumstance. Our first approach could be to add more assertions to our test, <span class="No-Break">like so:</span></p>&#13;
			<pre class="source-code">&#13;
def test_add():    assert add(2, 3) == 5&#13;
    assert add(0, 0) == 0&#13;
    assert add(100, 0) == 100&#13;
    assert add(1, 1) == 2</pre>&#13;
			<p>While working, this method has two drawbacks: first, it may be a bit cumbersome to write the same assertion several times with only some parameters changing. In this example, it’s not too bad, but tests can be way more complex, as we’ll see with FastAPI. Second, we still only have one test: the first failing assertion will stop the test and the following ones won’t be <a id="_idIndexMarker655"/>executed. Thus, we’ll only know the result if we fix the failing assertion first and run the <span class="No-Break">test again.</span></p>&#13;
			<p>To help with this specific task, pytest <a id="_idIndexMarker656"/>provides the <strong class="source-inline">parametrize</strong> marker. In pytest, a <strong class="bold">marker</strong> is <a id="_idTextAnchor634"/>a special <a id="_idIndexMarker657"/>decorator that’s used to easily pass metadata to the test. Special behaviors can then be implemented, depending on the markers used by <span class="No-Break">the test.</span></p>&#13;
			<p>Here, <strong class="source-inline">paramet<a id="_idTextAnchor635"/>rize</strong> allows us to <a id="_idIndexMarker658"/>define several sets of variabl<a id="_idTextAnchor636"/>es that will be passed as arguments to the test function. At runtime, each set will generate a new and independent test. To understand this better, let’s look at how to use this marker to generate several tests for our <span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break"> function:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_introduction_pytest_parametrize.py</p>&#13;
			<pre class="source-code">&#13;
import pytestfrom chapter09.chapter09_introduction import add&#13;
@pytest.mark.parametrize("a,b,result", [(2, 3, 5), (0, 0, 0), (100, 0, 100), (1, 1, 2)])&#13;
def test_add(a, b, result):&#13;
    assert add(a, b) == result</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest_parametrize.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest_parametrize.py</a></p>&#13;
			<p>Here, you can see that we simply decorated our test function with the <strong class="source-inline">parametrize</strong> marker. The basic usage is as follows: the first argument is a string with the name of each parameter separated by a comma. Then, the second argument is a list of tuples. Each tuple contains the values of the parameters <span class="No-Break">in order.</span></p>&#13;
			<p>Our test function receives those parameters in arguments, each one named the way you specified previously. Thus, you can<a id="_idIndexMarker659"/> use them at will in the test logic. As you can see, the great benefit here is that we <a id="_idIndexMarker660"/>only have to write the <strong class="source-inline">assert</strong> statement once. Besides, it’s very quick to add a new test case: we just have to <a id="_idIndexMarker661"/>add another tuple to the <span class="No-Break"><strong class="source-inline">parametrize</strong></span><span class="No-Break"> marker.</span></p>&#13;
			<p>Now, let’s run t<a id="_idTextAnchor637"/>his test to see what happens by using<a id="_idTextAnchor638"/> the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pytest chapter09/chapter09_introduction_pytest_parametrize.py================ test session starts ================&#13;
platform darwin -- Python 3.10.8, pytest-7.2.0, pluggy-1.0.0&#13;
rootdir: /Users/fvoron/Development/Building-Data-Science-Applications-with-FastAPI-Second-Edition, configfile: pyproject.toml&#13;
plugins: asyncio-0.20.2, cov-4.0.0, anyio-3.6.2&#13;
asyncio: mode=strict&#13;
collected 4 items&#13;
chapter09/chapter09_introduction_pytest_parametrize.py ....   [100%]&#13;
================ 4 passed in 0.01s ================</pre>&#13;
			<p>As you can see, pytest executed <em class="italic">four tests instead of one</em>! This means that it generated four independent tests, along with their own sets of parameters. If several tests fail, we’ll be informed, and the output will tell us which set of parameters caused <span class="No-Break">the error.</span></p>&#13;
			<p>To conclude, <strong class="source-inline">parametrize</strong> is a very convenient way to test different outcomes when it’s given a different set <span class="No-Break">of parameters.</span></p>&#13;
			<p>While writing unit tests, you’ll often <a id="_idIndexMarker662"/>need variables and objects several times across your tests, such as app instances, fake data, and so on. To avoid having to <a id="_idIndexMarker663"/>repea<a id="_idTextAnchor639"/>t the same things over and <a id="_idIndexMarker664"/>over across your tests<a id="_idTextAnchor640"/>, pytest proposes an interesting <span class="No-Break">f<a id="_idTextAnchor641"/>eature: fixtures.</span></p>&#13;
			<h2 id="_idParaDest-151">Reusing test logic by creating fixtu<a id="_idTextAnchor642"/>res</h2>&#13;
			<p>When testing a large<a id="_idIndexMarker665"/> application, tests tend to<a id="_idIndexMarker666"/> become quite repetitive: lots of them will share the same boilerplate code <a id="_idIndexMarker667"/>before their actual assertion. Consider the following Pydantic models representing a person and their <span class="No-Break">postal address:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_introduction_fixtures.py</p>&#13;
			<pre class="source-code">&#13;
from datetime import datefrom enum import Enum&#13;
from pydantic import BaseModel&#13;
class Gender(str, Enum):&#13;
    MALE = "MALE"&#13;
    FEMALE = "FEMALE"&#13;
    NON_BINARY = "NON_BINARY"&#13;
class Address(BaseModel):&#13;
    street_address: str&#13;
    postal_code: str&#13;
    city: str&#13;
    country: str&#13;
class Person(BaseModel):&#13;
    first_name: str&#13;
    last_name: str&#13;
    gender: Gender&#13;
    birthdate: date&#13;
    interests: list[str]&#13;
    address: Address</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures.py</a></p>&#13;
			<p>T<a id="_idTextAnchor643"/>his example may look<a id="_idIndexMarker668"/> familiar: it was<a id="_idIndexMarker669"/> taken from <a href="B19528_04.xhtml#_idTextAnchor176"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Managing Pydantic Data Models in FastAPI</em>. Now, let’s say that we want to write tests with some instances of those models. Obviously, it would<a id="_idIndexMarker670"/> be a bit annoying to instantiate them in each test, filling them with <span class="No-Break">fake data.</span></p>&#13;
			<p>Fortunately, fixtures allow us to write them once and for all. The following example shows how to <span class="No-Break">use them:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_introduction_fixtures_test.py</p>&#13;
			<pre class="source-code">&#13;
import pytestfrom chapter09.chapter09_introduction_fixtures import Address, Gender, Person&#13;
@pytest.fixture&#13;
def address():&#13;
    return Address(&#13;
        street_address="12 Squirell Street",&#13;
        postal_code="424242",&#13;
        city="Woodtown",&#13;
        country="US",&#13;
    )&#13;
@pytest.fixture&#13;
def person(address):&#13;
    return Person(&#13;
        first_name="John",&#13;
        last_name="Doe",&#13;
        gender=Gender.MALE,&#13;
        birthdate="1991-01-01",&#13;
        interests=["travel", "sports"],&#13;
        address=address,&#13;
    )&#13;
def test_address_country(address):&#13;
    assert address.country == "US"&#13;
def test_person_first_name(person):&#13;
    assert person.first_name == "John"&#13;
def test_person_address_city(person):&#13;
    assert person.address.city == "Woodtown"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures_test.py</a></p>&#13;
			<p>Once again, pytest makes it very straightforward: fixtures are <em class="italic">simple functions</em> decorated <em class="italic">with the fixture decorator</em>. Inside, you<a id="_idIndexMarker671"/> can write any logic and return the object you’ll need in your tests. Here, in <strong class="source-inline">address</strong>, we instantiate an <strong class="source-inline">Address</strong> object with fake data and <span class="No-Break">return it.</span></p>&#13;
			<p>Now, how can we use this<a id="_idIndexMarker672"/> fixture? If you look at the <strong class="source-inline">test_address_country</strong> test, you’ll see some magic happening: by setting an <strong class="source-inline">address</strong> argument on the test function, pytest automatically detects that it corresponds to the <strong class="source-inline">address</strong> fixture, executes it, and passes its <a id="_idIndexMarker673"/>return value. Inside the test, we have our <strong class="source-inline">Address</strong> <a id="_idTextAnchor644"/>object ready to use. pytest calls this <em class="italic">requesting </em><span class="No-Break"><em class="italic">a fixture</em></span><span class="No-Break">.</span></p>&#13;
			<p>You may have noticed that we also defined another fixture, <strong class="source-inline">person</strong>. Once again, we instantiate a <strong class="source-inline">Person</strong> model with dummy data. The interesting thing to note, however, is that we actually requested the <strong class="source-inline">address</strong> fixture to use it inside! That’s what makes this system so powerful: fixtures can depend on other fixtures, which can also depend on others, and so on. In some way, it’s quite similar to dependency injection, as we discussed in <a href="B19528_05.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Dependency Injection </em><span class="No-Break"><em class="italic">in FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<p>With that, our quick introduction to pytest has come to an end. Of course, there are so many more things to say, but this will be enough for you to get started. If you want to explore this topic further, you can read the official pytest documentation, which includes tons of examples showing you how you can benefit from all its <span class="No-Break">features: </span><a href="https://docs.pytest.org/en/latest/"><span class="No-Break">https://docs.pytest.org/en/latest/</span></a><span class="No-Break">.</span></p>&#13;
			<p>Now, let’s focus on FastAPI. We’ll start by setting up the tools for<a id="_idTextAnchor645"/> testing <span class="No-Break">our applications.</span></p>&#13;
			<h1 id="_idParaDest-152"><a id="_idTextAnchor646"/>Setting up testing tools for FastAPI with HTTPX</h1>&#13;
			<p><a id="_idTextAnchor647"/>If you look at the FastA<a id="_idTextAnchor648"/>PI documentation regarding testing, you’ll see that it recommends that you use <strong class="source-inline">TestClient</strong> provided by Starlette. In this book, we’ll show you a different approach<a id="_idIndexMarker674"/> involving an HTTP client <span class="No-Break">called HTTPX.</span></p>&#13;
			<p>Why? The default <strong class="source-inline">TestClient</strong> is implemented in a way that makes it completely synchronous, meaning you can write tests without worrying about <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. This might sound nice, but we found that it causes some problems in practice: since your FastAPI app is designed to work asynchronously, you’ll likely have lots of services working asynchronously, such as the database drivers we saw in <a href="B19528_06.xhtml#_idTextAnchor346"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Databases and Asynchronous ORMs</em>. Thus, in your tests, you’ll probably need to perform some actions on those asynchronous services, such as filling a database with dummy data, which will make your tests asynchronous anyway. Melding the two approaches often leads to strange errors that are hard <span class="No-Break">to debug.</span></p>&#13;
			<p>Fortunately, HTTPX, an HTTP client created by the same team as Starlette, allows us to have a pure asynchronous<a id="_idIndexMarker675"/> HTTP client able to make requests to our FastAPI app. To make this approach work, we’ll need <span class="No-Break">three libraries:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">HTTPX</strong>, the client that will perform <span class="No-Break">HTTP requests</span></li>&#13;
				<li><strong class="source-inline">asgi-lifespan</strong>, a library for managing the lifespan events of your FastAPI <span class="No-Break">app programmatically</span></li>&#13;
				<li><strong class="source-inline">pytest-asyncio</strong>, an extension for pytest that allows us to write <span class="No-Break">asynchronous tests</span></li>&#13;
			</ul>&#13;
			<p>Let’s install those libraries using the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install httpx asgi-lifespan pyte<a id="_idTextAnchor649"/>st-asyncio</pre>			<p>Great! Now, let’s write <a id="_idTextAnchor650"/>some fixtures so that we can easily get an HTTP test client for a FastAPI application. This way, when writing a test, we’ll only have to request the fixture and we’ll be able to make a request <span class="No-Break">right away.</span></p>&#13;
			<p>In the following example, we are considering a simple FastAPI application that we want <span class="No-Break">to test:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app.py</p>&#13;
			<pre class="source-code">&#13;
import contextlibfrom fastapi import FastAPI&#13;
@contextlib.asynccontextmanager&#13;
async def lifespan(app: FastAPI):&#13;
    print("Startup")&#13;
    yield&#13;
    print("Shutdown")&#13;
app = FastAPI(lifespan=lifespan)&#13;
@app.get("/")&#13;
async def hello_world():&#13;
    return {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app.py</a></p>&#13;
			<p>In a separate test file, we’ll implement <span class="No-Break">two fixtures.</span></p>&#13;
			<p>The first one, <strong class="source-inline">event_loop</strong>, will <a id="_idIndexMarker676"/>ensure that we always work with the same event loop instance. It’s automatically requested by <strong class="source-inline">pytest-asyncio<a id="_idTextAnchor651"/></strong> before executing asynchronous tests. You can see its implementation in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest.fixture(scope="session")def event_loop():&#13;
    loop = asyncio.new_event_loop()&#13;
    yield loop&#13;
    loop.close()</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py</a></p>&#13;
			<p>Here, you can see that we simply create a new event loop before <em class="italic">yielding</em> it. As we discussed in <a href="B19528_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Python Programming Specificities</em>, using a generator allows us to “pause” the function’s execution and get back to the execution of its caller. This way, when the caller is done, we can execute cleanup operations, such as closing the loop. pytest is smart enough to handle this correctly in fixtures, so this is a very common pattern for setting up test data, using it, and destroying it after. We also use the same approach for lifespan functions <span class="No-Break">in FastAPI.</span></p>&#13;
			<p>Of course, this function is decorated with the <strong class="source-inline">fixture</strong> decorator to make it a fixture for pytest. You may have noticed that we set an argument called <strong class="source-inline">scope</strong> with the <strong class="source-inline">session</strong> value. This argument controls at which level the fixture should be instantiated. By default, it’s recreated <em class="italic">at the beginning of each single test function</em>. The <strong class="source-inline">session</strong> value is the highest level, meaning that the fixture is only created once at the beginning of the whole test run, which is relevant for our event loop. You can find out more about this more advanced<a id="_idIndexMarker677"/> feature in the official <span class="No-Break">documentation: </span><a href="https://docs.pytest.org/en/latest/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-packages-or-session"><span class="No-Break">https://docs.pytest.org/en/latest/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-pa<span id="_idTextAnchor652"/>ckages-or-session</span></a><span class="No-Break">.</span></p>&#13;
			<p>Next, we’ll implement <a id="_idTextAnchor653"/>our <strong class="source-inline">test_client</strong> fixture, which will create an instance of HTTPX for our FastAPI application. We must also remember to trigger the app events with <strong class="source-inline">asgi-lifespan</strong>. You can see what it looks like in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest_asyncio.fixtureasync def test_client():&#13;
    async with LifespanManager(app):&#13;
        async with httpx.AsyncClient(app=app, base_url="http://app.io") as test_client:&#13;
            yield test_client</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py</a></p>&#13;
			<p>Only three lines are needed. The first difference with fixtures we’ve seen so far is that this is an async function. In this case, notice that we used the <strong class="source-inline">@pytest_asyncio.fixture</strong> decorator instead of <strong class="source-inline">@pytest.fixture</strong>. It’s the async counterpart of this decorator provided by <strong class="source-inline">pytest-asyncio</strong> so async fixtures are correctly handled. In previous versions, using the standard decorator used to work but it’s <span class="No-Break">now discouraged.</span></p>&#13;
			<p>Then, we have two context managers: <strong class="source-inline">LifespanManager</strong> and <strong class="source-inline">httpx.AsyncClient</strong>. The first one ensures startup and shutdown events are executed, while the second one ensures that an HTTP session is ready. On both of them, we set the <strong class="source-inline">app</strong> variable: this is our FastAPI application instance we imported from its module, <strong class="source-inline">chapter09.chapter09_<a id="_idTextAnchor654"/>app </strong><span class="No-Break"><strong class="source-inline">import app</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Notice that we once again used a generator here, with <strong class="source-inline">yield</strong>. This is important because, even if we <a id="_idIndexMarker678"/>don’t have any more code after, <em class="italic">we need to close the context managers after we use our client</em>. If we used <strong class="source-inline">return</strong>, Python would have immediately closed them and we would end up with an <span class="No-Break">unusable client.</span></p>&#13;
			<p class="callout-heading">Organizing tests and global fixtures in projects</p>&#13;
			<p class="callout">In larger projects, you’ll likely <a id="_idIndexMarker679"/>have several test files to keep your tests organized. Usually, those files are placed in a <strong class="source-inline">tests</strong> folder at the root of your project. If your test files are prefixed with <strong class="source-inline">test_</strong>, they will be automatically discovered by pytest. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> shows an example <span class="No-Break">of this.</span></p>&#13;
			<p class="callout">Besides this, you’ll need the fixtures we defined in this section for all your tests. Rather than repeating them again and again in all your test files, pytest allows you to write global fixtures in a file named <strong class="source-inline">conftest.py</strong>. After putting it in your <strong class="source-inline">tests</strong> folder, it will automatically be imported, allowing you to request all the fixtures you define inside it. You can read more about this in the official documentation <span class="No-Break">at </span><span class="No-Break">https://docs.pytest.org/en/latest/reference/fixtures.html#conftest-py-sharing-fixtures-across-multiple-files</span><span class="No-Break">.</span></p>&#13;
			<p>As mentioned previously, <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> shows the test files in the <span class="No-Break"><strong class="source-inline">tests</strong></span><span class="No-Break"> folder:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer046" class="IMG---Figure">&#13;
					<img src="Images/Figure_9.1_B19528.jpg" alt="Figure 9.1 – Structure of a project with tests" width="478" height="838"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Structure of a project with tests</p>&#13;
			<p>That’s it! We now <a id="_idIndexMarker680"/>have all the fixtures ready to write tests for our REST API endpoints. That’s wh<a id="_idTextAnchor655"/>at we’ll do in the <span class="No-Break">next section.</span></p>&#13;
			<h1 id="_idParaDest-153">Writing tests for REST API e<a id="_idTextAnchor656"/>ndpoints</h1>&#13;
			<p>All the tools we need to<a id="_idIndexMarker681"/> test our FastA<a id="_idTextAnchor657"/>PI application are now ready. All these tests boil down to performing an HTTP request and checking the response<a id="_idIndexMarker682"/> to see whether it corresponds to what <span class="No-Break">we expect.</span></p>&#13;
			<p>Let’s start simply with a test for our <strong class="source-inline">hello_world</strong> path operation function. You can see it in the <span class="No-Break">following code:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest.mark.asyncioasync def test_hello_world(test_client: httpx.AsyncClient):&#13;
    response = await test_client.get("/")&#13;
    assert response.status_code == status.HTTP_200_OK&#13;
    json = response.json()&#13;
    assert json == {"hello": "world"}</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py</a></p>&#13;
			<p>First of all, notice that the test function is defined as async. As we mentioned previously, to make it work with pytest, we had to install <strong class="source-inline">pytest-asyncio</strong>. This extension provides the <strong class="source-inline">asyncio</strong> marker: each asynchronous test should be decorated with this marker <a id="_idTextAnchor658"/>to make it <span class="No-Break">work properly.</span></p>&#13;
			<p>Next, we request<a id="_idTextAnchor659"/> our <strong class="source-inline">test_client</strong> fixture, which we defined earlier. It gives us an HTTPX client instance ready to make requests to our FastAPI app. Note that we manually type hinted the fixture. While not strictly required, it’ll greatly help you if you use an IDE such as Visual Studio Code, which uses type hints to provide you with convenient <span class="No-Break">auto-completion features.</span></p>&#13;
			<p>Then, in the body of our test, we perform the request. Here, it’s a simple GET request to the <strong class="source-inline">/</strong> path. It returns an HTTPX <strong class="source-inline">Response</strong> object (which is <em class="italic">different</em> from the <strong class="source-inline">Response</strong> class of FastAPI) containing all the data of the HTTP response: the status code, the headers, and<a id="_idIndexMarker683"/> <span class="No-Break">the body.</span></p>&#13;
			<p>Finally, we make assertions based on this data. As you can see, we verify that the status code is indeed <strong class="source-inline">200</strong>. We also check the content of the body, which is a simple JSON object. Notice that <a id="_idIndexMarker684"/>the <strong class="source-inline">Response</strong> object has a convenient method called <strong class="source-inline">json</strong> for automatically parsing <span class="No-Break">JSON content.</span></p>&#13;
			<p>Great! We wrote our first FastAPI test! Of course, you’ll likely have more complex tests<a id="_idTextAnchor660"/>, typically ones for <span class="No-Break">POST endpoints.</span></p>&#13;
			<h2 id="_idParaDest-154">Writing tests for P<a id="_idTextAnchor661"/>OST endpoints</h2>&#13;
			<p>Testing a POST <a id="_idIndexMarker685"/>endpoint is not very differ<a id="_idTextAnchor662"/>ent from what we’ve seen<a id="_idIndexMarker686"/> earlier. The difference is that we’ll likely have more cases to check whether data validation is working. In the following example, we are implementing a POST endpoint that accepts a <strong class="source-inline">Person</strong> model in <span class="No-Break">the body:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_post.py</p>&#13;
			<pre class="source-code">&#13;
class Person(BaseModel):    first_name: str&#13;
    last_name: str&#13;
    age: int&#13;
@app.post("/persons", status_code=status.HTTP_201_CREATED)&#13;
async def create_person(person: Person):&#13;
    return person</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post.py</a></p>&#13;
			<p>An interesting test<a id="_idIndexMarker687"/> could be to ensure that an error is raised if some fields are missing in the request payload. In the following extract, we wrote two tests – one with an invalid payload and another <a id="_idIndexMarker688"/>with a <span class="No-Break">valid one:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_post_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest.mark.asyncioclass TestCreatePerson:&#13;
    async def test_invalid(self, test_client: httpx.AsyncClient):&#13;
        payload = {"first_name": "John", "last_name": "Doe"}&#13;
        response = await test_client.post("/persons", json=payload)&#13;
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY&#13;
    async def test_valid(self, test_client: httpx.AsyncClient):&#13;
        payload = {"first_name": "John", "last_name": "Doe", "age": 30}&#13;
        response = await test_client.post("/persons", json=payload)&#13;
        assert response.status_code == status.HTTP_201_CREATED&#13;
        json = response.json()&#13;
        assert json == payload</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_<span id="_idTextAnchor663"/>app_post_test.py</a></p>&#13;
			<p>The first thing you may have noticed<a id="_idTextAnchor664"/> is that we wrapped our two tests inside a class. While not required in pytest, it could help you organize your tests – for example, to regroup tests that concern a single endpoint. Notice that, in this case, we only have to decorate the class with the <strong class="source-inline">asyncio</strong> marker; it will be automatically applied on single tests. Also, ensure that you add the <strong class="source-inline">self</strong> argument to each test: since we are now inside a class, they <span class="No-Break">become methods.</span></p>&#13;
			<p>These tests are not<a id="_idIndexMarker689"/> very different from our first example. As you can see, the HTTPX client makes it very easy to perform POST requests with a JSON payload: you just have to pass a dictionary to<a id="_idTextAnchor665"/> the <span class="No-Break"><strong class="source-inline">json</strong></span><span class="No-Break"> argument.</span></p>&#13;
			<p>Of course, HTTPX helps you build all <a id="_idTextAnchor666"/>kinds of HTTP requests with headers, query parameters, and so on. Be sure to check its official documentation to learn more about its <span class="No-Break">usage: </span><a href="https://www.python-httpx.org/quickstart/"><span class="No-Break"><span id="_idTextAnchor667"/>https://www.python-httpx.org/quickstart/</span></a><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-155">Testing wi<a id="_idTextAnchor668"/>th a database</h2>&#13;
			<p>Your application will lik<a id="_idTextAnchor669"/>ely <a id="_idIndexMarker690"/>have a database connection to read and store data. In this context, you’ll need to work with a fresh test database in each run to have a clean and predictable set of data to write <span class="No-Break">your tests.</span></p>&#13;
			<p>For this, we’ll use two things. The first one, <strong class="source-inline">dependency_overrides</strong>, is a FastAPI feature that allows us to replace some dependencies at runtime. For example, we can replace the dependency that returns the database instance with another one that returns a test database instance. The second one is, once again, fixtures, which will help us create fake data in the test database before we run <span class="No-Break">the tests.</span></p>&#13;
			<p>To show you a working example, we’ll consider the same example we built in the <em class="italic">Communicating with a MongoDB database with Motor</em> section of <a href="B19528_06.xhtml#_idTextAnchor346"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Databases and Asynchronous ORMs</em>. In that example, we built REST endpoints to manage blog posts. As you may recall, we had a <strong class="source-inline">get_database</strong> dependency that returned the database instance. As a reminder, we show it <span class="No-Break">again here:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">database.py</p>&#13;
			<pre class="source-code">&#13;
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase# Connection to the whole server&#13;
motor_client = AsyncIOMotorClient("mongodb://localhost:27017")&#13;
# Single database instance&#13;
database = motor_client["chapter6_mongo"]&#13;
def get_database() -&gt; AsyncIOMotorDatabase:&#13;
    return database</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter6/mongodb/database.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter6/mongodb/database.py</a></p>&#13;
			<p>Path operation functions and other dependencies would then use this dependency to retrieve the <span class="No-Break">database instance.</span></p>&#13;
			<p>For our tests, we’ll create <a id="_idIndexMarker691"/>a new instance of <strong class="source-inline">AsyncIOMotorDatabase</strong> that points to another database. Then, we’ll create a new dependency, directly in our test file, that returns this instance. You can see this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_db_test.py</p>&#13;
			<pre class="source-code">&#13;
motor_client = AsyncIOMotorClient(    os.getenv("MONGODB_CONNECTION_STRING", "mongodb://localhost:27017")&#13;
)&#13;
database_test = motor_client["chapter09_db_test"]&#13;
def get_test_database():&#13;
    return database_test</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/<span id="_idTextAnchor670"/>main/chapter09/chapter09_db_test.py</a></p>&#13;
			<p>Then, in our <strong class="source-inline">test_client</strong> fixture, we’ll <a id="_idTextAnchor671"/>override<a id="_idIndexMarker692"/> the default <strong class="source-inline">get_database</strong> dependency by using our current <strong class="source-inline">get_test_database</strong> dependency. The following example shows how this <span class="No-Break">is done:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_db_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest_asyncio.fixtureasync def test_client():&#13;
    app.dependency_overrides[get_database] = get_test_database&#13;
    async with LifespanManager(app):&#13;
        async with httpx.AsyncClient(app=app, base_url="http://app.io") as test_client:&#13;
            yield test_client</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py</a></p>&#13;
			<p>FastAPI provides a property called <strong class="source-inline">dependency_overrides</strong>, which is a dictionary that maps original dependency functions with substitutes. Here, we directly used the <strong class="source-inline">get_database</strong> function as a key. The rest of the fixture doesn’t have to change. Now, whenever the <strong class="source-inline">get_database</strong> dependency is injected into the application code, FastAPI will automatically replace it with <strong class="source-inline">get_test_database</strong>. As a result, our endpoints will now work with the test <span class="No-Break">database instance.</span></p>&#13;
			<p class="callout-heading">app and dependency_overrides are global</p>&#13;
			<p class="callout">Since we are directly importing <strong class="source-inline">app</strong> from its module, it’s instantiated only once for the whole test run. It means that <strong class="source-inline">dependency_overrides</strong> is common for every test. Keep this in mind if someday you want to override a dependency for a single test: once you’ve set it, it’ll be set for the rest of the execution. In this case, you can reset <strong class="source-inline">dependency_overrides</strong> by using <strong class="source-inline">app.dependency_ov<a id="_idTextAnchor672"/>errides = {}</strong>.</p>&#13;
			<p>To test some behaviors, such <a id="_idIndexMarker693"/>as retr<a id="_idTextAnchor673"/>ieving a single post, it’s usually convenient to have some base data in our test database. To allow this, we’ll create a new fixture that will instantiate dummy <strong class="source-inline">PostDB</strong> objects and insert them into the test database. You can see this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_db_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest_asyncio.fixture(autouse=True, scope="module")async def initial_posts():&#13;
    initial_posts = [&#13;
        Post(title="Post 1", content="Content 1"),&#13;
        Post(title="Post 2", content="Content 2"),&#13;
        Post(title="Post 3", content="Content 3"),&#13;
    ]&#13;
    await database_test["posts"].insert_many(&#13;
        [post.dict(by_alias=True) for post in initial_posts]&#13;
    )&#13;
    yield initial_posts&#13;
    await motor_client.drop_database("chapter09_db_test")</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py</a></p>&#13;
			<p>Here, you can see that we just had to make an <strong class="source-inline">insert_many</strong> request to the MongoDB database to create <span class="No-Break">the posts.</span></p>&#13;
			<p>Notice that we used the <strong class="source-inline">autouse</strong> and <strong class="source-inline">scope</strong> arguments of the <strong class="source-inline">fi<a id="_idTextAnchor674"/>xture</strong> decorator. The first one tells pytest to automatically call this fixture <em class="italic">even if it’s not requested in any test</em>. In this case, it’s convenient becau<a id="_idTextAnchor675"/>se we’ll always ensure that the data has been created in the database, without the risk of forgetting to request it in the tests. The other one, <strong class="source-inline">scope</strong>, allows us, as we mentioned previously, to not run this fixture at the beginning of each test. With the <strong class="source-inline">module</strong> value, the fixture will create the objects only once, at the beginning of this <a id="_idIndexMarker694"/>particular test file. It helps make the test fast because, in this case, it doesn’t make sense to recreate the posts before <span class="No-Break">each test.</span></p>&#13;
			<p>Once again, we <em class="italic">yield</em> the posts instead of returning them. This pattern allows us to delete the test database after the tests run. By doing this, we’re making sure that we always start with a fresh database when we’ve run <span class="No-Break">the tests.</span></p>&#13;
			<p>And we are done! We can now write tests while knowing exactly what we have in the database. In the following example, you can see tests that are used to verify the behavior of the endpoint retrieving a <span class="No-Break">single post:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_db_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest.mark.asyncioclass TestGetPost:&#13;
    async def test_not_existing(self, test_client: httpx.AsyncClient):&#13;
        response = await test_client.get("/posts/abc")&#13;
        assert response.status_code == status.HTTP_404_NOT_FOUND&#13;
    async def test_existing(&#13;
        self, test_client: httpx.AsyncClient, initial_posts: list[Post]&#13;
    ):&#13;
        response = await test_client.get(f"/posts/{initial_posts[0].id}")&#13;
        assert response.status_code == status.HTTP_200_OK&#13;
        json = response.json()&#13;
        assert json["_id"] == str(initial_posts[0].id)</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter0<span id="_idTextAnchor676"/>9/chapter09_db_test.py</a></p>&#13;
			<p>Notice that we requested <a id="_idTextAnchor677"/>the <strong class="source-inline">initial_posts</strong> fixture in the second test to retrieve the identifier of the post that truly exists in <span class="No-Break">our database.</span></p>&#13;
			<p>Of course, we can also test <a id="_idIndexMarker695"/>our endpoints by creating data and checking whether it was correctly inserted into the database. You can see this in the <span class="No-Break">following example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_db_test.py</p>&#13;
			<pre class="source-code">&#13;
@pytest.mark.asyncioclass TestCreatePost:&#13;
    async def test_invalid_payload(self, test_client: httpx.AsyncClient):&#13;
        payload = {"title": "New post"}&#13;
        response = await test_client.post("/posts", json=payload)&#13;
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY&#13;
    async def test_valid_payload(self, test_client: httpx.AsyncClient):&#13;
        payload = {"title": "New post", "content": "New post content"}&#13;
        response = await test_client.post("/posts", json=payload)&#13;
        assert response.status_code == status.HTTP_201_CREATED&#13;
        json = response.json()&#13;
        post_id = ObjectId(json["_id"])&#13;
        post_db = await database_test["posts"].find_one({"_id": post_id})&#13;
        assert post_db is not None</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py</a></p>&#13;
			<p>In the second test, we used the <strong class="source-inline">database_test</strong> instance to perform a request and check that the object was inserted correctly. This shows the benefit of using asynchronous tests: we can use the same libraries and tools inside <span class="No-Break">our tests.</span></p>&#13;
			<p>That’s all you need <a id="_idTextAnchor678"/>to know about <a id="_idTextAnchor679"/><strong class="source-inline">dependency_overrides</strong>. This feature is also very helpful when you need to write tests for logic involving external services, such as external APIs. Instead of<a id="_idIndexMarker696"/> making real requests to those external services during your tests, which could cause issues or incur costs, you’ll be able to replace them with another dependency that fakes the requests. To understand t<a id="_idTextAnchor680"/>his, we’ve bu<a id="_idTextAnchor681"/>ilt another example application with an endpoint for retrieving data from an <span class="No-Break">external API:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_external_api.py</p>&#13;
			<pre class="source-code">&#13;
class ExternalAPI:    def __init__(self) -&gt; None:&#13;
        self.client = httpx.AsyncClient(base_url="https://dummyjson.com")&#13;
    async def __call__(self) -&gt; dict[str, Any]:&#13;
        async with self.client as client:&#13;
            response = await client.get("/products")&#13;
            return response.json()&#13;
external_api = ExternalAPI()&#13;
@app.get("/products")&#13;
async def external_products(products: dict[str, Any] = Depends(external_api)):&#13;
    return products</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api.py</a></p>&#13;
			<p>To call our external API, we’ve built a class dependency, as we saw in the <em class="italic">Creating and using a parameterized dependency with a class</em> section of <a href="B19528_05.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Dependency Injection in FastAPI</em>. We use<a id="_idTextAnchor682"/> HTTPX as an HTTP client to make a request to the external API and retrieve the <a id="_idIndexMarker697"/>data. This external API is a dummy API containing fake data – very useful for experiments like <span class="No-Break">this: </span><a href="https://dummyjson.com"><span class="No-Break">https://dummyjson.com</span></a><span class="No-Break">.</span></p>&#13;
			<p>The <strong class="source-inline">/products</strong> endpoint is simply injected with this dependency and directly returns the data provided by the <span class="No-Break">external API.</span></p>&#13;
			<p>Of course, to test this endpoint, we don’t want to make real requests to the external API: it may take time and could be subject to rate limiting. Besides, you may want to test behavior that is not easy to reproduce in the real API, such <span class="No-Break">as errors.</span></p>&#13;
			<p>Thanks to <strong class="source-inline">dependency_overrides</strong>, it’s very easy to replace our <strong class="source-inline">ExternalAPI</strong> dependency class with another <a id="_idIndexMarker698"/>one that returns static data. In the following example, you can see how we implemented such <span class="No-Break">a test:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_app_external_api_test.py</p>&#13;
			<pre class="source-code">&#13;
class MockExternalAPI:    mock_data = {&#13;
        "products": [&#13;
            {&#13;
                "id": 1,&#13;
                "title": "iPhone 9",&#13;
                "description": "An apple mobile which is nothing like apple",&#13;
                "thumbnail": "https://i.dummyjson.com/data/products/1/thumbnail.jpg",&#13;
            },&#13;
        ],&#13;
        "total": 1,&#13;
        "skip": 0,&#13;
        "limit": 30,&#13;
    }&#13;
    async def __call__(self) -&gt; dict[str, Any]:&#13;
        return MockExternalAPI.mock_data&#13;
@pytest_asyncio.fixture&#13;
async def test_client():&#13;
    app.dependency_overrides[external_api] = MockExternalAPI()&#13;
    async with LifespanManager(app):&#13;
        async with httpx.AsyncClient(app=app, base_url="http://app.io") as test_client:&#13;
            yield test_client</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter<span id="_idTextAnchor683"/>09_app_external_api_test.py</a></p>&#13;
			<p>Here, you can see that w<a id="_idTextAnchor684"/>e wrote a simple class called <strong class="source-inline">MockExternalAPI</strong> that returns hardcoded data. All we have to do then is override the original dependency with this one. During the tests, the external API won’t be called; we’ll only work with the <span class="No-Break">static data.</span></p>&#13;
			<p>With the guidelines we’ve <a id="_idIndexMarker699"/>seen so far, you can now write tests for any HTTP endpoints in your FastAPI app. However, there is another kind of endpoint that behaves differently: WebSockets. As we’ll see in the next section, unit testing WebSockets is also quite d<a id="_idTextAnchor685"/>ifferent from what we described for <span class="No-Break">REST endpoints.</span></p>&#13;
			<h1 id="_idParaDest-156"><a id="_idTextAnchor686"/>Writing tests for WebSocket endpoints</h1>&#13;
			<p>In <a href="B19528_08.xhtml#_idTextAnchor551"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Defining WebSockets for Two-Way Int<a id="_idTextAnchor687"/>eractive Communication in FastAPI</em>, we exp<a id="_idTextAnchor688"/>lained how<a id="_idIndexMarker700"/> WebSockets work and how you can<a id="_idIndexMarker701"/> implement such endpoints in FastAPI. As you may have guessed, writing unit tests for WebSockets endpoints is quite different from what we’ve seen <span class="No-Break">so far.</span></p>&#13;
			<p>For this task, we’ll need to tweak our <strong class="source-inline">test_client</strong> fixture a little bit. Indeed, HTTPX doesn’t have built-in support to communicate with WebSockets. Hence, we’ll need to use a plugin, HTTPX WS. Let’s install it with the <span class="No-Break">following command:</span></p>&#13;
			<pre class="source-code">&#13;
(venv) $ pip install httpx-ws</pre>			<p>To enable support for WebSockets on our test client, we’ll change it <span class="No-Break">like this:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_websocket_test.py</p>&#13;
			<pre class="source-code">&#13;
from httpx_ws.transport import ASGIWebSocketTransport@pytest_asyncio.fixture&#13;
async def test_client():&#13;
    async with LifespanManager(app):&#13;
        async with httpx.AsyncClient(&#13;
            transport=ASGIWebSocketTransport(app), base_url="http://app.io"&#13;
        ) as test_client:&#13;
            yield test_client</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py</a></p>&#13;
			<p>You can see that, instead of <a id="_idIndexMarker702"/>directly setting the <strong class="source-inline">app</strong> argument, we set <strong class="source-inline">transport</strong> with a class provided by HTTPX WS. This class provides support to test apps with WebSockets endpoints. Other<a id="_idIndexMarker703"/> than that, nothing changes. It’s worth noting that testing standard HTTP endpoints will still work correctly, so you can use this test client for all <span class="No-Break">your tests.</span></p>&#13;
			<p>Now, let’s consider a simple WebSocket <span class="No-Break">endpoint example:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">chapter09_websocket.py</p>&#13;
			<pre class="source-code">&#13;
@app.websocket("/ws")async def websocket_endpoint(websocket: WebSocket):&#13;
    await websocket.accept()&#13;
    try:&#13;
        while True:&#13;
            data = await websocket.receive_text()&#13;
            await websocket.send_text(f"Message text was: {data}")&#13;
    except WebSocketDisconnect:&#13;
        await websocket.close()</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket.py</a></p>&#13;
			<p>You may have recognized the “echo” example from <a href="B19528_08.xhtml#_idTextAnchor551"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Defining WebSockets for Two-Way I<a id="_idTextAnchor689"/>nteractive Communication </em><span class="No-Break"><em class="italic">in FastAPI</em></span><span class="No-Break">.</span></p>&#13;
			<p>Now, let’s write a test for <a id="_idIndexMarker704"/>our WebSocket using our <span class="No-Break">test client:</span></p>&#13;
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Chapter09_websocket_test.py</p>&#13;
			<pre class="source-code">&#13;
from httpx_ws import aconnect_ws@pytest.mark.asyncio&#13;
async def test_websocket_echo(test_client: httpx.AsyncClient):&#13;
    async with aconnect_ws("/ws", test_client) as websocket:&#13;
        await websocket.send_text("Hello")&#13;
        message = await websocket.receive_text()&#13;
        assert message == "Message text was: Hello"</pre>&#13;
			<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py">https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py</a></p>&#13;
			<p>As you can see, HTTPX WS<a id="_idIndexMarker705"/> provides the <strong class="source-inline">aconnect_ws</strong> function to open a connection to a WebSocket endpoint. It expects the path of your WebSocket endpoint and a valid HTTPX client in an argument. By using <strong class="source-inline">test_client</strong>, we’ll make requests directly against our <span class="No-Break">FastAPI application.</span></p>&#13;
			<p>It opens a context manager, giving you the <strong class="source-inline">websocket</strong> variable. It’s an object that exposes several methods to either send or receive data. Each of those methods will block until a message has been sent <span class="No-Break">or received.</span></p>&#13;
			<p>Here, to test our “echo” server, we send a message thanks to the <strong class="source-inline">send_text</strong> method. Then, we retrieve a message <a id="_idIndexMarker706"/>with <strong class="source-inline">receive_text</strong> and assert that it corresponds to what we expect. Equivalent methods also exist for sending and receiving JSON data directly: <strong class="source-inline">send_json</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">receive_json</strong></span><span class="No-Break">.</span></p>&#13;
			<p>This is what makes WebSocket testing a bit special: you have to think about the sequence of sent and received messages <a id="_idTextAnchor690"/>and implement them programmatically to test the b<a id="_idTextAnchor691"/>ehavior of <span class="No-Break">your WebSocket.</span></p>&#13;
			<p>Other than that, all the things we’ve seen <a id="_idIndexMarker707"/>so far regarding testing are applicable, especially <a id="_idTextAnchor692"/><strong class="source-inline">dependency_overrides</strong>, when you need to use a <span class="No-Break">test database.</span></p>&#13;
			<h1 id="_idParaDest-157"><a id="_idTextAnchor693"/>Summary</h1>&#13;
			<p>Congratulations! You are now ready to build high-quality FastAPI applications that have been well tested. In this chapter, you learned how to use pytest, a powerful and efficient testing framework for Python. Thanks to pytest fixtures, you saw how to create a reusable test client for your FastAPI application that can work asynchronously. Using this client, you learned how to make HTTP requests to assert the behavior of your REST API. Finally, we reviewed how to test WebSocket endpoints, which involves a fairly different way <span class="No-Break">of thinking.</span></p>&#13;
			<p>Now that you can build a reliable and efficient FastAPI application, it’s time to bring it to the whole world! In the next chapter, we’ll review the best practices and patterns for preparing a FastAPI application for the world before studying several <span class="No-Break">deployment methods.</span></p>&#13;
		</div>&#13;
	</div></body></html>