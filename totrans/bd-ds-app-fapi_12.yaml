- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a FastAPI Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a good application is great, but it’s even better if customers can
    enjoy it. In this chapter, you’ll look at different techniques and the best practices
    for deploying your FastAPI application to make it available on the web. First,
    you’ll learn how to structure your project to make it ready for deployment by
    using environment variables to set the configuration options you need, as well
    as by managing your dependencies properly with `pip`. Once that’s done, we’ll
    show you three ways to deploy your application: with a serverless cloud platform,
    with a Docker container, and with a traditional Linux server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and using environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Python dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a FastAPI application on a serverless platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a FastAPI application with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a FastAPI application on a traditional server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll require a Python virtual environment, just as we set
    up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development* *Environment
    Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find all the code examples for this chapter in the dedicated GitHub repository
    at https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and using environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before deep-diving into the different deployment techniques, we need to structure
    our application to enable reliable, fast, and secure deployments. One of the key
    things in this process is handling configuration variables: a database URL, an
    external API token, a debug flag, and so on. When handling those variables, it’s
    necessary to handle them dynamically instead of hardcoding them into your source
    code. Why?'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, those variables will likely be different in your local environment
    and in production. Typically, your database URL will point to a local database
    on your computer while developing but will point to a proper production database
    in production. This is even more pertinent if you want to have other environments
    such as a staging or pre-production environment. Furthermore, if we need to change
    one of the values, we’ll have to change the code, commit it, and deploy it again.
    Thus, we need a convenient mechanism to set those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, it’s unsafe to write those values in your code. Values such as database
    connection strings or API tokens are extremely sensitive. If they appear in your
    code, they’ll likely be committed to your repository: they can be read by anyone
    who has access to your repository, which causes obvious security issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we usually use **environment variables**. Environment variables
    are values that aren’t set in the program itself but in the whole operating system.
    Most programming languages have the required functions to read those variables
    from the system. You can try this very easily in a Unix command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the Python source code, we can get the value dynamically from the system.
    During deployment, we’ll only have to make sure that we set the correct environment
    variables on the server. This way, we can easily change a value without redeploying
    the code and have several deployments of our application containing different
    configurations sharing the same source code. However, bear in mind that sensitive
    values that have been set in environment variables can still leak if you don’t
    pay attention – for example, in log files or error stack traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us with this task, we’ll use a very convenient feature of Pydantic:
    settings management. This allows us to structure and use our configuration variables
    as we do for any other data model. It even takes care of automatically retrieving
    the values from environment variables!'
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’ll work with an application that you can find
    in `chapter10/project` within our example repository. It’s a simple FastAPI application
    that uses SQLAlchemy, very similar to the one we reviewed in the *Communicating
    with a SQL database with the SQLAlchemy ORM* section of [*Chapter 6*](B19528_06.xhtml#_idTextAnchor346),
    *Databases and* *Asynchronous ORMs*.
  prefs: []
  type: TYPE_NORMAL
- en: Running the commands from the project directory
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the example repository, be sure to run the commands shown in this
    chapter from the `project` directory. On the command line, simply type `cd chapter10/project`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To structure a settings model, all you need to do is create a class that inherits
    from `pydantic.BaseSettings`. The following example shows a configuration class
    with a debug flag, an environment name, and a database URL:'
  prefs: []
  type: TYPE_NORMAL
- en: settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, creating this class is very similar to creating a standard Pydantic
    model. We can even define default values, as we did for `debug` here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we only have to create an instance of this class. We can then import
    it wherever we need it in our project. For example, here is how to retrieve the
    database URL to create our SQLAlchemy engine:'
  prefs: []
  type: TYPE_NORMAL
- en: database.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/database.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also use the `debug` flag to print all the settings in the `lifespan` event
    at startup:'
  prefs: []
  type: TYPE_NORMAL
- en: app.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/app.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our application is designed to work with SQLAlchemy, we also took care
    of initializing a database migration environment with Alembic, as we showed in
    [*Chapter 6*](B19528_06.xhtml#_idTextAnchor346), *Databases and Asynchronous ORMs*.
    The difference here is that we use our `settings` object to dynamically configure
    the database URL; instead of hardcoding it in `alembic.ini`, we can set it from
    our settings in `env.py`, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: env.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/alembic/env.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/alembic/env.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we take care of manually removing the `aiosqlite` driver part of
    the URL. Indeed, as we mentioned previously, Alembic is designed to work synchronously,
    so we need to pass it a standard URL. Now, we can generate migrations from our
    development database and apply them in production without changing anything in
    our Alembic configuration!
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing with this `Settings` model is that it works just like any other
    Pydantic model: it automatically parses the values it finds in environment variables
    and raises an error if one value is missing in your environment. This way, you
    can ensure you don’t forget any values directly when the app starts. You can test
    this behavior by running the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a clear list of the missing variables. Let’s set those variables in
    our environment and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The application started! You can even see that our lifespan handler printed
    our settings values. Notice that Pydantic is case-insensitive (by default) when
    retrieving environment variables. By convention, environment variables are usually
    set in all caps on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Using a .env file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In local development, it’s a bit annoying to set environment variables by hand,
    especially if you’re working on several projects at the same time on your machine.
    To solve this, Pydantic allows you to read the values from a `.env` file. This
    file contains a simple list of environment variables and their associated values.
    It’s usually easier to edit and manipulate during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, we’ll need a new library, `python-dotenv`, whose task is
    to parse those `.env` files. You can install it as usual with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable this feature, notice how we added the `Config` subclass with the
    `env_file` property:'
  prefs: []
  type: TYPE_NORMAL
- en: settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py)'
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, we simply tell Pydantic to look for environment variables set
    in a file named `.env`, if it’s available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can create your `.env` file at the root of the project with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s it! The values will now be read from this `.env` file. If the file
    is missing, `Settings` will try to read them from the environment variables as
    usual. Of course, this is only for convenience while developing: this file *shouldn’t
    be committed* and you should rely on *properly set environment variables in production*.
    To ensure you don’t commit this file by accident, it’s usually recommended that
    you add it to your `.``gitignore` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating hidden files such as .env files
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unix systems, files starting with a dot, such as `.env`, are considered
    hidden files. If you try to create them from the operating system’s file explorer,
    it might show you warnings or even prevent you from doing so. Thus, it’s usually
    more convenient to create them from your IDE, such as Visual Studio Code, or from
    the command line by executing the following command: `touch .env`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Our application now supports dynamic configuration variables, which
    are now easy to set and change on our deployment platforms. Another important
    thing to take care of is dependencies: we’ve installed quite a lot of them at
    this point, but we must make sure they are installed properly during deployments!'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Python dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we’ve installed libraries using `pip` to add some useful
    features to our application: FastAPI, of course, but also SQLAlchemy, pytest,
    and so on. When deploying a project to a new environment, such as a production
    server, we have to make sure all those dependencies are installed for our application
    to work properly. This is also true if you have colleagues that also need to work
    on the project: they need to know the dependencies they must install on their
    machines.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, `pip` comes with a solution for this so that we don’t have to remember
    all this in our heads. Indeed, most Python projects define a `requirements.txt`
    file, which contains a list of all Python dependencies. It usually lives at the
    root of your project. `pip` has a special option for reading this file and installing
    all the needed dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you already have a working environment, such as the one we’ve used since
    the beginning of this book, people usually recommend that you run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The result of `pip freeze` is a list of *every Python package currently installed
    in your environment*, along with their corresponding versions. This list can be
    directly used in the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that it lists every package, including the
    sub-dependencies of the libraries you install. Said another way, in this list,
    you’ll see packages that you don’t directly use but that are needed by the ones
    you installed. If, for some reason, you decide to not use a library anymore, you’ll
    be able to remove it, but it’ll be very hard to guess which sub-dependencies it
    has installed. In the long term, your `requirements.txt` file will grow larger
    and larger, with lots of dependencies that are useless in your project.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, some people recommend that you *manually maintain your* `requirements.txt`
    *file*. With this approach, you have to list yourself all the libraries you use,
    along with their respective versions. During installation, `pip` will take care
    of installing the sub-dependencies, but they’ll never appear in `requirements.txt`.
    This way, when you remove one of your dependencies, you make sure any useless
    packages are not kept.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you can see the `requirements.txt` file for the project
    we are working on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: requirements.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/requirements.txt](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/requirements.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the list is much shorter! Now, whenever we install a new dependency,
    our responsibility is to add it manually to `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: A word on alternate package managers such as Poetry, Pipenv, and Conda
  prefs: []
  type: TYPE_NORMAL
- en: While exploring the Python community, you may hear about alternate package managers
    such as Poetry, Pipenv, and Conda. These managers were created to solve some issues
    posed by `pip`, especially related to sub-dependency management. While they are
    very good tools, lots of cloud platforms expect a traditional `requirements.txt`
    file to specify the dependencies, rather than those more modern tools. Therefore,
    they may not be the best choice for a FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `requirements.txt` file should be committed along with your source code.
    When you need to install the dependencies on a new computer or server, you’ll
    simply need to run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, make sure that you’re working on proper virtual environments when
    doing this, as we described in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development* *Environment Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed the `gunicorn` dependency in `requirements.txt`. Let’s
    look at what it is and why it’s needed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Gunicorn as a server process for deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032), *Python Programming Specificities*,
    we briefly introduced the WSGI and ASGI protocols. They define the norm and data
    structure for building web servers in Python. Traditional Python web frameworks,
    such as Django and Flask, rely on the WSGI protocol. ASGI appeared recently and
    is presented as the “spiritual successor” of WSGI, providing a protocol for developing
    web servers running asynchronously. This protocol is at the heart of FastAPI and
    Starlette.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing
    RESTful APIs with FastAPI*, we use *Uvicorn* to run our FastAPI applications:
    its role is to accept HTTP requests, transform them according to the ASGI protocol,
    and pass them to the FastAPI application, which returns an ASGI-compliant response
    object. Then, Uvicorn can form a proper HTTP response from this object.'
  prefs: []
  type: TYPE_NORMAL
- en: In the WSGI world, the most widely used server is *Gunicorn*. It has the same
    role in the context of a Django or Flask application. Why are we talking about
    it, then? Gunicorn has lots of refinements and features that make it more robust
    and reliable in production than Uvicorn. However, Gunicorn is designed to work
    for WSGI applications. So, what can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we can use both: Gunicorn will be used as a robust process manager
    for our production server. However, we’ll specify a special worker class provided
    by Uvicorn, which will allow us to run ASGI applications such as FastAPI. This
    is the recommended way of doing deployments in the official Uvicorn documentation:
    [https://www.uvicorn.org/deployment/#using-a-process-manager](https://www.uvicorn.org/deployment/#using-a-process-manager).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s install Gunicorn to our dependencies by using the following command
    (remember to add it to your `requirements.txt` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish, you can try to run our FastAPI project using Gunicorn by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Its usage is quite similar to Uvicorn, except that we tell it to use a Uvicorn
    worker. Once again, this is necessary to make it work with an ASGI application.
    Also, notice the `-w` option. This allows us to set the number of workers to launch
    for our server. Here, we launch four instances of our application. Then, Gunicorn
    takes care of load-balancing the incoming requests between each worker. This is
    what makes Gunicorn more robust: if, for any reason, your application blocks the
    event loop with a synchronous operation, other workers will be able to process
    other requests while this is happening.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to deploy our FastAPI application! In the next section, you’ll
    learn how to deploy one on a serverless platform.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a FastAPI application on a serverless platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, serverless platforms have gained a lot of popularity and have
    become a very common way to deploy web applications. Those platforms completely
    hide the complexity of setting up and managing a server, giving you the tools
    to automatically build and deploy your application in minutes. Google App Engine,
    Heroku, and Azure App Service are among the most popular. Even though they have
    their own specificities, all these serverless platforms work on the same principles.
    This is why, in this section, we’ll outline the common steps you should follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, serverless platforms expect you to provide the source code in the
    form of a GitHub repository, which you push directly to their servers or which
    they pull automatically from GitHub. Here, we’ll assume that you have a GitHub
    repository with the source code structured like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Project structure for serverless deployment](img/B19528_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Project structure for serverless deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the general steps you should follow to deploy your projects on this
    kind of platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account on a cloud platform of your choice. You must do this before
    you can start any work. It’s worth noting that most cloud platforms offer free
    credits when you are getting started so that you can try their services for free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the necessary command-line tools. Most cloud providers supply a complete
    CLI for managing their services. Typically, this is required for deploying your
    application. Here are the relevant documentation pages for the most popular cloud
    providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Google Cloud: [https://cloud.google.com/sdk/gcloud](https://cloud.google.com/sdk/gcloud)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Azure: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heroku: https://devcenter.heroku.com/articles/heroku-cli'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set up the application configuration. Depending on the platform, you’ll either
    have to create a configuration file or use the CLI or the web interface to do
    this. Here are the relevant documentation pages for the most popular cloud providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Google App Engine (configuration file): [https://cloud.google.com/appengine/docs/standard/python3/configuring-your-app-with-app-yaml](https://cloud.google.com/appengine/docs/standard/python3/configuring-your-app-with-app-yaml)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Service (web interface and CLI): [https://docs.microsoft.com/en-us/azure/app-service/quickstart-python](https://docs.microsoft.com/en-us/azure/app-service/quickstart-python)
    and [https://docs.microsoft.com/en-us/azure/app-service/configure-language-python](https://docs.microsoft.com/en-us/azure/app-service/configure-language-python)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heroku (configuration file): [https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile](https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The key point in this step is to correctly *set the startup command*. As we
    saw in the previous section, it’s essential to set the Uvicorn worker class using
    the `gunicorn` command, as well as set the correct path to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the environment variables. Depending on the cloud provider, you should
    be able to do so during configuration or deployment. Remember that they are key
    for your application to work. Here are the relevant documentation pages for the
    most popular cloud providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Google App Engine (configuration file): [https://cloud.google.com/appengine/docs/standard/python/config/appref](https://cloud.google.com/appengine/docs/standard/python/config/appref)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Service (web interface): [https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings](https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heroku (CLI or web interface): [https://devcenter.heroku.com/articles/config-vars](https://devcenter.heroku.com/articles/config-vars)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploy the application. Some platforms can automatically deploy when they detect
    changes on a hosted repository, such as GitHub. Others require that you start
    deployment from the command-line tools. Here are the relevant documentation pages
    for the most popular cloud providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Google App Engine (CLI): [https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app#deploying_your_application](https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app#deploying_your_application)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Service (continuous deployment or manual Git deployment): [https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github](https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github)
    and [https://docs.microsoft.com/en-us/azure/app-service/deploy-local-git?tabs=cli](https://docs.microsoft.com/en-us/azure/app-service/deploy-local-git?tabs=cli%0D)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heroku (CLI): [https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app](https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application should now be live on the platform. Under the hood, most cloud
    platforms actually automatically build and deploy Docker containers while following
    the configuration you provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'They will make your application available on a generic subdomain such as `myapplication.herokuapp.com`.
    Of course, they also provide mechanisms for binding it to your own domain or subdomain.
    Here are the relevant documentation pages for the most popular cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google App Engine: [https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains](https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Service: [https://docs.microsoft.com/en-us/azure/app-service/manage-custom-dns-migrate-domain](https://docs.microsoft.com/en-us/azure/app-service/manage-custom-dns-migrate-domain%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heroku: [https://devcenter.heroku.com/articles/custom-domains](https://devcenter.heroku.com/articles/custom-domains)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding database servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, your application will be backed by a database engine, such
    as PostgreSQL. Fortunately, cloud providers propose fully managed databases, billed
    according to the computing power, memory, and storage you need. Once created,
    you’ll have access to a connection string to connect to the database instance.
    All you have to do then is set it in the environment variables of your application.
    Here are the relevant documentation pages for getting started with managed databases
    with the most popular cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Cloud SQL: [https://cloud.google.com/sql/docs/postgres/create-instance](https://cloud.google.com/sql/docs/postgres/create-instance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Database for PostgreSQL: [https://docs.microsoft.com/en-us/azure/postgresql/quickstart-create-server-database-portal](https://docs.microsoft.com/en-us/azure/postgresql/quickstart-create-server-database-portal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon RDS: [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heroku Postgres: [https://devcenter.heroku.com/articles/heroku-postgresql](https://devcenter.heroku.com/articles/heroku-postgresql%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we’ve seen, serverless platforms are the quickest and easiest way to deploy
    a FastAPI application. However, in some situations, you may wish to have more
    control of how things are deployed, or you may need system packages that are not
    available on serverless platforms. In those cases, it may be worthwhile to use
    a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a FastAPI application with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker is a widely used technology for containerization. **Containers** are
    small, self-contained systems running on a computer. Each container contains all
    the files and configurations necessary for running a single application: a web
    server, a database engine, a data processing application, and so on. The main
    goal is to be able to run those applications without worrying about the dependency
    and version conflicts that often happen when trying to install and configure them
    on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, Docker containers are designed to be *portable and reproducible*:
    to create a Docker container, you simply have to write a **Dockerfile** containing
    all the necessary instructions to build the small system, along with all the files
    and configuration you need. Those instructions are executed during a **build**,
    which results in a Docker **image**. This image is a package containing your small
    system, ready to use, which you can easily share on the internet through **registries**.
    Any developer who has a working Docker installation can then download this image
    and run it on their system in a container.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker has been quickly adopted by developers as it greatly eases the setup
    of complex development environments, allowing them to have several projects with
    different system package versions, all without worrying about their installation
    on their local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Docker is not only for local development: it’s also widely used for
    deploying applications to production. Since the builds are reproducible, we can
    ensure that the local and production environments remain the same, which limits
    any issues when moving to production.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to write a Dockerfile for a FastAPI application,
    how to build an image, and how to deploy it on a cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to this section, a Dockerfile is a set of
    instructions for building your Docker image, a self-contained system containing
    all the required components to run your applications. To begin with, all Dockerfiles
    derive from a base image; usually, this is a standard Linux installation, such
    as Debian or Ubuntu. From this base, we can copy files from our local machine
    into the image (usually, the source code of our application) and execute Unix
    commands – for example, to install packages or execute scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the creator of FastAPI has created a base Docker image that contains
    all the necessary tools to run a FastAPI app! All we have to do is start from
    this image, copy our source files, and install our dependencies! Let’s learn how
    to do that!
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you’ll need a working Docker installation on your machine. Follow
    the official *Getting Started* tutorial, which should guide you in this process:
    [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Docker image, we simply have to create a file named `Dockerfile`
    at the root of our project. The following example shows the content of this file
    for our current project:'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/Dockerfile](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/Dockerfile)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through each instruction. The first instruction, `FROM`, is the base
    image we derive from. Here, we took the `uvicorn-gunicorn-fastapi` image, which
    was created by the creator of FastAPI. Docker images have tags, which can be used
    to pick a specific version of the image. Here, we chose Python version 3.10\.
    Lots of variations exist for this image, including ones with other versions of
    Python. You can check them out in the official README file: [https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we set the `APP_MODULE` environment variable thanks to the `ENV` instruction.
    In a Docker image, environment variables can be set at build time, as we did here,
    or at runtime. `APP_MODULE` is an environment variable defined by the base image.
    It should point to the path of your FastAPI application: it’s the same argument
    that we set at the end of Uvicorn and Gunicorn commands to launch the application.
    You can find the list of all the accepted environment variables for the base image
    in the official README file.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our first `COPY` statement. As you may have guessed, this instruction
    will copy a file from your local system to the image. Here, we only copied our
    `requirements.txt` file. We’ll explain why shortly. Notice that we copied the
    file into the `/app` directory of the image; it’s the main working directory defined
    by the base image.
  prefs: []
  type: TYPE_NORMAL
- en: We then have a `RUN` statement. This instruction is used to execute Unix commands.
    In our case, we ran `pip` to install our dependencies, following the `requirements.txt`
    file we just copied. This is essential to make sure all our Python dependencies
    are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we copied the rest of our source code files into the `/app` directory.
    Now, let’s explain why we separately copied `requirements.txt`. The important
    thing to understand is that Docker images are built using layers: each instruction
    will create a new layer in the build system. To improve performance, Docker does
    its best to reuse layers it has already built. Therefore, if it detects no changes
    from the previous build, it’ll reuse the ones it has in memory without rebuilding
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: By copying the `requirements.txt` file alone and installing the Python dependencies
    before the rest of the source code, we allow Docker to reuse the layer where the
    dependencies have been installed. If we edit our source code but not `requirements.txt`,
    the Docker build will only execute the last `COPY` instruction, reusing all the
    previous layers. Thus, the image is built in a few seconds instead of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, Dockerfiles end with a `CMD` instruction, which should be
    the command to execute when the container is started. In our case, we would have
    used the Gunicorn command we saw in the *Adding Gunicorn as a server* section.
    However, in our case, the base image already handles this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a prestart script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deploying an application, it’s quite common to run several commands before
    the application starts. The most typical case is to execute database migrations
    so that our production database has the correct set of tables and columns. To
    help us with this, our base Docker image allows us to create a bash script named
    `prestart.sh`. If this file is present, it’ll be automatically run before the
    FastAPI application is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we just run the Alembic command to execute migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: prestart.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/prestart.sh](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/prestart.sh)'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that this is a mechanism provided only for convenience by the `tiangolo/uvicorn-gunicorn-fastapi`
    image. If you start from a more basic image, you’ll have to come up with your
    own solution to run a prestart script.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now build our Docker image! From the root of your project, just run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The dot (`.`) denotes the path of the root context to build your image – in
    this case, the current directory. The `-t` option is here to tag the image and
    give it a practical name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker will then perform the build. You’ll see that it’ll download the base
    image and sequentially run your instructions. This should take a few minutes.
    If you run the command again, you’ll experience what we explained earlier about
    layers: if there is no change, layers are reused and the build takes only a few
    seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Running a Docker image locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before deploying it to production, you can try to run your image locally. To
    do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the `run` command with the name of the image we just built. There
    are, of course, a few options here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-p` allows you to publish ports on your local machine. By default, Docker
    containers are not accessible on your local machine. If you publish ports, they
    will be available through `localhost`. On the container side, the FastAPI application
    is executed on port `80`. We publish it on port `8000` on our local machine –
    that is, `8000:80`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e` is used to set environment variables. As we mentioned in the *Setting
    and using environment variables* section, we need those variables to configure
    our application. Docker allows us to set them easily and dynamically at runtime.
    Notice that we set a simple SQLite database for testing purposes. However, in
    production, it should point to a proper database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can review the numerous options of this command in the official Docker
    documentation: [https://docs.docker.com/engine/reference/commandline/run/#options](https://docs.docker.com/engine/reference/commandline/run/#options).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command will run your application, which will be accessible through `http://localhost:8000`.
    Docker will show you the logs in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a working Docker image, you can deploy it on virtually any
    machine that runs Docker. This can be your own server or a dedicated platform.
    Lots of serverless platforms have emerged to help you deploy container images
    automatically: Google Cloud Run, Amazon Elastic Container Service, and Microsoft
    Azure Container Instances are just a few.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, what you have to do is upload (**push**, in Docker jargon) your image
    to a registry. By default, Docker pulls and pushes images from Docker Hub, the
    official Docker registry, but lots of services and platforms propose their own
    registries. Usually, using the private cloud registry proposed by the cloud platform
    is necessary to deploy it on this platform. Here are the relevant documentation
    pages for getting started with private registries with the most popular cloud
    providers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Artifact Registry: [https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images](https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon ECR: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-console.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-console.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Azure Container Registry: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you followed the relevant instructions, you should have a private registry
    for storing Docker images. The instructions probably showed you how to authenticate
    your local Docker command line with it and how to push your first image. Basically,
    all you have to do is tag the image you built with the path to your private registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to push it to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Your image is now safely stored in the cloud platform registry. You can now
    use a serverless container platform to deploy it automatically. Here are the relevant
    documentation pages for getting started with private registries with the most
    popular cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Cloud Run: [https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon Elastic Container Service: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/getting-started-ecs-ec2.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/getting-started-ecs-ec2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Azure Container Instances: [https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you’ll be able to set the environment variables just like you can
    for fully managed apps. Those environments also provide lots of options for tuning
    the scalability of your containers, both vertically (using more powerful instances)
    and horizontally (spawning more instances).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, your application should be live on the web! The great thing about
    deploying Docker images compared to automated serverless platforms is that you
    are not limited to the features supported by the platform: you can deploy anything,
    even complex applications that require a lot of exotic packages, without worrying
    about compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve seen the easiest and most efficient ways to deploy a FastAPI
    application. However, you may wish to deploy one the old-fashioned way and manually
    set up your server. In the next section, we’ll provide some guidelines for doing
    so.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a FastAPI application on a traditional server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some situations, you may not have the chance to use a serverless platform
    to deploy your application. Some security or regulatory policies may force you
    to deploy on physical servers with specific configurations. In this case, it’s
    worth knowing some basic things so that you can deploy your application on traditional
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll consider you are working on a Linux server:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, make sure a *recent version of Python has been installed* on your
    server, ideally with the version matching the one you used in development. The
    easiest way to do this is to set up `pyenv`, as we saw in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development* *Environment Setup*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To retrieve your source code and keep it in sync with your latest developments,
    you can *clone your Git repository* on your server. This way, you only have to
    pull the changes and restart the server process to deploy a new version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a *Python virtual environment*, as we explained in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development Environment Setup*. You can install the dependencies with
    `pip` thanks to your `requirements.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At that point, you should be able to run Gunicorn and start serving your FastAPI
    application. However, some improvements are strongly recommended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Use a process manager* to ensure your Gunicorn process is always running and
    restarted when the server is restarted. A good option for this is *Supervisor*.
    The Gunicorn documentation provides good guidelines for this: [https://docs.gunicorn.org/en/stable/deploy.html#supervisor](https://docs.gunicorn.org/en/stable/deploy.html#supervisor).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s also recommended to *put Gunicorn behind an HTTP proxy* instead of directly
    putting it on the front line. Its role is to handle SSL connections, perform load
    balancing, and serve static files such as images or documents. The Gunicorn documentation
    recommends using nginx for this task and provides a basic configuration: [https://docs.gunicorn.org/en/stable/deploy.html#nginx-configuration](https://docs.gunicorn.org/en/stable/deploy.html#nginx-configuration).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, in this context, there are quite a lot of configurations and
    decisions to make regarding your server configuration. Of course, you should also
    pay attention to security and make sure your server is well protected against
    the usual attacks. In the following DigitalOcean tutorial, you’ll find some guidelines
    for securing your server: [https://www.digitalocean.com/community/tutorials/recommended-security-measures-to-protect-your-servers](https://www.digitalocean.com/community/tutorials/recommended-security-measures-to-protect-your-servers).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not an experienced system administrator, we recommend that you favor
    serverless platforms; professional teams handle security, system updates, and
    server scalability for you, letting you focus on what matters most to you: developing
    a great application!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your application is now live on the web! In this chapter, we covered the best
    practices to apply before deploying your application to production: use environment
    variables to set configuration options, such as database URLs, and manage your
    Python dependencies with a `requirements.txt` file. Then, we showed you how to
    deploy your application to a serverless platform, which handles everything for
    you by retrieving your source code, packaging it with its dependencies, and serving
    it on the web. Next, you learned how to build a Docker image for FastAPI using
    the base image created by the creator of FastAPI. As you saw, it allows you to
    be flexible while configuring the system, but you can still deploy it in a few
    minutes with a serverless platform that’s compatible with containers. Finally,
    we provided you with some guidelines for manual deployment on a traditional Linux
    server.'
  prefs: []
  type: TYPE_NORMAL
- en: This marks the end of the second part of this book. You should now be confident
    in writing efficient, reliable FastAPI applications and be able to deploy them
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin some data science tasks and integrate them
    efficiently into a FastAPI project.
  prefs: []
  type: TYPE_NORMAL
