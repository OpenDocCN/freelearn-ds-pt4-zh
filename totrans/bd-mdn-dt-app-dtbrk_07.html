<html><head></head><body>
  <div id="_idContainer081">
   <h1 class="chapter-number" id="_idParaDest-136">
    <a id="_idTextAnchor165">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     7
    </span>
   </h1>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor166">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Viewing Data Lineage Using Unity Catalog
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, we’ll dive into the critical role that data lineage plays within the Databricks Data Intelligence Platform.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     You’ll learn how to trace data origins, visualize dataset transformations, identify upstream and downstream dependencies, and document lineage using the lineage graph capabilities of the Catalog Explorer.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     By the end of the chapter, you’ll be equipped with the skills needed to ensure data is coming from trusted sources, and spot breaking changes before
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      they happen.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.7.1">
      Introducing data lineage in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.8.1">
       Unity Catalog
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Tracing data origins using the Data Lineage
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       REST API
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Visualizing upstream and downstream
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       data transformations
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      Identifying dependencies
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       and impacts
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Hands-on lab – documenting data lineage across
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       an organization
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-138">
    <a id="_idTextAnchor167">
    </a>
    <span class="koboSpan" id="kobo.17.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     To follow along with the examples provided in this chapter, you’ll need Databricks workspace permissions to create and start an all-purpose cluster so that you can import and execute the chapter’s accompanying notebooks.
    </span>
    <span class="koboSpan" id="kobo.18.2">
     All code samples can be downloaded from this chapter’s GitHub repository, located at
    </span>
    <a href="https://github.com/PacktPublishing/Building-Modern-Data-Applications-Using-Databricks-Lakehouse/tree/main/chapter07">
     <span class="koboSpan" id="kobo.19.1">
      https://github.com/PacktPublishing/Building-Modern-Data-Applications-Using-Databricks-Lakehouse/tree/main/chapter07
     </span>
    </a>
    <span class="koboSpan" id="kobo.20.1">
     .
    </span>
    <span class="koboSpan" id="kobo.20.2">
     This chapter will create and run several new notebooks
    </span>
    <a id="_idIndexMarker409">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     using an all-purpose cluster and is estimated to consume around 5-10
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.22.1">
      Databricks
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.23.1">
       units
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.24.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.25.1">
       DBUs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.26.1">
      ).
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-139">
    <a id="_idTextAnchor168">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     Introducing data lineage in Unity Catalog
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.28.1">
      Data lineage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.29.1">
     refers to
    </span>
    <a id="_idIndexMarker410">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     the ability to trace relationships
    </span>
    <a id="_idIndexMarker411">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     across securable objects, such as tables, in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.32.1">
      Unity Catalog
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.34.1">
      UC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.35.1">
     ) so that
    </span>
    <a id="_idIndexMarker412">
    </a>
    <span class="koboSpan" id="kobo.36.1">
     users can view how data assets are formed from upstream sources and verify
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      downstream dependencies.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer070">
     <span class="koboSpan" id="kobo.38.1">
      <img alt="Figure 7.1 – Data lineage traces the flow of data and how it gets transformed over time by internal processes" src="image/B22011_07_001.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.39.1">
     Figure 7.1 – Data lineage traces the flow of data and how it gets transformed over time by internal processes
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     In Databricks, users can trace the lineage of data assets in near real time so that data stewards can ensure that they are working with the latest assets.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     Furthermore, data lineage in Unity Catalog spans across multiple workspaces that are attached to the same Unity Catalog metastore, allowing data professionals to get a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.41.1">
      complete
     </span>
    </em>
    <span class="koboSpan" id="kobo.42.1">
     , holistic view into how datasets are transformed and are related to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      one another.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     Data lineage
    </span>
    <a id="_idIndexMarker413">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     can be traced across a variety of securable objects in the Databricks Data Intelligence Platform, including the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      following objects:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.47.1">
       Queries
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.48.1">
       Tables
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.49.1">
       Table columns
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.50.1">
       Notebooks
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.51.1">
       Workflows
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.52.1">
      Machine
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.53.1">
       learning models
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.54.1">
       Delta Live Tables
      </span>
     </strong>
     <span class="koboSpan" id="kobo.55.1">
      (
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.56.1">
        DLT
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.57.1">
       ) pipelines
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.58.1">
       Dashboards
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Like many
    </span>
    <a id="_idIndexMarker414">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     objects within the Databricks Data Intelligence Platform, you can trace the lineage through a variety of mechanisms, including the Databricks UI, using Catalog Explorer, or by consuming the Data Lineage REST API.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     In fact, data lineage is automatically captured by the Databricks Data Intelligence Platform and recorded
    </span>
    <a id="_idIndexMarker415">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     in the system tables (covered in
    </span>
    <a href="B22011_05.xhtml#_idTextAnchor126">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.62.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.63.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.63.2">
     Like other system information that gets preserved in the Databricks system tables, lineage
    </span>
    <a id="_idIndexMarker416">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     information can accumulate quite a bit.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     To preserve storage costs, this information is retained for one year by default.
    </span>
    <span class="koboSpan" id="kobo.64.3">
     For longer lineage storage requirements, it’s recommended to set up an alternate process that will append the lineage information to longer-term archival storage.
    </span>
    <span class="koboSpan" id="kobo.64.4">
     For example, say that an organization needs to retain system auditing information on the order of years, then a long-term archival ETL pipeline would be needed to copy the lineage data into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      archival storage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.66.1">
     In the coming sections, we’ll cover all varieties for viewing lineage across data assets
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      in Databricks.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-140">
    <a id="_idTextAnchor169">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     Tracing data origins using the Data Lineage REST API
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.69.1">
     Like many securable objects in the Databricks Data Intelligence Platform, there are a variety of ways
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     to retrieve detailed lineage
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     information pertaining to the object.
    </span>
    <span class="koboSpan" id="kobo.71.2">
     One common pattern for retrieving lineage information about a particular object in Databricks is through the Data Lineage REST API.
    </span>
    <span class="koboSpan" id="kobo.71.3">
     At the moment, the Data Lineage REST API is limited to retrieving a read-only view of table lineage information as well as column
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      lineage information.
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-5">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.73.1">
           UC Object
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.74.1">
           HTTP Verb
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.75.1">
           Endpoint
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.76.1">
           Description
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.77.1">
          Table
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.78.1">
           GET
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.79.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.80.1">
           api/2.0/lineage-tracking/table-lineage
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.81.1">
         Given a UC table name, retrieves a list of upstream and downstream table connections, as well as information about their related
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.82.1">
          notebook connections
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.83.1">
          Column
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.84.1">
           GET
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.85.1">
          /
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.86.1">
           api/2.0/lineage-tracking/column-lineage
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.87.1">
         Given a UC table name and column name, retrieves a list of upstream and downstream
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.88.1">
          column connections
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.89.1">
     Table 7.1 – Data Lineage REST API fetches information pertaining to upstream and downstream connections for UC table and column objects
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.90.1">
     However, it’s expected that the Data Lineage REST API will evolve over time, adding additional capabilities for data stewards to retrieve information and even manipulate the end-to-end lineage of data assets within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.91.1">
      the platform.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.92.1">
     Let’s look at how we might use the Lineage Tracking API to retrieve information about the upstream and downstream connections for a table created by the dataset generator notebook in this chapter’s accompanying GitHub repository, located
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Building-Modern-Data-Applications-Using-Databricks-Lakehouse/tree/main/chapter07">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.94.1">
       https://github.com/PacktPublishing/Building-Modern-Data-Applications-Using-Databricks-Lakehouse/tree/main/chapter07
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.95.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.96.1">
     First, we’ll begin by creating a brand-new notebook in our Databricks workspace and importing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.97.1">
      requests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     Python library.
    </span>
    <span class="koboSpan" id="kobo.98.2">
     We’ll be exclusively using the Python
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.99.1">
      requests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.100.1">
     library to send data lineage requests to the Databricks REST API and parse the response from the Databricks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.101.1">
      control plane:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.102.1">
import requests</span></pre>
   <p>
    <span class="koboSpan" id="kobo.103.1">
     Create and start an all-purpose cluster to attach the notebook to and run the notebook cells.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     You’ll
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     need to generate a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.105.1">
      personal access token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.107.1">
      PAT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     ) to authenticate with the Databricks REST endpoints and send Data Lineage
    </span>
    <a id="_idIndexMarker420">
    </a>
    <span class="koboSpan" id="kobo.109.1">
     API requests.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     It’s strongly
    </span>
    <a id="_idIndexMarker421">
    </a>
    <span class="koboSpan" id="kobo.110.1">
     recommended to store the PAT in a Databricks secret object (
    </span>
    <a href="https://docs.databricks.com/en/security/secrets/secrets.html">
     <span class="koboSpan" id="kobo.111.1">
      https://docs.databricks.com/en/security/secrets/secrets.html
     </span>
    </a>
    <span class="koboSpan" id="kobo.112.1">
     ) to avoid accidentally leaking the authentication details to your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      Databricks workspace.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.114.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.115.1">
     The following code snippets are for illustration purposes only.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     You’ll need to update the workspace name to match the name of your Databricks workspace, as well as the value for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      API token.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.117.1">
     Let’s use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      requests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     library to send a request to the Data Lineage API by specifying the fully
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      qualified endpoint:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.121.1">
response = requests.get(
    f"https://{WORKSPACE_N</span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.122.1">AME}.cloud.databricks.com/api/2.0/lineage-tracking/table-lineage",
    head</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.123.1">ers={
        "Authorization": f"Bearer {API_TOKEN}"
    },
    j</span><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.124.1">son={
        "table_name": FULLY_QUALIFIED_TABLE_NAME,
        "include_entity_lineage": "true"
    }
)
print(response.json())</span></pre>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     Next, let’s include a few helper functions for parsing the response from the Data Lineage API and
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.126.1">
     printing the connection
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     information in a nicely formatted manner that’s easy to understand.
    </span>
    <span class="koboSpan" id="kobo.127.2">
     Add a new cell to your notebook and paste the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      helper functions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.129.1">
def print_table_info(conn_type, table_info_json):
    info = table_info_json["tableInfo"]
    print(f"""
        +---------------------------------------------+
        | {conn_type.upper()} Table Connection Info
        |---------------------------------------------|
        | Table name: {info['name']}
        |---------------------------------------------|
        | Catalog name: {info['catalog_name']}
        |---------------------------------------------|
        | Table type: {info['table_type']}
        |---------------------------------------------|
        | Lineage timestamp: {info['lineage_timestamp']}
        +---------------------------------------------+
    """)
    if conn_type.upper() == "UPSTREAMS":
        print(f"""
                                |
                               \|/
        """)
def print_notebook_info(conn_type, notebook_info):
    print(f"""
        +---------------------------------------------+
        | {conn_type.upper()} Notebook Connection Info:
        |---------------------------------------------|
        | Workspace id: {str(notebook_info['workspace_id'])}
        |---------------------------------------------|
        | Notebook id: {str(notebook_info['notebook_id'])}
        |---------------------------------------------|
        | Timestamp: {notebook_info['lineage_timestamp']}
        +---------------------------------------------+
    """)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     Now, let’s
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.131.1">
     update the response
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.132.1">
     section of our previous code snippet for fetching table lineage information, but this time, we’ll invoke these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.133.1">
      helper functions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.134.1">
if response.status_code == 200:
    connection_flows = ["upstreams", "downstreams"]
    for flow in connection_flows:
        if flow in response.json():
            connections = response.json()[flow]
            for conn in connections:
                if "tableInfo" in conn:
                    print_table_info(flow, conn)
                elif "notebookInfos" in conn:
                    for notebook_info in conn["notebookInfos"]:
                        print_notebook_info(flow, notebook_info)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     The output
    </span>
    <a id="_idIndexMarker426">
    </a>
    <span class="koboSpan" id="kobo.136.1">
     should now be a much
    </span>
    <a id="_idIndexMarker427">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     more legible response from our Data Lineage API, allowing us to clearly view the upstream and downstream table connections from our table in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      Unity Catalog.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer071">
     <span class="koboSpan" id="kobo.139.1">
      <img alt="Figure 7.2 – Table lineage response output from the Databricks Data Lineage REST API" src="image/B22011_07_002.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.140.1">
     Figure 7.2 – Table lineage response output from the Databricks Data Lineage REST API
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.141.1">
     The Data
    </span>
    <a id="_idIndexMarker428">
    </a>
    <span class="koboSpan" id="kobo.142.1">
     Lineage API is great for tracing
    </span>
    <a id="_idIndexMarker429">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     connections between datasets in Unity Catalog.
    </span>
    <span class="koboSpan" id="kobo.143.2">
     However, we can also retrieve finer-grained lineage information about the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.144.1">
      columns
     </span>
    </em>
    <span class="koboSpan" id="kobo.145.1">
     of our table as well.
    </span>
    <span class="koboSpan" id="kobo.145.2">
     In the next example, let’s retrieve information about the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      description
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     column of our table.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     Let’s also define another helper function to nicely display the column
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      connection information:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.149.1">
def print_column_info(conn_type, column_info):
    print(f"""
        Connection flow: {conn_type.upper()}
        Column name: {column_info['name']}
        Catalog name: {column_info['catalog_name']}
        Schema name: {column_info['schema_name']}
        Table name: {column_info['table_name']}
        Table type: {column_info['table_type']}
        Lineage timestamp: {column_info['lineage_timestamp']}
    """)
column_name = "description"
response = requests.get(
    f"https://{WORKSPACE_NAME}.cloud.databricks.com/api/2.0/lineage-tracking/column-lineage",
    headers={
        "Authorization": f"Bearer {API_TOKEN}"
    },
    json={
        "table_name": FULLY_QUALIFIED_TABLE_NAME,
        "column_name": column_name
    }
)
if response.status_code == 200:
    if "upstream_cols" in response.json():
        print("| Upstream cols:")
        for column_info in response.json()['upstream_cols']:
            print_column_info("Upstream", column_info)
    if "downstream_cols" in response.json():
        print("| Downstream cols:")
        for column_info in response.json()['downstream_cols']:
            print_column_info("Downstream", column_info)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.150.1">
     In this scenario, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.151.1">
      description
     </span>
    </strong>
    <span class="koboSpan" id="kobo.152.1">
     column in our table is particularly interesting, as it’s the
    </span>
    <a id="_idIndexMarker430">
    </a>
    <span class="koboSpan" id="kobo.153.1">
     result of a concatenation
    </span>
    <a id="_idIndexMarker431">
    </a>
    <span class="koboSpan" id="kobo.154.1">
     of a text string with two different columns.
    </span>
    <span class="koboSpan" id="kobo.154.2">
     If you update the previous column lineage requests with a different column name, you’ll notice that the number of upstream sources will change to reflect the number of connections specific to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.155.1">
      that column.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer072">
     <span class="koboSpan" id="kobo.156.1">
      <img alt="Figure 7.3 – Column lineage response output from the Databricks Lineage API" src="image/B22011_07_003.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.157.1">
     Figure 7.3 – Column lineage response output from the Databricks Lineage API
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.158.1">
     By now, you should feel comfortable working with the Databricks Data Lineage API to trace connections between datasets and even fine-grained data transformations, such as column
    </span>
    <a id="_idIndexMarker432">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     connections.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     As you’ve
    </span>
    <a id="_idIndexMarker433">
    </a>
    <span class="koboSpan" id="kobo.160.1">
     seen, the requests and responses from the Data Lineage API require experience working with JSON payloads.
    </span>
    <span class="koboSpan" id="kobo.160.2">
     For some responses, we needed to create helper functions to parse the response into a more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.161.1">
      readable form.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     In the next section, we’ll look at using the Databricks UI for tracing dataset relationships, allowing non-technical data stewards the ability to view upstream and downstream sources with just the click of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.163.1">
      a button.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-141">
    <a id="_idTextAnchor173">
    </a>
    <span class="koboSpan" id="kobo.164.1">
     Visualizing upstream and downstream transformations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.165.1">
     In this section, we’ll be leveraging the dataset generator notebook to create several datasets
    </span>
    <a id="_idIndexMarker434">
    </a>
    <span class="koboSpan" id="kobo.166.1">
     in Unity Catalog for working with the Databricks UI to trace dataset lineage.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     If you haven’t done so already, clone this chapter’s
    </span>
    <a id="_idIndexMarker435">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     accompanying GitHub repository, which is located at
    </span>
    <a href="https://github.com/PacktPublishing/Building-Modern-Data-Applications-Using-Databricks-Lakehouse/tree/main/chapter07">
     <span class="koboSpan" id="kobo.168.1">
      https://github.com/PacktPublishing/Building-Modern-Data-Applications-Using-Databricks-Lakehouse/tree/main/chapter07
     </span>
    </a>
    <span class="koboSpan" id="kobo.169.1">
     .
    </span>
    <span class="koboSpan" id="kobo.169.2">
     Next, either start an existing all-purpose cluster or create a new cluster and begin by attaching the data generator notebook to the cluster.
    </span>
    <span class="koboSpan" id="kobo.169.3">
     Click the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.170.1">
      Run all
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     button in the top-right corner of the Databricks workspace to execute all the notebook cells, verifying that all cells execute successfully.
    </span>
    <span class="koboSpan" id="kobo.171.2">
     If you encounter runtime errors, verify that you have the correct metastore permissions to create new catalogs, schemas, and tables in your Unity
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      Catalog metastore.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.173.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.174.1">
     You will need to be granted permission to create a new catalog and schema in your Unity Catalog metastore.
    </span>
    <span class="koboSpan" id="kobo.174.2">
     If this isn’t possible, feel free to reuse an existing catalog and schema to generate the sample tables.
    </span>
    <span class="koboSpan" id="kobo.174.3">
     You will need to update the DDL and DML statements accordingly to match the value within your own
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      Databricks workspace.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.176.1">
     The result of the data generator notebook should be three tables in total:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      youtube_channels
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      youtube_channel_artists
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     .
    </span>
    <span class="koboSpan" id="kobo.182.2">
     Data lineage can easily be traced in the Databricks Data Intelligence Platform in a variety of ways.
    </span>
    <span class="koboSpan" id="kobo.182.3">
     In this example, let’s trace the data lineage of a data asset, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     table, using the Databricks UI.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     From your Databricks workspace, click on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.185.1">
      Catalog Explorer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     menu tab from the left-hand side navigation menu of the Databricks Data Intelligence Platform.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     Next, either drill down to the catalog and schema to locate the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     table, or simply type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     into the search box
    </span>
    <a id="_idIndexMarker436">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     at the top of the Catalog Explorer, which
    </span>
    <a id="_idIndexMarker437">
    </a>
    <span class="koboSpan" id="kobo.192.1">
     will filter the list of data assets matching the text string.
    </span>
    <span class="koboSpan" id="kobo.192.2">
     Click on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     table, which will open the data asset
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      Overview
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     details in a separate pane on the right-hand side of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      the UI.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer073">
     <span class="koboSpan" id="kobo.198.1">
      <img alt="Figure 7.4 – The data lineage can be traced directly from the Catalog Explorer in Databricks" src="image/B22011_07_004.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.199.1">
     Figure 7.4 – The data lineage can be traced directly from the Catalog Explorer in Databricks
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.200.1">
     From the UI pane, click on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.201.1">
      Lineage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     tab to expose the details of the data lineage for our table.
    </span>
    <span class="koboSpan" id="kobo.202.2">
     After navigating to the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.203.1">
      Lineage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     tab, you should see a summary of all connections related to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.205.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     dataset, clearly identifying all the upstream sources that are used to construct this table, as well as any downstream dependencies that leverage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      this table.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer074">
     <span class="koboSpan" id="kobo.208.1">
      <img alt="Figure 7.5 – The Lineage tab in the Catalog Explorer contains lineage information about a table" src="image/B22011_07_005.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.209.1">
     Figure 7.5 – The Lineage tab in the Catalog Explorer contains lineage information about a table
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     In this case, there should be two rows containing information about the upstream sources – the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      youtube_channels
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     parent table and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      youtube_channel_artists
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     table.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     Since we’ve only recently created this table using our
    </span>
    <a id="_idIndexMarker438">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     data generator notebook, there shouldn’t be
    </span>
    <a id="_idIndexMarker439">
    </a>
    <span class="koboSpan" id="kobo.216.1">
     any rows with downstream dependencies.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     As you can imagine, this table will be updated in near real time with a list of all objects that use the dataset in some fashion, clearly identifying any downstream dependents of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.217.1">
      the data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.218.1">
     Lastly, let’s visualize what our table lineage relationships look like.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     Click on the blue button labeled
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.219.1">
      See lineage graph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     to open the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      lineage visualization.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     You should now clearly see that two upstream tables join to form the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.223.1">
       combined_table
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.224.1">
      table.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer075">
     <span class="koboSpan" id="kobo.225.1">
      <img alt="Figure 7.6 – Lineage connection information can be generated by clicking on connection links on a lineage graph" src="image/B22011_07_006.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.226.1">
     Figure 7.6 – Lineage connection information can be generated by clicking on connection links on a lineage graph
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     Next, click on
    </span>
    <a id="_idIndexMarker440">
    </a>
    <span class="koboSpan" id="kobo.228.1">
     the arrow connecting the upstream
    </span>
    <a id="_idIndexMarker441">
    </a>
    <span class="koboSpan" id="kobo.229.1">
     table with the downstream table,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     , to reveal more details about the lineage connection.
    </span>
    <span class="koboSpan" id="kobo.231.2">
     You will notice that a side pane will open displaying information about the lineage connection, such as the source and target tables, but it will also display how these data assets are used across various other objects in the Databricks Data Intelligence Platform.
    </span>
    <span class="koboSpan" id="kobo.231.3">
     For instance, the UI pane will list how these datasets are currently being leveraged across notebooks, workflows, DLT pipelines, and DBSQL queries.
    </span>
    <span class="koboSpan" id="kobo.231.4">
     In this case, we’ve only generated these tables using our data generator notebook, so it is the only object listed in the lineage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      connection information.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer076">
     <span class="koboSpan" id="kobo.233.1">
      <img alt="Figure 7.7 – Connection details between datasets can be viewed from the lineage graph" src="image/B22011_07_007.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.234.1">
     Figure 7.7 – Connection details between datasets can be viewed from the lineage graph
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.235.1">
     Column
    </span>
    <a id="_idIndexMarker442">
    </a>
    <span class="koboSpan" id="kobo.236.1">
     lineage can also be traced using the Catalog
    </span>
    <a id="_idIndexMarker443">
    </a>
    <span class="koboSpan" id="kobo.237.1">
     Explorer.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     In the same lineage graph, click on various columns in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      combined_table
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     table to reveal lineage information.
    </span>
    <span class="koboSpan" id="kobo.239.2">
     For example, by clicking on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.240.1">
      description
     </span>
    </strong>
    <span class="koboSpan" id="kobo.241.1">
     table column, the lineage graph will be updated to clearly visualize how the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      description
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     column is calculated.
    </span>
    <span class="koboSpan" id="kobo.243.2">
     In this case, the column is calculated by concatenating a string of text with the category column from our parent table as well as the artist’s name from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      child table.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer077">
     <span class="koboSpan" id="kobo.245.1">
      <img alt="Figure 7.8 – Column lineage can be traced by clicking the column to expose upstream lineage connections" src="image/B22011_07_008.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.246.1">
     Figure 7.8 – Column lineage can be traced by clicking the column to expose upstream lineage connections
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.247.1">
     As you can see, generating a lineage graph from the Catalog Explorer provides an accurate
    </span>
    <a id="_idIndexMarker444">
    </a>
    <span class="koboSpan" id="kobo.248.1">
     snapshot of the latest relationships
    </span>
    <a id="_idIndexMarker445">
    </a>
    <span class="koboSpan" id="kobo.249.1">
     between datasets in Unity Catalog.
    </span>
    <span class="koboSpan" id="kobo.249.2">
     These relationships can help us identify the impact data changes have on downstream dependencies, such as changing the data type of a column or dropping a dataset,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.250.1">
      for example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     In the next section, we’ll look at how data lineage can help us identify relationships between our datasets, spot dependent notebooks that leverage these datasets, and avoid introducing breaking changes across
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      our organization.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor174">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     Identifying dependencies and impacts
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     In this
    </span>
    <a id="_idIndexMarker446">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     section, we’ll leverage the lineage graph UI from the Catalog Explorer again to better understand how changing the data type and value of a particular column will impact downstream datasets and downstream processes, such as notebooks and workflows, across our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      Databricks workspaces.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     Let’s first begin by creating a new notebook in our Databricks workspace that will contain the definition of a new DLT pipeline.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     The first dataset in our DLT pipeline will ingest raw
    </span>
    <a id="_idIndexMarker447">
    </a>
    <span class="koboSpan" id="kobo.258.1">
     CSV files containing commercial airline flight information stored in the default
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.259.1">
      Databricks Filesystem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.261.1">
      DBFS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     ) under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      /databricks-datasets
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     directory.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     Every Databricks workspace will have access to this
    </span>
    <a id="_idIndexMarker448">
    </a>
    <span class="koboSpan" id="kobo.265.1">
     dataset.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     Create a new notebook cell and add
    </span>
    <a id="_idIndexMarker449">
    </a>
    <span class="koboSpan" id="kobo.266.1">
     the following code snippet for the definition of a bronze table in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      dat
     </span>
     <a id="_idTextAnchor175">
     </a>
     <span class="koboSpan" id="kobo.268.1">
      a pipeline:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.269.1">
import dlt
@dlt.table(
    name="commercial_airliner_flights_bronze",
    comment="The commercial airliner flight data dataset located in `/databricks-datasets/`"
)
def commercial_airliner_flights_bronze():
    path = "/databricks-datasets/airlines/"
    return (spark.readStream
            .format("csv")
            .schema(schema)
            .option("header", True)
            .load(path))</span></pre>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     We’d like to augment the flight data with information about the commercial airliner jet.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     Create a new notebook cell and add the following code snippet, which defines a static reference table with information about popular commercial airline jets, including the manufacturer name, airplane model, country of origin, and fuel capacity, to name
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      a few:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.272.1">
commercial_airliners = [
    ("Airbus A220", "Canada", 2, 2013, 2016, 287, 287, 5790),
    ("Airbus A330neo", "Multinational", 2, 2017, 2018, 123,
     123, 36744 ),
    ("Airbus A350 XWB", "Multinational", 2, 2013, 2014, 557,
     556, 44000),
    ("Antonov An-148/An-158", "Ukraine", 2, 2</span><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.273.1">004, 2009, 37,
     8, 98567 ),
    ("Boeing 737", "United States", 2, 1967, 1968, 11513, 7649,
     6875),
    ("Boeing 767", "United States", 2, 1981, 1982, 1283, 764,
     23980),
    ("Boeing 777", "United States", 2, 1994, 1995, 1713, 1483,
     47890),
    ("Boeing 787 Dreamliner", "United States", 2, 2009, 2011,
     1072, 1069, 33340),
    ("Embraer E-Jet family", "Brazil", 2, 2002, 2004, 1671,
     1443, 3071),
    ("Embraer E-Jet E2 family", "Brazil", 2, 2016, 2018, 81,
     23, 3071)
]
commercial_airliners_schema = "jet_model string, Country_of_Origin string, Engines int, First_Flight int, Airline_Service_Entry int, Number_Built int, Currently_In_Service int, Fuel_Capacity int"
airliners_df = spark.createDataFrame(
    data=commercial_airpliners,
    schema=commercial_airliners_schema
)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     Next, we’ll
    </span>
    <a id="_idIndexMarker450">
    </a>
    <span class="koboSpan" id="kobo.275.1">
     save the airline jet reference table to
    </span>
    <a id="_idIndexMarker451">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     the schema created earlier in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.277.1">
      Unity Catalog:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.278.1">
airliners_ta</span><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.279.1">ble_name = f"{</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.280.1">catalog_name}.{schema_name}.{table_name}"
(airliners_df.write
    .format("delta")
    .mode("overwrite")
    .option("mergeSchema", True)
    .saveAsTable(airliners_table_name))</span></pre>
   <p>
    <span class="koboSpan" id="kobo.281.1">
     Let’s add another step to our data pipeline, which will join our static, commercial jet airline reference
    </span>
    <a id="_idIndexMarker452">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     table with our stream of airline flight data.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     In a new notebook cell, create the following
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.283.1">
      user-defined function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.285.1">
      UDF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     ), which will generate a tail number for each entry in the commercial
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      airline dataset:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.288.1">
from pyspark.sql.types import StringType
from pyspark.sql.functions im</span><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.289.1">port udf
@udf(returnType=StringType())
def generate_jet_model():
    import random
    commercial_jets = [
        "Airbus A220",
        "Airbus A320",
        "Airbus A330",
        "Airbus A330neo",
        "Airbus A350 XWB",
        "Antonov An-148/An-158",
        "Boeing 737",
        "Boeing 767",
        "Boeing 777",
        "Boeing 787 Dreamliner",
        "Comac ARJ21 Xiangfeng",
        "Comac C919",
        "Embraer E-Jet family",
        "Embraer E-Jet E2 family",
        "Ilyushin Il-96",
        "Sukhoi Superjet SSJ100",
        "Tupolev Tu-204/Tu-214"
    ]
    random_index = random.randint(0, 16)
    return commercial_jets[random_index]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     Lastly, create
    </span>
    <a id="_idIndexMarker453">
    </a>
    <span class="koboSpan" id="kobo.291.1">
     one more notebook cell and add
    </span>
    <a id="_idIndexMarker454">
    </a>
    <span class="koboSpan" id="kobo.292.1">
     the following DLT dataset defin
    </span>
    <a id="_idTextAnchor180">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     ition for our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      silver table:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.295.1">
@dlt.table(
    name="commercial_airliner_flights_silver",
    comment="The commercial airliner flight data augmented with randomly generated jet model and used fuel amount."
</span><span class="koboSpan" id="kobo.295.2">)
def commercial_airliner_flights_silver():
    return (dlt.read_stream(
            "commercial_airliner_flights_bronze")
            .withColumn("jet_model", generate_jet_model())
            .join(spark.table(airliners_table_name),
                  ["jet_model"], "left"))</span></pre>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     When prompted, let’s create a new DLT pipeline by clicking on the blue button at the bottom
    </span>
    <a id="_idIndexMarker455">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     of the notebook cell output
    </span>
    <a id="_idIndexMarker456">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     titled
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.299.1">
      Create pipeline
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     .
    </span>
    <span class="koboSpan" id="kobo.300.2">
     Give the pipeline a meaningful name, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.301.1">
      Commercial Airliner Flights Pipeline
     </span>
    </strong>
    <span class="koboSpan" id="kobo.302.1">
     .
    </span>
    <span class="koboSpan" id="kobo.302.2">
     Select
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.303.1">
      Triggered
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     as the execution mode and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.305.1">
      Core
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     for the product edition.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     Next, select the target catalog and schema in the previous code sample as a target dataset location for our DLT pipeline.
    </span>
    <span class="koboSpan" id="kobo.306.3">
     Finally, click the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.307.1">
      Start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     button to trigger a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      pipeline update.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer078">
     <span class="koboSpan" id="kobo.310.1">
      <img alt="Figure 7.9 – The DLT pipeline created for ingesting commercial airline flight data" src="image/B22011_07_009.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.311.1">
     Figure 7.9 – The DLT pipeline created for ingesting commercial airline flight data
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.312.1">
     Let’s imagine for a second that there’s an external process that aims to calculate the carbon footprint for each commercial flight.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     In this example, the process is another Databricks notebook that reads the output of our silver table and calculates the carbon dioxide emission for each flight taken across the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      United States.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     Create another notebook within your Databricks workspace and give the notebook a meaningful name, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.315.1">
      Calculating Commercial Airliner Carbon Footprint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.316.1">
     .
    </span>
    <span class="koboSpan" id="kobo.316.2">
     Next, let’s add a new notebook cell that reads the silver table and calculates the carbon dioxide output using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      simple formula:
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.318.1">
      Carbon footprint = amount of fuel burned * coefficient / number
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.319.1">
       of passengers
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     In this case, we are only interested in calculating the carbon footprint per airliner jet; so, we will
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     avoid dividing by the number
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.322.1">
     of passengers.
    </span>
    <span class="koboSpan" id="kobo.322.2">
     Add the following code snippet to the newly created notebook, which will assign a calculated carbon footprint per
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      flight entry:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.324.1">
# 3.1kg of CO2 is created</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.325.1"> for every 1kg of fuel used.
</span><span class="koboSpan" id="kobo.325.2"># So we multiply the fuel mass above by 3.1 to estimate the CO2 emitted
# Source: https://ecotree.green/en/calculate-flight-co2
# 1 gallon of jet fuel weighs approximately 3.03907 kilograms
def calc_carbon_footprint(fuel_consumed_gallons):
    return (fuel_consumed_gallons * 3.03907) * 3.1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     Let’s imagine again that the fuel capacity amount in the silver table of our DLT pipeline is currently measured in gallons.
    </span>
    <span class="koboSpan" id="kobo.326.2">
     However, our European business partners want to work with the dataset using liters instead.
    </span>
    <span class="koboSpan" id="kobo.326.3">
     Let’s use the Catalog Explorer to explore the lineage graph of our silver table to better understand what type of impact, converting the unit of measure for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      fuel_capacity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     column, would have on the consumers of the dataset.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     Navigate to the lineage graph by clicking on the Catalog Explorer in the left-hand side navigation bar, filtering the catalogs by entering the name of the catalog in the search text field, and finally clicking on the silver
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      table,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.330.1">
       commercial_airliner_flights_silver
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.331.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer079">
     <span class="koboSpan" id="kobo.332.1">
      <img alt="Figure 7.10 – Column lineage can help us understand how changing columns will impact downstream dependencies – an overview" src="image/B22011_07_010.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.333.1">
     Figure 7.10 – Column lineage can help us understand how changing columns will impact downstream dependencies – an overview
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     By generating
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.335.1">
     the lineage graph, we were
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.336.1">
     able to see in near real time all the downstream columns that might depend on this column.
    </span>
    <span class="koboSpan" id="kobo.336.2">
     Furthermore, we can also see a real-time list of all the Unity Catalog objects that depend on this column, such as notebooks, workflows, DLT pipelines, and machine-learning models.
    </span>
    <span class="koboSpan" id="kobo.336.3">
     So, in effect, we can quickly understand what type of impact changing the unit of measure could have across our organization sharing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.337.1">
      this dataset.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.338.1">
     In the next section, we’ll continue with this example to determine an alternative way for updating this dataset to include fuel capacity, distance travel, and arrival times to be European-friendly without impacting any existing consumers of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      our data.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor182">
    </a>
    <span class="koboSpan" id="kobo.340.1">
     Hands-on lab – documenting data lineage across an organization
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.341.1">
     In this section, we’ll look at how the system tables in Databricks automatically document
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.342.1">
     how the relationships between our datasets and other data assets change over time.
    </span>
    <span class="koboSpan" id="kobo.342.2">
     As previously mentioned, Unity Catalog will preserve data lineage across all workspaces that attach to the same Unity Catalog metastore.
    </span>
    <span class="koboSpan" id="kobo.342.3">
     This is particularly useful in scenarios when organizations need to have strong end-to-end auditing of their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.343.1">
      data assets.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.344.1">
     Let’s again begin by creating a new notebook within our Databricks workspace and giving it a meaningful title, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      Viewing Documented Data Lineage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     .
    </span>
    <span class="koboSpan" id="kobo.346.2">
     Next, let’s create a new all-purpose cluster or attach the notebook to an already running cluster to begin executing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      notebook cells.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Like the Data Lineage API, there are two system tables that provide a read-only view of lineage information in Unity Catalog – the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      system.access.table_lineage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     table and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.351.1">
      system.access.column_lineage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     table.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     Data lineage system tables automatically document information pertaining to upstream and downstream connections for UC table and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.353.1">
      column objects.
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.354.1">
           UC Object
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.355.1">
           Table Name
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.356.1">
           Description
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.357.1">
          Table
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.358.1">
           system.access.table_lineage
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.359.1">
         Contains a list of upstream and downstream table connections, as well as information about their related
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.360.1">
          notebook connections
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.361.1">
          Column
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.362.1">
           system.access.column_lineage
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.363.1">
         Contains a list of upstream and downstream
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.364.1">
          column connections
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.365.1">
     Table 7.2 – Data lineage system tables capture connections info about tables and columns
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     Let’s query
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     the upstream and downstream lineage information in the previous example.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     In a new notebook cell, add the following query and execute
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      the cell:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.369.1">
SELECT *
  FROM system.access.table_lineage
  WHERE source_table_name LIKE '%commercial_airliners_silver%';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     We get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      following output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer080">
     <span class="koboSpan" id="kobo.372.1">
      <img alt="Figure 7.11 – Lineage information can be queried from the system tables" src="image/B22011_07_011.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.373.1">
     Figure 7.11 – Lineage information can be queried from the system tables
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     As you can see from the output, the system table automatically documents connection information about the upstream and downstream sources.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     In addition, the system tables will automatically capture auditing information, including information about the dataset’s creator and the event timestamp of the object creation.
    </span>
    <span class="koboSpan" id="kobo.374.3">
     This is a great way to document, review, or even report on data lineage across your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      organization’s datasets.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-144">
    <a id="_idTextAnchor183">
    </a>
    <span class="koboSpan" id="kobo.376.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     In this chapter, we covered the various ways that data lineage can be traced across datasets in the Databricks Data Intelligence Platform.
    </span>
    <span class="koboSpan" id="kobo.377.2">
     We saw how the Data Lineage REST API allowed us to quickly view the upstream and downstream connections of a particular table or column in Unity Catalog.
    </span>
    <span class="koboSpan" id="kobo.377.3">
     Next, we look at how easy it was to generate a lineage graph using the Catalog Explorer in Unity Catalog.
    </span>
    <span class="koboSpan" id="kobo.377.4">
     The lineage graph was essential for enabling greater insight into how changes to datasets could impact downstream consumers of the dataset.
    </span>
    <span class="koboSpan" id="kobo.377.5">
     Lastly, we looked at how the system tables in Unity Catalog provided a way for our organization to document the evolving flow of data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.378.1">
      asset relationships.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.379.1">
     In the next chapter, we’ll turn our attention to deploying our data pipelines and all their dependencies in an automated fashion using tools such
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.380.1">
      as Terraform.
     </span>
    </span>
   </p>
  </div>
 

  <div class="Content" id="_idContainer082">
   <h1 id="_idParaDest-145" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor184">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 3:Continuous Integration, Continuous Deployment, and Continuous Monitoring
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In the final part of this book, we’ll look at how we can automate the deployment of pipeline changes using popular automation tools such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.3.1">
      Terraform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.4.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.5.1">
      Databricks Asset Bundles
     </span>
    </strong>
    <span class="koboSpan" id="kobo.6.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      DABs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.8.2">
     We conclude the book with a lesson on how you can continuously monitor your DLT pipelines using a variety of tools in the Databricks Data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      Intelligence Platform.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.10.1">
     This part contains the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22011_08.xhtml#_idTextAnchor185">
      <em class="italic">
       <span class="koboSpan" id="kobo.12.1">
        Chapter 8
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.13.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.14.1">
       Deploying, Maintaining, and Administrating
      </span>
     </em>
     <em class="italic">
      <span class="koboSpan" id="kobo.15.1">
       DLT
      </span>
     </em>
     <em class="italic">
      <span class="koboSpan" id="kobo.16.1">
       Pipelines Using Terraform
      </span>
     </em>
    </li>
    <li>
     <a href="B22011_09.xhtml#_idTextAnchor222">
      <em class="italic">
       <span class="koboSpan" id="kobo.17.1">
        Chapter 9
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.18.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.19.1">
       Leveraging Databricks Asset Bundles to Streamline Data Pipeline Deployment
      </span>
     </em>
    </li>
    <li>
     <a href="B22011_10.xhtml#_idTextAnchor249">
      <em class="italic">
       <span class="koboSpan" id="kobo.20.1">
        Chapter 10
       </span>
      </em>
     </a>
     <em class="italic">
      <span class="koboSpan" id="kobo.21.1">
       ,
      </span>
     </em>
     <em class="italic">
      <span class="koboSpan" id="kobo.22.1">
       Monitoring Data Pipelines in Production
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer083">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer084">
   </div>
  </div>
 </body></html>