<html><head></head><body>
		<div id="_idContainer068">
			<h1 class="chapterNumber">2</h1>
			<h1 id="_idParaDest-26" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor025"/>Getting Started with KNIME</h1>
			<p class="normal">It's time to get our hands finally dirty with data as we unveil KNIME, the first instrument we find in our data analytics toolkit. This chapter will introduce you to the foundational features of any low-code analytics platform and will allow you to get started with the universal need you face at the beginning of every analytics project: loading and cleaning data.</p>
			<p class="normal">Let's have a look at the questions this chapter aims to answer:</p>
			<ul>
				<li class="bullet">What is KNIME and where can I get it?</li>
				<li class="bullet">What are nodes and how do they work?</li>
				<li class="bullet">What does a data workflow look like?</li>
				<li class="bullet">How can I load some data in KNIME and clean it up?</li>
			</ul>
			<p class="normal">This is going to be a rather hands-on initiation to the everyday practice of data analytics. Since we will spend some time with KNIME, it's worth first getting some basic background on it.</p>
			<div>
				<div id="_idContainer017" class="note">
					<p class="Information-Box--PACKT-">KNIME (/na�m/) is pronounced like the word <em class="italic">knife</em> but with an <em class="italic">m</em> at the end instead of an f.</p>
				</div>
			</div>
			<h1 id="_idParaDest-27" class="title"><a id="_idTextAnchor026"/>KNIME in a nutshell</h1>
			<p class="normal"><strong class="keyword">KNIME</strong> is a low-code data analytics <a id="_idIndexMarker064"/>platform known for its ease of use and versatility. Let's go through its most prominent features:</p>
			<ul>
				<li class="bullet">KNIME allows the <strong class="keyword">visual design </strong>of data analytics: this means that you can build your sequence of transformation and modeling steps by just drawing it. In the same way as you would sketch a flowchart to describe a process using pencil and paper, with KNIME you will use a mouse and keyboard to depict what you want to do with your data. This is the fundamental difference versus the approach implemented in code-based analytics environments: using tools like KNIME means you don't need to write a line of code unless you want to. The visual approach will also let you have a clear line of sight of what's happening with your data at each step of the process. This makes even complex procedures intuitive to understand and easier to build. For advanced data practitioners like data scientists, this means saving a lot of time for debugging a prototype, as they can easily spot issues along the way. For business users in need of some data analytics, KNIME offers a very hospitable environment, accessible to everyone who wants to learn from scratch.</li>
				<li class="bullet">It is <strong class="keyword">open source</strong> and free <a id="_idIndexMarker065"/>to use: you can download its full version and install it on your computer at no cost. Different from what happens with the trial version of other products, it offers the complete set of functionalities for data analytics without limitations or time constraints. For the sake of completeness: KNIME also offers a <a id="_idIndexMarker066"/>commercial product (called <strong class="keyword">KNIME Server</strong>) that enables the full operationalization of workflows as real-time applications and services, but we will not need to use any of this on our journey.</li>
				<li class="bullet">It offers a rich library of <strong class="keyword">additional packages </strong>for extending its base functionalities. These are available—in most cases—for free. Some of these extensions will let you connect KNIME with cloud platforms (like Amazon Web Services or Microsoft Azure), access other applications (Twitter or Google Analytics, to mention a few), or run specific types of advanced analytics (such as text mining or deep learning). Some packages will even let you add some Python or R code into KNIME so that you can implement even the most specific and sophisticated functionalities offered within their extensive set of libraries. This means that if you know how to program, you can leverage that as well in KNIME. The good news is that—in the vast majority of cases—you simply don't need to!</li>
				<li class="bullet">Lastly, there is a broad and <strong class="keyword">growing community</strong> of KNIME practitioners around the world. This makes it easier to find blogs and forums filled with examples (like the KNIME official one, <a href="http://forum.knime.com"><span class="url">forum.knime.com</span></a>), tutorials, and answers to the most frequent questions you will encounter. Generous KNIME users can also share some ready-to-use modules with the rest of the community to enable others to replicate them: this further enriches the functionalities available out there at the time of need.</li>
			</ul>
			<p class="normal">All these features make KNIME an all-inclusive tool, to the point that some have called it the <strong class="keyword">Swiss Army knife</strong> of <a id="_idIndexMarker067"/>data analytics. Whatever nickname we prefer to give it, KNIME is well suited for learning and practicing everyday analytics and is certainly a tool worth adding to our kit.</p>
			<p class="normal">It's time to get KNIME up and running <a id="_idIndexMarker068"/>on your computer: you can download it from the <a id="_idIndexMarker069"/>official website <a href="http://www.knime.com"><span class="url">www.knime.com</span></a>. Just go to the <strong class="screenText">Download</strong> page and get the installation started for your operating system (KNIME is available for Windows, Unix, and Mac). When you are done with the installation, open the app. At the first run, you might be asked to confirm the location of the <strong class="keyword">Workspace</strong>; this will be the folder where all your projects will be saved. After confirming the workspace folder (you can select any location you like), you are ready to go: the KNIME interface will be there to welcome you.</p>
			<h1 id="_idParaDest-28" class="title"><a id="_idTextAnchor027"/>Moving around in KNIME</h1>
			<p class="normal">As we enter the world of KNIME, it makes sense to familiarize ourselves with the two keywords we are going to use most often: <strong class="keyword">nodes </strong>and <strong class="keyword">workflows</strong>:</p>
			<ul>
				<li class="bullet">A <strong class="keyword">node </strong>is <a id="_idIndexMarker070"/>the essential <a id="_idIndexMarker071"/>building block of any data operation that happens in KNIME. Every action you apply on data—like loading a file, filtering out rows, applying some formula, or building a machine learning model—is represented by a square icon in KNIME, called a <strong class="keyword">node</strong>.</li>
				<li class="bullet">A <strong class="keyword">workflow </strong>is the full <a id="_idIndexMarker072"/>sequence of nodes that describe what you want <a id="_idIndexMarker073"/>to do with your data, from the beginning to the end. To build a data process in KNIME you will have to select the nodes you need and connect them in the desired order, designing the workflow that is right for you:<figure class="mediaobject"><img src="image/B17125_02_01.png" alt=""/></figure></li>
			</ul>
			<p class="packt_figref">Figure 2.1: KNIME user interface: your workbench for crafting analytics</p>
			<p class="normal">KNIME's user interface has got all you need to pick and mix nodes to construct the workflow that you need. Let's go through the six fundamental elements of the interface that will welcome you as soon as you start the application:</p>
			<ol>
				<li class="numbered"><strong class="keyword">Explorer</strong>. This is where <a id="_idIndexMarker074"/>your workflows will be kept handy and tidy. In here you will find: the <strong class="screenText">LOCAL</strong> workspace, which contains the folders stored on your local machine; the KNIME public server, storing many <strong class="screenText">EXAMPLES</strong> organized by topic that you can use for inspiration and replication; the <strong class="screenText">My-KNIME-Hub</strong> space, linked to your user on the KNIME Hub cloud, where you can share private and public workflows and reusable modules—called <strong class="keyword">Components </strong>in KNIME—with others (you can create your space for free by registering at <a href="http://hub.knime.com"><span class="url">hub.knime.com</span></a>).</li>
				<li class="numbered"><strong class="keyword">Node Repository</strong>. In this space, you <a id="_idIndexMarker075"/>can find all the nodes available to you, ready to be dragged and dropped into your workflow. Nodes are arranged in hierarchical categories: if you click on the chevron sign <strong class="screenText">&gt;</strong> on the left of each header, you will go to the level below. For instance, the first category is <strong class="screenText">IO</strong> (<strong class="keyword">input/output</strong>) which includes multiple subcategories, such as <strong class="screenText">Read</strong>, <strong class="screenText">Write</strong>, and <strong class="screenText">Connectors</strong>. You can search for the node you need by entering some keywords in the textbox at the top right. Try entering the word <code class="Code-In-Text--PACKT-">Excel</code> in the search box: you will obtain all nodes that let you import and export data in the Microsoft spreadsheet format. As a painter would find all available colors in the palette, the repository will give you access to all <a id="_idIndexMarker076"/>available nodes for your workflow:<figure class="mediaobject"><img src="image/B17125_02_02.png" alt=""/></figure><p class="packt_figref">Figure 2.2: The Node Repository lists all the nodes available for you to pick</p></li>
				<li class="numbered"><strong class="keyword">Workflow Editor</strong>. This is <a id="_idIndexMarker077"/>where the magic happens: in here you will combine the nodes you need, connect them as required, and see your workflow come to life. Following the analogy we started above with the color palette, the Workflow Editor will be the white canvas on which you will paint your data masterpiece.</li>
				<li class="numbered"><strong class="keyword">Node Description</strong>. This is an <a id="_idIndexMarker078"/>always-on reference guide for each node. When you click on any node—lying either in the repository or in the Workflow Editor—this window gets updated with all you need to know about the node. The typical description of a node includes three parts: a summary of what it does and how it works, a list of the various steps of configuration we can apply (<strong class="screenText">Dialog Options</strong>), and finally, a description of the input and output ports of the node (<strong class="screenText">Ports</strong>).</li>
				<li class="numbered"><strong class="keyword">Outline</strong>. Your workflow <a id="_idIndexMarker079"/>can get quite big and you might not be able to see it fully within your Workflow Editor: the Outline gives you a full view of the workflow and shows which part you are currently visualizing in the Workflow Editor. If you drag the blue rectangle around, you can easily jump to the part of the workflow you are interested in.</li>
				<li class="numbered"><strong class="keyword">Console </strong>and <strong class="keyword">Node Monitor</strong>. In this section, you <a id="_idIndexMarker080"/>will find a couple of helpful diagnostics and debugging gadgets. The <strong class="screenText">Console</strong> will show the full description of the latest warnings and errors while the <strong class="screenText">Node Monitor</strong> shows a <a id="_idIndexMarker081"/>summary of the data available at the output port of the currently selected node.</li>
			</ol>
			<div>
				<div id="_idContainer020" class="packt_tip">
					<p class="Tip--PACKT-">You can personalize the look and feel of the user interface by adding and removing elements from the <strong class="screenText">View</strong> menu. Should you want to go back to the original setup, as displayed in the figure above, just click on <strong class="screenText">View | Reset Perspective...</strong>.</p>
				</div>
			</div>
			<p class="normal">Although these six sections cover all the essential needs, the KNIME user interface offers more sections that you might be curious enough to explore. For instance, on the left, you have the Workflow Coach, which suggests the next most likely node you are going to add to the workflow, based on what other users do. Lastly, in the same window of the Node Description, you will find an <a id="_idIndexMarker082"/>additional panel (look for its header at the top) called KNIME Hub: in here, you can search for examples, additional packages, and modules that you can directly drag and drop into your workflow, as you would do from the Node Repository.</p>
			<h2 id="_idParaDest-29" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor028"/>Nodes</h2>
			<p class="normal">Nodes are the <a id="_idIndexMarker083"/>backbone of KNIME and we <a id="_idIndexMarker084"/>need to feel totally confident with them: let's discover how they work and what types of nodes are available:</p>
			<figure class="mediaobject"><img src="image/B17125_02_03.png" alt=""/></figure>
			<p class="packt_figref"> Figure 2.3: Anatomy of a node in KNIME: the traffic light tells us the current status</p>
			<p class="normal">As you can see from the figure above, nodes look like square icons with some text and shapes around them. More precisely:</p>
			<ul>
				<li class="bullet">On top of a node, you will find its <strong class="keyword">Name</strong> in bold. The name tells you, in a nutshell, what that type of node does. For example, to rename some columns in a table, we use the <a id="_idIndexMarker085"/>node called <strong class="keyword">Column Rename</strong>.</li>
				<li class="bullet">At the bottom of the square, you find a <strong class="keyword">Comment </strong>. This is a label that should explain the specific role of that node in your workflow. By default, KNIME applies a counter to every new node as it gets added to the workflow, like Node 1, Node 2, and so on. You can modify the comment by just double-clicking on it.</li>
			</ul>
			<div>
				<div id="_idContainer022" class="packt_tip">
					<p class="Tip--PACKT-">I strongly encourage you to comment on every single node in your workflow with a short description that explains what it does. When workflows get complex you will quickly forget what each node was meant to do there. Trust me: it's a worthy investment of your time!</p>
				</div>
			</div>
			<ul>
				<li class="bullet">Nodes are <a id="_idIndexMarker086"/>connected <a id="_idIndexMarker087"/>through <strong class="keyword">Ports</strong>, lying at the left and at the right of <a id="_idIndexMarker088"/>the square. By convention, the ports on the left are input ports, as they bring data into the node, while ports on the right are output ports, carrying the results of the node execution. Ports can have different shapes and colors, depending on what they carry: most of them are triangles, as they convey data tables, but they could be squares (models, connections, images, and more) or circles (variables).</li>
				<li class="bullet">At the bottom of every node, you have a traffic light that signals the current <strong class="keyword">Status </strong>of the node. If the red light is on, the node is not ready yet to do its job: it could be that some required data has not been given as an input or some configuration step is needed. When the light is amber, the node has all it needs and is ready to be executed on your command. The green light is good news: it means that the node was successfully executed and the results are available at the output ports. Some icons can appear on the traffic light if something is not right: a yellow triangle with an exclamation mark indicates a warning while a red circle with a cross announces an error. In these cases, you can learn more about what went wrong by keeping your mouse on them for a second (a label will appear) or by reading the Console.</li>
			</ul>
			<p class="normal">As we have already started to see in the Node Repository, there are several families of nodes available in KNIME, each responding to a different class of data analytics needs. Here are the most popular ones:</p>
			<ul>
				<li class="bullet"><strong class="keyword">Input &amp; Out</strong>p<strong class="keyword">ut</strong>: these nodes will bring data in and out of KNIME. Normally, input nodes are at the beginning of workflows: they can open files in different formats (CSV, Excel, images, webpages, to mention some) or connect to remote databases and pull the data they need. As you can see from <em class="italic">Figure 2.4</em>, the input nodes have only output ports on the right and do not have any input ports on the left (unless they require a connection with a database). This makes sense as they have the role of initiating a workflow by pulling data into it after reading it from somewhere. Conversely, output nodes tend to be used at the end of a workflow as they can save data to files or cloud locations. They rarely have output ports as they close our chain of operations.</li>
				<li class="bullet"><strong class="keyword">Manipulation</strong>: These nodes are <a id="_idIndexMarker089"/>capable of handling data tables and transforming them according to our needs. They can apply steps for aggregating, combining, sorting, filtering, and reshaping tables, but also managing missing values, normalizing data points, and converting data types. These nodes, together with those in the previous family, are virtually unmissable in any data analytics workflow: they can jointly clean the data and prepare it in the format required by any subsequent step, like creating a model, a report, or a chart. These nodes can have one or more input ports and one or more output ports, as they are capable of merging and splitting tables.</li>
				<li class="bullet"><strong class="keyword">Analytics</strong>: These are the <a id="_idIndexMarker090"/>smartest nodes of the pack, able to build statistical models and support the implementation of artificial intelligence algorithms. We will learn how to use these nodes in the chapters dedicated to machine learning. For now, it will be sufficient to keep with us the reassuring thought that even complex AI procedures (like creating a deep neural network) can be obtained by wisely combining the right modeling nodes, available in our Node Repository. As you will notice in <em class="italic">Figure 2.4</em>, some of the ports are squares as they stand for statistical models instead of data tables.</li>
				<li class="bullet"><strong class="keyword">Flow Control</strong>: Sometimes, our <a id="_idIndexMarker091"/>workflows will need to go beyond the simple one-branch structure where data flows only once and follows a single chain of nodes. These <a id="_idIndexMarker092"/>nodes can create loops across branches so we can repeat several steps through cycles, like a programmer would do with flow control statements (for those of you who can program, think of <code class="Code-In-Text--PACKT-">while</code> or <code class="Code-In-Text--PACKT-">for</code> constructs). We can also dynamically change the behavior of nodes by controlling their configuration through variables. These nodes are more advanced and, although we don't need them most of the time, they are a useful resource when the going gets tough.</li>
				<li class="bullet"><strong class="keyword">All others</strong>: On top of the ones above, KNIME offers many other types of nodes, which can help us with more specific needs. Some nodes let us interact systematically with third-party applications <a id="_idIndexMarker093"/>through interfaces called <strong class="keyword">Application Programming Interfaces</strong> (<strong class="keyword">APIs</strong>): for example, an extension called KNIME Twitter Connectors lets you search for tweets or download public user information in mass to run some analytics on it. Other extensions will let you blend KNIME with programming languages like Python and R so you can run snippets of code in KNIME or execute KNIME workflows from other environments. You will also have nodes for running statistical tests and for building visualizations or full reports.</li>
			</ul>
			<div>
				<div id="_idContainer023" class="packt_tip">
					<p class="Tip--PACKT-">When you are looking for advanced functionality in KNIME, you can check the KNIME Hub or run a search on <a href="http://nodepit.com"><span class="url">nodepit.com</span></a>, a search engine for KNIME workflows, components, and nodes. </p>
				</div>
			</div>
			<figure class="mediaobject"><img src="image/B17125_02_04.png" alt=""/></figure>
			<p class="packt_figref">Figure 2.4: A selection of KNIME nodes by type: these are the LEGO® bricks of your data analytics flow</p>
			<p class="normal">I hope that reading about <a id="_idIndexMarker094"/>the broad <a id="_idIndexMarker095"/>variety of things you can do with nodes has whetted your appetite for more. It's finally time to see nodes in action and build a simple KNIME workflow.</p>
			<h1 id="_idParaDest-30" class="title"><a id="_idTextAnchor029"/>Hello World in KNIME</h1>
			<p class="normal">As you put together <a id="_idIndexMarker096"/>your first workflow, you will learn how to interact with KNIME's user interface to connect, configure, and execute nodes: this is the bread and butter of any KNIME user, which you are about to become.</p>
			<div>
				<div id="_idContainer025" class="note">
					<p class="Information-Box--PACKT-">The title of this section is a thing for geeks: in fact, when you learn a new programming language, <code class="Code-In-Text--PACKT-">"Hello, World!"</code> is the first program you get to write. It is very simple and is meant to illustrate the basic syntax of a language. </p>
				</div>
			</div>
			<p class="normal">Let's imagine we have a simple and repetitive data operation to perform regularly: every day we receive a text file in <strong class="keyword">Comma-Separated Value </strong>(<strong class="keyword">CSV</strong>) format, which reports the cumulative sales generated by country in the year to date. The original file has some unnecessary columns and the order of rows is random. We need to apply some basic transformation steps so that we end up with a simple table showing just two columns: one is the name of the country and the other the amount of generated sales. We also want the rows to be sorted by decreasing sales. Lastly, we need to convert the file into Excel as it is a format that's easier to read for our colleagues. We can build a KNIME workflow that does exactly that once, in a way that we don't need to repeat the tedious task manually every day. Let's open KNIME Analytics Platform and build our time-saving workflow.</p>
			<p class="normal">To keep our workflows tidy, we can organize them hierarchically, in folders: in KNIME, folders are called <strong class="keyword">Workflow Groups</strong>. So, let's <a id="_idIndexMarker097"/>start by creating a workflow group that will host our first piece of work:</p>
			<ol>
				<li class="numbered" value="1">Right-click on the <strong class="screenText">LOCAL</strong> entry in the KNIME Explorer section (top-left) and then click on <strong class="screenText">New Workflow Group...</strong> in the pop-up menu.</li>
				<li class="numbered">Enter the name of your new folder (you can call it <code class="Code-In-Text--PACKT-">Chapter 2</code>) and click on <strong class="screenText">Finish</strong>:<figure class="mediaobject"><img src="image/B17125_02_05.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.5: Creating a Workflow Group in KNIME: keep your work tidy by organizing it in folders</p><p class="normal">You will see that the <a id="_idIndexMarker098"/>new folder has appeared in your local workspace. Now we can finally create a new workflow within this group. Similar to what you just did when creating a group, you just need to follow a few more steps:</p></li>
				<li class="numbered">Right-click on the newly created workflow group and then on <strong class="screenText">New KNIME Workflow...</strong>.</li>
				<li class="numbered">Enter the name of your new workflow (how about <code class="Code-In-Text--PACKT-">Hello World</code>?) and then click <strong class="screenText">Finish</strong>. Your workflow will appear in the editor, which at this point will look like a sheet of squared paper.</li>
				<li class="numbered">It's time to load our CSV file into KNIME, using the proper input node. The fastest way to do so is to drag and drop the file directly into the Workflow Editor: just grab the file named <code class="Code-In-Text--PACKT-">raw_sales_country.csv</code> from the folder where it is located and drop it anywhere on the blank editor. KNIME will recognize the type of file and automatically implement the right node for reading it: in this case, CSV Reader. As you drop the file, its configuration dialog will appear. If at any point you need to revise its configuration, you can just double-click on the node to obtain the same dialog.<p class="normal">Like we will do every time we meet a new KNIME node on our journey, let's quickly discover how it works and how to configure it.</p></li></ol>

<h2 id="_idParaDest-31" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor030"/><img src="image/B17125_02_06.png" alt=""/> <em class="bold-italic">CSV Reader</em></h2><p class="normal">This node (available in the repository under the path <strong class="screenText">IO &gt; Reader</strong>) reads data from a text file stored in a <a id="_idIndexMarker099"/>CSV format and makes it available as a table in KNIME. This <a id="_idIndexMarker100"/>node is pretty handy: it attempts to detect the format of the file and recognizes the type of data stored in each column, allowing you to manually change it if needed. It also lets you run some basic reformatting on the fly, like changing the names of columns. As you see in <em class="italic">Figure 2.6</em>, its configuration <a id="_idIndexMarker101"/>window displays multiple tabs, whose headers appear at the top. The first tab (<strong class="screenText">Settings</strong>) lets you set the fundamentals:</p><ul><li class="bullet">In the first section at the top, you can specify the path of the file to be read: to do so, just click on the <strong class="screenText">Browse...</strong> button and select the file. If you dragged and dropped your file in the Workflow Editor, this field is pre-populated. The node lets you also read multiple files in a folder having the same format, by selecting the <strong class="screenText">Files in folder</strong> mode.</li><li class="bullet">In the middle section, you can specify the format of the file, like the characters used to delimit rows and columns and if it has column headers. All these parameters get automatically guessed by the node when a new file is loaded (you can click on <strong class="screenText">Autodetect format</strong> to force a new attempt). One useful option is <strong class="screenText">Support short data rows</strong>: if this box is ticked, the node will keep working even if some rows have incomplete data points. The good news is that in most cases you will not need to change any of these parameters manually as the automatic detection feature is pretty robust.</li><li class="bullet">At the bottom of the tab, you find the <strong class="screenText">Preview</strong> of the table read in the file. This lets you check that the format has been determined correctly.</li></ul>

			<figure class="mediaobject"><img src="image/B17125_02_07.png" alt="Graphical user interface, table&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 2.6: Configuration dialog of the CSV Reader node: you can specify which file to read and how</p>
			<p class="normal">If you move to the <a id="_idIndexMarker102"/>second tab of the window (called <strong class="screenText">Transformation</strong>) you will <a id="_idIndexMarker103"/>have the opportunity to apply some simple reformatting to your table as it gets loaded. For instance, you can: change the name of columns (just write the new one in the <strong class="screenText">New name</strong> column), drop some columns you don't need (untick the box on the left of their name), change the column order (drag and drop them using your mouse), and change their data type (for instance, from text to numbers).</p>
			<div>
				<div id="_idContainer029" class="note">
					<p class="Information-Box--PACKT-">Every column in a KNIME table is associated with a <strong class="keyword">data type</strong>, indicated by a squared letter beside the name of the column. The most common data types are strings (indicated by the letter <code class="Code-In-Text--PACKT-">S</code>, which are sets of text characters), decimal numbers (letter <code class="Code-In-Text--PACKT-">D</code>), integer numbers (<code class="Code-In-Text--PACKT-">I</code>), long integers (<code class="Code-In-Text--PACKT-">L</code>, like integers but able to store more digits), and Boolean values (<code class="Code-In-Text--PACKT-">B</code>, which can be only <code class="Code-In-Text--PACKT-">FALSE</code> or <code class="Code-In-Text--PACKT-">TRUE</code>).</p>
				</div>
			</div>
			<p class="normal">You can check the results of your transformation in the preview section at the bottom. To be clear, you could do these transformations later in your workflow (you have specific KNIME nodes for <a id="_idIndexMarker104"/>renaming columns, changing their orders, and so on) but it <a id="_idIndexMarker105"/>might be just faster and easier to make these changes here on the spot, using one single node.</p>
			<div>
				<div id="_idContainer030" class="packt_tip">
					<p class="Tip--PACKT-">In case the CSV Reader node fails in reading your data as you required, try another node called File Reader. Especially with ill-formatted files, the latter node is more robust than CSV Reader, although it cannot transform the structure of the table on the fly. </p>
				</div>
			</div>
			<figure class="mediaobject"><img src="image/B17125_02_08.png" alt=""/></figure>
			<p class="packt_figref">Figure 2.7: The transformation tab of the CSV Reader node: reformat your table on the fly</p>
			<ol>
				<li class="numbered" value="6">Looking at the preview of the table in the <strong class="screenText">Settings</strong> tab, it looks like the node has done a good job of interpreting the format of the file. We just noticed that there are some columns we don't need to carry and they can be dropped (specifically, <code class="Code-In-Text--PACKT-">country_CODE</code> and <code class="Code-In-Text--PACKT-">population_2020</code>) and, also, that we can simplify some of the column names by renaming them. To do this, we need to move to the <strong class="screenText">Transformation</strong> tab: just click on its name at the top of the window.</li>
				<li class="numbered">Let's first remove the columns we don't need, by just unticking the boxes beside their names, as shown in <em class="italic">Figure 2.7</em>.</li>
				<li class="numbered">Let's also assign more friendly titles to the other two columns by typing them in the <strong class="screenText">New name</strong> section: let's rename <code class="Code-In-Text--PACKT-">country_name</code> to <code class="Code-In-Text--PACKT-">Country</code> and <code class="Code-In-Text--PACKT-">sales_USD</code> to <code class="Code-In-Text--PACKT-">Sales</code>.</li>
				<li class="numbered">The preview of the transformed table looks exactly like we wanted; this means we are done with the configuration of this node, and we can close it by clicking on the <strong class="screenText">OK</strong> button.</li>
				<li class="numbered">To keep things <a id="_idIndexMarker106"/>clear to ourselves and others we want to <a id="_idIndexMarker107"/>comment on every node in our workflows. Let's start from this very first node. If we double-click on the label underneath (which by default will read <strong class="screenText">Node 1</strong>), we can change it to something more meaningful, like <code class="Code-In-Text--PACKT-">Read raw data</code>. From this point on, I will not mention every time we need to comment on each node—just make it become a habit.</li>
				<li class="numbered">Our node is displaying an encouraging yellow traffic light: it means it has all it needs to fulfill its duty—we just need to say the word. To execute a node in KNIME, we can either select it and press <span class="keyStroke">F7</span> on our keyboard or right-click on the node to obtain the pop-up menu, as shown in <em class="italic">Figure 2.8</em>. When it appears, click on <strong class="screenText">Execute</strong>:<figure class="mediaobject"><img src="image/B17125_02_09.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.8: The pop-up menu in the Workflow Editor: right-click on any node to make it appear</p></li>
				<li class="numbered">The traffic light turning green is a good sign: our node was successfully executed. A useful feature of KNIME is that you can easily inspect what's going on at each step of the flow, by viewing what data is available at the output ports of every node. In the pop-up menu obtained by right-clicking on a node, you will find one or more icons showing a magnifying lens (normally one for each output port, at the bottom of the menu). By clicking on these icons, you will open a window showing the data you are after. Let's do so now: right-click to make the pop-up menu appear and then click on <strong class="screenText">File Table</strong> at the bottom of the menu (alternatively you can check out the Node Monitor or use the keyboard shortcut to open the first output view of a node, which is <span class="keyStroke">Shift</span> + <span class="keyStroke">F6</span>). Not surprisingly, we obtain the same table we had in preview in the preview step. It seems that, so far, everything is working right. We can click <strong class="screenText">OK</strong> and move on.</li>
				<li class="numbered">The next step is <a id="_idIndexMarker108"/>to sort rows by decreasing <a id="_idIndexMarker109"/>amounts of sales. We can use a node that is meant to do exactly that: Sorter. Let's add our Sorter node to the workflow, pulling it from the Node Repository at the bottom left. You can either look it up by typing <code class="Code-In-Text--PACKT-">Sorter</code> in the search box or find it in the hierarchy by clicking first on <strong class="screenText">Manipulation</strong>, then <strong class="screenText">Row</strong>, and—finally—<strong class="screenText">Transform</strong>. When you see the Sorter node, grab it with your mouse and drop it on the workflow, at the right of the CSV Reader node.</li>
				<li class="numbered">Your node is now lying <a id="_idIndexMarker110"/>alone in the workflow while we <a id="_idIndexMarker111"/>want it to be cooperating with other nodes. In fact, we need it to sort the table output by the CSV Reader, so we need to create a connection between the two nodes. In KNIME, we create connections by just drawing them with the mouse. Click on the output port of the CSV Reader (the little arrow on its right) and while keeping the mouse button pressed, go to the input port of the Sorter node. When you release the button, you will see a connection appearing between the nodes. This is exactly what we wanted, the table given in the output by the CSV Reader has now become an input for the Sorter.<p class="normal">We are now ready to configure the Sorter: let's learn about our new node.</p>
</li>
</ol>

<h2 id="_idParaDest-32" class="title" lang="en-GB" xml:lang="en-GB"><strong class="bold-italic"><a id="_idTextAnchor031"/><img src="image/B17125_02_10.png" alt=""/> <em class="bold-italic">Sorter</em></strong></h2><p class="normal">This node (available in the repository in <strong class="screenText">Manipulation &gt; Row &gt; Transform</strong>) can sort the <a id="_idIndexMarker112"/>rows of a table <a id="_idIndexMarker113"/>according to a set of criteria defined by the user. Its configuration is self-explanatory: from the drop-down menu, you <a id="_idIndexMarker114"/>can select the column you wish to sort by. The radio buttons on the right let you choose whether the sorting shall follow an <strong class="screenText">Ascending</strong> (A to Z or 1 to 9) or <strong class="screenText">Descending</strong> (the other way around) order. You can add additional rules on other columns that will come to play to <em class="italic">break the ties</em> in case multiple rows carry the same value in a column. To do so, just click on the <strong class="screenText">Add Rule</strong> button and you will see further drop-down menus appearing. You can change the order of precedence among multiple rules by using the <strong class="screenText">↑</strong> and <strong class="screenText">↓</strong> arrows:</p><figure class="mediaobject"><img src="image/B17125_02_11.png" alt=""/></figure><p class="packt_figref">Figure 2.9: Configuration window of the node Sorter: define the desired order of your rows</p>
<ol>				
<li class="numbered" value="15">To open the <a id="_idIndexMarker115"/>configuration window of Sorter, you can either <a id="_idIndexMarker116"/>double-click on the node or right-click on it and then press <strong class="screenText">Configure…</strong>. You could also just press <span class="keyStroke">F6</span> on your keyboard after selecting the node with your mouse.</li>
				<li class="numbered">Given our needs, the configuration of the node is straightforward: just select <code class="Code-In-Text--PACKT-">Sales</code> in the drop-down menu and then click on the second radio button to apply a descending order. Press <strong class="screenText">OK</strong> to close the window.</li>
				<li class="numbered">The Sorter node is now clear about the input table to use and about the way we want the sorting to happen: it is all ready to go. Let's execute it (<span class="keyStroke">F7</span> or right-click and select <strong class="screenText">Execute</strong>) and open the view showing its output (<span class="keyStroke">Shift</span> + <span class="keyStroke">F6</span> or right-click and select <strong class="screenText">Sorted Table</strong>, the last icon with the magnifying lens):<figure class="mediaobject"><img src="image/B17125_02_12.png" alt="Table&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.10: Output of Sorter node: our countries are now showing by decreasing sales</p>
</li>
</ol>

<div id="_idContainer036" class="note"><p class="Information-Box--PACKT-">Every row in a KNIME table is associated <a id="_idIndexMarker117"/>with a unique label called <strong class="keyword">Row ID</strong>. When a table is created, row IDs are normally generated in the form of a counter (<code class="Code-In-Text--PACKT-">Row0</code>, <code class="Code-In-Text--PACKT-">Row1</code>, <code class="Code-In-Text--PACKT-">Row2</code>, and so on) and are preserved along the workflow. That's why in the output of the Sorter node you can still find the original row position by looking at the Row IDs on the left.</p></div><p class="normal">It looks like we have our countries sorted in the right order and we can proceed to the last step: exporting our table as an Excel file.</p>

<h2 id="_idParaDest-33" class="title" lang="en-GB" xml:lang="en-GB"><strong class="bold-italic"><a id="_idTextAnchor032"/><img src="image/B17125_02_13.png" alt=""/> Excel Writer</strong></h2><p class="normal">This node (available within <strong class="screenText">IO &gt; Write</strong> in the repository) saves data as Excel worksheets. The configuration <a id="_idIndexMarker118"/>dialog will let you first select the <a id="_idIndexMarker119"/>format of the file to create (the legacy <code class="Code-In-Text--PACKT-">.xls</code> or the latest <code class="Code-In-Text--PACKT-">.xlsx</code> one) and where to save it (click on the <strong class="screenText">Browse...</strong> button to select a path). By selecting the <strong class="screenText">if exists</strong> radio buttons, you can specify what to do if a file with that name is already there <a id="_idIndexMarker120"/>where you want to save it: you can overwrite the old data, append the new data as additional rows, or preserve the original file. An important option to check is <strong class="screenText">Write column headers</strong>: when selected, the column names of your table are added as headers in the first row of your Excel file.</p><div id="_idContainer038" class="packt_tip"><p class="Tip--PACKT-">Although we don't need to do that now, it's useful to know that some KNIME nodes can also save files on cloud-based file systems, like Google Drive or Microsoft Sharepoint. This is why you also see the option <strong class="screenText">Add ports | File System Connection</strong> when you click on the three dots (<strong class="screenText">...</strong>) at the bottom left of the node. Another useful feature of the node is that it can manage multiple input tables and save them as separate worksheets in the same Excel file. To do so, you need to click on the three dots on the node and click on <strong class="screenText">Add ports &gt; Sheet Input Ports</strong>. You can give different names to the various sheets by typing in the <strong class="screenText">Sheets</strong> section of the configuration window.</p></div><figure class="mediaobject"><img src="image/B17125_02_14.png" alt=""/></figure><p class="packt_figref">Figure 2.11: Configuration window of Excel Writer: select where to save your output file</p>
<ol>
				<li class="numbered" value="18">Let's <a id="_idIndexMarker121"/>add the Excel Writer node to our workflow, dragging it <a id="_idIndexMarker122"/>from the Node Repository, and then create a connection between the output port of the Sorter and the input node of the Excel Writer.</li>
				<li class="numbered">Open the configuration window of the Excel Writer (double-click on it). The only configurations we need to add in this case are the location and the name of the output file (click on the <strong class="screenText">Browse...</strong> button, go to the desired folder, and type the name of the new file) and, since we might need to repeat this process regularly, select the <strong class="screenText">overwrite</strong> option using the radio button below.</li>
				<li class="numbered">It's time to run the node (<em class="keyStroke">F7</em> or right-click and select <strong class="screenText">Execute</strong>) and open the new file in Excel. You'll be pleased to see that the new file looks exactly how we wanted.</li>
			</ol>


			<p class="normal">Congratulations on creating your first KNIME workflow! By combining three nodes and configuring them appropriately, you implemented a simple data transformation routine that you can now repeat in a matter of seconds, whenever it's needed. More importantly, we used this first tutorial to get acquainted with the fundamental operations you need to build any workflow, such as pulling the right nodes, configuring and executing them, and checking that all works as it should:</p>
			<figure class="mediaobject"><img src="image/B17125_02_15.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 2.12: Hello World: your first workflow in KNIME</p>
			<p class="normal">We now have all we need to start building more complex data operations, discovering what other KNIME nodes can do, and this is exactly what we will do in the next few pages. Since we don't want to lose our precious Hello World workflow, it would be a good idea to save it: just press <span class="keyStroke">Ctrl</span> + <span class="keyStroke">S</span> on your keyboard or click on the disk icon at the top left of your screen. If you want to share your workflow with others, you first need to export it as a standalone file. To do so, right-click on the name of the workflow within the KNIME Explorer panel on the left and then select <strong class="screenText">Export KNIME Workflow...</strong>:</p>
			<figure class="mediaobject"><img src="image/B17125_02_16.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 2.13: How to export a KNIME workflow: you can then share it with whoever you like</p>
			<p class="normal">In the window that appears, you will have to specify the location and name of the file with your workflow by clicking on the <strong class="screenText">Browse...</strong> button. If you keep the <strong class="screenText">Reset Workflow(s) before export</strong> option checked, KNIME will only export the definition of the workflow (the nodes' structure and their configuration) without any data in it. If you untick it, the <a id="_idIndexMarker123"/>data stored in every executed node will be <a id="_idIndexMarker124"/>exported as well (making your export much larger in size). You can now send the resulting file (with <code class="Code-In-Text--PACKT-">.KNWF</code> as an extension) via email or save it in a safe place. Whoever receives it can import it back in their KNIME installation by clicking on <strong class="screenText">File | Import KNIME Workflow...</strong> and selecting the location of the file to import and the destination of the workflow.</p>
			<h1 id="_idParaDest-34" class="title"><a id="_idTextAnchor033"/>Cleaning data</h1>
			<p class="normal">Often, when we deal with <a id="_idIndexMarker125"/>real-world data analytics, we face a reality that is as annoying as ubiquitous: data can be dirty. The format of text and numbers, the order of rows and columns, the presence of undesired data points, and the lack of some expected values are all possible glitches that can slow down or even jeopardize the process of creating some value from data. Indeed, the lower the quality of the input data, the less useful the resulting output will be. This inconvenient truth is often summarized with the <a id="_idIndexMarker126"/>acronym <strong class="keyword">GIGO</strong>: <strong class="keyword">Garbage In, Garbage Out</strong>. As a consequence, one of the preliminary phases of a data analytics workflow is <strong class="keyword">Data Cleaning</strong>, meaning the process of systematically identifying and correcting inaccurate or corrupt data points. Let's learn how to build a full set of data cleaning steps in KNIME through a realistic example.</p>
			<p class="normal">In this tutorial, we are <a id="_idIndexMarker127"/>going to clean a table that captures information on the users of an e-commerce website, such as name, age, email address, available credit, and so on. This table has been generated by pulling directly from the webserver all the available raw data. Our ultimate objective is to create a clean list of contactable users, which we can leverage as a mailing list for sending email newsletters. Since the list of users constantly changes (as some subscribe and unregister themselves every day), we want to build a KNIME workflow that systematically cleans the latest data for us every time we want to update our mailing list:</p>
			<figure class="mediaobject"><img src="image/B17125_02_17.png" alt=""/></figure>
			<p class="packt_figref">Figure 2.14: The raw data: we certainly have some cleaning chores ahead</p>
			<p class="normal">As you can see from <em class="italic">Figure 2.14</em>, a first look at the raw table unveils a series of data quality flaws to be looked after. For instance:</p>
			<ol type="A">
				<li class="alphabetic-l2">Some rows appear to be duplicated.</li>
				<li class="alphabetic-l2">Names and surnames have inconsistent capitalization and some unpleasant blank characters. Additionally, instead of having two separate fields for the name, we would prefer to have a single column (currently missing) with the full name of each person.</li>
				<li class="alphabetic-l2">Some email addresses are wrongly formatted (as they miss the <code class="Code-In-Text--PACKT-">@</code> symbol or the full domain), making the respective users not contactable.</li>
				<li class="alphabetic-l2">Various values are missing, leaving the cell empty.<div id="_idContainer043" class="note"><p class="Information-Box--PACKT-">In KNIME, missing values are indicated with a red question mark symbol, <code class="Code-In-Text--PACKT-">?</code>. For reference, in computer science, a missing value is referred to with the expression <code class="Code-In-Text--PACKT-">NULL</code>.</p></div></li>
				<li class="alphabetic-l2">Some credit values are negative. We know that according to company policy these users should be considered inactive and shall not be contacted, so we can remove them from the list.</li>
				<li class="alphabetic-l2">Some columns are not needed. In this case, we can drop the column holding the IP address of the user since it cannot be used for sending a newsletter or to personalize its content.</li>
			</ol>
			<p class="normal">We have an <a id="_idIndexMarker128"/>Excel file (<code class="Code-In-Text--PACKT-">DirtyData.xlsx</code>) with an excerpt of the raw data, showing samples of all those issues listed above. By using this file as a base, we can build a KNIME workflow that polishes the data and exports a good-looking and ready-to-use mailing list. Let's do this one step at a time:</p>
			<ol>
				<li class="numbered" value="1">First of all, we need to create a blank workflow (you can do this as seen in the previous example or—alternatively—you can go to <strong class="screenText">File | New...</strong> and then select <strong class="screenText">New KNIME Workflow</strong>): we can call it <code class="Code-In-Text--PACKT-">Cleaning data</code>.</li>
				<li class="numbered">To load the data, we can either drag and drop the source file on the Workflow Editor or grab the Excel Reader node from the repository and place it in the blank editor space.
</li>
</ol>


<h2 id="_idParaDest-35" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor034"/><img src="image/B17125_02_18.png" alt=""/> <em class="bold-italic">Excel Reader</em></h2><p class="normal">This node (<strong class="screenText">IO &gt; Read</strong>) opens Excel files, reads the <a id="_idIndexMarker129"/>content of the <a id="_idIndexMarker130"/>specified worksheet, and makes it available as a table at its output port. In the main tab of the configuration dialog, after indicating which file or folder to open (click on <strong class="screenText">Browse...</strong> to change), you can specify (<strong class="screenText">Sheet selection</strong>) the worksheet to consider: by default, the node will read the first sheet available in the workbook but you can indicate the name of a specific sheet or its position. If your sheet includes the column headers, you can ask KNIME to use them as column names in the resulting table: in the section <strong class="screenText">Column Header</strong>, you can select which row contains the column headers. You can also restrict the reading to a portion of the sheet, by specifying the range of columns and rows to read within the <strong class="screenText">Sheet area</strong> section. You can check whether the <a id="_idIndexMarker131"/>node is configured correctly by looking at the bottom of the window, which <a id="_idIndexMarker132"/>gives you a preview of what KNIME is reading from the file:</p><figure class="mediaobject"><img src="image/B17125_02_19.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.15: Configuration of the Excel Reader node: select file, sheets, and areas to read</p><p class="normal">If you want to apply some transformations (like renaming columns, reordering them, and so on) as the data gets read, you can use the <strong class="screenText">Transformation</strong> tab, which works the same as in the CSV Reader node we have already met.</p>
<ol>
				<li class="numbered" value="3">Configuring this node will be pretty simple in our case: we should just select the file to open and leave all other parameters unchanged as the default selection looks good for us. We could use the <strong class="screenText">Transformation</strong> tab to make some adjustments to the format but we will do it later using the appropriate nodes, so we can keep it easy for now.<p class="normal">To remove the duplicated rows we <a id="_idIndexMarker133"/>can use a new node <a id="_idIndexMarker134"/>that does exactly that: its name is Duplicate Row Filter.</p>
</li>
</ol>


<h2 id="_idParaDest-36" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor035"/><img src="image/B17125_02_20.png" alt=""/> <em class="bold-italic">Duplicate Row Filter</em></h2><p class="normal">This node (<strong class="screenText">Manipulation &gt; Row &gt; Filter</strong>) identifies rows having the same values in selected columns and manages <a id="_idIndexMarker135"/>them accordingly. In the <a id="_idIndexMarker136"/>first tab of the configuration window, you select which columns should be considered for the search of duplicates. </p><p class="normal">If more than one column is selected, the node will consider duplicates as only rows that have exactly the same values across all the selected columns. In the configuration of many KNIME nodes, we will be asked to select a subset of columns, so it makes sense to spend some time on becoming acquainted with the interface:</p>
<ul>
<li class="bullet">The panel on the right (having a green border) contains the columns included in your selection while the one on the left (red-bordered) displays the excluded columns.</li>
<li class="bullet">By double-clicking on the names of the columns or by using the four arrow buttons in the middle, you can transfer the columns across panes.</li><li class="bullet">If you have many columns, you can look them up by name using the <strong class="screenText">Filter</strong> textboxes at the top of each pane.</li>
<li class="bullet">If you want to select columns by patterns in their names (like the ones starting with an <code class="Code-In-Text--PACKT-">A</code>) or by type (integers, decimal numbers, strings, and so on), you can select the other options available on the radio selector on top (<strong class="screenText">Wildcard/Regex Selection</strong> or <strong class="screenText">Type Selection</strong>).</li>
</ul>

			<p class="normal">The second tab in the configuration window (titled <strong class="screenText">Advanced</strong>) lets you decide what to do with the duplicate rows once identified (by default, they get removed but you can also keep them and add an extra column specifying whether they are duplicates or not) and which rows should be kept among the duplicates (by default, the first row is kept and all others are removed, but other strategies are available):</p>
			<figure class="mediaobject"><img src="image/B17125_02_21.png" alt="Graphical user interface, application, email&#10;&#10;Description automatically generated"/> </figure>
			<p class="packt_figref">Figure 2.16: Configuration of the Duplicate Row Filter: select which columns to use for detecting duplicate rows</p>
			<ol>
				<li class="numbered" value="4">Let's implement the Duplicate Row Filter node and connect it with the output port of the Excel Reader. The new node will now show an amber status light, signaling that it can run with its default behavior, although we want to do some configuration first.</li>
				<li class="numbered">Double-click on the <a id="_idIndexMarker137"/>node to enter its <a id="_idIndexMarker138"/>configuration window. Since we don't want to bombard the same user with multiple emails, we should keep one entry per email address, removing all rows having a duplicate address. Hence, from the configuration window, we move all columns to the left and we keep only <code class="Code-In-Text--PACKT-">__Email_Entered</code> on the right. We click on OK and run the node (<em class="keyStroke">F7</em>). </li>
				<li class="numbered">Our curiosity makes it impossible to refrain from checking whether this node has worked well. So, we have a look at the data appearing on its output port (right-click and the last icon with the magnifying lens or <em class="keyStroke">Shift + F6</em>) and we notice that a couple of rows having duplicated email addresses were removed as expected.<p class="normal">We can now proceed to fix the formatting of names and surnames. To do so, we will start using a very versatile node for working on textual data called String Manipulation.</p></li></ol>


<h2 id="_idParaDest-37" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor036"/><img src="image/B17125_02_22.png" alt=""/> <em class="bold-italic">String Manipulation</em></h2><p class="normal">This node (<strong class="screenText">Manipulation &gt; Column &gt; Convert &amp; Replace</strong>) applies transformations to strings, making it possible to <a id="_idIndexMarker139"/>reformat textual <a id="_idIndexMarker140"/>data as needed. The node includes a large set of pre-built functions for text manipulation, such as replacement, capitalization, and concatenation, among others:</p><figure class="mediaobject"><img src="image/B17125_02_23.png" alt=""/></figure><p class="packt_figref">Figure 2.17: String Manipulation: build your text transformation selecting functions and columns to use</p><p class="normal">The configuration window provides several panels:</p>
<ol type="A">
<li class="alphabetic-l2">The <strong class="screenText">Expression</strong> box is used to specify the overall formula that implements the desired transformation. In most cases, you can build the expression by just using your mouse, clicking on the functions to use and on the columns upon which to apply them.</li>
<li class="alphabetic-l2">The <strong class="screenText">Function</strong> list includes all available transformations. For instance, the function <code class="Code-In-Text--PACKT-">upperCase()</code> will convert a string in all-capital letters. When you double-click on a function here, it will get added to your expression.</li>
<li class="alphabetic-l2">The <strong class="screenText">Description</strong> box is a handy source of help, showing a description and some examples for each available function as soon as you select it from the list.</li><li class="alphabetic-l2">The <strong class="screenText">Column List</strong> will show you all available columns in the table. By double-clicking on them, you add them to the expression: they will show with a dollar sign character (<code class="Code-In-Text--PACKT-">$</code>) on either side to indicate a column.</li>
<li class="alphabetic-l2">At the bottom, you find a radio button to decide where to store your result. You can either <strong class="screenText">Append</strong> it as a new column or <strong class="screenText">Replace</strong> an existing one.</li></ol>

			<p class="normal"><em class="italic">Table 2.1</em> summarizes the <a id="_idIndexMarker141"/>most useful <a id="_idIndexMarker142"/>functions available within this node.</p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Function</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Description</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Example</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Result</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">strip</strong>(<em class="italic">x</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Removes any whitespace from the beginning and the end of a string.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">strip("  Hi! ")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"Hi!"</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">upperCase</strong>(<em class="italic">x</em>),</p>
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">lowerCase</strong>(<em class="italic">x</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Converts all characters to upper or lower case.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">upperCase("Leonardo")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"LEONARDO"</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">capitalize</strong>(<em class="italic">x</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Converts first letters of all words in a string to upper case.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">capitalize("bill kiddo")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"Bill Kiddo"</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">compare</strong>(<em class="italic">x</em>,<em class="italic">y</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Compares two strings and returns 0 if they are equal and -1 or 1 if they differ, depending on their alphabetical sorting.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">compare("Budd","Budd")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">0</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">replace</strong>(<em class="italic">x</em>,<em class="italic">y</em>,<em class="italic">z</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Replaces all occurrences of substring y within x with z.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">replace("cool goose","oo","u")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"cul guse"</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">removeChars</strong>(<em class="italic">x</em>,<em class="italic">y</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Removes from string x all characters included in y.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">removeChars("No vowels!","aeiou")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"N wwls!"</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">join</strong>(<em class="italic">x</em>,<em class="italic">y</em>,...)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Concatenates any number of strings in a single string.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">join("Hi ","the","re")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"Hi there"</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><strong class="keyword">length</strong>(<em class="italic">x</em>)</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Counts the number of characters in a string.</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">length("Analytics is for everyone!")</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">26</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 2.1: Useful functions within String Manipulation</p>
			<p class="normal">This node is perfect for our needs as we have a few strings to manipulate. We need to fix the capitalization of names and surnames, remove those bad-looking whitespaces, and create a new column with the full name:</p>
			<ol>
				<li class="numbered" value="7">Let's implement the String Manipulation node, dragging it from the repository and connecting the output of the previous node with the input of this new one. Double-click on the <a id="_idIndexMarker143"/>node and its <a id="_idIndexMarker144"/>configuration dialog appears. Let's start with the column <code class="Code-In-Text--PACKT-">First name</code>. We want to see a nice upper-case character at the beginning of every word and we also require whitespaces to be stripped from both ends of the string. Let's build the expression by double-clicking first on <code class="Code-In-Text--PACKT-">capitalize()</code> and <code class="Code-In-Text--PACKT-">strip()</code> from the <strong class="screenText">Function</strong> box and then on <code class="Code-In-Text--PACKT-">First name</code> from the <strong class="screenText">Column list</strong>. By clicking in this order, we should have obtained the expression <code class="Code-In-Text--PACKT-">capitalize(strip($First name$))</code>, which is exactly what we wanted. In this case, we want to substitute the raw version of the first name with the result of this expression, so we need to select <strong class="screenText">Replace column</strong> and then <code class="Code-In-Text--PACKT-">First name</code>. We are all set so we can click on <strong class="screenText">OK</strong> and close the window.</li>
				<li class="numbered">Now we want to repeat the same for the surname. We'll use another String Manipulation node for it. To make it faster we can also copy and paste the icon of the node from the Workflow Editor, with the usual <em class="keyStroke">Ctrl</em> + <em class="keyStroke">C</em> and <em class="keyStroke">Ctrl</em> + <em class="keyStroke">V</em> key combinations. We need to repeat the configuration described in the previous step: the only difference is that now we apply it to column <code class="Code-In-Text--PACKT-">Surname</code> instead of <code class="Code-In-Text--PACKT-">First name</code>. Just make sure that both the expression and the <strong class="screenText">Replace column</strong> setting refer to <code class="Code-In-Text--PACKT-">Surname</code> this time.</li>
				<li class="numbered">Both parts of the name look fine now as they show no extra spaces and boast good-looking capitalization. As required by our business case, we need to create a new column carrying the full name of each user, combining first name and surname. Once again, we <a id="_idIndexMarker145"/>can use the String Manipulation node for this: let's get one more node of these in <a id="_idIndexMarker146"/>the Workflow Editor, make the connection, and open the configuration page. This time, we need to concatenate two strings so we can leverage the <code class="Code-In-Text--PACKT-">join()</code> function. Let's double-click first on <code class="Code-In-Text--PACKT-">join()</code> from the <strong class="screenText">Function</strong> box and then on <code class="Code-In-Text--PACKT-">First name</code> from the <strong class="screenText">Column list</strong>. Since we want names and surnames to be separated by a blank space, we need to add this character on the expression, by typing the sequence <code class="Code-In-Text--PACKT-">," ", </code>in the expression box just after <code class="Code-In-Text--PACKT-">$First name$</code>. We complete the expression by double-clicking on the column <code class="Code-In-Text--PACKT-">Surname</code> and we are done. The overall expression should be: <code class="Code-In-Text--PACKT-">join($First name$," ",$Surname$)</code>. Before closing, we need to decide where to store the result. This time we want to create a new column so we select <strong class="screenText">Append</strong> and then type the name of the new column, which could be Full name. Click on <strong class="screenText">OK</strong> and check the results.<div id="_idContainer050" class="note"><p class="Information-Box--PACKT-">Since in the end, we are going to keep only the <code class="Code-In-Text--PACKT-">Full name</code> column, we could have combined the last three nodes in a single one. In fact, <code class="Code-In-Text--PACKT-">Full name</code> can be created at once with the expression: <code class="Code-In-Text--PACKT-">join(capitalize(strip($First name$))," ",capitalize(strip($Surname$)))</code>.</p><p class="Information-Box-Within-Bullet--PACKT-">We took the longer route to get some practice with the node. It's up to you to decide which version to keep in your workflow.</p></div><p class="normal">With all names fixed, we can move on to the next hurdle and remove the ill-formatted email addresses. It's time to introduce a new node that will be ubiquitous in our future KNIME workflows: Row Filter.</p>
</li>
</ol>

<h2 id="_idParaDest-38" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor037"/><img src="image/B17125_02_24.png" alt=""/> <em class="bold-italic">Row Filter</em></h2><p class="normal">This node (<strong class="screenText">Manipulation &gt; Row &gt; Filter</strong>) applies filters <a id="_idIndexMarker147"/>on rows according <a id="_idIndexMarker148"/>to the criteria you specify. Such criteria can either be based on values of a specific column to test (like <em class="italic">all strings starting with A</em> or <em class="italic">all numbers greater than 5.2</em>) or on the position of the row in the table (for instance <em class="italic">only the top 20 rows</em>). To configure the node, you need to first specify the type of criteria you would like to apply using the selector on the left. You also need to specify if those rows that match your criteria should be kept in your workflow (<strong class="screenText">Include rows...</strong>) or should be dropped, keeping all others (<strong class="screenText">Exclude rows...</strong>). You have multiple ways to specify the criteria behind your filtering:</p><ul><li class="bullet">Filter by <strong class="keyword">attribute value</strong>: In this case, you will be presented on the right with the full list of columns available so that you can pick the one to consider for the filtering (<strong class="screenText">Column to test</strong>). Once you pick the column, you need to describe the logic for the selection in the box below (<strong class="screenText">Matching criteria</strong>). You have three options:</li><li class="bullet">The first one (<strong class="screenText">use pattern matching</strong>) will check if the value (considered as a string) adheres to the pattern you specify in the textbox. You can enter a specific value like <code class="Code-In-Text--PACKT-">maria</code>: this will match rows like "MARIA" or "Maria," unless you check the <strong class="screenText">case sensitive match</strong> option, which would consider the lower and upper cases as different. Another option is to use wild cards in your search pattern (remember to tick <strong class="screenText">contains wild cards</strong>): in this case, the star character <code class="Code-In-Text--PACKT-">"*"</code> will stand for any sequence of characters (so <code class="Code-In-Text--PACKT-">"M*"</code> selects all names starting with <code class="Code-In-Text--PACKT-">"M"</code> like "Mary" and "Mario") while the question mark <code class="Code-In-Text--PACKT-">"?"</code> will match any single character (<code class="Code-In-Text--PACKT-">"H?"</code> refers to any string of two characters starting with "H," so it will include "Hi" and exclude "Hello"). If you want to implement more complex searches, you could also use the <a id="_idIndexMarker149"/>powerful <strong class="keyword">Regular Expressions</strong> (<strong class="keyword">RegEx</strong>), which offer great flexibility in setting criteria.</li><li class="bullet">The second one (<strong class="screenText">use range checking</strong>) is great with numbers as it lets you set any kind of interval: you can specify a lower bound (including all numbers that are greater or equal than that) or an upper bound (lower or equal) or both (making it a closed interval).</li>
</ul>
			<div>
				<div id="_idContainer052" class="packt_tip">
					<p class="Tip--PACKT-">Remember that bounds are always considered as included in the interval. If you want to exclude the endpoint of an interval, you need to reverse the logic of your filtering. For instance, if you want to include all non-zero, positive numbers you need to select the option <strong class="screenText">Exclude rows by attribute value</strong> and set <code class="Code-In-Text--PACKT-">0</code> as the upper bound.</p>
				</div>
			</div>
			<ul>
				<li class="bullet">The third option is to match only the rows that have a missing value in the column under test. </li>
				<li class="bullet">Filter by <strong class="keyword">row number</strong>: This way you can specify which is the first and the last row to match, considering the current sorting order in the table. So if you put <code class="Code-In-Text--PACKT-">1</code> in the <strong class="screenText">First row number</strong> selector and then <code class="Code-In-Text--PACKT-">1</code> in <strong class="screenText">Last row number</strong>, you will match only the top 10 rows of the table. If you want to match only the rows after a certain position, like from the 100th onwards, you can set the threshold in the first selector (<code class="Code-In-Text--PACKT-">100</code>) and tick the check box below (<strong class="screenText">to the end of the table</strong>).</li>
				<li class="bullet">Filter by <strong class="keyword">row ID</strong>: You <a id="_idIndexMarker150"/>could test row IDs against <a id="_idIndexMarker151"/>some regular expressions as well, although this route is rarely used:<figure class="mediaobject"><img src="image/B17125_02_25.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure></li>
			</ul>
			<p class="packt_figref">Figure 2.18: Configuration dialog for Row Filter: specify which rows to keep or remove from your table</p>
			<div>
				<div id="_idContainer054" class="packt_tip">
					<p class="Tip--PACKT-">If your filtering criteria require several columns to be tested, you can use multiple instances of this node in a series, each time looking at a different column. An alternative is to use a <a id="_idIndexMarker152"/>different node called Rule-based Row Filter, which lets you define several rules for filtering at once. Other nodes, such <a id="_idIndexMarker153"/>as <strong class="keyword">Row Filter (Labs)</strong> and <strong class="keyword">Rule-based Row Filter (Dictionary)</strong>, can do <a id="_idIndexMarker154"/>more sophisticated filtering if needed. Check them out if you need to.</p>
				</div>
			</div>
			<p class="normal">Let's see our new node in action straight away as we filter out all the email addresses that do not look valid:</p>
			<ol>
				<li class="numbered" value="10">Implement the <strong class="keyword">Row Filter</strong> node, connect it downstream, and open its configuration <a id="_idIndexMarker155"/>dialog by double-clicking on it. Since <a id="_idIndexMarker156"/>we want to keep only the rows matching certain column criteria, let's select the first option from the radio button on the left (<strong class="screenText">Include rows by attribute value</strong>) and, on the right, pick the column with the email address <code class="Code-In-Text--PACKT-">__Email_Entered</code>. One simple pattern we can use for checking the validity of an email address is the wild card expression <code class="Code-In-Text--PACKT-">*@*.*</code>. This will check for all strings that have at least an <code class="Code-In-Text--PACKT-">@</code> symbol followed by a dot . with some text in between. This is not going to be the most thorough validity check for email addresses, but it will certainly spot the ones that are clearly irregular and is good enough for us at this stage. Remember to tick the <strong class="screenText">contains wild cards</strong> checkbox and click <strong class="screenText">OK</strong> to move on.</li>
				<li class="numbered">We have yet more filtering to be done. We want to remove all rows displaying a negative credit: those users are inactive and should not be added to our mailing list. Let's implement an additional Row Filter node and put it next to the previous one, creating the right connections across the ports. We will again use the <strong class="screenText">Include rows by attribute value</strong> option but the matching criteria will be set as range checking (second radio button on the right). By setting <code class="Code-In-Text--PACKT-">0</code> as <strong class="screenText">Lower bound</strong>, we are good to go since all negative values will be filtered out. We can click <strong class="screenText">OK</strong> and move on to the next challenge.<p class="normal">At this point, we want to manage the little red question marks appearing here and there in the table, signaling that some values are missing. Also, in this case, KNIME offers a powerful node to manage this situation quickly, with a couple of clicks.</p>
</li>
</ol>

<h2 id="_idParaDest-39" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor038"/><img src="image/B17125_02_26.png" alt=""/> <em class="bold-italic">Missing Value</em></h2><p class="normal">The node (<strong class="screenText">Manipulation &gt; Column &gt; Transform</strong>) handles missing values (<code class="Code-In-Text--PACKT-">NULLs</code>) in a table, offering <a id="_idIndexMarker157"/>multiple methods for imputing the best <a id="_idIndexMarker158"/>available replacement. In the first tab of the configuration window (<strong class="screenText">Default</strong>), you can define a default treatment option for all columns of a certain data type (<code class="Code-In-Text--PACKT-">strings</code>, <code class="Code-In-Text--PACKT-">integer</code>, and <code class="Code-In-Text--PACKT-">double</code>) by selecting it in the dropdown menus. The second tab (<strong class="screenText">Column settings</strong>) allows you to set a specific strategy for each individual column by double-clicking on the name of the column from the list on the left and setting the strategy through the menu that will appear.</p><div id="_idContainer056" class="packt_tip"><p class="Tip--PACKT-">Unless you have a large number of columns that you want to treat with the same missing value strategy, it's best to be explicit and use the second tab. That way you only impute missing values for the precise columns specified.</p></div><p class="Tip--PACKT-">You have a vast list of possible methods to treat your missing values. The most useful ones are:</p><ul><li class="bullet"><strong class="keyword">Remove Row</strong>: Gets rid of the row altogether if the value is missing.</li><li class="bullet"><strong class="keyword">Fix Value</strong>: Replaces the NULL with a specific value you have to enter in the box that will appear below. All rows with missing values will get the same fix replacement.</li><li class="bullet"><strong class="keyword">Minimum</strong>/<strong class="keyword">Maximum</strong>/<strong class="keyword">Mean</strong>/<strong class="keyword">Median</strong>/<strong class="keyword">Most Frequent Value</strong>: Calculates a summary statistic on the distribution over all existing values in the column and uses it as a fixed replacement value.
</li>
			</ul>
				<div id="_idContainer057" class="packt_tip">
					<p class="Tip--PACKT-">If you substitute missing values with the median of a numeric column, your imputed values are going to stick "in the middle" of the existing distribution, making your inference less disruptive and more robust. Of course, this will depend on your business cases and on the actual distribution of data, but it's worth giving this approach a try.</p>
				</div>
			<ul>
			
				<li class="bullet"><strong class="keyword">Previous/Next</strong>: Replaces the missing value with the previous or the next non-missing value in the column, using the current order of rows in the table.</li>
				<li class="bullet"><strong class="keyword">Linear Interpolation</strong>: Substitutes missing values with the linear interpolation between the previous and the next non-missing values in the column. If your column represents values changing over time (we call them time series), this handler might offer a smooth way to fill the gaps.</li>
				<li class="bullet"><strong class="keyword">Moving Average</strong>: Substitutes the missing values with a moving average calculated over a certain number of non-missing values appearing in the table just before the missing value (<strong class="screenText">lookbehind window</strong>) or after it (<strong class="screenText">lookahead window</strong>). For instance, if you have for a column a sequence of values such as [2, 3, 4, NULL] and you apply a lookbehind window of size 2, the NULL value will be substituted for 3.5, which is the average of 3 and 4. For this and the previous handlers, you want to make sure your table is properly sorted (like, in a time series, by increasing time).<figure class="mediaobject"><img src="image/B17125_02_27.png" alt="Graphical user interface&#10;&#10;Description automatically generated"/></figure></li>
			</ul>
			<p class="packt_figref">Figure 2.19: Configuration of Missing Value: decide how to manage the empty spots of your table</p>
			<p class="normal">Going back to our case, we <a id="_idIndexMarker159"/>noticed that we have <a id="_idIndexMarker160"/>two columns displaying some question marks. Let's manage them appropriately by leveraging the Missing Value node:</p>
			<ol>
				<li class="numbered" value="12">Drag the Missing Value node on your workflow and connect it properly. Let's jump straight to the second tab of its configuration window (<strong class="screenText">Column settings</strong>), as we want to keep control of which handling strategy we shall adopt for each column in need. For column <code class="Code-In-Text--PACKT-">Age</code> (double-click on it from the list on the left), we can select <strong class="screenText">Median</strong>: by doing so, we will assign an age to those users missing one that is not "far off" the age that most users tend to have in our table. When it comes to the number of times users have logged in (<code class="Code-In-Text--PACKT-">Logins</code> column) we assume that the lack of a value means that they haven't logged in yet. So the best strategy to select will be <strong class="screenText">Fix Value</strong>, keeping 0 as a default value for all. We can click on OK and close this dialog.</li>
				<li class="numbered">Let's check how our chain of transformations is looking at the minute. If we click on the last node, execute it (<em class="keyStroke">F7</em>), and check its output port view (<em class="keyStroke">Shift</em> + <em class="keyStroke">F6</em>), we can breathe a sigh of relief: no missing values, no negative credits, and both names and email addresses look reasonably formatted.<p class="normal">The only steps left ahead of us are of an aesthetic nature: we want to drop the columns we don't need, sort the ones remaining, and give them a more intuitive name, before finally saving the output file. We are <a id="_idIndexMarker161"/>going to need a <a id="_idIndexMarker162"/>few more nodes to complete this last bit.</p>
</li>
</ol>

<h2 id="_idParaDest-40" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor039"/><img src="image/B17125_02_28.png" alt=""/> <em class="bold-italic">Column Filter</em></h2><p class="normal">This node (<strong class="screenText">Manipulation &gt; Column &gt; Filter</strong>) drops <a id="_idIndexMarker163"/>unneeded columns in a table. The only <a id="_idIndexMarker164"/>required step for its configuration is to select which columns to keep at the output port (the green box on the right) and which ones to filter out (the red box on the left):</p><figure class="mediaobject"><img src="image/B17125_02_29.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.20: Configuration of Column Filter: which columns would you like to keep?</p>
<ol>
				<li class="numbered" value="14">Add the Column Filter node to the <a id="_idIndexMarker165"/>workflow and exclude <a id="_idIndexMarker166"/>the columns we no longer need (<code class="Code-In-Text--PACKT-">First Name</code>, <code class="Code-In-Text--PACKT-">Surname</code>, and <code class="Code-In-Text--PACKT-">IP_Address</code>) by moving them onto the left panel.</li>
</ol>

<h2 id="_idParaDest-41" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor040"/><img src="image/B17125_02_30.png" alt=""/> <em class="bold-italic">Column Rename</em></h2><p class="normal">The node lets you change the <a id="_idIndexMarker167"/>names and the data <a id="_idIndexMarker168"/>types of columns. To configure it, double-click on the columns you would like to edit (you'll find a list on the left) and tick the <strong class="screenText">Change</strong> box: you will then be able to enter the new names in the box beside. To change the data type of a column and convert all its values, you can use the drop-down menu on the right. The menu will be prepopulated with a list of possible data types each column can be safely converted into:</p><figure class="mediaobject"><img src="image/B17125_02_31.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.21: Configuration of Column Rename: pick the best names for your columns</p>

<ol>
				<li class="numbered" value="15">We can now <a id="_idIndexMarker169"/>use the Column Rename node to <a id="_idIndexMarker170"/>change the headers in our table. The only ones that need some makeup are <code class="Code-In-Text--PACKT-">__Email_Entered</code>, which can become simply <code class="Code-In-Text--PACKT-">Email</code>, and <code class="Code-In-Text--PACKT-">_Credit</code>, which can be renamed to <code class="Code-In-Text--PACKT-">Credit</code>.
</li>
</ol>


<h2 id="_idParaDest-42" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor041"/><img src="image/B17125_02_32.png" alt=""/> <em class="bold-italic">Column Resorter</em></h2><p class="normal">This node (available in <strong class="screenText">Manipulation &gt; Column &gt; Transform</strong>) changes the order of columns in a table. In the <a id="_idIndexMarker171"/>configuration window, you <a id="_idIndexMarker172"/>will find, on the left, all columns available at the input port, and on the right, a series of buttons to move them around. Select the column you wish to move across and then click on the different buttons to move columns up or down, place columns first or last in the table, or sort them in alphabetical order. If different columns appear at the input port (imagine the case where your source file is coming in with some new columns), they will be placed where the <strong class="screenText">&lt;any unknown new column&gt;</strong> placeholder lies:</p><figure class="mediaobject"><img src="image/B17125_02_33.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.22: Configuration of Column Resorter: shuffle your columns to the desired order</p>

<ol>
				<li class="numbered" value="16">The last transformation <a id="_idIndexMarker173"/>required is to <a id="_idIndexMarker174"/>slightly change the order of columns in the table. In fact, the <strong class="screenText">Full name</strong> column was added earlier in the process and ended up appearing as the last column while we would like it to be the first. Just select the column and click on <strong class="screenText">Move First</strong> to fix it as needed.
</li>
</ol>

<h2 id="_idParaDest-43" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor042"/><img src="image/B17125_02_34.png" alt=""/> <em class="bold-italic">CSV Writer</em></h2><p class="normal">This node (<strong class="screenText">IO &gt; Write</strong>) saves the <a id="_idIndexMarker175"/>input data table into a <a id="_idIndexMarker176"/>CSV file on the local disk or to a remote location. The only required configuration step is to specify the full path of the file to create: you can click on the <strong class="screenText">Browse...</strong> button to select the desired folder. The other configuration steps (not required) let you: change the format of the resulting CSV file like column delimiters (<strong class="screenText">Format</strong> section), keep or remove headers as the first row (<strong class="screenText">Write column header</strong>), and compress the newly generated file in <code class="Code-In-Text--PACKT-">.gzip</code> format to save space on disk (go to the <strong class="screenText">Advanced Settings </strong>tab for this):</p><figure class="mediaobject"><img src="image/B17125_02_35.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.23: Configuration of CSV Writer: save your table as a text file</p>

<ol>
				<li class="numbered" value="17">The very last step of our process is to save our good-looking table as a CSV file. We implement the CSV Writer node, connect it, and do the only piece of required configuration, which is to specify where to save the new file and how to name it. Click <strong class="screenText">OK</strong> to close the window and execute the node to finally write the file on your disk.</li>
			</ol>
			<p class="normal">Well done for <a id="_idIndexMarker177"/>completing your second data workflow! The <a id="_idIndexMarker178"/>routine required for building a clean mailing list out of a messy raw dataset required a dozen nodes and some of our time, but the effort was certainly worth it. Now we can clean up any number of records whenever we like by just re-running the same workflow, making sure that the name of the input file and its path stay the same. To do so, you will just need to: reset the workflow (right-click on the name of the workflow in the Explorer on the left and then click on <strong class="screenText">Reset</strong> or just reset the first node pressing <em class="keyStroke">F8</em> after having selected it), and execute it again (the simplest way is to just press <em class="keyStroke">Shift</em> + <em class="keyStroke">F7</em> on your <a id="_idIndexMarker179"/>keyboard or execute <a id="_idIndexMarker180"/>the last node with a right-click and select <strong class="screenText">Execute</strong>):</p>
			<figure class="mediaobject"><img src="image/B17125_02_36.png" alt=""/></figure>
			<p class="packt_figref">Figure 2.24: The full data cleaning workflow: twelve nodes to make our user data spotless</p>
			<h1 id="_idParaDest-44" class="title"><a id="_idTextAnchor043"/>Summary</h1>
			<p class="normal">This chapter introduced us to KNIME, the new addition to our data analytics toolbox. We learned what KNIME is in a nutshell and got started with its user interface, which enables us to combine simple computation units (nodes) into more complex analytical routines (workflows) with speed and agility, without having to write extensive code. We got started with the ever-present preliminary steps of any data work: loading and cleaning up data to make it usable for doing analytics. We got acquainted with twelve basic nodes in KNIME that empowered us to create repeatable routines, which include: opening files in different formats, sorting and filtering data following some logic, manipulating strings, and managing missing values and duplicate rows. Not bad for being just on the second chapter!</p>
			<p class="normal">Having the basics clearly explained, we can now dare to go further with KNIME. In the next chapter, <em class="chapterRef">Chapter 3</em>, <em class="italic">Transforming Data</em>, we will learn how to work on multiple data tables and to build more complex data workflows for analyzing real-world data feeds.</p>
		</div>
	</body></html>