<html><head></head><body>
		<div id="_idContainer128">
			<h1 class="chapterNumber">3</h1>
			<h1 id="_idParaDest-45" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor044"/>Transforming Data</h1>
			<p class="normal">Now that we have the basics of KNIME at hand, we can move to the next level. In this chapter, we will learn how to transform data to make the best out of it systematically. The following pages will show how to work with multiple tables, aggregate data points, apply expressions, and iterate through your workflows to automating their execution. All these new skills will make you an autonomous user of KNIME when manipulating real-world data.</p>
			<p class="normal">This chapter will answer the following questions:</p>
			<ul>
				<li class="bullet">What is a data model, and how can I visualize it?</li>
				<li class="bullet">How can I combine several data tables?</li>
				<li class="bullet">How can I aggregate data points and calculate formulas?</li>
				<li class="bullet">How can KNIME automate the creation of summary reports? </li>
				<li class="bullet">What do variables and loops look like in KNIME?</li>
			</ul>
			<p class="normal">This chapter will end with a full tutorial based on real data and a very realistic business case: it will be an opportunity to put into practice all you've learned so far about KNIME while confronting the complexity of data you will face in your work. Before diving into the concrete ways to transform data, let's invest a few minutes in the fundamentals of relational databases and data models.</p>
			<h1 id="_idParaDest-46" class="title"><a id="_idTextAnchor045"/>Modeling your data</h1>
			<p class="normal">Data tables <a id="_idIndexMarker181"/>are hardly useful when they lie apart. In fact, by organizing them together in a database, we amplify their overall value as we unveil patterns and connections across data points. That is why data is typically stored in an ensemble of different tables connected with each other to virtually form a single <a id="_idIndexMarker182"/>body called a <strong class="keyword">Data Model</strong>. When you work with multiple tables, it is beneficial to "visualize" what the underlying data model looks like: this gives you the ability to anticipate ways to leverage the data and interpret it correctly.</p>
			<p class="normal">We shall bring the concept of a data model to life by going through a business example. Let's imagine that we own a small store selling musical instruments. Our business model is pretty simple: we order instruments from manufacturers and store them in a warehouse. Customers call at our shop and get the chance to try a few instruments before deciding whether to purchase or not. Our most loyal customers sign up and get a membership card: occasionally, they receive a newsletter with new arrivals and special offers.</p>
			<p class="normal">To manage our store's activities, we use a simple information system that keeps track of products, sales, inventory, and customers. Data is organized in a simple database, made of four different tables, each having multiple columns, whose names are—fortunately—self-explanatory:</p>
			<ul>
				<li class="bullet"><strong class="keyword">Product Master Data</strong>: This stores<a id="_idIndexMarker183"/> the list of products we buy and sell. For each product, we have a unique <em class="italic">Product_ID</em>, a <em class="italic">Category </em>(like Guitars, Violins, and Pianos), a short <em class="italic">Description</em> (which includes the model of the instrument), the <em class="italic">Brand</em>, and the <em class="italic">List_price</em>.</li>
				<li class="bullet"><strong class="keyword">Sales Transactions</strong>: This records all sales. Every row includes the <em class="italic">Date</em> of purchase, the <em class="italic">Receipt_ID</em> (counting the number of receipts created during each day), the <em class="italic">Product_ID</em>, the <em class="italic">Quantity</em> (number of items purchased), the <em class="italic">Discount_rate</em> that was applied (if any), the overall <em class="italic">Amount </em>paid, and—if the customers are members of our loyalty card program—their <em class="italic">Customer_ID</em>. </li>
				<li class="bullet"><strong class="keyword">Customer Master Data</strong>: This carries preferences and contact details related to our loyalty card members. It includes the unique <em class="italic">Customer_ID</em>, <em class="italic">Full_Name</em>, <em class="italic">ZIP_Code</em> of where they live, <em class="italic">Email_Address</em>, <em class="italic">Telephone </em>number, and their primary <em class="italic">Instrument</em>.</li>
				<li class="bullet"><strong class="keyword">Inventory Transactions</strong>: This accounts for all product movements in our warehouse, such as the loading of the items as they arrive and transferring them to the shop floor. Its columns are <em class="italic">Date</em> (which includes the time when it happened), <em class="italic">Product_ID</em>, and <em class="italic">Quantity </em>(this will be positive when items are loaded in and negative when they leave the warehouse).</li>
			</ul>
			<p class="normal">By looking at this simple example, we can observe a few features that are worth elaborating on as they apply to most databases we would encounter in our work:</p>
			<ul>
				<li class="bullet">We see two different types<a id="_idIndexMarker184"/> of tables fulfilling two different needs: <strong class="keyword">Master Data </strong>and <strong class="keyword">Transactional</strong> tables. Master <a id="_idIndexMarker185"/>data tables aim at describing entities of business relevance, such as products, customers, suppliers, employees, and so on. In these kinds of tables, each row corresponds to an instance of the entity (for example, a specific product, or an individual customer), while every column describes a different aspect of the entity (like its name or description). On the other hand, transactional tables record events (like a monetary transaction, a sale, an order) occurring at a specific point in time. Every row corresponds to an event, while columns describe the event's features and the entities that took part in it. Master data and transactional data tend to be updated and used in different fashions: master data tables are touched more rarely than transactional tables. Think about the frequency of adding a new product to the catalog or hiring an employee: these events occur much less often than regular sales or inventory movements do.</li>
				<li class="bullet">The tables are clearly connected to each other. In fact, many of their columns represent the same thing. For instance, <em class="italic">Product_ID</em>s of sold items are the same <em class="italic">Product_ID</em>s we find in<a id="_idIndexMarker186"/> the product master data. The two tables are related<a id="_idIndexMarker187"/> and, indeed, databases of this kind—omnipresent in firms—are called <strong class="keyword">Relational Databases</strong>. The columns used to connect multiple tables are<a id="_idIndexMarker188"/> called <strong class="keyword">Keys</strong>: when the rows of two tables have matching values in their keys, it means that these rows are connected and refer to the same event or entity. This means that all rows in the sales transactional table having a specific value in the column <em class="italic">Product_ID</em> (let's say <em class="italic">PS012</em>) refer to sales of the same product. Thanks to the relationship occurring across the tables, you can then find the product's description by looking up the value of <em class="italic">Product_ID</em> in the product master data (where you will find that <em class="italic">PS012</em> refers to—in this case—a <em class="italic">Steinway piano</em>).</li>
			</ul>
			<p class="normal">A simple and effective way of describing the underlying data model of a relational database is through<a id="_idIndexMarker189"/> the <strong class="keyword">Entity-Relationship</strong> (<strong class="keyword">ER</strong>) <strong class="keyword">Diagram</strong>. The ER diagram looks like a series of boxes connected with each other: each box is a table and displays its columns while the connections show the existing relationships across keys. <em class="italic">Figure 3.1</em> represents a simplified rendering of the ER diagram of our music store database: keys are highlighted with a bold font and a little icon:</p>
			<figure class="mediaobject"><img src="image/B17125_03_01.png" alt=""/></figure>
			<p class="packt_figref">Figure 3.1: The Entity-Relationship diagram of the music store database</p>
			<p class="normal">We will encounter diagrams of this kind throughout this book. I suggest you make the effort to sketch the<a id="_idIndexMarker190"/> ER diagrams of those tables you use at work the most, as it will simplify your thinking on how to best leverage them. In fact, mapping all the data available in the various systems of a firm is a tough but worthwhile exercise.</p>
			<p class="normal">Keeping this mapping up to date and—in general—managing data assets in a firm requires discipline and a set <a id="_idIndexMarker191"/>of formal roles, processes, and standards called <strong class="keyword">Data Governance</strong>. A good (and often underestimated) practice of data governance is, indeed, to create a <strong class="keyword">Data Inventory</strong>: this <a id="_idIndexMarker192"/>is a systematic description of all information assets in a company. As you build an inventory, you are forced to map master data and transactional tables correctly, spotting duplications and missing keys.</p>
			<div>
				<div id="_idContainer070" class="note">
					<p class="Information-Box--PACKT-">A data inventory includes information about the data stored in tables, such as content, source, owners, and licensing: these are all examples of <strong class="keyword">Metadata</strong>, a word that literally means "data about data."</p>
				</div>
			</div>
			<h1 id="_idParaDest-47" class="title"><a id="_idTextAnchor046"/>Combining tables</h1>
			<p class="normal">Data models<a id="_idIndexMarker193"/> show us how data points within separate tables are logically connected with each other. In the practice of data analytics, we often need to combine data together by leveraging the logic relationships which the data model describes. The most common operation for combining two tables into a third one is called <strong class="keyword">Join</strong>. By combining<a id="_idIndexMarker194"/> two tables together, we cross-enrich them as we merge all the information we have on a specific event or entity. The join operation will take the two tables and match the rows that have the same values in the columns we specify (<strong class="keyword">Matching Columns</strong>). Let's imagine we have the following two tables, which refer to sales transactions and to<a id="_idIndexMarker195"/> the product master data:</p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="3">
							<p class="Table-Column-Heading--PACKT-">Sales</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1499</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.1: Sales table</p>
			<table id="table002-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="2">
							<p class="Table-Column-Heading--PACKT-">Products</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.2: Products table</p>
			<p class="normal">What if we need to calculate the overall sales generated by each product category? The first table tells us the amount of sales for each transaction but misses the category information so we cannot aggregate those sales accordingly. The second table has the category bit but doesn't tell us anything about sales. Each table is missing something, so we need to combine them by means of a join. The good news is that the two tables share a column (<em class="italic">Product</em>), which could serve for doing the matching. Let's join them together using <em class="italic">Product</em> as a matching column:</p>
			<table id="table003" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="4">
							<p class="Table-Column-Heading--PACKT-">Join of the two tables above</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">449</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.3: Joining the Products table and the Sales table</p>
			<p class="normal">See what happens? By joining the two tables, we obtain a third one as an output where we have, for each transaction, not only the product name, date, and amount (which would only be available in the first table) but also the category of each product (which is only available in the second table). This table can now be used for calculating how much sales are generated by each product category by just running the right aggregations (which we'll learn how to do in a few pages).</p>
			<p class="normal">To complete our introduction to joins, let's consider one last aspect. Even if two tables have some columns in common (which could be leveraged for our matching), they will not necessarily have a correspondence between every row of their own and a row in the other table. In the earlier example, we might have, for instance, some transactions that refer to instruments not included in the product master data (maybe they are new arrivals and haven't been<a id="_idIndexMarker196"/> categorized yet) or the other way around (products available in the master data that haven't sold yet). If we combine tables without a perfect matching of the rows, the output might carry some blanks (the famous NULL values we met in the previous chapter) since we don't have a corresponding value to use. Depending on our strategy to manage such missing matches (and the resulting incomplete rows in the output), we can implement different types of joins. Let's imagine that we want to join the following two tables (by convention, the two tables combined in a join operation <a id="_idIndexMarker197"/>are<a id="_idIndexMarker198"/> called <strong class="keyword">Left</strong> and <strong class="keyword">Right</strong> table, hence the name of the headers in the following tables):</p>
			<table id="table004" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="3">
							<p class="Table-Column-Heading--PACKT-">Left table: Sales</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Korg B2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">499</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1274</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Didgeridoo Black 2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">459</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.4: Left table</p>
			<table id="table005" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="2">
							<p class="Table-Column-Heading--PACKT-">Right table: Products</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Korg B2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Steinway B-211</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">American Jazz-5</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Basses</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.5: Right table</p>
			<p class="normal">Notice that some products have no corresponding matches in the other table, as the following Venn<a id="_idIndexMarker199"/> diagram intuitively displays:</p>
			<figure class="mediaobject"><img src="image/B17125_03_02.png" alt="Diagram, venn diagram&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.2: Venn diagram of Sales and Product tables: not all instruments are present in both tables</p>
			<p class="normal">Depending on how we prefer to manage the "non-matching" rows in the resulting output table, we have four different<a id="_idIndexMarker200"/> types of joins:</p>
			<ul>
				<li class="bullet"><strong class="keyword">Inner Join</strong>: In this case, we <a id="_idIndexMarker201"/>only keep the rows with a match in both tables. We focus on the intersection of the keys across the two columns. By doing so, we avoid generating any NULL value due to non-matching keys. On the other side, we might be neglecting some rows which—even if incomplete—carry some valuable information, like sales of products not yet categorized.</li>
				<li class="bullet"><strong class="keyword">Left Outer Join</strong>: This <a id="_idIndexMarker202"/>type of join will keep all the rows existing in the left table, even those that have no match in the right table. In this way, we might incur some NULL values in the output, but we "preserve" the information stored in the left table.</li>
				<li class="bullet"><strong class="keyword">Right Outer Join</strong>: This one <a id="_idIndexMarker203"/>is just the opposite of the previous one and will preserve all the rows in the right table, including the ones without a match in the left one.</li>
				<li class="bullet"><strong class="keyword">Full Outer Join</strong>: We <a id="_idIndexMarker204"/>go for this option when we cannot afford to lose anything! All rows in the two tables will be kept, even if they don't have a match. This is the option that could potentially create most NULL values: it's the price to pay to conserve all data.<figure class="mediaobject"><img src="image/B17125_03_03.png" alt=""/></figure></li>
			</ul>
			<p class="packt_figref">Figure 3.3: The four types of join: decide which rows you want to keep in the output</p>
			<p class="normal">In <em class="italic">Table 3.6</em>, you will <a id="_idIndexMarker205"/>find the results of applying the four types of joins: the NULL values are displayed as a question mark, as you would find in KNIME. The Inner Join has no NULL values, as anticipated:</p>
			<table id="table006" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="4">
							<p class="Table-Column-Heading--PACKT-">Inner Join</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Korg B2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1274</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.6: Inner Join</p>
			<p class="normal">In the Left Outer Join, we will have a row referring to the Didgeridoo sales, even if it is yet uncategorized. What probably happened with this peculiar Aboriginal instrument is that it is a new shiny arrival that attracted the attention of a customer quickly, before we had the time to <a id="_idIndexMarker206"/>update the product master table by adding it:</p>
			<table id="table007" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="4">
							<p class="Table-Column-Heading--PACKT-">Left Outer Join</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Korg B2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Didgeridoo Black 2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">459</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.7: Left Outer Join</p>
			<p class="normal">In the Right Outer Join, we are also forcing a row for those instruments that, given their price, have not sold yet. This view can be beneficial to discover products that might require some more advertisement in our next newsletters:</p>
			<table id="table008" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="4">
							<p class="Table-Column-Heading--PACKT-">Right Outer Join</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Korg B2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Steinway B-211</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">American Jazz-5</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Basses</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.8: Right Outer Join</p>
			<p class="normal">The Full Outer Join will contain not only the products that never sold but also the ones that haven't been categorized yet. Creating such a table can help us summarize sales by category and spot <a id="_idIndexMarker207"/>uncategorized and unsold products all at once:</p>
			<table id="table009" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="4">
							<p class="Table-Column-Heading--PACKT-">Full Outer Join</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Product</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Amount</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Gibson Explorer B-2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1040</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Korg B2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Yamaha YDP-164</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Piano</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Squier Affinity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Didgeridoo Black 2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">22-Dec</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">459</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Steinway B-211</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">American Jazz-5</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">?</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Basses</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.9: Full Outer Join</p>
			<p class="normal">As this simple example unveiled for us, there might be value in any type of join. As data practitioners, we want to know what options we have available so that we can select which one to use, depending on the business case we face.</p>
			<p class="normal">To perform joins in KNIME, we can leverage a very useful node which is called—unsurprisingly, we shall admit—<strong class="keyword">Joiner</strong>.</p>
			<h2 id="_idParaDest-48" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor047"/><img src="image/NEW-Joiner_node.png" alt=""/> <em class="bold-italic">Joiner</em></h2>
			<p class="normal">The node (available in <strong class="screenText">Manipulation &gt; Column &gt; Split &amp; Combine</strong>) joins the two tables connected at its input ports according to the user-provided matching criteria. To con-figure it (<em class="italic">Figure 3.4</em>), you first need to specify the criteria for the join by choosing the couple of columns in the two tables that are related and should match. To add the first couple of columns, click on the button labeled <strong class="screenText">Add matching criterion</strong>. You will find two drop-down menus with the available columns of the tables connected with the upper and the lower input ports (by convention, they refer, to the <strong class="screenText">left </strong>and the <strong class="screenText">right</strong> tables of the join operation, respectively). You can add or remove columns to be matched by clicking on the + and the – buttons on the right. By default, all the couples of columns you enter here need to have matching values for rows to be matched. They also need to be of the same type (integers matching with integers, string match-ing with strings, and so on).</p>
			<div>
				<div id="_idContainer074" class="packt_tip">
					<p class="Tip--PACKT-">To solve unmatching data types, the node allows you to convert the data types of the columns before assessing the matching criteria. For example, from the selector labeled as <strong class="screenText">Compare value in join columns by</strong>, you can pick <strong class="screenText">string representation</strong> to convert all values to strings before checking if they match. </p>
				</div>
			</div>
			<p class="normal">After clarifying the matching criteria, you need to decide the type of join operation you would like to perform (<strong class="screenText">Inner</strong>, <strong class="screenText">Left outer</strong>,<strong class="screenText"> Right outer</strong>, or<strong class="screenText"> Full outer</strong>). To do so, use the Venn diagrams you find in <em class="italic">Figure 3.3</em> as a guide. If you want an inner join, only the <strong class="screenText">Matching rows</strong> box needs to stay selected. For the left or right outer joins, you have to tick also the Left or the <strong class="screenText">Right unmatched rows</strong>, respectively. For the full outer, all box-es should be selected. As you noticed from its icon, the node has three outputs. The first output port on the top carries the result of the join. You can also decide to review the rows that did not find any match in the other table and place them in the second and third output ports. If you are interested in viewing the unmatched rows as well (it might be useful sometimes to understand why not all rows match), you need to tick the <strong class="screenText">Route unmatched rows to separate ports</strong> box: this will activate the second and third ports which would—otherwise—stay inactive and marked with a red cross. </p>
			<p class="normal">One last option that you would select in most cases is <strong class="screenText">Merge joining columns</strong>: by doing so, you keep only one "copy" of the pair of columns used to assess the matching. If you leave it unticked, you will keep both the two columns which were coming from the left and the right input tables: in most cases you don't want that so this box should be al-ways selected.</p>
			<figure class="mediaobject"><img src="image/B17125_03_04.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.4: Configuration dialog of Joiner: select which columns should match</p>
			<p class="normal">In the second tab of the configuration dialog (<strong class="screenText">Column Selection</strong>), you can specify which columns resulting from the join operation should be kept at the output port of the node. This might be handy when you know you will not need some of the columns in the subsequent steps of your workflow: in this case, just go through the columns in the boxes on the right and double-click on the ones to remove:</p>
			<figure class="mediaobject"><img src="image/B17125_03_05.png" alt="Graphical user interface&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.5: Configuration dialog of Joiner: select which columns should match</p>
			<div>
				<div id="_idContainer077" class="note">
					<p class="Information-Box--PACKT-">For those of you <a id="_idIndexMarker208"/>using Microsoft Excel, you will notice that you can implement a Left Outer Join in Excel with functions such as <code class="Code-In-Text--PACKT-">vlookup()</code>. By using KNIME instead of Excel, you can run all types of join (not just the left outer) and easily define matching criteria on multiple columns (which in Excel would require some workarounds).</p>
				</div>
			</div>
			<p class="normal">For completeness, there are a couple of other ways to combine tables beyond the join operator. If you don't need to take care of any matching criteria and you just want to "stitch together" tables that have the same size in one dimension, you can:</p>
			<ul>
				<li class="bullet">Append columns across two tables that have the same number of rows. You will obtain the columns of the first table just beside the second table columns, in whatever order they have in the original table. You can do so in KNIME by using the <strong class="keyword">Column</strong> <strong class="keyword">Appender</strong> node.</li>
				<li class="bullet">Concatenate rows of two tables having the same columns, putting the rows of the first table on top of the ones coming from the second table. The node for this is<a id="_idIndexMarker209"/> called just <strong class="keyword">Concatenate</strong>.</li>
			</ul>
			<p class="normal"><em class="italic">Figure 3.6</em> give you an idea of how these two nodes would work:</p>
			<figure class="mediaobject"><img src="image/B17125_03_06.png" alt=""/></figure>
			<p class="packt_figref">Figure 3.6: Combining tables without matching criteria: you can append columns or concatenate rows with these two nodes</p>
			<p class="normal">Now we are clear on the many ways available to us to combine several tables into one. Let's move to the other omnipresent data transformation need: aggregating values to create summary views of a table.</p>
			<h1 id="_idParaDest-49" class="title"><a id="_idTextAnchor048"/>Aggregating values</h1>
			<p class="normal">The information<a id="_idIndexMarker210"/> contained in a raw data table lies dispersed across all its rows. Often, we need to condense a large table into a smaller and more readable one where its values get aggregated or summarized following a given logic. For instance, if we have a table including all orders received in the last year and want to make sense of our sales' evolution over time, we might prefer to calculate a simpler table that shows the total number of orders generated every month. Instead of having a long table with as many rows as orders, we prefer scanning through its aggregation showing only twelve rows, one for each month.</p>
			<p class="normal">The simpler way of aggregating<a id="_idIndexMarker211"/> data is by using a rather popular database operation called <strong class="keyword">Group By</strong>: it combines rows in various groups and aggregates their values within each group. To perform a Group By, you will need to decide two things:</p>
			<ul>
				<li class="bullet">First, you must declare which columns define a <strong class="keyword">group</strong>. All the rows showing the same values in the columns defining the group will be combined together into a single row in the output. Let's take <em class="italic">Table 3.6</em> as an example. If you defined our group using column <em class="italic">Category</em>, the result of the Group By will have only two rows: one with the total sales of guitars and the other one with the total sales of pianos. You can define groups by multiple columns: in this case, you will get an aggregated row for each combination of unique values in the group columns. For example, if you selected both <em class="italic">Date</em> and <em class="italic">Category</em> as group definition, you will obtain multiple output rows for each category, one for each different day of sales.</li>
				<li class="bullet">Second, you need to <a id="_idIndexMarker212"/>decide how to summarize rows across, meaning which <strong class="keyword">aggregation function</strong> to use. For instance, you could simply count all rows appearing in a group, summing up their values or calculating their average. In the case of the sales summary table, we decided to count the number of sales transactions, but we could have calculated the overall income generated each month by using the sum as an aggregation function instead.</li>
			</ul>
			<p class="normal">It's time to see the Group By operation in action on our music store example. Let's use as input the result of the Inner Join in <em class="italic">Table 3.6</em>. We want to summarize our sales by product category, calculating the income generated by each category and the number of items sold in total:</p>
			<table id="table010" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="3">
							<p class="Table-Column-Heading--PACKT-">Sales, group by Category</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Sales</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Quantity</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1538</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">3</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1773</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">2</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.10: Summary of sales by category</p>
			<p class="normal">As we would expect, the <a id="_idIndexMarker213"/>resulting table has just two rows, one for each category present in the original table. Let's meet the node that can perform aggregation of this kind in KNIME.</p>
			<h2 id="_idParaDest-50" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor049"/><img src="image/image015.png" alt=""/> <em class="bold-italic">GroupBy</em></h2>
			<p class="normal">This node (<strong class="screenText">Manipulation &gt; Row &gt; Transform</strong>) aggregates rows of a table by groups, defined by means of <a id="_idIndexMarker214"/>a subset of columns. Its basic <a id="_idIndexMarker215"/>configuration requires two steps. In the <strong class="screenText">Groups </strong>panel, you need to select which columns define the groups by moving them to the list on the right, bordered in green. You can choose multiple columns: the output table will have one row for each unique combination of different values in all of the columns you specify here. If you don't select a column, you will aggregate all rows at the input into one single grand total row at the output:</p>
			<figure class="mediaobject"><img src="image/B17125_03_07.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.7: Group settings for a Group By: decide what columns define a group</p>
			<p class="normal">The second step is to declare which columns should be summarized and using which aggregation function. You can define the columns to aggregate upon by double-clicking on their name from the left list. Then, you can specify the aggregation function by selecting it from the drop-down menu under <strong class="screenText">Aggregation</strong>. You can select the same column multiple times and aggregate it with different functions. In the drop-down menu at the bottom (<strong class="screenText">Column naming</strong>), you can specify the naming convention to be used for the aggregate <a id="_idIndexMarker216"/>columns. The default option is <strong class="screenText">Aggregation method (column name)</strong>, which<a id="_idIndexMarker217"/> will create headers like <em class="italic">Sum(Quantity)</em>:</p>
			<figure class="mediaobject"><img src="image/B17125_03_08.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.8: Aggregation settings for a Group By: decide how to summarize your rows within each group</p>
			<p class="normal">In <em class="italic">Table 3.11</em>, you find the most popular functions you can use for summarizing your rows within each group. For some of these functions, like Count or First, you need to decide whether to consider NULLs as values like all others or ignore them. If you want them to be ignored (focusing the aggregation on actual values only), tick the <strong class="screenText">Missing </strong>checkbox on the right:</p>
			<table id="table011" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Aggregation Function</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Description</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Sum</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Sums all values in a group, returning the total.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Count/Unique Count</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Counts all rows within each group. Unique Count ignores duplicates and counts only distinct values.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Mean/Median</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Calculates averages and the median value within each group.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Mode</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Takes the value with the highest number of occurrences in a group.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">First/Last</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Takes the first/last value appearing in each group, depending on their sorting when input. Make sure you sort rows accordingly before.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Minimum/Maximum</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Takes the minimum and the maximum values within the group.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Concatenate/Unique Concatenate</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Joins all values in a single string, using the delimiter indicated in the text box at the bottom. Unique Concatenate ignores duplicates.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Correlation</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Calculates correlation with another column (you can select it by clicking on the <strong class="screenText">Edit</strong> button), across elements of each group. </p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.11: Summarizing functions</p>
			<p class="normal">Another way of aggregating <a id="_idIndexMarker218"/>data is by using the <strong class="keyword">Pivot </strong>operation. While <a id="_idIndexMarker219"/>the Group By groups up being rows in the output table, with this operation, we can "rotate" some groups (that we call pivots) to appear vertically, as columns, in the output table. You can think of a pivot as a 2-dimensional matrix showing aggregations across horizontal groups (which will ultimately appear as rows of the pivot) and pivoted vertical groups (appearing as columns in the output matrix). </p>
			<p class="normal">Let's see the Pivot operation in use on our music store example. Starting again from the Inner Join result, we would like to summarize our sales in a single table showing sums for each combination of categories (horizontal groups) and dates (vertical groups, or pivots):</p>
			<table id="table012" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="5">
							<p class="Table-Column-Heading--PACKT-">Sales, pivot by Category and Dates</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Date</p>
						</td>
						<td class="No-Table-Style" colspan="2">
							<p class="Table-Column-Heading--PACKT-">21-Dec</p>
						</td>
						<td class="No-Table-Style" colspan="2">
							<p class="Table-Column-Heading--PACKT-">22-Dec</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Category</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Sales</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Quantity</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Sales</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Heading--PACKT-">Quantity</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Guitars</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1289</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">2</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">249</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">Pianos</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">499</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1274</p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Column-Content--PACKT-">1</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="packt_figref">Table 3.12: Sales pivot by category and dates</p>
			<p class="normal">The resulting pivot table has two rows, one for each of the categories (like with Group By), and multiple columns showing the aggregations for each available date. In KNIME, we can use the <strong class="keyword">Pivoting</strong> node to create such summaries.</p>
			<h2 id="_idParaDest-51" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor050"/><img src="image/image021.png" alt=""/> <em class="bold-italic">Pivoting</em></h2>
			<p class="normal">This node (<strong class="screenText">Manipulation &gt; Row &gt; Transform</strong>) aggregates values by creating a pivot table. Its configuration<a id="_idIndexMarker220"/> dialog is similar to that of <strong class="keyword">GroupBy</strong>, but contains<a id="_idIndexMarker221"/> an additional <strong class="screenText">Pivots</strong> panel, as the following shows:</p>
			<ul>
				<li class="bullet">In the <strong class="screenText">Groups </strong>panel, you specify the input columns that define the horizontal groups, which will show as rows in the output pivot table. </li>
				<li class="bullet">In the <strong class="screenText">Pivots </strong>panel, you specify instead which input columns to use for creating the vertical groups, appearing as columns in the resulting table.</li>
				<li class="bullet">Finally, in the <strong class="screenText">Aggregation</strong> panel, you can select the input columns to summarize and the aggregation method to use.</li>
			</ul>
			<p class="normal">Similar to what we have seen for the <strong class="keyword">GroupBy</strong> node, the two drop-down menus at the bottom (<strong class="screenText">Column name</strong> and <strong class="screenText">Aggregation name</strong>) can be used to specify the naming convention for the columns of the resulting pivot. By default, you will have headers concatenating the name of each pivot with the aggregation method, like <em class="italic">21-Dec+Sum(Amount)</em>:</p>
			<figure class="mediaobject"><img src="image/B17125_03_09.png" alt="Graphical user interface, application, email&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.9: Pivot setting: select the columns to use for the vertical groups (pivots)</p>
			<p class="normal">The <strong class="keyword">Pivoting</strong> node has<a id="_idIndexMarker222"/> not one but three output ports: you can<a id="_idIndexMarker223"/> view them by selecting one of the last three magnifying lens icons at the bottom of the pop-up menu after right-clicking on the node. The first output is the pivot matrix (most of the time, you will only need this one), the second one is the total aggregation of the horizontal groups only (pivots are ignored), while the third one is the grand total across all rows of the pivot (groups are ignored).</p>
			<div>
				<div id="_idContainer084" class="note">
					<p class="Information-Box--PACKT-">The concept of pivot tables has been popularized in Microsoft Excel. Knowing how to build a pivot in KNIME, you now have access to a broader range of aggregation methods, and you will be able to make the pivot operation part of a more extended, automated workflow of steps, removing all manual interventions such as refreshes and copy/paste.</p>
				</div>
			</div>
			<p class="normal">In some cases, you want to run the reverse<a id="_idIndexMarker224"/> operation, called <strong class="keyword">Unpivoting</strong>: this will place the columns of a table to appear as multiple rows in the output table. If you want to perform this transformation in KNIME, check out the <strong class="keyword">Unpivoting</strong> node.</p>
			<p class="normal">In <em class="italic">Figure 3.10</em>, you see a summary of the three table aggregations and disaggregation methods we have seen:</p>
			<figure class="mediaobject"><img src="image/B17125_03_10.png" alt=""/></figure>
			<p class="packt_figref">Figure 3.10: Transforming tables by aggregating and disaggregating: a summary of the most useful operations</p>
			<p class="normal">Combining tables and <a id="_idIndexMarker225"/>aggregating values are the fundamental <a id="_idIndexMarker226"/>data transformations you can do. Let's see them in action in a full tutorial, which will be an opportunity to learn a few more tricks about KNIME, like calculating formulas, visualizing data, and using loops and variables.</p>
			<h1 id="_idParaDest-52" class="title"><a id="_idTextAnchor051"/>Tutorial: Sales report automation</h1>
			<p class="normal">In this tutorial, you will<a id="_idIndexMarker227"/> impersonate the role of a business analyst working for a UK-based online retailer, selling all-occasion gifts. You are intrigued by data analytics and are reading a few (good) books about its potential. You have set for yourself the ambition of progressively amplifying the role of data analytics in the company by leveraging your new skills. You decide to start from something relatively simple: automate and improve the reporting of sales data. By doing so, you want to make a quick and visible impact and instill an <em class="italic">appetite</em> for more advanced analytics in your colleagues and managers, unlocking interest and investments.</p>
			<p class="normal">The company you work for has grown quickly and didn't have the opportunity to adopt a sustainable business intelligence solution. The regular reporting is managed manually using Excel. The poor finance analyst responsible for it pulls data from the company website every Friday and, after a couple of hours of boring manual steps, sends an email with the latest status. Due to the manual nature of the activity, the reports are prone to human error, and almost every week this causes several <em class="italic">back and forth</em> emails, which leave no time for identifying business-meaningful patterns in the data and creating real value. You empathize with the finance analyst and decide to set aside a few hours to automate the full reporting process in KNIME.</p>
			<p class="normal">First of all, you manage to retrieve a list of the most important business questions people ask about sales <a id="_idIndexMarker228"/>evolution. This initial list will be a good base for your initial endeavor:</p>
			<ol>
				<li class="numbered">What are the top ten products in our assortment, meaning the ones that generate the most significant number of sales?</li>
				<li class="numbered">What are the top three products within each subcategory?</li>
				<li class="numbered">To which country do we sell the most?</li>
				<li class="numbered">During the current calendar year to date, how much revenue was generated within each product category?</li>
				<li class="numbered">What's the relative footprint of each category out of the total portfolio of products for the current year?</li>
				<li class="numbered">In which months should we expect a peak in sales for our seasonal categories?</li>
			</ol>
			<p class="normal">You decide that your first automated report shall include a tabular view answering the first five business questions appearing above. For the last one, since the seasonal behavior of the business is not going to change significantly on a weekly basis, it will be enough to build a chart that depicts the patterns of sales by month as a one-off exercise. Having defined the minimum set of deliverables that your work should cover, you are ready to go to the next step and assess what data is required to make it happen.</p>
			<div>
				<div id="_idContainer086" class="packt_tip">
					<p class="Tip--PACKT-">Always start any data work by clarifying the business questions you are after. Many analytics initiatives fail because there is a lack of understanding of what the ultimate objective looks like. Make sure you always "visualize" what you want to obtain from your data analytics capabilities and how you expect it to practically affect your business. If possible, put it in writing, as we just did with the six questions above.</p>
				</div>
			</div>
			<p class="normal">With the help of the finance analyst (who is already getting very excited about your initiative), you retrieve the latest data required for the regular sales reporting and discover that it is scattered across three different tables.</p>
			<ul>
				<li class="bullet"><strong class="keyword">Product Master Data</strong>: This includes a unique alphanumeric code (column <em class="italic">StockCode</em>), which serves<a id="_idIndexMarker229"/> as a product ID, a short <em class="italic">Description</em>, and two columns to locate each item within the two-level product hierarchy used in the company, namely <em class="italic">Category</em> and <em class="italic">Subcategory</em>. For example, within the category "Stationery," we find the subcategories "Notebooks" and "Stickers," while within "Home," we have "Clocks" and "Furniture."</li>
				<li class="bullet"><strong class="keyword">Customer Master Data</strong>: For each customer who has signed up to the website, it includes an identifier (<em class="italic">Customer_ID</em>) and the <em class="italic">Country </em>of residence.</li>
				<li class="bullet"><strong class="keyword">Sales Transactions</strong>: This is the biggest table as it records all sales. For every invoice (identified with column <em class="italic">Invoice_ID</em>), this table can host multiple rows, one for each product (described through its <em class="italic">StockCode</em>) included within the transaction. For each row, we also have the number of purchased items (<em class="italic">Quantity</em>), the unit <em class="italic">Price</em>, the <em class="italic">Customer_ID</em> (which can be empty, if the customer hasn't signed up), and a string describing the date and time of the purchase (<em class="italic">Invoice_time</em>).</li>
			</ul>
			<p class="normal">The product and customer master data tables are available in two text files<strong class="keyword"> </strong>(named<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">productMD.csv</code> and<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">customerMD.csv</code>) extracted from the order<strong class="keyword"> </strong>management system. Transactions are stored, instead, in two separate Excel files<strong class="keyword"> </strong>(<code class="Code-In-Text--PACKT-">TransactionL3M.xlsx</code><strong class="keyword"> </strong>and<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">TransactionsHistory.xlsx</code>): the first one contains only the most recent sales, covering the latest three months of transactions, while the second one has the remainder of the transactions' history:</p>
			<figure class="mediaobject"><img src="image/B17125_03_11.png" alt=""/></figure>
			<p class="packt_figref">Figure 3.11: An Entity-Relationship diagram of the online retailer database</p>
			<p class="normal">We now have enough knowledge to get started: should we realize we need more info on the data and the business needs, we can always go back to our finance analyst and ask for extra help. By looking at the list of business questions, we notice that we will need to aggregate our transactions using fields (such as <em class="italic">Category</em><strong class="keyword">, </strong><em class="italic">Country</em>),<strong class="keyword"> </strong>which<strong class="keyword"> are </strong>in different master data tables, so we will need to load all of them and combine them. Let's open KNIME, create a new workflow (<strong class="screenText">File </strong>| <strong class="screenText">New...</strong> and <strong class="screenText">New KNIME Workflow</strong>), and begin to build it.</p>
			<ol>
				<li class="numbered" value="1">As a first step, we load the transactional data, which is contained in two separate Excel files. Let's start from the history, dragging<strong class="keyword"> </strong><code class="Code-In-Text--PACKT-">TransactionsHistory.xlsx</code><strong class="keyword"> </strong>on the blank workflow or implementing the <strong class="keyword">Excel Reader</strong> node. In the configuration window, we notice that the preview includes all the columns<a id="_idIndexMarker230"/> we anticipated being there, so we can close it, leaving the options unchanged. We repeat the same for the other file (<code class="Code-In-Text--PACKT-">TransactionsL3M.xlsx</code>) and run both nodes.<p class="normal">The two tables we have loaded so far refer to transactions and share exactly the same columns. We can combine them and stack one on top of the other by using the <strong class="keyword">Concatenate</strong> node.</p>
</li>
</ol>


<h2 id="_idParaDest-53" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor052"/><img src="image/image029.png" alt=""/> <em class="bold-italic">Concatenate</em></h2><p class="normal">The node (<strong class="screenText">Manipulation &gt; Row &gt; Transform</strong>) concatenates<a id="_idIndexMarker231"/> two tables by adding the rows of the <a id="_idIndexMarker232"/>second table at the bottom of the rows of the first table. The node will combine the columns if they have the same header. You can use its configuration window to decide how to handle the columns that do not appear in both input tables. By default, all columns will be kept (the <strong class="screenText">Use union of columns</strong> option from the <strong class="screenText">Column handling </strong>section): this means that, if a column only exists in one table, it will show in the output as NULL values for all the rows coming from the other table. If instead, you go for the alternative option (<strong class="screenText">Use intersection of columns</strong>), all non-matching columns will be discarded at the output:</p><figure class="mediaobject"><img src="image/B17125_03_12.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.12: Configuration window of the Concatenate node: choose how to manage duplicate and non-matching columns</p>
<ol>
				<li class="numbered" value="2">We can combine<a id="_idIndexMarker233"/> the two transaction <a id="_idIndexMarker234"/>tables and connect the outputs of the two <strong class="keyword">Excel Readers</strong> as inputs to a <strong class="keyword">Concatenate</strong> node. Since the two input tables share precisely the same columns (having identical names), we don't need to care about the configuration of the node and stick with its default behavior. As we run the node, we obtain at the output the full <strong class="keyword">Sales Transactions</strong> table with more than 600,000 rows.</li>
				<li class="numbered">Let's now load the <strong class="keyword">Customer Master Data</strong> table, stored in the <code class="Code-In-Text--PACKT-">customerMD.csv</code><strong class="keyword"> </strong>file. We can either drag and drop the file on the editor or implement a <strong class="keyword">CSV Reader</strong> node and configure it by specifying the file's path. Double-check in the configuration window that the node has rightly captured the column delimiter (in this case, a semicolon): you can always click on <strong class="screenText">Autodetect format</strong> to get KNIME to guess it.</li>
				<li class="numbered">We can now combine the sales table with the customer master data to enrich each transaction with the information on the <em class="italic">Country</em> where it was generated. Let's connect the outputs of the <strong class="keyword">Concatenate</strong> and <strong class="keyword">CSV Reader</strong> nodes as inputs to a <strong class="keyword">Joiner</strong> node. By double-clicking on the latter, we can configure it. First, we need to set the conditions for matching rows. We click on the <strong class="screenText">Add matching criterion</strong> button and select <em class="italic">Customer_ID</em> from both tables. The second configuration step is to specify the type of join to make. We want to maintain all transactions (left table) even if they don't have a corresponding match on the customer master data (right table), so we decide to go for a left outer join. In fact, our colleague (who is starting to admire our agility in KNIME) confirms that, although not all customers are included in the customer master data, we should consider transactions coming from all product sales. To obtain a left outer join, we need to tick both the <strong class="screenText">Matching rows</strong> and the <strong class="screenText">Left unmatched rows</strong>. The Left outer join title on top of the white and yellow Venn diagram confirms that we did well. The last configuration step is to select <strong class="screenText">Merge joining columns</strong> option so that we don't carry two copies of the <em class="italic">Customer_ID</em> columns.<p class="normal">When we close the configuration window and run the node, we notice that none of the rows got matched: in fact, the output table has got null values (the '<strong class="screenText">?</strong>' cells) in all rows. by reopening the configuration of the Joiner (<em class="chapterRef">Figure 3.13</em>) we realize what happened: the <em class="italic">Customer_ID</em> columns in the two tables we are joining refer to the same attribute but have a different data type (string in transactions and integer in the customer master data). These things happen: given the different formats of the files carrying the tables, data types might have been interpreted differently.</p>
</li>
</ol>

<figure class="mediaobject"><img src="image/B17125_03_13.png" alt="Graphical user interface&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.13: Non-matching joining columns: same content but different data types</p>

<h2 id="_idParaDest-54" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor053"/><img src="image/image035.png" alt=""/> <em class="bold-italic">Number To String</em></h2><p class="normal">This <a id="_idIndexMarker235"/>node (<strong class="screenText">Manipulation &gt; Column &gt; Convert &amp; Replace</strong>) converts <a id="_idIndexMarker236"/>numeric columns (like integers and decimal numbers) intro strings of text. Its configuration is trivial: you just need to select which numeric columns should be converted by keeping or removing them from the right selection panel:</p><figure class="mediaobject"><img src="image/B17125_03_14.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.14: Number To String configuration: which numbers do you want to convert into text?</p>
<ol>
				<li class="numbered" value="5">To convert the <em class="italic">Customer_ID</em> column from the master data into a string, we add a <strong class="keyword">Number To String</strong> node between <strong class="keyword">CSV Reader</strong> and <strong class="keyword">Joiner</strong>. The fastest way to do that is to drag the node from the repository and, by clicking the mouse button pressed, drop it on the connector which already exists between the two nodes (which will turn red when selected). We can now execute the <strong class="keyword">Joiner</strong> node and notice that at its output (<em class="italic">Shift</em>+<em class="italic">F6</em> to open the view) we do not have any more NULL value. Instead, we read all transactions, enriched with an additional column (<em class="italic">Country</em>) at the right end, which is exactly what we were aiming at.</li>
				<li class="numbered">It's now time to load the <strong class="keyword">Product Master Data</strong> table by loading the <code class="Code-In-Text--PACKT-">productMD.csv</code> file through the usual CSV Reader node. </li>
				<li class="numbered">We can now add an additional <strong class="keyword">Joiner</strong> downstream: the first input port should be connected with the first output of the previous <strong class="keyword">Joiner's</strong> node while the second port should get the product master data from the latest <strong class="keyword">CSV Reader</strong>. In its configuration, we first select <em class="italic">StockCode</em> as matching columns from both the left and right tables: the data types nicely match so no conversion is needed. This time we want to run an inner join because we don't want to carry sales from products that are not included in the product master data as they would not belong to any product category, making the reporting less readable. Thus, in the <strong class="keyword">Joiner's</strong> configuration window, we only keep the <strong class="screenText">Matching rows</strong> box selected. Lastly, tick the <strong class="screenText">Merge joining columns</strong> box so that we don't carry two copies of the <em class="italic">StockCode</em> column. When we execute the node, we obtain a table indicating for each row the description of the product being sold and its classification within the hierarchy.
</li>
</ol>


<p class="normal">All the data has now been loaded and combined in a single table: we can proceed in preparing this table, generating the reports we need. We notice that all the business questions require aggregating sales in terms of generated income, while our table displays <em class="italic">Quantity</em> and <em class="italic">Price</em> for each line item in an invoice. To calculate the resulting income generated by<a id="_idIndexMarker237"/> each transaction, we need to <a id="_idIndexMarker238"/>implement a simple mathematical formula, which is what the next node is all about.</p>

<h2 id="_idParaDest-55" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor054"/><img src="image/image039.png" alt=""/> <em class="bold-italic">Math Formula</em></h2>
<p class="normal">This <a id="_idIndexMarker239"/>node (<strong class="screenText">Manipulation &gt; Column &gt; Convert &amp; Replace</strong>) evaluates<a id="_idIndexMarker240"/> an expression for each row of a table, returning its result in a given column. The configuration dialog looks very familiar: indeed, it is structured in the same <a id="_idIndexMarker241"/>way as for the <strong class="keyword">String Manipulation</strong> node we met in <em class="italic">Chapter 2</em>, <em class="chapterRef">Getting Started with KNIME</em>. The only difference is that here, you can use functions working on numbers, like <code class="Code-In-Text--PACKT-">ceil()</code> or <code class="Code-In-Text--PACKT-">floor()</code> to round up or down a decimal number to the nearest integer or <code class="Code-In-Text--PACKT-">sqrt()</code> to calculate the square root. You find all the available functions in the list in the middle and, by selecting them, you will read their description and an example appearing in the text box on the right.</p><p class="normal">The easiest way to build an expression is to double-click on the available columns on the right (only the numeric ones will show up) and create your expression using the central text box. In here, you can add all math operators you need, like <code class="Code-In-Text--PACKT-">+</code>, <code class="codeHighlighted">-</code>, <code class="codeHighlighted">*</code>, <code class="codeHighlighted">/</code>, and parentheses. The result of the expression for each row will be saved either in a new column (<strong class="screenText">Append Column</strong>) or will substitute the content of an existing one (<strong class="screenText">Replace Column</strong>), as you can select with the radio button at the bottom:</p><figure class="mediaobject"><img src="image/B17125_03_15.png" alt=""/></figure><p class="packt_figref">Figure 3.15: Math Formula dialog: build your numeric expression by combining the columns you need</p>
<ol>
				<li class="numbered" value="8">To calculate the revenues generated by each transaction, we implement a Math Formula and create a connection between this and the previous node (the <strong class="keyword">Joiner's</strong> upper output port). In the configuration window, we build the expression: <code class="Code-In-Text--PACKT-">$Quantity$*$Price$</code>, select the option Append Column and give it the name <code class="Code-In-Text--PACKT-">Sales</code>.<p class="normal">By looking at the resulting table, we observe a couple of opportunities for cleaning it up. First, we notice that the column <em class="italic">Country</em> has some missing values because some customers were missing in the master data. We should substitute it with the default value we use when a country is missing, which is the <code class="Code-In-Text--PACKT-">Unspecified</code> string. Second, we find the category "Others" doesn't refer to actual product sales as it describes additional fees (like postage and bank commissions) and manual adjustments. The finance analyst confirms that all sales generated within "Others" should be excluded from any reporting.</p></li>
				<li class="numbered">To manage the missing countries, add the <strong class="keyword">Missing</strong> <strong class="keyword">Value</strong> node and configure it by using its second tab (<strong class="screenText">Column Settings</strong>). Double-click on the column <em class="italic">Country</em>, which you find on the left, and select <strong class="screenText">Fix Value </strong>in the dropdown that appears. Then, type <code class="Code-In-Text--PACKT-">Unspecified</code> in the text box and click on <strong class="screenText">OK</strong> to close the window.</li>
				<li class="numbered">To remove the rows referring to the "Others" category, we can use a <strong class="keyword">Row Filter</strong> node. To configure it, select <strong class="screenText">Exclude rows by attribute value</strong> on the right, then <em class="italic">Category</em> in the <strong class="screenText">Column to test</strong> selector<a id="_idIndexMarker242"/> and, lastly, "Others" from the <strong class="screenText">use pattern matching </strong>drop-down<a id="_idIndexMarker243"/> menu:<figure class="mediaobject"><img src="image/B17125_03_16.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.16: Row Filter dialog: exclude the rows having a specific value in a given column</p><p class="normal">Having the table cleaned up (you should by now have 672,104 rows and 11 columns at the output port of the last node), we are finally able to generate the tables that answer each of our business questions. The first one asks for a list of the products that have generated the most significant amount of sales. At this point, the sales related to a product are scattered across multiple rows, one for each invoice that included the product. Hence, we will need to aggregate sales by product.</p></li>
				<li class="numbered">To obtain the total sales generated by each product, we implement a <strong class="keyword">GroupBy</strong> node. In the configuration window, we select the columns that define the unique groups at the output. Since we want to have one row for each product and we also want to carry in the report the columns that describe it, in the <strong class="screenText">Groups</strong> tab, we select the columns <em class="italic">StockCode</em>, <em class="italic">Description</em>, <em class="italic">Category</em>, and <em class="italic">Subcategory</em>, making sure they all end up in the green-bordered list on the right. The <strong class="keyword">GroupBy</strong> node will create a row for each combination of values in the group columns but, since we know that for each <em class="italic">StockCode</em>, we have one single <em class="italic">Description</em>, <em class="italic">Category</em>, and <em class="italic">Subcategory</em>, we can safely keep all of them in the group description, to keep them in our output table, which will result in them being more informative. In the <strong class="screenText">Manual Aggregation</strong> tab, we double-click on the columns <em class="italic">Sales</em> and <em class="italic">Quantity</em> and <a id="_idIndexMarker244"/>specify for <a id="_idIndexMarker245"/>both of them the option <strong class="screenText">Sum</strong> as <strong class="screenText">Aggregation function</strong>. To make our report more readable and avoid bulky column names, we select <strong class="screenText">Keep original name(s)</strong> in the bottom dropdown labeled as <strong class="screenText">Column naming</strong>. We can then click on <strong class="screenText">OK</strong> and move to the next step. </li>
				<li class="numbered">Since we want to show only the products generating the most sales, we need to sort the table by decreasing <em class="italic">Sales</em>, using the <strong class="keyword">Sorter</strong> node. After implementing the node and making a connection with the previous one, we can select <em class="italic">Sales</em> in the drop-down menu and pick the <strong class="screenText">Descending</strong> order.</li>
				<li class="numbered">The last step for answering this business question is to limit our ranked list of products to the top ten entries. <a id="_idTextAnchor055"/>Using the <strong class="keyword">Row</strong> <strong class="keyword">Filter</strong> node, we <strong class="screenText">select Include rows by number</strong> on the left and then input <code class="Code-In-Text--PACKT-">1</code> as <strong class="screenText">First</strong> <strong class="screenText">row</strong> <strong class="screenText">number</strong> and <code class="Code-In-Text--PACKT-">10</code> as <strong class="screenText">Last row number</strong>.
</li>
</ol>

<p class="normal">After executing the last node and checking the resulting table, we are positively impressed as the screen displays the ten biggest selling products. This positive intermediate result encourages us to move ahead in our challenge:</p><figure class="mediaobject"><img src="image/B17125_03_17.png" alt="Graphical user interface, table&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.17: Top ten products by sales: who would have thought that a cake stand could make so much money?</p><p class="normal">The next question asks us to report the top-selling products within each subcategory. Similar to what we already did for the previous question, we apply a filter to the products list, keeping only the ones appearing on top of the sorted list. However, this time, we need to repeat the filtering multiple times, once for each subcategory.</p><p class="normal">In KNIME, you can <em class="italic">repeat</em> the execution of a portion of a workflow by creating a <strong class="keyword">Loop</strong>. Implementing a loop in KNIME is quite simple: you have a set of start and end loop nodes (you find them in <strong class="screenText">Workflow Control &gt; Loop Support</strong>), which you can use to define the segment of the workflow to be repeated (the <strong class="keyword">Loop Body</strong>). Depending on the type of <strong class="keyword">Loop</strong> <strong class="keyword">Start</strong> node you<a id="_idIndexMarker246"/> pick, you can decide the logic to follow for the repetition. Once the loop is executed, you will find the concatenated results of your loops at the output port of<a id="_idIndexMarker247"/> the <strong class="keyword">Loop</strong> <strong class="keyword">End</strong> node, with <a id="_idIndexMarker248"/>an extra column telling you the<a id="_idIndexMarker249"/> loop number each row refers to. It looks simple, and it actually is!</p><p class="normal">You will find a graphical summary of the most popular loop nodes below. More specifically:</p>
<ul>
<li class="bullet"><strong class="keyword">Counting Loop Start</strong>: Use <a id="_idIndexMarker250"/>this if you want to repeat a portion of a workflow a given number of times (which you can specify in the configuration dialog).</li>
<li class="bullet"><strong class="keyword">Chunk Loop Start</strong>: The loop will be repeated once for every fixed-size chunk of consecutive rows in the input table. You can decide the number of total loops or chunk size per loop to use. If you select a chunk size of 1, you will repeat a portion of the workflow for each individual row of the input table.</li>
<li class="bullet"><strong class="keyword">Group Loop Start</strong>: The loop will be repeated for every group of rows, defined by each combination of unique values in the columns you decide. Remember the <strong class="keyword">GroupBy</strong> node? In that case, you obtained an aggregated row for each group: in this case, you will repeat a portion of the workflow for each group. We'll use this node shortly, which will make its behavior clearer.</li>
</ul>
			<div>
				<div id="_idContainer097" class="note">
					<p class="Information-Box--PACKT-">There are other nodes for starting and ending loops, which would extend the flexibility you have for repeating some sets of operations in your workflows. Have a look at the <strong class="keyword">Recursive Loop </strong>nodes:<strong class="keyword"> </strong>with these you can<strong class="keyword"> </strong><em class="italic">bring back</em><strong class="keyword"> t</strong>he output of a loop to the start node, to repeat it over and over on the same rows.</p>
				</div>
			</div>
			<p class="normal"><em class="italic">Figure 3.18</em> shows a summary of possible loop setups for your workflow. Remember: you can only have a single <strong class="keyword">Loop</strong> <strong class="keyword">Start</strong> and a <strong class="keyword">Loop</strong> <strong class="keyword">End</strong> node working together on the same loop body. The dashed lines in the figure show you three plausible options for <strong class="keyword">Loop</strong> <strong class="keyword">Start</strong> nodes:</p>
			<figure class="mediaobject"><img src="image/B17125_03_18.png" alt=""/></figure>
			<p class="packt_figref">Figure 3.18: Loop nodes in KNIME: repeat a portion of the workflow as many times as you need </p>
			<p class="normal">After this short <a id="_idIndexMarker251"/>digression on creating loops in KNIME, let's<a id="_idIndexMarker252"/> go back to our business case. We want to repeat the filtering of the top products for each subcategory, so we should implement a group loop, where the group is simply defined by the column <em class="italic">Subcategory</em>. Here's how the <strong class="keyword">Group Loop Start</strong> node works.</p>
			<h2 id="_idParaDest-56" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor056"/><img src="image/image049.png" alt=""/> <em class="bold-italic">Group Loop Start</em></h2>
			<p class="normal">This <a id="_idIndexMarker253"/>node (available <a id="_idIndexMarker254"/>in <strong class="screenText">Workflow Control &gt; Loop Support</strong>) marks the starting point of the portion of workflow which will be repeated for each group. All the input rows showing the same values in the columns defining the group will be returned to the downstream loop for execution, one group at a time. Its configuration requires you to specify the columns that define each group. Using this node will require the implementation of a <strong class="keyword">Loop End</strong> node, which will mark the end of the segment of nodes for which to repeat the execution:</p>
			<figure class="mediaobject"><img src="image/B17125_03_19.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure>
			<p class="packt_figref">Figure 3.19: Configuration window of the Group Loop Start node: decide which columns define the group through which you want to iterate</p>
			<p class="normal">Let's create our first loop in KNIME to answer our current business question.</p>
			<ol>
				<li class="numbered" value="14">We can reuse the sorted list of products we created for the previous question as a base for our grouped filtering. Drag and drop the <strong class="keyword">Group Loop Start</strong> node and connect it downstream to the <strong class="keyword">Sorter</strong> node. In its configuration window, select only <em class="italic">Subcategory</em> to appear in the <strong class="screenText">Include </strong>panel on the right.</li>
				<li class="numbered">The loop will<a id="_idIndexMarker255"/> only have to select the<a id="_idIndexMarker256"/> top three products appearing in each group. To do so, we can replicate what we did for the overall top list of products. Let's implement a <strong class="keyword">Row Filter</strong> node, select <strong class="screenText">Include rows by number</strong>, and then input <code class="Code-In-Text--PACKT-">1</code> as <strong class="screenText">First row number</strong> and, in this case, <code class="Code-In-Text--PACKT-">3</code> as <strong class="screenText">Last row number</strong>.<p class="normal">To close a loop in a workflow, we need to indicate its end point by using the appropriate node.</p>
</li>
</ol>

<h2 id="_idParaDest-57" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor057"/><img src="image/image053.png" alt=""/> <em class="bold-italic">Loop End</em></h2><p class="normal">This<a id="_idIndexMarker257"/> node (<strong class="screenText">Workflow Control &gt; Loop Support</strong>) marks the<a id="_idIndexMarker258"/> end of a workflow loop. At each execution of a loop, it collects the intermediate results by storing the rows arriving at the input port. At the end of the last loop execution, it will return the intermediate results' full concatenation. In its configuration window, you can decide whether or not to add an extra column that counts the loop number in which each intermediate row was generated (<strong class="screenText">Add iteration column</strong>). In this node's pop-up menu (right-click on the node once implemented), you will find additional options for executing it. If you click on <strong class="screenText">Step Loop Execution</strong>, you will ask KNIME to run only one single iteration of the loop so you can check intermediate results:</p><div id="_idContainer102" class="note"><p class="Information-Box--PACKT-">The coders among you will recognize that this step execution acts as a <em class="italic">breakpoint</em> that can be used to investigate and debug the way your loop is working. You can also set individual breakpoints at any point within your loop: check out<a id="_idIndexMarker259"/> the <strong class="keyword">Breakpoint</strong> node for doing this.</p></div><figure class="mediaobject"><img src="image/B17125_03_20.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.20: Loop End node dialog: do you want to add an iteration column?</p><div id="_idContainer104" class="note"><p class="Information-Box--PACKT-">Sometimes, you need to collect multiple tables (with different columns) for each iteration of your loop. In this case, you can use the 2-port version of the <strong class="keyword">Loop End</strong> node, which you will find in the same repository folder. </p></div>

<ol>
				<li class="numbered" value="16">Let's implement a <strong class="keyword">Loop</strong> <strong class="keyword">End</strong> node, after the <strong class="keyword">Row</strong> <strong class="keyword">Filter</strong>, and untick the <strong class="screenText">Add iteration column</strong> option: we don't need it, as we keep the name of the <em class="italic">Subcategory</em> to indicate what we are referring to. The node's output shows three rows for each <a id="_idIndexMarker260"/>subcategory, which is exactly what we needed to answer the business<a id="_idIndexMarker261"/> question:<figure class="mediaobject"><img src="image/B17125_03_21.png" alt="Table&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.21: Top products for each subcategory: each iteration of the loop returned three rows, which have been stitched together by the Loop End node to appear in the same table</p><p class="normal">The next question asks us to report sales by country, identifying the ones we ship the most to. It will be enough to aggregate, once again, the sales table, this time grouping by country instead of grouping by product as we've done so far. We can reuse the <strong class="keyword">Row Filter's</strong> output (which excluded the "Others" category) as a starting point for this new branch of the workflow.</p></li>
				<li class="numbered">We need to implement a new <strong class="keyword">GroupBy</strong> node, having a similar configuration to the first <strong class="keyword">GroupBy</strong> we used earlier to aggregate by product but with a different definition of groups. Time is money, so let's copy and paste the previous <strong class="keyword">GroupBy</strong> and connect it with the first <strong class="keyword">Row Filter</strong>, as anticipated above. In its configuration, let's just work on the <strong class="screenText">Groups</strong> panel: this time, we want <em class="italic">Country</em> to be the only column defining groups. We can leave the <strong class="screenText">Manual</strong> <strong class="screenText">aggregation</strong> tab unaltered, as we still want to sum revenues and quantities.</li>
				<li class="numbered">To make our output clearer, let's use the <strong class="keyword">Sorter</strong> node to order rows by decreasing <em class="italic">Sales</em>, similar to what we did in the earlier branch.<p class="normal">As shown in <em class="italic">Figure 3.22</em>, we ascertain that most sales are made by UK-based customers, which makes sense, considering that we are talking about a British company:</p><figure class="mediaobject"><img src="image/B17125_03_22.png" alt="Table&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.22: Top products for each subcategory: each iteration of the loop returned three rows, which have been stitched together by the Loop End node to appear in the same table</p>
</li>
</ol>

<p class="normal">As we move to the next business questions, we notice that they all make reference to a dimension that, so far, we've ignored—time. To proceed in the creation of our reports, we will need to <a id="_idIndexMarker262"/>filter by date (two questions ask us to focus <a id="_idIndexMarker263"/>on the calendar year to date time frame) and reaggregate by month (to spot seasonal patterns). Managing time-related data in KNIME is relatively easy thanks to a set of nodes that are specifically designed for doing that. We have nodes that convert text to Date&amp;Time data types (<strong class="keyword">String to Date&amp;Time</strong>), nodes that extract specific elements from a Date&amp;Time data point like hour, month, or day of the week (<strong class="keyword">Extract Date&amp;Time Fields</strong>), and nodes that will filter rows according to some <em class="italic">temporal</em> logic (<strong class="keyword">Date&amp;Time-based Row Filter</strong>). In the next few pages, we will learn how to use such handy nodes one by one.</p><h2 id="_idParaDest-58" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor058"/><img src="image/image061.png" alt=""/> <em class="bold-italic">String to Date&amp;Time</em></h2><p class="normal">This<a id="_idIndexMarker264"/> node (<strong class="screenText">Other Data Types &gt; Time Series &gt; Transform</strong>) converts<a id="_idIndexMarker265"/> text columns into Date&amp;Time values so that they can be used in time-related nodes. The node attempts to automatically recognize the format of Date&amp;Time fields within strings, leaving the user the possibility to input the text field's expected format manually. In its configuration window, you can first specify which string columns should be converted (ensure you keep on the right only the ones that include Date&amp;Time). </p><p class="normal">In the <strong class="screenText">Replace/Append Selection</strong> panel, you can decide whether to replace columns with their converted version or to add them, adding a fixed suffix to their headers. In the last panel, you can enter a string that explains the expected <strong class="screenText">Date format</strong>: for instance, strings like <code class="Code-In-Text--PACKT-">16/02/2023</code> will be correctly parsed using the format string <code class="Code-In-Text--PACKT-">dd/MM/yyyy</code>. By clicking on the button <strong class="screenText">Guess data type and format</strong>, KNIME will try to recognize the format by analyzing the first cell's content, which you can read in the label below. If the automatic guess doesn't work, you can enter your own string using characters like <code class="Code-In-Text--PACKT-">d</code>, <code class="Code-In-Text--PACKT-">M</code>, <code class="Code-In-Text--PACKT-">y</code>, <code class="Code-In-Text--PACKT-">h</code>, <code class="Code-In-Text--PACKT-">m</code>, and <code class="Code-In-Text--PACKT-">s</code>, which stand for day, month, year, hour, minutes, and seconds (check out the node description for the full list of format placeholders). You can also select a regional setting (called <strong class="screenText">Locale</strong>, like <strong class="screenText">en-US</strong> or <strong class="screenText">it-CH</strong>) to determine the <a id="_idIndexMarker266"/>language expected for fields such as month or weekday names:</p><figure class="mediaobject"><img src="image/B17125_03_23.png" alt="Graphical user interface, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.23: String to Date&amp;Time configuration windows: convert a string of text into a Date&amp;Time value</p>

<ol>
				<li class="numbered" value="19">Let's implement a <strong class="keyword">String</strong> <strong class="keyword">to</strong> <strong class="keyword">Date&amp;Time</strong> node and plug inside it the output of the first <strong class="keyword">Row</strong> <strong class="keyword">Filter</strong> (we can still reuse that one as it carries a cleaned version of the table). Let's keep only the column <em class="italic">Invoice_time</em> on the right selection panel and click on <strong class="screenText">Guess data type and format</strong> to let KNIME find a way to interpret the string. We obtain the format string <code class="Code-In-Text--PACKT-">'D'dd/M/yy'T'HH:mm:ss</code>, which perfectly matches the content of the first value in our table (<code class="Code-In-Text--PACKT-">D01/12/17T07:45:00</code>).<p class="normal">After we run the node, we notice in the output table that the icon on top of the <em class="italic">Invoice_time</em> column is not an "S" any longer but a calendar picture: KNIME is now going to treat that column as a Date&amp;Time field and we can use all the other time-related nodes for its <a id="_idIndexMarker267"/>manipulation. Since the business question focuses on the calendar year to date, we need to <a id="_idIndexMarker268"/>find a way to filter rows by dates, exactly what our next node is specialized in.</p>
</li>
</ol>

<h2 id="_idParaDest-59" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor059"/><img src="image/image065.png" alt=""/> <em class="bold-italic">Date&amp;Time-based Row Filter</em></h2><p class="normal">This <a id="_idIndexMarker269"/>node (<strong class="screenText">Other Data Types &gt; Time Series &gt; Transform</strong>) applies <a id="_idIndexMarker270"/>row-level filtering based on a specified time range. To configure it, you first need to select the column that shall be used for the filtering (it must be of Date&amp;Time type). Then you can declare the interval of the rows to keep: you do so by specifying a lower bound (including all values happening later than the point in time you declare in the <strong class="screenText">Start </strong>panel), an upper bound (keeping everything that occurs before what is declared in the <strong class="screenText">End</strong> panel), or both (making it a closed interval). The upper bound can be defined either by inputting a specific point in time (option <strong class="screenText">Date&amp;Time</strong>), a composite interval from the start time (option <strong class="screenText">Duration</strong>, which can be like <code class="Code-In-Text--PACKT-">2y 1M</code>, meaning two years and one month from the start), or a specific number of time periods from the start (option <strong class="screenText">Numerical</strong>, like plus or minus 10 hours from the start). By ticking the <strong class="screenText">Inclusive </strong>checkbox, every value that is equal to the start (or the end) date will be kept in the output:</p><figure class="mediaobject"><img src="image/B17125_03_24.png" alt="Graphical user interface, text, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.24: Configuration of Date&amp;Time-based Row Filter node: keep only the rows referring to a specific time range</p>
<ol>
				<li class="numbered" value="20">Since <a id="_idIndexMarker271"/>the business <a id="_idIndexMarker272"/>question refers to the latest calendar year only (which in our dataset is 2019), we need to implement a <strong class="keyword">Date&amp;Time-based Row Filter</strong> node to remove all earlier rows. For its configuration, we can untick the <strong class="screenText">End</strong> box (we know that the date doesn't go beyond 2019) and input <code class="Code-In-Text--PACKT-">2019-01-01</code> as <strong class="screenText">Date</strong> and <code class="Code-In-Text--PACKT-">00:00:00</code> as <strong class="screenText">Time </strong>in the <strong class="screenText">Start </strong>box.</li>
				<li class="numbered">Since the question asks how much revenue was generated within each product category, we just need to group the resulting rows (now referring to 2019 only) by <em class="italic">Category</em>. Implement a <strong class="keyword">GroupBy</strong> node, keep only <em class="italic">Category</em> in the definition of <strong class="screenText">Groups</strong>, and the usual sum of <em class="italic">Sales</em> and <em class="italic">Quantity</em> in the <strong class="screenText">Manual Aggregation</strong> panel. Also, this time, we want to keep the naming simple and select <strong class="screenText">Keep original name(s)</strong> in the dropdown at the bottom: <figure class="mediaobject"><img src="image/B17125_03_25.png" alt=""/></figure><p class="packt_figref">Figure 3.25: Sales by Category in 2019</p>
</li>
</ol>

<p class="normal">Another question is answered! We managed to limit our sales to the time frame of interest and <a id="_idIndexMarker273"/>summarize sales at the granularity we need. For the next question, we have to deal with a slight complication: we are asked to compute each category's relative footprint out of the total revenues. This means that we should divide the sales generated in the various categories by the grand total of sales. We can use the <strong class="keyword">Math</strong> <strong class="keyword">Formula</strong> node to implement this division: the numerator of the division is readily available (it's the <strong class="screenText">Sales</strong> column obtained after the <strong class="keyword">GroupBy</strong> summarization we already did to answer the previous question). However, the denominator should be calculated separately and somehow included in the formula. This is where <strong class="keyword">variables</strong> come in handy. Although not every user will need to use variables in KNIME, let's go through the fundamentals. You can consider the next couple of pages as optional in your path to becoming an autonomous KNIME user.</p><p class="normal">Variables in KNIME can be used to control the configuration of any node dynamically. So far, we've always customized a node's behavior by manually operating on its configuration window. In most cases, this will be enough. However, sometimes we want to configure a node's parameter through a variable that might be, in turn, the output of some calculation executed in another node. For instance, in the case of our sales footprint calculation, we want to use the aggregation of total sales as a variable in our formula.</p><div id="_idContainer112" class="note"><p class="Information-Box--PACKT-">In general, any configuration parameter of a node can be controlled by a variable. If you open the configuration window of any node and go to the tab called <strong class="screenText">Flow Variables </strong>(which we have not used so far), you find a list of the parameters needed by that node, and you can select which variables (if available at that point in the workflow) should be used to control them.</p></div><p class="normal">To make variables available, you need to inject them into the workflow. The easiest way to do so is to <a id="_idIndexMarker274"/>transform the <a id="_idIndexMarker275"/>values of a data table into variables, using a special node called <strong class="keyword">Table Row<a id="_idTextAnchor060"/> to Variable</strong>.</p>


<h2 id="_idParaDest-60" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor061"/><img src="image/image071.png" alt=""/> <em class="bold-italic">Table Row to Variable</em></h2><p class="normal">This<a id="_idIndexMarker276"/> node (<strong class="screenText">Workflow Control &gt; Variables</strong>) takes <a id="_idIndexMarker277"/>all the values in the first row of the input table and transforms them into individual variables, each one named after the corresponding input column. Its configuration window lets you select the columns whose first row's value should be transformed into variables:</p><figure class="mediaobject"><img src="image/B17125_03_26.png" alt=""/></figure><p class="packt_figref">Figure 3.26: Configuration of Table Row to Variable node: select the values to be transformed into variables</p><p class="normal">The output port of this node is a red circle, which indicates flow variables. You can inject the variables into any node by just connecting this output port with the receiving node's body.</p><div id="_idContainer115" class="packt_tip"><p class="Tip--PACKT-">Every node in KNIME has flow variable ports available. They are hidden by default. To unhide them, just right-click on the node and then click on <strong class="screenText">Show Flow Variable Ports</strong>.</p></div><p class="normal">It's important to clarify that this node will only transform the <em class="italic">values in the first row</em> of a table into variables. If you need to iterate through different values, you can use <strong class="keyword">Table Row To Variable Loop Start</strong>. Using<a id="_idIndexMarker278"/> this node (for example, in conjunction with a <strong class="keyword">Loop</strong> <strong class="keyword">End</strong> node, which<a id="_idIndexMarker279"/> you have already seen), you can create a loop where, at every iteration, the variables assume the value included in each of the input rows.</p><p class="normal">Now that we know how to implement variables in KNIME, we can create a variable that contains the total aggregation of sales, which we will then use in the <strong class="keyword">Math</strong> <strong class="keyword">Formula</strong> node, to calculate the sales footprint. Let's use <strong class="keyword">GroupBy</strong> to aggregate total sales and then a <strong class="keyword">Table</strong> <strong class="keyword">Row</strong> <strong class="keyword">to</strong> <strong class="keyword">Variable</strong> node to transform that number into a variable.</p>
<ol>
				<li class="numbered" value="22">We need to aggregate all the sales that happened in 2019 into one single row, holding the grand total of generated revenues. Let's implement <strong class="keyword">GroupBy</strong> and connect it to the output port of the <strong class="keyword">Date&amp;Time-based Row Filter</strong> node. Since we only need a row with the grand total, we can leave the <strong class="screenText">Group </strong>panel empty: this will generate a warning on our node, but we know why we are doing this, so we can ignore it. On the <strong class="screenText">Manual Aggregation</strong> panel, let's add the usual <em class="italic">Sales</em> column and aggregate through the <strong class="screenText">Sum </strong>function. To avoid any confusion with the variable name, let's select <strong class="screenText">Aggregation method (column name) </strong>as the naming convention this time (the menu at the bottom). Once we run the node, we obtain a simple output, which is exactly what we were after: a table with one row and one column, displaying the grand total of sales in 2019.</li>
				<li class="numbered">We are now ready to transform this value into a variable by implementing the <strong class="keyword">Table Row to Variable</strong> node right after the <strong class="keyword">GroupBy</strong>. No configuration is needed for this node, as we can transform all columns (just one in our case) into variables.</li>
				<li class="numbered">It's finally time to make the footprint calculation. Let's implement a <strong class="keyword">Math Formula</strong> node and make the two connections we need. First, this node should receive as an input table the result of the <strong class="keyword">GroupBy</strong> that we used a few steps ago to calculate the total sales by category. Second, we should inject the variable with the grand total of sales, by creating a connection between the red port of the <strong class="keyword">Table Row to Variable </strong>node and the <strong class="keyword">Math Formula </strong>node. To do so, you can click on the red circle, keep the button pressed, and release it on the <strong class="keyword">Math Formula</strong> node icon.<div id="_idContainer116" class="packt_tip"><p class="Tip--PACKT-">Although this is not needed, if you want to view any node's variable ports, just open the pop-up menu (right-click on the node) and then click on <strong class="screenText">Show Flow Variable Ports</strong>.</p></div>
<p class="bullet-para">The node configuration dialog now allows us to use the flow variable we have just injected. You will notice the variable (called <em class="italic">Sum(Sales)</em>) on the right within the <strong class="screenText">Flow Variable List</strong>. We can calculate the footprint by using the mouse and keyboard and <a id="_idIndexMarker280"/>obtaining the expression: <code class="Code-In-Text--PACKT-">$Sales$/$${DSum(Sales)}$$*100</code>. We can append the <a id="_idIndexMarker281"/>resulting column, assigning it the name <em class="italic">Footprint</em> and, for simplicity, converting it to an integer number by ticking the last checkbox at the bottom:</p><figure class="mediaobject"><img src="image/B17125_03_27.png" alt=""/></figure><p class="packt_figref">Figure 3.27: Configuration of the Math Formula node for the footprint calculation: we found both columns and variables on the left, ready to be used in the expression</p>
</li>
</ol>

<p class="normal">Also, this business question has now found a proper answer: the output of Math Formula includes both the footprint of each category and its total sales, answering two questions at once. We have one last question to manage, which will require producing a chart. For all the previous ones, we have produced some tables: it would be nice to collect all these tables in a single Excel file with multiple tabs so we can disseminate our report easily and in a compact form.</p>

<ol>
				<li class="numbered" value="25">Let's implement an <strong class="keyword">Excel Writer</strong> node. Since this time we need to save four different tables in a single Excel file, we need to add three input ports to the node. To do so, click on the three dots appearing at the bottom left of the node icon and then <strong class="screenText">Add ports</strong> | <strong class="screenText">Sheet Input Ports</strong>. Repeat this, two more times, to obtain four input ports in total. Connect the output ports of the nodes providing the <em class="italic">answers</em> to <a id="_idIndexMarker282"/>the five questions we<a id="_idIndexMarker283"/> have managed so far (the overall top ten products, the top three by subcategory, the sales by country, and the output of the last Math Formula having both footprint and sales by category in 2019). In the <strong class="keyword">Excel Writer</strong>'s configuration, this time we find four textboxes in the <strong class="screenText">Sheets </strong>panel: we can use them to assign a meaningful name to guide whoever is reading the report. After declaring the full path and the name of the output file (click on the <strong class="screenText">Browse...</strong> button to select it), we are ready to close the configuration<a id="_idIndexMarker284"/> and <a id="_idIndexMarker285"/>execute the node:<figure class="mediaobject"><img src="image/B17125_03_28.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.28: Configuration of the Excel Writer: you can name each sheet differently</p>
</li>
</ol>

<p class="normal">The resulting Excel file looks exactly as we expected: we have four tabs, each looking after a different aspect of our business, providing straightforward answers to the common questions we had: </p><figure class="mediaobject"><img src="image/B17125_03_29.png" alt=""/></figure><p class="packt_figref">Figure 3.29: The output file in Excel has four sheets to answer five business questions</p><p class="normal">It's time to move <a id="_idIndexMarker286"/>on to the last and final <a id="_idIndexMarker287"/>business question, which is about monthly peaks of sales across our seasonal subcategories, which are "Christmas", "Summer", and "Easter". To show seasonal patterns across the year, we decide to aggregate sales by month/subcategory combinations. A pivot table will enable such bidimensional aggregation, which will be easy to display on a line chart. The only outstanding intricacy to solve is related to the aggregation by month. At this point, in fact, we do not have months indicated in a separate column, so we cannot perform the aggregation straightaway. Fortunately, there is a node that enables us the extraction of any temporal field from a Date&amp;Time column.</p>


<h2 id="_idParaDest-61" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor062"/><img src="image/image081.png" alt=""/> <em class="bold-italic">Extract Date&amp;Time Fields</em></h2><p class="normal">This <a id="_idIndexMarker288"/>node (<strong class="screenText">Other Data Types &gt; Time Series &gt; Transform</strong>) creates <a id="_idIndexMarker289"/>a separate column for each date or time field (such as Year, Month, Day of week, Hour, Minute, and so on), extracting it from a given Date&amp;Time input column. Its configuration requires us to select the Date&amp;Time source column and then tick the boxes of the fields to extract. Since some fields are prone to regional and language differences, you can specify the <strong class="screenText">Locale</strong> you prefer to use. For instance, if you extract Month (name) for a date in December, with the <strong class="screenText">es-ES</strong> locale (Spanish), you will get <code class="Code-In-Text--PACKT-">diciembre</code>:</p><figure class="mediaobject"><img src="image/B17125_03_30.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.30: Configuration of Extract Date&amp;Time Fields node: select the fields you want to appear as a separate column</p>

<ol>
				<li class="numbered" value="26">Let's <a id="_idIndexMarker290"/>implement<a id="_idIndexMarker291"/> an <strong class="keyword">Extract Date&amp;Time Fields</strong> node and connect the <strong class="keyword">String to Date&amp;Time</strong> output port to it (we want to consider the full dataset—not just 2019—so we want to build a separate branch). The configuration is straightforward: we only have one Data&amp;Time field in the input table so we find it already selected in the drop-down selection at the top. We only need to extract <strong class="screenText">Month (number)</strong>, so this will be the only box to tick.</li>
				<li class="numbered">We can now summarize sales by month and subcategory: add a <strong class="keyword">Pivoting</strong> node and configure it so that <strong class="screenText">Groups </strong>are defined by the newly created column (<em class="italic">Month (number)</em>), <strong class="screenText">Pivots </strong>are defined by the column <em class="italic">Subcategory</em>, and the <strong class="screenText">Manual Aggregation </strong>is on <strong class="screenText">Sum</strong> of <em class="italic">Sales</em>. To keep the headers clean, let's select <strong class="screenText">Pivot name</strong> as <strong class="screenText">Column name</strong> and <strong class="screenText">Keep original name(s)</strong> as <strong class="screenText">Aggregation name</strong> in the drop-down menus at the bottom.<p class="normal">Seasonality can be explained better through a nice chart instead of a table. To build a chart in KNIME, you can<a id="_idIndexMarker292"/> use one of the visualization<a id="_idIndexMarker293"/> nodes (check them out in the repository in <strong class="screenText">View &gt; JavaScript</strong>), like the one we will use for our line chart.</p>
</li>
</ol>

<h2 id="_idParaDest-62" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor063"/><img src="image/image085.png" alt=""/> <em class="bold-italic">Line Plot</em></h2><p class="normal">This node (<strong class="screenText">View &gt; JavaScript</strong>) generates <a id="_idIndexMarker294"/>a line plot based on<a id="_idIndexMarker295"/> the data given at the input port. When configuring the node, you need to specify what column to use for the horizontal axis (<strong class="screenText">x-axis</strong>) and what columns to visualize as separate lines (<strong class="screenText">y-axis</strong>). Additionally, you can generate a static vectorial image (in SVG format) at the node's output port: to enable this, tick the <strong class="screenText">Create image at outport</strong> box at the top:</p><figure class="mediaobject"><img src="image/B17125_03_31.png" alt="Graphical user interface, application&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.31: Configuration of Line Plot node: select which columns to use on the horizontal and vertical axes of your chart</p><p class="normal">In <a id="_idIndexMarker296"/>the <strong class="screenText">Axis Configuration</strong> panel, you can specify the titles <a id="_idIndexMarker297"/>of the horizontal and vertical axes, while in the <strong class="screenText">General Plot Options</strong>, you can set <strong class="screenText">Chart</strong> <strong class="screenText">title</strong>, <strong class="screenText">Chart</strong> <strong class="screenText">subtitle</strong>, and the size of the output image.</p>

<ol>
				<li class="numbered" value="28">Let's implement a Line Plot chart (pick the JavaScript version from the node repository) and connect the first output of the <strong class="keyword">Pivoting</strong> node with it. For its configuration, let's choose <em class="italic">Month (number)</em> for the <strong class="screenText">x-axis </strong>and the columns related to the seasonal subcategories (<em class="italic">Christmas</em>, <em class="italic">Easter</em>, and <em class="italic">Garden</em>) for the <strong class="screenText">y-axis</strong>. Let's also check the first option box so we generate the vectorial image at the outport. To make the chart more readable, we can add also the names of the axis (<code class="Code-In-Text--PACKT-">Sales</code> and <code class="Code-In-Text--PACKT-">Month</code> will do) using the <strong class="screenText">Axis Configuration</strong> panel. To execute the node and open its output straightaway, right-click on the node and then select <strong class="screenText">Execute and Open Views </strong>(or <em class="italic">Shift</em> + <em class="italic">F10</em>):<figure class="mediaobject"><img src="image/B17125_03_32.png" alt=""/></figure><p class="packt_figref">Figure 3.32: Output of the Line Plot node: our seasonal subcategories display an unsurprising monthly pattern</p>
</li>
</ol>


<p class="normal">The chart's output confirms to us the seasonality patterns that we would expect from our subcategories: the shape of the lines can help us to best plan for the demand that we will encounter<a id="_idIndexMarker298"/> in the coming years. It would be nice to <a id="_idIndexMarker299"/>export this chart as a vectorial file so that we can include it in shiny presentations and—most importantly, as we will learn—build an engaging story out of it!</p><h2 id="_idParaDest-63" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor064"/><img src="image/image091.png" alt=""/> <em class="bold-italic">Image Writer (Port)</em></h2><p class="normal">This<a id="_idIndexMarker300"/> node (<strong class="screenText">IO &gt; Write</strong>) saves <a id="_idIndexMarker301"/>an image as a separate file. The only configuration needed is to specify the <strong class="screenText">Output</strong> <strong class="screenText">location</strong>. You can select it in your file system by clicking on the <strong class="screenText">Browse...</strong> button:</p><figure class="mediaobject"><img src="image/B17125_03_33.png" alt="Graphical user interface, text, application, email&#10;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 3.33: Configuration of the Image Writer (Port) node: where do you want your image file to be?</p>

<ol>
				<li class="numbered" value="29">Let's <a id="_idIndexMarker302"/>implement the <strong class="keyword">Image</strong> <strong class="keyword">Writer</strong> <strong class="keyword">(Port)</strong> node; connect<a id="_idIndexMarker303"/> the output of the <strong class="keyword">Line</strong> <strong class="keyword">Plot</strong> node with it (the green square connectors indicate that we are transferring images here), and configure it by specifying the location of the output file (make sure you indicate the full file name, including the <code class="Code-In-Text--PACKT-">.svg</code> extension at the end).</li>
			</ol>

			<p class="normal">You made it! It took some time, but the investment was entirely worth it: your workflow is now able to generate a multi-page report (and, when needed, visual proof of the seasonal patterns) in a matter of seconds. Every time new data becomes available, the full workflow can be reset (select the initial nodes and press <em class="italic">F8</em>) and re-run by just executing the final nodes (or <em class="italic">Shift</em> + <em class="italic">F7</em> to execute all nodes at once): no more human error or tedious manual steps with Excel. The finance analyst is very thankful, as she can now reinvest the time she used to spend every Friday pulling together the reports in something more value adding, like analyzing the numbers in depth, offering a relevant interpretation of data evidence, and providing some recommendations for improving the business results moving forward.</p>
			<figure class="mediaobject"><img src="image/B17125_03_35.png" alt=""/></figure>
			<p class="packt_figref">Figure 3.34: It looks like a fish, but it's a workflow that automates sales reporting</p>
			<p class="normal">After admiring<a id="_idIndexMarker304"/> you in action, she is now intrigued by <a id="_idIndexMarker305"/>KNIME and wants to learn how to automate her data work by herself in the future. You have successfully planted a seed of enthusiasm for data analytics in your workplace, and it seems it is contagiously propagating further.</p>
			<h1 id="_idParaDest-64" class="title"><a id="_idTextAnchor065"/>Summary</h1>
			<p class="normal">By completing this chapter, you have made decisive progress in becoming a confident user of data analytics. You have learned how to provide some logic structure to your database by creating a simple entity-relationship model. You have also experienced the essential operations for transforming data assets, such as combining tables and aggregating values as needed. Your analytics toolbox is getting fatter: with fourteen more KNIME nodes at your disposal, you can now build some simple descriptive analytics workflows and automate their executions through loops and variables. The full tutorial has allowed you to gather first-person experience in building a machine that provides systemic answers to recurring needs, starting from a set of business questions and delivering a repeatable process to answer them.</p>
			<p class="normal">In the next chapter, we will get all of this to the next level by introducing the fundamental concepts of artificial intelligence: we will soon discover how to build machines that can autonomously learn from data and support our work.</p>
		</div>
	</body></html>