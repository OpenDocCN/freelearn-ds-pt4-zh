<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer142">
<h1 class="chapter-num er" id="_idParaDest-179"><a id="_idTextAnchor294"/>10</h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor295"/>A Primer on Security and Fraud Detection</h1>
<p class="author-quote">“All warfare is based on deception.” - Sun Tzu</p>
<p>The history of fraud is as old as time. Fraud in the crypto world comes as no surprise, and as crypto gains mainstream adoption, it becomes increasingly necessary to be aware of the different forms of fraud in order to be able to <span class="No-Break">identify it.</span></p>
<p>Fraud is a significant issue for businesses in general, for governments, and for the blockchain industry in particular. According to the 2022 PwC Global Annual Review on fraud, 46% of surveyed organizations reported experiencing some form of fraud or economic crime within the last <span class="No-Break">24 months.</span></p>
<p>Governments are aware of the issue for tax purposes, as well as to combat money laundering and terrorism financing. Relevant agencies have a mandate to enforce the law and combat such illicit activity even if cryptocurrencies are involved. Due diligence is required for all subjects associated with financial activity or money services businesses, a concept that has expanded to include centralized exchanges. That is the reason why major <strong class="old">centralized exchanges</strong> (<strong class="old">CEXs</strong>) only<a id="_idIndexMarker604"/> open accounts for new users when the person behind the ID is validated. Compliance with certain quality standards is essential, and failure to comply can lead <span class="No-Break">to sanctions.</span></p>
<p>The crypto industry is also interested in solidifying trust in compliance with robust smart contracts and a seamless experience while transacting. Smart contract breaches, scam schemes, and the use of cryptocurrencies as payment for hacks have not helped in this pursuit. Data science has been helping to solve this issue for some time now. The challenge has been adapting the data science practice for the blockchain dataset, which is rather different and pseudo-anonymous. Some interesting companies such as Chainalysis, Elliptic, and CipherTrace are at the forefront of forensic data science in blockchain, helping authorities in investigations and supporting general <span class="No-Break">user trust.</span></p>
<p>In this chapter, we will examine the transaction behavior of addresses to train a machine learning model that can determine whether or not we are dealing with <span class="No-Break">a scammer.</span></p>
<p>Particularly, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>What illicit activity looks like <span class="No-Break">on Ethereum</span></li>
<li>Exploratory data analysis of transactional data <span class="No-Break">on Ethereum</span></li>
<li>Preparation, model training, and evaluation to flag <span class="No-Break">fraudulent transactions</span></li>
</ul>
<h1 id="_idParaDest-181"><a id="_idTextAnchor296"/>Technical requirements</h1>
<p>You can find all the data and code files for this chapter in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Data-Science-for-Web3/tree/main/Chapter10">https://github.com/PacktPublishing/Data-Science-for-Web3/tree/main/Chapter10</a>. We recommend that you read through the code files in the <strong class="source-inline">Chapter10</strong> folder to <span class="No-Break">follow along.</span></p>
<p>In this chapter, we will use the Ethereum Utilities library (<strong class="source-inline">eth-utils</strong>), which contains commonly used utility functions for Python developers working with Ethereum. Depending on our environment, we may need to import additional low-level libraries that are utilized <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">eth-utils</strong></span><span class="No-Break">.</span></p>
<p>If you haven’t installed <strong class="source-inline">eth-utils</strong> yet, you can do so using the following <span class="No-Break">code snippet:</span></p>
<pre class="console">
pip install eth-utils</pre> <p>The documentation for <strong class="source-inline">eth-utils</strong> is available at <a href="https://eth-utils.readthedocs.io/en/stable/">https://eth-utils.readthedocs.io/en/stable/</a>. If the installation fails due to a lack of supporting libraries, you can find the complete list of required libraries that need to be pre-installed <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Chapter10/EDA.ipynb</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor297"/>A primer on illicit activity on Ethereum</h1>
<p>There is a <a id="_idIndexMarker605"/>technical difference between fraud and a scam. A <a id="_idIndexMarker606"/>scam is an act where we unknowingly pay for a fake item, transfer money, or provide our private keys to a criminal. Conversely, fraud<a id="_idIndexMarker607"/> refers to any suspicious activity on our address that we did not authorize. In this book, we will use both <span class="No-Break">terms interchangeably.</span></p>
<p>The Ethereum Security blog <a id="_idIndexMarker608"/>has three key messages for anyone starting in the <span class="No-Break">crypto industry:</span></p>
<ul>
<li><em class="italic">Always </em><span class="No-Break"><em class="italic">be skeptical</em></span></li>
<li><em class="italic">No one is going to give you free or </em><span class="No-Break"><em class="italic">discounted ETH</em></span></li>
<li><em class="italic">No one needs access to your private keys or </em><span class="No-Break"><em class="italic">personal information</em></span></li>
</ul>
<p>As of today, some <a id="_idIndexMarker609"/>of the most common scams include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="old">Giveaway scams</strong>: These <a id="_idIndexMarker610"/>basically work by criminals promising that if we send <em class="italic">X</em> amount of crypto to an address, it will be returned to us but doubled in amount. These schemes are often psychological, offering the victim only a limited amount of time to participate in this “opportunity,” generating<a id="_idIndexMarker611"/> a <strong class="old">fear of missing out</strong> (<strong class="old">FOMO</strong>) effect. This scheme often uses high-profile X (formerly Twitter) accounts, videos of celebrities, and <span class="No-Break">so on.</span></li>
<li><strong class="old">IT support scams</strong>: These<a id="_idIndexMarker612"/> scammers impersonate IT support or admin personnel from blockchain services, such as wallets, exchanges, marketplaces, or even a chain. They may ask for some information from us or to validate our ID and, in general, will try to get the minimum necessary information to extract our funds. These sorts of scammers can be found mostly on Discord discussion channels or Telegram. It is very usual to see next to real people’s names the phrase “<em class="italic">Never DM first</em>.” Scammers will write first, trying to generate a connection and trust. It is worth remembering that Web3 is a decentralized landscape, so it is unlikely that support teams will be scanning the internet to answer our questions. If we were interacting with a centralized platform with a support team in place, the team would always contact us through <span class="No-Break">official channels.</span></li>
<li><strong class="old">Phishing scams</strong>: This is <a id="_idIndexMarker613"/>a type of social engineering attack that uses impersonation through email to convince the victim to provide the necessary information to commit the fraud. The email will usually contain links that redirect to fake websites or download malicious malware. As we saw in <a href="B19446_03.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, when detailing where to go for off-chain data, we should try to access websites following a trusted link – for example, through CoinMarketCap or CoinGecko. There are many ways to detect phishing, but the reality is that they are becoming more creative <span class="No-Break">over time.</span></li>
<li><strong class="old">Broker scams</strong>: These<a id="_idIndexMarker614"/> are trading brokers with a lot of followers on social media who allegedly generate outstanding profits. A real person is behind the account of a broker, who will interact with the victim until the <a id="_idIndexMarker615"/>latter sends their funds to be “managed” by the broker. Once sent, those funds <span class="No-Break">are lost.</span></li>
</ul>
<p>Each of these scams is further explained with real-life examples on this <span class="No-Break">blog: </span><a href="https://ethereum.org/en/security/"><span class="No-Break">https://ethereum.org/en/security/</span></a><span class="No-Break">.</span></p>
<p>Regardless of the fraudulent scheme, money will be transferred through a transaction and saved in an account. In the next section, we will analyze account behavior to try to determine which account can be trusted and which should be flagged as <span class="No-Break">a scam.</span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor298"/>Preprocessing</h2>
<p>We will be working <a id="_idIndexMarker616"/>with a balanced dataset that was used in the paper <em class="italic">Detection of illicit accounts over the Ethereum blockchain</em>. You can find the link to the paper in the <em class="italic">Further reading</em> section. This dataset is a balanced dataset, with 48 columns or features that combine licit and illicit accounts. The dataset was created by using the CryptoScamDB database and Etherscan; the latter is a tool that we are already familiar with. <a href="http://cryptoscamdb.org">cryptoscamdb.org</a> manages an open source dataset that tracks malicious URLs and their <span class="No-Break">associated addresses.</span></p>
<p>The columns and their description <span class="No-Break">as follows:</span></p>
<table class="T---Table _idGenTablePara-1" id="table001-9">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="T---Table">
<td class="T---Table T---Body T---Header">
<p><span class="No-Break"><strong class="old">Feature</strong></span></p>
</td>
<td class="T---Table T---Body T---Header">
<p><span class="No-Break"><strong class="old">Description</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Avg_min_between_sent_tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average time between sent transactions for an account <span class="No-Break">in minutes</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Avg_min_between_received_tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average time between received transactions for an account <span class="No-Break">in minutes</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Time_Diff_between_first_and_last(Mins)</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The time difference between the first and <span class="No-Break">last transaction</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Sent_tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total number of sent <span class="No-Break">normal transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Received_tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total number of received <span class="No-Break">normal transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Number_of_Created_Contracts</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total number of created <span class="No-Break">contract transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Unique_Received_From_Addresses</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total unique addresses from which the account <span class="No-Break">received transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Unique_Sent_To_Addresses</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total unique addresses from which the account <span class="No-Break">sent transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Min_Value_Received</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The minimum value in Ether <span class="No-Break">ever received</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Max_Value_Received</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The maximum value in Ether <span class="No-Break">ever received</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Avg_Value_Received</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average value in Ether <span class="No-Break">ever received</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Min_Val_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The minimum value of Ether <span class="No-Break">ever sent</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Max_Val_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The maximum value of Ether <span class="No-Break">ever sent</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Avg_Val_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average value of Ether <span class="No-Break">ever sent</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Min_Value_Sent_To_Contract</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The minimum value of Ether sent to <span class="No-Break">a contract</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Max_Value_Sent_To_Contract</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The maximum value of Ether sent to <span class="No-Break">a contract</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Avg_Value_Sent_To_Contract</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average value of Ether sent <span class="No-Break">to contracts</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Total_Transactions(Including_Tnx_to_Create_Contract)</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total number <span class="No-Break">of transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Total_Ether_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total Ether sent for an <span class="No-Break">account address</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Total_Ether_Received</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total Ether received for an <span class="No-Break">account address</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Total_Ether_Sent_Contracts</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total Ether sent to <span class="No-Break">contract addresses</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Total_Ether_Balance</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total Ether balance following <span class="No-Break">enacted transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">Total_ERC20_Tnxs</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total number of ERC20 token <span class="No-Break">transfer transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Total_Ether_Received</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total ERC20 token-received transactions <span class="No-Break">in Ether</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Total_Ether_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total ERC20 token-sent transactions <span class="No-Break">in Ether</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Total_Ether_Sent_Contract</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The total number of ERC20 tokens transferred to other contracts <span class="No-Break">in Ether</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Uniq_Sent_Addr</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The number of ERC20 token transactions sent to unique <span class="No-Break">account addresses</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Uniq_Rec_Addr</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The number of ERC20 token transactions received from <span class="No-Break">unique addresses</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Uniq_Rec_Contract_Addr</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The number of ERC20 token transactions received from unique <span class="No-Break">contract addresses</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Avg_Time_Between_Sent_Tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average time between ERC20 token-sent transactions <span class="No-Break">in minutes</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Avg_Time_Between_Rec_Tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average time between ERC20 token-received transactions <span class="No-Break">in minutes</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Avg_Time_Between_Contract_Tnx</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average time ERC20 token between sent <span class="No-Break">token transactions</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Min_Val_Rec</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The minimum value in Ether received from ERC20 token transactions for <span class="No-Break">an account</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Max_Val_Rec</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The maximum value in Ether received from ERC20 token transactions for <span class="No-Break">an account</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Avg_Val_Rec</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average value in Ether received from ERC20 token transactions for <span class="No-Break">an account</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Min_Val_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The minimum value in Ether sent from ERC20 token transactions for <span class="No-Break">an account</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Max_Val_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The maximum value in Ether sent from ERC20 token transactions for <span class="No-Break">an account</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Avg_Val_Sent</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The average value in Ether sent from ERC20 token transactions for <span class="No-Break">an account</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Uniq_Sent_Token_Name</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The number of unique ERC20 <span class="No-Break">tokens transferred</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Uniq_Rec_Token_Name</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The number of unique ERC20 <span class="No-Break">tokens received</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Most_Sent_Token_Type</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The most sent token for an account via an <span class="No-Break">ERC20 transaction</span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="source-inline">ERC20_Most_Rec_Token_Type</strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p>The most received token for an account via an <span class="No-Break">ERC20 transaction</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 – An explanation of each dataset column (source – from page 10 of the paper, Detection of illicit accounts over the Ethereum blockchain)</p>
<p>In <strong class="source-inline">Chapter10/EDA.ipynb</strong>, we <a id="_idIndexMarker617"/>analyzed the dataset and came to the <span class="No-Break">following conclusions:</span></p>
<ol>
<li>There are 4,681 accounts and 48 features. Within these addresses, there are five duplicated addresses and five <span class="No-Break">invalid addresses.</span><p class="list-inset">To determine <a id="_idIndexMarker618"/>whether an address is valid or invalid, we use part of the code of EIP-55, combined with a custom formula <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">address_validation()</strong></span><span class="No-Break">.</span></p><p class="list-inset"><strong class="old">Ethereum Improvement Proposal</strong> (<strong class="old">EIP</strong>)-55 involves<a id="_idIndexMarker619"/> adding and checking for uppercase letters in Ethereum addresses. The original code can be found at <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md</a>. The code turns a hexadecimal address into bytes and checks the checksum encoding to confirm whether it is a valid Ethereum address. If not, it raises <span class="No-Break">a warning.</span></p><p class="list-inset">In the <strong class="source-inline">address_validation()</strong> function, we add an additional condition to count the characters of each address, discarding those that are not <span class="No-Break">42 characters.</span></p><p class="list-inset">If both conditions are met, the address is considered valid, and the checksummed version is returned. Otherwise, a <strong class="source-inline">not an ethereum address</strong> flag <span class="No-Break">is returned:</span></p><pre class="source-code">
<strong class="old">def checksum_encode(addr):</strong>
<strong class="old">    hex_addr = addr.hex()</strong>
<strong class="old">    checksummed_buffer = ""</strong>
<strong class="old">    hashed_address = eth_utils.keccak(text=hex_addr).hex()</strong>
<strong class="old">    for nibble_index, character in enumerate(hex_addr):</strong>
<strong class="old">        if character in "0123456789":</strong>
<strong class="old">            </strong><strong class="old">checksummed_buffer += character</strong>
<strong class="old">        elif character in "abcdef":</strong>
<strong class="old">            hashed_address_nibble = int(hashed_address[nibble_index], 16)</strong>
<strong class="old">            if hashed_address_nibble &gt; 7:</strong>
<strong class="old">                checksummed_buffer += character.upper()</strong>
<strong class="old">            else:</strong>
<strong class="old">                checksummed_buffer += character</strong>
<strong class="old">        else:</strong>
<strong class="old">            raise eth_utils.ValidationError(</strong>
<strong class="old">                f"Unrecognized hex character {character!r} at position {nibble_index}"</strong>
<strong class="old">            </strong><strong class="old">)</strong>
<strong class="old">    return "0x" + checksummed_buffer</strong>
<strong class="old">def test(addr_str):</strong>
<strong class="old">    addr_bytes = eth_utils.to_bytes(hexstr=addr_str)</strong>
<strong class="old">    checksum_encoded = checksum_encode(addr_bytes)</strong>
<strong class="old">    try:</strong>
<strong class="old">      assert checksum_encoded == addr_str, f"{checksum_encoded} != expected {addr_str}"</strong>
<strong class="old">    except AssertionError:</strong>
<strong class="old">      return checksum_encoded</strong>
<strong class="old">def address_validation(addr_str):</strong>
<strong class="old">    if len(addr_str) == 42:</strong>
<strong class="old">            </strong><strong class="old">result = test(addr_str)</strong>
<strong class="old">    else:</strong>
<strong class="old">        result = "not an ethereum address"</strong>
<strong class="old">    return result</strong></pre></li> <li>There are some missing values from columns 25 to 49. The percentage of null values is 17.7%. We identify any missing values in the dataframe, calculating the percentage of missing values for each column in <span class="No-Break">the dataframe.</span><p class="list-inset">We use the following <span class="No-Break">code snippet:</span></p><pre class="source-code">
<strong class="old">percent_missing = df.isnull().sum() * 100 / len(df)</strong></pre><p class="list-inset">There <a id="_idIndexMarker620"/>are several ways to proceed when dealing with null values, as we studied in <a href="B19446_05.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. However, we will explore another approach that we have not yet tried, which is complementing the dataset. Given the open nature of on-chain data, this is feasible. We will further analyze this step in the subsequent section <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Chapter10/Rebuilding.ipynb</strong></span><span class="No-Break">.</span></p></li> <li>The fraudulent transactions and missing values are at the top of the dataset. The most fraudulent accounts seem to have missing values. Refer to the heatmap <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">Chapter10/EDA.ipynb</strong></span><span class="No-Break">.</span></li>
<li>There are 12 columns with little variance (and only one value, which is zero). Columns with little variance may not be helpful for our training. These columns are <span class="No-Break">as follows:</span><p class="list-inset"><strong class="source-inline">['min_value_sent_to_contract', 'max_val_sent_to_contract', 'avg_value_sent_to_contract', 'total_ether_sent_contracts', 'ERC20_avg_time_between_sent_tnx', 'ERC20_avg_time_between_rec_tnx', 'ERC20_avg_time_between_rec_2_tnx', 'ERC20_avg_time_between_contract_tnx', 'ERC20_min_val_sent_contract', '</strong><span class="No-Break"><strong class="source-inline">ERC20_max_val_sent_contract', 'ERC20_avg_val_sent_contract']</strong></span></p><p class="list-inset">We identify these columns using the following <span class="No-Break">code snippet:</span></p><pre class="source-code">
<strong class="old">variance_df= df.nunique()</strong></pre></li> <li>After cleaning <a id="_idIndexMarker621"/>duplicates and invalids, there are 2,497 non-fraudulent accounts and 2,179 <span class="No-Break">fraudulent accoun<a id="_idTextAnchor299"/>ts.</span></li>
<li>We ran a correlation matrix and discovered that five columns are heavily correlated. These columns are <span class="No-Break">as follows:</span><p class="list-inset"><strong class="source-inline">['ERC20_max_val_rec', 'ERC20_min_val_sent', 'ERC20_max_val_sent', '</strong><span class="No-Break"><strong class="source-inline">ERC20_avg_val_sent', 'ERC20_uniq_rec_token_name']</strong></span></p><p class="list-inset">Dropping columns with similar information is important because redundant information does not add value to our training; rather, it can make our algorithm learn slower and complicate the interpretability of our model if we have to explain it. Multicollinearity can also affect certain models, such as linear models. Refer to the heatmap for correlations <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">Chapter10/EDA.ipynb</strong></span><span class="No-Break">.</span></p></li>
<li>The two columns with categorical data (<strong class="source-inline">ERC20_most_sent_token_type</strong> and <strong class="source-inline">ERC20_most_rec_token_type</strong>) are heavily sparse, with most tokens appearing only once or <span class="No-Break">being blank.</span><p class="list-inset">When we group by ERC token, there is no clear category that could be useful. One-hot-encoding these columns may result in a heavily sparse training dataset. Additionally, new tokens are being minted every day, and adding this information to our model would create a variable that becomes <span class="No-Break">outdated quick<a id="_idTextAnchor300"/>ly.</span></p></li>
</ol>
<p>Based on the conclusions reached from the preceding analysis, we cleaned up the data to adapt it to our needs. The following steps <span class="No-Break">were taken:</span></p>
<ol>
<li>We dropped <span class="No-Break">duplicated addresses.</span></li>
<li>We tried to populate missing values <span class="No-Break">from Etherscan.</span></li>
<li>We dropped <span class="No-Break">low-variance columns.</span></li>
<li>We dropped columns with 0.95 or <span class="No-Break">more correlation.</span></li>
<li>We dropped the <span class="No-Break"><strong class="source-inline">object</strong></span><span class="No-Break">-type columns.</span></li>
<li>We dropped the <span class="No-Break"><strong class="source-inline">Address</strong></span><span class="No-Break"> column.</span></li>
<li>We refilled NaNs with <span class="No-Break">the median.</span></li>
</ol>
<p>Let’s expand <a id="_idIndexMarker622"/>the preprocessing from <em class="italic">step 2</em>, which involves populating missing values from Etherscan. Real-life datasets tend to be incomplete. It is the job of data analysts or data scientists to complement those columns that are partially complete. There are several methodologies to do that, and we explored the traditional ones in <a href="B19446_05.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> when no further data <span class="No-Break">is available.</span></p>
<p>In <strong class="source-inline">Chapter10_Rebuilding</strong>, we tried another methodology that involves going to the source and looking for the missing data. Throughout this book, we have listed multiple sources, and as more progress is made in this area, new sources of on-chain data will become available, helping us complete our datasets. Additionally, specialization in Web3 will enable us to make inferences over data because we can understand it. This is particularly helpful when the data point we need to reflect in the dataset is indirect or does not stem directly from <span class="No-Break">on-chain data.</span></p>
<p>In the dataset extracted from the paper, <em class="italic">Detection of illicit accounts over the Ethereum blockchain</em>, 17% of the rows had missing data. To complement the paper, we used one of the data sources we have been analyzing for some time now – Etherscan. We leveraged the free tier of their API and were able to complement most of the rows. The link to the API documentation is <a href="https://docs.etherscan.io/">https://docs.etherscan.io/</a>. The steps to complement those columns are outlined in <strong class="source-inline">Chapter10_Rebuilding</strong>, where we extracted the missing data points and appended them to the dataframe. If Etherscan has no trace, we can infer that the address did not carry out such <span class="No-Break">a transaction.</span></p>
<p>After this process, a few null rows remained that we complemented with the median of the column. With this final step, we have a complete dataset ready <span class="No-Break">for training.</span></p>
<p><strong class="old">Checkpoint</strong>: If you want to skip this section, the resulting <strong class="source-inline">.csv</strong> file has been uploaded to the book's GitHub and is accessible <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">final.csv</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">A note on great preprocessing</p>
<p class="callout">A great example of data building and preprocessing in this space is related to a dataset constructed for the paper <em class="italic">Exploiting Blockchain Data to Detect Smart Ponzi Schemes on Ethereum</em> (the link to the paper is provided in the <em class="italic">Further reading</em> section). The aim of the paper is to train a machine learning algorithm to classify Ponzi schemes’ smart contracts. To achieve this, the researchers built a dataset comprising 200 Ponzi smart contracts and 3,580 non-Ponzi ones. For each contract, they extracted the bytecodes, transaction data, and internal transactions. Since internal transactions are not stored on-chain, the research team reran an Ethereum client to reproduce them. Additionally, to convert bytecodes into meaningful features or categories, the team translated them to opcode and included the frequency of each one in the <span class="No-Break">smart contract.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor301"/>Training the model</h2>
<p>Once we <a id="_idIndexMarker623"/>have finished cleaning and preprocessing the data, we shuffle the dataset and then split it into separate train and test datasets. Then, we iterate through several models that have performed well on binary classification tasks, including <strong class="source-inline">KNeighborsClassifier</strong>, <strong class="source-inline">DecisionTreeClassifier</strong>, <strong class="source-inline">AdaBoostClassifier</strong>, <strong class="source-inline">GradientBoostingClassifier</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">RandomForestClassifier</strong></span><span class="No-Break">.</span></p>
<p>However, just because a model performs well on one dataset doesn’t mean it will work well on another. This is where tuning the model becomes important. Machine learning models have hyperparameters that need to be modified to adapt to the specific data. Customizing these hyperparameters to our dataset will improve the performance of the model. In order to execute this optimization, there are some available tools, such as <span class="No-Break">scikit-learn GridSearchCV.</span></p>
<p><strong class="old">GridSearchCV</strong> is an<a id="_idIndexMarker624"/> exhaustive search through a range of hyperparameter values to find the best combination that maximizes the evaluation metric of our choice. It is really “exhaustive” in the sense that it will test each combination of estimators, so it can become a computationally consuming procedure and can take a lot of time. It is also worth mentioning that the search is limited by the search space that we arbitrarily choose, and therefore, <strong class="source-inline">best_estimator_</strong> returned by the <strong class="source-inline">GridSearchCV</strong> will be contained within it. In cases where we have no idea which parameters to choose, we can<a id="_idIndexMarker625"/> run <strong class="old">RandomizedSearchCV</strong> to provide guidance on where to start the search. <strong class="source-inline">RandomizedSearchCV</strong> defines a search space and randomly tests it. The documentation for both classes can be found at <a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.xhtml">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.xhtml</a> <span class="No-Break">and </span><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.xhtml"><span class="No-Break">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.xhtml</span></a><span class="No-Break">.</span></p>
<p>Both <strong class="source-inline">GridSearchCV</strong> and <strong class="source-inline">RandomizedSearchCV</strong> have a <strong class="source-inline">cv</strong> parameter that refers to cross-validation. <strong class="old">Cross-validation</strong> is a <a id="_idIndexMarker626"/>resampling method that partitions data into <strong class="source-inline">K</strong> bins of equal size to run <strong class="source-inline">K</strong> number of learning experiments. The results are then averaged to reduce the randomness of a model’s performance and make it more robust. This class is typically contained in other implementations such as grid search. However, it can also be <span class="No-Break">used independently.</span></p>
<p>There are variations such as Stratified <em class="italic">K</em> fold, which ensures that each split contains the same proportion of observations of each class, and Repeated <em class="italic">K</em> fold, which repeats the exercise for each fold but shuffles each partition to make it a new sample every time. The documentation for these procedures can be found <span class="No-Break">at </span><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.xhtml"><span class="No-Break">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.xhtml</span></a><span class="No-Break">.</span></p>
<p>The result of <a id="_idIndexMarker627"/>our training shows a best-performing model <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">GradientBoostingClassifier</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-185">Evaluating t<a id="_idTextAnchor302"/>he results</h2>
<p>We will <a id="_idIndexMarker628"/>use a confusion matrix to show the model’s performance, as it is highly useful for binary classification problems. The choice of evaluation metric will depend on the type of problem being addressed. In the case of fraud detection, we want to ensure that the false negative rate is minimized, so we will use <strong class="old">recall</strong> as the evaluation metric. A detailed explanation of evaluation metrics was provided in <a href="B19446_05.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
<p>The result is 95.6% in the overall project, which is a <span class="No-Break">go<a id="_idTextAnchor303"/>od number.</span></p>
<p class="callout-heading">An imbalanced dataset</p>
<p class="callout">A similar dataset is<a id="_idIndexMarker629"/> also available on Kaggle and was initially analyzed by us in <a href="B19446_06.xhtml#_idTextAnchor210"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. This dataset is in an imbalanced form, as only 20% of the rows are fraudulent. It is common for fraud detection tasks to be associated with imbalanced data, as there are typically more regular transactions than fraudulent ones. Some models may overlook minority classes, which can sometimes include the specific class we are interested in detecting. To address imbalanced data, there is a traditional approach of resampling the dataset in both directions, either by oversampling the minority class or randomly deleting rows of the majority class in an undersampling exercise. More documentation on these procedures is provided in the <em class="italic">Further </em><span class="No-Break"><em class="italic">reading</em></span><span class="No-Break"> section.</span></p>
<h2 id="_idParaDest-186">Present<a id="_idTextAnchor304"/>ing results</h2>
<p>Data practitioners <a id="_idIndexMarker630"/>must possess strong communication skills to ensure that their findings are easily comprehensible for decision-making colleagues, clients, and in general, anyone who consumes these insights. It’s crucial to tailor the presentation of findings based on <span class="No-Break">the audience.</span></p>
<p>We can present the analysis with a <strong class="old">dashboard</strong>, which we learned earlier in the book how to build with Dune analytics, Flipside, or Covalent. It’s worth noting that not all visual analytics platforms offer the flexibility to query on-chain data; some are restricted to traditional databases. Platforms such as Tableau and Power BI are highly flexible, connecting with APIs and handling complex SQL queries from <span class="No-Break">on-chain data.</span></p>
<p>We can also make use of corporate <strong class="old">slide</strong> presentations, and<a id="_idIndexMarker631"/> informal <strong class="old">X (formerly Twitter) threads</strong> can be employed to convey the results of data analysis. Regardless of the chosen medium, the goal is to capture and maintain the audience’s interest. Starting with a compelling question and introductory sentence, keeping sentences concise, and delving into details only if the audience shows interest are key principles. A valuable resource on crafting engaging stories can be found in this X <span class="No-Break">thread: </span><a href="https://twitter.com/alexgarcia_atx/status/1381066483330117632"><span class="No-Break">https://twitter.com/alexgarcia_atx/status/1381066483330117632</span></a><span class="No-Break">.</span></p>
<p>Regardless of the presentation platform, storytelling skills are paramount in delivering findings with a <span class="No-Break">compelling narrative.</span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor305"/>Summary</h1>
<p>In conclusion, we have identified and discussed one of the key threats in the cryptocurrency space, highlighting the need for effective transaction monitoring and identification. To this end, we have undertaken a machine learning exercise at the Ethereum address level, where we have leveraged Etherscan to complete <span class="No-Break">our dataset.</span></p>
<p>We have evaluated and compared various machine learning models, optimizing their performance through grid search hyperparameter tuning and cross-validation. By undertaking this project, we have dived into a subject matter where forensics professionals are active and remains a current <span class="No-Break">news topic.</span></p>
<p>Blockchain forensics is one of the more innovative areas in data science applications, as models need to scale and keep evolving in order to adapt, to be able to spot new types of fraud and scams. </p>
<p>In the next chapter, we will dive into <span class="No-Break">predicting prices.</span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor306"/>Further reading</h1>
<p>Following is a list of sources for your further <span class="No-Break">reading purposes:</span></p>
<ul>
<li>PwC. (2022). PwC’s Global Economic Crime and Fraud Survey <span class="No-Break">2022. </span><a href="https://www.pwc.com/gx/en/forensics/gecsm-2022/PwC-Global-Economic-Crime-and-Fraud-Survey-2022.pdf"><span class="No-Break">https://www.pwc.com/gx/en/forensics/gecsm-2022/PwC-Global-Economic-Crime-and-Fraud-Survey-2022.pdf</span></a></li>
<li>Furneaux, N. (2018). <em class="italic">Investigating cryptocurrencies: Understanding, extracting, and analyzing blockchain evidence</em>. John Wiley &amp; Sons. <span class="No-Break">Page 268.</span></li>
<li>Sfarrugia15/Ethereum_Fraud_Detection. (n.d.). <span class="No-Break">GitHub: </span><a href="https://github.com/sfarrugia15/Ethereum_Fraud_Detection"><span class="No-Break">https://github.com/sfarrugia15/Ethereum_Fraud_Detection</span></a></li>
<li>Steven Farrugia, Joshua Ellul, George Azzopardi, <em class="italic">Detection of illicit accounts over the Ethereum blockchain, Expert Systems with Applications</em>, volume 150, 2020, 113318, ISSN <span class="No-Break">0957-4174: </span><a href="https://doi.org/10.1016/j.eswa.2020.113318"><span class="No-Break">https://doi.org/10.1016/j.eswa.2020.113318</span></a><span class="No-Break">.</span></li>
<li><em class="italic">Exploiting Blockchain data to detect Smart Contract Ponzi Schemes on Ethereum</em>. (2019, March 18). IEEE <span class="No-Break">Xplore: </span><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668768"><span class="No-Break">https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668768</span></a></li>
<li>Ethereum security and scam prevention. (n.d.). <span class="No-Break">ethereum.org. </span><a href="https://ethereum.org/en/security/"><span class="No-Break">https://ethereum.org/en/security/</span></a></li>
<li>Senilov, I. (2021, September 27). <em class="italic">Approaching anomaly detection in transactional data</em>. <span class="No-Break">Medium: </span><a href="https://towardsdatascience.com/approaching-anomaly-detection-in-transactional-data-744d132d524e"><span class="No-Break">https://towardsdatascience.com/approaching-anomaly-detection-in-transactional-data-744d132d524e</span></a></li>
<li>Janiobachmann. (2019, July 3). <em class="italic">Credit fraud || Dealing with Imbalanced datasets</em>. Kaggle: Your Machine Learning and Data Science <span class="No-Break">Community: </span><a href="https://www.kaggle.com/code/janiobachmann/credit-fraud-dealing-with-imbalanced-datasets"><span class="No-Break">https://www.kaggle.com/code/janiobachmann/credit-fraud-dealing-with-imbalanced-datasets</span></a></li>
<li>Jason Brownlee. (2020). <em class="italic">Random Oversampling and Undersampling for Imbalanced Classification</em>. Machine Learning <span class="No-Break">Mastery:</span><span class="No-Break"><span class="hidden"> </span></span><a href="https://machinelearningmastery.com/random-oversampling-and-undersampling-for-imbalanced-classification/"><span class="No-Break">https://machinelearningmastery.com/random-oversampling-and-undersampling-for-imbalanced-classification/</span></a></li>
<li><strong class="old">Clustering</strong>: Once we have clustered addresses, it is possible to build an anomaly detection identifier that takes as normality the parameters of the cluster to which each <span class="No-Break">address belongs.</span><p class="list-inset">Price, W. (2021, May 28). <em class="italic">Clustering Ethereum addresses</em>. <span class="No-Break">Medium: </span><a href="https://towardsdatascience.com/clustering-ethereum-addresses-18aeca61919d"><span class="No-Break">https://towardsdatascience.com/clustering-ethereum-addresses-18aeca61919d</span></a></p></li>
<li>Ethereum_clustering/main.ipynb at master · willprice221/ethereum_clustering. (n.d.). <span class="No-Break">GitHub. </span><a href="https://github.com/willprice221/ethereum_clustering/blob/master/main.ipynb"><span class="No-Break">https://github.com/willprice221/ethereum_clustering/blob/master/main.ipynb</span></a></li>
<li>Storytelling resource: Insider. (2019, June 21). <em class="italic">Pixar’s Secret Formula For Making Perfect Films | The Art Of Film</em> [Video]. <span class="No-Break">YouTube: </span><a href="https://www.youtube.com/watch?v=Y34eshkxE5o"><span class="No-Break">https://www.youtube.com/watch?v=Y34eshkxE5o</span></a></li>
</ul>
</div>
</div></body></html>