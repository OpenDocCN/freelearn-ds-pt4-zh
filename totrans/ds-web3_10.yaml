- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Primer on Security and Fraud Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “All warfare is based on deception.” - Sun Tzu
  prefs: []
  type: TYPE_NORMAL
- en: The history of fraud is as old as time. Fraud in the crypto world comes as no
    surprise, and as crypto gains mainstream adoption, it becomes increasingly necessary
    to be aware of the different forms of fraud in order to be able to identify it.
  prefs: []
  type: TYPE_NORMAL
- en: Fraud is a significant issue for businesses in general, for governments, and
    for the blockchain industry in particular. According to the 2022 PwC Global Annual
    Review on fraud, 46% of surveyed organizations reported experiencing some form
    of fraud or economic crime within the last 24 months.
  prefs: []
  type: TYPE_NORMAL
- en: Governments are aware of the issue for tax purposes, as well as to combat money
    laundering and terrorism financing. Relevant agencies have a mandate to enforce
    the law and combat such illicit activity even if cryptocurrencies are involved.
    Due diligence is required for all subjects associated with financial activity
    or money services businesses, a concept that has expanded to include centralized
    exchanges. That is the reason why major **centralized exchanges** (**CEXs**) only
    open accounts for new users when the person behind the ID is validated. Compliance
    with certain quality standards is essential, and failure to comply can lead to
    sanctions.
  prefs: []
  type: TYPE_NORMAL
- en: The crypto industry is also interested in solidifying trust in compliance with
    robust smart contracts and a seamless experience while transacting. Smart contract
    breaches, scam schemes, and the use of cryptocurrencies as payment for hacks have
    not helped in this pursuit. Data science has been helping to solve this issue
    for some time now. The challenge has been adapting the data science practice for
    the blockchain dataset, which is rather different and pseudo-anonymous. Some interesting
    companies such as Chainalysis, Elliptic, and CipherTrace are at the forefront
    of forensic data science in blockchain, helping authorities in investigations
    and supporting general user trust.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine the transaction behavior of addresses to train
    a machine learning model that can determine whether or not we are dealing with
    a scammer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Particularly, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What illicit activity looks like on Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploratory data analysis of transactional data on Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparation, model training, and evaluation to flag fraudulent transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the data and code files for this chapter in the book’s GitHub
    repository at [https://github.com/PacktPublishing/Data-Science-for-Web3/tree/main/Chapter10](https://github.com/PacktPublishing/Data-Science-for-Web3/tree/main/Chapter10).
    We recommend that you read through the code files in the `Chapter10` folder to
    follow along.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the Ethereum Utilities library (`eth-utils`), which
    contains commonly used utility functions for Python developers working with Ethereum.
    Depending on our environment, we may need to import additional low-level libraries
    that are utilized by `eth-utils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed `eth-utils` yet, you can do so using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The documentation for `eth-utils` is available at [https://eth-utils.readthedocs.io/en/stable/](https://eth-utils.readthedocs.io/en/stable/).
    If the installation fails due to a lack of supporting libraries, you can find
    the complete list of required libraries that need to be pre-installed in `Chapter10/EDA.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: A primer on illicit activity on Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a technical difference between fraud and a scam. A scam is an act where
    we unknowingly pay for a fake item, transfer money, or provide our private keys
    to a criminal. Conversely, fraud refers to any suspicious activity on our address
    that we did not authorize. In this book, we will use both terms interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ethereum Security blog has three key messages for anyone starting in the
    crypto industry:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always* *be skeptical*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*No one is going to give you free or* *discounted ETH*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*No one needs access to your private keys or* *personal information*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As of today, some of the most common scams include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giveaway scams**: These basically work by criminals promising that if we
    send *X* amount of crypto to an address, it will be returned to us but doubled
    in amount. These schemes are often psychological, offering the victim only a limited
    amount of time to participate in this “opportunity,” generating a **fear of missing
    out** (**FOMO**) effect. This scheme often uses high-profile X (formerly Twitter)
    accounts, videos of celebrities, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IT support scams**: These scammers impersonate IT support or admin personnel
    from blockchain services, such as wallets, exchanges, marketplaces, or even a
    chain. They may ask for some information from us or to validate our ID and, in
    general, will try to get the minimum necessary information to extract our funds.
    These sorts of scammers can be found mostly on Discord discussion channels or
    Telegram. It is very usual to see next to real people’s names the phrase “*Never
    DM first*.” Scammers will write first, trying to generate a connection and trust.
    It is worth remembering that Web3 is a decentralized landscape, so it is unlikely
    that support teams will be scanning the internet to answer our questions. If we
    were interacting with a centralized platform with a support team in place, the
    team would always contact us through official channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phishing scams**: This is a type of social engineering attack that uses impersonation
    through email to convince the victim to provide the necessary information to commit
    the fraud. The email will usually contain links that redirect to fake websites
    or download malicious malware. As we saw in [*Chapter 3*](B19446_03.xhtml#_idTextAnchor114),
    when detailing where to go for off-chain data, we should try to access websites
    following a trusted link – for example, through CoinMarketCap or CoinGecko. There
    are many ways to detect phishing, but the reality is that they are becoming more
    creative over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broker scams**: These are trading brokers with a lot of followers on social
    media who allegedly generate outstanding profits. A real person is behind the
    account of a broker, who will interact with the victim until the latter sends
    their funds to be “managed” by the broker. Once sent, those funds are lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these scams is further explained with real-life examples on this blog:
    [https://ethereum.org/en/security/](https://ethereum.org/en/security/).'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the fraudulent scheme, money will be transferred through a transaction
    and saved in an account. In the next section, we will analyze account behavior
    to try to determine which account can be trusted and which should be flagged as
    a scam.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be working with a balanced dataset that was used in the paper *Detection
    of illicit accounts over the Ethereum blockchain*. You can find the link to the
    paper in the *Further reading* section. This dataset is a balanced dataset, with
    48 columns or features that combine licit and illicit accounts. The dataset was
    created by using the CryptoScamDB database and Etherscan; the latter is a tool
    that we are already familiar with. [cryptoscamdb.org](http://cryptoscamdb.org)
    manages an open source dataset that tracks malicious URLs and their associated
    addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The columns and their description as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Avg_min_between_sent_tnx` | The average time between sent transactions for
    an account in minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `Avg_min_between_received_tnx` | The average time between received transactions
    for an account in minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `Time_Diff_between_first_and_last(Mins)` | The time difference between the
    first and last transaction |'
  prefs: []
  type: TYPE_TB
- en: '| `Sent_tnx` | The total number of sent normal transactions |'
  prefs: []
  type: TYPE_TB
- en: '| `Received_tnx` | The total number of received normal transactions |'
  prefs: []
  type: TYPE_TB
- en: '| `Number_of_Created_Contracts` | The total number of created contract transactions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Unique_Received_From_Addresses` | The total unique addresses from which
    the account received transactions |'
  prefs: []
  type: TYPE_TB
- en: '| `Unique_Sent_To_Addresses` | The total unique addresses from which the account
    sent transactions |'
  prefs: []
  type: TYPE_TB
- en: '| `Min_Value_Received` | The minimum value in Ether ever received |'
  prefs: []
  type: TYPE_TB
- en: '| `Max_Value_Received` | The maximum value in Ether ever received |'
  prefs: []
  type: TYPE_TB
- en: '| `Avg_Value_Received` | The average value in Ether ever received |'
  prefs: []
  type: TYPE_TB
- en: '| `Min_Val_Sent` | The minimum value of Ether ever sent |'
  prefs: []
  type: TYPE_TB
- en: '| `Max_Val_Sent` | The maximum value of Ether ever sent |'
  prefs: []
  type: TYPE_TB
- en: '| `Avg_Val_Sent` | The average value of Ether ever sent |'
  prefs: []
  type: TYPE_TB
- en: '| `Min_Value_Sent_To_Contract` | The minimum value of Ether sent to a contract
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Max_Value_Sent_To_Contract` | The maximum value of Ether sent to a contract
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Avg_Value_Sent_To_Contract` | The average value of Ether sent to contracts
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Total_Transactions(Including_Tnx_to_Create_Contract)` | The total number
    of transactions |'
  prefs: []
  type: TYPE_TB
- en: '| `Total_Ether_Sent` | The total Ether sent for an account address |'
  prefs: []
  type: TYPE_TB
- en: '| `Total_Ether_Received` | The total Ether received for an account address
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Total_Ether_Sent_Contracts` | The total Ether sent to contract addresses
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Total_Ether_Balance` | The total Ether balance following enacted transactions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Total_ERC20_Tnxs` | The total number of ERC20 token transfer transactions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Total_Ether_Received` | The total ERC20 token-received transactions
    in Ether |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Total_Ether_Sent` | The total ERC20 token-sent transactions in Ether
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Total_Ether_Sent_Contract` | The total number of ERC20 tokens transferred
    to other contracts in Ether |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Uniq_Sent_Addr` | The number of ERC20 token transactions sent to unique
    account addresses |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Uniq_Rec_Addr` | The number of ERC20 token transactions received from
    unique addresses |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Uniq_Rec_Contract_Addr` | The number of ERC20 token transactions received
    from unique contract addresses |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Avg_Time_Between_Sent_Tnx` | The average time between ERC20 token-sent
    transactions in minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Avg_Time_Between_Rec_Tnx` | The average time between ERC20 token-received
    transactions in minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Avg_Time_Between_Contract_Tnx` | The average time ERC20 token between
    sent token transactions |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Min_Val_Rec` | The minimum value in Ether received from ERC20 token
    transactions for an account |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Max_Val_Rec` | The maximum value in Ether received from ERC20 token
    transactions for an account |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Avg_Val_Rec` | The average value in Ether received from ERC20 token
    transactions for an account |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Min_Val_Sent` | The minimum value in Ether sent from ERC20 token transactions
    for an account |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Max_Val_Sent` | The maximum value in Ether sent from ERC20 token transactions
    for an account |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Avg_Val_Sent` | The average value in Ether sent from ERC20 token transactions
    for an account |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Uniq_Sent_Token_Name` | The number of unique ERC20 tokens transferred
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Uniq_Rec_Token_Name` | The number of unique ERC20 tokens received
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Most_Sent_Token_Type` | The most sent token for an account via an
    ERC20 transaction |'
  prefs: []
  type: TYPE_TB
- en: '| `ERC20_Most_Rec_Token_Type` | The most received token for an account via
    an ERC20 transaction |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – An explanation of each dataset column (source – from page 10 of
    the paper, Detection of illicit accounts over the Ethereum blockchain)
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Chapter10/EDA.ipynb`, we analyzed the dataset and came to the following
    conclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: There are 4,681 accounts and 48 features. Within these addresses, there are
    five duplicated addresses and five invalid addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To determine whether an address is valid or invalid, we use part of the code
    of EIP-55, combined with a custom formula named `address_validation()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`address_validation()` function, we add an additional condition to count the
    characters of each address, discarding those that are not 42 characters.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If both conditions are met, the address is considered valid, and the checksummed
    version is returned. Otherwise, a `not an ethereum address` flag is returned:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are some missing values from columns 25 to 49\. The percentage of null
    values is 17.7%. We identify any missing values in the dataframe, calculating
    the percentage of missing values for each column in the dataframe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The fraudulent transactions and missing values are at the top of the dataset.
    The most fraudulent accounts seem to have missing values. Refer to the heatmap
    at `Chapter10/EDA.ipynb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are 12 columns with little variance (and only one value, which is zero).
    Columns with little variance may not be helpful for our training. These columns
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[''min_value_sent_to_contract'', ''max_val_sent_to_contract'', ''avg_value_sent_to_contract'',
    ''total_ether_sent_contracts'', ''ERC20_avg_time_between_sent_tnx'', ''ERC20_avg_time_between_rec_tnx'',
    ''ERC20_avg_time_between_rec_2_tnx'', ''ERC20_avg_time_between_contract_tnx'',
    ''ERC20_min_val_sent_contract'', ''``ERC20_max_val_sent_contract'', ''ERC20_avg_val_sent_contract'']`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We identify these columns using the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After cleaning duplicates and invalids, there are 2,497 non-fraudulent accounts
    and 2,179 fraudulent accounts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We ran a correlation matrix and discovered that five columns are heavily correlated.
    These columns are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[''ERC20_max_val_rec'', ''ERC20_min_val_sent'', ''ERC20_max_val_sent'', ''``ERC20_avg_val_sent'',
    ''ERC20_uniq_rec_token_name'']`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dropping columns with similar information is important because redundant information
    does not add value to our training; rather, it can make our algorithm learn slower
    and complicate the interpretability of our model if we have to explain it. Multicollinearity
    can also affect certain models, such as linear models. Refer to the heatmap for
    correlations at `Chapter10/EDA.ipynb`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The two columns with categorical data (`ERC20_most_sent_token_type` and `ERC20_most_rec_token_type`)
    are heavily sparse, with most tokens appearing only once or being blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we group by ERC token, there is no clear category that could be useful.
    One-hot-encoding these columns may result in a heavily sparse training dataset.
    Additionally, new tokens are being minted every day, and adding this information
    to our model would create a variable that becomes outdated quickly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Based on the conclusions reached from the preceding analysis, we cleaned up
    the data to adapt it to our needs. The following steps were taken:'
  prefs: []
  type: TYPE_NORMAL
- en: We dropped duplicated addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We tried to populate missing values from Etherscan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dropped low-variance columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dropped columns with 0.95 or more correlation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dropped the `object`-type columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dropped the `Address` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We refilled NaNs with the median.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s expand the preprocessing from *step 2*, which involves populating missing
    values from Etherscan. Real-life datasets tend to be incomplete. It is the job
    of data analysts or data scientists to complement those columns that are partially
    complete. There are several methodologies to do that, and we explored the traditional
    ones in [*Chapter 5*](B19446_05.xhtml#_idTextAnchor168) when no further data is
    available.
  prefs: []
  type: TYPE_NORMAL
- en: In `Chapter10_Rebuilding`, we tried another methodology that involves going
    to the source and looking for the missing data. Throughout this book, we have
    listed multiple sources, and as more progress is made in this area, new sources
    of on-chain data will become available, helping us complete our datasets. Additionally,
    specialization in Web3 will enable us to make inferences over data because we
    can understand it. This is particularly helpful when the data point we need to
    reflect in the dataset is indirect or does not stem directly from on-chain data.
  prefs: []
  type: TYPE_NORMAL
- en: In the dataset extracted from the paper, *Detection of illicit accounts over
    the Ethereum blockchain*, 17% of the rows had missing data. To complement the
    paper, we used one of the data sources we have been analyzing for some time now
    – Etherscan. We leveraged the free tier of their API and were able to complement
    most of the rows. The link to the API documentation is [https://docs.etherscan.io/](https://docs.etherscan.io/).
    The steps to complement those columns are outlined in `Chapter10_Rebuilding`,
    where we extracted the missing data points and appended them to the dataframe.
    If Etherscan has no trace, we can infer that the address did not carry out such
    a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: After this process, a few null rows remained that we complemented with the median
    of the column. With this final step, we have a complete dataset ready for training.
  prefs: []
  type: TYPE_NORMAL
- en: '`.csv` file has been uploaded to the book''s GitHub and is accessible at `final.csv`.'
  prefs: []
  type: TYPE_NORMAL
- en: A note on great preprocessing
  prefs: []
  type: TYPE_NORMAL
- en: A great example of data building and preprocessing in this space is related
    to a dataset constructed for the paper *Exploiting Blockchain Data to Detect Smart
    Ponzi Schemes on Ethereum* (the link to the paper is provided in the *Further
    reading* section). The aim of the paper is to train a machine learning algorithm
    to classify Ponzi schemes’ smart contracts. To achieve this, the researchers built
    a dataset comprising 200 Ponzi smart contracts and 3,580 non-Ponzi ones. For each
    contract, they extracted the bytecodes, transaction data, and internal transactions.
    Since internal transactions are not stored on-chain, the research team reran an
    Ethereum client to reproduce them. Additionally, to convert bytecodes into meaningful
    features or categories, the team translated them to opcode and included the frequency
    of each one in the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Training the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have finished cleaning and preprocessing the data, we shuffle the dataset
    and then split it into separate train and test datasets. Then, we iterate through
    several models that have performed well on binary classification tasks, including
    `KNeighborsClassifier`, `DecisionTreeClassifier`, `AdaBoostClassifier`, `GradientBoostingClassifier`,
    and `RandomForestClassifier`.
  prefs: []
  type: TYPE_NORMAL
- en: However, just because a model performs well on one dataset doesn’t mean it will
    work well on another. This is where tuning the model becomes important. Machine
    learning models have hyperparameters that need to be modified to adapt to the
    specific data. Customizing these hyperparameters to our dataset will improve the
    performance of the model. In order to execute this optimization, there are some
    available tools, such as scikit-learn GridSearchCV.
  prefs: []
  type: TYPE_NORMAL
- en: '`best_estimator_` returned by the `GridSearchCV` will be contained within it.
    In cases where we have no idea which parameters to choose, we can run `RandomizedSearchCV`
    defines a search space and randomly tests it. The documentation for both classes
    can be found at [https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.xhtml](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.xhtml)
    and [https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.xhtml](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Both `GridSearchCV` and `RandomizedSearchCV` have a `cv` parameter that refers
    to cross-validation. `K` bins of equal size to run `K` number of learning experiments.
    The results are then averaged to reduce the randomness of a model’s performance
    and make it more robust. This class is typically contained in other implementations
    such as grid search. However, it can also be used independently.
  prefs: []
  type: TYPE_NORMAL
- en: There are variations such as Stratified *K* fold, which ensures that each split
    contains the same proportion of observations of each class, and Repeated *K* fold,
    which repeats the exercise for each fold but shuffles each partition to make it
    a new sample every time. The documentation for these procedures can be found at
    [https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.xhtml](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The result of our training shows a best-performing model on `GradientBoostingClassifier`.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a confusion matrix to show the model’s performance, as it is highly
    useful for binary classification problems. The choice of evaluation metric will
    depend on the type of problem being addressed. In the case of fraud detection,
    we want to ensure that the false negative rate is minimized, so we will use **recall**
    as the evaluation metric. A detailed explanation of evaluation metrics was provided
    in [*Chapter 5*](B19446_05.xhtml#_idTextAnchor168).
  prefs: []
  type: TYPE_NORMAL
- en: The result is 95.6% in the overall project, which is a good number.
  prefs: []
  type: TYPE_NORMAL
- en: An imbalanced dataset
  prefs: []
  type: TYPE_NORMAL
- en: A similar dataset is also available on Kaggle and was initially analyzed by
    us in [*Chapter 6*](B19446_06.xhtml#_idTextAnchor210). This dataset is in an imbalanced
    form, as only 20% of the rows are fraudulent. It is common for fraud detection
    tasks to be associated with imbalanced data, as there are typically more regular
    transactions than fraudulent ones. Some models may overlook minority classes,
    which can sometimes include the specific class we are interested in detecting.
    To address imbalanced data, there is a traditional approach of resampling the
    dataset in both directions, either by oversampling the minority class or randomly
    deleting rows of the majority class in an undersampling exercise. More documentation
    on these procedures is provided in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data practitioners must possess strong communication skills to ensure that their
    findings are easily comprehensible for decision-making colleagues, clients, and
    in general, anyone who consumes these insights. It’s crucial to tailor the presentation
    of findings based on the audience.
  prefs: []
  type: TYPE_NORMAL
- en: We can present the analysis with a **dashboard**, which we learned earlier in
    the book how to build with Dune analytics, Flipside, or Covalent. It’s worth noting
    that not all visual analytics platforms offer the flexibility to query on-chain
    data; some are restricted to traditional databases. Platforms such as Tableau
    and Power BI are highly flexible, connecting with APIs and handling complex SQL
    queries from on-chain data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make use of corporate **slide** presentations, and informal **X
    (formerly Twitter) threads** can be employed to convey the results of data analysis.
    Regardless of the chosen medium, the goal is to capture and maintain the audience’s
    interest. Starting with a compelling question and introductory sentence, keeping
    sentences concise, and delving into details only if the audience shows interest
    are key principles. A valuable resource on crafting engaging stories can be found
    in this X thread: [https://twitter.com/alexgarcia_atx/status/1381066483330117632](https://twitter.com/alexgarcia_atx/status/1381066483330117632).'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the presentation platform, storytelling skills are paramount in
    delivering findings with a compelling narrative.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, we have identified and discussed one of the key threats in the
    cryptocurrency space, highlighting the need for effective transaction monitoring
    and identification. To this end, we have undertaken a machine learning exercise
    at the Ethereum address level, where we have leveraged Etherscan to complete our
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: We have evaluated and compared various machine learning models, optimizing their
    performance through grid search hyperparameter tuning and cross-validation. By
    undertaking this project, we have dived into a subject matter where forensics
    professionals are active and remains a current news topic.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain forensics is one of the more innovative areas in data science applications,
    as models need to scale and keep evolving in order to adapt, to be able to spot
    new types of fraud and scams.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into predicting prices.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is a list of sources for your further reading purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: PwC. (2022). PwC’s Global Economic Crime and Fraud Survey 2022\. [https://www.pwc.com/gx/en/forensics/gecsm-2022/PwC-Global-Economic-Crime-and-Fraud-Survey-2022.pdf](https://www.pwc.com/gx/en/forensics/gecsm-2022/PwC-Global-Economic-Crime-and-Fraud-Survey-2022.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furneaux, N. (2018). *Investigating cryptocurrencies: Understanding, extracting,
    and analyzing blockchain evidence*. John Wiley & Sons. Page 268.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sfarrugia15/Ethereum_Fraud_Detection. (n.d.). GitHub: [https://github.com/sfarrugia15/Ethereum_Fraud_Detection](https://github.com/sfarrugia15/Ethereum_Fraud_Detection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Steven Farrugia, Joshua Ellul, George Azzopardi, *Detection of illicit accounts
    over the Ethereum blockchain, Expert Systems with Applications*, volume 150, 2020,
    113318, ISSN 0957-4174: [https://doi.org/10.1016/j.eswa.2020.113318](https://doi.org/10.1016/j.eswa.2020.113318).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Exploiting Blockchain data to detect Smart Contract Ponzi Schemes on Ethereum*.
    (2019, March 18). IEEE Xplore: [https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668768](https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668768)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum security and scam prevention. (n.d.). ethereum.org. [https://ethereum.org/en/security/](https://ethereum.org/en/security/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Senilov, I. (2021, September 27). *Approaching anomaly detection in transactional
    data*. Medium: [https://towardsdatascience.com/approaching-anomaly-detection-in-transactional-data-744d132d524e](https://towardsdatascience.com/approaching-anomaly-detection-in-transactional-data-744d132d524e)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Janiobachmann. (2019, July 3). *Credit fraud || Dealing with Imbalanced datasets*.
    Kaggle: Your Machine Learning and Data Science Community: [https://www.kaggle.com/code/janiobachmann/credit-fraud-dealing-with-imbalanced-datasets](https://www.kaggle.com/code/janiobachmann/credit-fraud-dealing-with-imbalanced-datasets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jason Brownlee. (2020). *Random Oversampling and Undersampling for Imbalanced
    Classification*. Machine Learning Mastery: [https://machinelearningmastery.com/random-oversampling-and-undersampling-for-imbalanced-classification/](https://machinelearningmastery.com/random-oversampling-and-undersampling-for-imbalanced-classification/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clustering**: Once we have clustered addresses, it is possible to build an
    anomaly detection identifier that takes as normality the parameters of the cluster
    to which each address belongs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Price, W. (2021, May 28). *Clustering Ethereum addresses*. Medium: [https://towardsdatascience.com/clustering-ethereum-addresses-18aeca61919d](https://towardsdatascience.com/clustering-ethereum-addresses-18aeca61919d)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ethereum_clustering/main.ipynb at master · willprice221/ethereum_clustering.
    (n.d.). GitHub. [https://github.com/willprice221/ethereum_clustering/blob/master/main.ipynb](https://github.com/willprice221/ethereum_clustering/blob/master/main.ipynb)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storytelling resource: Insider. (2019, June 21). *Pixar’s Secret Formula For
    Making Perfect Films | The Art Of Film* [Video]. YouTube: [https://www.youtube.com/watch?v=Y34eshkxE5o](https://www.youtube.com/watch?v=Y34eshkxE5o)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
