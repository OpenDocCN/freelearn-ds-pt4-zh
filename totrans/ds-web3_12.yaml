- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Marketing Discovery with Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data has played a pivotal role in marketing, empowering decision-making, and
    optimizing resource allocation for impactful campaigns. However, the inherent
    pseudonymity and complexities of blockchain data pose challenges for marketing
    teams where extracting maximum value is, in many cases, an ongoing opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main applications that’s used by marketing teams is clustering, which
    involves organizing groups with shared interests for customer segmentation. This
    technique was very successful primarily in social networks, facilitating recommendation
    systems for products and fostering new connections.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to social networks, blockchain data, with its wealth of transactions,
    holds immense potential to deduce preferences from a few interactions. Label classification
    is another valuable use case, allowing marketing teams to identify and target
    communities within the blockchain effectively. By discerning communities, data
    scientists can help marketers overcome the limitations of pseudonymity and gain
    valuable insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A primer on graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database selection and feature engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling, training, and evaluating the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have had a comprehensive introduction to
    harnessing the power of networks and graphs for effective marketing strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will utilize the `networkx` library, a Python library that’s
    used for working with networks or graphs. It offers a range of tools and functions
    for creating, manipulating, and analyzing networks. This library facilitates node
    creation, adding information, and providing algorithms for analyzing and exploring
    networks, such as finding the shortest paths, calculating centrality measures,
    and detecting communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not worked with `networkx` before, it can be installed using the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The documentation for `networkx` can be found at [https://networkx.org/documentation/stable/index.xhtml](https://networkx.org/documentation/stable/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: We will also use **Gephi**, a free open source tool for graph plotting. Gephi
    is a user-friendly tool that’s designed for visualizing and exploring graphs and
    networks. It assists users in gaining insights and analyzing complex relationships
    within graph data.
  prefs: []
  type: TYPE_NORMAL
- en: With Gephi, we can import data from various formats and select specific nodes
    to understand their positions in our dataset. The tool provides numerous statistical
    functionalities to support graph analysis. It allows us to filter, sort, and manipulate
    the graph based on specific criteria, enabling us to focus on relevant nodes and
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not worked with Gephi before, it can be downloaded from their page
    at [https://gephi.org/](https://gephi.org/). A comprehensive guide to Gephi is
    available in the book *Gephi Cookbook*, accessible at [https://www.packtpub.com/product/gephi-cookbook/9781783987405](https://www.packtpub.com/product/gephi-cookbook/9781783987405).
  prefs: []
  type: TYPE_NORMAL
- en: For our machine learning model, we will utilize the StellarGraph library. StellarGraph
    is designed for working with graph-structured data, specifically for tasks related
    to machine learning and data analysis. One of its key features is its integration
    with popular machine learning frameworks such as TensorFlow and Keras. StellarGraph
    provides methods to convert graphs into formats compatible with these frameworks,
    allowing us to apply machine learning models and algorithms to graph-structured
    data. The documentation for StellarGraph can be found at [https://stellargraph.readthedocs.io/en/stable/](https://stellargraph.readthedocs.io/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the first time you’re using this library, you can install it with
    `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All the data and code files related to this chapter, as well as the color images
    can be found in this book’s GitHub repository at https://github.com/PacktPublishing/Data-Science-for-Web3/tree/main/Chapter12.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you read through the code files in the `Chapter12` folder
    so that you can follow along with this chapter effectively.
  prefs: []
  type: TYPE_NORMAL
- en: A primer on graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Innar Liiv, “*Network science, sometimes considered a subfield
    of data science and sometimes an independent academic field, is a set of techniques,
    methods, and tools to study patterns in networked structures.*” An example of
    a network is the image of the London underground map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – An overview of Beck’s design for the London underground map
    (source: https://en.wikipedia.org/wiki/File:Beck_Map_1933.jpg found under fair
    use)](img/B19446_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1 – An overview of Beck’s design for the London underground map (source:
    [https://en.wikipedia.org/wiki/File:Beck_Map_1933.jpg](https://en.wikipedia.org/wiki/File:Beck_Map_1933.jpg)
    found under fair use)'
  prefs: []
  type: TYPE_NORMAL
- en: In our exploration of networks and graphs, we will use these terms interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: The study of networks has gained significant interest in recent years due to
    their ability to explain relationships between entities simply. As explained by
    Professor Matías Avila, “*A network, also called a graph in the mathematical literature,
    is a collection of nodes where some pairs are connected* *by edges.*”
  prefs: []
  type: TYPE_NORMAL
- en: In this primer, we will explore fundamental concepts of graphs, including their
    definition and features.
  prefs: []
  type: TYPE_NORMAL
- en: A network consists of nodes (also referred to as vertices or V) that are linked
    together (by connections or edges or E). The graph or network is commonly denoted
    as G, with the notation G=(V,E).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 12**.2*, we can observe the components of the graph within the network
    formed between addresses `0xdac17f958d2ee523a2206206994597c13d831ec7` and `0x28C6c06298d514Db089934071355E5743bf21d60`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The relationship between two addresses](img/B19446_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – The relationship between two addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'The role of a data analyst is to derive meaning and actionable insights from
    data. Once we have found a meaningful connection, it is important to add context.
    For example, in the graph shown in *Figure 12**.3*, we are looking at the relationship
    between a USDT smart contract and a Binance address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The relationship between two labeled addresses](img/B19446_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – The relationship between two labeled addresses
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Directed graphs** (**digraphs**), as defined by Stamile, Marzullo, and Deusebio,
    are represented as “*A couple, G=(V,E), where V is a set of nodes and E is a set
    of ordered couples representing the connection between two nodes.*” The elements
    of E are ordered, indicating a direction from one node (usually referred to as
    the “source”) to another node (usually referred to as the “target”):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – An example of a digraph](img/B19446_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – An example of a digraph
  prefs: []
  type: TYPE_NORMAL
- en: In **digraphs**, nodes can be classified as indegree (the number of incoming
    edges to a node, representing the nodes in the graph that have directed edges
    pointing toward it) and outdegree (the number of outgoing edges from a node, representing
    the nodes in the graph that the given node has directed edges pointing toward).
    Indegree and outdegree provide insights into the connectivity and influence of
    nodes in a directed graph. Understanding this concept is valuable for various
    graph analysis tasks, such as identifying central nodes, studying information
    flow, detecting influential nodes, and assessing the structure and dynamics of
    directed networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **ego graph**, also known as a neighborhood graph, focuses on a specific
    node called the “ego” node. It displays the ego node and all its neighboring nodes,
    along with the edges connecting them. Ego graphs are useful for analyzing the
    local structure and connections around a specific node of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – An example of an ego graph](img/B19446_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – An example of an ego graph
  prefs: []
  type: TYPE_NORMAL
- en: 'A **weighted graph** is a graph where each edge has an associated weight or
    value. The weights are numerical values that can represent various features of
    the relationship between the connected nodes, such as strength, distance, cost,
    frequency of connection, and so on. The weights provide additional information
    that can be used for analysis, training, and inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – An example of a weighted graph](img/B19446_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – An example of a weighted graph
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other graph patterns with their own characteristics and uses
    that are outside the scope of this introduction. But why are graph patterns important
    for our data analysis? Graph patterns help reveal the dynamics of relationships
    between addresses in the blockchain. In an article titled *Visualizing Dynamic
    Bitcoin Transaction Patterns*, the authors break down these patterns and provide
    corresponding explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Examples of graph patterns in a Bitcoin block](img/B19446_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Examples of graph patterns in a Bitcoin block
  prefs: []
  type: TYPE_NORMAL
- en: Attribution
  prefs: []
  type: TYPE_NORMAL
- en: '*Visualizing Dynamic Bitcoin Transaction Patterns*, Dan McGinn et al. 2016;
    Published by Mary Ann Liebert, Inc.'
  prefs: []
  type: TYPE_NORMAL
- en: This open access article is distributed under the terms of the Creative Commons
    license ([http://creativecommons.org/licenses/by/4.0](http://creativecommons.org/licenses/by/4.0)),
    which permits unrestricted use, distribution, and reproduction in any medium,
    provided the original work is properly credited.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the subsequent sections, we will analyze a dataset of addresses belonging
    to two communities with different characteristics – one linked to the OpenSea
    NFT marketplace and the other to a centralized exchange named Binance. The characteristics
    of the relationship that each address has with its community can be seen in the
    pattern formed within the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Relationships between target communities](img/B19446_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Relationships between target communities
  prefs: []
  type: TYPE_NORMAL
- en: Graph properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the categorization proposed by Stamile, Marzullo, and Deusebio, we
    find it helpful to analyze integration metrics and segregation metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration** metrics show how nodes tend to be interconnected with each
    other. Among the metrics, we have the distance and the shortest path.'
  prefs: []
  type: TYPE_NORMAL
- en: The distance is defined as “*The number of edges to traverse to reach a target
    node from a given source node.*” The shortest path is the path with the lowest
    number of edges compared to all the possible paths between two nodes. If the graph
    is weighted, it is a path that holds the minimum sum of edge weights. We are interested
    in this concept because it will help us identify important nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Another metric related to the shortest path is the **characteristic path length**.
    This is defined as the average of all the shortest path lengths between all possible
    pairs of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Another group of metrics is **segregation** metrics, which, as their name implies,
    look for patterns in which ties are more likely to exist between nodes similar
    to each other. They identify the presence of groups of interconnected nodes, known
    as **communities**. Among these metrics, we have the clustering coefficient and
    modularity.
  prefs: []
  type: TYPE_NORMAL
- en: The **clustering coefficient** is a measure of the degree to which nodes tend
    to group (or “cluster”). The rationale is that nodes tend to group with similar
    nodes to a higher degree than with random nodes. It is based on the division of
    triangles or triplets, which consist of three nodes and three edges. It studies
    the proportion in which a node’s neighbors are also neighbors between each other.
    Local and global clustering coefficients exist here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** measures the strength of a network so that it can be divided
    into modules or communities. If the modularity of a network is high, it means
    that there are dense connections between nodes within a community and sparse connections
    between nodes that correspond to different modules. Both the Gephi tool and the
    Networkx library allow us to calculate modularity and identify communities.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.9* shows the dataset that will be introduced in the following
    section painted in two colors, one for each community that’s been detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Dataset communities with Gephi filters applied ](img/B19446_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Dataset communities with Gephi filters applied
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure was created using Gephi with the following filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Topology filter**: Giant component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree range**: Above 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size of nodes**: Betweenness centrality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color of nodes**: Modularity 2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dive into the dataset!
  prefs: []
  type: TYPE_NORMAL
- en: The dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dataset comprises a series of transactions with destinations set to Binance
    or OpenSea. These entities are served by multiple addresses, and for the sake
    of simplicity, we have selected one among the many associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: The Binance 14 address (`0x28c6c06298d514db089934071355e5743bf21d60`) represents
    a Binance hot wallet that is used to facilitate the connection between the centralized
    exchange and Ethereum. The funds in this wallet serve deposits and withdrawals
    outside of Binance.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the address for OpenSea, specifically Wyvern Exchange v2
    (`0x7f268357a8c2552623316e2562d90e642bb538e5`), corresponds to the marketplace
    contract for OpenSea.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replicate this dataset using Flipside, we can use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For the visualizations, we can use the `draw_metric` function proposed in *Graph
    Machine Learning*, which highlights the nodes with the higher value of the metric
    under discussion. The analysis that we will carry out can be found in `Chapter12/features.ipynb`
    and the resulting DataFrame named `influencer_nodes.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Betweenness centrality** is a measure that indicates the number of times
    a node serves as a bridge on the shortest path between other nodes. The larger
    the number of shortest paths between other pairs of objects passing through this
    specific node, the larger the betweenness centrality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, in `influencer_nodes.csv`, we can observe that USDT and **Wrapped
    Ethereum** (**WETH**) stablecoin nodes have high betweenness centrality, each
    connected with Binance and OpenSea, respectively. The following figure shows the
    nodes with higher betweenness centrality highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Betweenness centrality on the dataset](img/B19446_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Betweenness centrality on the dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'The following information was taken from the CSV file, filtered by the `Betweenness`
    `Centrality` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** **or Node** | **Betweenness** **Centrality** | **Label** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x28c6c06298d514db089934071355e5743bf21d60` | `0.494010213` | Binance 14
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x7f268357a8c2552623316e2562d90e642bb538e5` | `0.323956896` | OpenSea: Wyvern
    Exchange v2 |'
  prefs: []
  type: TYPE_TB
- en: '| `0xdac17f958d2ee523a2206206994597c13d831ec7` | `0.173128355` | Tether- USDT
    stablecoin |'
  prefs: []
  type: TYPE_TB
- en: '| `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2` | `0.16215128` | Wrapped Ether
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Data filtered by the Betweenness Centrality column
  prefs: []
  type: TYPE_NORMAL
- en: '**Degree** is the number of connections or nodes that are one link away from
    a specific node. More connected nodes tend to have more power and centrality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `influencer_nodes.csv`, we can see that, connected with Binance, we have
    USDT and USD Coin, and connected with OpenSea, we have WETH and Seaport 1.1 address
    (which is part of the OpenSea infrastructure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Degree on the dataset](img/B19446_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Degree on the dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'The following information was taken from the CSV file, filtered by the `Degree`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** **or Node** | **Degree** | **Label** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x28c6c06298d514db089934071355e5743bf21d60` | `0.370160529` | Binance 14
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x7f268357a8c2552623316e2562d90e642bb538e5` | `0.101038716` | OpenSea: Wyvern
    Exchange v2 |'
  prefs: []
  type: TYPE_TB
- en: '| `0xdac17f958d2ee523a2206206994597c13d831ec7` | `0.094428706` | Tether- USDT
    stablecoin |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48` | `0.046270066` | Circle USD
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2` | `0.16215128` | Wrapped Ether
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000000006c3852cbef3e08e8df289169ede581` | `0.029272899` | Seaport 1.1
    (OpenSea infrastructure) |'
  prefs: []
  type: TYPE_TB
- en: Table 12.2 – Data filtered by the Degree column
  prefs: []
  type: TYPE_NORMAL
- en: '`influencer_nodes.csv`, we can see that the addresses with closer centrality
    are nodes connected between the two addresses with higher betweenness centrality
    (Binance 14 and OpenSea: Wyvern Exchange v2). They work as a bridge between the
    two communities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Closeness centrality on the dataset](img/B19446_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Closeness centrality on the dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'The following information was taken from the CSV file, filtered by the `Closeness`
    `Centrality` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** **or Node** | **Closeness** **Centrality** | **Label** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x411c104dcec01380ee86ea2d090ed3450850f1d6` | `0.33197098` | No label available
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x28c6c06298d514db089934071355e5743bf21d60` | `0.33030801` | Binance 14
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2` | `0.32937989` | Wrapped Ether
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x6e785f2fdbdc899f8f08cc1517f82a585b44f9c5` | `0.32602094` | renethecat.eth
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.3 – Data filtered by the Closeness Centrality column
  prefs: []
  type: TYPE_NORMAL
- en: '**Eigenvalue centrality** shows how influential a node is within a network,
    considering the scoring of the nodes it is connected with. The centrality will
    be higher if it is connected with high-scoring nodes. For this analysis, we need
    to respect communities because nodes will be important within a certain community.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we calculate the Eigenvalue centrality within the Binance community, we
    can see that the USDT stablecoin smart contract and USD Coin have the highest
    eigenvector centrality. The drop in value in the subsequent addresses suggests
    that, generally, the addresses bridge to reach Binance through the stablecoin
    addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Eigenvalue centrality on the Binance community](img/B19446_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Eigenvalue centrality on the Binance community
  prefs: []
  type: TYPE_NORMAL
- en: 'The following information was taken from the CSV file, filtered by the `Class1_ecentrality`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** **or Node** | **class1_ecentrality** | **Label** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x28c6c06298d514db089934071355e5743bf21d60` | `0.669654742` | Binance 14
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xdac17f958d2ee523a2206206994597c13d831ec7` | `0.198603275` | Tether- USDT
    stablecoin |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48` | `0.080423932` | Circle USD
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.4 – Data filtered by the Class1_ecentrality column
  prefs: []
  type: TYPE_NORMAL
- en: 'For the OpenSea community, the drop between the first two addresses and the
    rest of the addresses is less dramatic. As a decentralized structure, the scoring
    is dispersed. We can see Wrapped Eth, Uniswap, and the address of a collector
    named `renethecat.eth` ([https://opensea.io/ReneTheCat](https://opensea.io/ReneTheCat))
    among the main nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Eigenvalue centrality on the OpenSea community](img/B19446_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Eigenvalue centrality on the OpenSea community
  prefs: []
  type: TYPE_NORMAL
- en: 'The following information was taken from the CSV file, filtered by the `Class0_ecentrality`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** **or Node** | **Class0_ecentrality** | **Label** |'
  prefs: []
  type: TYPE_TB
- en: '| `0x7f268357a8c2552623316e2562d90e642bb538e5` | `0.553669353` | OpenSea: Wyvern
    Exchange v2 |'
  prefs: []
  type: TYPE_TB
- en: '| `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2` | `0.227218243` | Wrapped Ether
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000000006c3852cbef3e08e8df289169ede581` | `0.208338034` | Seaport 1.1
    (OpenSea infrastructure) |'
  prefs: []
  type: TYPE_TB
- en: '| `0xef1c6e67703c7bd7107eed8303fbe6ec2554bf6b` | `0.17412939` | Uniswap: Universal
    Router 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x6e785f2fdbdc899f8f08cc1517f82a585b44f9c5` | `0.133520629441651` | renethecat.eth
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.5 – Data filtered by the Class0_ecentrality column
  prefs: []
  type: TYPE_NORMAL
- en: Carrying out this type of analysis can help us determine the influencer nodes
    for a specific community. The concept of influencer depends on the context. For
    example, if we are analyzing a centralized exchange, we can learn which addresses
    they are using as reserves, which stablecoins are mostly used by their clients,
    and so on. For a decentralized NFT marketplace where individuals trade with their
    addresses, we can identify collectors, collection smart contracts, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derived from the analysis explained previously, we found an address labeled
    as “rene the cat” to be influential. If we merge off-chain information from OpenSea
    and X (formerly, Twitter) (both APIs were reviewed in *Chapters 3* and *4* of
    this book), we can retrieve the following actionable data, which is derived exclusively
    from blockchain data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x6e785f2fDbdc899F8F08cc1517F82A585b44F9c5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenSea** **collection**: [https://opensea.io/ReneTheCat](https://opensea.io/ReneTheCat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twitter** **handle**: [https://twitter.com/mmendiguchiia](https://twitter.com/mmendiguchiia)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A note on presentation
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, presenting graph findings to an audience with no data background
    can be challenging. It is generally advisable to showcase the key nodes in a table,
    providing a user-friendly format that offers an overview of individuals listed
    based on selected criteria (such as highest closeness, betweenness centrality,
    and so on). This approach allows us to highlight individuals who appear on multiple
    top lists, as demonstrated in this section. This way, our audience can easily
    identify and understand the importance of these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: With this analysis, we have identified influencer nodes. In the next section,
    we will shed light on the influenced nodes, those that belong to a community.
  prefs: []
  type: TYPE_NORMAL
- en: Node classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the introduction to this chapter, when dealing with large graphs,
    such as the ever-growing blockchain transaction data, we may only have a subset
    of nodes labeled. These labels indicate certain protocols, user interests, and
    marketing segmentation groups. The challenge is to extend the labeling so that
    as all the nodes are added to the network, they belong to a segment or community.
    This exercise is performed in `Chapter12/Graphsage_node_classification.ipynb`.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we intend to build a marketing solution, but graph
    analysis is also used for discovering potential fraud detection or money laundering.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we will use GraphSAGE, which is a model built on top of a
    graph convolutional network. It is an inductive deep learning model for graphs
    that can handle the addition of new nodes without retraining. This feature is
    beneficial for transactional data that continuously grows as new addresses and
    transactions are added over time, eliminating the need to generate new training
    data to create a new model for the entire network. GraphSAGE is implemented within
    the StellarGraph library.
  prefs: []
  type: TYPE_NORMAL
- en: GraphSAGE is capable of predicting the embedding of a new node. To achieve this,
    the model learns aggregator functions that can generate the embedding of a new
    node based on its features and the characteristics of its neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.15* shows a simplified version of our dataset, where we can observe
    the two communities. GraphSAGE operates by sampling and aggregating information
    from a node’s local neighborhood to generate node embeddings, which capture the
    structural properties and relationships within the graph. The algorithm iteratively
    updates the embeddings by considering the embeddings of neighboring nodes and
    aggregating their information. This allows GraphSAGE to capture the graph’s global
    structure while leveraging local neighborhood information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – GraphSAGE learning steps](img/B19446_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – GraphSAGE learning steps
  prefs: []
  type: TYPE_NORMAL
- en: This process is called *inductive* learning as the model can infer that a general
    principle is derived from a body of observations, similar to how our brain functions.
    For additional technical explanations of this process, please refer to the *Further
    reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this model, we will need to feed an **edges** dataset and a **features**
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The **edges** dataset is the same one we analyzed in the previous section and
    is composed of transactions that interacted with the Binance 14 and OpenSea addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The `influencers.csv` file, which is the output of the `Chapter12/features.ipynb`
    notebook. From this dataset, we will only use the 30 most important nodes based
    on the features criteria, such as betweenness centrality, node degree, and so
    on. For each node in the edges dataset, we will analyze whether they had any transactions
    with the 30 top influencer nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we’ll provide a modularity dictionary to the Louvain community
    detection algorithm (included in the Networkx library) to determine the community
    assignment for each node in the edges dataset. We’ll use the `best_partition`
    function, which computes the partition of the graph nodes and maximizes the modularity
    using the Louvain heuristics. The code snippet for this process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result of this process is a well-balanced dataset where each node has 30
    features, including the target column named `community` with values of `0` and
    `1`. This is a binary classification task between two communities but it is possible
    to re-create this exercise with more categories.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in utilizing the model is to create a StellarGraph object from
    the datasets. This can be achieved by creating a graph from the two datasets using
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we have two labels: `{''community 0''` and `''community 1''}`.
    These labels have to be encoded. We’ll use the `binarize` label from the scikit-learn
    library to perform that task.'
  prefs: []
  type: TYPE_NORMAL
- en: As with all machine learning tasks, we must split the data into training and
    test sets using the traditional `model_selection.train_test_split` function from
    scikit-learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build a `GraphSAGENodeGenerator` object to feed the node features in
    sampled subgraphs to Keras:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The concepts of bias, dropout, and layers were introduced in [*Chapter 6*](B19446_06.xhtml#_idTextAnchor210).
  prefs: []
  type: TYPE_NORMAL
- en: 'The prediction layer will have an activation sigmoid because it is a binary
    problem. If there are more categories to predict, it is possible to change the
    activation to softmax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Training and evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll train the model with 20 epochs. Here, we are interested in using `accuracy`
    as the evaluation metric. The loss metric is `binary_crossentropy`, which is consistent
    with the two-label task that we are addressing. We’ll use `shuffle` to ensure
    that the data is shuffled before each epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that the results are encoded, to interpret them, we must transform them
    back into their original format. For that purpose, we can use the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The accuracy on the test set is 99%. To see the results, we must create a new
    DataFrame with two columns – one containing the predicted community and the other
    containing the ground truth. This DataFrame and the confusion matrix are shown
    in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a list of GraphSAGE demos can be found in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, this chapter delved into the fundamentals of graph networks,
    exploring various aspects such as node features, graph types, and their significance
    in data analysis. By understanding these foundational concepts, we laid the groundwork
    for further exploration and analysis of complex networks.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding on this knowledge, we explored the characteristics of influential
    nodes within a graph formed by the interactions between two distinct communities
    --one centralized, such as Binance, and the other decentralized, such as OpenSea.
  prefs: []
  type: TYPE_NORMAL
- en: Marketing solutions are crucial in this stage of the Web3 economy. Companies
    such as Spindl are actively building tools to bridge the information and granularity
    gap between the Web2 and Web3 worlds. To achieve this, they are concentrating
    on attribution mechanisms that measure the actual impact of advertising on the
    protocols. Once attribution is achieved, it is needed to identify communities
    to target with campaigns. To aid this objective, we employed the GraphSAGE algorithm
    for the task of node classification. This methodology enables to expand limited
    labeling to the ever expanding Web 3 transaction data.
  prefs: []
  type: TYPE_NORMAL
- en: This is the final chapter of *Part 2* of this book. In the *Part 3*, we will
    analyze some practical advice so that you can start a career in Web3 data science
    while understanding the opinions of professionals working in leading companies.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stamile, C., Marzullo, A., and Deusebio, E. (2021). *Graph Machine Learning:
    Take graph data to the next level by applying machine learning techniques and
    algorithms*. Packt Publishing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liiv, I. (2021). *Data Science Techniques for Cryptocurrency* *Blockchains*.
    Springer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spindl. (n.d.). *Introduction*: [https://docs.spindl.xyz/spindl/overview/introduction](https://docs.spindl.xyz/spindl/overview/introduction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding GraphSAGE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ruberts, A. (2021, May 4). *GraphSAGE for Classification in Python*. Well Enough:
    [https://antonsruberts.github.io/graph/graphsage/](https://antonsruberts.github.io/graph/graphsage/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Özçelik, R. (2019, October 25). *An Intuitive Explanation of GraphSAGE*. Medium:
    [https://towardsdatascience.com/an-intuitive-explanation-of-graphsage-6df9437ee64f](https://towardsdatascience.com/an-intuitive-explanation-of-graphsage-6df9437ee64f).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Demos:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*StellarGraph basics – StellarGraph 1.2.1 documentation*. (n.d.). Welcome to
    StellarGraph’s documentation! – StellarGraph 1.2.1 documentation: [https://stellargraph.readthedocs.io/en/stable/demos/basics/index.xhtml](https://stellargraph.readthedocs.io/en/stable/demos/basics/index.xhtml).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attacker Traceablity on Ethereum through Graph Analysis*. (2022, January 27).
    Publishing open access research journals and papers | Hindawi: [https://www.hindawi.com/journals/scn/2022/3448950/](https://www.hindawi.com/journals/scn/2022/3448950/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Network Graphs to Visualize Potential Fraud on the Ethereum Blockchain*.
    (2022, September 29). NVIDIA Technical Blog: [https://developer.nvidia.com/blog/using-network-graphs-to-visualize-potential-fraud-on-ethereum-blockchain/](https://developer.nvidia.com/blog/using-network-graphs-to-visualize-potential-fraud-on-ethereum-blockchain/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NFT dataset:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Blog_scripts/nft_network_analysis_blog_06042022/nft_analytics/nft_analytics_notebook.ipynb*
    at main · onthemarkdata/blog_scripts. (n.d.). GitHub: [https://github.com/onthemarkdata/blog_scripts/blob/main/nft_network_analysis_blog_06042022/nft_analytics/nft_analytics_notebook.ipynb?nvid=nv-int-txtad-930904-vt46#cid=an01_nv-int-txtad_en-us](https://github.com/onthemarkdata/blog_scripts/blob/main/nft_network_analysis_blog_06042022/nft_analytics/nft_analytics_notebook.ipynb?nvid=nv-int-txtad-930904-vt46#cid=an01_nv-int-txtad_en-us).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NNs (graph neural networks):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prodramp. (n.d.). *Think Graph Neural Networks (GNN) are hard to understand?
    Try this two part series*. [Video]. YouTube: [https://www.youtube.com/watch?v=YdGN-J322y4](https://www.youtube.com/watch?v=YdGN-J322y4).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avkash Chauhan. (n.d.). *Do you want to know Graph Neural Networks (GNN) implementation
    in Python?* [Video]. YouTube: [https://www.youtube.com/watch?v=VDzrvhgyxsU](https://www.youtube.com/watch?v=VDzrvhgyxsU).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DeepWorks/GraphNeuralNetworks/Part2_Example2NodeClassification.ipynb* at main
    · prodramp/DeepWorks. (n.d.). GitHub: [https://github.com/prodramp/DeepWorks/blob/main/GraphNeuralNetworks/Part2_Example2NodeClassification.ipynb](https://github.com/prodramp/DeepWorks/blob/main/GraphNeuralNetworks/Part2_Example2NodeClassification.ipynb).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3 Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, we will explore the next steps to use the knowledge
    we’ve gained. We’ll delve into potential career paths and learn from leaders in
    the Web3 data space about their journeys – how they reached their current positions,
    their visions for the future, and the qualities they value in professionals within
    the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19446_13.xhtml#_idTextAnchor346), *Building Experience with
    Crypto Data – BUIDL*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19446_14.xhtml#_idTextAnchor360), *Interviews with Web3 Data
    Leaders*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Appendix 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Appendix 2*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Appendix 3*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
