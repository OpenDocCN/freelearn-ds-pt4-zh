<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer075" class="Content">
			</div>
		</div>
		<div id="_idContainer076" class="Content">
			<h1 id="_idParaDest-41">2. <a id="_idTextAnchor040"/>Regression</h1>
		</div>
		<div id="_idContainer096" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter is an introduction to linear regression analysis and its application to practical problem-solving in data science. You will learn how to use Python, a versatile programming language, to carry out regression analysis and examine the results. The use of the logarithm function to transform inherently non-linear relationships between variables and to enable the application of the linear regression method of analysis will also be introduced.</p>
			<p class="callout">By the end of this chapter, you will be able to identify and import the Python modules required for regression analysis; use the <strong class="source-inline">pandas</strong> module to load a dataset and prepare it for regression analysis; create a scatter plot of bivariate data and fit a regression line through it; use the methods available in the Python <strong class="source-inline">statsmodels</strong> module to fit a regression model to a dataset; explain the results of simple and multiple linear regression analysis; assess the goodness of fit of a linear regression model; and apply linear regression analysis as a tool for practical problem-solving.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Introduction</h1>
			<p>The previous chapter provided a primer to Python programming and an overview of the data science field. Data science is a relatively young multidisciplinary field of study. It draws its concepts and methods from the traditional fields of statistics, computer science, and the broad field of artificial intelligence (AI), especially the subfield of AI called machine learning: </p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="Images/B15019_02_01.jpg" alt="Figure 2.1: The data science models&#13;&#10;" width="1300" height="480"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1: The data science models</p>
			<p>As you can see in <em class="italic">Figure 2.1</em>, data science aims to make use of both <strong class="bold">structured</strong> and <strong class="bold">unstructured</strong> data, develop models that can be effectively used, make predictions, and also derive insights for decision making. </p>
			<p>A loose description of structured data will be any set of data that can be conveniently arranged into a table that consists of rows and columns. This kind of data is normally stored in database management systems. </p>
			<p>Unstructured data, however, cannot be conveniently stored in tabular form â€“ an example of such a dataset is a text document. To achieve the objectives of data science, a flexible programming language that effectively combines interactivity with computing power and speed is necessary. This is where the Python programming language meets the needs of data science and, as mentioned in <em class="italic">Chapter 1</em>,<em class="italic"> Introduction to Data Science in Python</em>, we will be using Python in this book. </p>
			<p>The need to develop models to make predictions and to gain insights for decisionmaking cuts across many industries. Data science is, therefore, finding uses in many industries, including healthcare, manufacturing and the process industries in general, the banking and finance sectors, marketing and e-commerce, the government, and education.</p>
			<p>In this chapter, we will be specifically be looking at regression, which is one of the key methods that is used regularly in data science, in order to model relationships between variables, where the <strong class="bold">target variable</strong> (that is, the value you're looking for) is a real number.</p>
			<p>Consider a situation where a real estate business wants to understand and, if possible, model the relationship between the prices of property in a city and knowing the key attributes of the properties. This is a data science problem and it can be tackled using regression.</p>
			<p>This is because the target variable of interest, which is the price of a property, is a real number. Examples of the key attributes of a property that can be used to predict its value are as follows:</p>
			<ul>
				<li>The age of the property</li>
				<li>The number of bedrooms in a property</li>
				<li>Whether the property has a pool or not</li>
				<li>The area of land the property covers</li>
				<li>The distance of the property from facilities such as railway stations and schools</li>
			</ul>
			<p>Regression analysis can be employed to study this scenario, in which you have to create a function that maps the key attributes of a property to the target variable, which, in this case, is the price of a property. </p>
			<p>Regression analysis is part of a family of machine learning techniques called <strong class="bold">supervised machine learning</strong>. It is called supervised because the machine learning algorithm that learns the model is provided a kind of <em class="italic">question</em> and <em class="italic">answer</em> dataset to learn from. The <em class="italic">question</em> here is the key attribute and the <em class="italic">answer</em> is the property price for each property that is used in the study, as shown in the following figure:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="Images/B15019_02_02.jpg" alt="Figure 2.2: Example of a supervised learning technique&#13;&#10;" width="1270" height="365"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2: Example of a supervised learning technique</p>
			<p>Once a model has been learned by the algorithm, we can provide the model with a question (that is, a set of attributes for a property whose price we want to find) for it to tell us what the answer (that is, the price) of that property will be. </p>
			<p>This chapter is an introduction to linear regression and how it can be applied to solve practical problems like the one described previously in data science. Python provides a rich set of modules (libraries) that can be used to conduct rigorous regression analysis of various kinds. In this chapter, we will make use of the following Python modules, among others: <strong class="source-inline">pandas</strong>, <strong class="source-inline">statsmodels</strong>, <strong class="source-inline">seaborn</strong>, <strong class="source-inline">matplotlib</strong>, and <strong class="source-inline">scikit-learn</strong>.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Simple Linear Regression</h1>
			<p>In <em class="italic">Figure 2.3</em>, you can see the crime rate per capita and the median value of owner-occupied homes for the city of Boston, which is the largest city of the Commonwealth of Massachusetts. We seek to use regression analysis to gain an insight into what drives crime rates in the city. </p>
			<p>Such analysis is useful to policy makers and society in general because it can help with decision-making directed toward the reduction of the crime rate, and hopefully the eradication of crime across communities. This can make communities safer and increase the quality of life in society. </p>
			<p>This is a data science problem and is of the supervised machine learning type. There is a dependent variable named <strong class="source-inline">crime rate</strong> (let's denote it <em class="italic">Y</em>), whose variation we seek to understand in terms of an independent variable, named <strong class="source-inline">Median value of owner-occupied homes</strong> (let's denote it <em class="italic">X</em>). </p>
			<p>In other words, we are trying to understand the variation in crime rate based on different neighborhoods. </p>
			<p>Regression analysis is about finding a function, under a given set of assumptions, that best describes the relationship between the dependent variable (<em class="italic">Y</em> in this case) and the independent variable (<em class="italic">X</em> in this case). </p>
			<p>When the number of independent variables is only one, and the relationship between the dependent and the independent variable is assumed to be a straight line, as shown in <em class="italic">Figure 2.3</em>, this type of regression analysis is called <strong class="bold">simple linear regression</strong>. The straight-line relationship is called the regression line or the line of <strong class="bold">best</strong> fit:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="Images/B15019_02_03.jpg" alt="Figure 2.3: A scatter plot of the crime rate against the median value &#13;&#10;of owner-occupied homes&#13;&#10;" width="1313" height="780"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3: A scatter plot of the crime rate against the median value of owner-occupied homes</p>
			<p>In <em class="italic">Figure 2.3</em>, the regression line is shown as a solid black line. Ignoring the poor quality of the fit of the regression line to the data in the figure, we can see a decline in crime rate per capita as the median value of owner-occupied homes increases.</p>
			<p>From a data science point of view, this observation may pose lots of questions. For instance, what is driving the decline in crime rate per capita as the median value of owner-occupier homes increases? Are richer suburbs and towns receiving more policing resources than less fortunate suburbs and towns? Unfortunately, these questions cannot be answered with such a simple plot as we find in <em class="italic">Figure 2.3</em>. But the observed trend may serve as a starting point for a discussion to review the distribution of police and community-wide security resources. </p>
			<p>Returning to the question of how well the regression line fits the data, it is evident that almost one-third of the regression line has no data points scattered around it at all. Many data points are simply clustered on the horizontal axis around the zero (<strong class="source-inline">0</strong>) crime rate mark. This is not what you expect of a good regression line that fits the data well. A good regression line that fits the data well must sit amidst a <em class="italic">cloud</em> of dataÂ points. </p>
			<p>It appears that the relationship between the crime rate per capita and the median value of owner-occupied homes is not as linear as you may have thought initially. </p>
			<p>In this chapter, we will learn how to use the logarithm function (a mathematical function for transforming values) to linearize the relationship between the crime rate per capita and the median value of owner-occupied homes, in order to improve the fit of the regression line to the data points on the scatter graph. </p>
			<p>We have ignored a very important question thus far. That is, <em class="italic">how can you determine the regression line for a given set of data?</em></p>
			<p>A common method used to determine the regression line is called the method of least squares, which is covered in the next section. </p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>The Method of Least Squares</h2>
			<p>The simple linear regression line is generally of the form shown in <em class="italic">Figure 2.4</em>, where Î²<span class="subscript">0</span> and Î²<span class="subscript">1</span> are unknown constants, representing the intercept and the slope of the regression line, respectively. </p>
			<p>The intercept is the value of the dependent variable (Y) when the independent variable (X) has a value of zero (0). The slope is a measure of the rate at which the dependent variable (Y) changes when the independent variable (X) changes by one (1). The unknown constants are called the <strong class="bold">model coefficients</strong> or <strong class="bold">parameters</strong>. This form of the regression line is sometimes known as the population regression line, and, as a probabilistic model, it fits the dataset approximately, hence the use of the symbol (<strong class="source-inline">â‰ˆ</strong>) in <em class="italic">Figure 2.4</em>. The model is called probabilistic because it does not model all the variability in the dependent variable (Y) :</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="Images/B15019_02_04.jpg" alt="Figure 2.4: Simple linear regression equation&#13;&#10;" width="1665" height="71"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4: Simple linear regression equation</p>
			<p>Calculating the difference between the actual dependent variable value and the predicted dependent variable value gives an error that is commonly termed as the residual (Ïµ<span class="subscript">i</span>).</p>
			<p>Repeating this calculation for every data point in the sample, the residual (Ïµ<span class="subscript">i</span>) for every data point can be squared, to eliminate algebraic signs, and added together to obtain the <strong class="bold">error sum of squares</strong> <strong class="bold">(ESS)</strong>. </p>
			<p>The least squares method seeks to minimize the ESS. </p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Multiple Linear Regression</h1>
			<p>In the simple linear regression discussed previously, we only have one independent variable. If we include multiple independent variables in our analysis, we get a multiple linear regression model. Multiple linear regression is represented in a way that's similar to simple linear regression. </p>
			<p>Let's consider a case where we want to fit a linear regression model that has three independent variables, X<span class="subscript">1</span>, X<span class="subscript">2</span>, and X<span class="subscript">3</span>. The formula for the multiple linear regression equation will look like <em class="italic">Figure 2.5</em>:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="Images/B15019_02_05.jpg" alt="Figure 2.5: Multiple linear regression equation&#13;&#10;" width="1665" height="82"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5: Multiple linear regression equation</p>
			<p>Each independent variable will have its own coefficient or parameter (that is, Î²<span class="subscript">1</span> Î²<span class="subscript">2</span> or Î²<span class="subscript">3</span>). The Î²<span class="subscript">s</span> coefficient tells us how a change in their respective independent variable influences the dependent variable if all other independent variables are unchanged.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Estimating the Regression Coefficients (Î²<span class="subscript">0, </span>Î²<span class="subscript">1, </span>Î²<span class="subscript">2</span> and Î²<span class="subscript">3</span>)</h2>
			<p>The regression coefficients in <em class="italic">Figure 2.5</em> are estimated using the same least squares approach that was discussed when simple linear regression was introduced. To satisfy the least squares method, the chosen coefficients must minimize the sum of squared residuals. </p>
			<p>Later in the chapter, we will make use of the Python programming language to compute these coefficient estimates practically.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Logarithmic Transformations of Variables</h2>
			<p>As has been mentioned already, sometimes the relationship between the dependent and independent variables is not linear. This limits the use of linear regression. To get around this, depending on the nature of the relationship, the logarithm function can be used to transform the variable of interest. What happens then is that the transformed variable tends to have a linear relationship with the other untransformed variables, enabling the use of linear regression to fit the data. This will be illustrated in practice on the dataset being analyzed later in the exercises of theÂ book.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Correlation Matrices</h2>
			<p>In <em class="italic">Figure 2.3</em>, we saw how a linear relationship between two variables can be analyzed using a straight-line graph. Another way of visualizing the linear relationship between variables is with a correlation matrix. A correlation matrix is a kind of cross-table of numbers showing the correlation between pairs of variables, that is, how strongly the two variables are connected (this can be thought of as how a change in one variable will cause a change in the other variable). It is not easy analyzing raw figures in a table. A correlation matrix can, therefore, be converted to a form of "heatmap" so that the correlation between variables can easily be observed using different colors. An example of this is shown in <em class="italic">Exercise 2.01</em>, <em class="italic">Loading and Preparing the Data for Analysis</em>.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Conducting Regression Analysis Using Python</h1>
			<p>Having discussed the basics of regression analysis, it is now time to get our hands dirty and actually do some regression analysis using Python.</p>
			<p>To begin with our analysis, we need to start a session in Python and load the relevant modules and dataset required. </p>
			<p>All of the regression analysis we will do in this chapter will be based on the Boston Housing dataset. The dataset is good for teaching and is suitable for linear regression analysis. It presents the level of challenge that necessitates the use of the logarithm function to transform variables in order to achieve a better level of model fit to the data. The dataset contains information on a collection of properties in the Boston area and can be used to determine how the different housing attributes of a specific property affect the property's value.</p>
			<p>The column headings of the Boston Housing dataset CSV file can be explained asÂ follows:</p>
			<ul>
				<li>CRIM â€“ per capita crime rate by town</li>
				<li>ZN â€“ proportion of residential land zoned for lots over 25,000 sq.ft.</li>
				<li>INDUS â€“ proportion of non-retail business acres per town</li>
				<li>CHAS â€“ Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)</li>
				<li>NOX â€“ nitric oxide concentration (parts per 10 million)</li>
				<li>RM â€“ average number of rooms per dwelling</li>
				<li>AGE â€“ proportion of owner-occupied units built prior to 1940</li>
				<li>DIS â€“ weighted distances to five Boston employment centers</li>
				<li>RAD â€“ index of accessibility to radial highways</li>
				<li>TAX â€“ full-value property-tax rate per $10,000</li>
				<li>PTRATIO â€“ pupil-teacher ratio by town</li>
				<li>LSTAT â€“ % of lower status of the population</li>
				<li>MEDV â€“ median value of owner-occupied homes in $1,000s</li>
			</ul>
			<p>The dataset we're using is a slightly modified version of the original and was sourced from <a href="https://packt.live/39IN8Y6">https://packt.live/39IN8Y6</a>.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Exercise 2.01: Loading and Preparing the Data for Analysis</h2>
			<p>In this exercise, we will learn how to load Python modules, and the dataset we need for analysis, into our Python session and prepare the data for analysis.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will be using the Boston Housing dataset in this chapter, which can be found on our GitHub repository at <a href="https://packt.live/2QCCbQB">https://packt.live/2QCCbQB</a>.</p>
			<p>The following steps will help you to complete this exercise:</p>
			<ol>
				<li>Open a new Colab notebook file.</li>
				<li>Load the necessary Python modules by entering the following code snippet into a single Colab notebook cell. Press the <strong class="bold">Shift</strong> and <strong class="bold">Enter</strong> keys together to run the block of code: <p class="source-code">%matplotlib inline</p><p class="source-code">import matplotlib as mpl</p><p class="source-code">import seaborn as sns</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">import statsmodels.formula.api as smf</p><p class="source-code">import statsmodels.graphics.api as smg</p><p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">import patsy</p><p class="source-code">from statsmodels.graphics.correlation import plot_corr</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">plt.style.use('seaborn')</p><p>The first line of the preceding code enables <strong class="source-inline">matplotlib</strong> to display the graphical output of the code in the notebook environment. The lines of code that follow use the <strong class="source-inline">import</strong> keyword to load various Python modules into our programming environment. This includes <strong class="source-inline">patsy</strong>, which is a Python module. Some of the modules are given aliases for easy referencing, such as the <strong class="source-inline">seaborn</strong> module being given the alias <strong class="source-inline">sns</strong>. Therefore, whenever we refer to <strong class="source-inline">seaborn</strong> in subsequent code, we use the alias <strong class="source-inline">sns</strong>. The <strong class="source-inline">patsy</strong> module is imported without an alias. We, therefore, use the full name of the <strong class="source-inline">patsy</strong> module in our code where needed. </p><p>The <strong class="source-inline">plot_corr</strong> and <strong class="source-inline">train_test_split</strong> functions are imported from the <strong class="source-inline">statsmodels.graphics.correlation</strong> and <strong class="source-inline">sklearn.model_selection</strong> modules respectively. The last statement is used to set the aesthetic look of the graphs that <strong class="source-inline">matplotlib</strong> generates to the type displayed by the <strong class="source-inline">seaborn</strong> module.</p></li>
				<li>Next, load the <strong class="source-inline">Boston.CSV</strong> file and assign the variable name <strong class="source-inline">rawBostonData</strong> to it by running the following code: <p class="source-code">rawBostonData = pd.read_csv\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ('https://raw.githubusercontent.com/'\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'PacktWorkshops/The-Data-Science-'\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'Workshop/master/Chapter02/'\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'Dataset/Boston.csv')</p></li>
				<li>Inspect the first five records in the DataFrame:<p class="source-code">rawBostonData.head()</p><p>You should get the following output:</p><div id="_idContainer082" class="IMG---Figure"><img src="Images/B15019_02_06.jpg" alt="Figure 2.6: First five rows of the dataset&#13;&#10;" width="1213" height="328"/></div><p class="figure-caption">Figure 2.6: First five rows of the dataset</p></li>
				<li>Check for missing values (<em class="italic">null</em> values) in the DataFrame and then drop them in order to get a clean dataset Use the pandas method <strong class="source-inline">dropna()</strong> to find and remove these missing values:<p class="source-code">rawBostonData = rawBostonData.dropna()</p></li>
				<li>Check for duplicate records in the DataFrame and then drop them in order to get a clean dataset. Use the <strong class="source-inline">drop_duplicates()</strong> method from pandas:<p class="source-code">rawBostonData = rawBostonData.drop_duplicates()</p></li>
				<li>List the column names of the DataFrame so that you can examine the fields in your dataset, and modify the names, if necessary, to names that are meaningful:<p class="source-code">list(rawBostonData.columns)</p><p>You should get the following output:</p><div id="_idContainer083" class="IMG---Figure"><img src="Images/B15019_02_07.jpg" alt="Figure 2.7: Listing all the column names&#13;&#10;" width="880" height="417"/></div><p class="figure-caption">Figure 2.7: Listing all the column names</p></li>
				<li>Rename the DataFrame columns so that they are meaningful. Be mindful to match the column names exactly as leaving out even white spaces in the name strings will result in an error. For example, this string, <strong class="source-inline">ZN</strong>, has a white space before and after and it is different from <strong class="source-inline">ZN</strong>. After renaming, print the head of the new DataFrame as follows:<p class="source-code">renamedBostonData = rawBostonData.rename\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (columns = {\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'CRIM':'crimeRatePerCapita',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ' ZN ':'landOver25K_sqft',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'INDUS ':'non-retailLandProptn',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'CHAS':'riverDummy',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'NOX':'nitrixOxide_pp10m',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'RM':'AvgNo.RoomsPerDwelling',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'AGE':'ProptnOwnerOccupied',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'DIS':'weightedDist',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'RAD':'radialHighwaysAccess',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'TAX':'propTaxRate_per10K',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'PTRATIO':'pupilTeacherRatio',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'LSTAT':'pctLowerStatus',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'MEDV':'medianValue_Ks'})</p><p class="source-code">renamedBostonData.head()</p><p>You should get the following output:</p><div id="_idContainer084" class="IMG---Figure"><img src="Images/B15019_02_08.jpg" alt="Figure 2.8: DataFrames being renamed&#13;&#10;" width="901" height="307"/></div><p class="figure-caption">Figure 2.8: DataFrames being renamed</p><p class="callout-heading">Note</p><p class="callout">The preceding output is truncated. Please head to the GitHub repository to find the entire output.</p></li>
				<li>Inspect the data types of the columns in your DataFrame using the <strong class="source-inline">.info()</strong>Â function:<p class="source-code">renamedBostonData.info()</p><p>You should get the following output:</p><div id="_idContainer085" class="IMG---Figure"><img src="Images/B15019_02_09.jpg" alt="Figure 2.9: The different data types in the dataset&#13;&#10;" width="1375" height="768"/></div><p class="figure-caption">Figure 2.9: The different data types in the dataset</p><p>The output shows that there are <strong class="source-inline">506</strong> rows (<strong class="source-inline">Int64Index: 506 entries</strong>) in the dataset. There are also <strong class="source-inline">13</strong> columns in total (<strong class="source-inline">Data columns</strong>). None of the <strong class="source-inline">13</strong> columns has a row with a missing value (all <strong class="source-inline">506</strong> rows are <em class="italic">non-null</em>). 10 of the columns have floating-point (decimal) type data and three have integer typeÂ data.</p></li>
				<li>Now, calculate basic statistics for the numeric columns in the DataFrame:<p class="source-code">renamedBostonData.describe(include=[np.number]).T</p><p>We used the pandas function, <strong class="source-inline">describe</strong>, called on the DataFrame to calculate simple statistics for numeric fields (this includes any field with a <strong class="source-inline">numpy</strong> number data type) in the DataFrame. The statistics include the minimum, the maximum, the count of rows in each column, the average of each column (mean), the 25<span class="superscript">th</span> percentile, the 50<span class="superscript">th</span> percentile, and the 75<span class="superscript">th</span> percentile. We transpose (using the <strong class="source-inline">.T</strong> function) the output of the <strong class="source-inline">describe</strong> function to get a better layout.</p><p>You should get the following output:</p><div id="_idContainer086" class="IMG---Figure"><img src="Images/B15019_02_10.jpg" alt="Figure 2.10: Basic statistics of the numeric column&#13;&#10;" width="1344" height="702"/></div><p class="figure-caption">Figure 2.10: Basic statistics of the numeric column</p></li>
				<li>Divide the DataFrame into training and test sets, as shown in the following codeÂ snippet:<p class="source-code">X = renamedBostonData.drop('crimeRatePerCapita', axis = 1)</p><p class="source-code">y = renamedBostonData[['crimeRatePerCapita']]</p><p class="source-code">seed = 10 </p><p class="source-code">test_data_size = 0.3 </p><p class="source-code">X_train, X_test, \</p><p class="source-code">y_train, y_test = train_test_split(X, y, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â test_size = test_data_size, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â random_state = seed)</p><p class="source-code">train_data = pd.concat([X_train, y_train], axis = 1)</p><p class="source-code">test_data = pd.concat([X_test, y_test], axis = 1)</p><p>We choose a test data size of 30%, which is <strong class="source-inline">0.3</strong>. The <strong class="source-inline">train_test_split</strong> function is used to achieve this. We set the seed of the random number generator so that we can obtain a reproducible split each time we run this code. An arbitrary value of <strong class="source-inline">10</strong> is used here. It is good model-building practice to divide a dataset being used to develop a model into at least two parts. One part is used to develop the model and it is called a training set (<strong class="source-inline">X_train</strong> and <strong class="source-inline">y_train</strong>Â combined).</p><p class="callout-heading">Note</p><p class="callout">Splitting your data into training and test subsets allows you to use some of the data to train your model (that is, it lets you build a model that learns the relationships between the variables), and the rest of the data to test your model (that is, to see how well your new model can make predictions when given new data). You will use train-test splits throughout this book, and the concept will be explained in more detail in <em class="italic">Chapter 7, The Generalization Of Machine Learning Models</em>.</p></li>
				<li>Calculate and plot a correlation matrix for the <strong class="source-inline">train_data</strong> set: <p class="source-code">corrMatrix = train_data.corr(method = 'pearson')</p><p class="source-code">xnames=list(train_data.columns)</p><p class="source-code">ynames=list(train_data.columns)</p><p class="source-code">plot_corr(corrMatrix, xnames=xnames, ynames=ynames,\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â title=None, normcolor=False, cmap='RdYlBu_r')</p><p>The use of the backslash character, <strong class="source-inline">\</strong>, on <em class="italic">line 4</em> in the preceding code snippet is to enforce the continuation of code on to a new line in Python. The <strong class="source-inline">\</strong> character is not required if you are entering the full line of code into a single line in yourÂ notebook.</p><p>You should get the following output:</p><div id="_idContainer087" class="IMG---Figure"><img src="Images/B15019_02_11.jpg" alt="Figure 2.11: Output with the expected heatmap&#13;&#10;" width="1665" height="1186"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.11: Output with the expected heatmap</p>
			<p>In the preceding heatmap, we can see that there is a strong positive correlation (an increase in one causes an increase in the other) between variables that have orange or red squares. There is a strong negative correlation (an increase in one causes a decrease in the other) between variables with blue squares. There is little or no correlation between variables with pale-colored squares. For example, there appears to be a relatively strong correlation between <strong class="source-inline">nitrixOxide_pp10m</strong> and <strong class="source-inline">non-retailLandProptn</strong>, but a low correlation between <strong class="source-inline">riverDummy</strong> and any other variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/320HLAH">https://packt.live/320HLAH</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/34baJAA">https://packt.live/34baJAA</a>.</p>
			<p>We can use the findings from the correlation matrix as the starting point for further regression analysis. The heatmap gives us a good overview of relationships in the data and can show us which variables to target in our investigation.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>The Correlation Coefficient</h2>
			<p>In the previous exercise, we have seen how a correlation matrix heatmap can be used to visualize the relationships between pairs of variables. We can also see these same relationships in numerical form using the raw correlation coefficient numbers. These are values between -1 and 1, which represent how closely two variables are linked.</p>
			<p>Pandas provides a <strong class="source-inline">corr</strong> function, which when called on DataFrame provides a matrix (table) of the correlation of all numeric data types. In our case, running the code, <strong class="source-inline">train_data.corr (method = 'pearson')</strong>, in the Colab notebook provides the results in <em class="italic">Figure 2.12</em>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Pearson is the standard correlation coefficient for measuring the relationship between variables.</p>
			<p>It is important to note that <em class="italic">Figure 2.12</em> is symmetric along the left diagonal. The left diagonal values are correlation coefficients for features against themselves (and so all of them have a value of one (1)), and therefore are not relevant to our analysis. The data in <em class="italic">Figure 2.12</em> is what is presented as a plot in the output of <em class="italic">Step 12</em> in <em class="italic">ExerciseÂ 2.01</em>, <em class="italic">Loading and Preparing the Data for Analysis</em>.</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="Images/B15019_02_12.jpg" alt="Figure 2.12: A correlation matrix of the training dataset &#13;&#10;" width="954" height="333"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12: A correlation matrix of the training dataset </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding output is truncated.</p>
			<p>Data scientists use the correlation coefficient as a statistic in order to measure the linear relationship between two numeric variables, X and Y. The correlation coefficient for a sample of bivariate data is commonly represented by r. In statistics, the common method to measure the correlation between two numeric variables is by using the Pearson correlation coefficient. Going forward in this chapter, therefore, any reference to the correlation coefficient means the Pearson correlation coefficient. </p>
			<p>To practically calculate the correlation coefficient statistic for the variables in our dataset in this course, we use a Python function. What is important to this discussion is the meaning of the values the correlation coefficient we calculate takes. The correlation coefficient (r) takes values between +1 and -1. </p>
			<p>When r is equal to +1, the relationship between X and Y is such that both X and Y increase or decrease in the same direction perfectly. When r is equal to -1, the relationship between X and Y is such that an increase in X is associated with a decrease in Y perfectly and vice versa. When r is equal to zero (0), there is no linear relationship between X and Y. </p>
			<p>Having no linear relationship between X and Y does not mean that X and Y are not related; instead, it means that if there is any relationship, it cannot be described by a straight line. In practice, correlation coefficient values around 0.6 or higher (or -0.6 or lower) is a sign of a potentially exciting linear relationship between two variables, X and Y. </p>
			<p>The last column of the output of <em class="italic">Exercise 2.01</em>, <em class="italic">Loading and Preparing the Data for Analysis</em>, <em class="italic">Step 12</em>, provides r values for crime rate per capita against other features in color shades. Using the color bar, it is obvious that <strong class="source-inline">radialHighwaysAccess</strong>, <strong class="source-inline">propTaxRate_per10K</strong>, <strong class="source-inline">nitrixOxide_pp10m</strong>, and <strong class="source-inline">pctLowerStatus</strong> have the strongest correlation with crime rate per capita. This indicates that a possible linear relationship, between crime rate per capita and any of these independent variables, may be worth looking into. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Exercise 2.02: Graphical Investigation of Linear Relationships Using Python</h2>
			<p>Scatter graphs fitted with a regression line are a quick way by which a data scientist can visualize a possible correlation between a dependent variable and an independent variable. </p>
			<p>The goal of the exercise is to use this technique to investigate any linear relationship that may exist between crime rate per capita and the median value of owner-occupied homes in towns in the city of Boston. </p>
			<p>The following steps will help you complete the exercise:</p>
			<ol>
				<li value="1">Open a new Colab notebook file and execute the steps up to and including <em class="italic">Step 11</em> from <em class="italic">Exercise 2.01</em>, <em class="italic">Loading and Preparing the Data for Analysis</em>. This is shown in the code blocks below, starting with the import statements:<p class="source-code">%matplotlib inline</p><p class="source-code">import matplotlib as mpl</p><p class="source-code">import seaborn as sns</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">import statsmodels.formula.api as smf</p><p class="source-code">import statsmodels.graphics.api as smg</p><p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">import patsy</p><p class="source-code">from statsmodels.graphics.correlation import plot_corr</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">plt.style.use('seaborn')</p><p>Loading and preprocessing the data:</p><p class="source-code">rawBostonData = pd.read_csv\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ('https://raw.githubusercontent.com/'\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'PacktWorkshops/The-Data-Science-'\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'Workshop/master/Chapter02/'</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'Dataset/Boston.csv')</p><p class="source-code">rawBostonData = rawBostonData.dropna()</p><p class="source-code">rawBostonData = rawBostonData.drop_duplicates()</p><p class="source-code">renamedBostonData = rawBostonData.rename\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (columns = {\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'CRIM':'crimeRatePerCapita',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ' ZN ':'landOver25K_sqft',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'INDUS ':'non-retailLandProptn',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'CHAS':'riverDummy',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'NOX':'nitrixOxide_pp10m',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'RM':'AvgNo.RoomsPerDwelling',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'AGE':'ProptnOwnerOccupied',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'DIS':'weightedDist',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'RAD':'radialHighwaysAccess',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'TAX':'propTaxRate_per10K',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'PTRATIO':'pupilTeacherRatio',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'LSTAT':'pctLowerStatus',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'MEDV':'medianValue_Ks'})</p><p>Setting up the test and train data:</p><p class="source-code">X = renamedBostonData.drop('crimeRatePerCapita', axis = 1)</p><p class="source-code">y = renamedBostonData[['crimeRatePerCapita']]</p><p class="source-code">seed = 10 </p><p class="source-code">test_data_size = 0.3 </p><p class="source-code">X_train, X_test, y_train, y_test = train_test_split\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (X, y, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â test_size = test_data_size,\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â random_state = seed)</p><p class="source-code">train_data = pd.concat([X_train, y_train], axis = 1)</p><p class="source-code">test_data = pd.concat([X_test, y_test], axis = 1)</p></li>
				<li>Now use the <strong class="source-inline">subplots</strong> function in <strong class="source-inline">matplotlib</strong> to define a canvas (assigned the variable name <strong class="source-inline">fig</strong> in the following code) and a graph object (assigned the variable name <strong class="source-inline">ax</strong> in the following code) in Python. You can set the size of the graph by setting the <strong class="source-inline">figsize</strong> (width = <strong class="source-inline">10</strong>, height = <strong class="source-inline">6</strong>) argument of the function:<p class="source-code">fig, ax = plt.subplots(figsize=(10, 6))</p><p>Do not execute the code yet.</p></li>
				<li>Use the <strong class="source-inline">seaborn</strong> function <strong class="source-inline">regplot</strong> to create the scatter plot. Do not execute this code cell yet; we will add more code to style the plot in the next step: <p class="source-code">sns.regplot(x='medianValue_Ks', y='crimeRatePerCapita', \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â ci=None, data=train_data, ax=ax, color='k', \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â scatter_kws={"s": 20,"color": "royalblue", \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â "alpha":1})</p><p>The function accepts arguments for the independent variable (<strong class="source-inline">x</strong>), the dependent variable (<strong class="source-inline">y</strong>), the confidence interval of the regression parameters (<strong class="source-inline">ci</strong>), which takes values from 0 to 100, the DataFrame that has <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> (<strong class="source-inline">data</strong>), a matplotlib graph object (<strong class="source-inline">ax</strong>), and others to control the aesthetics of the points on the graph. (In this case, the confidence interval is set to <strong class="source-inline">None</strong> â€“ we will see more on confidence intervals later in the chapter.)</p></li>
				<li>In the same cell as step 3, set the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> labels, the <strong class="source-inline">fontsize</strong> and <strong class="source-inline">name</strong> labels, the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> limits, and the <strong class="source-inline">tick</strong> parameters of the matplotlib graph object (<strong class="source-inline">ax</strong>). Also, set the layout of the canvas to <strong class="source-inline">tight</strong>: <p class="source-code">ax.set_ylabel('Crime rate per Capita', fontsize=15, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fontname='DejaVu Sans')</p><p class="source-code">ax.set_xlabel("Median value of owner-occupied homes "\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â "in $1000's", fontsize=15, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â fontname='DejaVu Sans')</p><p class="source-code">ax.set_xlim(left=None, right=None)</p><p class="source-code">ax.set_ylim(bottom=None, top=30)</p><p class="source-code">ax.tick_params(axis='both', which='major', labelsize=12)</p><p class="source-code">fig.tight_layout()</p><p>Now execute the cell. You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="Images/B15019_02_13.jpg" alt="Figure 2.13: Scatter graph with a regression line using Python&#13;&#10;" width="994" height="592"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13: Scatter graph with a regression line using Python</p>
			<p>If the exercise was followed correctly, the output must be the same as the graph in <em class="italic">Figure 2.3</em>. In <em class="italic">Figure 2.3</em>, this output was presented and used to introduce linear regression without showing how it was created. What this exercise has taught us is how to create a scatter graph and fit a regression line through it using Python.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34cITnk">https://packt.live/34cITnk</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2CA4NFG">https://packt.live/2CA4NFG</a>.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Exercise 2.03: Examining a Possible Log-Linear Relationship Using Python</h2>
			<p>In this exercise, we will use the logarithm function to transform variables and investigate whether this helps provide a better fit of the regression line to the data. We will also look at how to use confidence intervals by including a 95% confidence interval of the regression coefficients on the plot.</p>
			<p>The following steps will help you to complete this exercise:</p>
			<ol>
				<li value="1">Open a new Colab notebook file and execute all the steps up to <em class="italic">Step 11</em> from <em class="italic">Exercise 2.01</em>, <em class="italic">Loading and Preparing the Data for Analysis</em>.</li>
				<li>Use the <strong class="source-inline">subplots</strong> function in <strong class="source-inline">matplotlib</strong> to define a canvas and a graph object in Python: <p class="source-code">fig, ax = plt.subplots(figsize=(10, 6))</p><p>Do not execute this code yet.</p></li>
				<li>In the same code cell, use the logarithm function in <strong class="source-inline">numpy</strong> (<strong class="source-inline">np.log</strong>) to transform the dependent variable (<strong class="source-inline">y</strong>). This essentially creates a new variable, <strong class="source-inline">log(y)</strong>:<p class="source-code">y = np.log(train_data['crimeRatePerCapita'])</p><p>Do not execute this code yet.</p></li>
				<li>Use the seaborn <strong class="source-inline">regplot</strong> function to create the scatter plot. Set the <strong class="source-inline">regplot</strong> function confidence interval argument (<strong class="source-inline">ci</strong>) to <strong class="source-inline">95%</strong>. This will calculate a <strong class="source-inline">95%</strong> confidence interval for the regression coefficients and have them plotted on the graph as a shaded area along the regression line. <p class="callout-heading">Note</p><p class="callout">A confidence interval gives an estimated range that is likely to contain the true value that you're looking for. So, a <strong class="source-inline">95%</strong> confidence interval indicates we can be <strong class="source-inline">95%</strong> certain that the true regression coefficients lie in that shadedÂ area.</p><p>Parse the <strong class="source-inline">y</strong> argument with the new variable we defined in the preceding step. The <strong class="source-inline">x</strong> argument is the original variable from the DataFrame without any transformation. Continue in the same code cell. Do not execute this cell yet; we will add in more styling code in the next step. </p><p class="source-code">sns.regplot(x='medianValue_Ks', y=y, ci=95, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â data=train_data, ax=ax, color='k', \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â scatter_kws={"s": 20,"color": "royalblue", \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â "alpha":1})</p></li>
				<li>Continuing in the same cell, set the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> labels, the <strong class="source-inline">fontsize</strong> and <strong class="source-inline">name</strong> labels, the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> limits, and the <strong class="source-inline">tick</strong> parameters of the <strong class="source-inline">matplotlib</strong> graph object (<strong class="source-inline">ax</strong>). Also, set the layout of the canvas to <strong class="source-inline">tight</strong>:<p class="source-code">ax.set_ylabel('log of Crime rate per Capita', \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â fontsize=15, fontname='DejaVu Sans')</p><p class="source-code">ax.set_xlabel("Median value of owner-occupied homes "\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â "in $1000's", fontsize=15, \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â fontname='DejaVu Sans')</p><p class="source-code">ax.set_xlim(left=None, right=None)</p><p class="source-code">ax.set_ylim(bottom=None, top=None)</p><p class="source-code">ax.tick_params(axis='both', which='major', labelsize=12)</p><p class="source-code">fig.tight_layout()</p><p>Now execute this cell. The output is as follows:</p><div id="_idContainer090" class="IMG---Figure"><img src="Images/B15019_02_14.jpg" alt="Figure 2.14: Expected scatter plot with an improved linear regression line&#13;&#10;" width="1002" height="606"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.14: Expected scatter plot with an improved linear regression line</p>
			<p>By completing this exercise, we have successfully improved our scatter plot. The regression line created in this activity fits the data better than what was created in <em class="italic">Exercise 2.02</em>, <em class="italic">Graphical Investigation of Linear Relationships Using Python</em>. You can see by comparing the two graphs, the regression line in the log graph more clearly matches the spread of the data points. We have solved the issue where the bottom third of the line had no points clustered around it. This was achieved by transforming the dependent variable with the logarithm function. The transformed dependent variable (log of crime rate per capita) has an improved linear relationship with the median value of owner-occupied homes than the untransformed variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3ay4aZS">https://packt.live/3ay4aZS</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/324nN7R">https://packt.live/324nN7R</a>.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>The Statsmodels formula API</h2>
			<p>In <em class="italic">Figure 2.3</em>, a solid line represents the relationship between the crime rate per capita and the median value of owner-occupied homes. But how can we obtain the equation that describes this line? In other words, how can we find the intercept and the slope of the straight-line relationship?</p>
			<p>Python provides a rich <strong class="bold">Application Programming Interface</strong> <strong class="bold">(API)</strong> for doing this easily. The statsmodels formula API enables the data scientist to use the formula language to define regression models that can be found in statistics literature and many dedicated statistical computer packages. </p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Exercise 2.04: Fitting a Simple Linear Regression Model Using the Statsmodels formula API</h2>
			<p>In this exercise, we examine a simple linear regression model where the crime rate per capita is the dependent variable and the median value of owner-occupied homes is the independent variable. We use the statsmodels formula API to create a linear regression model for Python to analyze. </p>
			<p>The following steps will help you complete this exercise:</p>
			<ol>
				<li value="1">Open a new Colab notebook file and import the required packages.<p class="source-code">import pandas as pd</p><p class="source-code">import statsmodels.formula.api as smf</p><p class="source-code">from sklearn.model_selection import train_test_split</p></li>
				<li>Execute <em class="italic">Step 2</em> to <em class="italic">11</em> from <em class="italic">Exercise 2.01</em>, <em class="italic">Loading and Preparing the Data for Analysis</em>.</li>
				<li>Define a linear regression model and assign it to a variable named <strong class="source-inline">linearModel</strong>:  <p class="source-code">linearModel = smf.ols\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â (formula='crimeRatePerCapita ~ medianValue_Ks',\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â data=train_data)</p><p>As you can see, we call the <strong class="source-inline">ols</strong> function of the statsmodels API and set its formula argument by defining a <strong class="source-inline">patsy</strong> formula string that uses the tilde (<strong class="source-inline">~</strong>) symbol to relate the dependent variable to the independent variable. Tell the function where to find the variables named, in the string, by assigning the data argument of the <strong class="source-inline">ols</strong> function to the DataFrame that contains your variables (<strong class="source-inline">train_data</strong>).</p></li>
				<li>Call the .<strong class="source-inline">fit</strong> method of the model instance and assign the results of the method to a <strong class="source-inline">linearModelResult</strong> variable, as shown in the following code snippet:<p class="source-code">linearModelResult = linearModel.fit()</p></li>
				<li>Print a summary of the results stored the <strong class="source-inline">linearModelResult</strong> variable by running the following code:<p class="source-code">print(linearModelResult.summary())</p><p>You should get the following output:</p><div id="_idContainer091" class="IMG---Figure"><img src="Images/B15019_02_15.jpg" alt="Figure 2.15: A summary of the simple linear regression analysis results&#13;&#10;" width="882" height="496"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.15: A summary of the simple linear regression analysis results</p>
			<p>If the exercise was correctly followed, then a model has been created with the <strong class="source-inline">statsmodels</strong> formula API. The <strong class="source-inline">fit</strong> method (<strong class="source-inline">.fit()</strong>) of the model object was called to fit the linear regression model to the data. What fitting here means is to estimate the regression coefficients (parameters) using the ordinary least squaresÂ method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3iJXXge">https://packt.live/3iJXXge</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YbZ54v">https://packt.live/2YbZ54v</a>.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Analyzing the Model Summary</h2>
			<p>The <strong class="source-inline">.fit</strong> method provides many functions to explore its output. These include the <strong class="source-inline">conf_int()</strong>, <strong class="source-inline">pvalues</strong>, <strong class="source-inline">tvalues</strong>, and <strong class="source-inline">summary()</strong> parameters. With these functions, the parameters of the model, the confidence intervals, and the p-values and t-values for the analysis can be retrieved from the results. (The concept of p-values and t-values will be explained later in the chapter.)</p>
			<p>The syntax simply involves following the dot notation, after the variable name containing the results, with the relevant function name â€“ for example, <strong class="source-inline">linearModelResult.conf_int()</strong> will output the confidence interval values. The handiest of them all is the <strong class="source-inline">summary()</strong> function, which presents a table of all relevant results from the analysis. </p>
			<p>In <em class="italic">Figure 2.15</em>, the output of the summary function used in <em class="italic">Exercise 2.04, Fitting a Simple Linear Regression Model Using the Statsmodels formula API,</em> is presented. The output of the summary function is divided, using double dashed lines, into three main sections. </p>
			<p>In <em class="italic">Chapter 9</em>, <em class="italic">Interpreting a Machine Learning Model</em>, the results of the three sections will be treated in detail. However, it is important to comment on a few points here. </p>
			<p>In the top-left corner of <em class="italic">Section 1</em> in <em class="italic">Figure 2.15</em>, we find the dependent variable in the model (<strong class="source-inline">Dep. Variable</strong>) printed and <strong class="source-inline">crimeRatePerCapita</strong> is the value for <em class="italic">Exercise 2.04</em>,<em class="italic"> Fitting a Simple Linear Regression Model Using the Statsmodels formula API</em>. A statistic named R-squared with a value of <strong class="source-inline">0.144</strong> for our model is also provided in <em class="italic">Section 1</em>. The R-squared value is calculated by Python as a fraction (<strong class="source-inline">0.144</strong>) but it is to be reported in percentages so the value for our model is <strong class="source-inline">14.4%</strong> The R-squared statistic provides a measure of how much of the variability in the dependent variable (<strong class="source-inline">crimeRatePerCapita</strong>), our model is able to explain. It can be interpreted as a measure of how well our model fits the dataset. In <em class="italic">Section 2</em> of <em class="italic">Figure 2.15</em>, the intercept and the independent variable in our model is reported. The independent variable in our model is the median value of owner-occupied homes (<strong class="source-inline">medianValue_Ks</strong>). </p>
			<p>In this same <em class="italic">Section 2</em>, just next to the intercept and the independent variable, is a column that reports the model coefficients (<strong class="source-inline">coef</strong>). The intercept and the coefficient of the independent variable are printed under the column labeled <strong class="source-inline">coef</strong> in the summary report that Python prints out. The intercept has a value of <strong class="source-inline">11.2094</strong> with the coefficient of the independent variable having a value of negative <strong class="source-inline">0.3502</strong> (<strong class="source-inline">-0.3502</strong>). If we choose to denote the dependent variable in our model (<strong class="source-inline">crimeRatePerCapita</strong>) as y and the independent variable (the median value of owner-occupied homes) as <em class="italic">x</em>, we have all the ingredients to write out the equation that defines our model. </p>
			<p>Thus, y â‰ˆ 11.2094 - 0.3502 x, is the equation for our model. In <em class="italic">Chapter 9</em>, <em class="italic">Interpreting a Machine Learning Model</em>, what this model means and how it can be used will be discussed in full. </p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>The Model Formula Language</h2>
			<p>Python is a very powerful language liked by many developers. Since the release of version 0.5.0 of statsmodels, Python now provides a very competitive option for statistical analysis and modeling rivaling R and SAS. </p>
			<p>This includes what is commonly referred to as the R-style formula language, by which statistical models can be easily defined. Statsmodels implements the R-style formula language by using the <strong class="source-inline">Patsy</strong> Python library internally to convert formulas and data to the matrices that are used in model fitting. </p>
			<p><em class="italic">Figure 2.16</em> summarizes the operators used to construct the <strong class="source-inline">Patsy</strong> formula strings and what they mean:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="Images/B15019_02_16.jpg" alt="Figure 2.16: A summary of the Patsy formula syntax and examples&#13;&#10;" width="1427" height="1900"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16: A summary of the Patsy formula syntax and examples</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Intercept Handling</h2>
			<p>In patsy formula strings, <strong class="source-inline">string 1</strong> is used to define the intercept of a model. Because the intercept is needed most of the time, <strong class="source-inline">string 1</strong> is automatically included in every formula string definition. You don't have to include it in your string to specify the intercept. It is there invisibly. If you want to delete the intercept from your model, however, then you can subtract one (-1) from the formula string and that will define a model that passes through the origin. For compatibility with other statistical software, <strong class="source-inline">Patsy</strong> also allows the use of the string zero (0) and negative one (-1) to be used to exclude the intercept from a model. What this means is that, if you include 0 or -1 on the right-hand side of your formula string, your model will have no intercept. </p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Activity 2.01: Fitting a Log-Linear Model Using the Statsmodels Formula API</h2>
			<p>You have seen how to use the statsmodels API to fit a linear regression model. In this activity, you are asked to fit a log-linear model. Your model should represent the relationship between the log-transformed dependent variable (log of crime rate per capita) and the median value of owner-occupied homes.</p>
			<p>The steps to complete this activity are as follows:</p>
			<ol>
				<li value="1">Define a linear regression model and assign it to a variable. Remember to use the <strong class="source-inline">log</strong> function to transform the dependent variable in the formula string. </li>
				<li>Call the <strong class="source-inline">fit</strong> method of the log-linear model instance and assign the results of the method to a variable.</li>
				<li>Print a summary of the results and analyze the output.</li>
			</ol>
			<p>Your output should look like the following figure:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="Images/B15019_02_17.jpg" alt="Figure 2.17: A log-linear regression of crime rate per capita on the median value &#13;&#10;of owner-occupied homes&#13;&#10;" width="779" height="437"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.17: A log-linear regression of crime rate per capita on the median value of owner-occupied homes</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found here: <a href="https://packt.live/2GbJloz">https://packt.live/2GbJloz</a>.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Multiple Regression Analysis</h1>
			<p>In the exercises and activity so far, we have used only one independent variable in our regression analysis. In practice, as we have seen with the Boston Housing dataset, processes and phenomena of analytic interest are rarely influenced by only one feature. To be able to model the variability to a higher level of accuracy, therefore, it is necessary to investigate all the independent variables that may contribute significantly toward explaining the variability in the dependent variable. Multiple regression analysis is the method that is used to achieve this. </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Exercise 2.05: Fitting a Multiple Linear Regression Model Using the Statsmodels Formula API</h2>
			<p>In this exercise, we will be using the plus operator (<strong class="source-inline">+</strong>) in the <strong class="source-inline">patsy</strong> formula string to define a linear regression model that includes more than one independent variable. </p>
			<p>To complete this activity, run the code in the following steps in your Colab notebook:</p>
			<ol>
				<li value="1">Open a new Colab notebook file and import the required packages.<p class="source-code">import statsmodels.formula.api as smf</p><p class="source-code">import pandas as pd</p><p class="source-code">from sklearn.model_selection import train_test_split</p></li>
				<li>Execute <em class="italic">Step 2</em> to <em class="italic">11</em> from <em class="italic">Exercise 2.01</em>,<em class="italic"> Loading and Preparing the Data for Analysis</em>.</li>
				<li>Use the plus operator (<strong class="source-inline">+</strong>) of the Patsy formula language to define a linear model that regresses <strong class="source-inline">crimeRatePerCapita</strong> on <strong class="source-inline">pctLowerStatus</strong>, <strong class="source-inline">radialHighwaysAccess</strong>, <strong class="source-inline">medianValue_Ks</strong>, and <strong class="source-inline">nitrixOxide_pp10m</strong> and assign it to a variable named <strong class="source-inline">multiLinearModel</strong>. Use the Python line continuation symbol (<strong class="source-inline">\</strong>) to continue your code on a new line should you run out of space: <p class="source-code">multiLinearModel = smf.ols\</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (formula = 'crimeRatePerCapita \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ~ pctLowerStatus \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â + radialHighwaysAccess \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â + medianValue_Ks \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â + nitrixOxide_pp10m', \</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â data=train_data)</p></li>
				<li>Call the <strong class="source-inline">fit</strong> method of the model instance and assign the results of the method to a variable:<p class="source-code">multiLinearModResult = multiLinearModel.fit()</p></li>
				<li>Print a summary of the results stored the variable created in <em class="italic">Step 3</em>:</li>
			</ol>
			<p class="source-code">print(multiLinearModResult.summary())</p>
			<p>The output is as follows:</p>
			<p> </p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="Images/B15019_02_18.jpg" alt="Figure 2.18: A summary of multiple linear regression results&#13;&#10;" width="903" height="565"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.18: A summary of multiple linear regression results</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/34cJgOK">https://packt.live/34cJgOK</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3h1CKOt">https://packt.live/3h1CKOt</a>.</p>
			<p>If the exercise was correctly followed, <em class="italic">Figure 2.18</em> will be the result of the analysis. In <em class="italic">Activity 2.01</em>, the R-squared statistic was used to assess the model for goodness of fit. When multiple independent variables are involved, the goodness of fit of the model created is assessed using the adjusted R-squared statistic.</p>
			<p>The adjusted R-squared statistic considers the presence of the extra independent variables in the model and corrects for inflation of the goodness of fit measure of the model, which is just caused by the fact that more independent variables are being used to create the model. </p>
			<p>The lesson we learn from this exercise is the improvement in the adjusted R-squared value in <em class="italic">Section 1</em> of <em class="italic">Figure 2.18</em>. When only one independent variable was used to create a model that seeks to explain the variability in <strong class="source-inline">crimeRatePerCapita</strong> in <em class="italic">Exercise 2.04</em>, <em class="italic">Fitting a Simple Linear Regression Model Using the Statsmodels formula API</em>, the R-squared value calculated was only <strong class="source-inline">14.4</strong> percent. In this exercise, we used four independent variables. The model that was created improved the adjusted R-squared statistic to <strong class="source-inline">39.1</strong> percent, an increase of <strong class="source-inline">24.7</strong> percent. </p>
			<p>We learn that the presence of independent variables that are correlated to a dependent variable can help explain the variability in the independent variable in a model. But it is clear that a considerable amount of variability, about <strong class="source-inline">60.9</strong> percent, in the dependent variable is still not explained by our model. </p>
			<p>There is still room for improvement if we want a model that does a good job of explaining the variability we see in <strong class="source-inline">crimeRatePerCapita</strong>. In <em class="italic">Section 2</em> of <em class="italic">Figure 2.18</em>, the intercept and all the independent variables in our model are listed together with their coefficients. If we denote <strong class="source-inline">pctLowerStatus</strong> by x<span class="subscript">1</span>, <strong class="source-inline">radialHighwaysAccess</strong> by x<span class="subscript">2</span>, <strong class="source-inline">medianValue_Ks</strong> by x<span class="subscript">3</span> , and <strong class="source-inline">nitrixOxide_pp10m</strong> by x<span class="subscript">4</span>, a mathematical expression for the model created canÂ be written as y â‰ˆ 0.8912+0.1028x<span class="subscript">1</span>+0.4948x<span class="subscript">2</span>-0.1103x<span class="subscript">3</span>-2.1039x<span class="subscript">4</span>. </p>
			<p>The expression just stated defines the model created in this exercise, and it is comparable to the expression for multiple linear regression provided in <em class="italic">Figure 2.5</em>Â earlier. </p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Assumptions of Regression Analysis</h1>
			<p>Due to the parametric nature of linear regression analysis, the method makes certain assumptions about the data it analyzes. When these assumptions are not met, the results of the regression analysis may be misleading to say the least. It is, therefore, necessary to check any analysis work to ensure the regression assumptions are notÂ violated. </p>
			<p>Let's review the main assumptions of linear regression analysis that we must ensure are met in order to develop a good model:</p>
			<ol>
				<li value="1">The relationship between the dependent and independent variables must be linear and additive.<p>This means that the relationship must be of the straight-line type, and if there are many independent variables involved, thus multiple linear regression, the weighted sum of these independent variables must be able to explain the variability in the dependent variable. </p></li>
				<li>The residual terms (Ïµ<span class="subscript">i</span>) must be normally distributed. This is so that the standard error of estimate is calculated correctly. This standard error of estimate statistic is used to calculate t-values, which, in turn, are used to make statistical significance decisions. So, if the standard error of estimate is wrong, the t-values will be wrong and so are the statistical significance decisions that follow on from the p-values. The t-values that are calculated using the standard error of estimate are also used to construct confidence intervals for the population regression parameters. If the standard error is wrong, then the confidence intervals will be wrong as well. </li>
				<li>The residual terms (Ïµ<span class="subscript">i</span>) must have constant variance (homoskedasticity). When this is not the case, we have the heteroskedasticity problem. This point refers to the variance of the residual terms. It is assumed to be constant. We assume that each data point in our regression analysis contributes equal explanation to the variability we are seeking to model. If some data points contribute more explanation than others, our regression line will be pulled toward the points with more information. The data points will not be equally scattered around our regression line. The error (variance) about the regression line, in that case, will not be constant. </li>
				<li>The residual terms (Ïµ<span class="subscript">i</span>) must not be correlated. When there is correlation in the residual terms, we have the problem known as autocorrelation. Knowing one residual term, must not give us any information about what the next residual term will be. Residual terms that are autocorrelated are unlikely to have a normal distribution. </li>
				<li>There must not be correlation among the independent variables. When the independent variables are correlated among themselves, we have a problem called multicollinearity. This would lead to developing a model with coefficients that have values that depend on the presence of other independent variables. In other words, we will have a model that will change drastically should a particular independent variable be dropped from the model for example. A model like that will be inaccurate. </li>
			</ol>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Activity 2.02: Fitting a Multiple Log-Linear Regression Model</h2>
			<p>A log-linear regression model you developed earlier was able to explain about 24% of the variability in the transformed crime rate per capita variable (see the values in <em class="italic">Figure 2.17</em>). You are now asked to develop a log-linear multiple regression model that will likely explain 80% or more of the variability in the transformed dependent variable. You should use independent variables from the Boston Housing dataset that have a correlation coefficient of 0.4 or more. </p>
			<p>You are also encouraged to include the interaction of these variables to order two in your model. You should produce graphs and data that show that your model satisfies the assumptions of linear regression.</p>
			<p>The steps are as follows:</p>
			<ol>
				<li value="1">Define a linear regression model and assign it to a variable. Remember to use the <strong class="source-inline">log</strong> function to transform the dependent variable in the formula string, and also include more than one independent variable in your analysis. </li>
				<li>Call the <strong class="source-inline">fit</strong> method of the model instance and assign the results of the method to a new variable. </li>
				<li>Print a summary of the results and analyze your model.<p>Your output should appear as shown:</p><div id="_idContainer095" class="IMG---Figure"><img src="Images/B15019_02_19.jpg" alt="Figure 2.19: Expected OLS results&#13;&#10;" width="842" height="480"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.19: Expected OLS results</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found here: <a href="https://packt.live/2GbJloz">https://packt.live/2GbJloz</a>.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Explaining the Results of Regression Analysis</h1>
			<p>A primary objective of regression analysis is to find a model that explains the variability observed in a dependent variable of interest. It is, therefore, very important to have a quantity that measures how well a regression model explains this variability. The statistic that does this is called R-squared (R<span class="superscript">2</span>). Sometimes, it is also called the coefficient of determination. To understand what it actually measures, we need to take a look at some other definitions. </p>
			<p>The first of these is called the <strong class="bold">Total Sum of Squares</strong> (<strong class="bold">TSS</strong>). TSS gives us a measure of the total variance found in the dependent variable from its mean value. </p>
			<p>The next quantity is called the <strong class="bold">Regression sum of squares</strong> (<strong class="bold">RSS</strong>). This gives us a measure of the amount of variability in the dependent variable that our model explains. If you imagine us creating a perfect model with no errors in prediction, then TSS will be equal to RSS. Our hypothetically perfect model will provide an explanation for all the variability we see in the dependent variable with respect to the mean value. In practice, this rarely happens. Instead, we create models that are not perfect, so RSS is less than TSS. The missing amount by which RSS falls short of TSS is the amount of variability in the dependent variable that our regression model is not able to explain. That quantity is the <strong class="bold">Error Sum of Squares</strong> (<strong class="bold">ESS</strong>), which is essentially the sum of the residual terms of our model. </p>
			<p>R-squared is the ratio of RSS to TSS. This, therefore, gives us a percentage measure of how much variability our regression model is able to explain compared to the total variability in the dependent variable with respect to the mean. R<span class="superscript">2</span> will become smaller when RSS grows smaller and vice versa. In the case of simple linear regression where the independent variable is one, R<span class="superscript">2</span> is enough to decide the overall fit of the model to the data. </p>
			<p>There is a problem, however, when it comes to multiple linear regression. The R<span class="superscript">2</span> is known to be sensitive to the addition of extra independent variables to the model, even if the independent variable is only slightly correlated to the dependent variable. Its addition will increase R<span class="superscript">2</span>. Depending on R<span class="superscript">2</span> alone to make a decision between models defined for the same dependent variable will lead to chasing a complex model that has many independent variables in it. This complexity is not helpful practically. In fact, it may lead to a problem in modeling called overfitting. </p>
			<p>To overcome this problem, the Adjusted R<span class="superscript">2</span> (denoted <em class="italic">Adj. R-Squared</em> on the output of statsmodels) is used to select between models defined for the same dependent variable. Adjusted R<span class="superscript">2</span> will increase only when the addition of an independent variable to the model contributes to explaining the variability in the dependent variable in a meaningful way. </p>
			<p>In <em class="italic">Activity 2.02</em>,<em class="italic"> Fitting a Multiple Log-Linear Regression Model</em>, our model explained 88 percent of the variability in the transformed dependent variable, which is really good. We started with simple models and worked to improve the fit of the models using different techniques. All the exercises and activities done in this chapter have pointed out that the regression analysis workflow is iterative. You start by plotting to get a visual picture and follow from there to improve upon the model you finally develop by using different techniques. Once a good model has been developed, the next step is to validate the model statistically before it can be used for making a prediction or acquiring insight for decision making. Next, let's discuss what validating the model statistically means.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Regression Analysis Checks and Balances</h2>
			<p>In the preceding discussions, we used the R-squared and the Adjusted R-squared statistics to assess the goodness of fit of our models. While the R-squared statistic provides an estimate of the strength of the relationship between a model and the dependent variable(s), it does not provide a formal statistical hypothesis test for thisÂ relationship. </p>
			<p>What do we mean by a formal statistical hypothesis test for a relationship between a dependent variable and some independent variable(s) in a model? </p>
			<p>We must recall that, to say an independent variable has a relationship with a dependent variable in a model, the coefficient (Î²) of that independent variable in the regression model must <em class="italic">not</em> be zero (0). It is well and good to conduct a regression analysis with our Boston Housing dataset and find an independent variable (say the median value of owner-occupied homes) in our model to have a nonzero coefficientÂ (Î²).</p>
			<p>The question is will we (or someone else) find the median value of owner-occupied homes as having a nonzero coefficient (Î²), if we repeat this analysis using a different sample of Boston Housing dataset taken at different locations or times? Is the nonzero coefficient for the median value of owner-occupied homes, found in our analysis, specific to our sample dataset and zero for any other Boston Housing data sample that may be collected? Did we find the nonzero coefficient for the median value of owner-occupied homes by chance? These questions are what hypothesis tests seek to clarify. We cannot be a hundred percent sure that the nonzero coefficient (Î²) of an independent variable is by chance or not. But hypothesis testing gives a framework by which we can calculate the level of confidence where we can say that the nonzero coefficient (Î²) found in our analysis is not by chance. This is how it works. </p>
			<p>We first agree a level of risk (Î±-value or Î±-risk or Type I error) that may exist that the nonzero coefficient (Î²) may have been found by chance. The idea is that we are happy to live with this level of risk of making the error or mistake of claiming that the coefficient (Î²) is nonzero when in fact it is zero.  </p>
			<p>In most practical analyses, the Î±-value is set at 0.05, which is 5 in percentage terms. When we subtract the Î±-risk from one (1-Î±) we have a measure of the level of confidence that we have that the nonzero coefficient (Î²) found in our analysis did not come about by chance. So, our confidence level is 95% at 5% Î±-value. </p>
			<p>We then go ahead to calculate a probability value (usually called the p-value), which gives us a measure of the Î±-risk related to the coefficient (Î²) of interest in our model. We compare the p-value to our chosen Î±-risk, and if the p-value is less than the agreed Î±-risk, we reject the idea that the nonzero coefficient (Î²) was found by chance. This is because the risk of making a mistake of claiming the coefficient (Î²) is nonzero is within the acceptable limit we set for ourselves earlier. </p>
			<p>Another way of stating that the nonzero coefficient (Î²) was NOT found by chance is to say that the coefficient (Î²) is statistically significant or that we reject the null hypothesis (the null hypothesis being that there is no relationship between the variables being studied). We apply these ideas of statistical significance to our models in two stages:</p>
			<ol>
				<li value="1">In stage one, we validate the model as a whole statistically.</li>
				<li>In stage two, we validate the independent variables in our model individually for statistical significance.</li>
			</ol>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>The F-test</h2>
			<p>The F-test is what validates the overall statistical significance of the strength of the relationship between a model and its dependent variables. If the p-value for the F-test is less than the chosen Î±-level (0.05, in our case), we reject the null hypothesis and conclude that the model is statistically significant overall. </p>
			<p>When we fit a regression model, we generate an F-value. This value can be used to determine whether the test is statistically significant. In general, an increase in R<span class="superscript">2</span> increases the F-value. This means that the larger the F-value, the better the chances 	of the overall statistical significance of a model. </p>
			<p>A good F-value is expected to be larger than <strong class="bold">one</strong>. The model in <em class="italic">Figure 2.19</em> has an F-statistic value of 261.5, which is larger than one, and a p-value (Prob (F-statistic)) of approximately zero. The risk of making a mistake and rejecting the null hypothesis when we should not (known as a Type I error in hypothesis testing), is less than the 5% limit we chose to live with at the beginning of the hypothesis test. Because the p-value is less than 0.05, we reject the null hypothesis about our model in <em class="italic">Figure 2.19</em>. Therefore, we state that the model is statistically significant at the chosen 95% confidence level. </p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>The t-test</h2>
			<p>Once a model has been determined to be statistically significant globally, we can proceed to examine the significance of individual independent variables in the model. In <em class="italic">Figure 2.19</em>, the p-values (denoted <strong class="source-inline">p&gt;|t|</strong> in <em class="italic">Section 2</em>) for the independent variables are provided. The p-values were calculated using the t-values also given on the summary results. The process is not different from what was just discussed for the global case. We compare the p-values to the 0.05 Î±-level. If an independent variable has a p-value of less than 0.05, the independent variable is statistically significant in our model in explaining the variability in the dependent variable. If the p-value is 0.05 or higher, the particular independent variable (or term) in our model is not statistically significant. What this means is that that term in our model does not contribute toward explaining the variability in our dependent variable statistically. A close inspection of <em class="italic">Figure 2.19</em> shows that some of the terms have p-values larger than 0.05. These terms don't contribute in a statistically significant way of explaining the variability in our transformed dependent variable. To improve this model, those terms will have to be dropped and a new model tried. It is clear by this point that the process of building a regression model is truly iterative.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Summary</h1>
			<p>This chapter introduced the topic of linear regression analysis using Python. We learned that regression analysis, in general, is a supervised machine learning or data science problem. We learned about the fundamentals of linear regression analysis, including the ideas behind the method of least squares. We also learned about how to use the pandas Python module to load and prepare data for exploration andÂ analysis. </p>
			<p>We explored how to create scatter graphs of bivariate data and how to fit a line of best fit through them. Along the way, we discovered the power of the statsmodels module in Python. We explored how to use it to define simple linear regression models and to solve the model for the relevant parameters. We also learned how to extend that to situations where the number of independent variables is more than one â€“ multiple linear regressions. We investigated approaches by which we can transform a non-linear relation between a dependent and independent variable so that a non-linear problem can be handled using linear regression, introduced because of the transformation. We took a closer look at the statsmodels formula language. We learned how to use it to define a variety of linear models and to solve for their respective model parameters. </p>
			<p>We continued to learn about the ideas underpinning model goodness of fit. We discussed the R-squared statistic as a measure of the goodness of fit for regression models. We followed our discussions with the basic concepts of statistical significance. We learned about how to validate a regression model globally using the F-statistic, which Python calculates for us. We also examined how to check for the statistical significance of individual model coefficients using t-tests and their associated p-values. We reviewed the assumptions of linear regression analysis and how they impact on the validity of any regression analysis work. </p>
			<p>We will now move on from regression analysis, and <em class="italic">Chapter 3</em>, <em class="italic">Binary Classification</em>, and <em class="italic">Chapter 4</em>,<em class="italic"> Multiclass Classification with RandomForest</em>, will discuss binary and multi-label classification, respectively. These chapters will introduce the techniques needed to handle supervised data science problems where the dependent variable is of the categorical data type. </p>
			<p>Regression analysis will be revisited when the important topics of model performance improvement and interpretation are given a closer look later in the book. In <em class="italic">Chapter 8</em>, <em class="italic">Hyperparameter Tuning</em>, we will see how to use k-nearest neighbors and as another method for carrying out regression analysis. We will also be introduced to ridge regression, a linear regression method that is useful for situations where there are a large number of parameters.</p>
		</div>
		<div>
			<div id="_idContainer097" class="Content">
			</div>
		</div>
	</div></body></html>