<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer157" class="Content">
			</div>
		</div>
		<div id="_idContainer158" class="Content">
			<h1 id="_idParaDest-103">4. <a id="_idTextAnchor102"/>Multiclass Classification with RandomForest</h1>
		</div>
		<div id="_idContainer202" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter will show you how to train a multiclass classifier using the Random Forest algorithm. You will also see how to evaluate the performance of multiclass models. </p>
			<p class="callout">By the end of the chapter, you will be able to implement a Random Forest classifier, as well as tune hyperparameters in order to improve model performance.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Introduction</h1>
			<p>In the previous chapter, you saw how to build a binary classifier using the famous <strong class="bold">Logistic Regression</strong> algorithm. A binary classifier can only take two different values for its response variables, such as 0 and 1 or yes and no. A multiclass classification task is just an extension. Its response variable can have more than two different values.</p>
			<p>In the data science industry, quite often you will face multiclass classification problems. For example, if you were working for Netflix or any other streaming platform, you would have to build a model that could predict the user rating for a movie based on key attributes such as genre, duration, or cast. A potential list of rating values may be: <em class="italic">Hate it</em>, <em class="italic">Dislike it</em>, <em class="italic">Neutral</em>, <em class="italic">Like</em> <em class="italic">it</em>, <em class="italic">Love it</em>. The objective of the model would be to predict the right rating from those five possible values.</p>
			<p>Multiclass classification doesn't always mean the response variable will be text. In some datasets, the target variable may be encoded into a numerical form. Taking the same example as discussed, the rating may be coded from 1 to 5: 1 for <em class="italic">Hate it</em>, 2 for <em class="italic">Dislike it</em>, 3 for <em class="italic">Neutral</em>, and so on. So, it is important to understand the meaning of this response variable first before jumping to the conclusion that this is a regression problem.</p>
			<p>In the next section, we will be looking at training our first Random Forest classifier.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Training a Random Forest Classifier</h1>
			<p>In this chapter, we will use the Random Forest algorithm for multiclass classification. There are other algorithms on the market, but Random Forest is probably one of the most popular for such types of projects.</p>
			<p>The Random Forest methodology was first proposed in 1995 by Tin Kam Ho but it was first developed by Leo Breiman in 2001.</p>
			<p>So Random Forest is not really a recent algorithm per se. It has been in use for almost two decades already. But its popularity hasn't faded, thanks to its performance and simplicity.</p>
			<p>For the examples in this chapter, we will be using a dataset called "Activity Recognition system based on Multisensor data." It was originally shared by <em class="italic">F. Palumbo, C. Gallicchio, R. Pucci, and A. Micheli, Human activity recognition using multisensor data fusion based on Reservoir Computing, Journal of Ambient Intelligence and Smart Environments, 2016, 8 (2), pp. 87-107</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The complete dataset can be found here: <a href="https://packt.live/3a5FI1s%20">https://packt.live/3a5FI1s</a></p>
			<p>Let's see how we can train a Random Forest classifier on this dataset. First, we need to load the data from the GitHub repository using <strong class="source-inline">pandas</strong> and then we will print its first five rows using the <strong class="source-inline">head()</strong> method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the example code given outside of Exercises in this chapter relates to this Activity Recognition dataset. It is recommended that all code from these examples is entered and run in a single Google Colab Notebook, and kept separate from your Exercise Notebooks.</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">file_url = 'https://raw.githubusercontent.com/PacktWorkshops'\</p>
			<p class="source-code">           '/The-Data-Science-Workshop/master/Chapter04/'\</p>
			<p class="source-code">           'Dataset/activity.csv'</p>
			<p class="source-code">df = pd.read_csv(file_url)</p>
			<p class="source-code">df.head()</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="Images/B15019_04_01.jpg" alt="Figure 4.1: First five rows of the dataset&#13;&#10;" width="1296" height="374"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1: First five rows of the dataset</p>
			<p>Each row represents an activity that was performed by a person and the name of the activity is stored in the <strong class="source-inline">Activity</strong> column. There are seven different activities in this variable: <strong class="source-inline">bending1</strong>, <strong class="source-inline">bending2</strong>, <strong class="source-inline">cycling</strong>, <strong class="source-inline">lying</strong>, <strong class="source-inline">sitting</strong>, <strong class="source-inline">standing</strong>, and <strong class="source-inline">Walking</strong>. The other six columns are different measurements taken from sensor data. </p>
			<p>In this example, you will accurately predict the target variable (<strong class="source-inline">'Activity'</strong>) from the features (the six other columns) using Random Forest. For example, for the first row of the preceding example, the model will receive the following features as input and will predict the <strong class="source-inline">'bending1'</strong> class:</p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="Images/B15019_04_02.jpg" alt="Figure 4.2: Features for the first row of the dataset&#13;&#10;" width="931" height="94"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2: Features for the first row of the dataset</p>
			<p>But before that, we need to do a bit of data preparation. The <strong class="source-inline">sklearn</strong> package (we will use it to train Random Forest model) requires the target variable and the features to be separated. So, we need to extract the response variable using the <strong class="source-inline">.pop()</strong> method from <strong class="source-inline">pandas</strong>. The <strong class="source-inline">.pop()</strong> method extracts the specified column and removes it from the DataFrame: </p>
			<p class="source-code">target = df.pop('Activity')</p>
			<p>Now the response variable is contained in the variable called <strong class="source-inline">target</strong> and all the features are in the DataFrame called <strong class="source-inline">df</strong>. </p>
			<p>Now we are going to split the dataset into training and testing sets. The model uses the training set to learn relevant parameters in predicting the response variable. The test set is used to check whether a model can accurately predict unseen data. We say the model is overfitting when it has learned the patterns relevant only to the training set and makes incorrect predictions about the testing set. In this case, the model performance will be much higher for the training set compared to the testing one. Ideally, we want to have a very similar level of performance for the training and testing sets. This topic will be covered in more depth in <em class="italic">Chapter 7</em>, <em class="italic">The Generalization of Machine Learning Models</em>.</p>
			<p>The <strong class="source-inline">sklearn</strong> package provides a function called <strong class="source-inline">train_test_split()</strong> to randomly split the dataset into two different sets. We need to specify the following parameters for this function: the feature and target variables, the ratio of the testing set (<strong class="source-inline">test_size</strong>), and <strong class="source-inline">random_state</strong> in order to get reproducible results if we have to run the code again:</p>
			<p class="source-code">from sklearn.model_selection import train_test_split</p>
			<p class="source-code">X_train, X_test, y_train, y_test = train_test_split\</p>
			<p class="source-code">                                   (df, target, test_size=0.33, \</p>
			<p class="source-code">                                    random_state=42)</p>
			<p>There are four different outputs to the <strong class="source-inline">train_test_split()</strong> function: the features for the training set, the target variable for the training set, the features for the testing set, and its target variable. </p>
			<p>Now that we have got our training and testing sets, we are ready for modeling. Let's first import the <strong class="source-inline">RandomForestClassifier</strong> class from <strong class="source-inline">sklearn.ensemble</strong>:</p>
			<p class="source-code">from sklearn.ensemble import RandomForestClassifier</p>
			<p>Now we can instantiate the Random Forest classifier with some hyperparameters. Remember from <em class="italic">Chapter 1, Introduction to Data Science in Python</em>, a hyperparameter is a type of parameter the model can't learn but is set by data scientists to tune the model's learning process. This topic will be covered more in depth in <em class="italic">Chapter 8, Hyperparameter Tuning</em>. For now, we will just specify the <strong class="source-inline">random_state</strong> value. We will walk you through some of the key hyperparameters in the following sections:</p>
			<p class="source-code">rf_model = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                  n_estimators=10)</p>
			<p>The next step is to train (also called fit) the model with the training data. During this step, the model will try to learn the relationship between the response variable and the independent variables and save the parameters learned. We need to specify the features and target variables as parameters: </p>
			<p class="source-code">rf_model.fit(X_train, y_train)</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="Images/B15019_04_03.jpg" alt="Figure 4.3: Logs of the trained RandomForest&#13;&#10;" width="1371" height="245"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3: Logs of the trained RandomForest</p>
			<p>Now that the model has completed its training, we can use the parameters it learned to make predictions on the input data we will provide. In the following example, we are using the features from the training set:</p>
			<p class="source-code">preds = rf_model.predict(X_train)</p>
			<p>Now we can print these predictions:</p>
			<p class="source-code">preds</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="Images/B15019_04_04.jpg" alt="Figure 4.4: Predictions of the RandomForest algorithm on the training set&#13;&#10;" width="1114" height="82"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4: Predictions of the RandomForest algorithm on the training set</p>
			<p>This output shows us the model predicted, respectively, the values <strong class="source-inline">lying</strong>, <strong class="source-inline">bending1</strong>, and <strong class="source-inline">cycling</strong> for the first three observations and <strong class="source-inline">cycling</strong>, <strong class="source-inline">bending1</strong>, and <strong class="source-inline">standing</strong> for the last three observations. Python, by default, truncates the output for a long list of values. This is why it shows only six values here.</p>
			<p>These are basically the key steps required for training a Random Forest classifier. This was quite straightforward, right? Training a machine learning model is incredibly easy but getting meaningful and accurate results is where the challenges lie. In the next section, we will learn how to assess the performance of a trained model.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Evaluating the Model's Performance</h1>
			<p>Now that we know how to train a Random Forest classifier, it is time to check whether we did a good job or not. What we want is to get a model that makes extremely accurate predictions, so we need to assess its performance using some kind of metric.</p>
			<p>For a classification problem, multiple metrics can be used to assess the model's predictive power, such as F1 score, precision, recall, or ROC AUC. Each of them has its own specificity and depending on the projects and datasets, you may use one or another. </p>
			<p>In this chapter, we will use a metric called <strong class="bold">accuracy score</strong>. It calculates the ratio between the number of correct predictions and the total number of predictions made by the model:</p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="Images/B15019_04_05.jpg" alt="Figure 4.5: Formula for accuracy score&#13;&#10;" width="1665" height="126"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5: Formula for accuracy score</p>
			<p>For instance, if your model made 950 correct predictions out of 1,000 cases, then the accuracy score would be 950/1000 = 0.95. This would mean that your model was 95% accurate on that dataset. The <strong class="source-inline">sklearn</strong> package provides a function to calculate this score automatically and it is called <strong class="source-inline">accuracy_score()</strong>. We need to import it first:</p>
			<p class="source-code">from sklearn.metrics import accuracy_score</p>
			<p>Then, we just need to provide the list of predictions for some observations and the corresponding true value for the target variable. Using the previous example, we will use the <strong class="source-inline">y_train</strong> and <strong class="source-inline">preds</strong> variables, which respectively contain the response variable (also known as the target) for the training set and the corresponding predictions made by the Random Forest model. We will reuse the predictions from the previous section – <strong class="source-inline">preds</strong>:</p>
			<p class="source-code">accuracy_score(y_train, preds)</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="Images/B15019_04_06.jpg" alt="Figure 4.6: Accuracy score on the training set&#13;&#10;" width="880" height="32"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6: Accuracy score on the training set</p>
			<p>We achieved an accuracy score of 0.988 on our training data. This means we accurately predicted more than <strong class="source-inline">98%</strong> of these cases. Unfortunately, this doesn't mean you will be able to achieve such a high score for new, unseen data. Your model may have just learned the patterns that are only relevant to this training set, and in that case, the model will overfit. </p>
			<p>If we take the analogy of a student learning a subject for a semester, they could memorize by heart all the textbook exercises but when given a similar but unseen exercise, they wouldn't be able to solve it. Ideally, the student should understand the underlying concepts of the subject and be able to apply that learning to any similar exercises. This is exactly the same for our model: we want it to learn the generic patterns that will help it to make accurate predictions even on unseen data.</p>
			<p>But how can we assess the performance of a model for unseen data? Is there a way to get that kind of assessment? The answer to these questions is yes. </p>
			<p>Remember, in the last section, we split the dataset into training and testing sets. We used the training set to fit the model and assess its predictive power on it. But it hasn't seen the observations from the testing set at all, so we can use it to assess whether our model is capable of generalizing unseen data. Let's calculate the accuracy score for the testing set:</p>
			<p class="source-code">test_preds = rf_model.predict(X_test)</p>
			<p class="source-code">accuracy_score(y_test, test_preds)</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="Images/B15019_04_07.jpg" alt="Figure 4.7: Accuracy score on the testing set&#13;&#10;" width="901" height="38"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7: Accuracy score on the testing set</p>
			<p>OK. Now the accuracy has dropped drastically to <strong class="source-inline">0.77</strong>. The difference between the training and testing sets is quite big. This tells us our model is actually overfitting and learned only the patterns relevant to the training set. In an ideal case, the performance of your model should be equal or very close to equal for those two sets. </p>
			<p>In the next sections, we will look at tuning some Random Forest hyperparameters in order to reduce overfitting. </p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Exercise 4.01: Building a Model for Classifying Animal Type and Assessing Its Performance</h2>
			<p>In this exercise, we will train a Random Forest classifier to predict the type of an animal based on its attributes and check its accuracy score:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The dataset we will be using is the Zoo Data Set shared by Richard S. Forsyth: <a href="https://packt.live/36DpRVK">https://packt.live/36DpRVK</a>. The CSV version of this dataset can be found here: <a href="https://packt.live/37RWGhF">https://packt.live/37RWGhF</a>.</p>
			<ol>
				<li>Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> package:<p class="source-code">import pandas as pd</p></li>
				<li>Create a variable called <strong class="source-inline">file_url</strong> that contains the URL of the dataset:<p class="source-code">file_url = 'https://raw.githubusercontent.com'\</p><p class="source-code">           '/PacktWorkshops/The-Data-Science-Workshop'\</p><p class="source-code">           '/master/Chapter04/Dataset'\</p><p class="source-code">           '/openml_phpZNNasq.csv'</p></li>
				<li>Load the dataset into a DataFrame using the <strong class="source-inline">.read_csv()</strong> method from pandas:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Print the first five rows of the DataFrame:<p class="source-code">df.head()</p><p>You should get the following output:</p><div id="_idContainer166" class="IMG---Figure"><img src="Images/B15019_04_08.jpg" alt="Figure 4.8: First five rows of the DataFrame&#13;&#10;" width="1665" height="255"/></div><p class="figure-caption">Figure 4.8: First five rows of the DataFrame</p><p>We will be using the <strong class="source-inline">type</strong> column as our target variable. We will need to remove the <strong class="source-inline">animal</strong> column from the DataFrame and only use the remaining columns as features.</p></li>
				<li>Remove the <strong class="source-inline">'animal'</strong> column using the <strong class="source-inline">.drop()</strong> method from <strong class="source-inline">pandas</strong> and specify the <strong class="source-inline">columns='animal'</strong> and <strong class="source-inline">inplace=True</strong> parameters (to directly update the original DataFrame):<p class="source-code">df.drop(columns='animal', inplace=True)</p></li>
				<li>Extract the <strong class="source-inline">'type'</strong> column using the <strong class="source-inline">.pop()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">y = df.pop('type')</p></li>
				<li>Print the first five rows of the updated DataFrame:<p class="source-code">df.head()</p><p>You should get the following output:</p><div id="_idContainer167" class="IMG---Figure"><img src="Images/B15019_04_09.jpg" alt="Figure 4.9: First five rows of the DataFrame&#13;&#10;" width="1275" height="218"/></div><p class="figure-caption">Figure 4.9: First five rows of the DataFrame</p></li>
				<li>Import the <strong class="source-inline">train_test_split</strong> function from <strong class="source-inline">sklearn.model_selection</strong>:<p class="source-code">from sklearn.model_selection import train_test_split</p></li>
				<li>Split the dataset into training and testing sets with the <strong class="source-inline">df</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">test_size=0.4</strong>, and <strong class="source-inline">random_state=188</strong> parameters:<p class="source-code">X_train, X_test, y_train, y_test = train_test_split\</p><p class="source-code">                                   (df, y, test_size=0.4, \</p><p class="source-code">                                    random_state=188)</p></li>
				<li>Import <strong class="source-inline">RandomForestClassifier</strong> from <strong class="source-inline">sklearn.ensemble</strong>:<p class="source-code">from sklearn.ensemble import RandomForestClassifier</p></li>
				<li>Instantiate the <strong class="source-inline">RandomForestClassifier</strong> object with <strong class="source-inline">random_state</strong> equal to <strong class="source-inline">42</strong>. Set the <strong class="source-inline">n-estimators</strong> value to an initial default value of <strong class="source-inline">10</strong>. We'll discuss later how changing this value affects the result.<p class="source-code">rf_model = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                  n_estimators=10)</p></li>
				<li>Fit <strong class="source-inline">RandomForestClassifier</strong> with the training set:<p class="source-code">rf_model.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer168" class="IMG---Figure"><img src="Images/B15019_04_10.jpg" alt="Figure 4.10: Logs of RandomForestClassifier&#13;&#10;" width="1027" height="188"/></div><p class="figure-caption">Figure 4.10: Logs of RandomForestClassifier</p></li>
				<li>Predict the outcome of the training set with the <strong class="source-inline">.predict()</strong>method, save the results in a variable called '<strong class="source-inline">train_preds</strong>', and print its value:<p class="source-code">train_preds = rf_model.predict(X_train)</p><p class="source-code">train_preds</p><p>You should get the following output:</p><div id="_idContainer169" class="IMG---Figure"><img src="Images/B15019_04_11.jpg" alt="Figure 4.11: Predictions on the training set&#13;&#10;" width="947" height="272"/></div><p class="figure-caption">Figure 4.11: Predictions on the training set</p></li>
				<li>Import the <strong class="source-inline">accuracy_score</strong> function from <strong class="source-inline">sklearn.metrics</strong>:<p class="source-code">from sklearn.metrics import accuracy_score</p></li>
				<li>Calculate the accuracy score on the training set, save the result in a variable called <strong class="source-inline">train_acc</strong>, and print its value:<p class="source-code">train_acc = accuracy_score(y_train, train_preds)</p><p class="source-code">print(train_acc)</p><p>You should get the following output:</p><div id="_idContainer170" class="IMG---Figure"><img src="Images/B15019_04_12.jpg" alt="Figure 4.12: Accuracy score on the training set&#13;&#10;" width="1665" height="59"/></div><p class="figure-caption">Figure 4.12: Accuracy score on the training set</p><p>Our model achieved an accuracy of <strong class="source-inline">1</strong> on the training set, which means it perfectly predicted the target variable on all of those observations. Let's check the performance on the testing set.</p></li>
				<li>Predict the outcome of the testing set with the <strong class="source-inline">.predict()</strong> method and save the results into a variable called <strong class="source-inline">test_preds</strong>:<p class="source-code">test_preds = rf_model.predict(X_test)</p></li>
				<li>Calculate the accuracy score on the testing set, save the result in a variable called <strong class="source-inline">test_acc</strong>, and print its value:<p class="source-code">test_acc = accuracy_score(y_test, test_preds)</p><p class="source-code">print(test_acc)</p><p>You should get the following output:</p><div id="_idContainer171" class="IMG---Figure"><img src="Images/B15019_04_13.jpg" alt="Figure 4.13: Accuracy score on the testing set &#13;&#10;" width="830" height="38"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.13: Accuracy score on the testing set </p>
			<p>In this exercise, we trained a RandomForest to predict the type of animals based on their key attributes. Our model achieved a perfect accuracy score of <strong class="source-inline">1</strong> on the training set but only <strong class="source-inline">0.88</strong> on the testing set. This means our model is overfitting and is not general enough. The ideal situation would be for the model to achieve a very similar, high-accuracy score on both the training and testing sets.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Q4jpQK">https://packt.live/2Q4jpQK</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3h6JieL">https://packt.live/3h6JieL</a>.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Number of Trees Estimator</h2>
			<p>Now that we know how to fit a Random Forest classifier and assess its performance, it is time to dig into the details. In the coming sections, we will learn how to tune some of the most important hyperparameters for this algorithm. As mentioned in <em class="italic">Chapter 1, Introduction to Data Science in Python</em>, hyperparameters are parameters that are not learned automatically by machine learning algorithms. Their values have to be set by data scientists. These hyperparameters can have a huge impact on the performance of a model, its ability to generalize to unseen data, and the time taken to learn patterns from the data.</p>
			<p>The first hyperparameter you will look at in this section is called <strong class="source-inline">n_estimators</strong>. This hyperparameter is responsible for defining the number of trees that will be trained by the <strong class="source-inline">RandomForest</strong> algorithm. </p>
			<p>Before looking at how to tune this hyperparameter, we need to understand what a tree is and why it is so important for the <strong class="source-inline">RandomForest</strong> algorithm.</p>
			<p>A tree is a logical graph that maps a decision and its outcomes at each of its nodes. Simply speaking, it is a series of yes/no (or true/false) questions that lead to different outcomes. </p>
			<p>A leaf is a special type of node where the model will make a prediction. There will be no split after a leaf. A single node split of a tree may look like this:</p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="Images/B15019_04_14.jpg" alt="Figure 4.14: Example of a single tree node&#13;&#10;" width="942" height="565"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14: Example of a single tree node</p>
			<p>A tree node is composed of a question and two outcomes depending on whether the condition defined by the question is met or not. In the preceding example, the question is <strong class="source-inline">is avg_rss12 &gt; 41?</strong> If the answer is yes, the outcome is the <strong class="source-inline">bending_1</strong> leaf and if not, it will be the <strong class="source-inline">sitting</strong> leaf. </p>
			<p>A tree is just a series of nodes and leaves combined together:</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="Images/B15019_04_15.jpg" alt="Figure 4.15: Example of a tree&#13;&#10;" width="781" height="867"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15: Example of a tree</p>
			<p>In the preceding example, the tree is composed of three nodes with different questions. Now, for an observation to be predicted as <strong class="source-inline">sitting</strong>, it will need to meet the conditions: <strong class="source-inline">avg_rss13 &lt;= 41</strong>, <strong class="source-inline">var_rss &gt; 0.7</strong>, and <strong class="source-inline">avg_rss13 &lt;= 16.25</strong>. </p>
			<p>The <strong class="source-inline">RandomForest</strong> algorithm will build this kind of tree based on the training data it sees. We will not go through the mathematical details about how it defines the split for each node but, basically, it will go through every column of the dataset and see which split value will best help to separate the data into two groups of similar classes. Taking the preceding example, the first node with the <strong class="source-inline">avg_rss13 &gt; 41</strong> condition will help to get the group of data on the left-hand side with mostly the <strong class="source-inline">bending_1</strong> class. The <strong class="source-inline">RandomForest</strong> algorithm usually builds several of this kind of tree and this is the reason why it is called a forest. </p>
			<p>As you may have guessed now, the <strong class="source-inline">n_estimators</strong> hyperparameter is used to specify the number of trees the <strong class="source-inline">RandomForest</strong> algorithm will build. For example (as in the previous exercise), say we ask it to build 10 trees. For a given observation, it will ask each tree to make a prediction. Then, it will average those predictions and use the result as the final prediction for this input. For instance, if, out of 10 trees, 8 of them predict the outcome <strong class="source-inline">sitting</strong>, then the <strong class="source-inline">RandomForest</strong> algorithm will use this outcome as the final prediction.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you don't pass in a specific <strong class="source-inline">n_estimators</strong> hyperparameter, it will use the default value. The default depends on the version of scikit-learn you're using. In early versions, the default value is 10. From version 0.22 onwards, the default is 100. You can find out which version you are using by executing the following code: </p>
			<p class="callout"><strong class="source-inline">import sklearn</strong></p>
			<p class="callout"><strong class="source-inline">sklearn.__version__</strong></p>
			<p class="callout">For more information, see here: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html</a></p>
			<p>In general, the higher the number of trees is, the better the performance you will get. Let's see what happens with <strong class="source-inline">n_estimators = 2</strong> on the Activity Recognition dataset:</p>
			<p class="source-code">rf_model2 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=2)</p>
			<p class="source-code">rf_model2.fit(X_train, y_train)</p>
			<p class="source-code">preds2 = rf_model2.predict(X_train)</p>
			<p class="source-code">test_preds2 = rf_model2.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds2))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds2))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="Images/B15019_04_16.jpg" alt="Figure 4.16: Accuracy of RandomForest with n_estimators = 2&#13;&#10;" width="938" height="71"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16: Accuracy of RandomForest with n_estimators = 2</p>
			<p>As expected, the accuracy is significantly lower than the previous example with <strong class="source-inline">n_estimators = 10</strong>. Let's now try with <strong class="source-inline">50</strong> trees:</p>
			<p class="source-code">rf_model3 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50)</p>
			<p class="source-code">rf_model3.fit(X_train, y_train)</p>
			<p class="source-code">preds3 = rf_model3.predict(X_train)</p>
			<p class="source-code">test_preds3 = rf_model3.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds3))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds3))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="Images/B15019_04_17.jpg" alt="Figure 4.17: Accuracy of RandomForest with n_estimators = 50&#13;&#10;" width="957" height="74"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17: Accuracy of RandomForest with n_estimators = 50</p>
			<p>With <strong class="source-inline">n_estimators = 50</strong>, we respectively gained <strong class="source-inline">1%</strong> and <strong class="source-inline">2%</strong> on the accuracy scored for the training and testing sets, which is great. But the main drawback of increasing the number of trees is that it requires more computational power. So, it will take more time to train a model. In a real project, you will need to find the right balance between performance and training duration.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>Exercise 4.02: Tuning n_estimators to Reduce Overfitting</h2>
			<p>In this exercise, we will train a Random Forest classifier to predict the type of an animal based on its attributes and will try two different values for the <strong class="source-inline">n_estimators</strong> hyperparameter:</p>
			<p>We will be using the same zoo dataset as in the previous exercise.</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas </strong>package, <strong class="source-inline">train_test_split</strong>, <strong class="source-inline">RandomForestClassifier</strong>, and <strong class="source-inline">accuracy_score</strong> from <strong class="source-inline">sklearn</strong>:<p class="source-code">import pandas as pd</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">from sklearn.ensemble import RandomForestClassifier</p><p class="source-code">from sklearn.metrics import accuracy_score</p></li>
				<li>Create a variable called <strong class="source-inline">file_url</strong> that contains the URL to the dataset:<p class="source-code">file_url = 'https://raw.githubusercontent.com'\</p><p class="source-code">           '/PacktWorkshops/The-Data-Science-Workshop'\</p><p class="source-code">           '/master/Chapter04/Dataset'\</p><p class="source-code">           '/openml_phpZNNasq.csv'</p></li>
				<li>Load the dataset into a DataFrame using the <strong class="source-inline">.read_csv()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Remove the <strong class="source-inline">animal</strong> column using <strong class="source-inline">.drop()</strong> and then extract the <strong class="source-inline">type</strong> target variable into a new variable called <strong class="source-inline">y</strong> using <strong class="source-inline">.pop()</strong>:<p class="source-code">df.drop(columns='animal', inplace=True)</p><p class="source-code">y = df.pop('type')</p></li>
				<li>Split the data into training and testing sets with <strong class="source-inline">train_test_split()</strong> and the <strong class="source-inline">test_size=0.4</strong> and <strong class="source-inline">random_state=188</strong> parameters:<p class="source-code">X_train, X_test, y_train, y_test = train_test_split\</p><p class="source-code">                                   (df, y, test_size=0.4, \</p><p class="source-code">                                    random_state=188)</p></li>
				<li>Instantiate <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong> and <strong class="source-inline">n_estimators=1</strong>, and then fit the model with the training set:<p class="source-code">rf_model = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                  n_estimators=1)</p><p class="source-code">rf_model.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer176" class="IMG---Figure"><img src="Images/B15019_04_18.jpg" alt="Figure 4.18: Logs of RandomForestClassifier&#13;&#10;" width="1020" height="190"/></div><p class="figure-caption">Figure 4.18: Logs of RandomForestClassifier</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds</strong> and <strong class="source-inline">test_preds</strong>:<p class="source-code">train_preds = rf_model.predict(X_train)</p><p class="source-code">test_preds = rf_model.predict(X_test)</p></li>
				<li>Calculate the accuracy score for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">train_acc = accuracy_score(y_train, train_preds)</p><p class="source-code">test_acc = accuracy_score(y_test, test_preds)</p></li>
				<li>Print the accuracy scores: <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc)</p><p class="source-code">print(test_acc)</p><p>You should get the following output:</p><div id="_idContainer177" class="IMG---Figure"><img src="Images/B15019_04_19.jpg" alt="Figure 4.19: Accuracy scores for the training and testing sets&#13;&#10;" width="963" height="66"/></div><p class="figure-caption">Figure 4.19: Accuracy scores for the training and testing sets</p><p>The accuracy score decreased for both the training and testing sets. But now the difference is smaller compared to the results from <em class="italic">Exercise 4.01</em>, <em class="italic">Building a Model for Classifying Animal Type and Assessing Its Performance</em>.</p></li>
				<li>Instantiate another <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong> and <strong class="source-inline">n_estimators=30</strong>, and then fit the model with the training set:<p class="source-code">rf_model2 = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                   n_estimators=30)</p><p class="source-code">rf_model2.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer178" class="IMG---Figure"><img src="Images/B15019_04_20.jpg" alt="Figure 4.20: Logs of RandomForest with n_estimators = 30&#13;&#10;" width="1016" height="187"/></div><p class="figure-caption">Figure 4.20: Logs of RandomForest with n_estimators = 30</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds2</strong> and <strong class="source-inline">test_preds2</strong>:<p class="source-code">train_preds2 = rf_model2.predict(X_train)</p><p class="source-code">test_preds2 = rf_model2.predict(X_test)</p></li>
				<li>Calculate the accuracy score for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc2</strong> and <strong class="source-inline">test_acc2</strong>:<p class="source-code">train_acc2 = accuracy_score(y_train, train_preds2)</p><p class="source-code">test_acc2 = accuracy_score(y_test, test_preds2)</p></li>
				<li>Print the accuracy scores: <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc2)</p><p class="source-code">print(test_acc2)</p><p>You should get the following output:</p><div id="_idContainer179" class="IMG---Figure"><img src="Images/B15019_04_21.jpg" alt="Figure 4.21: Accuracy scores for the training and testing sets&#13;&#10;" width="928" height="70"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.21: Accuracy scores for the training and testing sets</p>
			<p>This output shows us the model is overfitting less compared to the results from the previous step and still has a very high-performance level for the training set.</p>
			<p>In the previous exercise, we achieved an accuracy score of <strong class="source-inline">1</strong> for the training set and <strong class="source-inline">0.88</strong> for the testing one. In this exercise, we trained two additional Random Forest models with <strong class="source-inline">n_estimators = 1</strong> and <strong class="source-inline">30</strong>. The model with the lowest number of trees has the lowest accuracy: <strong class="source-inline">0.92</strong> (training) and <strong class="source-inline">0.8</strong> (testing). On the other hand, increasing the number of trees to <strong class="source-inline">30</strong>, we achieved a higher accuracy: <strong class="source-inline">1</strong> and <strong class="source-inline">0.9</strong>. Our model is overfitting slightly less now. It is not perfect, but it is a good start.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/322x8gz">https://packt.live/322x8gz</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/313gUV8">https://packt.live/313gUV8</a>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Maximum Depth</h1>
			<p>In the previous section, we learned how Random Forest builds multiple trees to make predictions. Increasing the number of trees does improve model performance but it usually doesn't help much to decrease the risk of overfitting. Our model in the previous example is still performing much better on the training set (data it has already seen) than on the testing set (unseen data). </p>
			<p>So, we are not confident enough yet to say the model will perform well in production. There are different hyperparameters that can help to lower the risk of overfitting for Random Forest and one of them is called <strong class="source-inline">max_depth</strong>.</p>
			<p>This hyperparameter defines the depth of the trees built by Random Forest. Basically, it tells Random Forest model, how many nodes (questions) it can create before making predictions. But how will that help to reduce overfitting, you may ask. Well, let's say you built a single tree and set the <strong class="source-inline">max_depth</strong> hyperparameter to <strong class="source-inline">50</strong>. This would mean that there would be some cases where you could ask 49 different questions (the value <strong class="source-inline">c</strong> includes the final leaf node) before making a prediction. So, the logic would be <strong class="source-inline">IF X1 &gt; value1 AND X2 &gt; value2 AND X1 &lt;= value3 AND … AND X3 &gt; value49 THEN predict class A</strong>. </p>
			<p>As you can imagine, this is a very specific rule. In the end, it may apply to only a few observations in the training set, with this case appearing very infrequently. Therefore, your model would be overfitting. By default, the value of this <strong class="source-inline">max_depth</strong> parameter is <strong class="source-inline">None</strong>, which means there is no limit set for the depth of the trees.</p>
			<p>What you really want is to find some rules that are generic enough to be applied to bigger groups of observations. This is why it is recommended to not create deep trees with Random Forest. Let's try several values for this hyperparameter on the Activity Recognition dataset: <strong class="source-inline">3</strong>, <strong class="source-inline">10</strong>, and <strong class="source-inline">50</strong>:</p>
			<p class="source-code">rf_model4 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50, max_depth=3)</p>
			<p class="source-code">rf_model4.fit(X_train, y_train)</p>
			<p class="source-code">preds4 = rf_model4.predict(X_train)</p>
			<p class="source-code">test_preds4 = rf_model4.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds4))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds4))</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="Images/B15019_04_22.jpg" alt="Figure 4.22: Accuracy scores for the training and testing sets and a max_depth of 3&#13;&#10;" width="859" height="69"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22: Accuracy scores for the training and testing sets and a max_depth of 3</p>
			<p>For a <strong class="source-inline">max_depth</strong> of <strong class="source-inline">3</strong>, we got extremely similar results for the training and testing sets but the overall performance decreased drastically to <strong class="source-inline">0.61</strong>. Our model is not overfitting anymore, but it is now underfitting; that is, it is not predicting the target variable very well (only in <strong class="source-inline">61%</strong> of cases). Let's increase <strong class="source-inline">max_depth</strong> to <strong class="source-inline">10</strong>:</p>
			<p class="source-code">rf_model5 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50, \</p>
			<p class="source-code">                                   max_depth=10)</p>
			<p class="source-code">rf_model5.fit(X_train, y_train)</p>
			<p class="source-code">preds5 = rf_model5.predict(X_train)</p>
			<p class="source-code">test_preds5 = rf_model5.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds5))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds5))</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="Images/B15019_04_23.jpg" alt="Figure 4.23: Accuracy scores for the training and testing sets and a max_depth of 10&#13;&#10;" width="923" height="72"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23: Accuracy scores for the training and testing sets and a max_depth of 10</p>
			<p>The accuracy of the training set increased and is relatively close to the testing set. We are starting to get some good results, but the model is still slightly overfitting. Now we will see the results for <strong class="source-inline">max_depth = 50</strong>:</p>
			<p class="source-code">rf_model6 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50, \</p>
			<p class="source-code">                                   max_depth=50)</p>
			<p class="source-code">rf_model6.fit(X_train, y_train)</p>
			<p class="source-code">preds6 = rf_model6.predict(X_train)</p>
			<p class="source-code">test_preds6 = rf_model6.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds6))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds6))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="Images/B15019_04_24.jpg" alt="Figure 4.24: Accuracy scores for the training and testing sets and a max_depth of 50&#13;&#10;" width="951" height="67"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24: Accuracy scores for the training and testing sets and a max_depth of 50</p>
			<p>The accuracy jumped to <strong class="source-inline">0.99</strong> for the training set but it didn't improve much for the testing set. So, the model is overfitting with <strong class="source-inline">max_depth = 50</strong>. It seems the sweet spot to get good predictions and not much overfitting is around <strong class="source-inline">10</strong> for the <strong class="source-inline">max_depth</strong> hyperparameter in this dataset.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Exercise 4.03: Tuning max_depth to Reduce Overfitting</h2>
			<p>In this exercise, we will keep tuning our RandomForest classifier that predicts animal type by trying two different values for the <strong class="source-inline">max_depth</strong> hyperparameter:</p>
			<p>We will be using the same zoo dataset as in the previous exercise.</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> package, <strong class="source-inline">train_test_split</strong>, <strong class="source-inline">RandomForestClassifier</strong>, and <strong class="source-inline">accuracy_score</strong> from <strong class="source-inline">sklearn</strong>:<p class="source-code">import pandas as pd</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">from sklearn.ensemble import RandomForestClassifier</p><p class="source-code">from sklearn.metrics import accuracy_score</p></li>
				<li>Create a variable called <strong class="source-inline">file_url</strong> that contains the URL to the dataset:<p class="source-code">file_url = 'https://raw.githubusercontent.com'\</p><p class="source-code">           'PacktWorkshops/The-Data-Science-Workshop'\</p><p class="source-code">           '/master/Chapter04/Dataset'\</p><p class="source-code">           '/openml_phpZNNasq.csv'</p></li>
				<li>Load the dataset into a DataFrame using the <strong class="source-inline">.read_csv()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Remove the <strong class="source-inline">animal</strong> column using <strong class="source-inline">.drop()</strong> and then extract the <strong class="source-inline">type</strong> target variable into a new variable called <strong class="source-inline">y</strong> using <strong class="source-inline">.pop()</strong>:<p class="source-code">df.drop(columns='animal', inplace=True)</p><p class="source-code">y = df.pop('type')</p></li>
				<li>Split the data into training and testing sets with <strong class="source-inline">train_test_split()</strong> and the parameters <strong class="source-inline">test_size=0.4</strong> and <strong class="source-inline">random_state=188</strong>:<p class="source-code">X_train, X_test, y_train, y_test = train_test_split\</p><p class="source-code">                                   (df, y, test_size=0.4, \</p><p class="source-code">                                    random_state=188)</p></li>
				<li>Instantiate <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong>, <strong class="source-inline">n_estimators=30</strong>, and <strong class="source-inline">max_depth=5</strong>, and then fit the model with the training set:<p class="source-code">rf_model = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                  n_estimators=30, \</p><p class="source-code">                                  max_depth=5)</p><p class="source-code">rf_model.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer183" class="IMG---Figure"><img src="Images/B15019_04_25.jpg" alt="Figure 4.25: Logs of RandomForest&#13;&#10;" width="1017" height="193"/></div><p class="figure-caption">Figure 4.25: Logs of RandomForest</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds</strong> and <strong class="source-inline">test_preds</strong>:<p class="source-code">train_preds = rf_model.predict(X_train)</p><p class="source-code">test_preds = rf_model.predict(X_test)</p></li>
				<li>Calculate the accuracy score for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">train_acc = accuracy_score(y_train, train_preds)</p><p class="source-code">test_acc = accuracy_score(y_test, test_preds)</p></li>
				<li>Print the accuracy scores: <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc)</p><p class="source-code">print(test_acc)</p><p>You should get the following output:</p><div id="_idContainer184" class="IMG---Figure"><img src="Images/B15019_04_26.jpg" alt="Figure 4.26: Accuracy scores for the training and testing sets&#13;&#10;" width="987" height="67"/></div><p class="figure-caption">Figure 4.26: Accuracy scores for the training and testing sets</p><p>We got the exact same accuracy scores as for the best result we obtained in the previous exercise. This value for the <strong class="source-inline">max_depth</strong> hyperparameter hasn't impacted the model's performance.</p></li>
				<li>Instantiate another <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong>, <strong class="source-inline">n_estimators=30</strong>, and <strong class="source-inline">max_depth=2</strong>, and then fit the model with the training set:<p class="source-code">rf_model2 = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                   n_estimators=30, \</p><p class="source-code">                                   max_depth=2)</p><p class="source-code">rf_model2.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer185" class="IMG---Figure"><img src="Images/B15019_04_27.jpg" alt="Figure 4.27: Logs of RandomForestClassifier with max_depth = 2&#13;&#10;" width="1023" height="193"/></div><p class="figure-caption">Figure 4.27: Logs of RandomForestClassifier with max_depth = 2</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds2 </strong>and <strong class="source-inline">test_preds2</strong>:<p class="source-code">train_preds2 = rf_model2.predict(X_train)</p><p class="source-code">test_preds2 = rf_model2.predict(X_test)</p></li>
				<li>Calculate the accuracy scores for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc2</strong> and <strong class="source-inline">test_acc2</strong>:<p class="source-code">train_acc2 = accuracy_score(y_train, train_preds2)</p><p class="source-code">test_acc2 = accuracy_score(y_test, test_preds2)</p></li>
				<li>Print the accuracy scores: <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc2)</p><p class="source-code">print(test_acc2)</p><p>You should get the following output:</p><div id="_idContainer186" class="IMG---Figure"><img src="Images/B15019_04_28.jpg" alt="Figure 4.28: Accuracy scores for training and testing sets&#13;&#10;" width="869" height="70"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.28: Accuracy scores for training and testing sets</p>
			<p>You learned how to tune the <strong class="source-inline">max_depth</strong> hyperparameter in this exercise. Reducing its value to <strong class="source-inline">2</strong> decreased the accuracy score for the training set to 0.9 but it also helped to reduce the overfitting for the training and testing set (0.83), so we will keep this value as the optimal one and proceed to the next step.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/31YXkIY">https://packt.live/31YXkIY</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2CCkxYX">https://packt.live/2CCkxYX</a>.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Minimum Sample in Leaf</h1>
			<p>Previously, we learned how to reduce or increase the depth of trees in Random Forest and saw how it can affect its performance and tendency to overfit or not. Now we will go through another important hyperparameter: <strong class="source-inline">min_samples_leaf</strong>.</p>
			<p>This hyperparameter, as its name implies, is related to the leaf nodes of the trees. We saw earlier that the <strong class="source-inline">RandomForest</strong> algorithm builds nodes that will clearly separate observations into two different groups. If we look at the tree example in <em class="italic">Figure 4.15</em>, the top node is splitting data into two groups: the left-hand group contains mainly observations for the <strong class="source-inline">bending_1</strong> class and the right-hand group can be from any class. This sounds like a reasonable split but are we sure it is not increasing the risk of overfitting? For instance, what if this split leads to only one observation falling on the left-hand side? This rule would be very specific (applying to only one single case) and we can't say it is generic enough for unseen data. It may be an edge case in the training set that will never happen again.</p>
			<p>It would be great if we could let the model know to not create such specific rules that happen quite infrequently. Luckily, <strong class="source-inline">RandomForest</strong> has such a hyperparameter and, you guessed it, it is <strong class="source-inline">min_samples_leaf</strong>. This hyperparameter will specify the minimum number of observations (or samples) that will have to fall under a leaf node to be considered in the tree. For instance, if we set <strong class="source-inline">min_samples_leaf</strong> to <strong class="source-inline">3</strong>, then <strong class="source-inline">RandomForest</strong> will only consider a split that leads to at least three observations on both the left and right leaf nodes. If this condition is not met for a split, the model will not consider it and will exclude it from the tree. The default value in <strong class="source-inline">sklearn</strong> for this hyperparameter is <strong class="source-inline">1</strong>. Let's try to find the optimal value for <strong class="source-inline">min_samples_leaf</strong> for the Activity Recognition dataset:</p>
			<p class="source-code">rf_model7 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50, \</p>
			<p class="source-code">                                   max_depth=10, \</p>
			<p class="source-code">                                   min_samples_leaf=3)</p>
			<p class="source-code">rf_model7.fit(X_train, y_train)</p>
			<p class="source-code">preds7 = rf_model7.predict(X_train)</p>
			<p class="source-code">test_preds7 = rf_model7.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds7))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds7))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="Images/B15019_04_29.jpg" alt="Figure 4.29: Accuracy scores for the training and testing sets for min_samples_leaf=3&#13;&#10;" width="864" height="67"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29: Accuracy scores for the training and testing sets for min_samples_leaf=3</p>
			<p>With <strong class="source-inline">min_samples_leaf=3</strong>, the accuracy for both the training and testing sets didn't change much compared to the best model we found in the previous section. Let's try increasing it to <strong class="source-inline">10</strong>:</p>
			<p class="source-code">rf_model8 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50, \</p>
			<p class="source-code">                                   max_depth=10, \</p>
			<p class="source-code">                                   min_samples_leaf=10)</p>
			<p class="source-code">rf_model8.fit(X_train, y_train)</p>
			<p class="source-code">preds8 = rf_model8.predict(X_train)</p>
			<p class="source-code">test_preds8 = rf_model8.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds8))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds8))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="Images/B15019_04_30.jpg" alt="Figure 4.30: Accuracy scores for the training and testing sets for min_samples_leaf=10&#13;&#10;" width="927" height="70"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.30: Accuracy scores for the training and testing sets for min_samples_leaf=10</p>
			<p>Now the accuracy of the training set dropped a bit but increased for the testing set and their difference is smaller now. So, our model is overfitting less. Let's try another value for this hyperparameter – <strong class="source-inline">25</strong>:</p>
			<p class="source-code">rf_model9 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                   n_estimators=50, \</p>
			<p class="source-code">                                   max_depth=10, \</p>
			<p class="source-code">                                   min_samples_leaf=25)</p>
			<p class="source-code">rf_model9.fit(X_train, y_train)</p>
			<p class="source-code">preds9 = rf_model9.predict(X_train)</p>
			<p class="source-code">test_preds9 = rf_model9.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds9))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds9))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="Images/B15019_04_31.jpg" alt="Figure 4.31: Accuracy scores for the training and testing sets for min_samples_leaf=25&#13;&#10;" width="896" height="75"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.31: Accuracy scores for the training and testing sets for min_samples_leaf=25</p>
			<p>Both accuracies for the training and testing sets decreased but they are quite close to each other now. So, we will keep this value (<strong class="source-inline">25</strong>) as the optimal one for this dataset as the performance is still OK and we are not overfitting too much.</p>
			<p>When choosing the optimal value for this hyperparameter, you need to be careful: a value that's too low will increase the chance of the model overfitting, but on the other hand, setting a very high value will lead to underfitting (the model will not accurately predict the right outcome). </p>
			<p>For instance, if you have a dataset of <strong class="source-inline">1000</strong> rows, if you set <strong class="source-inline">min_samples_leaf</strong> to <strong class="source-inline">400</strong>, then the model will not be able to find good splits to predict <strong class="source-inline">5</strong> different classes. In this case, the model can only create one single split and the model will only be able to predict two different classes instead of <strong class="source-inline">5</strong>. It is good practice to start with low values first and then progressively increase them until you reach satisfactory performance.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Exercise 4.04: Tuning min_samples_leaf</h2>
			<p>In this exercise, we will keep tuning our Random Forest classifier that predicts animal type by trying two different values for the <strong class="source-inline">min_samples_leaf</strong> hyperparameter:</p>
			<p>We will be using the same zoo dataset as in the previous exercise.</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> package, <strong class="source-inline">train_test_split</strong>, <strong class="source-inline">RandomForestClassifier</strong>, and <strong class="source-inline">accuracy_score</strong> from <strong class="source-inline">sklearn</strong>:<p class="source-code">import pandas as pd</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">from sklearn.ensemble import RandomForestClassifier</p><p class="source-code">from sklearn.metrics import accuracy_score</p></li>
				<li>Create a variable called <strong class="source-inline">file_url</strong> that contains the URL to the dataset:<p class="source-code">file_url = 'https://raw.githubusercontent.com'\</p><p class="source-code">           '/PacktWorkshops/The-Data-Science-Workshop'\</p><p class="source-code">           '/master/Chapter04/Dataset/openml_phpZNNasq.csv'</p></li>
				<li>Load the dataset into a DataFrame using the <strong class="source-inline">.read_csv()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Remove the <strong class="source-inline">animal</strong> column using <strong class="source-inline">.drop()</strong> and then extract the <strong class="source-inline">type</strong> target variable into a new variable called <strong class="source-inline">y</strong> using <strong class="source-inline">.pop()</strong>:<p class="source-code">df.drop(columns='animal', inplace=True)</p><p class="source-code">y = df.pop('type')</p></li>
				<li>Split the data into training and testing sets with <strong class="source-inline">train_test_split()</strong> and the parameters <strong class="source-inline">test_size=0.4</strong> and <strong class="source-inline">random_state=188</strong>:<p class="source-code">X_train, X_test, \</p><p class="source-code">y_train, y_test = train_test_split(df, y, test_size=0.4, \</p><p class="source-code">                                   random_state=188)</p></li>
				<li>Instantiate <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong>, <strong class="source-inline">n_estimators=30</strong>, <strong class="source-inline">max_depth=2</strong>, and <strong class="source-inline">min_samples_leaf=3</strong>, and then fit the model with the training set:<p class="source-code">rf_model = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                  n_estimators=30, \</p><p class="source-code">                                  max_depth=2, \</p><p class="source-code">                                  min_samples_leaf=3)</p><p class="source-code">rf_model.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer190" class="IMG---Figure"><img src="Images/B15019_04_32.jpg" alt="Figure 4.32: Logs of RandomForest&#13;&#10;" width="1020" height="182"/></div><p class="figure-caption">Figure 4.32: Logs of RandomForest</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds</strong> and <strong class="source-inline">test_preds</strong>:<p class="source-code">train_preds = rf_model.predict(X_train)</p><p class="source-code">test_preds = rf_model.predict(X_test)</p></li>
				<li>Calculate the accuracy score for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">train_acc = accuracy_score(y_train, train_preds)</p><p class="source-code">test_acc = accuracy_score(y_test, test_preds)</p></li>
				<li>Print the accuracy score – <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc)</p><p class="source-code">print(test_acc)</p><p>You should get the following output:</p><div id="_idContainer191" class="IMG---Figure"><img src="Images/B15019_04_33.jpg" alt="Figure 4.33: Accuracy scores for the training and testing sets&#13;&#10;" width="909" height="69"/></div><p class="figure-caption">Figure 4.33: Accuracy scores for the training and testing sets</p><p>The accuracy score decreased for both the training and testing sets compared to the best result we got in the previous exercise. Now the difference between the training and testing sets' accuracy scores is much smaller so our model is overfitting less.</p></li>
				<li>Instantiate another <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong>, <strong class="source-inline">n_estimators=30</strong>, <strong class="source-inline">max_depth=2</strong>, and <strong class="source-inline">min_samples_leaf=7</strong>, and then fit the model with the training set:<p class="source-code">rf_model2 = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                   n_estimators=30, \</p><p class="source-code">                                   max_depth=2, \</p><p class="source-code">                                   min_samples_leaf=7)</p><p class="source-code">rf_model2.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer192" class="IMG---Figure"><img src="Images/B15019_04_34.jpg" alt="Figure 4.34: Logs of RandomForest with max_depth=2&#13;&#10;" width="1023" height="186"/></div><p class="figure-caption">Figure 4.34: Logs of RandomForest with max_depth=2</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds2</strong> and <strong class="source-inline">test_preds2</strong>:<p class="source-code">train_preds2 = rf_model2.predict(X_train)</p><p class="source-code">test_preds2 = rf_model2.predict(X_test)</p></li>
				<li>Calculate the accuracy score for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc2</strong> and <strong class="source-inline">test_acc2</strong>:<p class="source-code">train_acc2 = accuracy_score(y_train, train_preds2)</p><p class="source-code">test_acc2 = accuracy_score(y_test, test_preds2)</p></li>
				<li>Print the accuracy scores:  <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc2)</p><p class="source-code">print(test_acc2)</p><p>You should get the following output:</p><div id="_idContainer193" class="IMG---Figure"><img src="Images/B15019_04_35.jpg" alt="Figure 4.35: Accuracy scores for the training and testing sets&#13;&#10;" width="919" height="69"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.35: Accuracy scores for the training and testing sets</p>
			<p>Increasing the value of <strong class="source-inline">min_samples_leaf</strong> to <strong class="source-inline">7</strong> has led the model to not overfit anymore. We got extremely similar accuracy scores for the training and testing sets, at around <strong class="source-inline">0.8</strong>. We will choose this value as the optimal one for <strong class="source-inline">min_samples_leaf</strong> for this dataset.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3kUYVZa">https://packt.live/3kUYVZa</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/348bv0W">https://packt.live/348bv0W</a>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Maximum Features</h1>
			<p>We are getting close to the end of this chapter. You have already learned how to tune several of the most important hyperparameters for RandomForest. In this section, we will present you with another extremely important one: <strong class="source-inline">max_features</strong>.</p>
			<p>Earlier, we learned that <strong class="source-inline">RandomForest</strong> builds multiple trees and takes the average to make predictions. This is why it is called a forest, but we haven't really discussed the "random" part yet. Going through this chapter, you may have asked yourself: how does building multiple trees help to get better predictions, and won't all the trees look the same given that the input data is the same? </p>
			<p>Before answering these questions, let's use the analogy of a court trial. In some countries, the final decision of a trial is either made by a judge or a jury. A judge is a person who knows the law in detail and can decide whether a person has broken the law or not. On the other hand, a jury is composed of people from different backgrounds who don't know each other or any of the parties involved in the trial and have limited knowledge of the legal system. In this case, we are asking random people who are not expert in the law to decide the outcome of a case. This sounds very risky at first. The risk of one person making the wrong decision is very high. But in fact, the risk of 10 or 20 people all making the wrong decision is relatively low. </p>
			<p>But there is one condition that needs to be met for this to work: randomness. If all the people in the jury come from the same background, work in the same industry, or live in the same area, they may share the same way of thinking and make similar decisions. For instance, if a group of people were raised in a community where you only drink hot chocolate at breakfast and one day you ask them if it is OK to drink coffee at breakfast, they would all say no. </p>
			<p>On the other hand, say you got another group of people from different backgrounds with different habits: some drink coffee, others tea, a few drink orange juice, and so on. If you asked them the same question, you would end up with the majority of them saying yes. Because we randomly picked these people, they have less bias as a group, and this therefore lowers the risk of them making a wrong decision. </p>
			<p>RandomForest actually applies the same logic: it builds a number of trees independently of each other by randomly sampling the data. A tree may see <strong class="source-inline">60%</strong> of the training data, another one <strong class="source-inline">70%</strong>, and so on. By doing so, there is a high chance that the trees are absolutely different from each other and don't share the same bias. This is the secret of RandomForest: building multiple random trees leads to higher accuracy.</p>
			<p>But it is not the only way RandomForest creates randomness. It does so also by randomly sampling columns. Each tree will only see a subset of the features rather than all of them. And this is exactly what the <strong class="source-inline">max_features</strong> hyperparameter is for: it will set the maximum number of features a tree is allowed to see.</p>
			<p>In <strong class="source-inline">sklearn</strong>, you can specify the value of this hyperparameter as:</p>
			<ul>
				<li>The maximum number of features, as an integer.</li>
				<li>A ratio, as the percentage of allowed features.</li>
				<li>The <strong class="source-inline">sqrt</strong> function (the default value in <strong class="source-inline">sklearn</strong>, which stands for square root), which will use the square root of the number of features as the maximum value. If, for a dataset, there are <strong class="source-inline">25</strong> features, its square root will be <strong class="source-inline">5</strong> and this will be the value for <strong class="source-inline">max_features</strong>.</li>
				<li>The <strong class="source-inline">log2</strong> function, which will use the log base, <strong class="source-inline">2</strong>, of the number of features as the maximum value. If, for a dataset, there are eight features, its <strong class="source-inline">log2</strong> will be <strong class="source-inline">3</strong> and this will be the value for <strong class="source-inline">max_features</strong>.</li>
				<li>The <strong class="source-inline">None</strong> value, which means Random Forest will use all the features available.</li>
			</ul>
			<p>Let's try three different values on the activity dataset. First, we will specify the maximum number of features as two:</p>
			<p class="source-code">rf_model10 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                    n_estimators=50, \</p>
			<p class="source-code">                                    max_depth=10, \</p>
			<p class="source-code">                                    min_samples_leaf=25, \</p>
			<p class="source-code">                                    max_features=2)</p>
			<p class="source-code">rf_model10.fit(X_train, y_train)</p>
			<p class="source-code">preds10 = rf_model10.predict(X_train)</p>
			<p class="source-code">test_preds10 = rf_model10.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds10))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds10))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="Images/B15019_04_36.jpg" alt="Figure 4.36: Accuracy scores for the training and testing sets for max_features=2&#13;&#10;" width="954" height="66"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.36: Accuracy scores for the training and testing sets for max_features=2</p>
			<p>We got results similar to those of the best model we trained in the previous section. This is not really surprising as we were using the default value of <strong class="source-inline">max_features</strong> at that time, which is <strong class="source-inline">sqrt</strong>. The square root of <strong class="source-inline">2</strong> equals <strong class="source-inline">1.45</strong>, which is quite close to <strong class="source-inline">2</strong>. This time, let's try with the ratio <strong class="source-inline">0.7</strong>:</p>
			<p class="source-code">rf_model11 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                    n_estimators=50, \</p>
			<p class="source-code">                                    max_depth=10, \</p>
			<p class="source-code">                                    min_samples_leaf=25, \</p>
			<p class="source-code">                                    max_features=0.7)</p>
			<p class="source-code">rf_model11.fit(X_train, y_train)</p>
			<p class="source-code">preds11 = rf_model11.predict(X_train)</p>
			<p class="source-code">test_preds11 = rf_model11.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds11))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds11))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="Images/B15019_04_37.jpg" alt="Figure 4.37: Accuracy scores for the training and testing sets for max_features=0.7&#13;&#10;" width="860" height="67"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.37: Accuracy scores for the training and testing sets for max_features=0.7</p>
			<p>With this ratio, both accuracy scores increased for the training and testing sets and the difference between them is less. Our model is overfitting less now and has slightly improved its predictive power. Let's give it a shot with the <strong class="source-inline">log2</strong> option:</p>
			<p class="source-code">rf_model12 = RandomForestClassifier(random_state=1, \</p>
			<p class="source-code">                                    n_estimators=50, \</p>
			<p class="source-code">                                    max_depth=10, \</p>
			<p class="source-code">                                    min_samples_leaf=25, \</p>
			<p class="source-code">                                    max_features='log2')</p>
			<p class="source-code">rf_model12.fit(X_train, y_train)</p>
			<p class="source-code">preds12 = rf_model12.predict(X_train)</p>
			<p class="source-code">test_preds12 = rf_model12.predict(X_test)</p>
			<p class="source-code">print(accuracy_score(y_train, preds12))</p>
			<p class="source-code">print(accuracy_score(y_test, test_preds12))</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="Images/B15019_04_38.jpg" alt="Figure 4.38: Accuracy scores for the training and testing sets for max_features='log2'&#13;&#10;" width="859" height="68"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.38: Accuracy scores for the training and testing sets for max_features='log2'</p>
			<p>We got similar results as for the default value (<strong class="source-inline">sqrt</strong>) and <strong class="source-inline">2</strong>. Again, this is normal as the <strong class="source-inline">log2</strong> of <strong class="source-inline">6</strong> equals <strong class="source-inline">2.58</strong>. So, the optimal value we found for the <strong class="source-inline">max_features</strong> hyperparameter is <strong class="source-inline">0.7</strong> for this dataset. </p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Exercise 4.05: Tuning max_features</h2>
			<p>In this exercise, we will keep tuning our RandomForest classifier that predicts animal type by trying two different values for the <strong class="source-inline">max_features</strong> hyperparameter:</p>
			<p>We will be using the same zoo dataset as in the previous exercise.</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> package, <strong class="source-inline">train_test_split</strong>, <strong class="source-inline">RandomForestClassifier</strong>, and <strong class="source-inline">accuracy_score</strong> from <strong class="source-inline">sklearn</strong>:<p class="source-code">import pandas as pd</p><p class="source-code">from sklearn.model_selection import train_test_split</p><p class="source-code">from sklearn.ensemble import RandomForestClassifier</p><p class="source-code">from sklearn.metrics import accuracy_score</p></li>
				<li>Create a variable called <strong class="source-inline">file_url</strong> that contains the URL to the dataset:<p class="source-code">file_url = 'https://raw.githubusercontent.com'\</p><p class="source-code">           '/PacktWorkshops/The-Data-Science-Workshop'\</p><p class="source-code">           '/master/Chapter04/Dataset/openml_phpZNNasq.csv'</p></li>
				<li>Load the dataset into a DataFrame using the <strong class="source-inline">.read_csv()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Remove the <strong class="source-inline">animal</strong> column using <strong class="source-inline">.drop()</strong> and then extract the <strong class="source-inline">type</strong> target variable into a new variable called <strong class="source-inline">y</strong> using <strong class="source-inline">.pop()</strong>:<p class="source-code">df.drop(columns='animal', inplace=True)</p><p class="source-code">y = df.pop('type')</p></li>
				<li>Split the data into training and testing sets with <strong class="source-inline">train_test_split()</strong> and the parameters <strong class="source-inline">test_size=0.4</strong> and <strong class="source-inline">random_state=188</strong>:<p class="source-code">X_train, X_test, \</p><p class="source-code">y_train, y_test = train_test_split(df, y, test_size=0.4, \</p><p class="source-code">                                   random_state=188)</p></li>
				<li>Instantiate <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong>, <strong class="source-inline">n_estimators=30</strong>, <strong class="source-inline">max_depth=2</strong>, <strong class="source-inline">min_samples_leaf=7</strong>, and <strong class="source-inline">max_features=10</strong>, and then fit the model with the training set:<p class="source-code">rf_model = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                  n_estimators=30, \</p><p class="source-code">                                  max_depth=2, \</p><p class="source-code">                                  min_samples_leaf=7, \</p><p class="source-code">                                  max_features=10)</p><p class="source-code">rf_model.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer197" class="IMG---Figure"><img src="Images/B15019_04_39.jpg" alt="Figure 4.39: Logs of RandomForest&#13;&#10;" width="1015" height="189"/></div><p class="figure-caption">Figure 4.39: Logs of RandomForest</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds</strong> and <strong class="source-inline">test_preds</strong>:<p class="source-code">train_preds = rf_model.predict(X_train)</p><p class="source-code">test_preds = rf_model.predict(X_test)</p></li>
				<li>Calculate the accuracy scores for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">train_acc = accuracy_score(y_train, train_preds)</p><p class="source-code">test_acc = accuracy_score(y_test, test_preds)</p></li>
				<li>Print the accuracy scores:  <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc)</p><p class="source-code">print(test_acc)</p><p>You should get the following output:</p><div id="_idContainer198" class="IMG---Figure"><img src="Images/B15019_04_40.jpg" alt="Figure 4.40: Accuracy scores for the training and testing sets&#13;&#10;" width="882" height="65"/></div><p class="figure-caption">Figure 4.40: Accuracy scores for the training and testing sets</p></li>
				<li>Instantiate another <strong class="source-inline">RandomForestClassifier</strong> with <strong class="source-inline">random_state=42</strong>, <strong class="source-inline">n_estimators=30</strong>, <strong class="source-inline">max_depth=2</strong>, <strong class="source-inline">min_samples_leaf=7</strong>, and <strong class="source-inline">max_features=0.2</strong>, and then fit the model with the training set:<p class="source-code">rf_model2 = RandomForestClassifier(random_state=42, \</p><p class="source-code">                                   n_estimators=30, \</p><p class="source-code">                                   max_depth=2, \</p><p class="source-code">                                   min_samples_leaf=7, \</p><p class="source-code">                                   max_features=0.2)</p><p class="source-code">rf_model2.fit(X_train, y_train)</p><p>You should get the following output:</p><div id="_idContainer199" class="IMG---Figure"><img src="Images/B15019_04_41.jpg" alt="Figure 4.41: Logs of RandomForest with max_features = 0.2&#13;&#10;" width="1023" height="180"/></div><p class="figure-caption">Figure 4.41: Logs of RandomForest with max_features = 0.2</p></li>
				<li>Make predictions on the training and testing sets with <strong class="source-inline">.predict()</strong> and save the results into two new variables called <strong class="source-inline">train_preds2</strong> and <strong class="source-inline">test_preds2</strong>:<p class="source-code">train_preds2 = rf_model2.predict(X_train)</p><p class="source-code">test_preds2 = rf_model2.predict(X_test)</p></li>
				<li>Calculate the accuracy score for the training and testing sets and save the results in two new variables called <strong class="source-inline">train_acc2</strong> and <strong class="source-inline">test_acc2</strong>:<p class="source-code">train_acc2 = accuracy_score(y_train, train_preds2)</p><p class="source-code">test_acc2 = accuracy_score(y_test, test_preds2)</p></li>
				<li>Print the accuracy scores:  <strong class="source-inline">train_acc</strong> and <strong class="source-inline">test_acc</strong>:<p class="source-code">print(train_acc2)</p><p class="source-code">print(test_acc2)</p><p>You should get the following output:</p><div id="_idContainer200" class="IMG---Figure"><img src="Images/B15019_04_42.jpg" alt="Figure 4.42: Accuracy scores for the training and testing sets&#13;&#10;" width="981" height="67"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.42: Accuracy scores for the training and testing sets</p>
			<p>The values <strong class="source-inline">10</strong> and <strong class="source-inline">0.2</strong>, which we tried in this exercise for the <strong class="source-inline">max_features</strong> hyperparameter, did improve the accuracy of the training set but not the testing set. With these values, the model starts to overfit again. The optimal value for <strong class="source-inline">max_features</strong> is the default value (<strong class="source-inline">sqrt</strong>) for this dataset. In the end, we succeeded in building a model with a 0.8 accuracy score that is not overfitting. This is a pretty good result given the fact the dataset wasn't big: we got only <strong class="source-inline">6</strong> features and <strong class="source-inline">41759</strong> observations.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3g8nTk7">https://packt.live/3g8nTk7</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/324quGv">https://packt.live/324quGv</a>.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Activity 4.01: Train a Random Forest Classifier on the ISOLET Dataset</h2>
			<p>You are working for a technology company and they are planning to launch a new voice assistant product. You have been tasked with building a classification model that will recognize the letters spelled out by a user based on the signal frequencies captured. Each sound can be captured and represented as a signal composed of multiple frequencies.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This activity uses the ISOLET dataset, taken from the UCI Machine Learning Repository from the following link: <a href="https://packt.live/2QFOawy">https://packt.live/2QFOawy</a>.</p>
			<p class="callout">The CSV version of this dataset can be found here: <a href="https://packt.live/36DWHpi">https://packt.live/36DWHpi</a>.</p>
			<p>The following steps will help you to complete this activity:</p>
			<ol>
				<li value="1">Download and load the dataset using <strong class="source-inline">.read_csv()</strong> from <strong class="source-inline">pandas</strong>.</li>
				<li>Extract the response variable using <strong class="source-inline">.pop()</strong> from <strong class="source-inline">pandas</strong>.</li>
				<li>Split the dataset into training and test sets using <strong class="source-inline">train_test_split()</strong> from <strong class="source-inline">sklearn.model_selection</strong>.</li>
				<li>Create a function that will instantiate and fit a <strong class="source-inline">RandomForestClassifier</strong> using <strong class="source-inline">.fit()</strong> from <strong class="source-inline">sklearn.ensemble</strong>.</li>
				<li>Create a function that will predict the outcome for the training and testing sets using <strong class="source-inline">.predict()</strong>.</li>
				<li>Create a function that will print the accuracy score for the training and testing sets using <strong class="source-inline">accuracy_score()</strong> from <strong class="source-inline">sklearn.metrics</strong>.</li>
				<li>Train and get the accuracy score for a range of different hyperparameters. Here are some options you can try: <ul><li><strong class="source-inline">n_estimators = 20</strong> and <strong class="source-inline">50</strong></li><li><strong class="source-inline">max_depth = 5</strong> and <strong class="source-inline">10</strong></li><li><strong class="source-inline">min_samples_leaf = 10</strong> and <strong class="source-inline">50</strong></li><li><strong class="source-inline">max_features = 0.5</strong> and <strong class="source-inline">0.3</strong></li></ul></li>
				<li>Select the best hyperparameter value.</li>
			</ol>
			<p>These are the accuracy scores for the best model we trained:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="Images/B15019_04_43.jpg" alt="Figure 4.43: Accuracy scores for the Random Forest classifier&#13;&#10;" width="955" height="68"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.43: Accuracy scores for the Random Forest classifier</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to the activity can be found here: <a href="https://packt.live/2GbJloz">https://packt.live/2GbJloz</a>.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Summary</h1>
			<p>We have finally reached the end of this chapter on multiclass classification with Random Forest. We learned that multiclass classification is an extension of binary classification: instead of predicting only two classes, target variables can have many more values. We saw how we can train a Random Forest model in just a few lines of code and assess its performance by calculating the accuracy score for the training and testing sets. Finally, we learned how to tune some of its most important hyperparameters: <strong class="source-inline">n_estimators</strong>, <strong class="source-inline">max_depth</strong>, <strong class="source-inline">min_samples_leaf</strong>, and <strong class="source-inline">max_features</strong>. We also saw how their values can have a significant impact on the predictive power of a model but also on its ability to generalize to unseen data.</p>
			<p>In real projects, it is extremely important to choose a valid testing set. This is your final proxy before putting a model into production so you really want it to reflect the types of data you think it will receive in the future. For instance, if your dataset has a date field, you can use the last few weeks or months as your testing set and everything before that date as the training set. If you don't choose the testing set properly, you may end up with a very good model that seems to not overfit but once in production, it will generate incorrect results. The problem doesn't come from the model but from the fact the testing set was chosen poorly.</p>
			<p>In some projects, you may see that the dataset is split into three different sets: training, validation, and testing. The validation set can be used to tune the hyperparameters and once you are confident enough, you can test your model on the testing set. As mentioned earlier, we don't want the model to see too much of the testing set but hyperparameter tuning requires you to run a model several times until you find the optimal values. This is the reason why most data scientists create a validation set for this purpose and only use the testing set a handful of times. This will be explained in more depth in <em class="italic">Chapter 7, The Generalization of Machine Learning Models</em>.</p>
			<p>In the next chapter, you will be introduced to unsupervised learning and will learn how to build a clustering model with the k-means algorithm.</p>
		</div>
	</div></body></html>