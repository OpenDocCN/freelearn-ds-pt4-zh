- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Hyperparameter Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, each hyperparameter tuning strategy will be first broken down
    into its key steps before any high-level scikit-learn implementations are demonstrated.
    This is to ensure that you fully understand the concept behind each of the strategies
    before jumping to the more automated methods.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to find further predictive performance
    improvements via the systematic evaluation of estimators with different hyperparameters.
    You will successfully deploy manual, grid, and random search strategies to find
    the optimal hyperparameters. You will be able to parameterize **k-nearest neighbors**
    (**k-NN**), **support vector machines** (**SVMs**), ridge regression, and random
    forest classifiers to optimize model performance.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed several methods to arrive at a model that
    performs well. These include transforming the data via preprocessing, feature
    engineering and scaling, or simply choosing an appropriate estimator (algorithm)
    type from the large set of possible estimators made available to the users of
    scikit-learn.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which estimator you eventually select, there may be settings that
    can be adjusted to improve overall predictive performance. These settings are
    known as hyperparameters, and deriving the best hyperparameters is known as tuning
    or optimizing. Properly tuning your hyperparameters can result in performance
    improvements well into the double-digit percentages, so it is well worth doing
    in any modeling exercise.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss the concept of hyperparameter tuning and will present
    some simple strategies that you can use to help find the best hyperparameters
    for your estimators.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we have seen some exercises that use a range of estimators,
    but we haven't conducted any hyperparameter tuning. After reading this chapter,
    we recommend you revisit these exercises, apply the techniques taught, and see
    if you can improve the results.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Hyperparameters?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperparameters can be thought of as a set of dials and switches for each estimator
    that change how the estimator works to explain relationships in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at *Figure 8.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: How hyperparameters work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: How hyperparameters work'
  prefs: []
  type: TYPE_NORMAL
- en: If you read from left to right in the preceding figure, you can see that during
    the tuning process we change the value of the hyperparameter, which results in
    a change to the estimator. This in turn causes a change in model performance.
    Our objective is to find hyperparameterization that leads to the best model performance.
    This will be the *optimal* hyperparameterization.
  prefs: []
  type: TYPE_NORMAL
- en: Estimators can have hyperparameters of varying quantities and types, which means
    that sometimes you can be faced with a very large number of possible hyperparameterizations
    to choose for an estimator.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, scikit-learn's implementation of the SVM classifier (`sklearn.svm.SVC`),
    which you will be introduced to later in the chapter, is an estimator that has
    multiple possible hyperparameterizations. We will test out only a small subset
    of these, namely using a linear kernel or a polynomial kernel of degree 2, 3,
    or 4.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these hyperparameters are continuous in nature, while others are discrete,
    and the presence of continuous hyperparameters means that the number of possible
    hyperparameterizations is theoretically infinite. Of course, when it comes to
    producing a model with good predictive performance, some hyperparameterizations
    are much better than others, and it is your job as a data scientist to find them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at setting these hyperparameters in
    more detail. But first, some clarification of terms.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between Hyperparameters and Statistical Model Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your reading on data science, particularly in the area of statistics, you
    will come across terms such as "model parameters," "parameter estimation," and
    "(non)-parametric models." These terms relate to the parameters that feature in
    the mathematical formulation of models. The simplest example is that of the single
    variable linear model with no intercept term that takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Equation for a single variable linear model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.2: Equation for a single variable linear model'
  prefs: []
  type: TYPE_NORMAL
- en: Here, ùõΩ is the statistical model parameter, and if this formulation is chosen,
    it is the data scientist's job to use data to estimate what value it takes. This
    could be achieved using **Ordinary Least Squares** (**OLS**) regression modeling,
    or it could be achieved through a method called median regression.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameters are different in that they are external to the mathematical
    form. An example of a hyperparameter in this case is the way in which ùõΩ will be
    estimated (OLS, or median regression). In some cases, hyperparameters can change
    the algorithm completely (that is, generating a completely different mathematical
    form). You will see examples of this occurring throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be looking at how to set a hyperparameter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Hyperparameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 7*, *The Generalization of Machine Learning Models*, you were introduced
    to the k-NN model for classification and you saw how varying k, the number of
    nearest neighbors, resulted in changes in model performance with respect to the
    prediction of class labels. Here, k is a hyperparameter, and the act of manually
    trying different values of k is a simple form of hyperparameter tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Each time you initialize a scikit-learn estimator, it will take on a hyperparameterization
    as determined by the values you set for its arguments. If you specify no values,
    then the estimator will take on a default hyperparameterization. If you would
    like to see how the hyperparameters have been set for your estimator, and what
    hyperparameters you can adjust, simply print the output of the `estimator.get_params()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say we initialize a k-NN estimator without specifying any arguments
    (empty brackets). To see the default hyperparameterization, we can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A dictionary of all the hyperparameters is now printed to the screen, revealing
    their default settings. Notice `k`, our number of nearest neighbors, is set to
    `5`.
  prefs: []
  type: TYPE_NORMAL
- en: To get more information as to what these parameters mean, how they can be changed,
    and what their likely effect may be, you can run the following command and view
    the help file for the estimator in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our k-NN estimator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Help file for the k-NN estimator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: Help file for the k-NN estimator'
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely at the help file, you will see the default hyperparameterization
    for the estimator under the `String form` heading, along with an explanation of
    what each hyperparameter means under the `Parameters` heading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our example, if we want to change the hyperparameterization
    from `k = 5` to `k = 15`, just re-initialize the estimator and set the `n_neighbors`
    argument to `15`, which will override the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that k is not the only hyperparameter available for k-NN
    classifiers. Setting multiple hyperparameters is as easy as specifying the relevant
    arguments. For example, let''s increase the number of neighbors from `5` to `15`
    and force the algorithm to take the distance of points in the neighborhood, rather
    than a simple majority vote, into account when training. For more information,
    see the description for the `weights` argument in the help file (`?knn`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the output, you can see `n_neighbors` (`k`) is now set to `15`, and `weights`
    is now set to `distance`, rather than `uniform`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found at [https://packt.live/2tN5CH1](https://packt.live/2tN5CH1).
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, efforts have been made by the developers of machine learning libraries
    to set sensible default hyperparameters for estimators. That said, for certain
    datasets, significant performance improvements may be achieved through tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Best Hyperparameterization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best hyperparameterization depends on your overall objective in building
    a machine learning model in the first place. In most cases, this is to find the
    model that has the highest predictive performance on unseen data, as measured
    by its ability to correctly label data points (classification) or predict a number
    (regression).
  prefs: []
  type: TYPE_NORMAL
- en: The prediction of unseen data can be simulated using hold-out test sets or cross-validation,
    the former being the method used in this chapter. Performance is evaluated differently
    in each case, for instance, **Mean Squared Error** (**MSE**) for regression and
    accuracy for classification. We seek to reduce the MSE or increase the accuracy
    of our predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement manual hyperparameterization in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Manual Hyperparameter Tuning for a k-NN Classifier'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will manually tune a k-NN classifier, which was covered
    in *Chapter 7, The Generalization of Machine Learning Models*, our goal being
    to predict incidences of malignant or benign breast cancer based on cell measurements
    sourced from the affected breast sample.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The dataset to be used in this exercise can be found on our GitHub repository
    at [https://packt.live/36dsxIF](https://packt.live/36dsxIF).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the important attributes of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: ID number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagnosis (M = malignant, B = benign)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3-32)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10 real-valued features are computed for each cell nucleus as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Radius (mean of distances from the center to points on the perimeter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture (standard deviation of grayscale values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perimeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoothness (local variation in radius lengths)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compactness (perimeter^2 / area - 1.0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concavity (severity of concave portions of the contour)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concave points (number of concave portions of the contour)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fractal dimension (refers to the complexity of the tissue architecture; "coastline
    approximation" - 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Details on the attributes of the dataset can be found at [https://packt.live/30HzGQ6](https://packt.live/30HzGQ6).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new notebook in Google Colab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, import `neighbors`, `datasets`, and `model_selection` from scikit-learn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the data. We will call this object `cancer`, and isolate the target `y`,
    and the features, `X`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a k-NN classifier with its default hyperparameterization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Feed this classifier into a 10-fold cross-validation (`cv`), calculating the
    precision score for each fold. Assume that maximizing precision (the proportion
    of true positives in all positive classifications) is the primary objective of
    this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Printing `cv` shows the precision score calculated for each fold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate and print the mean precision score for all folds. This will give
    us an idea of the overall performance of the model, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see the mean score is close to 94%. Can this be improved upon?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run everything again, this time setting hyperparameter `k` to `15`. You can
    see that the result is actually marginally worse (1% lower):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try again with `k` = `7`, `3`, and `1`. In this case, it seems reasonable that
    the default value of 5 is the best option. To avoid repetition, you may like to
    define and call a Python function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Nothing beats 94%.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s alter a second hyperparameter. Setting `k = 5`, what happens if we change
    the k-NN weighing system to depend on `distance` rather than having `uniform`
    weights? Run all code again, this time with the following hyperparameterization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Did performance improve?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see no further improvement on the default hyperparameterization
    because the output is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We therefore conclude that the default hyperparameterization is the optimal
    one in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/322lWk4](https://packt.live/322lWk4).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3gbOyfU](https://packt.live/3gbOyfU).
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and Disadvantages of a Manual Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of all the strategies for hyperparameter tuning, the manual process gives you
    the most control. As you go through the process, you can get a feel for how your
    estimators might perform under different hyperparameterizations, and this means
    you can adjust them in line with your expectations without having to try a large
    number of possibilities unnecessarily. However, this strategy is feasible only
    when there is a small number of possibilities you would like to try. When the
    number of possibilities exceeds about five, this strategy becomes too labor-intensive
    to be practical.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will introduce two strategies to better deal with
    this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning Using Grid Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of machine learning, grid search refers to a strategy of systematically
    testing out every hyperparameterization from a pre-defined set of possibilities
    for your chosen estimator. You decide the criteria used to evaluate performance,
    and once the search is complete, you may manually examine the results and choose
    the best hyperparameterization, or let your computer automatically choose it for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: The overall objective is to try and find an optimal hyperparameterization that
    leads to improved performance when predicting unseen data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to the implementations of grid search in scikit-learn, let's first
    demonstrate the strategy using simple Python `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Demonstration of the Grid Search Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following demonstration of the grid search strategy, we will use the
    breast cancer prediction dataset we saw in *Exercise 8.01*, *Manual Hyperparameter
    Tuning for a k-NN Classifier*, where we manually tuned the hyperparameters of
    the k-NN classifier to optimize for the precision of cancer predictions.
  prefs: []
  type: TYPE_NORMAL
- en: This time, instead of manually fitting models with different values of `k` we
    just define the `k` values we would like to try, that is, `k = 1, 3, 5, 7` in
    a Python dictionary. This dictionary will be the grid we will search through to
    find the optimal hyperparameterization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found at [https://packt.live/2U1Y0Li](https://packt.live/2U1Y0Li).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, we have used a dictionary `{}` and set the `k` values in
    a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the code snippet, to conduct the search, we iterate through
    the grid, fitting a model for each value of `k`, each time evaluating the model
    through 10-fold cross-validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of each iteration, we extract, format, and report back the mean
    precision score after cross-validation via the `print` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Average precisions for all folds'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Average precisions for all folds'
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the output that `k = 5` is the best hyperparameterization found,
    with a mean precision score of roughly 94%. Increasing `k` to `7` didn't significantly
    improve performance. It is important to note that the only parameter we are changing
    here is k and that each time the k-NN estimator is initialized, it is done with
    the remaining hyperparameters set to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this point clear, we can run the same loop, this time just printing
    the hyperparameterization that will be tried:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output that the only parameter we are changing is k; everything
    else remains the same in each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Simple, single-loop structures are fine for a grid search of a single hyperparameter,
    but what if we would like to try a second one? Remember that for k-NN we also
    have weights that can take values `uniform` or `distance`, the choice of which
    influences how k-NN learns how to classify points.
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, all we need to do is create a dictionary containing both the values
    of k and the weight functions we would like to try as separate key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Average precision values for all folds for different values of
    k'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.5: Average precision values for all folds for different values of
    k'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that when `k = 5`, the weight function is not based on distance
    and all the other hyperparameters are kept as their default values, and the mean
    precision comes out highest. As we discussed earlier, if you would like to see
    the full set of hyperparameterizations evaluated for k-NN, just add `print(knn.get_params())`
    inside the `for` loop after the estimator is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This implementation, while great for demonstrating how the grid search process
    works, may not practical when trying to evaluate estimators that have `3`, `4`,
    or even `10` different types of hyperparameters, each with a multitude of possible
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: To carry on in this way will mean writing and keeping track of multiple `for`
    loops, which can be tedious. Thankfully, `scikit-learn`'s `model_selection` module
    gives us a method called `GridSearchCV` that is much more user-friendly. We will
    be looking at this in the topic ahead.
  prefs: []
  type: TYPE_NORMAL
- en: GridSearchCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GridsearchCV` is a method of tuning wherein the model can be built by evaluating
    the combination of parameters mentioned in a grid. In the following figure, we
    will see how `GridSearchCV` is different from manual search and look at grid search
    in a muchdetailed way in a table format.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuning using GridSearchCV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can conduct a grid search much more easily in practice by leveraging `model_selection.GridSearchCV`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of comparison, we will use the same breast cancer dataset and
    k-NN classifier as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do after loading the data is to initialize the class
    of the estimator we would like to evaluate under different hyperparameterizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To set up the search, we pass the freshly initialized estimator and our grid
    of hyperparameters to `model_selection.GridSearchCV()`. We must also specify a
    scoring metric, which is the method that will be used to evaluate the performance
    of the various hyperparameterizations tried during the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is set the number splits to be used using cross-validation
    via the `cv` argument. We will set this to `10`, thereby conducting 10-fold cross-validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to feed data to this object via its `fit()` method. Once this
    has been done, the grid search process will be kick-started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, information relating to the search will be printed to the screen,
    allowing you to see the exact estimator parameterizations that will be evaluated
    for the k-NN estimator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Estimator parameterizations for the k-NN estimator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.6: Estimator parameterizations for the k-NN estimator'
  prefs: []
  type: TYPE_NORMAL
- en: Once the search is complete, we can examine the results by accessing and printing
    the `cv_results_` attribute. `cv_results_` is a dictionary containing helpful
    information regarding model performance under each hyperparameterization, such
    as the mean test-set value of your scoring metric (`mean_test_score`, the lower
    the better), the complete list of hyperparameterizations tried (`params`), and
    the model ranks as they relate to the `mean_test_score` (`rank_test_score`).
  prefs: []
  type: TYPE_NORMAL
- en: The best model found will have rank = 1, the second-best model will have rank
    = 2, and so on, as you can see in *Figure 8.8*. The model fitting times are reported
    through `mean_fit_time`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although not usually a consideration for smaller datasets, this value can be
    important because in some cases you may find that a marginal increase in model
    performance through a certain hyperparameterization is associated with a significant
    increase in model fit time, which, depending on the computing resources you have
    available, may render that hyperparameterization infeasible because it will take
    too long to fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: GridsearchCV results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.7: GridsearchCV results'
  prefs: []
  type: TYPE_NORMAL
- en: 'The model ranks can be seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Model ranks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Model ranks'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of presentation, the output has been truncated. You can see
    the complete output here: [https://packt.live/2uD12uP](https://packt.live/2uD12uP).'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, it is worth noting that this dictionary can be easily transformed
    into a pandas DataFrame, which makes information much clearer to read and allows
    us to selectively display the metrics we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we are only interested in each hyperparameterization (`params`)
    and mean cross-validated test score (`mean_test_score`) for the top five high
    - performing models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: mean_test_score for top 5 models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9: mean_test_score for top 5 models'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use pandas to produce visualizations of the result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Using pandas to visualize the output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: Using pandas to visualize the output'
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the preceding figure, you see that the best hyperparameterization
    found is where `n_neighbors = 5` and `weights = 'uniform'`, because this results
    in the highest mean test score (precision).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found at [https://packt.live/2uD12uP](https://packt.live/2uD12uP).
  prefs: []
  type: TYPE_NORMAL
- en: Support Vector Machine (SVM) Classifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **SVM** classifier is basically a supervised machine learning model. It
    is a commonly used class of estimator that can be used for both binary and multi-class
    classification. It is known to perform well in cases where the data is limited,
    hence it is a reliable model. It is relatively fast to train compared to highly
    iterative or ensemble methods such as artificial neural networks or random forests,
    which makes it a good option if there is a limit on your computer's processing
    power.
  prefs: []
  type: TYPE_NORMAL
- en: It makes its predictions by leveraging a special mathematical formulation known
    as a kernel function. This function can take several forms with some functions,
    such as the polynomial kernel function with a degree (squared, cubed, and so on),
    that have their own adjustable parameters.
  prefs: []
  type: TYPE_NORMAL
- en: SVMs have been shown to perform well in the context of image classification,
    which you will see in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on support vector machines, see [https://packt.live/37iDytw](https://packt.live/37iDytw)
    and also refer to [https://packt.live/38xaPkC](https://packt.live/38xaPkC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.02: Grid Search Hyperparameter Tuning for an SVM'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will employ a class of estimator called an SVM classifier
    and tune its hyperparameters using a grid search strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The supervised learning objective we will focus on here is the classification
    of handwritten digits (0-9) based solely on images. The dataset we will use contains
    1,797 labeled images of handwritten digits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The dataset to be used in this exercise can be found on our GitHub repository
    at [https://packt.live/2vdbHg9](https://packt.live/2vdbHg9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Details on the attributes of the dataset can be found on the original dataset''s
    URL: [https://packt.live/36cX35b](https://packt.live/36cX35b).'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new notebook in Google Colab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `datasets`, `svm`, and `model_selection` from scikit-learn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the data. We will call this object images, and then we''ll isolate the
    target `y` and the features `X`. In the training step, the SVM classifier will
    learn how `y` relates to `X` and will therefore be able to predict new `y` values
    when given new `X` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the estimator as a multi-class SVM classifier and set the `gamma`
    argument to `scale`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on the gamma argument, go to [https://packt.live/2Ga2l79](https://packt.live/2Ga2l79).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define our grid to cover four distinct hyperparameterizations of the classifier
    with a linear kernel and with a polynomial kernel of degrees `2`, `3,` and `4`.
    We want to see which of the four hyperparameterizations leads to more accurate
    predictions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up grid search k-fold cross-validation with `10` folds and a scoring measure
    of accuracy. Make sure it has our `grid` and `estimator` objects as inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the search by providing data to the `.fit()` method. Details of the process,
    including the hyperparameterizations tried and the scoring method selected, will
    be printed to the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.11: Grid Search using the .fit() method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.11: Grid Search using the .fit() method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To examine all of the results, simply print `cv_spec.cv_results_` to the screen.
    You will see that the results are structured as a dictionary, allowing you to
    access the information you require using the keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.12: Results as a dictionary'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.12: Results as a dictionary'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this exercise, we are primarily concerned with the test-set performance
    of each distinct hyperparameterization. You can see the first hyperparameterization
    through `cv_spec.cv_results_['mean_test_score']`, and the second through `cv_spec.cv_results_['params']`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s convert the results dictionary to a `pandas` DataFrame and find the
    best hyperparameterization:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13: Parameterization results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.13: Parameterization results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may get slightly different results. However, the values you obtain should
    largely agree with those in the preceding output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is best practice to visualize any results you produce. `pandas` makes this
    easy. Run the following code to produce a visualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14: Using pandas to visualize the results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.14: Using pandas to visualize the results'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/36At2MO](https://packt.live/36At2MO).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YdQsGq](https://packt.live/2YdQsGq).
  prefs: []
  type: TYPE_NORMAL
- en: We can see that an SVM classifier with a third-degree polynomial kernel function
    has the highest accuracy of all the hyperparameterizations evaluated in our search.
    Feel free to add more hyperparameterizations to the grid and see if you can improve
    on the score.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and Disadvantages of Grid Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary advantage of the grid search compared to a manual search is that
    it is an automated process that one can simply set and forget. Additionally, you
    have the power to dictate the exact hyperparameterizations evaluated, which can
    be a good thing when you have prior knowledge of what kind of hyperparameterizations
    might work well in your context. It is also easy to understand exactly what will
    happen during the search thanks to the explicit definitions of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: The major drawback of the grid search strategy is that it is computationally
    very expensive; that is, when the number of hyperparameterizations to try increases
    substantially, processing times can be very slow. Also, when you define your grid,
    you may inadvertently omit an hyperparameterization that would in fact be optimal.
    If it is not specified in your grid, it will never be tried
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these drawbacks, we will be looking at random search in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Random Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of searching through every hyperparameterizations in a pre-defined set,
    as is the case with a grid search, in a random search we sample from a distribution
    of possibilities by assuming each hyperparameter to be a random variable. Before
    we go through the process in depth, it will be helpful to briefly review what
    random variables are and what we mean by a distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Random Variables and Their Distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A random variable is non-constant (its value can change) and its variability
    can be described in terms of distribution. There are many different types of distributions,
    but each falls into one of two broad categories: discrete and continuous. We use
    discrete distributions to describe random variables whose values can take only
    whole numbers, such as counts.'
  prefs: []
  type: TYPE_NORMAL
- en: An example is the count of visitors to a theme park in a day, or the number
    of attempted shots it takes a golfer to get a hole-in-one.
  prefs: []
  type: TYPE_NORMAL
- en: We use continuous distributions to describe random variables whose values lie
    along a continuum made up of infinitely small increments. Examples include human
    height or weight, or outside air temperature. Distributions often have parameters
    that control their shape.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete distributions can be described mathematically using what's called a
    probability mass function, which defines the exact probability of the random variable
    taking a certain value. Common notation for the left-hand side of this function
    is `P(X=x)`, which in plain English means that the probability that the random
    variable `X` equals a certain value `x` is `P`. Remember that probabilities range
    between `0` (impossible) and `1` (certain).
  prefs: []
  type: TYPE_NORMAL
- en: By definition, the summation of each `P(X=x)` for all possible `x`'s will be
    equal to 1, or if expressed another way, the probability that `X` will take any
    value is 1\. A simple example of this kind of distribution is the discrete uniform
    distribution, where the random variable `X` will take only one of a finite range
    of values and the probability of it taking any particular value is the same for
    all values, hence the term uniform.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if there are 10 possible values the probability that `X` is any
    particular value is exactly 1/10\. If there were 6 possible values, as in the
    case of a standard 6-sided die, the probability would be 1/6, and so on. The probability
    mass function for the discrete uniform distribution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15: Probability mass function for the discrete uniform distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.15: Probability mass function for the discrete uniform distribution'
  prefs: []
  type: TYPE_NORMAL
- en: The following code will allow us to see the form of this distribution with 10
    possible values of X.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a list of all the possible values `X` can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We then calculate the probability that `X` will take up any value of `x (P(X=x))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed, the summation of probabilities will equal 1, and this is the
    case with any distribution. We now have everything we need to visualize the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16: Visualizing the bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.16: Visualizing the bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: In the visual output, we see that the probability of `X` being a specific whole
    number between 1 and 10 is equal to 1/10.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Other discrete distributions you commonly see include the binomial, negative
    binomial, geometric, and Poisson distributions, all of which we encourage you
    to investigate. Type these terms into a search engine to find out more.
  prefs: []
  type: TYPE_NORMAL
- en: Distributions of continuous random variables are a bit more challenging in that
    we cannot calculate an exact `P(X=x)` directly because `X` lies on a continuum.
    We can, however, use integration to approximate probabilities between a range
    of values, but this is beyond the scope of this book. The relationship between
    `X` and probability is described using a probability density function, `P(X)`.
    Perhaps the most well-known continuous distribution is the normal distribution,
    which visually takes the form of a bell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The normal distribution has two parameters that describe its shape, mean (`ùúá`)
    and variance (`ùúé`2). The probability density function for the normal distribution
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17: Probability density function for the normal distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.17: Probability density function for the normal distribution'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows two normal distributions with the same mean (`ùúá` `=
    0`) but different variance parameters (`ùúé``2 = 1` and `ùúé``2 = 2.25`). Let''s first
    generate 100 evenly spaced values from `-10` to `10` using NumPy''s `.linspace`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We then generate the approximate `X` probabilities for both normal distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `scipy.stats` is a good way to work with distributions, and its `pdf`
    method allows us to easily visualize the shape of probability density functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `loc` corresponds to ùúá, while `scale` corresponds to the standard
    deviation, which is the square root of `ùúé``2`, hence why we square the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then visualize the result. Notice that `ùúé``2` controls how fat the distribution
    is and therefore how variable the random variable is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18: Visualizing the normal distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.18: Visualizing the normal distribution'
  prefs: []
  type: TYPE_NORMAL
- en: Other discrete distributions you commonly see include the gamma, exponential,
    and beta distributions, which we encourage you to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found at [https://packt.live/38Mfyzm](https://packt.live/38Mfyzm).
  prefs: []
  type: TYPE_NORMAL
- en: Simple Demonstration of the Random Search Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, before we get to the scikit-learn implementation of random search parameter
    tuning, we will step through the process using simple Python tools. Up until this
    point, we have only been using classification problems to demonstrate tuning concepts,
    but now we will look at a regression problem. Can we find a model that's able
    to predict the progression of diabetes in patients based on characteristics such
    as BMI and age?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The original dataset can be found at [https://packt.live/2O4XN6v](https://packt.live/2O4XN6v).
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found at [https://packt.live/3aOudvK](https://packt.live/3aOudvK).
  prefs: []
  type: TYPE_NORMAL
- en: 'We first load the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a feel for the data, we can examine the disease progression for the
    first patient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now examine their characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Dictionary for patient characteristics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.19: Dictionary for patient characteristics'
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario, we will try a technique called ridge regression, which will
    fit a linear model to the data. Ridge regression is a special method that allows
    us to directly employ regularization to help mitigate the problem of overfitting.
    Ridge regression has one key hyperparameter, ùõº, which controls the level of regularization
    in the model fit. If ùõº is set to 1, no regularization will be employed, which
    is actually a special case in which a ridge regression model fit will be exactly
    equal to the fit of an OLS' linear regression model. Increase the value of ùõº and
    you increase the degree of regularization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We covered ridge regression in *Chapter 7*, *The Generalization of Machine Learning
    Models*.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on ridge regression and regularization, see [https://packt.live/2NR3GUq](https://packt.live/2NR3GUq).
  prefs: []
  type: TYPE_NORMAL
- en: In the context of random search parameter tuning, we assume ùõº is a random variable
    and it is up to us to specify a likely distribution.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will assume alpha follows a gamma distribution. This distribution
    takes two parameters, k and ùúÉ, which control the shape and scale of the distribution
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For ridge regression, we believe the optimal ùõº to be somewhere near 1, becoming
    less likely as you move away from 1\. A parameterization of the gamma distribution
    that reflects this idea is where k and ùúÉ are both equal to 1\. To visualize the
    form of this distribution, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20: Visualization of probabilities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.20: Visualization of probabilities'
  prefs: []
  type: TYPE_NORMAL
- en: In the graph, you can see how probability decays sharply for smaller values
    of ùõº, then decays more slowly for larger values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in the random search process is to sample n values from the chosen
    distribution. In this example, we will draw 100 ùõº values. Remember that the probability
    of drawing out a particular value of ùõº is related to its probability as defined
    by this distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We set a random state to ensure reproducible results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotting a histogram of the sample, as shown in the following figure, reveals
    a shape that approximately conforms to the distribution that we have sampled from.
    Note that as your sample sizes increases, the more the histogram conforms to the
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21: Visualization of the sample distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.21: Visualization of the sample distribution'
  prefs: []
  type: TYPE_NORMAL
- en: A model will then be fitted for each value of ùõº sampled and assessed for performance.
    As we have seen with the other approaches to hyperparameter tuning in this chapter,
    performance will be assessed using k-fold cross-validation (with `k =10`) but
    because we are dealing with a regression problem, the performance metric will
    be the test-set negative MSE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this metric means larger values are better. We will store the results
    in a dictionary with each ùõº value as the key and the corresponding cross-validated
    negative MSE as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of examining the raw dictionary of results, we will convert it to a
    pandas DataFrame, transpose it, and give the columns names. Sorting by descending
    negative mean squared error reveals that the optimal level of regularization for
    this problem is actually when ùõº is approximately 1, meaning that we did not find
    evidence to suggest regularization is necessary for this problem and that the
    OLS linear model will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22: Output for the random search process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.22: Output for the random search process'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The results will be different, depending on the data used.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always beneficial to visualize results where possible. Plotting ùõº by
    negative mean squared error as a scatter plot makes it clear that venturing away
    from ùõº = 1 does not result in improvements in predictive performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23: Plotting the scatter plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.23: Plotting the scatter plot'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we found the optimal ùõº to be 1 (its default value) is a special
    case in hyperparameter tuning in that the optimal hyperparameterization is the
    default one.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning Using RandomizedSearchCV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In practice, we can use the `RandomizedSearchCV` method inside scikit-learn''s
    `model_selection` module to conduct the search. All you need to do is pass in
    your estimator, the hyperparameters you wish to tune along with their distributions,
    the number of samples you would like to sample from each distribution, and the
    metric by which you would like to assess model performance. These correspond to
    the `param_distributions`, `n_iter`, and `scoring` arguments respectively. For
    the sake of demonstration, let''s conduct the search we completed earlier using
    `RandomizedSearchCV`. First, we load the data and initialize our ridge regression
    estimator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then specify that the hyperparameter we would like to tune is `alpha` and
    that we would like ùõº to be distributed `gamma`, with `k = 1` and `ùúÉ` `= 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up and run the random search process, which will sample 100 values
    from our `gamma(1,1)` distribution, fit the ridge regression, and evaluate its
    performance using cross-validation scored on the negative mean squared error metric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After completing the search, we can extract the results and generate a pandas
    DataFrame, as we have done previously. Sorting by `rank_test_score` and viewing
    the first five rows aligns with our conclusion that alpha should be set to 1 and
    regularization does not seem to be required for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24: Output for tuning using RandomizedSearchCV'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.24: Output for tuning using RandomizedSearchCV'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding results may vary, depending on the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: Random Search Hyperparameter Tuning for a Random Forest Classifier'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will revisit the handwritten digit classification problem,
    this time using a random forest classifier with hyperparameters tuned using a
    random search strategy. The random forest is a popular method used for both single-class
    and multi-class classification problems. It learns by growing `n` simple tree
    models that each progressively split the dataset into areas that best separate
    the points of different classes.
  prefs: []
  type: TYPE_NORMAL
- en: The final model produced can be thought of as the average of each of the n tree
    models. In this way, the random forest is an `ensemble` method. The parameters
    we will tune in this exercise are `criterion` and `max_features`.
  prefs: []
  type: TYPE_NORMAL
- en: '`criterion` refers to the way in which each split is evaluated from a class
    purity perspective (the purer the splits, the better) and `max_features` is the
    maximum number of features the random forest can use when finding the best splits.'
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will help you complete the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new notebook in Google Colab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the data and isolate the features `X` and the target `y`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the random forest classifier estimator. We will set the `n_estimators`
    hyperparameter to `100`, which means the predictions of the final model will essentially
    be an average of `100` simple tree models. Note the use of a random state to ensure
    the reproducibility of results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One of the parameters we will be tuning is `max_features`. Let''s find out
    the maximum value this could take:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see that we have 64 features:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we know the maximum value of `max_features` we are free to define our
    hyperparameter inputs to the randomized search process. At this point, we have
    no reason to believe any particular value of `max_features` is more optimal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set a discrete uniform distribution covering the range `1` to `64`. Remember
    the probability mass function, `P(X=x) = 1/n`, for this distribution, so `P(X=x)
    = 1/64` in our case. Because `criterion` has only two discrete options, this will
    also be sampled as a discrete uniform distribution with `P(X=x) = ¬Ω`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have everything we need to set up the randomized search process. As
    before, we will use accuracy as the metric of model evaluation. Note the use of
    a random state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s kick off the process with the. `fit` method. Please note that both fitting
    random forests and cross-validation are computationally expensive processes due
    to their internal processes of iteration. Generating a result may take some time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.25: RandomizedSearchCV results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.25: RandomizedSearchCV results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, you need to examine the results. Create a `pandas` DataFrame from the
    `results` attribute, order by the `rank_test_score`, and look at the top five
    model hyperparameterizations. Note that because the random search draws samples
    of hyperparameterizations at random, it is possible to have duplication. We remove
    the duplicate entries from the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.26: Top five hyperparameterizations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.26: Top five hyperparameterizations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may get slightly different results. However, the values you obtain should
    largely agree with those in the preceding output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to visualize the result. Including every parameterization
    will result in a cluttered plot, so we will filter on parameterizations that resulted
    in a mean test score > 0.93:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.27: Visualizing the test scores of the top-performing models'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15019_08_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.27: Visualizing the test scores of the top-performing models'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2uDVct8](https://packt.live/2uDVct8).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3gbQMvw](https://packt.live/3gbQMvw).
  prefs: []
  type: TYPE_NORMAL
- en: We have found the best hyperparameterization to be a random forest classifier
    using the `gini` criterion with the maximum features set to 4.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and Disadvantages of a Random Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a random search takes a finite sample from a range of possible hyperparameterizations
    (`n_iter` in `model_selection.RandomizedSearchCV`), it is feasible to expand the
    range of your hyperparameter search beyond what would be practical with a grid
    search. This is because a grid search has to try everything in the range, and
    setting a large range of values may be too slow to process. Searching this wider
    range gives you the chance of discovering a truly optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the manual and grid search strategies, you do sacrifice a level
    of control to obtain this benefit. The other consideration is that setting up
    random search is a bit more involved than other options in that you have to specify
    distributions. There is always a chance of getting this wrong. That said, if you
    are unsure about what distributions to use, stick with discrete or continuous
    uniform for the respective variable types as this will assign an equal probability
    of selection to all options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Is the Mushroom Poisonous?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you are a data scientist working for the biology department at your
    local university. Your colleague who is a mycologist (a biologist who specializes
    in fungi) has requested that you help her develop a machine learning model capable
    of discerning whether a particular mushroom species is poisonous or not given
    attributes relating to its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of this activity is to employ the grid and randomized search strategies
    to find an optimal model for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The dataset to be used in this exercise can be found on our GitHub repository
    at [https://packt.live/38zdhaB](https://packt.live/38zdhaB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Details on the attributes of the dataset can be found on the original dataset
    site: [https://packt.live/36j0jfA](https://packt.live/36j0jfA).'
  prefs: []
  type: TYPE_NORMAL
- en: Load the data into Python using the `pandas.read_csv()` method, calling the
    object `mushrooms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: The dataset is in CSV format and has no header. Set `header=None` in
    `pandas.read_csv()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Separate the target, `y` and features, `X` from the dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: The target can be found in the first column (`mushrooms.iloc[:,0]`) and
    the features in the remaining columns (`mushrooms.iloc[:,1:]`).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recode the target, `y`, so that poisonous mushrooms are represented as `1` and
    edible mushrooms as `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the columns of the feature set `X` into a `numpy` array with a binary
    representation. This is known as one-hot encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: Use `preprocessing.OneHotEncoder()` to transform `X`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Conduct both a grid and random search to find an optimal hyperparameterization
    for a random forest classifier. Use accuracy as your method of model evaluation.
    Make sure that when you initialize the classifier and when you conduct your random
    search, `random_state = 100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the grid search, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the randomized search, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Plot the mean test score versus hyperparameterization for the top 10 models
    found using random search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a plot similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.28: Mean test score plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15019_08_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.28: Mean test score plot'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to the activity can be found here: [https://packt.live/2GbJloz](https://packt.live/2GbJloz).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered three strategies for hyperparameter tuning
    based on searching for estimator hyperparameterizations that improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: The manual search is the most hands-on of the three but gives you a unique feel
    for the process. It is suitable for situations where the estimator in question
    is simple (a low number of hyperparameters).
  prefs: []
  type: TYPE_NORMAL
- en: The grid search is an automated method that is the most systematic of the three
    but can be very computationally intensive to run when the range of possible hyperparameterizations
    increases.
  prefs: []
  type: TYPE_NORMAL
- en: The random search, while the most complicated to set up, is based on sampling
    from distributions of hyperparameters, which allows you to expand the search range,
    thereby giving you the chance to discover a good solution that you may miss with
    the grid or manual search options.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how to visualize results, summarize
    models, and articulate feature importance and weights.
  prefs: []
  type: TYPE_NORMAL
