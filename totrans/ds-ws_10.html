<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer474" class="Content">
			</div>
		</div>
		<div id="_idContainer475" class="Content">
			<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>10. Analyzing a Dataset</h1>
		</div>
		<div id="_idContainer525" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to explain the key steps involved in performing exploratory data analysis; identify the types of data contained in the dataset; summarize the dataset and at a detailed level for each variable; visualize the data distribution in each column; find relationships between variables and analyze missing values and outliers for each variable</p>
			<p class="callout">This chapter will introduce you to the art of performing exploratory data analysis and visualizing the data in order to identify quality issues, potential data transformations, and interesting patterns.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor242"/>Introduction</h1>
			<p>The previous chapter was all about improving our machine learning model, and interpreting its results and parameters to provide meaningful insights to the business. This chapter opens the third part of this book: <em class="italic">enhancing your dataset</em>. In the next three chapters, we are taking a step back and will be focusing on the key input of any machine learning model: the dataset. We will learn how to explore a new dataset, prepare it for the modeling stage, and create new variables (also called <strong class="bold">feature engineering</strong>). These are very exciting and important topics to learn about, so let's jump in.</p>
			<p>When we mention data science, most people think about building fancy machine learning algorithms for predicting future outcomes. They usually do not think about all the other critical tasks involved in a data science project. In reality, the modeling step covers only a small part of such a project. You may have already heard about the <em class="italic">rule of thumb</em> stating that data scientists spend only 20% of their time fitting a model and the other 80% on understanding and preparing the data. This is actually quite close to reality.</p>
			<p>A very popular methodology that's used in the industry for running data science projects is <strong class="bold">CRISP-DM</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will not go into too much detail about this methodology as it is out of the scope of this book. But if you are interested in learning more about it, you can find the description of CRISP-DM here: <a href="https://packt.live/2QMRepG">https://packt.live/2QMRepG</a>.</p>
			<p>This methodology breaks down a data science project into six different stages:</p>
			<ol>
				<li>Business understanding</li>
				<li>Data understanding</li>
				<li>Data preparation</li>
				<li>Modeling</li>
				<li>Evaluation</li>
				<li>Deployment</li>
			</ol>
			<p>As you can see, modeling represents only one phase out of the six and it happens quite close toward the end of the project. In this chapter, we will mainly focus on the second step of CRISP-DM: the data understanding stage.</p>
			<p>You may wonder why it is so important to understand the data and why we shouldn't spend more time on modeling. Some researchers have actually shown that training very simple models on high-quality data outperformed extremely complex models with bad data. </p>
			<p>If your data is not right, even the most advanced model will not be able to find the relevant patterns and predict the right outcome. This is <em class="italic">garbage in, garbage out</em>, which means that the wrong input will lead to the wrong output. Therefore, we need to have a good grasp of the limitations and issues of our dataset and fix them before fitting it into a model. </p>
			<p>The second reason why it is so important to understand the input data is because it will also help us to define the right approach and shortlist the relevant algorithms accordingly. For instance, if you see that a specific class is less represented compared to other ones in your dataset, you may want to use specific algorithms that can handle imbalanced data or use some resampling techniques beforehand to make the classes more evenly distributed.</p>
			<p>In this chapter, you will learn about some of the key concepts and techniques for getting a deep and good understanding of your data.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/>Exploring Your Data</h1>
			<p>If you are running your project by following the CRISP-DM methodology, the first step will be to discuss the project with the stakeholders and clearly define their requirements and expectations. Only once this is clear can you start having a look at the data and see whether you will be able to achieve these objectives.</p>
			<p>After receiving a dataset, you may want to make sure that the dataset contains the information you need for your project. For instance, if you are working on a supervised project, you will check whether this dataset contains the target variable you need and whether there are any missing or incorrect values for this field. You may also check how many observations (rows) and variables (columns) there are. These are the kind of questions you will have initially with a new dataset. This section will introduce you to some techniques you can use to get the answers to these questions.</p>
			<p>For the rest of this section, we will be working with a dataset containing transactions from an online retail store.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This dataset is in our GitHub repository: <a href="https://packt.live/36s4XIN">https://packt.live/36s4XIN</a>. </p>
			<p class="callout">It was sourced from <a href="https://packt.live/2Qu5XqC">https://packt.live/2Qu5XqC</a>, courtesy of Daqing Chen, Sai Liang Sain, and Kun Guo, Data mining for the online retail industry, UCI Machine Learning Repository.</p>
			<p>Our dataset is an Excel spreadsheet. Luckily, the <strong class="source-inline">pandas</strong> package provides a method we can use to load this type of file: <strong class="source-inline">read_excel()</strong>. </p>
			<p>Let's read the data using the <strong class="source-inline">.read_excel()</strong> method and store it in a <strong class="source-inline">pandas</strong> DataFrame, as shown in the following code snippet:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">file_url = 'https://github.com/PacktWorkshops/'\</p>
			<p class="source-code">           'The-Data-Science-Workshop/blob/'\</p>
			<p class="source-code">           'master/Chapter10/dataset/'\</p>
			<p class="source-code">           'Online%20Retail.xlsx?raw=true'</p>
			<p class="source-code">df = pd.read_excel(file_url)</p>
			<p>After loading the data into a DataFrame, we want to know the size of this dataset, that is, its number of rows and columns. To get this information, we just need to call the <strong class="source-inline">.shape</strong> attribute from <strong class="source-inline">pandas</strong>:</p>
			<p class="source-code">df.shape</p>
			<p>You should get the following output:</p>
			<p class="source-code">(541909, 8)</p>
			<p>This attribute returns a tuple containing the number of rows as the first element and the number of columns as the second element. The loaded dataset contains <strong class="source-inline">541909</strong> rows and <strong class="source-inline">8</strong> different columns. </p>
			<p>Since this attribute returns a tuple, we can access each of its elements independently by providing the relevant index. Let's extract the number of rows (index <strong class="source-inline">0</strong>):</p>
			<p class="source-code">df.shape[0]</p>
			<p>You should get the following output:</p>
			<p class="source-code">541909</p>
			<p>Similarly, we can get the number of columns with the second index:</p>
			<p class="source-code">df.shape[1]</p>
			<p>You should get the following output:</p>
			<p class="source-code">8</p>
			<p>Usually, the first row of a dataset is the header. It contains the name of each column. By default, the <strong class="source-inline">read_excel()</strong> method assumes that the first row of the file is the header. If the <strong class="source-inline">header</strong> is stored in a different row, you can specify a different index for the header with the parameter header from <strong class="source-inline">read_excel()</strong>, such as <strong class="source-inline">pd.read_excel(header=1)</strong> for specifying the header column is the second row. </p>
			<p>Once loaded into a <strong class="source-inline">pandas</strong> DataFrame, you can print out its content by calling it directly:</p>
			<p class="source-code">df</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer476" class="IMG---Figure">
					<img src="Images/B15019_10_01.jpg" alt="Figure 10.1: First few rows of the loaded online retail DataFrame&#13;&#10;" width="1665" height="425"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: First few rows of the loaded online retail DataFrame</p>
			<p>To access the names of the columns for this DataFrame, we can call the <strong class="source-inline">.columns</strong> attribute:</p>
			<p class="source-code">df.columns</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer477" class="IMG---Figure">
					<img src="Images/B15019_10_02.jpg" alt="Figure 10.2: List of the column names for the online retail DataFrame&#13;&#10;" width="1252" height="111"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: List of the column names for the online retail DataFrame</p>
			<p>The columns from this dataset are <strong class="source-inline">InvoiceNo</strong>, <strong class="source-inline">StockCode</strong>, <strong class="source-inline">Description</strong>, <strong class="source-inline">Quantity</strong>, <strong class="source-inline">InvoiceDate</strong>, <strong class="source-inline">UnitPrice</strong>, <strong class="source-inline">CustomerID</strong>, and <strong class="source-inline">Country</strong>. We can infer that a row from this dataset represents the sale of an article for a given quantity and price for a specific customer at a particular date.</p>
			<p>Looking at these names, we can potentially guess what types of information are contained in these columns, however, to be sure, we can use the <strong class="source-inline">dtypes</strong> attribute, as shown in the following code snippet:</p>
			<p class="source-code">df.dtypes</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer478" class="IMG---Figure">
					<img src="Images/B15019_10_03.jpg" alt="Figure 10.3: Description of the data type for each column of the DataFrame&#13;&#10;" width="929" height="315"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3: Description of the data type for each column of the DataFrame</p>
			<p>From this output, we can see that the <strong class="source-inline">InvoiceDate</strong> column is a date type (<strong class="source-inline">datetime64[ns]</strong>), <strong class="source-inline">Quantity</strong> is an integer (<strong class="source-inline">int64</strong>), and that <strong class="source-inline">UnitPrice</strong> and <strong class="source-inline">CustomerID</strong> are decimal numbers (<strong class="source-inline">float64</strong>). The remaining columns are text (<strong class="source-inline">object</strong>).</p>
			<p>The <strong class="source-inline">pandas</strong> package provides a single method that can display all the information we have seen so far, that is, the <strong class="source-inline">info()</strong> method:</p>
			<p class="source-code">df.info()</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer479" class="IMG---Figure">
					<img src="Images/B15019_10_04.jpg" alt="Figure 10.4: Output of the info() method&#13;&#10;" width="1074" height="445"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4: Output of the info() method</p>
			<p>In just a few lines of code, we learned some high-level information about this dataset, such as its size, the column names, and their types. </p>
			<p>In the next section, we will analyze the content of a dataset.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor244"/>Analyzing Your Dataset</h1>
			<p>Previously, we learned about the overall structure of a dataset and the kind of information it contains. Now, it is time to really dig into it and look at the values of each column.</p>
			<p>First, we need to import the <strong class="source-inline">pandas</strong> package:</p>
			<p class="source-code">import pandas as pd</p>
			<p>Then, we'll load the data into a <strong class="source-inline">pandas</strong> DataFrame:</p>
			<p class="source-code">file_url = 'https://github.com/PacktWorkshops/'\</p>
			<p class="source-code">           'The-Data-Science-Workshop/blob/'\</p>
			<p class="source-code">           'master/Chapter10/dataset/'\</p>
			<p class="source-code">           'Online%20Retail.xlsx?raw=true'</p>
			<p class="source-code">df = pd.read_excel(file_url)</p>
			<p>The <strong class="source-inline">pandas</strong> package provides several methods so that you can display a snapshot of your dataset. The most popular ones are <strong class="source-inline">head()</strong>, <strong class="source-inline">tail()</strong>, and <strong class="source-inline">sample()</strong>.</p>
			<p>The <strong class="source-inline">head()</strong> method will show the top rows of your dataset. By default, <strong class="source-inline">pandas</strong> will display the first five rows:</p>
			<p class="source-code">df.head()</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer480" class="IMG---Figure">
					<img src="Images/B15019_10_05.jpg" alt="Figure 10.5: Displaying the first five rows using the head() method&#13;&#10;" width="1665" height="286"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5: Displaying the first five rows using the head() method</p>
			<p>The output of the <strong class="source-inline">head()</strong> method shows that the <strong class="source-inline">InvoiceNo</strong>, <strong class="source-inline">StockCode</strong>, and <strong class="source-inline">CustomerID</strong> columns are unique identifier fields for each purchasing invoice, item sold, and customer. The <strong class="source-inline">Description</strong> field is text describing the item sold. <strong class="source-inline">Quantity</strong> and <strong class="source-inline">UnitPrice</strong> are the number of items sold and their unit price, respectively. <strong class="source-inline">Country</strong> is a text field that can be used for specifying where the customer or the item is located or from which country version of the online store the order has been made. In a real project, you may reach out to the team who provided this dataset and confirm what the meaning of the <strong class="source-inline">Country</strong> column is, or any other column details that you may need, for that matter.</p>
			<p>With <strong class="source-inline">pandas</strong>, you can specify the number of top rows to be displayed with the <strong class="source-inline">head()</strong> method by providing an integer as its parameter. Let's try this by displaying the first <strong class="source-inline">10</strong> rows:</p>
			<p class="source-code">df.head(10)</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer481" class="IMG---Figure">
					<img src="Images/B15019_10_06.jpg" alt="Figure 10.6: Displaying the first 10 rows using the head() method&#13;&#10;" width="1665" height="543"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6: Displaying the first 10 rows using the head() method</p>
			<p>Looking at this output, we can assume that the data is sorted by the <strong class="source-inline">InvoiceDate</strong> column and grouped by <strong class="source-inline">CustomerID</strong> and <strong class="source-inline">InvoiceNo</strong>. We can only see one value in the <strong class="source-inline">Country</strong> column: <strong class="source-inline">United Kingdom</strong>. Let's check whether this is really the case by looking at the last rows of the dataset. This can be achieved by calling the <strong class="source-inline">tail()</strong> method. Like <strong class="source-inline">head()</strong>, this method, by default, will display only five rows, but you can specify the number of rows you want as a parameter. Here, we will display the last eight rows:</p>
			<p class="source-code">df.tail(8)</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer482" class="IMG---Figure">
					<img src="Images/B15019_10_07.jpg" alt="Figure 10.7: Displaying the last eight rows using the tail() method&#13;&#10;" width="1665" height="444"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7: Displaying the last eight rows using the tail() method</p>
			<p>It seems that we were right in assuming that the data is sorted in ascending order by the <strong class="source-inline">InvoiceDate</strong> column. We can also confirm that there is actually more than one value in the <strong class="source-inline">Country</strong> column.</p>
			<p>We can also use the <strong class="source-inline">sample()</strong> method to randomly pick a given number of rows from the dataset with the <strong class="source-inline">n</strong> parameter. You can also specify a <strong class="bold">seed</strong> (which we covered in <em class="italic">Chapter 5</em>, <em class="italic">Performing Your First Cluster Analysis</em>) in order to get reproducible results if you run the same code again with the <strong class="source-inline">random_state</strong> parameter:</p>
			<p class="source-code">df.sample(n=5, random_state=1)</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer483" class="IMG---Figure">
					<img src="Images/B15019_10_08.jpg" alt="Figure 10.8: Displaying five random sampled rows using the sample() method&#13;&#10;" width="1665" height="302"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8: Displaying five random sampled rows using the sample() method</p>
			<p>In this output, we can see an additional value in the <strong class="source-inline">Country</strong> column: <strong class="source-inline">Germany</strong>. We can also notice a few interesting points:</p>
			<ul>
				<li><strong class="source-inline">InvoiceNo</strong> can also contain alphabetical letters (row <strong class="source-inline">94,801</strong> starts with a <strong class="source-inline">C</strong>, which may have a special meaning).</li>
				<li><strong class="source-inline">Quantity</strong> can have negative values: <strong class="source-inline">-2</strong> (row <strong class="source-inline">94801</strong>).</li>
				<li><strong class="source-inline">CustomerID</strong> contains missing values: <strong class="source-inline">NaN</strong> (row <strong class="source-inline">210111</strong>).</li>
			</ul>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/>Exercise 10.01: Exploring the Ames Housing Dataset with Descriptive Statistics</h2>
			<p>In this exercise, we will explore the <strong class="source-inline">Ames Housing dataset</strong> in order to get a good understanding of it by analyzing its structure and looking at some of its rows. </p>
			<p>The dataset we will be using in this exercise is the Ames Housing dataset, which can be found on our GitHub repository: <a href="https://packt.live/35kRKAo">https://packt.live/35kRKAo</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This dataset was compiled by Dean De Cock. </p>
			<p class="callout">This dataset contains a list of residential house sales in the city of Ames, Iowa, between 2016 and 2010.</p>
			<p class="callout">More information about each variable can be found at <a href="https://packt.live/2sT88L4">https://packt.live/2sT88L4</a>.</p>
			<p>The following steps will help you to complete this exercise:</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> package:<p class="source-code">import pandas as pd</p></li>
				<li>Assign the link to the AMES dataset to a variable called <strong class="source-inline">file_url</strong>:<p class="source-code">file_url = 'https://raw.githubusercontent.com/'\</p><p class="source-code">           'PacktWorkshops/The-Data-Science-Workshop/'\</p><p class="source-code">           'master/Chapter10/dataset/ames_iowa_housing.csv'</p></li>
				<li>Use the <strong class="source-inline">.read_csv()</strong> method from the <strong class="source-inline">pandas </strong>package and load the dataset into a new variable called <strong class="source-inline">df</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Print the number of rows and columns of the DataFrame using the <strong class="source-inline">shape</strong> attribute from the <strong class="source-inline">pandas</strong> package:<p class="source-code">df.shape</p><p>You should get the following output:</p><p class="source-code">(1460, 81)</p><p>We can see that this dataset contains <strong class="source-inline">1460</strong> rows and <strong class="source-inline">81</strong> different columns. </p></li>
				<li>Print the names of the variables contained in this DataFrame using the <strong class="source-inline">columns</strong> attribute from the <strong class="source-inline">pandas</strong> package:<p class="source-code">df.columns</p><p>You should get the following output:</p><div id="_idContainer484" class="IMG---Figure"><img src="Images/B15019_10_09.jpg" alt="Figure 10.9: List of columns in the housing dataset&#13;&#10;" width="945" height="461"/></div><p class="figure-caption">Figure 10.9: List of columns in the housing dataset</p><p>We can infer the type of information contained in some of the variables by looking at their names, such as <strong class="source-inline">LotArea</strong> (property size), <strong class="source-inline">YearBuilt</strong> (year of construction), and <strong class="source-inline">SalePrice</strong> (property sale price).</p></li>
				<li>Print out the type of each variable contained in this DataFrame using the <strong class="source-inline">dtypes</strong> attribute from the <strong class="source-inline">pandas</strong> package:<p class="source-code">df.dtypes</p><p>You should get the following output:</p><div id="_idContainer485" class="IMG---Figure"><img src="Images/B15019_10_10.jpg" alt="Figure 10.10: List of columns and their type from the housing dataset&#13;&#10;" width="953" height="359"/></div><p class="figure-caption">Figure 10.10: List of columns and their type from the housing dataset</p><p>We can see that the variables are either numerical or text types. There is no date column in this dataset.</p></li>
				<li>Display the top rows of the DataFrame using the <strong class="source-inline">head()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">df.head()</p><p>You should get the following output:</p><div id="_idContainer486" class="IMG---Figure"><img src="Images/B15019_10_11.jpg" alt="Figure 10.11: First five rows of the housing dataset&#13;&#10;" width="961" height="260"/></div><p class="figure-caption">Figure 10.11: First five rows of the housing dataset</p></li>
				<li>Display the last five rows of the DataFrame using the <strong class="source-inline">tail()</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">df.tail()</p><p>You should get the following output:</p><div id="_idContainer487" class="IMG---Figure"><img src="Images/B15019_10_12.jpg" alt="Figure 10.12: Last five rows of the housing dataset&#13;&#10;" width="1055" height="280"/></div><p class="figure-caption">Figure 10.12: Last five rows of the housing dataset</p><p>It seems that the <strong class="source-inline">Alley</strong> column has a lot of missing values, which are represented by the <strong class="source-inline">NaN</strong> value (which stands for <strong class="source-inline">Not a Number</strong>). The <strong class="source-inline">Street</strong> and <strong class="source-inline">Utilities</strong> columns seem to have only one value.</p></li>
				<li>Now, display <strong class="source-inline">5</strong> random sampled rows of the DataFrame using the <strong class="source-inline">sample()</strong> method from <strong class="source-inline">pandas</strong> and pass it a <strong class="source-inline">'random_state'</strong> of <strong class="source-inline">8</strong>:<p class="source-code">df.sample(n=5, random_state=8)</p><p>You should get the following output:</p><div id="_idContainer488" class="IMG---Figure"><img src="Images/B15019_10_13.jpg" alt="Figure 10.13: Five randomly sampled rows of the housing dataset&#13;&#10;" width="1053" height="282"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.13: Five randomly sampled rows of the housing dataset</p>
			<p>With these random samples, we can see that the <strong class="source-inline">LotFrontage</strong> column also has some missing values. We can also see that this dataset contains both numerical and text data (object types). We will analyze them more in detail in <em class="italic">Exercise 10.02</em>, <em class="italic">Analyzing the Categorical Variables from the Ames Housing Dataset</em>, and <em class="italic">Exercise 10.03</em>, <em class="italic">Analyzing Numerical Variables from the Ames Housing Dataset</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2E8HMdH">https://packt.live/2E8HMdH</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3g62zLT">https://packt.live/3g62zLT</a>.</p>
			<p>We learned quite a lot about this dataset in just a few lines of code, such as the number of rows and columns, the data type of each variable, and their information. We also identified some issues with missing values.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/>Analyzing the Content of a Categorical Variable</h1>
			<p>Now that we've got a good feel for the kind of information contained in the <strong class="source-inline">online retail dataset</strong>, we want to dig a little deeper into each of its columns: </p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">file_url = 'https://github.com/PacktWorkshops/'\</p>
			<p class="source-code">           'The-Data-Science-Workshop/blob'\</p>
			<p class="source-code">           '/master/Chapter10/dataset/'\</p>
			<p class="source-code">           'Online%20Retail.xlsx?raw=true'</p>
			<p class="source-code">df = pd.read_excel(file_url)</p>
			<p>For instance, we would like to know how many different values are contained in each of the variables by calling the <strong class="source-inline">nunique()</strong> method. This is particularly useful for a categorical variable with a limited number of values, such as <strong class="source-inline">Country</strong>:</p>
			<p class="source-code">df['Country'].nunique()</p>
			<p>You should get the following output:</p>
			<p class="source-code">38</p>
			<p>We can see that there are 38 different countries in this dataset. It would be great if we could get a list of all the values in this column. Thankfully, the <strong class="source-inline">pandas</strong> package provides a method to get these results: <strong class="source-inline">unique()</strong>:</p>
			<p class="source-code">df['Country'].unique()</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer489" class="IMG---Figure">
					<img src="Images/B15019_10_14.jpg" alt="Figure 10.14: List of unique values for the 'Country' column&#13;&#10;" width="936" height="205"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14: List of unique values for the 'Country' column</p>
			<p>We can see that there are multiple countries from different continents, but most of them come from Europe. We can also see that there is a value called <strong class="source-inline">Unspecified</strong> and another one for <strong class="source-inline">European Community</strong>, which may be for all the countries of the eurozone that are not listed separately.</p>
			<p>Another very useful method from <strong class="source-inline">pandas </strong>is <strong class="source-inline">value_counts()</strong>. This method lists all the values from a given column but also their occurrence. By providing the <strong class="source-inline">dropna=False</strong> and <strong class="source-inline">normalise=True</strong> parameters, this method will include the missing value in the listing and calculate the number of occurrences as a ratio, respectively:</p>
			<p class="source-code">df['Country'].value_counts(dropna=False, normalize=True)</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer490" class="IMG---Figure">
					<img src="Images/B15019_10_15.jpg" alt="Figure 10.15: A truncated list of unique values and their occurrence percentage &#13;&#10;for the 'Country' column&#13;&#10;" width="806" height="482"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15: A truncated list of unique values and their occurrence percentage for the 'Country' column</p>
			<p>From this output, we can see that the <strong class="source-inline">United Kingdom</strong> value is totally dominating this column as it represents over 91% of the rows and that other values such as <strong class="source-inline">Austria</strong> and <strong class="source-inline">Denmark</strong> are quite rare as they represent less than 1% of this dataset. </p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor247"/>Exercise 10.02: Analyzing the Categorical Variables from the Ames Housing Dataset</h2>
			<p>In this exercise, we will continue our dataset exploration by analyzing the categorical variables of this dataset. To do so, we will implement our own <strong class="source-inline">describe</strong> functions.</p>
			<p>The dataset we will be using in this exercise is the Ames Housing dataset, which can be found on our GitHub repository: <a href="https://packt.live/35kRKAo">https://packt.live/35kRKAo</a>. Let's get started:</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas </strong>package:<p class="source-code">import pandas as pd</p></li>
				<li>Assign the following link to the AMES dataset to a variable called <strong class="source-inline">file_url</strong>:<p class="source-code">file_url = 'https://raw.githubusercontent.com/'\</p><p class="source-code">           'PacktWorkshops/The-Data-Science-Workshop/'\</p><p class="source-code">           'master/Chapter10/dataset/ames_iowa_housing.csv'</p></li>
				<li>Use the <strong class="source-inline">.read_csv()</strong> method from the <strong class="source-inline">pandas</strong> package and load the dataset into a new variable called <strong class="source-inline">df</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Create a new DataFrame called <strong class="source-inline">obj_df</strong> with only the columns that are of numerical types using the <strong class="source-inline">select_dtypes</strong> method from <strong class="source-inline">pandas</strong> package. Then, pass in the <strong class="source-inline">object</strong> value to the <strong class="source-inline">include </strong>parameter:<p class="source-code">obj_df = df.select_dtypes(include='object')</p></li>
				<li>Using the <strong class="source-inline">columns</strong> attribute from <strong class="source-inline">pandas</strong>, extract the list of columns of this DataFrame, <strong class="source-inline">obj_df</strong>, assign it to a new variable called <strong class="source-inline">obj_cols</strong>, and print its content:<p class="source-code">obj_cols = obj_df.columns</p><p class="source-code">obj_cols</p><p>You should get the following output:</p><div id="_idContainer491" class="IMG---Figure"><img src="Images/B15019_10_16.jpg" alt="Figure 10.16: List of categorical variables&#13;&#10;" width="998" height="256"/></div><p class="figure-caption">Figure 10.16: List of categorical variables</p></li>
				<li>Create a function called <strong class="source-inline">describe_object</strong> that takes a <strong class="source-inline">pandas </strong>DataFrame and a column name as input parameters. Then, inside the function, print out the name of the given column, its number of unique values using the <strong class="source-inline">nunique()</strong> method, and the list of values and their occurrence using the <strong class="source-inline">value_counts()</strong> method, as shown in the following code snippet:<p class="source-code">def describe_object(df, col_name):</p><p class="source-code">    print(f"\nCOLUMN: {col_name}")</p><p class="source-code">    print(f"{df[col_name].nunique()} different values")</p><p class="source-code">    print(f"List of values:")</p><p class="source-code">    print(df[col_name].value_counts\</p><p class="source-code">                       (dropna=False, normalize=True))</p></li>
				<li>Test this function by providing the <strong class="source-inline">df</strong> DataFrame and the <strong class="source-inline">'MSZoning'</strong> column:<p class="source-code">describe_object(df, 'MSZoning')</p><p>You should get the following output:</p><div id="_idContainer492" class="IMG---Figure"><img src="Images/B15019_10_17.jpg" alt="Figure 10.17: Display of the created function for the MSZoning column&#13;&#10;" width="915" height="307"/></div><p class="figure-caption">Figure 10.17: Display of the created function for the MSZoning column</p><p>For the <strong class="source-inline">MSZoning</strong> column, the <strong class="source-inline">RL</strong> value represents almost <strong class="source-inline">79%</strong> of the values, while <strong class="source-inline">C</strong> <strong class="source-inline">(all)</strong> is only present in less than <strong class="source-inline">1%</strong> of the rows.</p></li>
				<li>Create a <strong class="source-inline">for </strong>loop that will call the created function for every element from the <strong class="source-inline">obj_cols</strong> list:<p class="source-code">for col_name in obj_cols:</p><p class="source-code">    describe_object(df, col_name)</p><p>You should get the following output:</p><div id="_idContainer493" class="IMG---Figure"><img src="Images/B15019_10_18.jpg" alt="Figure 10.18: Display of the created function for the first columns contained in obj_cols&#13;&#10;" width="703" height="526"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.18: Display of the created function for the first columns contained in obj_cols</p>
			<p>The output of the previous step is truncated in <em class="italic">Figure 10.18</em>. We can confirm that the <strong class="source-inline">Street</strong> column is almost constant as 99.6% of the rows contain the same value: <strong class="source-inline">Pave</strong>. For the column, that is, <strong class="source-inline">Alley</strong>, almost 94% of the rows have missing values.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3kWoRn2">https://packt.live/3kWoRn2</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3gbPnp0">https://packt.live/3gbPnp0</a>.</p>
			<p>We just analyzed all the categorical variables from this dataset. We saw how to look at the distribution of all the values contained in any feature. We also found that some of them are dominated by a single value and others have mainly missing values in them.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor248"/>Summarizing Numerical Variables</h1>
			<p>Now, let's have a look at a numerical column and get a good understanding of its content. We will use some statistical measures that summarize a variable. All of these measures are referred to as descriptive statistics. In this chapter, we will introduce you to the most popular ones.</p>
			<p>With the <strong class="source-inline">pandas</strong> package, a lot of these measures have been implemented as methods. For instance, if we want to know what the highest value contained in the <strong class="source-inline">'Quantity'</strong> column is, we can use the <strong class="source-inline">.max()</strong> method:</p>
			<p class="source-code">df['Quantity'].max()</p>
			<p>You should get the following output:</p>
			<p class="source-code">80995</p>
			<p>We can see that the maximum quantity of an item sold in this dataset is <strong class="source-inline">80995</strong>, which seems extremely high for a retail business. In a real project, this kind of unexpected value will have to be discussed and confirmed with the data owner or key stakeholders to see whether this is a genuine or an incorrect value. Now, let's have a look at the lowest value for <strong class="source-inline">'Quantity'</strong> using the <strong class="source-inline">.min()</strong> method:</p>
			<p class="source-code">df['Quantity'].min()</p>
			<p>You should get the following output:</p>
			<p class="source-code">-80995</p>
			<p>The lowest value in this variable is extremely low. We can think that having negative values is possible for returned items, but here, the minimum (<strong class="source-inline">-80995</strong>) is very low. This, again, will be something to be confirmed with the relevant people in your organization.</p>
			<p>Now, we are going to have a look at the central tendency of this column. <strong class="bold">Central tendency</strong> is a statistical term referring to the central point where the data will cluster around. The most famous central tendency measure is the average (or mean). The average is calculated by summing all the values of a column and dividing them by the number of values. </p>
			<p>If we plot the <strong class="source-inline">Quantity </strong>column on a graph with its average, it would look as follows:</p>
			<div>
				<div id="_idContainer494" class="IMG---Figure">
					<img src="Images/B15019_10_19.jpg" alt="Figure 10.19: Average value for the 'Quantity' column&#13;&#10;" width="904" height="684"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.19: Average value for the 'Quantity' column</p>
			<p>We can see the average for the <strong class="source-inline">Quantity </strong>column is very close to 0 and most of the data is between <strong class="source-inline">-50</strong> and <strong class="source-inline">+50</strong>.</p>
			<p>We can get the average value of a feature by using the <strong class="source-inline">mean()</strong> method from <strong class="source-inline">pandas</strong>: </p>
			<p class="source-code">df['Quantity'].mean()</p>
			<p>You should get the following output:</p>
			<p class="source-code">9.55224954743324</p>
			<p>In this dataset, the average quantity of items sold is around <strong class="source-inline">9.55</strong>. The average measure is very sensitive to outliers and, as we saw previously, the minimum and maximum values of the <strong class="source-inline">Quantity</strong> column are quite extreme (<strong class="source-inline">-80995 to +80995</strong>). </p>
			<p>We can use the median instead as another measure of central tendency. The median is calculated by splitting the column into two groups of equal lengths and getting the value of the middle point by separating these two groups, as shown in the following example:</p>
			<div>
				<div id="_idContainer495" class="IMG---Figure">
					<img src="Images/B15019_10_20.jpg" alt="Figure 10.20: Sample median example&#13;&#10;" width="660" height="218"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.20: Sample median example</p>
			<p>In <strong class="source-inline">pandas</strong>, you can call the <strong class="source-inline">median()</strong> method to get this value:</p>
			<p class="source-code">df['Quantity'].median()</p>
			<p>You should get the following output:</p>
			<p class="source-code">3.0</p>
			<p>The median value for this column is 3, which is quite different from the mean (<strong class="source-inline">9.55</strong>) we found earlier. This tells us that there are some outliers in this dataset and we will have to decide on how to handle them after we've done more investigation (this will be covered in <em class="italic">Chapter 11</em>, <em class="italic">Data Preparation</em>).</p>
			<p>We can also evaluate the spread of this column (how much the data points vary from the central point). A common measure of spread is the standard deviation. The smaller this measure is, the closer the data is to its mean. On the other hand, if the standard deviation is high, this means there are some observations that are far from the average. We will use the <strong class="source-inline">std()</strong> method from <strong class="source-inline">pandas </strong>to calculate this measure:</p>
			<p class="source-code">df['Quantity'].std()</p>
			<p>You should get the following output:</p>
			<p class="source-code">218.08115784986612</p>
			<p>As expected, the standard deviation for this column is quite high, so the data is quite spread from the average, which is <strong class="source-inline">9.55</strong> in this example.</p>
			<p>In the <strong class="source-inline">pandas </strong>package, there is a method that can display most of these descriptive statistics with one single line of code: <strong class="source-inline">describe()</strong>:</p>
			<p class="source-code">df.describe()</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer496" class="IMG---Figure">
					<img src="Images/B15019_10_21.jpg" alt="Figure 10.21: Output of the describe() method&#13;&#10;" width="768" height="396"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.21: Output of the describe() method</p>
			<p>We got the exact same values for the <strong class="source-inline">Quantity</strong> column as we saw previously. This method has calculated the descriptive statistics for the three numerical columns (<strong class="source-inline">Quantity</strong>, <strong class="source-inline">UnitPrice</strong>, and <strong class="source-inline">CustomerID</strong>). </p>
			<p>Even though the <strong class="source-inline">CustomerID</strong> column contains only numerical data, we know these values are used to identify each customer and have no mathematical meaning. For instance, it will not make sense to add customer ID <strong class="source-inline">12680 to 17850</strong> in the table or calculate the mean of these identifiers. This column is not actually numerical but categorical. </p>
			<p>The <strong class="source-inline">describe()</strong> method doesn't know this information and just noticed there are numbers, so it assumed this is a numerical variable. This is the perfect example of why you should understand your dataset perfectly and identify the issues to be fixed before feeding the data to an algorithm. In this case, we will have to change the type of this column to categorical. In <em class="italic">Chapter 11</em>, <em class="italic">Data Preparation</em>, we will see how we can handle this kind of issue, but for now, we will look at some graphical tools and techniques that will help us have an even better understanding of the data.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>Exercise 10.03: Analyzing Numerical Variables from the Ames Housing Dataset</h2>
			<p>In this exercise, we will continue our dataset exploration by analyzing the numerical variables of this dataset. To do so, we will implement our own <strong class="source-inline">describe </strong>functions.</p>
			<p>The dataset we will be using in this exercise is the Ames Housing dataset, which can be found on our GitHub repository: <a href="https://packt.live/35kRKAo">https://packt.live/35kRKAo</a>. Let's get started:</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> package:<p class="source-code">import pandas as pd</p></li>
				<li>Assign the link to the AMES dataset to a variable called <strong class="source-inline">file_url</strong>:<p class="source-code">file_url = 'https://raw.githubusercontent.com/'\</p><p class="source-code">           'PacktWorkshops/The-Data-Science-Workshop/'\</p><p class="source-code">           'master/Chapter10/dataset/ames_iowa_housing.csv'</p></li>
				<li>Use the <strong class="source-inline">.read_csv()</strong> method from the <strong class="source-inline">pandas </strong>package and load the dataset into a new variable called <strong class="source-inline">df</strong>:<p class="source-code">df = pd.read_csv(file_url)</p></li>
				<li>Create a new DataFrame called <strong class="source-inline">num_df</strong> with only the columns that are numerical using the <strong class="source-inline">select_dtypes</strong> method from the <strong class="source-inline">pandas </strong>package and pass in the <strong class="source-inline">'number'</strong> value to the <strong class="source-inline">include</strong> parameter:<p class="source-code">num_df = df.select_dtypes(include='number')</p></li>
				<li>Using the <strong class="source-inline">columns</strong> attribute from <strong class="source-inline">pandas</strong>, extract the list of columns of this DataFrame, <strong class="source-inline">num_df</strong>, assign it to a new variable called <strong class="source-inline">num_cols</strong>, and print its content:<p class="source-code">num_cols = num_df.columns</p><p class="source-code">num_cols</p><p>You should get the following output:</p><div id="_idContainer497" class="IMG---Figure"><img src="Images/B15019_10_22.jpg" alt="Figure 10.22: List of numerical columns&#13;&#10;" width="998" height="231"/></div><p class="figure-caption">Figure 10.22: List of numerical columns</p></li>
				<li>Create a function called <strong class="source-inline">describe_numeric</strong> that takes a <strong class="source-inline">pandas </strong>DataFrame and a column name as input parameters. Then, inside the function, print out the name of the given column, its minimum value using <strong class="source-inline">min()</strong>, its maximum value using <strong class="source-inline">max()</strong>, its average value using <strong class="source-inline">mean()</strong>, its standard deviation using <strong class="source-inline">std()</strong>, and its <strong class="source-inline">median</strong> using <strong class="source-inline">median()</strong>:<p class="source-code">def describe_numeric(df, col_name):</p><p class="source-code">    print(f"\nCOLUMN: {col_name}")</p><p class="source-code">    print(f"Minimum: {df[col_name].min()}")</p><p class="source-code">    print(f"Maximum: {df[col_name].max()}")</p><p class="source-code">    print(f"Average: {df[col_name].mean()}")</p><p class="source-code">    print(f"Standard Deviation: {df[col_name].std()}")</p><p class="source-code">    print(f"Median: {df[col_name].median()}")</p></li>
				<li>Now, test this function by providing the <strong class="source-inline">df</strong> DataFrame and the <strong class="source-inline">SalePrice</strong> column:<p class="source-code">describe_numeric(df, 'SalePrice')</p><p>You should get the following output:</p><div id="_idContainer498" class="IMG---Figure"><img src="Images/B15019_10_23.jpg" alt="Figure 10.23: The display of the created function for the 'SalePrice' column&#13;&#10;" width="989" height="210"/></div><p class="figure-caption">Figure 10.23: The display of the created function for the 'SalePrice' column</p><p>The sale price ranges from <strong class="source-inline">34,900</strong> to <strong class="source-inline">755,000 </strong>with an average of <strong class="source-inline">180,921</strong>. The median is slightly lower than the average, which tells us there are some outliers with high sales prices.</p></li>
				<li>Create a <strong class="source-inline">for </strong>loop that will call the created function for every element from the <strong class="source-inline">num_cols</strong> list:<p class="source-code">for col_name in num_cols:</p><p class="source-code">    describe_numeric(df, col_name)</p><p>You should get the following output:</p><div id="_idContainer499" class="IMG---Figure"><img src="Images/B15019_10_24.jpg" alt="Figure 10.24: Display of the created function for the first few columns &#13;&#10;contained in 'num_cols'&#13;&#10;" width="759" height="600"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.24: Display of the created function for the first few columns contained in 'num_cols'</p>
			<p><em class="italic">Figure 10.25</em> displays the truncated output. The <strong class="source-inline">Id</strong> column ranges from <strong class="source-inline">1</strong> to <strong class="source-inline">1460</strong>, which is the exact value as the number of rows in this dataset. This means this column is definitely a unique identifier of the property that was sold. It appears the values from the <strong class="source-inline">MSSubClass</strong> are all rounded. This may indicate that the information contained in this column has either been clustered into groups of 10 or categorical variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Q2TJEc">https://packt.live/2Q2TJEc</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2Yez18U">https://packt.live/2Yez18U</a>.</p>
			<p>We saw how to explore a newly received dataset with just a few lines of code. This helped us to understand its structure, the type of information contained in each variable, and also helped us identify some potential data quality issues, such as missing values or incorrect values.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor250"/>Visualizing Your Data</h1>
			<p>In the previous section, we saw how to explore a new dataset and calculate some simple descriptive statistics. These measures helped summarize the dataset into interpretable metrics, such as the average or maximum values. Now it is time to dive even deeper and get a more granular view of each column using data visualization. </p>
			<p>In a data science project, data visualization can be used either for data analysis or communicating gained insights. Presenting results in a visual way that stakeholders can easily understand and interpret them in is definitely a must-have skill for any good data scientist.</p>
			<p>However, in this chapter, we will be focusing on using data visualization for analyzing data. Most people tend to interpret information more easily on a graph than reading written information. For example, when looking at the following descriptive statistics and the scatter plot for the same variable, which one do you think is easier to interpret? Let's take a look: </p>
			<div>
				<div id="_idContainer500" class="IMG---Figure">
					<img src="Images/B15019_10_25.jpg" alt="Figure 10.25: Sample visual data analysis &#13;&#10;" width="1045" height="436"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.25: Sample visual data analysis </p>
			<p>Even though the information shown with the descriptive statistics are more detailed, by looking at the graph, you have already seen that the data is stretched and mainly concentrated around the value 0. It probably took you less than 1 or 2 seconds to come up with this conclusion, that is, there is a cluster of points near the 0 value and that it gets reduced while moving away from it. Coming to this conclusion would have taken you more time if you were interpreting the descriptive statistics. This is the reason why data visualization is a very powerful tool for effectively analyzing data.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor251"/>Using the Altair API</h2>
			<p>We will be using a package called <strong class="source-inline">altair</strong> (if you recall, we already briefly used it in <em class="italic">Chapter 5</em>, <em class="italic">Performing Your First Cluster Analysis</em>). There are quite a lot of Python packages for data visualization on the market, such as <strong class="source-inline">matplotlib</strong>, <strong class="source-inline">seaborn</strong>, or <strong class="source-inline">Bokeh</strong>, and compared to them, <strong class="source-inline">altair</strong> is relatively new, but its community of users is growing fast thanks to its simple API syntax. </p>
			<p>Let's see how we can display a bar chart step by step on the online retail dataset.</p>
			<p>First, import the <strong class="source-inline">pandas</strong> and <strong class="source-inline">altair</strong> packages:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import altair as alt</p>
			<p>Then, load the data into a <strong class="source-inline">pandas</strong> DataFrame:</p>
			<p class="source-code">file_url = 'https://github.com/PacktWorkshops/'\</p>
			<p class="source-code">           'The-Data-Science-Workshop/blob/'\</p>
			<p class="source-code">           'master/Chapter10/dataset/'\</p>
			<p class="source-code">           'Online%20Retail.xlsx?raw=true'</p>
			<p class="source-code">df = pd.read_excel(file_url)</p>
			<p>We will randomly sample 5,000 rows of this DataFrame using the <strong class="source-inline">sample()</strong> method (<strong class="source-inline">altair </strong>requires additional steps in order to display a larger dataset):</p>
			<p class="source-code">sample_df = df.sample(n=5000, random_state=8)</p>
			<p>Now instantiate a <strong class="source-inline">Chart</strong> object from <strong class="source-inline">altair</strong> with the <strong class="source-inline">pandas </strong>DataFrame as its input parameter:</p>
			<p class="source-code">base = alt.Chart(sample_df)</p>
			<p>Next, we call the <strong class="source-inline">mark_circle()</strong> method to specify the type of graph we want to plot: a scatter plot:</p>
			<p class="source-code">chart = base.mark_circle()</p>
			<p>Finally, we specify the names of the columns that will be displayed on the <em class="italic">x</em> and <em class="italic">y</em> axes using the <strong class="source-inline">encode()</strong> method:</p>
			<p class="source-code">chart.encode(x='Quantity', y='UnitPrice')</p>
			<p>We just plotted a scatter plot in seven lines of code:</p>
			<div>
				<div id="_idContainer501" class="IMG---Figure">
					<img src="Images/B15019_10_26.jpg" alt="Figure 10.26: Output of the scatter plot&#13;&#10;" width="896" height="692"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.26: Output of the scatter plot</p>
			<p>Altair provides the option for combining its methods all together into one single line of code, like this:</p>
			<p class="source-code">alt.Chart(sample_df).mark_circle()\</p>
			<p class="source-code">   .encode(x='Quantity', y='UnitPrice')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer502" class="IMG---Figure">
					<img src="Images/B15019_10_27.jpg" alt="Figure 10.27: Output of the scatter plot with combined altair methods&#13;&#10;" width="902" height="692"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.27: Output of the scatter plot with combined altair methods</p>
			<p>We can see that we got the exact same output as before. This graph shows us that there are a lot of outliers (extreme values) for both variables: most of the values of <strong class="source-inline">UnitPrice</strong> are below 100, but there are some over 300, and <strong class="source-inline">Quantity</strong> ranges from -200 to 800, while most of the observations are between -50 to 150. We can also notice a pattern where items with a high unit price have lower quantity (items over 50 in terms of unit price have a quantity close to 0) and the opposite is also true (items with a quantity over 100 have a unit price close to 0).</p>
			<p>Now, let's say we want to visualize the same plot while adding the <strong class="source-inline">Country</strong> column's information. One easy way to do this is to use the <strong class="source-inline">color</strong> parameter from the <strong class="source-inline">encode()</strong> method. This will color all the data points according to their value in the <strong class="source-inline">Country</strong> column:</p>
			<p class="source-code">alt.Chart(sample_df).mark_circle()\</p>
			<p class="source-code">   .encode(x='Quantity', y='UnitPrice', color='Country')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer503" class="IMG---Figure">
					<img src="Images/B15019_10_28.jpg" alt="Figure 10.28: Scatter plot with colors based on the 'Country' column&#13;&#10;" width="1665" height="1198"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.28: Scatter plot with colors based on the 'Country' column</p>
			<p>We added the information from the <strong class="source-inline">Country</strong> column into the graph, but as we can see, there are too many values and it is hard to differentiate between countries: there are a lot of blue points, but it is hard to tell which countries they are representing. </p>
			<p>With <strong class="source-inline">altair</strong>, we can easily add some interactions on the graph in order to display more information for each observation; we just need to use the <strong class="source-inline">tooltip</strong> parameter from the <strong class="source-inline">encode()</strong> method and specify the list of columns to be displayed and then call the <strong class="source-inline">interactive()</strong> method to make the whole thing interactive (as seen previously in <em class="italic">Chapter 5</em>, <em class="italic">Performing Your First Cluster Analysis</em>): </p>
			<p class="source-code">alt.Chart(sample_df).mark_circle()\</p>
			<p class="source-code">   .encode(x='Quantity', y='UnitPrice', color='Country', \</p>
			<p class="source-code">           tooltip=['InvoiceNo','StockCode','Description',\</p>
			<p class="source-code">                    'InvoiceDate','CustomerID']).interactive()</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer504" class="IMG---Figure">
					<img src="Images/B15019_10_29.jpg" alt="Figure 10.29: Interactive scatter plot with tooltip&#13;&#10;" width="1665" height="1210"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.29: Interactive scatter plot with tooltip</p>
			<p>Now, if we hover on the observation with the highest <strong class="source-inline">UnitPrice</strong> value (the one near 600), we can see the information displayed by the tooltip: this observation doesn't have any value for <strong class="source-inline">StockCode</strong> and its <strong class="source-inline">Description</strong> is <strong class="source-inline">Manual</strong>. So, it seems that this is not a normal transaction to happen on the website. It may be a special order that has been manually entered into the system. This is something you will have to discuss with your stakeholder and confirm.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor252"/>Histogram for Numerical Variables</h2>
			<p>Now that we are familiar with the <strong class="source-inline">altair</strong> API, let's have a look at some specific type of charts that will help us analyze and understand each variable. First, let's focus on numerical variables such as <strong class="source-inline">UnitPrice</strong> or <strong class="source-inline">Quantity</strong> in the online retail dataset. </p>
			<p>For this type of variable, a histogram is usually used to show the distribution of a given variable. The x axis of a histogram will show the possible values in this column and the y axis will plot the number of observations that fall under each value. Since the number of possible values can be very high for a numerical variable (potentially an infinite number of potential values), it is better to group these values by chunks (also called bins). For instance, we can group prices into bins of 10 steps (that is, groups of 10 items each) such as 0 to 10, 11 to 20, 21 to 30, and so on. </p>
			<p>Let's look at this by using a real example. We will plot a histogram for <strong class="source-inline">'UnitPrice'</strong> using the <strong class="source-inline">mark_bar()</strong> and <strong class="source-inline">encode()</strong> methods with the following parameters:</p>
			<ul>
				<li><strong class="source-inline">alt.X("UnitPrice:Q", bin=True)</strong>: This is another <strong class="source-inline">altair </strong>API syntax that allows you to tune some of the parameters for the x axis. Here, we are telling altair to use the <strong class="source-inline">'UnitPrice'</strong> column as the axis. <strong class="source-inline">':Q'</strong> specifies that this column is quantitative data (that is, numerical) and <strong class="source-inline">bin=True</strong> forces the grouping of the possible values into bins.</li>
				<li><strong class="source-inline">y='count()'</strong>: This is used for calculating the number of observations and plotting them on the y axis, like so:</li>
			</ul>
			<p class="source-code">alt.Chart(sample_df).mark_bar()\</p>
			<p class="source-code">   .encode(alt.X("UnitPrice:Q", bin=True), \</p>
			<p class="source-code">           y='count()')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer505" class="IMG---Figure">
					<img src="Images/B15019_10_30.jpg" alt="Figure 10.30: Histogram for UnitPrice with the default bin step size&#13;&#10;" width="910" height="694"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.30: Histogram for UnitPrice with the default bin step size</p>
			<p>By default, <strong class="source-inline">altair</strong> grouped the observations by bins of 100 steps: 0 to 100, then 100 to 200, and so on. The step size that was chosen is not optimal as almost all the observations fell under the first bin (0 to 100) and we can't see any other bin. With <strong class="source-inline">altair</strong>, we can specify the values of the parameter bin and we will try this with 5, that is, <strong class="source-inline">alt.Bin(step=5)</strong>:</p>
			<p class="source-code">alt.Chart(sample_df).mark_bar()\</p>
			<p class="source-code">   .encode(alt.X("UnitPrice:Q", bin=alt.Bin(step=5)), \</p>
			<p class="source-code">           y='count()')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer506" class="IMG---Figure">
					<img src="Images/B15019_10_31.jpg" alt="Figure 10.31: Histogram for UnitPrice with a bin step size of 5&#13;&#10;" width="914" height="696"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.31: Histogram for UnitPrice with a bin step size of 5</p>
			<p>This is much better. With this step size, we can see that most of the observations have a unit price under 5 (almost 4,200 observations). We can also see that a bit more than 500 data points have a unit price under 10. The count of records keeps decreasing as the unit price increases.</p>
			<p>Let's plot the histogram for the <strong class="source-inline">Quantity</strong> column with a bin step size of 10:</p>
			<p class="source-code">alt.Chart(sample_df).mark_bar()\</p>
			<p class="source-code">   .encode(alt.X("Quantity:Q", bin=alt.Bin(step=10)), \</p>
			<p class="source-code">           y='count()')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer507" class="IMG---Figure">
					<img src="Images/B15019_10_32.jpg" alt="Figure 10.32: Histogram for Quantity with a bin step size of 10&#13;&#10;" width="923" height="692"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.32: Histogram for Quantity with a bin step size of 10</p>
			<p>In this histogram, most of the records have a positive quantity between 0 and 30 (first three highest bins). There is also a bin with around 50 observations that have a negative quantity from -10 to 0. As we mentioned earlier, these may be returned items from customers.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>Bar Chart for Categorical Variables </h2>
			<p>Now, we are going to have a look at categorical variables. For such variables, there is no need to group the values into bins as, by definition, they have a limited number of potential values. We can still plot the distribution of such columns using a simple bar chart. In <strong class="source-inline">altair</strong>, this is very simple – it is similar to plotting a histogram but without the <strong class="source-inline">bin</strong> parameter. Let's try this on the <strong class="source-inline">Country</strong> column and look at the number of records for each of its values:</p>
			<p class="source-code">alt.Chart(sample_df).mark_bar()\</p>
			<p class="source-code">   .encode(x='Country',y='count()')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer508" class="IMG---Figure">
					<img src="Images/B15019_10_33.jpg" alt="Figure 10.33: Bar chart of the Country column's occurrence&#13;&#10;" width="1392" height="865"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.33: Bar chart of the Country column's occurrence</p>
			<p>We can confirm that <strong class="source-inline">United Kingdom</strong> is the most represented country in this dataset (and by far), followed by <strong class="source-inline">Germany</strong>, <strong class="source-inline">France</strong>, and <strong class="source-inline">EIRE</strong>. We clearly have imbalanced data that may affect the performance of a predictive model. In <em class="italic">Chapter 13</em>, <em class="italic">Imbalanced Datasets</em>, we will look at how we can handle this situation.</p>
			<p>Now, let's analyze the datetime column, that is, <strong class="source-inline">InvoiceDate</strong>. The <strong class="source-inline">altair</strong> package provides some functionality that we can use to group datetime information by period, such as day, day of week, month, and so on. For instance, if we want to have a monthly view of the distribution of a variable, we can use the <strong class="source-inline">yearmonth</strong> function to group datetimes. We also need to specify that the type of this variable is ordinal (there is an order between the values) by adding <strong class="source-inline">:O</strong> to the column name:</p>
			<p class="source-code">alt.Chart(sample_df).mark_bar()\</p>
			<p class="source-code">   .encode(alt.X('yearmonth(InvoiceDate):O'),\</p>
			<p class="source-code">           y='count()')</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer509" class="IMG---Figure">
					<img src="Images/B15019_10_34.jpg" alt="Figure 10.34: Distribution of InvoiceDate by month&#13;&#10;" width="810" height="760"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.34: Distribution of InvoiceDate by month</p>
			<p>This graph tells us that there was a huge spike of items sold in November 2011. It peaked to 800 items sold in this month, while the average is around 300. Was there a promotion or an advertising campaign run at that time that can explain this increase? These are the questions you may want to ask your stakeholders so that they can confirm this sudden increase of sales.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor254"/>Boxplots</h1>
			<p>Now, we will have a look at another specific type of chart called a <strong class="bold">boxplot</strong>. This kind of graph is used to display the distribution of a variable based on its quartiles. Quartiles are the values that split a dataset into quarters. Each quarter contains exactly 25% of the observations. For example, in the following sample data, the quartiles will be as follows:</p>
			<div>
				<div id="_idContainer510" class="IMG---Figure">
					<img src="Images/B15019_10_35.jpg" alt="Figure 10.35: Example of quartiles for the given data&#13;&#10;" width="740" height="241"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.35: Example of quartiles for the given data</p>
			<p>So, the first quartile (usually referred to as Q1) is 4; the second one (Q2), which is also the median, is 5; and the third quartile (Q3) is 8.</p>
			<p>A boxplot will show these quartiles but also additional information, such as the following:</p>
			<ul>
				<li>The <strong class="bold">interquartile range (or IQR)</strong>, which corresponds to Q3 - Q1</li>
				<li>The <em class="italic">lowest</em> value, which corresponds to Q1 - (1.5 * IQR)</li>
				<li>The <em class="italic">highest</em> value, which corresponds to Q3 + (1.5 * IQR)</li>
				<li>Outliers, that is, any point outside of the lowest and highest points:<div id="_idContainer511" class="IMG---Figure"><img src="Images/B15019_10_36.jpg" alt="Figure 10.36: Example of a boxplot&#13;&#10;" width="1112" height="856"/></div></li>
			</ul>
			<p class="figure-caption">Figure 10.36: Example of a boxplot</p>
			<p>With a boxplot, it is quite easy to see the central point (median), where 50% of the data falls under (IQR), and the outliers. </p>
			<p>Another benefit of using a boxplot is to plot the distribution of categorical variables against a numerical variable and compare them. Let's try it with the <strong class="source-inline">Country</strong> and <strong class="source-inline">Quantity</strong> columns using the <strong class="source-inline">mark_boxplot()</strong> method:</p>
			<p class="source-code">alt.Chart(sample_df).mark_boxplot()\</p>
			<p class="source-code">   .encode(x='Country:O', y='Quantity:Q')</p>
			<p>You should receive the following output:</p>
			<div>
				<div id="_idContainer512" class="IMG---Figure">
					<img src="Images/B15019_10_37.jpg" alt="Figure 10.37: Boxplot of the 'Country' and 'Quantity' columns&#13;&#10;" width="1380" height="867"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.37: Boxplot of the 'Country' and 'Quantity' columns</p>
			<p>This chart shows us how the <strong class="source-inline">Quantity</strong> variable is distributed across the different countries for this dataset. We can see that <strong class="source-inline">United Kingdom</strong> has a lot of outliers, especially in the negative values. <strong class="source-inline">Eire</strong> is another country that has negative outliers. Most of the countries have very low value quantities except for <strong class="source-inline">Japan</strong>, <strong class="source-inline">Netherlands</strong>, and <strong class="source-inline">Sweden</strong>, who sold more items.</p>
			<p>In this section, we saw how to use the <strong class="source-inline">altair</strong> package to generate graphs that helped us get additional insights about the dataset and identify some potential issues.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor255"/>Exercise 10.04: Visualizing the Ames Housing Dataset with Altair</h2>
			<p>In this exercise, we will learn how to get a better understanding of a dataset and the relationship between variables using data visualization features such as histograms, scatter plots, or boxplots.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You will be using the same Ames housing dataset that was used in the previous exercises.</p>
			<ol>
				<li value="1">Open a new Colab notebook.</li>
				<li>Import the <strong class="source-inline">pandas</strong> and <strong class="source-inline">altair</strong> packages:<p class="source-code">import pandas as pd</p><p class="source-code">import altair as alt</p></li>
				<li>Assign the link to the AMES dataset to a variable called <strong class="source-inline">file_url</strong>:<p class="source-code">file_url = 'https://raw.githubusercontent.com/'\</p><p class="source-code">           'PacktWorkshops/The-Data-Science-Workshop/'\</p><p class="source-code">           'master/Chapter10/dataset/ames_iowa_housing.csv'</p></li>
				<li>Using the <strong class="source-inline">read_csv</strong> method from the pandas package, load the dataset into a new variable called <strong class="source-inline">'df'</strong>:<p class="source-code">df = pd.read_csv(file_url)</p><p>Plot the histogram for the <strong class="source-inline">SalePrice</strong> variable using the <strong class="source-inline">mark_bar()</strong> and <strong class="source-inline">encode()</strong> methods from the <strong class="source-inline">altair</strong> package. Use the <strong class="source-inline">alt.X</strong> and <strong class="source-inline">alt.Bin</strong> APIs to specify the number of bin steps, that is, <strong class="source-inline">50000</strong>:</p><p class="source-code">alt.Chart(df).mark_bar()\</p><p class="source-code">   .encode(alt.X("SalePrice:Q", bin=alt.Bin(step=50000)),\</p><p class="source-code">           y='count()')</p><p>You should get the following output:</p><div id="_idContainer513" class="IMG---Figure"><img src="Images/B15019_10_38.jpg" alt="Figure 10.38: Histogram of SalePrice&#13;&#10;" width="895" height="692"/></div><p class="figure-caption">Figure 10.38: Histogram of SalePrice</p><p>This chart shows that most of the properties have a sale price centered around <strong class="source-inline">100,000 – 150,000</strong>. There are also a few outliers with a high sale price over <strong class="source-inline">500,000</strong>. </p></li>
				<li>Now, let's plot the histogram for <strong class="source-inline">LotArea</strong> but this time with a bin step size of <strong class="source-inline">10000</strong>:<p class="source-code">alt.Chart(df).mark_bar()\</p><p class="source-code">   .encode(alt.X("LotArea:Q", bin=alt.Bin(step=10000)),\</p><p class="source-code">           y='count()')</p><p>You should get the following output:</p><div id="_idContainer514" class="IMG---Figure"><img src="Images/B15019_10_39.jpg" alt="Figure 10.39: Histogram of LotArea&#13;&#10;" width="897" height="694"/></div><p class="figure-caption">Figure 10.39: Histogram of LotArea</p><p><strong class="source-inline">LotArea</strong> has a totally different distribution compared to <strong class="source-inline">SalePrice</strong>. Most of the observations are between <strong class="source-inline">0</strong> and <strong class="source-inline">20,000</strong>. The rest of the observations represent a small portion of the dataset. We can also notice some extreme outliers over <strong class="source-inline">150,000</strong>.</p></li>
				<li>Now, plot a scatter plot with <strong class="source-inline">LotArea</strong> as the <em class="italic">x</em> axis and <strong class="source-inline">SalePrice</strong> as the <em class="italic">y</em> axis to understand the interactions between these two variables:<p class="source-code">alt.Chart(df).mark_circle()\</p><p class="source-code">   .encode(x='LotArea:Q', y='SalePrice:Q')</p><p>You should get the following output:</p><div id="_idContainer515" class="IMG---Figure"><img src="Images/B15019_10_40.jpg" alt="Figure 10.40: Scatter plot of SalePrice and LotArea&#13;&#10;" width="1665" height="1225"/></div><p class="figure-caption">Figure 10.40: Scatter plot of SalePrice and LotArea</p><p>There is clearly a correlation between the size of the property and the sale price. If we look only at the properties with <strong class="source-inline">LotArea</strong> under 50,000, we can see a linear relationship: if we draw a straight line from the (<strong class="source-inline">0,0</strong>) coordinates to the (<strong class="source-inline">20000,800000</strong>) coordinates, we can say that <strong class="source-inline">SalePrice</strong> increases by 40,000 for each additional increase of 1,000 for <strong class="source-inline">LotArea</strong>. The formula of this straight line (or regression line) will be <strong class="source-inline">SalePrice = 40000 * LotArea / 1000</strong>. We can also see that, for some properties, although their size is quite high, their price didn't follow this pattern. For instance, the property with a size of 160,000 has been sold for less than 300,000.</p></li>
				<li>Now, let's plot the histogram for <strong class="source-inline">OverallCond</strong>, but this time with the default bin step size, that is, (<strong class="source-inline">bin=True</strong>):<p class="source-code">alt.Chart(df).mark_bar()\</p><p class="source-code">   .encode(alt.X("OverallCond", bin=True), \</p><p class="source-code">           y='count()')</p><p>You should get the following output:</p><div id="_idContainer516" class="IMG---Figure"><img src="Images/B15019_10_41.jpg" alt="Figure 10.41: Histogram of OverallCond&#13;&#10;" width="887" height="690"/></div><p class="figure-caption">Figure 10.41: Histogram of OverallCond</p><p>We can see that the values contained in this column are discrete: they can only take a finite number of values (any integer between <strong class="source-inline">1</strong> and <strong class="source-inline">9</strong>). This variable is not numerical, but ordinal: the order matters, but you can't perform some mathematical operations on it such as adding value <strong class="source-inline">2</strong> to value <strong class="source-inline">8</strong>. This column is an arbitrary mapping to assess the overall quality of the property. In the next chapter, we will look at how we can change the type of such a column.</p></li>
				<li>Build a boxplot with <strong class="source-inline">OverallCond:O</strong> (<strong class="source-inline">':O'</strong> is for specifying that this column is ordinal) on the <em class="italic">x</em> axis and <strong class="source-inline">SalePrice</strong> on the <em class="italic">y</em> axis using the <strong class="source-inline">mark_boxplot()</strong> method, as shown in the following code snippet:<p class="source-code">alt.Chart(df).mark_boxplot()\</p><p class="source-code">   .encode(x='OverallCond:O', y='SalePrice:Q')</p><p>You should get the following output:</p><div id="_idContainer517" class="IMG---Figure"><img src="Images/B15019_10_42.jpg" alt="Figure 10.42: Boxplot of OverallCond&#13;&#10;" width="763" height="671"/></div><p class="figure-caption">Figure 10.42: Boxplot of OverallCond</p><p>It seems that the <strong class="source-inline">OverallCond</strong> variable is in ascending order: the sales price is higher if the condition value is high. However, we will notice that <strong class="source-inline">SalePrice</strong> is quite high for the value 5, which seems to represent a medium condition. There may be other factors impacting the sales price for this category, such as higher competition between buyers for such types of properties.</p></li>
				<li>Now, let's plot a bar chart for <strong class="source-inline">YrSold</strong> as its <em class="italic">x</em> axis and <strong class="source-inline">count()</strong> as its <em class="italic">y</em> axis. Don't forget to specify that <strong class="source-inline">YrSold</strong> is an ordinal variable and not numerical using <strong class="source-inline">':O'</strong>:<p class="source-code">alt.Chart(df).mark_bar()\</p><p class="source-code">   .encode(alt.X('YrSold:O'), y='count()')</p><p>You should get the following output:</p><div id="_idContainer518" class="IMG---Figure"><img src="Images/B15019_10_43.jpg" alt="Figure 10.43: Bar chart of YrSold&#13;&#10;" width="775" height="704"/></div><p class="figure-caption">Figure 10.43: Bar chart of YrSold</p><p>We can see that, roughly, the same number of properties are sold every year, except for 2010. From 2006 to 2009, there was, on average, 310 properties sold per year, while there were only 170 in 2010. </p></li>
				<li>Plot a boxplot similar to the one shown in <em class="italic">Step 8</em> but for <strong class="source-inline">YrSold</strong> as its <em class="italic">x</em> axis:<p class="source-code">alt.Chart(df).mark_boxplot()\</p><p class="source-code">   .encode(x='YrSold:O', y='SalePrice:Q')</p><p>You should get the following output:</p><div id="_idContainer519" class="IMG---Figure"><img src="Images/B15019_10_44.jpg" alt="Figure 10.44: Boxplot of YrSold and SalePrice&#13;&#10;" width="876" height="710"/></div><p class="figure-caption">Figure 10.44: Boxplot of YrSold and SalePrice</p><p>Overall, the median sale price is quite stable across the years, with a slight decrease in 2010.</p></li>
				<li>Let's analyze the relationship between <strong class="source-inline">SalePrice</strong> and <strong class="source-inline">Neighborhood</strong> by plotting a bar chart, similar to the one shown in <em class="italic">Step 9</em>:<p class="source-code">alt.Chart(df).mark_bar()\</p><p class="source-code">   .encode(x='Neighborhood',y='count()')</p><p>You should get the following output:</p><div id="_idContainer520" class="IMG---Figure"><img src="Images/B15019_10_45.jpg" alt="Figure 10.45: Bar chart of Neighborhood&#13;&#10;" width="1665" height="1154"/></div><p class="figure-caption">Figure 10.45: Bar chart of Neighborhood</p><p>The number of sold properties differs, depending on their location. The <strong class="source-inline">'NAmes'</strong> neighborhood has the higher number of properties sold: over 220. On the other hand, neighborhoods such as <strong class="source-inline">'Blueste'</strong> or <strong class="source-inline">'NPkVill'</strong> only had a few properties sold.</p></li>
				<li>Let's analyze the relationship between <strong class="source-inline">SalePrice</strong> and <strong class="source-inline">Neighborhood</strong> by plotting a boxplot chart similar to the one in <em class="italic">Step 10</em>:<p class="source-code">alt.Chart(df).mark_boxplot()\</p><p class="source-code">   .encode(x='Neighborhood:O', y='SalePrice:Q')</p><p>You should get the following output:</p><div id="_idContainer521" class="IMG---Figure"><img src="Images/B15019_10_46.jpg" alt="Figure 10.46: Boxplot of Neighborhood and SalePrice&#13;&#10;" width="1665" height="1114"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.46: Boxplot of Neighborhood and SalePrice</p>
			<p>The location of the properties that were sold has a significant impact on the sale price. The <strong class="source-inline">noRidge</strong>, <strong class="source-inline">NridgHt</strong>, and <strong class="source-inline">StoneBr</strong> neighborhoods have a higher price overall. It is also worth noting that there are some extreme outliers for <strong class="source-inline">NoRidge</strong> where some properties have been sold with a price that's much higher than other properties in this neighborhood.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2CDWfO4">https://packt.live/2CDWfO4</a>.</p>
			<p class="callout">This section does not currently have an online interactive example, but can be run as usual on Google Colab.</p>
			<p>With this analysis, we've completed this exercise. We saw that, by using data visualization, we can get some valuable insights about the dataset. For instance, using a scatter plot, we identified a linear relationship between <strong class="source-inline">SalePrice</strong> and <strong class="source-inline">LotArea</strong>, where the price tends to increase as the size of the property gets bigger. Histograms helped us to understand the distribution of the numerical variables and bar charts gave us a similar view for categorical variables. For example, we saw that there are more sold properties in some neighborhoods compared to others. Finally, we were able to analyze and compare the impact of different values of a variable on <strong class="source-inline">SalePrice</strong> through the use of a boxplot. We saw that the better condition a property is in, the higher the sale price will be. Data visualization is a very important tool for data scientists so that they can explore and analyze datasets.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor256"/>Activity 10.01: Analyzing Churn Data Using Visual Data Analysis Techniques</h2>
			<p>You are working for a major telecommunications company. The marketing department has noticed a recent spike of customer churn (<em class="italic">customers that stopped using or canceled their service from the company</em>). </p>
			<p>You have been asked to analyze the customer profiles and predict future customer churn. Before building the predictive model, your first task is to analyze the data the marketing department has shared with you and assess its overall quality.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The dataset to be used in this activity can be found on our GitHub repository: <a href="https://packt.live/2s1yquq">https://packt.live/2s1yquq</a>.</p>
			<p class="callout">The dataset we are going to be using was has originally shared by Eduardo Arino De La Rubia on Data.World: <a href="https://packt.live/2s1ynie">https://packt.live/2s1ynie</a>.</p>
			<p>The following steps will help you complete this activity:</p>
			<ol>
				<li value="1">Download and load the dataset into Python using <strong class="source-inline">.read_csv()</strong>.</li>
				<li>Explore the structure and content of the dataset by using <strong class="source-inline">.shape</strong>, <strong class="source-inline">.dtypes</strong>, <strong class="source-inline">.head()</strong>, <strong class="source-inline">.tail()</strong>, or <strong class="source-inline">.sample()</strong>.</li>
				<li>Calculate and interpret descriptive statistics with <strong class="source-inline">.describe()</strong>.</li>
				<li>Analyze each variable using data visualization with bar charts, histograms, or boxplots.</li>
				<li>Identify areas that need clarification from the marketing department and potential data quality issues.</li>
			</ol>
			<p><strong class="bold">Expected Output</strong></p>
			<p>Here is the expected bar chart output:</p>
			<div>
				<div id="_idContainer522" class="IMG---Figure">
					<img src="Images/B15019_10_47.jpg" alt="Figure 10.47: Expected bar chart output&#13;&#10;" width="1045" height="853"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.47: Expected bar chart output</p>
			<p>Here is the expected histogram output:</p>
			<div>
				<div id="_idContainer523" class="IMG---Figure">
					<img src="Images/B15019_10_48.jpg" alt="Figure 10.48: Expected histogram output&#13;&#10;" width="1665" height="622"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.48: Expected histogram output</p>
			<p>Here is the expected boxplot output:</p>
			<div>
				<div id="_idContainer524" class="IMG---Figure">
					<img src="Images/B15019_10_49.jpg" alt="Figure 10.49: Expected boxplot output&#13;&#10;" width="893" height="692"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.49: Expected boxplot output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found here: <a href="https://packt.live/2GbJloz">https://packt.live/2GbJloz</a>.</p>
			<p>You just completed the activity for this chapter. You have analyzed the dataset related to customer churn. You learned a lot about this dataset using descriptive statistics and data visualization. In a few lines of codes, you understood the structure of the DataFrame (number of rows and columns) and the type of information contained in each variable. By plotting the distribution of some columns, we learned there are specific charges for day, evening, or international calls. We also saw that the churn variable is imbalanced: there are roughly only 10% of customers who churn. Finally, we saw that one of the variables, <strong class="source-inline">numbervmailmessages</strong>, has a very different distribution for customers who churned or not. This may be a strong predictor for customer churn.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor257"/>Summary</h1>
			<p>You just learned a lot regarding how to analyze a dataset. This a very critical step in any data science project. Getting a deep understanding of the dataset will help you to better assess the feasibility of achieving the requirements from the business.</p>
			<p>Getting the right data in the right format at the right level of quality is key for getting good predictive performance for any machine learning algorithm. This is why it is so important to take the time analyzing the data before proceeding to the next stage. This task is referred to as the data understanding phase in the CRISP-DM methodology and can also be called <strong class="bold">Exploratory Data Analysis</strong> (<strong class="bold">EDA</strong>).</p>
			<p>You learned how to use descriptive statistics to summarize key attributes of the dataset such as the average value of a numerical column, its spread with standard deviation or its range (minimum and maximum values), the unique values of a categorical variable, and its most frequent values. You also saw how to use data visualization to get valuable insights for each variable. Now, you know how to use scatter plots, bar charts, histograms, and boxplots to understand the distribution of a column.</p>
			<p>While analyzing the data, we came across additional questions that, in a normal project, need to be addressed with the business. We also spotted some potential data quality issues, such as missing values, outliers, or incorrect values that need to be fixed. This is the topic we will cover in the next chapter: preparing the data. Stay tuned.</p>
		</div>
	</div></body></html>