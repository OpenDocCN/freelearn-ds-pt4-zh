- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Augmentation Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data augmentation is essential for developing a successful **deep learning**
    (**DL**) project. However, data scientists and developers often overlook this
    crucial step. It is no secret that you will spend the majority of your project
    time gathering, cleaning, and augmenting the dataset in a real-world DL project.
    Thus, learning how to expand the dataset without purchasing new data is essential.
    This book covers standard and advanced techniques for extending image, text, audio,
    and tabular datasets. Furthermore, you will learn about data biases and learn
    how to code on **Jupyter** **Python Notebooks**.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B17990_01.xhtml#_idTextAnchor016)will introduce various data
    augmentation concepts, set up the coding environment, and create the foundation
    class. Later chapters will explain various techniques in detail, including Python
    coding. The effective use of data augmentation has proven to be the deciding factor
    between success and failure in **machine learning** (**ML**). Many real-world
    ML projects stay in the conceptual phase because of insufficient data for training
    the ML model. Data augmentation is a cost-effective technique that can increase
    the size of the dataset, lower the training error rate, and produce a more accurate
    prediction and forecast.'
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: The car gasoline analogy is helpful for students who first learn about data
    augmentation and **artificial intelligence** (**AI**). You can think of data for
    the AI engine as the gasoline and data augmentation as the additive, such as the
    Chevron Techron fuel cleaner, that makes your car engine run faster, smoother,
    and further without extra petrol.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll define the data augmentation role and the limitations
    of extending data without changing its integrity. We’ll briefly discuss the different
    types of input data, such as image, text, audio, and tabular data, and the challenges
    in supplementing it. Finally, we’ll set up the system requirements and the programming
    style in the accompanying Python notebook.
  prefs: []
  type: TYPE_NORMAL
- en: I designed this book to be a hands-on journey. It will be most effective to
    read a chapter, run the code, re-read the part of the chapter that confused you,
    and jump back to hacking the code until you firmly understand the concept or technique
    that was presented.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to change or add new code to the Python notebook. The primary
    purpose of this book is interactive learning. So, if something goes wrong, download
    a fresh copy from the book's GitHub. The surest method to learn is to make mistakes
    and create something new.
  prefs: []
  type: TYPE_NORMAL
- en: Data augmentation is an iterative process. There is no fixed recipe. In other
    words, depending on the dataset, you select augmented functions and jiggle the
    parameters. A subject domain expert may provide insight into how much distortion
    is acceptable. By the end of this chapter, you will know the general rules for
    data augmentation, what type of input data can be augmented, the programming style,
    and how to set up a Python Notebook online or offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, this chapter covers the following primary topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data augmentation role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data input types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the data augmentation role.
  prefs: []
  type: TYPE_NORMAL
- en: Data augmentation role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is paramount in any AI project. This is especially true when using the
    **artificial neural network** (**ANN**) algorithm, also known as **DL**. The success
    or failure of a DL project is primarily due to the input data quality.
  prefs: []
  type: TYPE_NORMAL
- en: One primary reason for the significance of data augmentation is that it is relatively
    too easy to develop an AI for prediction and forecasting, and those models require
    robust data input. With the remarkable advancement in developing, training, and
    deploying a DL project, such as using the **FastAI** framework, you can create
    a world-class DL model in a handful of Python code lines. Thus, expanding the
    dataset is an effective option to improve the DL model’s accuracy over your competitor.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional method of acquiring additional data is difficult, expensive,
    and impractical. Sometimes, the only available option is to use data augmentation
    techniques to extend the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: Data augmentation methods can increase the data’s size tenfold. For example,
    it is relatively challenging to acquire additional skin cancer images. Thus, using
    a random combination of image transformations, such as vertical flip, horizontal
    flip, rotating, and skewing, is a practical technique that can expand the skin
    cancer photo data.
  prefs: []
  type: TYPE_NORMAL
- en: Without data augmentation, sourcing new skin cancer photos and labeling them
    is expensive and time-consuming. The **International Skin Imaging Collaboration**
    (**ISIC**) is the authoritative data source for skin diseases, where a team of
    dermatologists verified and classified the images. ISIC made the datasets available
    to the public to download for free. If you can’t find a particular dataset from
    ISIC, it is difficult to find other means, as accessing hospital or university
    labs to acquire skin disease images is laced with legal and logistic blockers.
    After obtaining the photos, hiring a team of dermatologists to classify the pictures
    to correct diseases would be costly.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of the impracticality of attaining additional images instead
    of augmentation is when you download photos from social media or online search
    engines. Social media is a rich source of image, text, audio, and video data.
    Search engines, such as **Google** or **Bing**, make it relatively easy to download
    additional data for a project, but copyrights and legal usage are a quagmire.
    Most images, texts, audio, and videos on social media, such as **YouTube**, **Facebook**,
    **TikTok**, and **Twitter**, are not clearly labeled as copyrights or public domain
    material.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, social media promotes popular content, not unfavorable or obscure
    material. For example, let’s say you want to add more images of parrots to your
    parrot classification AI system. Online searches will return a lot of blue-and-yellow
    macaws, red-and-green macaws, or sulfur-crested cockatoos, but not as many Galah,
    Kea, or the mythical Norwegian-blue parrot – a fake parrot from the Monty Python
    comedy skit.
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient data for AI training is exacerbated for text, audio, and tabular
    data types. Generally, obtaining additional text, audio, and tabular data is expensive
    and time-consuming. There are strong copyright laws protecting text data. Audio
    files are less common online, and tabular data is primarily from private company
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will define the four commonly used data types.
  prefs: []
  type: TYPE_NORMAL
- en: Data input types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The four data input types are self-explanatory, but it is worth clearly defining
    the data input types and what is out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: Image definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabular data definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Image, text, tabular, and audio augmentation](img/B17990_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Image, text, tabular, and audio augmentation
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.1* provides a sneak peek at image, text, tabular and audio augmentation.
    Later in this book, you will learn how to implement augmentation methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with images.
  prefs: []
  type: TYPE_NORMAL
- en: Image definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Image is a large category because you can represent almost anything as an image,
    such as people, landscapes, animals, plants, and various objects around us. Pictures
    can also represent action, such as sports, sign language, yoga poses, and many
    more. One particularly creative use of images is capturing a computer mouse’s
    movement over time to predict whether a user is a computer hacker or not.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques for increasing the number of pictures are horizontal flip, vertical
    flip, enlarge, zoom in, zoom out, skew, warp, and lighting. Humans are experts
    at processing images. Thus, if a picture is slightly distorted or darkened, you
    can still tell that it is the same image. However, this is not the same for a
    computer. AI represents a color picture as a three-dimensional array of float
    numbers – the width, height, and RGB as depth. Any image distortion will yield
    an array with different values.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs, such as time series data charts, and mathematical equation plots, such
    as 3D topology plots, are outside the scope of image augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: You can eliminate the **overfitting** problem in DL image classification training
    by creatively using data augmentation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Text augmentation has different concerns than image augmentation. Let’s take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Text definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary text input data is in English, but the same techniques for text
    augmentation can be applied to other West Germanic languages. Python lessons use
    English as the text input data.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques for supplementing the text input are back translation, easy data
    augmentation, and albumentation. A few methods might be counterintuitive at first
    glance, such as deleting or swamping words in a sentence. However, it is an acceptable
    practice because, in the real world, not everyone writes perfect English.
  prefs: []
  type: TYPE_NORMAL
- en: For example, movie reviewers on the **American Multi-Cinema** (**AMC**) website
    write incomplete or grammatically incorrect sentences. They omit verbs or use
    inappropriate words. As a rule of thumb, you should not expect perfect English
    for text input data in many NLP projects.
  prefs: []
  type: TYPE_NORMAL
- en: If an NLP model is trained in perfect English as text input data, it could cause
    bias against typical online reviewers. In other words, the NLP model will predict
    inaccurately when deployed to a real-world audience. For example, in sentiment
    analysis, the AI system will predict whether a movie review has a positive or
    negative sentiment. Suppose you trained the system using a perfect English dataset.
    In that case, the AI system might forecast a **false positive** or **false negative**
    when people write a short line with misspelled words and grammatical errors.
  prefs: []
  type: TYPE_NORMAL
- en: Language translation, ideograms, and hieroglyphs are outside the scope of this
    book. Now, let’s look at audio augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Audio definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Audio input data can be any sound wave recording such as music, speech, and
    natural sounds. Sound wave attributes such as amplitude and frequency are represented
    as graphs, which are technically images, but you can’t use any image augmentation
    methods for audio input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques for expanding audio input are split into two types: **waveform**
    and **spectrograph**. For raw audio, the transformation methods range from time-shifting
    and pitch scaling to random gain, while for spectrographs, the functions are time
    masking, time stretching, pitch scaling, and many others.'
  prefs: []
  type: TYPE_NORMAL
- en: Speech in a language other than English is outside the scope of this book. This
    is not due to technical difficulties but rather because this book is written in
    English. Writing about the aftermath effects of switching to a different language
    would be problematic.Audio augmentation is demanding, but tabular data is even
    more challenging to expand.
  prefs: []
  type: TYPE_NORMAL
- en: Tabular data definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tabular data is information in a relational database, spreadsheet, or text file
    in **comma-separated values** (**CSV**) format. Tabular data augmentation is a
    fast-growing field in ML and DL. The tabular data augmentation techniques are
    transforming, interacting, mapping, and extraction.
  prefs: []
  type: TYPE_NORMAL
- en: Fun challenge
  prefs: []
  type: TYPE_NORMAL
- en: Here is a thought experiment. Can you think of data types other than image,
    text, audio, and tabular? A hint is *Casablanca* and *Blade Runner*.
  prefs: []
  type: TYPE_NORMAL
- en: There are two parts to this chapter. The first half discussed the various concepts
    and techniques; what follows is hands-on Python coding on a Python Notebook. The
    book will use this learn-then-code pattern in all the chapters. It is time to
    get your hands dirty and write Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Python Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jupyter Notebook** is an open source web application that is the de facto
    choice for AI, ML, and data scientists. Jupyter Notebook supports multiple computer
    languages, and the most popular is Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, the term **Python Notebook** will be used synonymously
    for **Jupyter Notebook**, **JupyterLab**, and **Google Colab** **Jupyter Notebook**.
  prefs: []
  type: TYPE_NORMAL
- en: For Python developers, there are many choices of **integrated development environment**
    (**IDE**) platforms, such as **Integrated Development and Learning Environment**
    (**IDLE**), PyCharm, Microsoft Visual Studio, Atom, Sublime, and many more. Still,
    a Python Notebook is the preferred choice for AI, ML, and data scientists. It
    is an interactive IDE fit for exploring, coding, and deploying AI projects.
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: The easiest learning method is reading this book, running the code, and hacking
    it. This book cannot cover all scenarios; therefore, you must be comfortable with
    hacking the code so that it matches your real-world dataset. The Python Notebook
    is designed for interactivity. It gives us the freedom to play, explore, and make
    mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Notebook is the development tool of choice, and in particular, we will
    review the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Colab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Notebook options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Python Notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin with Google Colab.
  prefs: []
  type: TYPE_NORMAL
- en: Google Colab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google Colab Jupyter Notebook** with Python is one of the popular options
    for developing AI and ML projects. All you need is a Gmail account.'
  prefs: []
  type: TYPE_NORMAL
- en: Colab can be found at [https://colab.research.google.com/](https://colab.research.google.com/).
    The free Colab version is sufficient for the code in this book; the Pro+ version
    enables more CPU and GPU RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in to Colab, you can retrieve this book’s Python Notebooks from
    the following GitHub URL: https://github.com/PacktPublishing/data-augmentation-with-python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start using Colab by using one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *first method* of opening a Python Notebook is copying it from GitHub.
    From Colab, go to the `.``ipynb`) file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Loading a Python Notebook from GitHub](img/B17990_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Loading a Python Notebook from GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'The *second method* of opening a Python Notebook is auto-loading it from GitHub.
    Go to the GitHub link mentioned previously and click on the Python Notebook (`ipynb`)
    file. Click the blue-colored **Open in Colab** button, as shown in *Figure 1**.3*;
    it should be on the first line of the Python Notebook. It will launch Colab and
    load in the Python Notebook automatically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Loading a Python Notebook from Colab](img/B17990_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Loading a Python Notebook from Colab
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you save a copy of the Python Notebook to your local Google Drive by
    clicking on the **File** menu and selecting the **Save a copy in Drive** option.
    Afterward, close the original and use the copy version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *third method* of opening a Python Notebook is by downloading a copy from
    GitHub. Upload the Python Notebook to Colab by clicking on the **File** menu,
    choosing **Open Notebook**, then clicking on the **Upload** tab, as shown in *Figure
    1**.4*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Loading a Python Notebook by uploading it to Colab](img/B17990_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Loading a Python Notebook by uploading it to Colab
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: For a quick overview of Colab’s features, go to [https://colab.research.google.com/notebooks/basic_features_overview.ipynb](https://colab.research.google.com/notebooks/basic_features_overview.ipynb).
    For a tutorial on how to use a Python Notebook, go to [https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/jupyter-notebook-tutorial.ipynb](https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/jupyter-notebook-tutorial.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing **Colab** follows the same rationale as selecting an IDE: it is based
    mainly on your preferences. The following section describes additional Python
    Notebook options.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Python Notebook options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python notebooks are available in free and paid versions from many online companies,
    such as Microsoft, Amazon, Kaggle, Paperspace, and others. Using more than one
    vendor is typical because a Python Notebook behaves the same way across multiple
    vendors. However, it is similar to choosing an IDE – once selected, we tend to
    stay in the same environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following feature criteria to select a Python Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to set up. Can you load and run a Python Notebook in 15 minutes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free version where you can run the Python Notebooks in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free CPU and GPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free permanent storage for the Python Notebooks and versioning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy access to GitHub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to upload and download the Python Notebooks to and from the local disk
    drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option to upgrade to a paid version for faster and additional RAM in terms of
    CPU and GPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The choice of Python Notebook is based on your needs, preferences, or familiarity.
    You don’t have to use Google Colab for the lessons in this book. This book’s Python
    Notebooks will run on, but are not limited to, the following vendors:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Colab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kaggle Notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deepnote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon SageMaker Studio Lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paperspace Gradient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataCrunch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Notebooks in Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cloud-based options depend on having fast internet access at all times,
    so if internet access is a problem, you might want to install the Python Notebook
    locally on your laptop/computer. The installation process is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python Notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python Notebook can be installed on a local desktop or laptop for Windows,
    Mac, and Linux. The advantages of the online version are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fully customizable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No limit on runtime – that is, no timeout on the Python Notebook during long
    training sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No rules or arbitrary limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantage is that you have to set up and maintain the environment. For
    example, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Python and Jupyter Notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure the NVIDIA graphic card (optional for data augmentation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain and update dozens of dependency Python libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade the disk drive, CPU, and GPU RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Python Notebook is easy, requiring just one console or terminal
    command, but first, check the Python version. Type the following command in the
    terminal or console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should have version 3.7.0 or later. If you don’t have Python 3 or have an
    older version, install Python from [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install JupyterLab using `pip`, which contains Python Notebook. On a Windows,
    Mac, or Linux laptop, use the following command for all three OSs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t like `pip`, use `conda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than `pip` and `conda`, you can use `mamba`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Start JupyterLab or Python Notebook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of installing Python Notebook on a Mac is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Jupyter Notebook on a local MacBook](img/B17990_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Jupyter Notebook on a local MacBook
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is cloning this book’s Python Notebook from the respective GitHub
    link. You can use the GitHub desktop app, the GitHub command on the terminal command
    line, or the Python Notebook using the magic character exclamation point (`!`)
    and standard GitHub command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether you choose the cloud-based options, such as Google Colab
    or Kaggle, or work offline, the Python Notebook code will work the same. The following
    section will dive into the Python Notebook programming style and introduce you
    to Pluto.
  prefs: []
  type: TYPE_NORMAL
- en: Programming styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coding style is the standard, tried-and-true method of object-oriented programing
    and is the variable naming convention for functions and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: The majority of Python code you find on blogs and websites is snippets. Therefore,
    they are not very helpful in studying fundamental topics such as data augmentation.
    In addition, Python on a Notebook induces lazy practices because programmers think
    each Notebook’s code cell is a separate snippet from the whole. In reality, the
    entire Python Notebook is one program. Chief among the benefits of using best
    programming practices is that it’s easier to learn and retain knowledge. A programming
    style may include many standard best practices, but it is also unique to your
    programming style. Use it to your advantage by learning new concepts and techniques
    faster, such as how to write data augmentation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few topics in this section. In particular, we will cover
    the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PackTDataAug` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin with source control.
  prefs: []
  type: TYPE_NORMAL
- en: Source control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first rule of programming is to manage the source code version. It will
    help you answer questions such as, *What did you code last week?*, *What was fixed
    yesterday?*, *What new feature was added today?*, and *How do I share my code
    with* *my team?*
  prefs: []
  type: TYPE_NORMAL
- en: The Git process manages the source code for one person or a team. Among many
    of Git's virtues is the freedom to make mistakes. In other words, Git allows you
    to try something new or break the code because you can always roll back to a previous
    version.
  prefs: []
  type: TYPE_NORMAL
- en: For source control, **GitHub** is a popular website, and **Bitbucket** comes
    in second place. You can use the Git process from a command-line terminal or Git
    applications, such as GitHub Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Colab has a built-in Git feature. You have seen how easy it is to load
    a Python Notebook on Google Colab, and saving it is just as easy. In Git, you
    must commit and push. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Colab** menu, click on **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Save a copy** **in GitHub**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your GitHub URL in the **Repository** field and select the code branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the commit message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Google Colab – saving to GitHub](img/B17990_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Google Colab – saving to GitHub
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.6* shows the interface between Google Colab Python Notebook and
    GitHub. Next, we’ll look at the base class, `PacktDataAug`.'
  prefs: []
  type: TYPE_NORMAL
- en: The PacktDataAug class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for the base class is neither original nor unique to this book. It
    is standard Python code for constructing an object-oriented class. The name of
    the object is different for every project. For this book, the name of the class
    is `PacktDataAug`.
  prefs: []
  type: TYPE_NORMAL
- en: Every chapter begins with this base class, and we will add new methods to the
    object using a Python decorator as we learn new concepts and techniques for augmenting
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise's Python code is in the Python Notebooks and on this book’s GitHub
    repository. Thus, I will not copy or display the complete code in this book. I
    will show relevant code lines, explain their significance, and rely on you to
    study the entire code in the Python Notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the base class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`PacktDataAug` is inherent from the based `Object` class, and the definition
    has two optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` parameter is a string, and it is the name of your object. It has
    no essential function other than labeling your object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_verbose` is a Boolean that tells the object to print the object information
    during instantiation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next topic we will cover is the code naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code naming convention is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The function’s name will begin with an action verb, such as `print_`, `fetch_`,
    or `say_`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that returns a Boolean value begins with `is_` or `has_`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names begin with a noun, not an action verb.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a heated discussion in the Python community on whether to use camelCase
    – for example, `fetchKaggleData()` – or use lowercase with underscores – for example,
    `fetch_kaggle_data()`. This book uses lowercase with underscores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions or variables that begin with underscores are temporary variables or
    helper functions – for example, `_image_auto_id`, `_drop_images()`, and `_append_full_path()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable or function abbreviations are sparingly used because the descriptive
    name is easier to understand. In addition, Colab has auto-complete functionality.
    Thus, it makes using long, descriptive names easier to type with fewer typos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for instantiating a base class is standard Python code. I used `pluto`
    as the object name, but you can choose any name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The base class comes with two simple helper methods. They are both for printing
    pretty – that is, making the printing of status or output messages neatly centered.
  prefs: []
  type: TYPE_NORMAL
- en: The `self._ph()` method prints the header line with an equal number of dashes
    on both sides of the colon character, while the `self._pp()` function takes two
    parameters, one for the left-hand side and the other for the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen the result of instantiating pluto with the default parameter
    of `is_verbose=True`. As standard practice, I will not print the complete code
    in this book. I am relying on you to view and run the code in the Python Notebook,
    but I will make an exception for this chapter and show you the snippet of code
    for the `is_verbose` option. This demonstrates how easy it is to read Python code
    in the Python Notebook. The snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: This book’s primary goal is to help you write clean and easy-to-understand code
    and not write compact code that may lead to obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful programming technique is using a Python decorator to extend
    the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Extend base class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book has been designed as an interactive journey where you learn and discover
    new data augmentation concepts and techniques sequentially, from image, text,
    and audio data to tabular data. The object, `pluto`, will acquire new methods
    as the journey progresses. Thus, having a technique to extend the class with new
    functions is essential. In contrast, providing the fully built class at the beginning
    of this book would not allow you to embark on the learning journey. Learning by
    exploration helps you retain knowledge longer compared to learning by memorization.
  prefs: []
  type: TYPE_NORMAL
- en: The `@add_method()` decorator function extends any class with a new function.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an excellent example of extending the base class. The root cause of
    Python’s most common and frustrating error is having a different library version
    from the class homework or code snippet copy from the Python community. Python
    data scientists seldom write code from scratch and rely heavily on existing libraries.
    Thus, printing the Python library versions on a local or cloud-based server would
    save hours of aggravating debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this issue, we can extend the `PacktDataAug` class or use the journey
    metaphor of teaching Pluto a new trick. The new method, `say_sys_info()`, prints
    this book’s expected system library version on the left-hand side and the actual
    library version on your local or remote servers on the right-hand side. The decorator’s
    definition for extending the Pluto class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the aforementioned code cell, you can ask Pluto to print the
    library version using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If your result contains libraries that are older versions than this book’s expected
    value, you might run into bugs while working through the lessons. For example,
    the **Pillow** (**PIL**) library version is 7.1.2, which is lower than the book’s
    expected version of 9.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct this issue, run the following code line in the Notebook to install
    the 9.0.0 version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rerunning `pluto.say_sys_info()` should now show the **PIL** version as 9.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Fun challenge
  prefs: []
  type: TYPE_NORMAL
- en: Extend Pluto with a new function to display the system’s GPU total RAM and available
    free RAM. The function name can be `fetch_system_gpu_ram()`. A hint is to use
    the `torch` library and the `torch.to cuda.memory_allocated()` and `torch.cuda.memory_reserved()`
    functions. You can use this technique to extend any Python library class. For
    example, to add a new function to the `numpy` library, you can use the `@``add_method(numpy)`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more programming-style topics. Next, you’ll discover how best
    to reference a library.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing a library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is a flexible language when it comes to importing libraries. There are
    aliases and direct imports. Here are a few examples of importing the same function
    – that is, `plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The salient point is that all these examples are valid, and that is both good
    and bad. It enables flexibility, but at the same time, sharing code snippets online
    or maintaining code can lead to frustration when they break. Python often gives
    an unintelligible error message when the system cannot locate the function. To
    fix this bug, you need to know which library to upgrade. The problem is compounded
    when many libraries use the same function name, such as the `imread()` method,
    which appears in at least four libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adhering to this book’s programming style, when the `imread()` method fails,
    you know which library needs to be upgraded or, in rare conditions, downgraded.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`matplotlib` might need to be upgraded, or equally, you might be using the
    wrong `imread()` method. It could be from `cv2.imread()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next concept is exporting. It may not strictly belong to the programming
    style, but it is necessary if you wish to reuse and add extra functions to this
    chapter’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting Python code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book ensures that every chapter has its own Python Notebook. The advanced
    image, text, and audio chapters need the previous chapter's code. Thus, it is
    necessary to export the selected Python code cells from the Python Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Notebook has both markup and code cells, and not all code cells must
    be exported. You only need to export code cells that define new functions. For
    the code cells that you want to export to a Python file, use the Python Notebook
    `%%writefile file_name.py` magic command at the beginning of the code cells and
    `%%writefile -a file_name.py` to append additional code to the file. `file_name`
    is the name of the Python file – for example, `pluto_chapter_1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The last and best part of the programming style is introducing **Pluto** as
    your coding companion.
  prefs: []
  type: TYPE_NORMAL
- en: Pluto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pluto uses a whimsical idea of teaching by including dialogs with an imaginary
    digital character. We can give Pluto tasks to complete. It has a friendly tone,
    and sometimes the author addresses you directly. It moves away from the direct
    lecturing format. There are scholarly papers that explain how lecturing in monologue
    is not the optimal method for learning new concepts, such as the article *Why
    Students Learn More From Dialogue- Than Monologue-Videos: Analyses of Peer Interactions*
    by Michelene T. H. Chi, Seokmin Kang, and David L. Yaghmourian that was published
    by the *Journal of the Learning Sciences* in 2016.'
  prefs: []
  type: TYPE_NORMAL
- en: You are most likely reading this book alone rather than engaging in a group,
    learning how to write augmentation code together. Thus, creating an imaginary
    companion as the instantiated object might infuse imagination. It makes writing
    and reading more accessible – for example, the `pluto.fetch_kaggle_data()` function
    is self-explanatory, and little additional documentation is needed. It simplifies
    Python code to a common subject and action-verb-sentence format.
  prefs: []
  type: TYPE_NORMAL
- en: Fun challenge
  prefs: []
  type: TYPE_NORMAL
- en: Change the object name from `pluto = PackTDataAug("Pluto")` to `hanna =` `PackTDataAug("Hanna")`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fair warning**: Do not choose your beloved cat as the object’s name because
    felines will not listen to any commands. Imagine asking your cat to play fetch.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that data augmentation is essential for achieving
    higher accuracy prediction in DL and generative AI. Data augmentation is an economical
    option for extending a dataset without the difficulty of purchasing and labeling
    new data.
  prefs: []
  type: TYPE_NORMAL
- en: The four input data types are image, text, audio, and tabular. Each data type
    faces different challenges, techniques, and limitations. Furthermore, the dataset
    dictates which functions and parameters are suitable. For example, people’s faces
    and aerial photographs are image datasets, but you can’t expand the data by vertically
    flipping people’s images; however, you can vertically flip aerial photos.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, you used **Python notebooks** to reinforce
    your learning of these augmentation concepts. This involved selecting a Python
    Notebook as the default IDE to access a cloud-based platform, such as **Google
    Colab** or **Kaggle**, or installing the Python Notebook locally on your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: The *Programming styles* section lay the foundation for the Python Notebook’s
    structure. It touched on **GitHub** as a form of source control, using base classes,
    extending base classes, long library function names, exporting to Python, and
    introducing Pluto.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter laid the foundation with Pluto as the main object. Pluto does not
    start with complete data augmentation functions – he begins with a minimum structure,
    and as he learns new data augmentation concepts and techniques from chapter to
    chapter, he will add new methods to his arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this book, Pluto and you will learn techniques regarding how to
    augment image, text, audio, and tabular data. In other words, you will learn how
    to write a powerful image, text, audio, and tabular augmentation class from scratch
    using real-world data, which you can reuse in future data augmentation projects.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, there were *fun facts* and *fun challenges*. Pluto
    hopes you will take advantage of what’s been provided and expand your experience
    beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17990_02.xhtml#_idTextAnchor038), *Biases in Data Augmentation*,
    Pluto and you will explore how data augmentation can increase biases. Using data
    biases as a guiding principle to data augmentation is an often-overlooked technique.
  prefs: []
  type: TYPE_NORMAL
