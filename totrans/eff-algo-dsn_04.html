<html><head></head><body>
		<div id="_idContainer046" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-21" class="chapter-number"><a id="_idTextAnchor023" class="pcalibre pcalibre1 calibre6"/><st c="0">2</st></h1>
			<h1 id="_idParaDest-22" class="calibre5"><a id="_idTextAnchor024" class="pcalibre pcalibre1 calibre6"/><st c="2">Mathematical Induction and Loop Invariant for Algorithm Correctness</st></h1>
			<p class="calibre3"><st c="69">Rene Descartes famously said, “</st><em class="italic"><st c="101">With me, everything turns into mathematics</st></em><st c="144">,” emphasizing the profound connection between mathematics and various intellectual pursuits. </st><a id="_idTextAnchor025" class="pcalibre pcalibre1 calibre6"/><st c="238">This sentiment is especially relevant in the field of computer science, where the design, efficiency, and validation of algorithms are deeply rooted in mathematical principles. </st><st c="415">In this chapter, along with the next, we will explore the mathematical foundations that underpin algorithm analysis. </st><st c="532">We will discuss how these mathematical concepts not only guide the development of algorithmic solutions but also ensure their effectiveness and accuracy. </st><st c="686">This discussion aims to provide a comprehensive understanding of how integral mathematics is to the art and science of algorithm design </st><span><st c="822">and analysis.</st></span></p>
			<p class="calibre3"><st c="835">In this chapter, we explore the concept of mathematical induction and its crucial role in establishing loop invariants, a framework for evaluating algorithm correctness forming the foundation for proving algorithm correctness. </st><st c="1063">Through a series of detailed examples, we explain the concept of loop invariants, depicting how they function and their significance. </st><st c="1197">This discussion sets the groundwork for applying these concepts in subsequent chapters, enhancing your ability to rigorously verify the techniques for algorithm correctness. </st><st c="1371">This exploration not only serves as a theoretical framework but also provides practical insights, equipping you with essential tools for effective algorithm design and analysis. </st><st c="1549">In this chapter, the following topics will </st><span><st c="1592">be explored:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><span><st c="1604">Mathematical induction</st></span></li>
				<li class="calibre13"><st c="1627">Loop invariants for the correctness </st><span><st c="1664">of algorithms</st></span></li>
			</ul>
			<h1 id="_idParaDest-23" class="calibre5"><a id="_idTextAnchor026" class="pcalibre pcalibre1 calibre6"/><st c="1677">Mathematical induction</st></h1>
			<p class="calibre3"><st c="1700">Searching for </st><a id="_idIndexMarker023" class="pcalibre pcalibre1 calibre6"/><st c="1715">counterexamples is one of the strategies when questioning the correctness of certain propositions or algorithms. </st><st c="1828">This approach is particularly useful in cases where conventional methods of proving correctness are challenging. </st><st c="1941">A counterexample is essentially a specific instance or case that demonstrates the falsehood of a claim or the incorrectness of an algorithm. </st><st c="2082">When a proof seems complex or the logic behind an algorithm is convoluted, identifying a counterexample can provide a more straightforward means</st><a id="_idIndexMarker024" class="pcalibre pcalibre1 calibre6"/><st c="2226"> of disproving the claim. </st><st c="2252">This approach is also called </st><span><strong class="bold"><st c="2281">indirect proof</st></strong></span><span><st c="2295">.</st></span></p>
			<p class="calibre3"><st c="2296">Often, a counterexample can be easily observed. </st><st c="2345">In such instances, it serves as a quick and efficient way to invalidate a hypothesis, bypassing the need for a lengthy and intricate proof. </st><st c="2485">However, there are situations where finding a counterexample is a challenging task. </st><st c="2569">If after diligent search, a counterexample remains difficult, it might indicate that approaching the problem with a direct proof of correctness is more appropriate. </st><st c="2734">It’s crucial to note, though, that the inability to find a counterexample does not inherently prove the correctness of an algorithm. </st><st c="2867">Just because a counterexample is hard to find or non-apparent, does not mean the algorithm is valid. </st><st c="2968">This underscores the importance of rigorous analysis and testing in algorithm development and evaluation, ensuring that claims of correctness are not prematurely accepted without thorough examination. </st><st c="3169">Now, let’s look at the </st><span><st c="3192">following example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="3210">Example 2.1</st></strong></span><span><st c="3222">:</st></span></p>
			<p class="calibre3"><st c="3224">Prove or disprove: </st><img src="image/8.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;∀&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;&gt;&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;∀&lt;/mml:mo&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;&gt;&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;:&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre20"/><st c="3243"/> </p>
			<p class="calibre3"><st c="3292">Let </st><img src="image/9.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre21"/><st c="3296"/><st c="3297">and </st><img src="image/10.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre22"/><st c="3301"/><st c="3317">. Then, we must show </st><span><st c="3338">the following:</st></span></p>
			<p class="calibre3"><img src="image/11.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;!&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;!&lt;/mo&gt;&lt;mspace width=&quot;0.25em&quot; /&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;*&lt;/mi&gt;&lt;mspace width=&quot;0.25em&quot; /&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;!&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre23"/><st c="3352"/></p>
			<p class="calibre3"><st c="3361">This </st><span><st c="3366">is false.</st></span></p>
			<p class="calibre3"><st c="3375">As previously highlighted, indirect proofs do not guarantee the validity of a relationship or algorithm. </st><st c="3481">This underscores the necessity </st><a id="_idIndexMarker025" class="pcalibre pcalibre1 calibre6"/><st c="3512">for </st><strong class="bold"><st c="3516">direct proof techniques</st></strong><st c="3539"> in algorithm analysis. </st><st c="3563">In contrast to indirect proofs, where we seek counterexamples to disprove a hypothesis, direct proofs involve affirmatively demonstrating that a relationship or algorithm holds true under all </st><span><st c="3755">possible conditions.</st></span></p>
			<p class="calibre3"><st c="3775">For instance, in an</st><a id="_idIndexMarker026" class="pcalibre pcalibre1 calibre6"/><st c="3795"> indirect proof, finding just one counterexample is sufficient to invalidate the claim. </st><st c="3883">However, in direct proofing, especially when dealing with natural numbers, it is necessary to consider all natural numbers from </st><em class="italic"><st c="4011">n=0</st></em><st c="4014"> to </st><img src="image/12.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;∞&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre24"/><st c="4018"/><st c="4026">. This exhaustive approach requires a clear definition of the range and type of </st><em class="italic"><st c="4106">n</st></em><st c="4107">. In the context of algorithm analysis, </st><em class="italic"><st c="4147">n</st></em><st c="4148"> typically represents the number of cases we examine as we progress through the proof. </st><st c="4235">Since the number of cases cannot be fractional and must always be a whole number, </st><em class="italic"><st c="4317">n</st></em><st c="4318"> is defined as a natural number. </st><st c="4351">Furthermore, the range of </st><em class="italic"><st c="4377">n</st></em><st c="4378"> extends from 0 to infinity to ensure that every possible scenario is accounted for, verifying that no case exists that could falsify the algorithm’s correctness. </st><st c="4541">This rigorous method ensures a comprehensive validation of the algorithm’s reliability across all conceivable cases. </st><st c="4658">This is the exact objective of </st><span><st c="4689">mathematical induction.</st></span></p>
			<p class="callout-heading"><st c="4712">Flashback</st></p>
			<p class="callout"><st c="4722">The concept of </st><strong class="bold"><st c="4738">mathematical induction</st></strong><st c="4760"> has a rich history stretching back over 3,000 years. </st><st c="4814">The principle behind mathematical induction is that if a hypothesis holds true at the boundary of a range and continues to hold true within that range, then the hypothesis can be considered valid throughout. </st><st c="5022">This method is particularly efficient for proving mathematical sequences and has a direct relevance to </st><span><st c="5125">computer algorithms.</st></span></p>
			<p class="calibre3"><st c="5145">In the context of computer algorithms, mathematical induction can be seen as a powerful tool for validating algorithm correctness. </st><st c="5277">An algorithm can be viewed as a sophisticated sequence where the input, </st><img src="image/13.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre25"/><st c="5349"/><st c="5350">, represents the case number or the index of a loop, and the sequence embodies the functionality expected from </st><span><st c="5461">the algorithm.</st></span></p>
			<p class="calibre3"><st c="5475">In the process of mathematical induction, the proof begins at a boundary, typically when</st><img src="image/14.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre26"/><st c="5564"/><st c="5572">. From there, the task is to demonstrate that if the hypothesis is valid for some arbitrary natural number </st><img src="image/15.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre27"/><st c="5679"/><st c="5700">, then it is also true for </st><img src="image/16.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre28"/><st c="5727"/><st c="5728">. Once this has been established for </st><img src="image/17.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre29"/><st c="5765"/><st c="5769">(which could be any natural number), it effectively proves the hypothesis for all natural numbers </st><img src="image/18.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;double-struck&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;∈&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;double-struck&quot;&gt;N&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre30"/><st c="5867"/><st c="5868">. This step-by-step approach, progressing from one natural number to the next, underlines the reliability and applicability of mathematical induction in both pure mathematics and </st><span><st c="6047">algorithm design.</st></span></p>
			<p class="calibre3"><st c="6064">Mathematical induction can be succinctly described in two </st><span><st c="6123">straightforward steps:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="6145">Base case (initial step)</st></strong><st c="6170">: This</st><a id="_idIndexMarker027" class="pcalibre pcalibre1 calibre6"/><st c="6177"> involves evaluating and proving that the hypothesis holds true for the smallest value of</st><img src="image/19.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre31"/><st c="6266"/><st c="6332">, typically </st><img src="image/20.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre32"/><st c="6344"/><st c="6365">or </st><img src="image/21.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre33"/><st c="6368"/><st c="6374">, depending on the specifics of the problem. </st><st c="6419">In the context of algorithm design, the base case is usually </st><img src="image/22.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre34"/><st c="6480"/><st c="6481">since testing an algorithm typically begins with the first possible, non-void instance. </st><st c="6569">This step establishes the validity of the hypothesis at the starting point of </st><span><st c="6647">the sequence.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="6660">Induction step</st></strong><st c="6675">: This </st><a id="_idIndexMarker028" class="pcalibre pcalibre1 calibre6"/><st c="6683">step requires proving that if the hypothesis is valid for some arbitrary case number </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre35"/><st c="6768"/><st c="6769">, then it remains valid for</st><img src="image/24.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre36"/><st c="6796"/><st c="6826">. This process, often called the assumption or inductive hypothesis, involves showing that the truth of the hypothesis for one case logically extends its truth to the next case. </st><st c="7004">By successfully demonstrating this, we establish that the hypothesis holds for all subsequent cases, up </st><span><st c="7108">to infinity.</st></span></li>
			</ol>
			<p class="calibre3"><st c="7120">In Example </st><em class="italic"><st c="7132">2.2</st></em><st c="7135">, we demonstrate</st><a id="_idIndexMarker029" class="pcalibre pcalibre1 calibre6"/><st c="7151"> the process of mathematical induction step </st><span><st c="7195">by step.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="7203">Example 2.2</st></strong></span><span><st c="7215">:</st></span></p>
			<p class="calibre3"><st c="7217">Use mathematical induction to prove the </st><span><st c="7257">following proposition.</st></span></p>
			<p class="calibre3"><st c="7279">The sum of the first natural numbers is given by </st><span><st c="7329">the formula:</st></span></p>
			<p class="calibre3"><img src="image/25.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre37"/><st c="7341"/></p>
			<p class="calibre3"><span><strong class="bold"><st c="7343">Proof</st></strong></span><span><st c="7348">:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="7350">Base case</st></strong><st c="7359">: For </st><img src="image/26.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre38"/><st c="7366"/><st c="7367">, the sequence contains only one element, which is 1. </st><st c="7421">According to </st><span><st c="7434">the formula:</st></span><p class="calibre3"><img src="image/27.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt; &lt;/mml:mi&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre39"/><st c="7446"/></p><p class="calibre3"><st c="7448">The base case holds true as both sides of the equation </st><span><st c="7503">are equal.</st></span></p></li>
				<li class="calibre13"><strong class="bold"><st c="7513">Induction step</st></strong><st c="7528">: Assume the proposition holds for </st><img src="image/28.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre40"/><st c="7564"/><st c="7565">; that is, assume </st><span><st c="7583">that </st></span><span><img src="image/29.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre41"/><st c="7588"/></span><span><st c="7594">.</st></span></li>
			</ol>
			<p class="calibre3"><st c="7595">Now, prove it for </st><img src="image/30.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre42"/><st c="7614"/><st c="7615">. Thus, consider </st><span><st c="7632">the sum:</st></span></p>
			<p class="calibre3"><img src="image/31.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre43"/><st c="7640"/></p>
			<p class="calibre3"><st c="7642">According to the induction hypothesis, the sum of the first</st><img src="image/32.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre44"/><st c="7701"/><st c="7713">numbers is </st><img src="image/33.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre45"/><st c="7724"/><st c="7725"> . </st></p>
			<p class="calibre3"><st c="7727">Adding </st><img src="image/34.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre46"/><st c="7734"/><st c="7746">to both sides give </st><span><st c="7765">the following:</st></span></p>
			<p class="calibre3"><img src="image/35.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;×&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre47"/><st c="7779"/> <img src="image/36.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mspace width=&quot;0.25em&quot; /&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mspace width=&quot;0.25em&quot; /&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mspace width=&quot;0.25em&quot; /&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre48"/><st c="7781"/></p>
			<p class="calibre3"><st c="7782">This shows</st><a id="_idIndexMarker030" class="pcalibre pcalibre1 calibre6"/><st c="7792"> that if the proposition is true for </st><img src="image/37.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre49"/><st c="7829"/><st c="7844">, it is also true </st><span><st c="7862">for </st></span><span><img src="image/30.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre42"/><st c="7866"/></span><span><st c="7867">.</st></span></p>
			<p class="calibre3"><st c="7868">You might wonder about the link between mathematical induction and algorithm correctness. </st><st c="7959">To address this, we must first examine the architecture of an algorithm. </st><st c="8032">Fundamentally, an algorithm is a "sequence" – much like a cooking recipe, it is a series of commands designed to solve a problem. </st><st c="8162">Every algorithm comprises various types of commands, which can be broadly categorized </st><span><st c="8248">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="8259">Simple commands</st></strong><st c="8275">: These are</st><a id="_idIndexMarker031" class="pcalibre pcalibre1 calibre6"/><st c="8287"> instructions not dependent on the input size. </st><st c="8334">An example of this could be a basic assignment, such as </st><em class="italic"><st c="8390">x = 0</st></em><st c="8395">. Despite potentially involving complex arithmetic or logic operations, these commands remain independent of the input size. </st><st c="8520">We refer to</st><a id="_idIndexMarker032" class="pcalibre pcalibre1 calibre6"/><st c="8531"> these as </st><strong class="bold"><st c="8541">scale-free commands</st></strong><st c="8560">. Generally, the correctness of these commands is straightforward and often assumed, given </st><span><st c="8651">their simplicity.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="8668">Compound commands</st></strong><st c="8686">: This</st><a id="_idIndexMarker033" class="pcalibre pcalibre1 calibre6"/><st c="8693"> category includes blocks of other commands, which could be simple commands or additional compound commands. </st><st c="8802">A compound command might be encapsulated within a function call or consist of a block of simpler commands. </st><st c="8909">However, the most notable forms of compound commands are </st><strong class="bold"><st c="8966">selection blocks</st></strong> <span><st c="8982">and </st></span><span><strong class="bold"><st c="8987">iterations</st></strong></span><span><st c="8997">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="8999">Selections</st></strong><st c="9009">: These </st><a id="_idIndexMarker034" class="pcalibre pcalibre1 calibre6"/><st c="9018">commands in an algorithm modify the control flow or the direction of logic within the p</st><a id="_idTextAnchor027" class="pcalibre pcalibre1 calibre6"/><st c="9105">rogram. </st><st c="9114">The most commonly used selection commands are the </st><strong class="source-inline1"><st c="9164">if-then</st></strong><st c="9171"> instruction blocks. </st><st c="9192">The correctness of these blocks is crucial and depends on the logical structure of the algorithm, necessitating careful analysis to ensure they behave </st><span><st c="9343">as intended.</st></span></li><li class="calibre13"><strong class="bold"><st c="9355">Iteration</st></strong><st c="9365">: If </st><a id="_idIndexMarker035" class="pcalibre pcalibre1 calibre6"/><st c="9371">we analogize an algorithm to a vehicle, then simple commands represent the body and all stationary parts of the vehicle, while selection components are akin to the steering mechanisms. </st><st c="9556">The movement of the vehicle, however, depends on</st><a id="_idTextAnchor028" class="pcalibre pcalibre1 calibre6"/><st c="9604"> the engine, similar to how the operation of an algorithm relies on its iterative components. </st><st c="9698">While all other components may be scale-free, loops define the scale of the algorithms – in other words, their costs and complexities. </st><st c="9833">Furthermore, the correctness of an algorithm heavily relies on these </st><span><st c="9902">iterative components.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="9923">In essence, the relationship between mathematical induction and algorithm correctness becomes apparent when considering iterative components. </st><st c="10066">Mathematical induction is akin to proving that if a vehicle (algorithm) operates correctly over a given distance (for a certain number of iterative steps), then it will also operate correctly for the next increment of distance (the next step in the iteration). </st><st c="10327">This method of proof is ideally suited for verifying the behavior of loops and recursive procedures within algorithms, ensuring they meet their specifications for all </st><span><st c="10494">potential scenarios.</st></span></p>
			<p class="calibre3"><st c="10514">The following Python code implements an iterative binary search algorithm, which is designed to find the position of a target value within a sorted array. </st><st c="10670">In the following code, we provide a detailed walk-through of the code and highlight the specific roles of the simple commands, iteration block, and selection block. </st><st c="10835">Finally, we will demonstrate how to test </st><span><st c="10876">the function:</st></span></p>
			<pre class="source-code"><st c="10889" class="calibre11">
def binary_search(ar,x):
    low = 0
    high = len(ar) - 1
    mid = 0
    while low &lt;= high:
        mid = (high + low) // 2
        if ar[mid] &lt; x:
            low = mid + 1
        elif ar[mid] &gt; x:
            high = mid - 1
        else:
            return mid</st></pre>			<p class="calibre3"><st c="11072">Let’s analyze each command block in the binary </st><span><st c="11120">search algorithm:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><span><strong class="bold"><st c="11137">Simple commands</st></strong></span><span><st c="11153">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="source-inline1"><st c="11155">low = 0</st></strong><st c="11162">: Initializes the</st><a id="_idIndexMarker036" class="pcalibre pcalibre1 calibre6"/><st c="11180"> lower boundary of the </st><span><st c="11203">search area</st></span></li><li class="calibre13"><strong class="source-inline1"><st c="11214">high = len(ar) - 1</st></strong><st c="11233">: Sets the upper boundary based on the length of </st><span><st c="11283">the array</st></span></li><li class="calibre13"><strong class="source-inline1"><st c="11292">mid = 0</st></strong><st c="11300">: Initializes the </st><span><st c="11319">midpoint variable</st></span></li></ul><p class="calibre3"><st c="11336">These commands set up the initial conditions for the search and do not depend on the input size directly. </st><st c="11443">They’re executed once before the </st><span><st c="11476">loop begins.</st></span></p></li>
				<li class="calibre13"><strong class="bold"><st c="11488">Iteration block</st></strong><st c="11504">: The </st><strong class="source-inline1"><st c="11511">while</st></strong><st c="11516"> loop (</st><strong class="source-inline1"><st c="11523">while low &lt;= hig</st><a id="_idTextAnchor029" class="pcalibre pcalibre1 calibre6"/><st c="11540">h:</st></strong><st c="11543">) continues as long as there is a portion </st><a id="_idIndexMarker037" class="pcalibre pcalibre1 calibre6"/><st c="11586">of the array left to consider, defining the complexity and also impacting the correctness of the algorithm by ensuring every element within the search boundaries </st><span><st c="11748">is considered.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="11762">Selection block</st></strong><st c="11778">: Inside</st><a id="_idIndexMarker038" class="pcalibre pcalibre1 calibre6"/><st c="11787"> the loop, based on the comparison of </st><strong class="source-inline1"><st c="11825">ar[mid]</st></strong><st c="11832"> with </st><strong class="source-inline1"><st c="11838">x</st></strong><st c="11839">, the </st><strong class="source-inline1"><st c="11845">low</st></strong><st c="11848"> and </st><strong class="source-inline1"><st c="11853">high</st></strong><st c="11857"> bounds are adjusted, narrowing down the search space. </st><st c="11912">The </st><strong class="source-inline1"><st c="11916">if</st></strong><st c="11918"> and </st><strong class="source-inline1"><st c="11923">elif</st></strong><st c="11927"> conditions adjust the search boundaries (low and high), while the </st><strong class="source-inline1"><st c="11994">else</st></strong><st c="11998"> condition handles the scenario where the target is found, directly affecting the flow and decision-making within </st><span><st c="12112">the algorithm.</st></span></li>
			</ul>
			<p class="calibre3"><st c="12126">The binary search example was used to demonstrate why the correctness of an algorithm (and its cost, which will be discussed in the next chapter) is often assessed based on the algorithm’s iterative components. </st><st c="12338">With this in mind, a significant challenge arises when applying mathematical induction to verify an algorithm’s correctness: ensuring that the algorithm eventually terminates rather than running indefinitely. </st><st c="12547">This necessity to confirm that the algorithm still functions correctly upon termination is why we introduce a concept specifically tailored to computer algorithms known as loop invariant. </st><st c="12735">This adaptation of mathematical induction helps ensure that despite the iterative nature of an algorithm, it consistently produces the correct output and terminates </st><span><st c="12900">as expected.</st></span></p>
			<h1 id="_idParaDest-24" class="calibre5"><a id="_idTextAnchor030" class="pcalibre pcalibre1 calibre6"/><st c="12912">Loop invariants for the correctness of algorithms</st></h1>
			<p class="calibre3"><st c="12962">The </st><strong class="bold"><st c="12967">loop invariant</st></strong><st c="12981"> is a</st><a id="_idIndexMarker039" class="pcalibre pcalibre1 calibre6"/><st c="12986"> concept that extends mathematical induction, tailored specifically for analyzing algorithms. </st><st c="13080">It adjusts the traditional steps of mathematical induction to better suit the structure of iterative processes in computer algorithms, as outlined in </st><span><em class="italic"><st c="13230">Table 2.1</st></em></span><span><st c="13239">.</st></span></p>
			<table id="table001" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="13240">Mathematical induction</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="13263">Steps in </st></strong><span><strong class="bold"><st c="13273">loop invariant</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="13287">Base case</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="13297">Initialization</st></strong><st c="13312">: Corresponds to the base case in mathematical induction. </st><st c="13371">Here, it is verified that the relation of interest holds true before the iterative </st><span><st c="13454">loops begin.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="13466">Induction step</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="13481">Maintenance</st></strong><st c="13493">: Analogous to the induction step in mathematical induction. </st><st c="13555">This step ensures that if the relation holds true at the beginning of an iteration, it must also hold true at the end of </st><span><st c="13676">that iteration.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><em class="italic"><st c="13691">In mathematical induction, we prove the hypothesis for an infinite number of cases, and it does not involve a </st></em><span><em class="italic"><st c="13802">termination step.</st></em></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="13819">Termination</st></strong><st c="13831">: An additional step not typically part of mathematical induction. </st><st c="13899">This step confirms that the relation of interest continues to hold true after the </st><span><st c="13981">loop terminates.</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="13997">Table 2.1: Comparison of steps in mathematical induction and loop invariant</st></p>
			<p class="calibre3"><st c="14073">These</st><a id="_idIndexMarker040" class="pcalibre pcalibre1 calibre6"/><st c="14079"> three steps — </st><em class="italic"><st c="14094">initialization</st></em><st c="14108">, </st><em class="italic"><st c="14110">maintenance</st></em><st c="14121">, and </st><em class="italic"><st c="14127">termination</st></em><st c="14138"> — form the core of loop invariant theory and are crucial for proving the correctness of algorithms involving loops. </st><st c="14255">The approach ensures that the algorithm not only starts off correctly but also maintains its correctness throughout the execution and concludes with the desired outcome, thus verifying both its functional and </st><span><st c="14464">operational integrity.</st></span></p>
			<p class="calibre3"><st c="14486">To better understand the concept of a loop invariant, let’s use a practical example involving a school bus journey from a starting station to the school, picking up students at each station without any students getting off. </st><st c="14711">We’ll use this scenario to demonstrate how some elements change (the station) and others remain constant (the number of passengers) during the</st><a id="_idIndexMarker041" class="pcalibre pcalibre1 calibre6"/><st c="14853"> loop, and how this relates to loop invariants in </st><span><st c="14903">algorithmic loops.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="14921">Example 2.3</st></strong></span></p>
			<p class="calibre3"><st c="14933">A school bus starts its route with all seats empty. </st><st c="14986">At each station, it stops to pick up students, with no students getting off. </st><st c="15063">This process repeats at each station until the bus reaches </st><span><st c="15122">the school.</st></span></p>
			<p class="calibre3"><strong class="bold"><st c="15133">Loop invariant analysis</st></strong><st c="15157">: In this scenario, we analyze the number of passengers as our loop invariant. </st><st c="15237">The invariant we are testing is: </st><em class="italic"><st c="15270">“The number of passengers on the bus only increases from the beginning to the end of </st></em><span><em class="italic"><st c="15355">the journey.”</st></em></span></p>
			<p class="calibre3"><st c="15368">Now, let’s examine each step of the loop invariant in our school </st><span><st c="15434">bus example.</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="15446">Initialization</st></strong><st c="15461">: At the initial stop (starting station), the bus is empty, with zero students onboard. </st><st c="15550">This sets our initial condition for the loop invariant, where the number of passengers (students) on the bus is </st><span><st c="15662">initially zero.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="15677">Maintenance</st></strong><st c="15689">: As the bus travels from one station to the next (from station </st><em class="italic"><st c="15754">i</st></em><st c="15755">-1 to station i), students only board the bus and none get off. </st><st c="15819">Therefore, the number of students on the bus either increases or remains the same, but never decreases. </st><st c="15923">This maintains the loop invariant that the number of passengers can </st><span><st c="15991">only increase.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="16005">Termination</st></strong><st c="16017">: Upon </st><a id="_idIndexMarker042" class="pcalibre pcalibre1 calibre6"/><st c="16025">arrival at the school, the process of picking up students ceases. </st><st c="16091">The loop invariant holds true as the number of students has only increased or remained constant throughout the journey. </st><st c="16211">At this final point, the invariant confirms that no students have been dropped off and only additional students could have boarded at </st><span><st c="16345">each stop.</st></span></li>
			</ul>
			<p class="calibre3"><st c="16355">This example illustrates that the loop invariant – the assertion that the number of students on the bus never decreases – remains true throughout the entire journey. </st><st c="16522">It is initialized correctly, maintained through each iteration of the loop (each station stop), and still holds when the loop terminates at the school. </st><st c="16674">This analogy helps clarify how loop invariants are applied to ensure certain conditions remain unchanged throughout the execution of an algorithmic loop, providing a method to verify the correctness of </st><span><st c="16876">the process.</st></span></p>
			<p class="calibre3"><st c="16888">An important aspect to clarify is the distinction between the loop condition and the loop invariant. </st><st c="16990">To better illustrate this, let’s revisit the binary search algorithm example from the previous section, focusing specifically on the loop segment of </st><span><st c="17139">the algorithm:</st></span></p>
			<pre class="source-code"><st c="17153" class="calibre11">
while low &lt;= high:
        mid = (high + low)//2
        if ar[mid] &lt; x:
            low = mid + 1
        elif ar[mid] &gt; x:
            high = mid - 1
        else:
            return mid</st></pre>			<p class="calibre3"><st c="17274">The loop condition is a logical statement that determines whether the loop should continue executing or terminate. </st><st c="17390">It is evaluated before each iteration of the loop. </st><st c="17441">If the condition evaluates to true, the loop continues to execute; if it evaluates to false, the loop terminates. </st><st c="17555">The loop condition ensures that the loop runs for the correct number of iterations and is crucial for controlling the flow of the algorithm. </st><st c="17696">For example, in a binary search algorithm, the loop condition might be </st><strong class="source-inline"><st c="17767">low &lt;= high</st></strong><st c="17778">, which ensures that the search continues as long as there are elements </st><span><st c="17850">to consider.</st></span></p>
			<p class="calibre3"><st c="17862">On the other hand, a loop invariant </st><a id="_idIndexMarker043" class="pcalibre pcalibre1 calibre6"/><st c="17899">is a property or condition that holds true before and after each iteration of the loop. </st><st c="17987">It is used to prove the correctness of the algorithm. </st><st c="18041">By establishing that the invariant holds at the start and throughout the loop, we can ensure that the algorithm maintains its intended properties and ultimately produces the correct result. </st><st c="18231">The process of maintaining a loop invariant involves three steps: initialization (showing that the invariant holds before the loop starts), maintenance (showing that if the invariant holds before an iteration, it also holds after), and termination (showing that when the loop terminates, the invariant and the loop condition together imply the correctness of </st><span><st c="18590">the algorithm).</st></span></p>
			<p class="calibre3"><st c="18605">In summary, the loop condition controls the execution of the loop, while the loop invariant ensures the correctness of the algorithm by maintaining a consistent property throughout the </st><span><st c="18791">loop’s execution.</st></span></p>
			<p class="calibre3"><st c="18808">In the binary search algorithm, the loop condition is </st><strong class="source-inline"><st c="18863">low &lt;= high</st></strong><st c="18874">. This condition dictates the execution of the loop, ensuring it continues if there is a valid search space. </st><st c="18983">Essentially, it checks whether there are still potential elements within the designated range (</st><strong class="source-inline"><st c="19078">low</st></strong><st c="19082"> to </st><strong class="source-inline"><st c="19086">high</st></strong><st c="19090">) where the target might be found. </st><st c="19126">When this condition is not met (i.e., </st><strong class="source-inline"><st c="19164">low</st></strong><st c="19167"> exceeds </st><strong class="source-inline"><st c="19176">high</st></strong><st c="19180">), it indicates that the search space has been exhausted without finding the target, and the loop (and thus the search) terminates. </st><st c="19313">Therefore, the loop condition is crucial for defining the operational boundaries of the loop. </st><st c="19407">The question is why is the loop condition not a loop invariant? </st><st c="19471">The</st><a id="_idIndexMarker044" class="pcalibre pcalibre1 calibre6"/><st c="19474"> loop condition is not a loop invariant for a couple of </st><span><st c="19530">key reasons:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="19542">Validity at different stages</st></strong><st c="19571">: The loop invariant must hold true before the loop starts, throughout each iteration, and remain true when the loop exits. </st><st c="19696">In contrast, the loop condition needs to be true exclusively during the loop to permit the continuation of the loop. </st><st c="19813">Once the loop exits (when </st><strong class="source-inline1"><st c="19839">low</st></strong><st c="19842"> exceeds </st><strong class="source-inline1"><st c="19851">high</st></strong><st c="19855">), the </st><strong class="source-inline1"><st c="19863">low &lt;= high</st></strong><st c="19874"> condition is false, which is necessary for stopping the loop but does not align with the requirements of a </st><span><st c="19982">loop invariant.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="19997">Role of condition</st></strong><st c="20015">: The loop condition’s primary role is to check the feasibility of continuing the loop based on the current state of </st><strong class="source-inline1"><st c="20133">low</st></strong><st c="20136"> and </st><strong class="source-inline1"><st c="20141">high</st></strong><st c="20145">. It is a control mechanism, not a statement of correctness or a guarantee about the algorithm’s effectiveness or the integrity of the process. </st><st c="20289">On the other hand, a loop invariant relates to maintaining a certain property or condition that validates the correctness of the algorithm’s logic throughout </st><span><st c="20447">its execution.</st></span></li>
			</ul>
			<p class="calibre3"><st c="20461">Now, let’s take a look at a </st><span><st c="20490">loop invariant.</st></span></p>
			<p class="calibre3"><st c="20505">The</st><a id="_idIndexMarker045" class="pcalibre pcalibre1 calibre6"/><st c="20509"> loop invariant, in contrast with the loop condition, must hold true at the beginning and end of each iteration of the loop for the algorithm to be correct. </st><st c="20666">For a binary search, a suitable loop invariant could be: </st><em class="italic"><st c="20723">“At the start of each iteration, the target must be within the subarray bounded by low and high if it is present in the array.”</st></em><st c="20850"> This invariant assures that the search space is correctly narrowed down after each iteration, by adjusting either the </st><strong class="source-inline"><st c="20969">low</st></strong><st c="20972"> or </st><strong class="source-inline"><st c="20976">high</st></strong><st c="20980"> index based on the comparison of the target with the middle element of the current search </st><span><st c="21071">range (</st></span><span><strong class="source-inline"><st c="21078">ar[mid]</st></strong></span><span><st c="21086">).</st></span></p>
			<p class="calibre3"><st c="21089">In this context, the loop invariant is crucial for ensuring the correctness of the algorithm, guaranteeing that the target element is not overlooked and that the search space is reduced effectively. </st><st c="21289">Conversely, the loop condition governs the continuation of the search process. </st><st c="21368">Understanding the distinct roles of each is essential for effectively analyzing and establishing the correctness of algorithms such as binary search, where it is critical to accurately maintain and narrow the search boundary. </st><st c="21594">In subsequent chapters, as new algorithms are introduced, we will consistently revisit the loop invariant to evaluate the correctness of </st><span><st c="21731">each algorithm.</st></span></p>
			<h1 id="_idParaDest-25" class="calibre5"><a id="_idTextAnchor031" class="pcalibre pcalibre1 calibre6"/><st c="21746">Summary</st></h1>
			<p class="calibre3"><st c="21754">In this chapter, we discussed the important concepts of mathematical induction and loop invariants as foundational tools for verifying the correctness of algorithms. </st><st c="21921">The chapter started by explaining mathematical induction, describing its two primary steps: the base case, which establishes the initial validity of the proposition, and the induction step, which demonstrates the proposition’s maintenance across successive iterations. </st><st c="22190">It then introduces loop invariants, expanding on mathematical induction by including the additional step of termination to ensure that the algorithm’s properties hold from initiation through termination. </st><st c="22394">Through detailed examples, such as a binary search algorithm, the chapter illustrates how these principles are applied to prove that algorithms perform correctly and efficiently, emphasizing their importance in developing reliable software. </st><st c="22635">The chapter aimed to equip you with the methodologies to rigorously assess the integrity and operational correctness of </st><span><st c="22755">various algorithms.</st></span></p>
			<p class="calibre3"><st c="22774">As previously mentioned, algorithm analysis involves two key aspects: proving the correctness of the algorithm and analyzing its complexity. </st><st c="22916">The next chapter will address the second aspect, focusing on the complexity of algorithms and how to estimate </st><span><st c="23026">this complexity.</st></span></p>
			<h1 id="_idParaDest-26" class="calibre5"><a id="_idTextAnchor032" class="pcalibre pcalibre1 calibre6"/><st c="23042">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><em class="italic"><st c="23073">Introduction to Algorithms</st></em><st c="23100">. By Thomas H. </st><st c="23115">Cormen, Charles E. </st><st c="23134">Leiserson, Ronald L. </st><st c="23155">Rivest, and Clifford Stein. </st><st c="23183">Fourth Edition. </st><st c="23199">MIT </st><span><st c="23203">Press. </st><st c="23210">2022.</st></span></li>
				<li class="calibre13"><em class="italic"><st c="23215">Algorithm Design</st></em><st c="23232">. By Jon Kleinberg and Éva Tardos. </st><st c="23267">First Edition. </st><span><st c="23282">Pearson. </st><st c="23291">2005.</st></span></li>
				<li class="calibre13"><em class="italic"><st c="23296">The Art of Computer Programming</st></em><st c="23328">, Volume 1: Fundamental Algorithms. </st><st c="23364">Donald E. </st><st c="23374">Knuth. </st><st c="23381">Third Edition. </st><st c="23396">Addison-Wesley </st><span><st c="23411">Professional. </st><st c="23425">1997.</st></span></li>
				<li class="calibre13"><em class="italic"><st c="23430">Algorithms Unlocked</st></em><st c="23450">. By Thomas H. </st><st c="23465">Cormen. </st><st c="23473">MIT </st><span><st c="23477">Press. </st><st c="23484">2013.</st></span></li>
				<li class="calibre13"><em class="italic"><st c="23489">Discrete Mathematics and Its Applications</st></em><st c="23531">. By Kenneth H. </st><st c="23547">Rosen. </st><st c="23554">McGraw-Hill Science/Engineering/Math. </st><st c="23592">Twelfth Edition. </st><span><st c="23609">McGraw-Hill. </st><st c="23622">2012.</st></span></li>
				<li class="calibre13"><em class="italic"><st c="23627">Concrete Mathematics: A Foundation for Computer Science</st></em><st c="23683">. By Ronald L. </st><st c="23698">Graham, Donald E. </st><st c="23716">Knuth, and Oren Patashnik. </st><st c="23743">Second Edition. </st><span><st c="23759">Addison-Wesley. </st><st c="23775">1994.</st></span></li>
				<li class="calibre13"><em class="italic"><st c="23780">How to Prove It: A Structured Approach</st></em><st c="23819">. By Daniel J. </st><st c="23834">Velleman. </st><st c="23844">Third Edition. </st><st c="23859">Cambridge University </st><span><st c="23880">Press. </st><st c="23887">2019.</st></span></li>
			</ul>
		</div>
	<div id="charCountTotal" value="23892" class="calibre2"/></body></html>