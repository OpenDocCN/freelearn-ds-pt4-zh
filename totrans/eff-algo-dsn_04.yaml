- en: <st c="0">2</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Mathematical Induction and Loop Invariant for Algorithm Correctness</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="69">Rene Descartes famously said, “</st>*<st c="101">With me, everything
    turns into mathematics</st>*<st c="144">,” emphasizing the profound connection
    between mathematics and various intellectual pursuits.</st> <st c="238">This sentiment
    is especially relevant in the field of computer science, where the design, efficiency,
    and validation of algorithms are deeply rooted in mathematical principles.</st>
    <st c="415">In this chapter, along with the next, we will explore the mathematical
    foundations that underpin algorithm analysis.</st> <st c="532">We will discuss
    how these mathematical concepts not only guide the development of algorithmic
    solutions but also ensure their effectiveness and accuracy.</st> <st c="686">This
    discussion aims to provide a comprehensive understanding of how integral mathematics
    is to the art and science of algorithm design</st> <st c="822">and analysis.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="835">In this chapter, we explore the concept of mathematical induction
    and its crucial role in establishing loop invariants, a framework for evaluating
    algorithm correctness forming the foundation for proving algorithm correctness.</st>
    <st c="1063">Through a series of detailed examples, we explain the concept of
    loop invariants, depicting how they function and their significance.</st> <st
    c="1197">This discussion sets the groundwork for applying these concepts in subsequent
    chapters, enhancing your ability to rigorously verify the techniques for algorithm
    correctness.</st> <st c="1371">This exploration not only serves as a theoretical
    framework but also provides practical insights, equipping you with essential tools
    for effective algorithm design and analysis.</st> <st c="1549">In this chapter,
    the following topics will</st> <st c="1592">be explored:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1604">Mathematical induction</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1627">Loop invariants for the correctness</st> <st c="1664">of algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1677">Mathematical induction</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1700">Searching for</st> <st c="1715">counterexamples is one of the strategies
    when questioning the correctness of certain propositions or algorithms.</st> <st
    c="1828">This approach is particularly useful in cases where conventional methods
    of proving correctness are challenging.</st> <st c="1941">A counterexample is
    essentially a specific instance or case that demonstrates the falsehood of a claim
    or the incorrectness of an algorithm.</st> <st c="2082">When a proof seems complex
    or the logic behind an algorithm is convoluted, identifying a counterexample can
    provide a more straightforward means</st> <st c="2226">of disproving the claim.</st>
    <st c="2252">This approach is also called</st> **<st c="2281">indirect proof</st>**<st
    c="2295">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2296">Often, a counterexample can be easily observed.</st> <st c="2345">In
    such instances, it serves as a quick and efficient way to invalidate a hypothesis,
    bypassing the need for a lengthy and intricate proof.</st> <st c="2485">However,
    there are situations where finding a counterexample is a challenging task.</st>
    <st c="2569">If after diligent search, a counterexample remains difficult, it
    might indicate that approaching the problem with a direct proof of correctness
    is more appropriate.</st> <st c="2734">It’s crucial to note, though, that the
    inability to find a counterexample does not inherently prove the correctness of
    an algorithm.</st> <st c="2867">Just because a counterexample is hard to find
    or non-apparent, does not mean the algorithm is valid.</st> <st c="2968">This
    underscores the importance of rigorous analysis and testing in algorithm development
    and evaluation, ensuring that claims of correctness are not prematurely accepted
    without thorough examination.</st> <st c="3169">Now, let’s look at the</st> <st
    c="3192">following example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="3210">Example 2.1</st>**<st c="3222">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3224">Prove or disprove:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∀</mml:mo><mml:mi>a</mml:mi><mml:mo>></mml:mo><mml:mn>1</mml:mn><mml:mi
    mathvariant="normal"> </mml:mi><mml:mo>∀</mml:mo><mml:mi>b</mml:mi><mml:mo>></mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>!</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mi>a</mml:mi><mml:mo>!</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>b</mml:mi><mml:mo>!</mml:mo><mml:mi mathvariant="normal"> </mml:mi></mml:math>](img/8.png)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3292">Let</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/9.png)<st
    c="3296"><st c="3297">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math>](img/10.png)<st
    c="3301"><st c="3317">. Then, we must show</st> <st c="3338">the following:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow></mfenced><mo>!</mo><mo>=</mo><mn>2</mn><mo>!</mo><mspace
    width="0.25em" /><mi mathvariant="normal">*</mi><mspace width="0.25em" /><mn>3</mn><mo>!</mo></mrow></mrow></math>](img/11.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="3361">This</st> <st c="3366">is false.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3375">As previously highlighted, indirect proofs do not guarantee the
    validity of a relationship or algorithm.</st> <st c="3481">This underscores the
    necessity</st> <st c="3512">for</st> **<st c="3516">direct proof techniques</st>**
    <st c="3539">in algorithm analysis.</st> <st c="3563">In contrast to indirect
    proofs, where we seek counterexamples to disprove a hypothesis, direct proofs
    involve affirmatively demonstrating that a relationship or algorithm holds true
    under all</st> <st c="3755">possible conditions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3775">For instance, in an</st> <st c="3795">indirect proof, finding just
    one counterexample is sufficient to invalidate the claim.</st> <st c="3883">However,
    in direct proofing, especially when dealing with natural numbers, it is necessary
    to consider all natural numbers from</st> *<st c="4011">n=0</st>* <st c="4014">to</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>∞</mml:mi></mml:math>](img/12.png)<st
    c="4018"><st c="4026">. This exhaustive approach requires a clear definition of
    the range and type of</st> *<st c="4106">n</st>*<st c="4107">. In the context
    of algorithm analysis,</st> *<st c="4147">n</st>* <st c="4148">typically represents
    the number of cases we examine as we progress through the proof.</st> <st c="4235">Since
    the number of cases cannot be fractional and must always be a whole number,</st>
    *<st c="4317">n</st>* <st c="4318">is defined as a natural number.</st> <st c="4351">Furthermore,
    the range of</st> *<st c="4377">n</st>* <st c="4378">extends from 0 to infinity
    to ensure that every possible scenario is accounted for, verifying that no case
    exists that could falsify the algorithm’s correctness.</st> <st c="4541">This
    rigorous method ensures a comprehensive validation of the algorithm’s reliability
    across all conceivable cases.</st> <st c="4658">This is the exact objective of</st>
    <st c="4689">mathematical induction.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4712">Flashback</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4722">The concept of</st> **<st c="4738">mathematical induction</st>**
    <st c="4760">has a rich history stretching back over 3,000 years.</st> <st c="4814">The
    principle behind mathematical induction is that if a hypothesis holds true at
    the boundary of a range and continues to hold true within that range, then the
    hypothesis can be considered valid throughout.</st> <st c="5022">This method is
    particularly efficient for proving mathematical sequences and has a direct relevance
    to</st> <st c="5125">computer algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5145">In the context of computer algorithms, mathematical induction can
    be seen as a powerful tool for validating algorithm correctness.</st> <st c="5277">An
    algorithm can be viewed as a sophisticated sequence where the input,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)<st
    c="5349"><st c="5350">, represents the case number or the index of a loop, and
    the sequence embodies the functionality expected from</st> <st c="5461">the algorithm.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5475">In the process of mathematical induction, the proof begins at a
    boundary, typically when</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi> </mml:mi><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/14.png)<st
    c="5564"><st c="5572">. From there, the task is to demonstrate that if the hypothesis
    is valid for some arbitrary natural number</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:math>](img/15.png)<st
    c="5679"><st c="5700">, then it is also true for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/16.png)<st
    c="5727"><st c="5728">. Once this has been established for</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>k</mi></mrow></math>](img/17.png)<st
    c="5765"><st c="5769">(which could be any natural number), it effectively proves
    the hypothesis for all natural numbers</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mi
    mathvariant="double-struck"> </mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:math>](img/18.png)<st
    c="5867"><st c="5868">. This step-by-step approach, progressing from one natural
    number to the next, underlines the reliability and applicability of mathematical
    induction in both pure mathematics and</st> <st c="6047">algorithm design.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6064">Mathematical induction can be succinctly described in two</st>
    <st c="6123">straightforward steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="6145">Base case (initial step)</st>**<st c="6170">: This</st> <st
    c="6177">involves evaluating and proving that the hypothesis holds true for the
    smallest value of</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi> </mml:mi><mml:mi>n</mml:mi></mml:math>](img/19.png)<st
    c="6266"><st c="6332">, typically</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/20.png)<st
    c="6344"><st c="6365">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/21.png)<st
    c="6368"><st c="6374">, depending on the specifics of the problem.</st> <st c="6419">In
    the context of algorithm design, the base case is usually</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/22.png)<st
    c="6480"><st c="6481">since testing an algorithm typically begins with the first
    possible, non-void instance.</st> <st c="6569">This step establishes the validity
    of the hypothesis at the starting point of</st> <st c="6647">the sequence.</st></st></st></st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="6660">Induction step</st>**<st c="6675">: This</st> <st c="6683">step
    requires proving that if the hypothesis is valid for some arbitrary case number</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="6768"><st c="6769">, then it remains valid for</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi> </mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/24.png)<st
    c="6796"><st c="6826">. This process, often called the assumption or inductive
    hypothesis, involves showing that the truth of the hypothesis for one case logically
    extends its truth to the next case.</st> <st c="7004">By successfully demonstrating
    this, we establish that the hypothesis holds for all subsequent cases, up</st>
    <st c="7108">to infinity.</st></st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="7120">In Example</st> *<st c="7132">2.2</st>*<st c="7135">, we demonstrate</st>
    <st c="7151">the process of mathematical induction step</st> <st c="7195">by step.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7203">Example 2.2</st>**<st c="7215">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7217">Use mathematical induction to prove the</st> <st c="7257">following
    proposition.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7279">The sum of the first natural numbers is given by</st> <st c="7329">the
    formula:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mo>…</mo><mo>+</mo><mi>n</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>2</mn></mfrac></mrow></mrow></math>](img/25.png)'
  prefs: []
  type: TYPE_IMG
- en: '**<st c="7343">Proof</st>**<st c="7348">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7350">Base case</st>**<st c="7359">: For</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mn>1</mml:mn></mml:math>](img/26.png)<st
    c="7366"><st c="7367">, the sequence contains only one element, which is 1\.</st>
    <st c="7421">According to</st> <st c="7434">the formula:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>1</mml:mn><mml:mi mathvariant="normal"> </mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mn>1</mml:mn></mml:math>](img/27.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: <st c="7448">The base case holds true as both sides of the equation</st> <st
    c="7503">are equal.</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="7513">Induction step</st>**<st c="7528">: Assume the proposition holds
    for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>k</mml:mi></mml:math>](img/28.png)<st
    c="7564"><st c="7565">; that is, assume</st> <st c="7583">that</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mfrac><mml:mrow><mml:mi>k</mml:mi><mml:mi> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/29.png)<st
    c="7588"><st c="7594">.</st></st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="7595">Now, prove it for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/30.png)<st
    c="7614"><st c="7615">. Thus, consider</st> <st c="7632">the sum:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>1</mml:mn><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mn>2</mml:mn><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mn>3</mml:mn><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mi>k</mml:mi><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/31.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="7642">According to the induction hypothesis, the sum of the first</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi> </mml:mi><mml:mi>k</mml:mi><mml:mi> </mml:mi></mml:math>](img/32.png)<st
    c="7701"><st c="7713">numbers is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>k</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/33.png)
    <st c="7724"><st c="7725">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7727">Adding</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mi> </mml:mi></mml:math>](img/34.png)<st
    c="7734"><st c="7746">to both sides give</st> <st c="7765">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mfrac><mml:mrow><mml:mi>k</mml:mi><mml:mi> </mml:mi><mml:mo>×</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/35.png)
    <st c="7779">![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><mi>k</mi><mspace width="0.25em" /><mo>×</mo><mfenced
    open="(" close=")"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mn>2</mn><mfenced
    open="(" close=")"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>2</mn></mfrac></mstyle><mo>=</mo><mspace
    width="0.25em" /><mstyle scriptlevel="+1"><mfrac><mrow><mfenced open="(" close=")"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mspace
    width="0.25em" /><mfenced open="(" close=")"><mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></mfenced></mrow><mn>2</mn></mfrac></mstyle></mrow></mrow></math>](img/36.png)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7782">This shows</st> <st c="7792">that if the proposition is true for</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:math>](img/37.png)<st
    c="7829"><st c="7844">, it is also true</st> <st c="7862">for</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/30.png)<st
    c="7866"><st c="7867">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7868">You might wonder about the link between mathematical induction
    and algorithm correctness.</st> <st c="7959">To address this, we must first examine
    the architecture of an algorithm.</st> <st c="8032">Fundamentally, an algorithm
    is a "sequence" – much like a cooking recipe, it is a series of commands designed
    to solve a problem.</st> <st c="8162">Every algorithm comprises various types
    of commands, which can be broadly categorized</st> <st c="8248">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="8259">Simple commands</st>**<st c="8275">: These are</st> <st c="8287">instructions
    not dependent on the input size.</st> <st c="8334">An example of this could be
    a basic assignment, such as</st> *<st c="8390">x = 0</st>*<st c="8395">. Despite
    potentially involving complex arithmetic or logic operations, these commands remain
    independent of the input size.</st> <st c="8520">We refer to</st> <st c="8531">these
    as</st> **<st c="8541">scale-free commands</st>**<st c="8560">. Generally, the
    correctness of these commands is straightforward and often assumed, given</st>
    <st c="8651">their simplicity.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8668">Compound commands</st>**<st c="8686">: This</st> <st c="8693">category
    includes blocks of other commands, which could be simple commands or additional
    compound commands.</st> <st c="8802">A compound command might be encapsulated
    within a function call or consist of a block of simpler commands.</st> <st c="8909">However,
    the most notable forms of compound commands are</st> **<st c="8966">selection
    blocks</st>** <st c="8982">and</st> **<st c="8987">iterations</st>**<st c="8997">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8999">Selections</st>**<st c="9009">: These</st> <st c="9018">commands
    in an algorithm modify the control flow or the direction of logic within the p</st><st
    c="9105">rogram.</st> <st c="9114">The most commonly used selection commands are
    the</st> **<st c="9164">if-then</st>** <st c="9171">instruction blocks.</st> <st
    c="9192">The correctness of these blocks is crucial and depends on the logical
    structure of the algorithm, necessitating careful analysis to ensure they behave</st>
    <st c="9343">as intended.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9355">Iteration</st>**<st c="9365">: If</st> <st c="9371">we analogize
    an algorithm to a vehicle, then simple commands represent the body and all stationary
    parts of the vehicle, while selection components are akin to the steering mechanisms.</st>
    <st c="9556">The movement of the vehicle, however, depends on</st> <st c="9604">the
    engine, similar to how the operation of an algorithm relies on its iterative components.</st>
    <st c="9698">While all other components may be scale-free, loops define the scale
    of the algorithms – in other words, their costs and complexities.</st> <st c="9833">Furthermore,
    the correctness of an algorithm heavily relies on these</st> <st c="9902">iterative
    components.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9923">In essence, the relationship between mathematical induction and
    algorithm correctness becomes apparent when considering iterative components.</st>
    <st c="10066">Mathematical induction is akin to proving that if a vehicle (algorithm)
    operates correctly over a given distance (for a certain number of iterative steps),
    then it will also operate correctly for the next increment of distance (the next
    step in the iteration).</st> <st c="10327">This method of proof is ideally suited
    for verifying the behavior of loops and recursive procedures within algorithms,
    ensuring they meet their specifications for all</st> <st c="10494">potential scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10514">The following Python code implements an iterative binary search
    algorithm, which is designed to find the position of a target value within a sorted
    array.</st> <st c="10670">In the following code, we provide a detailed walk-through
    of the code and highlight the specific roles of the simple commands, iteration
    block, and selection block.</st> <st c="10835">Finally, we will demonstrate how
    to test</st> <st c="10876">the function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="11072">Let’s analyze each command block in the binary</st> <st c="11120">search
    algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11137">Simple commands</st>**<st c="11153">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11155">low = 0</st>**<st c="11162">: Initializes the</st> <st c="11180">lower
    boundary of the</st> <st c="11203">search area</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11214">high = len(ar) - 1</st>**<st c="11233">: Sets the upper boundary
    based on the length of</st> <st c="11283">the array</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11292">mid = 0</st>**<st c="11300">: Initializes the</st> <st c="11319">midpoint
    variable</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11336">These commands set up the initial conditions for the search and
    do not depend on the input size directly.</st> <st c="11443">They’re executed
    once before the</st> <st c="11476">loop begins.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="11488">Iteration block</st>**<st c="11504">: The</st> **<st c="11511">while</st>**
    <st c="11516">loop (</st>**<st c="11523">while low <= hig</st><st c="11540">h:</st>**<st
    c="11543">) continues as long as there is a portion</st> <st c="11586">of the
    array left to consider, defining the complexity and also impacting the correctness
    of the algorithm by ensuring every element within the search boundaries</st> <st
    c="11748">is considered.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11762">Selection block</st>**<st c="11778">: Inside</st> <st c="11787">the
    loop, based on the comparison of</st> **<st c="11825">ar[mid]</st>** <st c="11832">with</st>
    **<st c="11838">x</st>**<st c="11839">, the</st> **<st c="11845">low</st>** <st
    c="11848">and</st> **<st c="11853">high</st>** <st c="11857">bounds are adjusted,
    narrowing down the search space.</st> <st c="11912">The</st> **<st c="11916">if</st>**
    <st c="11918">and</st> **<st c="11923">elif</st>** <st c="11927">conditions adjust
    the search boundaries (low and high), while the</st> **<st c="11994">else</st>**
    <st c="11998">condition handles the scenario where the target is found, directly
    affecting the flow and decision-making within</st> <st c="12112">the algorithm.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="12126">The binary search example was used to demonstrate why the correctness
    of an algorithm (and its cost, which will be discussed in the next chapter) is
    often assessed based on the algorithm’s iterative components.</st> <st c="12338">With
    this in mind, a significant challenge arises when applying mathematical induction
    to verify an algorithm’s correctness: ensuring that the algorithm eventually terminates
    rather than running indefinitely.</st> <st c="12547">This necessity to confirm
    that the algorithm still functions correctly upon termination is why we introduce
    a concept specifically tailored to computer algorithms known as loop invariant.</st>
    <st c="12735">This adaptation of mathematical induction helps ensure that despite
    the iterative nature of an algorithm, it consistently produces the correct output
    and terminates</st> <st c="12900">as expected.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12912">Loop invariants for the correctness of algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="12962">The</st> **<st c="12967">loop invariant</st>** <st c="12981">is
    a</st> <st c="12986">concept that extends mathematical induction, tailored specifically
    for analyzing algorithms.</st> <st c="13080">It adjusts the traditional steps
    of mathematical induction to better suit the structure of iterative processes
    in computer algorithms, as outlined in</st> *<st c="13230">Table 2.1</st>*<st
    c="13239">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="13240">Mathematical induction</st>** | **<st c="13263">Steps in</st>**
    **<st c="13273">loop invariant</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="13287">Base case</st> | **<st c="13297">Initialization</st>**<st c="13312">:
    Corresponds to the base case in mathematical induction.</st> <st c="13371">Here,
    it is verified that the relation of interest holds true before the iterative</st>
    <st c="13454">loops begin.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="13466">Induction step</st> | **<st c="13481">Maintenance</st>**<st
    c="13493">: Analogous to the induction step in mathematical induction.</st> <st
    c="13555">This step ensures that if the relation holds true at the beginning of
    an iteration, it must also hold true at the end of</st> <st c="13676">that iteration.</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| *<st c="13691">In mathematical induction, we prove the hypothesis for an
    infinite number of cases, and it does not involve a</st>* *<st c="13802">termination
    step.</st>* | **<st c="13819">Termination</st>**<st c="13831">: An additional
    step not typically part of mathematical induction.</st> <st c="13899">This step
    confirms that the relation of interest continues to hold true after the</st> <st
    c="13981">loop terminates.</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="13997">Table 2.1: Comparison of steps in mathematical induction and
    loop invariant</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14073">These</st> <st c="14079">three steps —</st> *<st c="14094">initialization</st>*<st
    c="14108">,</st> *<st c="14110">maintenance</st>*<st c="14121">, and</st> *<st
    c="14127">termination</st>* <st c="14138">— form the core of loop invariant theory
    and are crucial for proving the correctness of algorithms involving loops.</st>
    <st c="14255">The approach ensures that the algorithm not only starts off correctly
    but also maintains its correctness throughout the execution and concludes with
    the desired outcome, thus verifying both its functional and</st> <st c="14464">operational
    integrity.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14486">To better understand the concept of a loop invariant, let’s use
    a practical example involving a school bus journey from a starting station to
    the school, picking up students at each station without any students getting off.</st>
    <st c="14711">We’ll use this scenario to demonstrate how some elements change
    (the station) and others remain constant (the number of passengers) during the</st>
    <st c="14853">loop, and how this relates to loop invariants in</st> <st c="14903">algorithmic
    loops.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="14921">Example 2.3</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14933">A school bus starts its route with all seats empty.</st> <st c="14986">At
    each station, it stops to pick up students, with no students getting off.</st>
    <st c="15063">This process repeats at each station until the bus reaches</st>
    <st c="15122">the school.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15133">Loop invariant analysis</st>**<st c="15157">: In this scenario,
    we analyze the number of passengers as our loop invariant.</st> <st c="15237">The
    invariant we are testing is:</st> *<st c="15270">“The number of passengers on
    the bus only increases from the beginning to the end of</st>* *<st c="15355">the
    journey.”</st>*'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15368">Now, let’s examine each step of the loop invariant in our school</st>
    <st c="15434">bus example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15446">Initialization</st>**<st c="15461">: At the initial stop (starting
    station), the bus is empty, with zero students onboard.</st> <st c="15550">This
    sets our initial condition for the loop invariant, where the number of passengers
    (students) on the bus is</st> <st c="15662">initially zero.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15677">Maintenance</st>**<st c="15689">: As the bus travels from one
    station to the next (from station</st> *<st c="15754">i</st>*<st c="15755">-1
    to station i), students only board the bus and none get off.</st> <st c="15819">Therefore,
    the number of students on the bus either increases or remains the same, but never
    decreases.</st> <st c="15923">This maintains the loop invariant that the number
    of passengers can</st> <st c="15991">only increase.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16005">Termination</st>**<st c="16017">: Upon</st> <st c="16025">arrival
    at the school, the process of picking up students ceases.</st> <st c="16091">The
    loop invariant holds true as the number of students has only increased or remained
    constant throughout the journey.</st> <st c="16211">At this final point, the invariant
    confirms that no students have been dropped off and only additional students could
    have boarded at</st> <st c="16345">each stop.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16355">This example illustrates that the loop invariant – the assertion
    that the number of students on the bus never decreases – remains true throughout
    the entire journey.</st> <st c="16522">It is initialized correctly, maintained
    through each iteration of the loop (each station stop), and still holds when the
    loop terminates at the school.</st> <st c="16674">This analogy helps clarify how
    loop invariants are applied to ensure certain conditions remain unchanged throughout
    the execution of an algorithmic loop, providing a method to verify the correctness
    of</st> <st c="16876">the process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16888">An important aspect to clarify is the distinction between the
    loop condition and the loop invariant.</st> <st c="16990">To better illustrate
    this, let’s revisit the binary search algorithm example from the previous section,
    focusing specifically on the loop segment of</st> <st c="17139">the algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17274">The loop condition is a logical statement that determines whether
    the loop should continue executing or terminate.</st> <st c="17390">It is evaluated
    before each iteration of the loop.</st> <st c="17441">If the condition evaluates
    to true, the loop continues to execute; if it evaluates to false, the loop terminates.</st>
    <st c="17555">The loop condition ensures that the loop runs for the correct number
    of iterations and is crucial for controlling the flow of the algorithm.</st> <st
    c="17696">For example, in a binary search algorithm, the loop condition might
    be</st> `<st c="17767">low <= high</st>`<st c="17778">, which ensures that the
    search continues as long as there are elements</st> <st c="17850">to consider.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="17862">On the other hand, a loop invariant</st> <st c="17899">is a property
    or condition that holds true before and after each iteration of the loop.</st>
    <st c="17987">It is used to prove the correctness of the algorithm.</st> <st c="18041">By
    establishing that the invariant holds at the start and throughout the loop, we
    can ensure that the algorithm maintains its intended properties and ultimately
    produces the correct result.</st> <st c="18231">The process of maintaining a loop
    invariant involves three steps: initialization (showing that the invariant holds
    before the loop starts), maintenance (showing that if the invariant holds before
    an iteration, it also holds after), and termination (showing that when the loop
    terminates, the invariant and the loop condition together imply the correctness
    of</st> <st c="18590">the algorithm).</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18605">In summary, the loop condition controls the execution of the loop,
    while the loop invariant ensures the correctness of the algorithm by maintaining
    a consistent property throughout the</st> <st c="18791">loop’s execution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18808">In the binary search algorithm, the loop condition is</st> `<st
    c="18863">low <= high</st>`<st c="18874">. This condition dictates the execution
    of the loop, ensuring it continues if there is a valid search space.</st> <st
    c="18983">Essentially, it checks whether there are still potential elements within
    the designated range (</st>`<st c="19078">low</st>` <st c="19082">to</st> `<st
    c="19086">high</st>`<st c="19090">) where the target might be found.</st> <st
    c="19126">When this condition is not met (i.e.,</st> `<st c="19164">low</st>`
    <st c="19167">exceeds</st> `<st c="19176">high</st>`<st c="19180">), it indicates
    that the search space has been exhausted without finding the target, and the loop
    (and thus the search) terminates.</st> <st c="19313">Therefore, the loop condition
    is crucial for defining the operational boundaries of the loop.</st> <st c="19407">The
    question is why is the loop condition not a loop invariant?</st> <st c="19471">The</st>
    <st c="19474">loop condition is not a loop invariant for a couple of</st> <st
    c="19530">key reasons:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="19542">Validity at different stages</st>**<st c="19571">: The loop
    invariant must hold true before the loop starts, throughout each iteration, and
    remain true when the loop exits.</st> <st c="19696">In contrast, the loop condition
    needs to be true exclusively during the loop to permit the continuation of the
    loop.</st> <st c="19813">Once the loop exits (when</st> **<st c="19839">low</st>**
    <st c="19842">exceeds</st> **<st c="19851">high</st>**<st c="19855">), the</st>
    **<st c="19863">low <= high</st>** <st c="19874">condition is false, which is
    necessary for stopping the loop but does not align with the requirements of a</st>
    <st c="19982">loop invariant.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="19997">Role of condition</st>**<st c="20015">: The loop condition’s
    primary role is to check the feasibility of continuing the loop based on the current
    state of</st> **<st c="20133">low</st>** <st c="20136">and</st> **<st c="20141">high</st>**<st
    c="20145">. It is a control mechanism, not a statement of correctness or a guarantee
    about the algorithm’s effectiveness or the integrity of the process.</st> <st
    c="20289">On the other hand, a loop invariant relates to maintaining a certain
    property or condition that validates the correctness of the algorithm’s logic
    throughout</st> <st c="20447">its execution.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20461">Now, let’s take a look at a</st> <st c="20490">loop invariant.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20505">The</st> <st c="20509">loop invariant, in contrast with the loop
    condition, must hold true at the beginning and end of each iteration of the loop
    for the algorithm to be correct.</st> <st c="20666">For a binary search, a suitable
    loop invariant could be:</st> *<st c="20723">“At the start of each iteration,
    the target must be within the subarray bounded by low and high if it is present
    in the array.”</st>* <st c="20850">This invariant assures that the search space
    is correctly narrowed down after each iteration, by adjusting either the</st>
    `<st c="20969">low</st>` <st c="20972">or</st> `<st c="20976">high</st>` <st c="20980">index
    based on the comparison of the target with the middle element of the current search</st>
    <st c="21071">range (</st>`<st c="21078">ar[mid]</st>`<st c="21086">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21089">In this context, the loop invariant is crucial for ensuring the
    correctness of the algorithm, guaranteeing that the target element is not overlooked
    and that the search space is reduced effectively.</st> <st c="21289">Conversely,
    the loop condition governs the continuation of the search process.</st> <st c="21368">Understanding
    the distinct roles of each is essential for effectively analyzing and establishing
    the correctness of algorithms such as binary search, where it is critical to accurately
    maintain and narrow the search boundary.</st> <st c="21594">In subsequent chapters,
    as new algorithms are introduced, we will consistently revisit the loop invariant
    to evaluate the correctness of</st> <st c="21731">each algorithm.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21746">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="21754">In this chapter, we discussed the important concepts of mathematical
    induction and loop invariants as foundational tools for verifying the correctness
    of algorithms.</st> <st c="21921">The chapter started by explaining mathematical
    induction, describing its two primary steps: the base case, which establishes
    the initial validity of the proposition, and the induction step, which demonstrates
    the proposition’s maintenance across successive iterations.</st> <st c="22190">It
    then introduces loop invariants, expanding on mathematical induction by including
    the additional step of termination to ensure that the algorithm’s properties hold
    from initiation through termination.</st> <st c="22394">Through detailed examples,
    such as a binary search algorithm, the chapter illustrates how these principles
    are applied to prove that algorithms perform correctly and efficiently, emphasizing
    their importance in developing reliable software.</st> <st c="22635">The chapter
    aimed to equip you with the methodologies to rigorously assess the integrity and
    operational correctness of</st> <st c="22755">various algorithms.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="22774">As previously mentioned, algorithm analysis involves two key
    aspects: proving the correctness of the algorithm and analyzing its complexity.</st>
    <st c="22916">The next chapter will address the second aspect, focusing on the
    complexity of algorithms and how to estimate</st> <st c="23026">this complexity.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23042">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="23073">Introduction to Algorithms</st>*<st c="23100">. By Thomas H.</st>
    <st c="23115">Cormen, Charles E.</st> <st c="23134">Leiserson, Ronald L.</st>
    <st c="23155">Rivest, and Clifford Stein.</st> <st c="23183">Fourth Edition.</st>
    <st c="23199">MIT</st> <st c="23203">Press.</st> <st c="23210">2022.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="23215">Algorithm Design</st>*<st c="23232">. By Jon Kleinberg and Éva
    Tardos.</st> <st c="23267">First Edition.</st> <st c="23282">Pearson.</st> <st
    c="23291">2005.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="23296">The Art of Computer Programming</st>*<st c="23328">, Volume
    1: Fundamental Algorithms.</st> <st c="23364">Donald E.</st> <st c="23374">Knuth.</st>
    <st c="23381">Third Edition.</st> <st c="23396">Addison-Wesley</st> <st c="23411">Professional.</st>
    <st c="23425">1997.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="23430">Algorithms Unlocked</st>*<st c="23450">. By Thomas H.</st> <st
    c="23465">Cormen.</st> <st c="23473">MIT</st> <st c="23477">Press.</st> <st c="23484">2013.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="23489">Discrete Mathematics and Its Applications</st>*<st c="23531">.
    By Kenneth H.</st> <st c="23547">Rosen.</st> <st c="23554">McGraw-Hill Science/Engineering/Math.</st>
    <st c="23592">Twelfth Edition.</st> <st c="23609">McGraw-Hill.</st> <st c="23622">2012.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="23627">Concrete Mathematics: A Foundation for Computer Science</st>*<st
    c="23683">. By Ronald L.</st> <st c="23698">Graham, Donald E.</st> <st c="23716">Knuth,
    and Oren Patashnik.</st> <st c="23743">Second Edition.</st> <st c="23759">Addison-Wesley.</st>
    <st c="23775">1994.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="23780">How to Prove It: A Structured Approach</st>*<st c="23819">.
    By Daniel J.</st> <st c="23834">Velleman.</st> <st c="23844">Third Edition.</st>
    <st c="23859">Cambridge University</st> <st c="23880">Press.</st> <st c="23887">2019.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
