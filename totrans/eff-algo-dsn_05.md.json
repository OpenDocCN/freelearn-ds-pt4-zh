["```py\n     def binary_search(a, x):\n        low = 0\n        high = len(a) - 1\n        while low <= high:\n            mid = (high + low) // 2\n            if a[mid] < x:\n                low = mid + 1\n            elif a[mid] > x:\n                high = mid - 1\n            else:\n                return mid\n        return -1 \n    print(binary_search([0,1,3,5,8,10],10))\n    ```", "```py\n     import math\n    def jump_search(a, x):\n        n = len(a)\n        step = int(math.sqrt(n))\n        prev = 0\n        while a[min(step, n)-1] < x:\n            prev = step\n            step += int(math.sqrt(n))\n            if prev >= n:\n                return -1\n        for i in range(prev, min(step, n)):\n            if a[i] == x:\n                return i\n        return -1\n    ```", "```py\n     def interpolation_search(a, x):\n        low = 0\n        high = len(a) - 1\n        while low <= high and x >= a[low] and x <= a[high]:\n            if low == high:\n                if a[low] == x:\n                    return low\n                return -1\n            pos = low + ((high - low) // (a[high] - a[low]) * (x - a[low]))\n            if a[pos] == x:\n                return pos\n            if a[pos] < x:\n                low = pos + 1\n            else:\n                high = pos - 1\n        return -1\n    ```", "```py\n def factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n```", "```py\n def factorial_recursive(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial_recursive(n - 1)\n```", "```py\n     def tower_of_hanoi(n, source, target, auxiliary):\n        if n == 1:\n            print(f\"Move disk 1 from {source} to {target}\")\n            return\n        tower_of_hanoi(n - 1, source, auxiliary, target)\n        print(f\"Move disk {n} from {source} to {target}\")\n        tower_of_hanoi(n - 1, auxiliary, target, source)\n    ```", "```py\n from itertools import permutations\ndef calculate_distance(permutation, distance_matrix):\n    distance = 0\n    for i in range(len(permutation) - 1):\n        distance += distance_matrix[permutation[i]][permutation[i + 1]]\n    distance += distance_matrix[permutation[-1]][permutation[0]]  # Return to the start\n    return distance\ndef tsp_brute_force(distance_matrix):\n    n = len(distance_matrix)\n    cities = list(range(n))\n    min_distance = float('inf')\n    best_permutation = None\n    for permutation in permutations(cities):\n        current_distance = calculate_distance(permutation, distance_matrix)\n        if current_distance < min_distance:\n            min_distance = current_distance\n            best_permutation = permutation\n    return best_permutation, min_distance\n```"]