<html><head></head><body>
		<div id="_idContainer538" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-44" class="chapter-number"><a id="_idTextAnchor051" class="pcalibre pcalibre1 calibre6"/><st c="0">4</st></h1>
			<h1 id="_idParaDest-45" class="calibre5"><a id="_idTextAnchor052" class="pcalibre pcalibre1 calibre6"/><st c="2">Recursion and Recurrence Functions</st></h1>
			<p class="calibre3"><st c="36">Estimating the complexity or running time of iterative algorithms is relatively straightforward due to their linear and predictable nature. </st><st c="177">However, recursive algorithms, which involve the function calling itself one or more times during execution, present a unique challenge in complexity estimation. </st><st c="339">These self-referential structures often lead to intricate and non-intuitive running times that cannot be easily discerned through simple observation or traditional </st><span><st c="503">iterative analysis.</st></span></p>
			<p class="calibre3"><st c="522">To address this challenge, we introduce the concept of </st><strong class="bold"><st c="578">recurrence functions</st></strong><st c="598">. Recurrence functions</st><a id="_idIndexMarker127" class="pcalibre pcalibre1 calibre6"/><st c="620"> are mathematical models that describe the running time of a recursive algorithm in terms of its input size. </st><st c="729">By expressing the running time as a function that recurs upon itself, we can systematically analyze and solve these recurrences to obtain a precise estimate of the </st><span><st c="893">algorithm’s complexity.</st></span></p>
			<p class="calibre3"><st c="916">This chapter explores the various aspects of recurrence functions, including their formulation, components, and the techniques used to solve them. </st><st c="1064">We will explore how these functions capture the essence of recursive calls and their subsequent impact on the overall computational cost of the algorithm. </st><st c="1219">Understanding recurrence functions is crucial for accurately predicting the performance of recursive algorithms and optimizing </st><span><st c="1346">their implementation.</st></span></p>
			<p class="calibre3"><st c="1367">The chapter is structured </st><span><st c="1394">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><span><st c="1405">Recursive algorithms</st></span></li>
				<li class="calibre13"><span><st c="1426">Recurrence functions</st></span></li>
				<li class="calibre13"><st c="1447">Unfolding </st><span><st c="1458">recurrence functions</st></span></li>
			</ul>
			<h1 id="_idParaDest-46" class="calibre5"><a id="_idTextAnchor053" class="pcalibre pcalibre1 calibre6"/><st c="1478">Recursive algorithms</st></h1>
			<p class="calibre3"><st c="1499">Imagine a traditional Matryoshka doll, commonly found in Russia. </st><st c="1565">When you open the outermost doll, you find a smaller doll inside. </st><st c="1631">Opening this smaller doll reveals an even smaller one within, and this process continues until you reach the smallest, indivisible doll at the core. </st><st c="1780">This fascinating nested structure is a perfect analogy for understanding recursion </st><span><st c="1863">in algorithms.</st></span></p>
			<p class="calibre3"><st c="1877">Just like the Matryoshka doll, a </st><strong class="bold"><st c="1911">recursive algorithm</st></strong><st c="1930"> solves </st><a id="_idIndexMarker128" class="pcalibre pcalibre1 calibre6"/><st c="1938">a problem by breaking it down into smaller instances of the same problem. </st><st c="2012">Each instance is simpler than the last, until a base case is reached, which can be solved directly without further recursion. </st><st c="2138">This self-referential approach is a fundamental concept in computer science and is used to solve complex problems in a straightforward and </st><span><st c="2277">elegant manner.</st></span></p>
			<p class="calibre3"><st c="2292">In this section, we will explore the principles of recursive algorithms, starting with their basic definition and properties. </st><st c="2419">We will examine how recursion works, its advantages and potential pitfalls, and the types of problems for which it is particularly well suited. </st><st c="2563">By understanding the core concepts of recursion, you will be able to design and implement recursive solutions effectively, leveraging their power to simplify and solve </st><span><st c="2731">intricate problems.</st></span></p>
			<h2 id="_idParaDest-47" class="calibre5"><a id="_idTextAnchor054" class="pcalibre pcalibre1 calibre6"/><st c="2750">The basics of recursion</st></h2>
			<p class="calibre3"><st c="2774">The evolution of computer science has</st><a id="_idIndexMarker129" class="pcalibre pcalibre1 calibre6"/><st c="2812"> been marked by a profound understanding of how to model intelligence and problem-solving through computation. </st><st c="2923">At its core, computation involves breaking down complex tasks into simpler, repeatable steps. </st><st c="3017">This foundational concept has given rise to the technology that powers our </st><span><st c="3092">modern computers.</st></span></p>
			<p class="calibre3"><st c="3109">One fundamental way to implement repetition in computing is</st><a id="_idIndexMarker130" class="pcalibre pcalibre1 calibre6"/><st c="3169"> through </st><strong class="bold"><st c="3178">loops</st></strong><st c="3183"> or iterative processes. </st><strong class="bold"><st c="3208">Loops</st></strong><st c="3213"> are constructs that repeat a block of instructions a number of times or until a specific condition is met. </st><st c="3321">They are straightforward to understand, their complexity is easy to estimate, and they are relatively simple to debug. </st><st c="3440">However, while loops are efficient for many tasks, they can sometimes be computationally expensive and less intuitive for certain types </st><span><st c="3576">of problems.</st></span></p>
			<p class="calibre3"><st c="3588">An alternative approach to managing repetition is through </st><strong class="bold"><st c="3647">recursion</st></strong><st c="3656">. Unlike loops, which iterate over a sequence of steps, </st><strong class="bold"><st c="3712">recursion</st></strong><st c="3721"> is a function calling itself to solve smaller instances of the original problem which is called a subproblem. </st><st c="3832">This method is rooted in</st><a id="_idIndexMarker131" class="pcalibre pcalibre1 calibre6"/><st c="3856"> the </st><strong class="bold"><st c="3861">divide and conquer</st></strong><st c="3879"> strategy, where a problem is divided into smaller subproblems, each of which is solved recursively until a base case is reached. </st><st c="4009">This approach can often lead to more elegant and simpler solutions, especially for problems that naturally fit a </st><span><st c="4122">recursive structure.</st></span></p>
			<p class="calibre3"><st c="4142">The following two </st><a id="_idIndexMarker132" class="pcalibre pcalibre1 calibre6"/><st c="4161">Python code examples demonstrate how to implement the factorial(n) algorithm using two different methods: the iterative approach (using loops) and the </st><span><st c="4312">recursive approach:</st></span></p>
			<pre class="source-code"><st c="4331" class="calibre11">
def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result</st></pre>			<p class="calibre3"><st c="4422">In the iterative implementation, the repetition is linear and straightforward. </st><st c="4502">One advantage of iterative, non-recursive implementations is that their complexity and running time are easy to estimate. </st><st c="4624">In the preceding function, the running time depends on the number of times the </st><strong class="source-inline"><st c="4703">for i in range(1, n + 1):</st></strong><st c="4728"> loop is executed. </st><st c="4747">Given the loop’s range, it is clear that the time complexity is </st><img src="image/430.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre350"/><st c="4811"/><st c="4818">, which simplifies </st><span><st c="4837">to </st></span><span><img src="image/49.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre351"/><st c="4840"/></span><span><st c="4857">.</st></span></p>
			<p class="calibre3"><st c="4858">Now, let’s have a look at the recursive implementation </st><span><st c="4914">of Factorial(n):</st></span></p>
			<pre class="source-code"><st c="4930" class="calibre11">
def factorial_recursive(n):
    # Base case
    if n == 0:
        return 1
    # Recursive case
    else:
        return n * factorial_recursive(n - 1)</st></pre>			<p class="calibre3"><st c="5051">In the recursive implementation, the first noticeable difference is the absence of loops. </st><st c="5142">Instead, repetition is achieved through nested self-calls of the function. </st><st c="5217">This makes tracking the flow of a recursive algorithm more complex. </st><st c="5285">Additionally, estimating the running time of a recursive algorithm is not as straightforward as it is for </st><span><st c="5391">non-recursive algorithms.</st></span></p>
			<p class="calibre3"><st c="5416">To estimate the running time, we need to model the recursion process using a computational function called a recurrence function, which will be discussed in detail in the next section. </st><st c="5602">For the recursive Factorial(n) function, the recurrence function is </st><img src="image/432.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre352"/><st c="5670"/><st c="5681">, where </st><img src="image/433.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre353"/><st c="5689"/><st c="5690"> represents the running time for computing the factorial of </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="5750"/><st c="5799">, and </st><img src="image/233.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre217"/><st c="5805"/><st c="5806"> is a constant representing the time for the non-recursive operations. </st><st c="5877">In the next chapter, we will see that solving this recurrence function shows that the computational complexity of the recursive Factorial(n) is </st><img src="image/436.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre354"/><st c="6021"/><st c="6030">, which is no better than the </st><span><st c="6060">iterative implementation.</st></span></p>
			<p class="calibre3"><st c="6085">From the recursive</st><a id="_idIndexMarker133" class="pcalibre pcalibre1 calibre6"/><st c="6104"> algorithm of Factorial(n), we can identify three components that are common in all </st><span><st c="6188">recursive algorithms:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="6209">Recursive calls</st></strong><st c="6225">: A </st><a id="_idIndexMarker134" class="pcalibre pcalibre1 calibre6"/><st c="6230">function that calls itself within its definition, such as </st><strong class="source-inline1"><st c="6288">factorial_recursive(n - 1)</st></strong><st c="6314">. Each call works on a smaller or simpler version of the </st><span><st c="6371">original problem.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="6388">Base case</st></strong><st c="6398">: The</st><a id="_idIndexMarker135" class="pcalibre pcalibre1 calibre6"/><st c="6404"> condition under which the recursive calls stop. </st><st c="6453">It prevents infinite recursion and provides a straightforward solution to the simplest version of the problem. </st><st c="6564">In the recursive factorial, this component is </st><span><st c="6610">as follows:</st></span><pre class="source-code"><st c="6621" class="calibre11">
if n == 0:
return 1</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="6641">Recursive case</st></strong><st c="6656">: The part </st><a id="_idIndexMarker136" class="pcalibre pcalibre1 calibre6"/><st c="6668">of the function where the recursion occurs. </st><st c="6712">It breaks the problem into smaller subproblems and calls the function itself to solve these subproblems. </st><st c="6817">In the recursive factorial, this component is </st><strong class="source-inline1"><st c="6863">return n * factorial_recursive(n - </st></strong><span><strong class="source-inline1"><st c="6898">1)</st></strong></span><span><st c="6900">.</st></span></li>
			</ul>
			<p class="calibre3"><st c="6901">Unlike </st><strong class="source-inline"><st c="6909">factorial_recursive(n)</st></strong><st c="6931">, the recursive implementation can often offer better running time than the non-recursive one. </st><st c="7026">Let’s consider the following example of calculating the power of a number using a recursive approach that leverages this technique to achieve </st><span><st c="7168">improved efficiency:</st></span></p>
			<pre class="source-code"><st c="7188" class="calibre11">
def power_recursive(base, exponent):
    # Base case
    if exponent == 0:
        return 1
    # Recursive case
    elif exponent % 2 == 0:
        half_power = power_recursive(base, exponent // 2)
        return half_power * half_power
    else:
        return base * power_recursive(base, exponent - 1)</st></pre>			<p class="calibre3"><st c="7442">Let’s explain </st><span><st c="7457">the code:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="source-inline1"><st c="7466">Base case</st></strong><st c="7476">: If the</st><a id="_idIndexMarker137" class="pcalibre pcalibre1 calibre6"/><st c="7485"> exponent is </st><strong class="source-inline1"><st c="7498">0</st></strong><st c="7499">, the result is </st><strong class="source-inline1"><st c="7515">1</st></strong><st c="7516">, since any number raised to the power of 0 </st><span><st c="7560">is 1.</st></span></li>
				<li class="calibre13"><strong class="source-inline1"><st c="7565">Recursive case</st></strong><st c="7580">: If the exponent is even, the problem is divided into two smaller subproblems by halving the exponent. </st><st c="7685">We recursively calculate </st><strong class="source-inline1"><st c="7710">half_power</st></strong><st c="7720"> for </st><strong class="source-inline1"><st c="7725">base</st></strong><st c="7729"> raised to the power of half the exponent and then square </st><span><st c="7787">the result.</st></span><p class="calibre3"><st c="7798">If the exponent is odd, the problem is reduced to an even exponent by subtracting 1 from the exponent, resulting in an additional multiplication by </st><strong class="source-inline"><st c="7947">base</st></strong><st c="7951"> after the </st><span><st c="7962">recursive call.</st></span></p></li>
				<li class="calibre13"><strong class="source-inline1"><st c="7977">Recursive call</st></strong><st c="7992">: The function calls itself recursively in </st><strong class="source-inline1"><st c="8036">recursive(base, exponent // 2)  </st></strong><st c="8067">and  </st><strong class="source-inline1"><st c="8071">power_recursive(base, exponent - </st></strong><span><strong class="source-inline1"><st c="8104">1)</st></strong></span><span><st c="8106">.</st></span></li>
			</ul>
			<p class="calibre3"><st c="8107">This method ensures that the number of recursive calls grows logarithmically with respect to the exponent, achieving a time complexity of </st><img src="image/437.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre355"/><st c="8246"/><st c="8255">. This is a significant improvement over the iterative approach, which has a linear time complexity </st><span><st c="8355">of </st></span><span><img src="image/203.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre183"/><st c="8358"/></span><span><st c="8359">.</st></span></p>
			<h2 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor055" class="pcalibre pcalibre1 calibre6"/><st c="8360">Types of recursion</st></h2>
			<p class="calibre3"><strong class="bold"><st c="8379">Recursion</st></strong><st c="8389"> can be </st><a id="_idIndexMarker138" class="pcalibre pcalibre1 calibre6"/><st c="8397">broadly classified into two types: direct recursion and indirect recursion. </st><st c="8473">Understanding these types helps in identifying the nature of recursive calls and their potential impacts on performance </st><span><st c="8593">and complexity.</st></span></p>
			<h3 class="calibre8"><st c="8608">Direct recursion</st></h3>
			<p class="calibre3"><strong class="bold"><st c="8625">Direct recursion</st></strong><st c="8642"> occurs</st><a id="_idIndexMarker139" class="pcalibre pcalibre1 calibre6"/><st c="8649"> when a function calls itself directly. </st><st c="8689">This is the most common </st><a id="_idIndexMarker140" class="pcalibre pcalibre1 calibre6"/><st c="8713">form of recursion, where the function is self-referential. </st><st c="8772">All examples of recursive algorithms so far in this book have been direct recursive types. </st><st c="8863">Some </st><a id="_idIndexMarker141" class="pcalibre pcalibre1 calibre6"/><st c="8868">major use cases of direct recursion are </st><span><st c="8908">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="8919">Simplifies problems that can naturally be divided into </st><span><st c="8975">identical subproblems</st></span></li>
				<li class="calibre13"><st c="8996">Easier to understand and debug compared to </st><span><st c="9040">indirect recursion</st></span></li>
				<li class="calibre13"><st c="9058">Commonly </st><a id="_idIndexMarker142" class="pcalibre pcalibre1 calibre6"/><st c="9068">used </st><a id="_idIndexMarker143" class="pcalibre pcalibre1 calibre6"/><st c="9073">in </st><a id="_idIndexMarker144" class="pcalibre pcalibre1 calibre6"/><st c="9076">problems such as </st><strong class="bold"><st c="9093">factorial calculation</st></strong><st c="9114">, </st><strong class="bold"><st c="9116">Fibonacci series</st></strong><st c="9132">, and </st><span><strong class="bold"><st c="9138">tree traversals</st></strong></span></li>
			</ul>
			<p class="calibre3"><st c="9153">There are several types of direct recursion, each suited to different kinds of problems and algorithmic strategies. </st><st c="9270">Here are the main types of </st><span><st c="9297">direct recursion:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="9314">Tail recursion</st></strong><st c="9329">: This is a special case of </st><a id="_idIndexMarker145" class="pcalibre pcalibre1 calibre6"/><st c="9358">recursion where the recursive call is the very </st><a id="_idIndexMarker146" class="pcalibre pcalibre1 calibre6"/><st c="9405">last action a function takes before returning. </st><st c="9452">This means no further operations are performed on the result of the recursive call. </st><st c="9536">The advantage of tail recursion is that it can often be optimized by compilers to avoid stack overflow. </st><st c="9640">Instead of creating a new stack frame for each recursive call, the compiler can reuse the existing frame, effectively turning the recursion into a loop. </st><st c="9793">An illustrative example is the </st><strong class="source-inline1"><st c="9824">factorial_tail</st></strong><st c="9838"> function, which calculates the factorial of a number by directly calling itself as its </st><span><st c="9926">final step:</st></span><pre class="source-code"><st c="9937" class="calibre11">
def factorial_tail(n, accumulator=1):
    if n == 0:
        return accumulator
    else:
        return factorial_tail(n - 1, n * accumulator)</st></pre><p class="calibre3"><st c="10057">One application of</st><a id="_idIndexMarker147" class="pcalibre pcalibre1 calibre6"/><st c="10076"> tail recursion is in managing linked lists. </st><st c="10121">Although </st><a id="_idIndexMarker148" class="pcalibre pcalibre1 calibre6"/><st c="10130">readers may already be familiar with linked list data structures, we will explore them in detail in </st><a href="B22248_12.xhtml#_idTextAnchor187" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="10230">Chapter 12</st></em></span></a><st c="10240">. In brief, linked lists are a fundamental data structure made up of nodes, where each node contains a value and a reference (or link) to the next node in the sequence. </st><st c="10409">The inherent recursive structure of linked lists – where each node can be viewed as a smaller version of the entire list – makes recursion an ideal approach for performing operations such as traversal, insertion, </st><span><st c="10622">and deletion.</st></span></p><p class="calibre3"><st c="10635">Here is one example of using tail recursion in the recursive traversal of a linked list. </st><st c="10725">Traversing a linked list is typically done recursively by processing the current node and then moving to the next node through a recursive call. </st><st c="10870">In a tail-recursive approach, this call to process the next node is the final operation in the function. </st><st c="10975">Here is a simple piece of </st><span><st c="11001">Python code:</st></span></p><pre class="source-code"><st c="11013" class="calibre11">def traverse_linked_list(node):
    if node is None:
        return
    print(node.value)
    traverse_linked_list(node.next)</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="11119">Head recursion</st></strong><st c="11134">: This is characterized </st><a id="_idIndexMarker149" class="pcalibre pcalibre1 calibre6"/><st c="11159">by a function’s initial action being a </st><a id="_idIndexMarker150" class="pcalibre pcalibre1 calibre6"/><st c="11198">recursive call to itself. </st><st c="11224">This means all other operations within the function are postponed until after this recursive call completes. </st><st c="11333">While less prevalent than tail recursion, head recursion does have its uses. </st><st c="11410">However, it is generally considered less efficient due to the need to maintain a stack of pending operations until the recursive calls unwind. </st><st c="11553">The following </st><strong class="source-inline1"><st c="11567">head_recursive</st></strong><st c="11581"> is an example of this type of </st><span><st c="11612">recursive function:</st></span><pre class="source-code"><st c="11631" class="calibre11">
def head_recursive(n):
    if n == 0:
        return
    else:
        head_recursive(n - 1)
        print(n)</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="11709">Linear recursion</st></strong><st c="11726">: In this type of</st><a id="_idIndexMarker151" class="pcalibre pcalibre1 calibre6"/><st c="11744"> recursion, a function makes at most one recursive call</st><a id="_idIndexMarker152" class="pcalibre pcalibre1 calibre6"/><st c="11799"> during each invocation. </st><st c="11824">This leads to a simple chain of recursive calls, resembling a straight line. </st><st c="11901">The following is a simple example of </st><span><st c="11938">linear recursion:</st></span><pre class="source-code"><st c="11955" class="calibre11">
def linear_recursive(n):
    if n == 0:
        return 0
    else:
        return n + linear_recursive(n - 1)</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="12041">Tree recursion</st></strong><st c="12056">: Unlike</st><a id="_idIndexMarker153" class="pcalibre pcalibre1 calibre6"/><st c="12065"> linear recursion, in tree recursion, a function calls </st><a id="_idIndexMarker154" class="pcalibre pcalibre1 calibre6"/><st c="12120">itself multiple times within a single activation. </st><st c="12170">This results in a branching structure of recursive calls, resembling a tree. </st><st c="12247">Examples include the Fibonacci sequence calculation, tree traversals, and the quick </st><span><st c="12331">sort algorithm:</st></span><pre class="source-code"><st c="12346" class="calibre11">
def fun(n):
    if (n &gt; 0):
        print(n, end=" ")
        fun(n - 1)
        fun(n - 1)</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="12410">Binary recursion</st></strong><st c="12427">: This is a </st><a id="_idIndexMarker155" class="pcalibre pcalibre1 calibre6"/><st c="12440">pattern where a function makes two recursive calls to</st><a id="_idIndexMarker156" class="pcalibre pcalibre1 calibre6"/><st c="12493"> itself within a single invocation. </st><st c="12529">This approach is frequently employed in divide-and-conquer algorithms, which break down a problem into two smaller subproblems that are solved recursively. </st><st c="12685">The solutions to these subproblems are then combined to obtain the </st><a id="_idIndexMarker157" class="pcalibre pcalibre1 calibre6"/><st c="12752">solution to the </st><span><st c="12768">original </st></span><span><a id="_idIndexMarker158" class="pcalibre pcalibre1 calibre6"/></span><span><st c="12777">problem:</st></span><pre class="source-code"><st c="12785" class="calibre11">
def fibonacci_binary_recursive(n):
    if n &lt;= 1:
        return n
    else:
        return fibonacci_binary_recursive(n - 1) +        fibonacci_binary_recursive(n - 2)</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="12923">Multiple recursion</st></strong><st c="12942">: This is a type of</st><a id="_idIndexMarker159" class="pcalibre pcalibre1 calibre6"/><st c="12962"> recursion where a function makes </st><a id="_idIndexMarker160" class="pcalibre pcalibre1 calibre6"/><st c="12996">more than two recursive calls to itself within a single invocation. </st><st c="13064">This pattern is less common than linear or binary recursion but can be useful for problems that inherently decompose into more than two subproblems. </st><st c="13213">Each of these subproblems is then solved recursively, and their solutions are combined to obtain the final result. </st><st c="13328">A simple multiple recursion has been implemented in the next </st><span><st c="13389">example (</st></span><span><strong class="source-inline1"><st c="13398">multiple_recursive</st></strong></span><span><st c="13417">):</st></span><pre class="source-code"><st c="13420" class="calibre11">
def multiple_recursive(n):
    if n &lt;= 1:
        return 1
    else:
        return multiple_recursive(n - 1) + multiple_recursive(n - 2) + multiple_recursive(n - 3)</st></pre><p class="calibre3"><st c="13562">A more sophisticated example is </st><span><st c="13595">as follows:</st></span></p><pre class="source-code"><st c="13606" class="calibre11">def ternary_search(arr, target, start, end):
    if start &gt; end:
        return -1  # Target not found
    else:
        mid1 = start + (end - start) // 3
        mid2 = start + 2 * (end - start) // 3
        if arr[mid1] == target:
            return mid1
        elif arr[mid2] == target:
            return mid2
        elif arr[mid1] &gt; target:
            return ternary_search(arr, target, start, mid1 - 1)  # First recursive call
        elif arr[mid2] &lt; target:
            return ternary_search(arr, target, mid2 + 1, end)  # Second recursive call
        else:
            return ternary_search(arr, target, mid1 + 1, mid2 - 1)  # Third recursive call</st></pre><p class="calibre3"><st c="14131">In this example, the </st><strong class="source-inline"><st c="14153">ternary_search</st></strong><st c="14167"> function performs a ternary search on a sorted array. </st><st c="14222">It divides the array into three roughly equal parts and makes three recursive calls to </st><a id="_idIndexMarker161" class="pcalibre pcalibre1 calibre6"/><st c="14309">search each part, illustrating the concept of a </st><a id="_idIndexMarker162" class="pcalibre pcalibre1 calibre6"/><span><st c="14357">multiple recursion.</st></span></p></li>				<li class="calibre13"><strong class="bold"><st c="14376">Nested recursion</st></strong><st c="14393">: This</st><a id="_idIndexMarker163" class="pcalibre pcalibre1 calibre6"/><st c="14400"> is a more intricate form of recursion where a function’s </st><a id="_idIndexMarker164" class="pcalibre pcalibre1 calibre6"/><st c="14458">recursive call doesn’t simply pass a modified argument, but includes another recursive call as part of the argument itself. </st><st c="14582">This means the depth of recursion can increase rapidly, making it a less common and more complex type of recursion to analyze </st><span><st c="14708">and understand:</st></span><pre class="source-code"><st c="14723" class="calibre11">
def nested_recursive(n):
    if n &gt; 100:
        return n - 10
    else:
        return nested_recursive_function(nested_recursive(n + 11))</st></pre></li>			</ul>
			<h3 class="calibre8"><st c="14839">Indirect recursion</st></h3>
			<p class="calibre3"><strong class="bold"><st c="14858">Indirect recursion</st></strong><st c="14877"> occurs when</st><a id="_idIndexMarker165" class="pcalibre pcalibre1 calibre6"/><st c="14889"> a function, let’s say function A, calls another </st><a id="_idIndexMarker166" class="pcalibre pcalibre1 calibre6"/><st c="14938">function, function B, and then function B (or a sequence of other functions) eventually calls function A again. </st><st c="15050">This creates a cycle or chain of function calls where the original function is indirectly invoked through other functions. </st><st c="15173">In the following example, </st><strong class="source-inline"><st c="15199">functionA</st></strong><st c="15208"> calls </st><strong class="source-inline"><st c="15215">functionB</st></strong><st c="15224">, and </st><strong class="source-inline"><st c="15230">functionB</st></strong><st c="15239"> calls </st><strong class="source-inline"><st c="15246">functionA</st></strong><st c="15255">, forming an </st><span><st c="15268">indirect recursion:</st></span></p>
			<pre class="source-code"><st c="15287" class="calibre11">
def functionA(n):
    if n &lt;= 0:
        return "End"
    else:
        return functionB(n - 1)
def functionB(n):
    if n &lt;= 0:
        return "End"
    else:
        return functionA(n - 2)</st></pre>			<p class="calibre3"><st c="15431">In the example of indirect recursion, </st><strong class="source-inline"><st c="15470">functionA</st></strong><st c="15479"> calls </st><strong class="source-inline"><st c="15486">functionB</st></strong><st c="15495">, which then calls </st><strong class="source-inline"><st c="15514">functionA</st></strong><st c="15523"> again. </st><st c="15531">This cycle continues until the base condition in either function is met (</st><strong class="source-inline"><st c="15604">n &lt;= 0</st></strong><st c="15611">), terminating the recursion. </st><st c="15642">This form of recursion can involve more than two functions, creating a complex chain </st><span><st c="15727">of calls.</st></span></p>
			<p class="calibre3"><st c="15736">Some major use cases of indirect recursion are </st><span><st c="15784">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="15795">Useful for </st><a id="_idIndexMarker167" class="pcalibre pcalibre1 calibre6"/><st c="15807">problems that require multiple stages of transformation </st><span><st c="15863">or processing</st></span></li>
				<li class="calibre13"><st c="15876">Can be more difficult to trace and debug due to the involvement of </st><span><st c="15944">multiple functions</st></span></li>
				<li class="calibre13"><st c="15962">Commonly</st><a id="_idIndexMarker168" class="pcalibre pcalibre1 calibre6"/><st c="15971"> seen in mutually recursive algorithms</st><a id="_idIndexMarker169" class="pcalibre pcalibre1 calibre6"/><st c="16009"> and certain </st><span><st c="16022">state machines</st></span></li>
			</ul>
			<p class="calibre3"><st c="16036">Understanding the differences between direct and indirect recursion allows for better selection of the appropriate recursive approach for a given problem. </st><st c="16192">Direct recursion is straightforward and widely used, while indirect recursion, though more complex, can be powerful in specific scenarios requiring interdependent </st><span><st c="16355">function calls.</st></span></p>
			<h3 class="calibre8"><st c="16370">Recursive problem-solving</st></h3>
			<p class="calibre3"><strong class="bold"><st c="16396">Recursive problem-solving</st></strong><st c="16422"> often</st><a id="_idIndexMarker170" class="pcalibre pcalibre1 calibre6"/><st c="16428"> employs the </st><em class="italic"><st c="16441">divide, conquer, and combine</st></em><st c="16469"> strategy. </st><st c="16480">This framework is highly effective for breaking down complex problems into simpler subproblems, solving these subproblems independently, and then combining their results to form the final solution. </st><st c="16678">Let’s explore this framework </st><span><st c="16707">in detail:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="16717">Divide</st></strong><st c="16724">: In the</st><a id="_idIndexMarker171" class="pcalibre pcalibre1 calibre6"/><st c="16733"> divide step, the problem is broken down into smaller subproblems that are easier to solve. </st><st c="16825">This step involves identifying how to partition the original problem into smaller parts. </st><st c="16914">The key is to ensure that the subproblems are of the same nature as the original problem, but simpler or smaller </st><span><st c="17027">in size.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="17035">Conquer</st></strong><st c="17043">: In the </st><a id="_idIndexMarker172" class="pcalibre pcalibre1 calibre6"/><st c="17053">conquer step, the subproblems are solved recursively. </st><st c="17107">If the subproblems are still too large, they are further divided using the same divide, conquer, and combine approach. </st><st c="17226">This process continues until the subproblems reach a base case, which can be solved directly without </st><span><st c="17327">further recursion.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="17345">Combine</st></strong><st c="17353">: In the</st><a id="_idIndexMarker173" class="pcalibre pcalibre1 calibre6"/><st c="17362"> combine step, the solutions to the subproblems are merged to form the solution to the original problem. </st><st c="17467">This step involves integrating the results of the recursive calls to obtain the </st><span><st c="17547">final answer.</st></span></li>
			</ul>
			<p class="calibre3"><st c="17560">It is worth mentioning that the key element in this framework is to identify the </st><em class="italic"><st c="17642">subproblem</st></em><st c="17652">. A </st><strong class="bold"><st c="17656">subproblem</st></strong><st c="17666"> is </st><a id="_idIndexMarker174" class="pcalibre pcalibre1 calibre6"/><st c="17670">similar to the main problem but smaller in size. </st><st c="17719">Essentially, a subproblem is a smaller instance of the </st><span><st c="17774">original problem.</st></span></p>
			<p class="calibre3"><st c="17791">This framework will be explored in detail in upcoming chapters, especially in sorting algorithms such as merge sort. </st><st c="17909">To give the reader a taste of this framework, consider the following merge sort algorithm, which will be discussed in </st><a href="B22248_06.xhtml#_idTextAnchor081" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="18027">Chapter 6</st></em></span></a><span><st c="18036">:</st></span></p>
			<pre class="source-code"><st c="18038" class="calibre11">
def merge_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    sorted_left = merge_sort(left_half)
    sorted_right = merge_sort(right_half)
    return merge(sorted_left, sorted_right)
def merge(left, right):
    sorted_array = []
    i = j = 0
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt; right[j]:
            sorted_array.append(left[i])
            i += 1
        else:
            sorted_array.append(right[j])
            j += 1
    # Append any remaining elements
    sorted_array.extend(left[i:])
    sorted_array.extend(right[j:])
    return sorted_array</st></pre>			<p class="calibre3"><st c="18574">Let’s briefly explain the divide, conquer, and </st><a id="_idIndexMarker175" class="pcalibre pcalibre1 calibre6"/><st c="18622">combine framework in the merge </st><span><st c="18653">sort algorithm:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="18668">Divide</st></strong><st c="18675">: The </st><strong class="source-inline1"><st c="18682">merge_sort</st></strong><st c="18692"> function splits the array into two halves, </st><strong class="source-inline1"><st c="18736">left_half</st></strong><st c="18745"> and </st><strong class="source-inline1"><st c="18750">right_half</st></strong><st c="18760">. This is done using the midpoint of </st><span><st c="18797">the array.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="18807">Conquer</st></strong><st c="18815">: The </st><strong class="source-inline1"><st c="18822">merge_sort</st></strong><st c="18832"> function is called recursively on both halves. </st><st c="18880">Each recursive call further divides the halves until the base case is reached, where the array length is </st><strong class="source-inline1"><st c="18985">0</st></strong><st c="18986"> or </st><strong class="source-inline1"><st c="18990">1</st></strong><st c="18991"> (</st><span><st c="18993">already sorted).</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="19009">Combine</st></strong><st c="19017">: The </st><strong class="source-inline1"><st c="19024">merge</st></strong><st c="19029"> function is used to merge the sorted halves. </st><st c="19075">It iterates through both halves, comparing elements and appending the smaller element to the sorted array. </st><st c="19182">Any remaining elements from either half are </st><span><st c="19226">then appended.</st></span></li>
			</ul>
			<p class="calibre3"><st c="19240">In the upcoming chapters, we will illustrate how identifying these three components is crucial for the design and analysis of </st><span><st c="19367">recursive algorithms.</st></span></p>
			<h3 class="calibre8"><st c="19388">Advantages and challenges of recursion</st></h3>
			<p class="calibre3"><st c="19427">Recursion is a fundamental concept in computer science and algorithm design. </st><st c="19505">While it offers several advantages, it also comes with its own set of challenges. </st><st c="19587">Understanding both can help you decide when and how to use </st><span><st c="19646">recursion effectively.</st></span></p>
			<p class="calibre3"><st c="19668">The following are three major advantages</st><a id="_idIndexMarker176" class="pcalibre pcalibre1 calibre6"/><st c="19709"> of </st><span><st c="19713">recursive solutions:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="19733">Simplicity and clarity</st></strong><st c="19756">: Recursion often provides a more straightforward and intuitive solution for problems that have a repetitive or self-similar structure, such as tree traversals, factorial calculations, and the Fibonacci sequence. </st><st c="19970">Recursive solutions can be also more concise and easier to read compared to iterative solutions. </st><st c="20067">This can make the code more maintainable and easier </st><span><st c="20119">to understand.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="20133">Reduction of complex problems</st></strong><st c="20163">: Recursion simplifies the process of breaking down complex problems into simpler subproblems. </st><st c="20259">This is particularly useful in divide-and-conquer algorithms, such as merge sort and quicksort. </st><st c="20355">Recursive functions can also lead to elegant and clean code, especially when the problem is naturally recursive, such as in dynamic programming and </st><span><st c="20503">combinatorial problems.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="20526">Implicit state management</st></strong><st c="20552">: Recursive calls inherently manage states through the call stack, eliminating the need for explicit state management in many cases. </st><st c="20686">This can simplify the logic and reduce the chance of errors related to </st><span><st c="20757">state </st></span><span><a id="_idIndexMarker177" class="pcalibre pcalibre1 calibre6"/></span><span><st c="20763">handling.</st></span></li>
			</ul>
			<p class="calibre3"><st c="20772">On the other side, recursive algorithms come with some challenges. </st><st c="20840">The following are some major challenges </st><span><st c="20880">and disadvantages:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="20898">Performance concerns</st></strong><st c="20919">: Each </st><a id="_idIndexMarker178" class="pcalibre pcalibre1 calibre6"/><st c="20927">recursive call adds a new frame to the call stack, which can result in significant overhead compared to iterative solutions, especially for deep recursion. </st><st c="21083">Deep or unbounded recursion can lead to stack overflow errors if the recursion depth exceeds the maximum stack size. </st><st c="21200">This is a common issue in languages with limited </st><span><st c="21249">stack memory.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="21262">Complexity in debugging</st></strong><st c="21286">: Debugging recursive functions can be challenging because it involves tracing multiple layers of function calls. </st><st c="21401">Understanding the flow of execution and the state at each level of recursion can be difficult. </st><st c="21496">Incorrectly defined base cases can also lead to infinite recursion or incorrect results. </st><st c="21585">Ensuring that all base cases are correctly handled is crucial for the correctness of </st><span><st c="21670">the algorithm.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="21684">Space complexity</st></strong><st c="21701">: Recursive algorithms can have high space complexity due to the additional memory required for the call stack. </st><st c="21814">This can be problematic for problems with large input sizes or deep recursion. </st><st c="21893">Recursive functions often require additional memory for each recursive call, which can lead to increased auxiliary space usage compared to their </st><span><st c="22038">iterative</st></span><span><a id="_idIndexMarker179" class="pcalibre pcalibre1 calibre6"/></span><span><st c="22047"> counterparts.</st></span></li>
			</ul>
			<p class="calibre3"><st c="22061">In addition, when designing a recursive algorithm, we need to pay attention to the following practical issues. </st><st c="22173">Some of them will be discussed in detail in </st><span><st c="22217">upcoming chapters:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="22235">Tail recursion</st></strong><st c="22250">: Some</st><a id="_idIndexMarker180" class="pcalibre pcalibre1 calibre6"/><st c="22257"> languages and compilers optimize tail-recursive functions to iterative ones, reducing the call stack overhead. </st><st c="22369">When possible, design recursive functions to </st><span><st c="22414">be tail-recursive.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="22432">Memoization</st></strong><st c="22444">: Use memoization</st><a id="_idIndexMarker181" class="pcalibre pcalibre1 calibre6"/><st c="22462"> to store the results of expensive recursive calls and avoid redundant computations. </st><st c="22547">This technique is especially useful in dynamic programming. </st><st c="22607">For more information, see </st><a href="B22248_10.xhtml#_idTextAnchor149" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="22633">Chapter 10</st></em></span></a><span><st c="22643">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="22644">Iterative alternatives</st></strong><st c="22667">: Consider </st><a id="_idIndexMarker182" class="pcalibre pcalibre1 calibre6"/><st c="22679">iterative solutions when recursion leads to performance or memory issues. </st><st c="22753">Iterative algorithms can often achieve the same results </st><span><st c="22809">more efficiently.</st></span></li>
			</ul>
			<p class="calibre3"><st c="22826">In this section, the concept of recursion</st><a id="_idIndexMarker183" class="pcalibre pcalibre1 calibre6"/><st c="22868"> was introduced, highlighting its importance in computer science and algorithm design. </st><st c="22955">Recursion, a method where a function calls itself to solve smaller instances of the same problem, was explained with examples such as factorial calculations and the Fibonacci sequence. </st><st c="23140">The section emphasized the divide, conquer, and combine framework, illustrating how problems are broken down into simpler subproblems, solved independently, and then combined to form the final solution, with merge sort as a </st><span><st c="23364">key example.</st></span></p>
			<p class="calibre3"><st c="23376">Various types of recursion, including direct and indirect recursion, were examined, along with their respective examples. </st><st c="23499">The advantages of recursion, such as simplicity, clarity, and effective problem decomposition, were discussed, alongside its challenges, such as function call overhead, potential stack overflow, and debugging complexity. </st><st c="23720">Practical considerations, including tail recursion, memoization, and iterative alternatives, were provided to optimize </st><span><st c="23839">recursive functions.</st></span></p>
			<p class="calibre3"><st c="23859">In conclusion, this section offered a comprehensive overview of recursion, detailing its principles, advantages, and challenges. </st><st c="23989">It laid a strong foundation for understanding and applying recursive problem-solving techniques in algorithm design. </st><st c="24106">The next section will discuss running time models for recursive algorithms, called </st><strong class="bold"><st c="24189">recurrence functions</st></strong><st c="24209">, essential for </st><span><st c="24225">complexity</st></span><span><a id="_idIndexMarker184" class="pcalibre pcalibre1 calibre6"/></span><span><st c="24235"> analysis.</st></span></p>
			<h1 id="_idParaDest-49" class="calibre5"><a id="_idTextAnchor056" class="pcalibre pcalibre1 calibre6"/><st c="24245">Recurrence functions</st></h1>
			<p class="calibre3"><st c="24266">The function representing </st><a id="_idIndexMarker185" class="pcalibre pcalibre1 calibre6"/><st c="24293">the running time of an incremental (non-recursive) algorithm can be determined straightforwardly due to the linear, sequential nature of these algorithms. </st><st c="24448">For example, consider the incremental implementation of the factorial of </st><img src="image/439.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre356"/><st c="24521"/><st c="24522">. </st><em class="italic"><st c="24524">Table 4.1</st></em><st c="24533"> illustrates the algorithm along with the associated computational cost in the </st><span><st c="24612">second column.</st></span></p>
			<p class="calibre3"><st c="24626">The function describing the running time of recursive algorithms is not as straightforward as it is for incremental algorithms. </st><st c="24755">To analyze the running time of recursive algorithms, we use </st><strong class="bold"><st c="24815">recurrence functions</st></strong><st c="24835"> or </st><strong class="bold"><st c="24839">recurrence relations</st></strong><st c="24859">. These concepts are adapted </st><span><st c="24888">from</st></span><span><a id="_idIndexMarker186" class="pcalibre pcalibre1 calibre6"/></span><span><st c="24892"> mathematics.</st></span></p>
			<p class="calibre3"><st c="24905">In mathematics, a </st><strong class="bold"><st c="24924">recurrence function</st></strong><st c="24943"> is an equation that defines the </st><em class="italic"><st c="24976">n</st></em><st c="24977">th term of a sequence in terms of its preceding terms. </st><st c="25032">Typically, only the previous </st><img src="image/440.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre357"/><st c="25061"/><st c="25062"> terms of the sequence are involved in the equation, where </st><img src="image/441.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre358"/><st c="25121"/><st c="25122"> is a parameter that does not depend on </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre359"/><st c="25162"/><st c="25163">. This parameter </st><img src="image/443.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre360"/><st c="25180"/><st c="25181">is known as the order of the recurrence function. </st><st c="25231">Once the values of the first </st><img src="image/444.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre361"/><st c="25260"/><st c="25261"> terms are known, the remaining terms of the sequence can be determined by repeatedly applying the </st><span><st c="25360">recurrence function.</st></span></p>
			<table id="table001-2" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="25380">Instruction</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="25392">Cost</st></strong></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="source-inline"><st c="25397">def factorial_incremental(n):</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="25427">-</st></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="source-inline"><st c="25429">result = 1</st></strong></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><img src="image/233.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre217"/><st c="25439"/></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="source-inline"><st c="25441">for i in range(1, n + </st></strong><span><strong class="source-inline"><st c="25463">1):</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><img src="image/446.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre362"/><st c="25466"/></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="source-inline"><st c="25471">result *= i</st></strong></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="25482"/></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="source-inline"><st c="25532">return result</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><img src="image/233.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre217"/><st c="25545"/></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="source-inline"><st c="25547">Running time </st></strong><span><strong class="source-inline"><st c="25560">function T(n)</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><img src="image/449.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre363"/><st c="25573"/></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="source-inline"><st c="25590">Complexity</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><img src="image/450.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre364"/><st c="25600"/></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="25602">Table 4.1: Incremental implementation of factorial of n and its running time</st></p>
			<p class="calibre3"><st c="25678">For example, the Fibonacci sequence can be defined by a recurrence function where each term is the sum of the two preceding terms. </st><st c="25810">By knowing the first two terms, the entire sequence can be generated (See </st><em class="italic"><st c="25884">Example 4.2</st></em><st c="25895">). </st><st c="25899">Similarly, in algorithm analysis, recurrence functions help us model the running time of recursive algorithms by expressing the time complexity of a problem in terms of </st><span><st c="26068">smaller subproblems.</st></span></p>
			<p class="calibre3"><st c="26088">In the context of recursive algorithms, a</st><a id="_idIndexMarker187" class="pcalibre pcalibre1 calibre6"/><st c="26130"> recurrence function captures the essence of how an algorithm divides a problem into subproblems, solves them recursively, and combines their solutions. </st><st c="26283">This approach allows us to systematically analyze and predict the performance of recursive algorithms, even though their execution paths and computational costs are not as immediately apparent as those of </st><span><st c="26488">incremental algorithms.</st></span></p>
			<p class="calibre3"><st c="26511">Two major categories of recurrence functions </st><a id="_idIndexMarker188" class="pcalibre pcalibre1 calibre6"/><st c="26557">are </st><strong class="bold"><st c="26561">subtractive recurrence</st></strong><st c="26583"> and </st><strong class="bold"><st c="26588">divide-and-conquer recurrence</st></strong><st c="26617"> functions. </st><st c="26629">Both subtractive and divide-and-conquer </st><a id="_idIndexMarker189" class="pcalibre pcalibre1 calibre6"/><st c="26669">recurrences are ways </st><a id="_idIndexMarker190" class="pcalibre pcalibre1 calibre6"/><st c="26690">to define problems recursively, where the solution to a </st><a id="_idIndexMarker191" class="pcalibre pcalibre1 calibre6"/><st c="26746">larger problem is expressed in terms of solutions to smaller subproblems. </st><st c="26820">However, they differ in how they break down the problem and how the solutions to the subproblems are combined. </st><st c="26931">Let’s explore these two types of recurrences </st><span><st c="26976">in detail.</st></span></p>
			<h2 id="_idParaDest-50" class="calibre5"><a id="_idTextAnchor057" class="pcalibre pcalibre1 calibre6"/><st c="26986">Subtractive recurrence functions</st></h2>
			<p class="calibre3"><strong class="bold"><st c="27019">Subtractive recurrence</st></strong><st c="27042"> functions (also called </st><strong class="bold"><st c="27066">subtract-and-conquer</st></strong><st c="27086"> and </st><strong class="bold"><st c="27091">decrease-and-conquer</st></strong><st c="27111">) are a </st><a id="_idIndexMarker192" class="pcalibre pcalibre1 calibre6"/><st c="27120">type of linear recurrence function where the next term in a sequence is a linear combination of previous terms. </st><st c="27232">These </st><a id="_idIndexMarker193" class="pcalibre pcalibre1 calibre6"/><st c="27238">functions are crucial in both mathematics and computer science for modeling problems that have </st><span><st c="27333">recursive structures.</st></span></p>
			<p class="calibre3"><st c="27354">A linear recurrence function is an equation that relates a term in a sequence to its preceding terms using linear coefficients. </st><st c="27483">The general form of a linear recurrence function of order </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="27541"/><st c="27542"> is </st><span><st c="27546">as follows:</st></span></p>
			<p class="calibre3"><img src="image/452.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;⋯&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre365"/><st c="27557"/></p>
			<p class="calibre3"><st c="27559">Here, </st><img src="image/453.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre366"/><st c="27565"/><st c="27578">  are constants, and </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="27597"/><st c="27598"> is the order of the </st><span><st c="27619">recurrence function.</st></span></p>
			<p class="calibre3"><st c="27639">The general form of a subtractive recurrence function is </st><span><st c="27697">as follows:</st></span></p>
			<p class="calibre3"><img src="image/455.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre367"/><st c="27708"/></p>
			<p class="calibre3"><st c="27746">Here’s a detailed breakdown of </st><span><st c="27777">the components:</st></span></p>
			<p class="calibre3"><img src="image/456.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre368"/><st c="27792"/><st c="27794">: This is a positive integer where </st><img src="image/457.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;mml:mo&gt;&lt;&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;&lt;&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre369"/><st c="27829"/><st c="27839">. It represents the step size by which the problem size is reduced in each recursive call. </st><st c="27930">If </st><img src="image/458.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre370"/><st c="27933"/><st c="27934">, the linear recurrence function can be written </st><span><st c="27982">as follows:</st></span></p>
			<p class="calibre3"><img src="image/459.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre371"/><st c="27993"/></p>
			<p class="calibre3"><st c="27995">Here, </st><img src="image/460.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre372"/><st c="28001"/><st c="28021"> is the number of subproblems to </st><span><st c="28053">be solved.</st></span></p>
			<p class="calibre3"><img src="image/461.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre373"/><st c="28063"/><st c="28079">: This is the recursive component of the recurrence function. </st><st c="28141">It indicates that the function calls itself with a problem size reduced by </st><img src="image/462.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre374"/><st c="28216"/><st c="28231">. This term captures the essence of the recursion, showing how the current problem depends on the solution to a </st><span><st c="28343">smaller subproblem.</st></span></p>
			<p class="calibre3"><img src="image/463.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre375"/><st c="28362"/><st c="28368">: This represents </st><a id="_idIndexMarker194" class="pcalibre pcalibre1 calibre6"/><st c="28386">the running time of the non-recursive component </st><a id="_idIndexMarker195" class="pcalibre pcalibre1 calibre6"/><st c="28434">of the algorithm. </st><st c="28452">It encompasses the time taken by all the operations that are performed in the function, excluding the time taken by the recursive call. </st><st c="28588">This could include operations such as initialization, the combination of results, or any other processing that occurs outside of the </st><span><st c="28721">recursive calls.</st></span></p>
			<p class="calibre3"><st c="28737">The following are the main </st><a id="_idIndexMarker196" class="pcalibre pcalibre1 calibre6"/><st c="28765">properties of subtractive </st><span><st c="28791">recurrence functions:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="28812">A subtractive approach breaks the problem down by subtracting a constant value (such as </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre376"/><st c="28901"/><st c="28902">) from the original </st><span><st c="28922">problem size</st></span></li>
				<li class="calibre13"><st c="28934">The solution to the smaller problem is then used to solve the original problem, often without needing to solve the remaining part of the original </st><span><st c="29081">problem entirely</st></span></li>
				<li class="calibre13"><st c="29097">This approach is less common than divide-and-conquer, but it can be effective for specific problems where the solution can be derived from a solution to a slightly </st><span><st c="29262">smaller problem</st></span></li>
			</ul>
			<p class="calibre3"><st c="29277">Let’s examine this type of recurrence function in two well-known Factorial and </st><span><st c="29357">Fibonacci algorithms.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="29378">Example 4.1</st></strong></span></p>
			<p class="calibre3"><strong class="bold"><st c="29390">Implementing factorial of </st></strong><strong class="bold"><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="29417"/></strong><strong class="bold"><st c="29466"> using linear recurrence</st></strong><st c="29489">: The factorial of a number </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="29518"/><st c="29567"> can be described using a linear recurrence function. </st><st c="29620">In this case, the problem size is reduced by </st><img src="image/467.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre377"/><st c="29665"/><st c="29666"> in each recursive step, making it a straightforward </st><span><st c="29719">linear recurrence.</st></span></p>
			<p class="calibre3"><st c="29737">The recurrence</st><a id="_idIndexMarker197" class="pcalibre pcalibre1 calibre6"/><st c="29752"> function for the </st><strong class="bold"><st c="29770">factorial function</st></strong><st c="29788"> can </st><a id="_idIndexMarker198" class="pcalibre pcalibre1 calibre6"/><st c="29793">be written </st><span><st c="29804">as</st></span><span><a id="_idIndexMarker199" class="pcalibre pcalibre1 calibre6"/></span><span><st c="29806"> follows:</st></span></p>
			<p class="calibre3"><img src="image/468.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre378"/><st c="29815"/></p>
			<p class="calibre3"><st c="29832">Here’s </st><span><st c="29839">the breakdown:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><img src="image/469.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre379"/><st c="29853"/><st c="29855"> is the number of subproblems in each recursion </st><span><st c="29903">is 1.</st></span></li>
				<li class="calibre13"><img src="image/470.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre380"/><st c="29908"/><st c="29910"> means the problem size is reduced by 1 in each </st><span><st c="29958">recursive step.</st></span></li>
				<li class="calibre13"><img src="image/471.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre381"/><st c="29973"/><st c="29981"> is the recursive component. </st><st c="30009">It shows that the factorial function calls itself </st><span><st c="30059">with </st></span><span><img src="image/472.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre382"/><st c="30064"/></span><span><st c="30065">.</st></span></li>
				<li class="calibre13"><img src="image/473.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre383"/><st c="30066"/><st c="30068"> is the non-recursive component. </st><st c="30101">It represents the constant time operations performed at each step, such as the multiplication and the function </st><span><st c="30212">call overhead.</st></span></li>
			</ul>
			<p class="calibre3"><st c="30226">The following code is the Python implementation of the factorial function using </st><span><st c="30307">linear recursion:</st></span></p>
			<pre class="source-code"><st c="30324" class="calibre11">
def factorial_recursive(n):
    # Base case: if n is 0, the factorial is 1
    if n == 0:
        return 1
    # Recursive case: multiply n by the factorial of (n - 1)
    else:
        return n * factorial_recursive(n - 1)</st></pre>			<p class="calibre3"><st c="30516">This recurrence function indicates that the time complexity is </st><img src="image/474.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre384"/><st c="30580"/><st c="30581">, as the function makes </st><img src="image/322.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre279"/><st c="30605"/><st c="30606"> recursive calls and performs a constant amount of work for </st><span><st c="30666">each call.</st></span></p>
			<p class="calibre3"><st c="30676">The running time of the </st><a id="_idIndexMarker200" class="pcalibre pcalibre1 calibre6"/><st c="30701">factorial algorithm for both the incremental and recursive approaches cannot be better than</st><img src="image/476.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre385"/><st c="30792"/><st c="30794">. This limitation arises from the nature of the problem itself. </st><st c="30858">To compute the factorial of </st><img src="image/477.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre386"/><st c="30886"/><st c="30887">, it is necessary to process every single number from 2 to </st><img src="image/478.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre386"/><st c="30946"/><st c="30947">. There </st><a id="_idIndexMarker201" class="pcalibre pcalibre1 calibre6"/><st c="30955">are no shortcuts or optimizations that can reduce the computational cost below this linear </st><span><st c="31046">time complexity.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="31062">Example 4.2</st></strong></span></p>
			<p class="calibre3"><st c="31074">The </st><strong class="bold"><st c="31079">Fibonacci sequence</st></strong><st c="31097"> is </st><a id="_idIndexMarker202" class="pcalibre pcalibre1 calibre6"/><st c="31101">one of the most well-known examples of a linear recurrence function. </st><st c="31170">It is defined by the following</st><a id="_idIndexMarker203" class="pcalibre pcalibre1 calibre6"/><st c="31200">ºu| </st><span><st c="31205">recurrence function:</st></span></p>
			<p class="calibre3"><img src="image/479.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre387"/><st c="31225"/></p>
			<p class="calibre3"><st c="31227">It is also defined with the </st><span><st c="31255">initial conditions:</st></span></p>
			<p class="calibre3"><img src="image/480.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre388"/><st c="31274"/></p>
			<p class="calibre3"><img src="image/481.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre388"/><st c="31276"/></p>
			<p class="calibre3"><st c="31285">This means that </st><a id="_idIndexMarker204" class="pcalibre pcalibre1 calibre6"/><st c="31301">each term in the Fibonacci sequence is the sum of the two preceding terms. </st><st c="31376">The Fibonacci sequence can be implemented using a recursive algorithm </st><span><st c="31446">as follows:</st></span></p>
			<pre class="source-code"><st c="31457" class="calibre11">
def fibonacci_recursive(n):
    if n &lt;= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)</st></pre>			<p class="calibre3"><st c="31596">The recurrence function for the linear recursive algorithm for the Fibonacci sequence is </st><span><st c="31686">as follows:</st></span></p>
			<p class="calibre3"><img src="image/482.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre389"/><st c="31697"/></p>
			<p class="calibre3"><st c="31730">Here is </st><span><st c="31738">the breakdown:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><img src="image/483.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre390"/><st c="31752"/><st c="31761"> represents the time complexity of computing the </st><img src="image/484.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre391"/><st c="31809"/><st c="31810">th Fibonacci number. </st><st c="31831">The function calls itself with </st><img src="image/485.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre362"/><st c="31862"/><st c="31863"> as </st><span><st c="31867">the argument.</st></span></li>
				<li class="calibre13"><img src="image/486.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre390"/><st c="31880"/><st c="31890"> represents the time complexity of computing the </st><img src="image/487.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre391"/><st c="31938"/><st c="31939">th Fibonacci number. </st><st c="31960">The function calls itself with </st><img src="image/488.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre362"/><st c="31991"/><st c="31992"> as </st><span><st c="31996">the argument.</st></span></li>
				<li class="calibre13"><img src="image/489.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre392"/><st c="32009"/><st c="32011"> accounts for the constant time operations performed in each recursive call, such as adding the results of the recursive calls and any other </st><span><st c="32152">constant-time operations.</st></span></li>
			</ul>
			<p class="calibre3"><st c="32177">The recursive </st><a id="_idIndexMarker205" class="pcalibre pcalibre1 calibre6"/><st c="32192">implementation of the Fibonacci sequence has exponential time complexity, </st><img src="image/490.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre393"/><st c="32266"/><st c="32267">. This inefficiency arises because the same </st><a id="_idIndexMarker206" class="pcalibre pcalibre1 calibre6"/><st c="32311">calculations are </st><a id="_idIndexMarker207" class="pcalibre pcalibre1 calibre6"/><st c="32328">repeated </st><span><st c="32337">multiple times.</st></span></p>
			<p class="calibre3"><st c="32352">Linear recurrence functions, such as the Fibonacci sequence, are not just theoretical constructs; they have practical applications in various fields in addition to algorithm design in computer science, such as predicting stock prices, analyzing investment strategies, and studying population growth in ecology </st><span><st c="32663">and epidemiology.</st></span></p>
			<h2 id="_idParaDest-51" class="calibre5"><a id="_idTextAnchor058" class="pcalibre pcalibre1 calibre6"/><st c="32680">Divide-and-conquer recurrence functions</st></h2>
			<p class="calibre3"><st c="32720">In divide-and-conquer</st><a id="_idIndexMarker208" class="pcalibre pcalibre1 calibre6"/><st c="32742"> recurrence functions, the </st><a id="_idIndexMarker209" class="pcalibre pcalibre1 calibre6"/><st c="32769">problem size is divided into smaller subproblems, which are solved independently and then combined. </st><st c="32869">These are typically represented </st><span><st c="32901">as follows:</st></span></p>
			<p class="calibre3"><img src="image/491.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre394"/><st c="32912"/></p>
			<p class="calibre3"><st c="32914">Here, </st><img src="image/460.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre395"/><st c="32920"/><st c="32940"> is the number of subproblems, </st><img src="image/493.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre396"/><st c="32970"/><st c="32971"> is the factor by which the problem size is divided, and </st><img src="image/494.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre397"/><st c="33028"/><st c="33033"> is the time complexity of dividing the problem and combining </st><span><st c="33094">the results.</st></span></p>
			<p class="calibre3"><st c="33106">It’s important to note that we generally have some constraints on </st><img src="image/460.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre372"/><st c="33173"/><st c="33193"> and </st><img src="image/493.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre398"/><st c="33197"/><st c="33198">, which will be discussed in the next chapter when introducing the master theorem for solving recurrence functions. </st><st c="33314">In simple terms, the constraints on the </st><span><st c="33354">parameter are:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><img src="image/497.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;≥&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre399"/><st c="33368"/><st c="33370"> means the number of subproblems cannot be smaller </st><span><st c="33421">than one</st></span></li>
				<li class="calibre13"><img src="image/498.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;&gt;&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre400"/><st c="33429"/><st c="33434"> means each subproblem should be smaller than the original problem, ensuring that the algorithm </st><span><st c="33529">eventually terminates</st></span></li>
			</ul>
			<p class="calibre3"><st c="33550">Additionally, both </st><img src="image/460.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre372"/><st c="33570"/><st c="33590"> and </st><img src="image/493.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre398"/><st c="33594"/><st c="33595"> should be constants and independent </st><span><st c="33632">of </st></span><span><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="33635"/></span><span><st c="33684">.</st></span></p>
			<p class="calibre3"><st c="33685">The following are the main </st><a id="_idIndexMarker210" class="pcalibre pcalibre1 calibre6"/><st c="33713">properties of divide-and-conquer </st><span><st c="33746">recurrence functions:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="33767">A divide-and-conquer approach breaks the problem into two or more smaller subproblems of roughly </st><span><st c="33865">equal size</st></span></li>
				<li class="calibre13"><st c="33875">The solutions to these subproblems are then combined to get the solution to the </st><span><st c="33956">original problem</st></span></li>
				<li class="calibre13"><st c="33972">This approach is often used for problems that can be naturally divided into </st><span><st c="34049">independent subproblems</st></span></li>
			</ul>
			<p class="calibre3"><st c="34072">Let’s examine the </st><a id="_idIndexMarker211" class="pcalibre pcalibre1 calibre6"/><st c="34091">recurrence function of merge sort as an example, which demonstrates the </st><span><st c="34163">divide-and-conquer approach.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="34191">Example 4.3</st></strong></span></p>
			<p class="calibre3"><st c="34203">An example is the</st><a id="_idIndexMarker212" class="pcalibre pcalibre1 calibre6"/><st c="34221"> recurrence function seen in algorithms such as </st><a id="_idIndexMarker213" class="pcalibre pcalibre1 calibre6"/><st c="34269">merge sort (see previous section), where the problem size is halved at each step, and the subproblems are solved recursively before being combined. </st></p>
			<p class="calibre3"><st c="34417">The recurrence function for the merge sort algorithm is </st><span><st c="34473">as follows:</st></span></p>
			<p class="calibre3"><img src="image/502.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;/&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre401"/><st c="34484"/></p>
			<p class="calibre3"><st c="34507">Here is </st><span><st c="34515">the breakdown:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><img src="image/503.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre379"/><st c="34529"/><st c="34574"> is the number of subproblems in </st><span><st c="34606">each recursion.</st></span></li>
				<li class="calibre13"><img src="image/504.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;/&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre402"/><st c="34621"/><st c="34631"> means that the problem is divided into two subproblems (</st><img src="image/505.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre403"/><st c="34687"/><st c="34689">), each of size </st><img src="image/506.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;/&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre404"/><st c="34705"/><st c="34709">. The time complexity for solving each subproblem </st><span><st c="34759">is </st></span><span><img src="image/507.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;/&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre405"/><st c="34762"/></span><span><st c="34771">.</st></span></li>
				<li class="calibre13"><img src="image/508.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre406"/><st c="34772"/><st c="34774"> accounts for the time taken to merge the sorted subarrays, which is linear with respect to the size of </st><span><st c="34878">the array.</st></span></li>
			</ul>
			<p class="calibre3"><st c="34888">In the previous example, a typical divide-and-conquer recurrence was demonstrated along with its key parameters. </st><st c="35002">In the next example, we will examine the recurrence function for binary search, which also follows a divide-and-conquer approach similar to </st><span><st c="35142">merge sort.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="35153">Example 4.4</st></strong></span></p>
			<p class="calibre3"><strong class="bold"><st c="35165">Binary search</st></strong><st c="35179"> is a</st><a id="_idIndexMarker214" class="pcalibre pcalibre1 calibre6"/><st c="35184"> classic</st><a id="_idIndexMarker215" class="pcalibre pcalibre1 calibre6"/><st c="35192"> example of a divide-and-conquer algorithm. </st><st c="35236">Binary search works by repeatedly dividing the search interval </st><a id="_idIndexMarker216" class="pcalibre pcalibre1 calibre6"/><st c="35299">in half and checking whether the target value is in the left or right half. </st><st c="35375">Here’s the Python implementation of binary search using a </st><span><st c="35433">recursive approach:</st></span></p>
			<pre class="source-code"><st c="35452" class="calibre11">
def binary_search(arr, target, low, high):
    if low &gt; high:
        return -1  # Target is not in the array
    mid = (low + high) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] &lt; target:
        return binary_search(arr, target, mid + 1, high)
    else:
        return binary_search(arr, target, low, mid - 1)</st></pre>			<p class="calibre3"><st c="35734">The binary search algorithm splits the problem size in half with each recursive call. </st><st c="35821">This can be expressed with the following </st><span><st c="35862">recurrence function:</st></span></p>
			<p class="calibre3"><img src="image/509.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre407"/><st c="35882"/></p>
			<p class="calibre3"><st c="35884">Here is </st><span><st c="35892">the breakdown:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><img src="image/510.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre408"/><st c="35906"/><st c="35908"> represents the recursive call to search within one-half of the array. </st><st c="35979">From the recurrence function, we know that </st><img src="image/469.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre379"/><st c="36022"/> <span><st c="36023">and </st></span><span><img src="image/512.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre22"/><st c="36027"/></span><span><st c="36028">.</st></span></li>
				<li class="calibre13"><img src="image/513.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre409"/><st c="36029"/><st c="36031"> accounts for the constant time operations, such as comparing the target with the middle element and determining which half to </st><span><st c="36158">search next.</st></span></li>
			</ul>
			<p class="calibre3"><st c="36170">In this section, we explored recurrence functions, focusing on both subtractive and divide-and-conquer approaches. </st><st c="36286">We learned how to identify each type and determine the parameters of their components. </st><st c="36373">Through this analysis, we gained the ability to classify recurrence </st><span><st c="36441">functions accurately.</st></span></p>
			<p class="calibre3"><st c="36462">Additionally, we applied our understanding of recurrence functions to well-known algorithms, such as search and sort algorithms. </st><st c="36592">We examined specific examples, such as merge sort and binary search, to see how recurrence functions operate in practice, allowing us to observe the direct impact of these concepts on the efficiency and complexity of these algorithms. </st><st c="36827">This comprehensive study provided a solid foundation for analyzing and designing recursive </st><span><st c="36918">algorithms effectively.</st></span></p>
			<h1 id="_idParaDest-52" class="calibre5"><a id="_idTextAnchor059" class="pcalibre pcalibre1 calibre6"/><st c="36941">Unfolding recurrence functions</st></h1>
			<p class="calibre3"><st c="36972">So far, we have discussed the recursive structures in algorithm design and introduced different types of recursions. </st><st c="37090">We then focused on two types of recurrence functions: subtractive and divide-and-conquer. </st><em class="italic"><st c="37180">Table 4.2</st></em><st c="37189"> provides a summary of the properties of these two recurrence functions. </st><st c="37262">As</st><a id="_idIndexMarker217" class="pcalibre pcalibre1 calibre6"/><st c="37264"> the table illustrates, divide-and-conquer recurrences generally offer more efficient solutions, although the efficiency highly depends on the specific problem </st><span><st c="37424">being solved.</st></span></p>
			<p class="calibre3"><st c="37437">In this section, we will demystify recurrence functions. </st><st c="37495">This understanding will be essential in the next chapter, where we will solve recurrence functions and estimate their computational complexity, or in other words, their rate of growth. </st><st c="37680">By unfolding these functions, we can gain insights into how recursive algorithms operate and how their performance scales with input size. </st><st c="37819">This knowledge will enable us to analyze and optimize algorithms </st><span><st c="37884">more effectively.</st></span></p>
			<p class="calibre3"><st c="37901">Regardless of the type of recurrence function, they consist of two main elements: the recursive component and the non-recursive component. </st><st c="38041">The </st><strong class="bold"><st c="38045">recursive component</st></strong><st c="38064"> reduces the problem</st><a id="_idIndexMarker218" class="pcalibre pcalibre1 calibre6"/><st c="38084"> size, either through subtraction or division. </st><st c="38131">On the other hand, the </st><strong class="bold"><st c="38154">non-recursive component</st></strong><st c="38177">, also</st><a id="_idIndexMarker219" class="pcalibre pcalibre1 calibre6"/><st c="38183"> known as</st><a id="_idIndexMarker220" class="pcalibre pcalibre1 calibre6"/><st c="38192"> the </st><strong class="bold"><st c="38197">driving function</st></strong><st c="38213">, is expressed as a function of </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="38245"/><st c="38294">, representing the size of </st><span><st c="38321">the problem.</st></span></p>
			<p class="calibre3"><st c="38333">The recursive component</st><a id="_idIndexMarker221" class="pcalibre pcalibre1 calibre6"/><st c="38357"> defines how the problem is broken down into smaller subproblems. </st><st c="38423">For subtractive recurrence functions, this reduction is typically by a constant amount, such as </st><img src="image/515.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre410"/><st c="38519"/><st c="38520">. For divide-and-conquer recurrence functions, the problem is divided by a factor, such as </st><img src="image/516.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre411"/><st c="38611"/><st c="38624">. Since division reduces the problem size more rapidly than subtraction, divide-and-conquer recursion generally leads to more efficient algorithms. </st><st c="38772">This is analogous to how multiplication grows faster than addition; in the same way, dividing the problem size tends to reduce it more quickly than subtracting a constant. </st><st c="38944">Consequently, algorithms based on divide-and-conquer strategies are often more efficient than those using simple </st><span><st c="39057">subtractive recursion.</st></span></p>
			<table id="table002-1" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="39079">Feature</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="39087">Subtractive Recurrence</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="39110">Divide-and-Conquer Recurrence</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="39140">Problem breakdown</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39158">Decreases</st><a id="_idIndexMarker222" class="pcalibre pcalibre1 calibre6"/><st c="39168"> by a </st><span><st c="39174">constant </st></span><span><a id="_idIndexMarker223" class="pcalibre pcalibre1 calibre6"/></span><span><st c="39183">amount.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39190">Divided into roughly </st><span><st c="39212">equal-sized subproblems.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="39236">Subproblem combination</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39259">A solution from one subproblem; others may </st><span><st c="39303">be ignored.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39314">Solutions combined to find the </st><span><st c="39346">overall solution.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="39363">Number </st><span><st c="39371">of subproblems</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39385">One (in </st><span><st c="39394">most cases).</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39406">Two </st><span><st c="39411">or more.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="39419">Applicability</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39433">Specific problems where the solution can be derived from a slightly </st><span><st c="39502">smaller problem.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39518">Problems that are naturally divisible into </st><span><st c="39562">independent subproblems.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="39586">Efficiency</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39597">Can be less efficient than divide-and-conquer for problems where dividing into subproblems leads to a faster overall solution. </st><st c="39725">This is because the problem size decreases slowly in </st><span><st c="39778">subtractive recurrence.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39801">Generally, more efficient for problems that can be broken down into multiple subproblems. </st><st c="39892">This is because it can leverage parallel processing and often leads to logarithmic or linearithmic time complexities. </st><st c="40010">However, the overhead of dividing and combining subproblems can sometimes make it less efficient than subtractive recurrence for very small </st><span><st c="40150">problem sizes.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="40164">Example algorithms</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="40183">Factorial, binary </st><a id="_idIndexMarker224" class="pcalibre pcalibre1 calibre6"/><st c="40202">search, </st><span><st c="40210">and Fibonacci.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="40224">Merge sort, quick sort, and Strassen’s </st><a id="_idIndexMarker225" class="pcalibre pcalibre1 calibre6"/><st c="40264">matrix </st><span><st c="40271">multiplication algorithm.</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="40296">Table 4.2: Summarizing the key differences between subtractive and divide-and-conquer recurrence functions</st></p>
			<p class="calibre3"><st c="40403">The non-recursive component, or driving function, </st><img src="image/517.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre412"/><st c="40454"/><st c="40459">, represents the work done outside the recursive calls. </st><st c="40515">It encompasses all the operations performed to divide the problem and combine the results of the subproblems. </st><st c="40625">This function plays a crucial role in determining the overall time complexity of </st><span><st c="40706">the algorithm.</st></span></p>
			<p class="calibre3"><st c="40720">Let’s imagine the recurrence function as a mechanical vehicle. </st><st c="40784">The recursive component acts as the engine. </st><st c="40828">The larger the value of </st><img src="image/518.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre413"/><st c="40852"/><st c="40853">, the slower the engine, meaning the recursive algorithm has to solve more subproblems. </st><st c="40941">On the other hand, </st><img src="image/493.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre398"/><st c="40960"/><st c="40961"> functions as the gears. </st><st c="40986">The higher the value of </st><img src="image/493.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre398"/><st c="41010"/><st c="41011">, the faster the engine works. </st><st c="41042">This implies that with each step (or recursion), the problem size is reduced more rapidly into </st><span><st c="41137">smaller subproblems.</st></span></p>
			<p class="calibre3"><st c="41157">Now, you might wonder about the role of </st><img src="image/521.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre414"/><st c="41198"/><st c="41199">. The driving function, though the name might not seem very intuitive, represents the load of the vehicle. </st><st c="41306">The larger </st><img src="image/494.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre415"/><st c="41317"/><st c="41322"> is in terms of its rate of growth, the more work the recursive algorithm must do to complete the task. </st><st c="41425">This means that if </st><img src="image/523.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre416"/><st c="41444"/><st c="41445"> grows quickly, the algorithm will need to exert more effort at each step, akin to a vehicle carrying a </st><span><st c="41549">heavier load.</st></span></p>
			<p class="calibre3"><st c="41562">Recursive algorithms offer elegant solutions to many problems, but their time complexity can be tricky to analyze. </st><st c="41678">A helpful guideline is that the driving function, the work done outside the recursive calls, sets a lower bound on the overall complexity. </st><st c="41817">In other words, a recursive algorithm cannot be faster than the time it takes to perform the </st><span><st c="41910">non-recursive operations.</st></span></p>
			<p class="calibre3"><st c="41935">However, the driving function is not the only factor determining the final complexity. </st><st c="42023">The number of subproblems created in each recursive step (often denoted by </st><em class="italic"><st c="42098">a</st></em><st c="42099">) and the reduction factor by which the problem size shrinks (denoted by </st><em class="italic"><st c="42172">b</st></em><st c="42173">) play crucial roles. </st><st c="42195">These parameters interact with the driving function, leading to different time complexities. </st><st c="42288">For example, if the number of subproblems is small and the problem size reduces significantly at each step, the impact of the driving function might be overshadowed. </st><st c="42454">On the other hand, if there are many subproblems or the problem size shrinks slowly, the driving function might become the </st><span><st c="42577">dominant factor.</st></span></p>
			<p class="calibre3"><st c="42593">To systematically analyze the interplay of all these factors and accurately estimate the time complexity of recursive algorithms, we turn to a powerful tool called the </st><strong class="bold"><st c="42762">master theorem</st></strong><st c="42776">. This </st><a id="_idIndexMarker226" class="pcalibre pcalibre1 calibre6"/><st c="42783">theorem provides a framework for solving recurrence functions, which are mathematical expressions that define the runtime of recursive algorithms in terms of </st><span><st c="42941">their subproblems.</st></span></p>
			<h1 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor060" class="pcalibre pcalibre1 calibre6"/><st c="42959">Summary</st></h1>
			<p class="calibre3"><st c="42967">In </st><a href="B22248_04.xhtml#_idTextAnchor051" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="42971">Chapter 4</st></em></span></a><st c="42980">, we explored the intricacies of recurrence functions and their crucial role in analyzing the complexity of recursive algorithms. </st><st c="43110">We began by examining the structure of recursive algorithms, distinguishing between subtractive and divide-and-conquer recurrence functions. </st><st c="43251">These concepts were illustrated through various examples, highlighting how different types of recurrence functions impact the overall efficiency of </st><span><st c="43399">an algorithm.</st></span></p>
			<p class="calibre3"><st c="43412">We then explained the components of recurrence functions, emphasizing the importance of both the recursive and non-recursive (driving) components. </st><st c="43560">The chapter introduced the master theorem as a powerful tool for solving recurrence functions. </st><st c="43655">By applying this theorem, we demonstrated how to estimate the computational complexity of recursive algorithms, taking into account the number of subproblems, the reduction scale, and the driving function. </st><st c="43861">The detailed analysis and examples provided a comprehensive understanding of how to approach and solve recurrence functions, setting the stage for more advanced topics in algorithm design and </st><span><st c="44053">complexity analysis.</st></span></p>
			<p class="calibre3"><st c="44073">In the next chapter, we will explore how to solve recurrence functions. </st><st c="44146">We will discuss several approaches to analyze recursive algorithms and estimate their running time, including the master theorem. </st><st c="44276">Additionally, we will examine the applications of these methods to various recursive algorithms, gaining a deeper understanding of their </st><span><st c="44413">time complexity.</st></span></p>
			<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor061" class="pcalibre pcalibre1 calibre6"/><st c="44429">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><em class="italic"><st c="44460">Introduction to Algorithms</st></em><st c="44487">. By Thomas H. </st><st c="44502">Cormen, Charles E. </st><st c="44521">Leiserson, Ronald L. </st><st c="44542">Rivest, and Clifford Stein. </st><st c="44570">Fourth Edition. </st><st c="44586">MIT </st><span><st c="44590">Press. </st><st c="44597">2022:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="44602">Chapter </st></em><span><em class="italic"><st c="44611">4</st></em></span><span><st c="44612">, </st></span><span><em class="italic"><st c="44614">Divide-and-Conquer</st></em></span></li><li class="calibre13"><em class="italic"><st c="44632">Chapter 34</st></em><st c="44643">, </st><span><em class="italic"><st c="44645">Advanced Topics</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="44660">Algorithm Design</st></em><st c="44677">. By Jon Kleinberg and Éva Tardos. </st><st c="44712">First Edition. </st><span><st c="44727">Pearson. </st><st c="44736">2005:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="44741">Chapter 5</st></em><st c="44751">, </st><em class="italic"><st c="44753">Divide </st></em><span><em class="italic"><st c="44760">and Conquer</st></em></span></li><li class="calibre13"><em class="italic"><st c="44771">Chapter 6</st></em><st c="44781">, </st><em class="italic"><st c="44783">Recurrence Relations and the </st></em><span><em class="italic"><st c="44812">Master Theorem</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="44826">Algorithms</st></em><st c="44837">. By Robert Sedgewick and Kevin Wayne. </st><st c="44876">Fourth Edition. </st><st c="44892">Addison-Wesley </st><span><st c="44907">Professional. </st><st c="44921">2011:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="44926">Chapter 2</st></em><st c="44936">, </st><em class="italic"><st c="44938">Principles of </st></em><span><em class="italic"><st c="44952">Algorithm Analysis</st></em></span></li><li class="calibre13"><em class="italic"><st c="44970">Chapter 4</st></em><st c="44980">, </st><span><em class="italic"><st c="44982">Divide-and-Conquer Algorithms</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="45011">The Art of Computer Programming, Volume 1: Fundamental Algorithms</st></em><st c="45077">. By Donald E. </st><st c="45092">Knuth. </st><st c="45099">Third edition. </st><st c="45114">Addison-Wesley </st><span><st c="45129">Professional. </st><st c="45143">1997:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="45148">Chapter 1</st></em><st c="45158">, </st><span><em class="italic"><st c="45160">Basic Concepts</st></em></span></li><li class="calibre13"><em class="italic"><st c="45174">Chapter 2</st></em><st c="45184">, </st><span><em class="italic"><st c="45186">Information Structures</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="45208">Introduction to the Design and Analysis of Algorithms</st></em><st c="45262">. By Anany Levitin. </st><st c="45282">Third Edition. </st><span><st c="45297">Pearson. </st><st c="45306">2011:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="45311">Chapter </st></em><span><em class="italic"><st c="45320">5</st></em></span><span><st c="45321">, </st></span><span><em class="italic"><st c="45323">Divide-and-Conquer</st></em></span></li></ul></li>
			</ul>
		</div>
	<div id="charCountTotal" value="45341" class="calibre2"/></body></html>