- en: <st c="0">4</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Recursion and Recurrence Functions</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="36">Estimating the complexity or running time of iterative algorithms
    is relatively straightforward due to their linear and predictable nature.</st>
    <st c="177">However, recursive algorithms, which involve the function calling
    itself one or more times during execution, present a unique challenge in complexity
    estimation.</st> <st c="339">These self-referential structures often lead to intricate
    and non-intuitive running times that cannot be easily discerned through simple
    observation or traditional</st> <st c="503">iterative analysis.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="522">To address this challenge, we introduce the concept of</st> **<st
    c="578">recurrence functions</st>**<st c="598">. Recurrence functions</st> <st
    c="620">are mathematical models that describe the running time of a recursive
    algorithm in terms of its input size.</st> <st c="729">By expressing the running
    time as a function that recurs upon itself, we can systematically analyze and
    solve these recurrences to obtain a precise estimate of the</st> <st c="893">algorithm’s
    complexity.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="916">This chapter explores the various aspects of recurrence functions,
    including their formulation, components, and the techniques used to solve them.</st>
    <st c="1064">We will explore how these functions capture the essence of recursive
    calls and their subsequent impact on the overall computational cost of the algorithm.</st>
    <st c="1219">Understanding recurrence functions is crucial for accurately predicting
    the performance of recursive algorithms and optimizing</st> <st c="1346">their
    implementation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1367">The chapter is structured</st> <st c="1394">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1405">Recursive algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1426">Recurrence functions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1447">Unfolding</st> <st c="1458">recurrence functions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1478">Recursive algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1499">Imagine a traditional Matryoshka doll, commonly found in Russia.</st>
    <st c="1565">When you open the outermost doll, you find a smaller doll inside.</st>
    <st c="1631">Opening this smaller doll reveals an even smaller one within, and
    this process continues until you reach the smallest, indivisible doll at the core.</st>
    <st c="1780">This fascinating nested structure is a perfect analogy for understanding
    recursion</st> <st c="1863">in algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1877">Just like the Matryoshka doll, a</st> **<st c="1911">recursive
    algorithm</st>** <st c="1930">solves</st> <st c="1938">a problem by breaking it
    down into smaller instances of the same problem.</st> <st c="2012">Each instance
    is simpler than the last, until a base case is reached, which can be solved directly
    without further recursion.</st> <st c="2138">This self-referential approach is
    a fundamental concept in computer science and is used to solve complex problems
    in a straightforward and</st> <st c="2277">elegant manner.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2292">In this section, we will explore the principles of recursive algorithms,
    starting with their basic definition and properties.</st> <st c="2419">We will
    examine how recursion works, its advantages and potential pitfalls, and the types
    of problems for which it is particularly well suited.</st> <st c="2563">By understanding
    the core concepts of recursion, you will be able to design and implement recursive
    solutions effectively, leveraging their power to simplify and solve</st> <st c="2731">intricate
    problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2750">The basics of recursion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2774">The evolution of computer science has</st> <st c="2812">been marked
    by a profound understanding of how to model intelligence and problem-solving through
    computation.</st> <st c="2923">At its core, computation involves breaking down
    complex tasks into simpler, repeatable steps.</st> <st c="3017">This foundational
    concept has given rise to the technology that powers our</st> <st c="3092">modern
    computers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3109">One fundamental way to implement repetition in computing is</st>
    <st c="3169">through</st> **<st c="3178">loops</st>** <st c="3183">or iterative
    processes.</st> **<st c="3208">Loops</st>** <st c="3213">are constructs that repeat
    a block of instructions a number of times or until a specific condition is met.</st>
    <st c="3321">They are straightforward to understand, their complexity is easy
    to estimate, and they are relatively simple to debug.</st> <st c="3440">However,
    while loops are efficient for many tasks, they can sometimes be computationally
    expensive and less intuitive for certain types</st> <st c="3576">of problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3588">An alternative approach to managing repetition is through</st>
    **<st c="3647">recursion</st>**<st c="3656">. Unlike loops, which iterate over
    a sequence of steps,</st> **<st c="3712">recursion</st>** <st c="3721">is a function
    calling itself to solve smaller instances of the original problem which is called
    a subproblem.</st> <st c="3832">This method is rooted in</st> <st c="3856">the</st>
    **<st c="3861">divide and conquer</st>** <st c="3879">strategy, where a problem
    is divided into smaller subproblems, each of which is solved recursively until
    a base case is reached.</st> <st c="4009">This approach can often lead to more
    elegant and simpler solutions, especially for problems that naturally fit a</st>
    <st c="4122">recursive structure.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="4142">The following two</st> <st c="4161">Python code examples demonstrate
    how to implement the factorial(n) algorithm using two different methods: the iterative
    approach (using loops) and the</st> <st c="4312">recursive approach:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4422">In the iterative implementation, the repetition is linear and straightforward.</st>
    <st c="4502">One advantage of iterative, non-recursive implementations is that
    their complexity and running time are easy to estimate.</st> <st c="4624">In the
    preceding function, the running time depends on the number of times the</st> `<st
    c="4703">for i in range(1, n + 1):</st>` <st c="4728">loop is executed.</st> <st
    c="4747">Given the loop’s range, it is clear that the time complexity is</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/430.png)<st
    c="4811"><st c="4818">, which simplifies</st> <st c="4837">to</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/49.png)<st
    c="4840"><st c="4857">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4858">Now, let’s have a look at the recursive implementation</st> <st
    c="4914">of Factorial(n):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5051">In the recursive implementation, the first noticeable difference
    is the absence of loops.</st> <st c="5142">Instead, repetition is achieved through
    nested self-calls of the function.</st> <st c="5217">This makes tracking the flow
    of a recursive algorithm more complex.</st> <st c="5285">Additionally, estimating
    the running time of a recursive algorithm is not as straightforward as it is for</st>
    <st c="5391">non-recursive algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5416">To estimate the running time, we need to model the recursion process
    using a computational function called a recurrence function, which will be discussed
    in detail in the next section.</st> <st c="5602">For the recursive Factorial(n)
    function, the recurrence function is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>c</mi></mrow></mrow></math>](img/432.png)<st
    c="5670"><st c="5681">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/433.png)
    <st c="5689"><st c="5690">represents the running time for computing the factorial
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="5750"><st c="5799">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    <st c="5805"><st c="5806">is a constant representing the time for the non-recursive
    operations.</st> <st c="5877">In the next chapter, we will see that solving this
    recurrence function shows that the computational complexity of the recursive Factorial(n)
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/436.png)<st
    c="6021"><st c="6030">, which is no better than the</st> <st c="6060">iterative
    implementation.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6085">From the recursive</st> <st c="6104">algorithm of Factorial(n),
    we can identify three components that are common in all</st> <st c="6188">recursive
    algorithms:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="6209">Recursive calls</st>**<st c="6225">: A</st> <st c="6230">function
    that calls itself within its definition, such as</st> **<st c="6288">factorial_recursive(n
    - 1)</st>**<st c="6314">. Each call works on a smaller or simpler version of the</st>
    <st c="6371">original problem.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6388">Base case</st>**<st c="6398">: The</st> <st c="6404">condition
    under which the recursive calls stop.</st> <st c="6453">It prevents infinite recursion
    and provides a straightforward solution to the simplest version of the problem.</st>
    <st c="6564">In the recursive factorial, this component is</st> <st c="6610">as
    follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="6641">Recursive case</st>**<st c="6656">: The part</st> <st c="6668">of
    the function where the recursion occurs.</st> <st c="6712">It breaks the problem
    into smaller subproblems and calls the function itself to solve these subproblems.</st>
    <st c="6817">In the recursive factorial, this component is</st> **<st c="6863">return
    n * factorial_recursive(n -</st>** **<st c="6898">1)</st>**<st c="6900">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="6901">Unlike</st> `<st c="6909">factorial_recursive(n)</st>`<st c="6931">,
    the recursive implementation can often offer better running time than the non-recursive
    one.</st> <st c="7026">Let’s consider the following example of calculating the
    power of a number using a recursive approach that leverages this technique to
    achieve</st> <st c="7168">improved efficiency:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7442">Let’s explain</st> <st c="7457">the code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7466">Base case</st>**<st c="7476">: If the</st> <st c="7485">exponent
    is</st> **<st c="7498">0</st>**<st c="7499">, the result is</st> **<st c="7515">1</st>**<st
    c="7516">, since any number raised to the power of 0</st> <st c="7560">is 1.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="7947">base</st>` <st c="7951">after the</st> <st c="7962">recursive
    call.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7977">Recursive call</st>**<st c="7992">: The function calls itself
    recursively in</st> **<st c="8036">recursive(base, exponent // 2)</st>** <st c="8067">and</st>
    **<st c="8071">power_recursive(base, exponent -</st>** **<st c="8104">1)</st>**<st
    c="8106">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8107">This method ensures that the number of recursive calls grows logarithmically
    with respect to the exponent, achieving a time complexity of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/437.png)<st
    c="8246"><st c="8255">. This is a significant improvement over the iterative approach,
    which has a linear time complexity</st> <st c="8355">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/203.png)<st
    c="8358"><st c="8359">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8360">Types of recursion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**<st c="8379">Recursion</st>** <st c="8389">can be</st> <st c="8397">broadly
    classified into two types: direct recursion and indirect recursion.</st> <st c="8473">Understanding
    these types helps in identifying the nature of recursive calls and their potential
    impacts on performance</st> <st c="8593">and complexity.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8608">Direct recursion</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="8625">Direct recursion</st>** <st c="8642">occurs</st> <st c="8649">when
    a function calls itself directly.</st> <st c="8689">This is the most common</st>
    <st c="8713">form of recursion, where the function is self-referential.</st> <st
    c="8772">All examples of recursive algorithms so far in this book have been direct
    recursive types.</st> <st c="8863">Some</st> <st c="8868">major use cases of direct
    recursion are</st> <st c="8908">as follows:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8919">Simplifies problems that can naturally be divided into</st> <st
    c="8975">identical subproblems</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8996">Easier to understand and debug compared to</st> <st c="9040">indirect
    recursion</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9058">Commonly</st> <st c="9068">used</st> <st c="9073">in</st> <st c="9076">problems
    such as</st> **<st c="9093">factorial calculation</st>**<st c="9114">,</st> **<st
    c="9116">Fibonacci series</st>**<st c="9132">, and</st> **<st c="9138">tree traversals</st>**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9153">There are several types of direct recursion, each suited to different
    kinds of problems and algorithmic strategies.</st> <st c="9270">Here are the main
    types of</st> <st c="9297">direct recursion:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="9314">Tail recursion</st>**<st c="9329">: This is a special case of</st>
    <st c="9358">recursion where the recursive call is the very</st> <st c="9405">last
    action a function takes before returning.</st> <st c="9452">This means no further
    operations are performed on the result of the recursive call.</st> <st c="9536">The
    advantage of tail recursion is that it can often be optimized by compilers to
    avoid stack overflow.</st> <st c="9640">Instead of creating a new stack frame
    for each recursive call, the compiler can reuse the existing frame, effectively
    turning the recursion into a loop.</st> <st c="9793">An illustrative example is
    the</st> **<st c="9824">factorial_tail</st>** <st c="9838">function, which calculates
    the factorial of a number by directly calling itself as its</st> <st c="9926">final
    step:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10057">One application of</st> <st c="10076">tail recursion is in managing
    linked lists.</st> <st c="10121">Although</st> <st c="10130">readers may already
    be familiar with linked list data structures, we will explore them in detail in</st>
    [*<st c="10230">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="10240">.
    In brief, linked lists are a fundamental data structure made up of nodes, where
    each node contains a value and a reference (or link) to the next node in the sequence.</st>
    <st c="10409">The inherent recursive structure of linked lists – where each node
    can be viewed as a smaller version of the entire list – makes recursion an ideal
    approach for performing operations such as traversal, insertion,</st> <st c="10622">and
    deletion.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10635">Here is one example of using tail recursion in the recursive traversal
    of a linked list.</st> <st c="10725">Traversing a linked list is typically done
    recursively by processing the current node and then moving to the next node through
    a recursive call.</st> <st c="10870">In a tail-recursive approach, this call to
    process the next node is the final operation in the function.</st> <st c="10975">Here
    is a simple piece of</st> <st c="11001">Python code:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="11119">Head recursion</st>**<st c="11134">: This is characterized</st>
    <st c="11159">by a function’s initial action being a</st> <st c="11198">recursive
    call to itself.</st> <st c="11224">This means all other operations within the
    function are postponed until after this recursive call completes.</st> <st c="11333">While
    less prevalent than tail recursion, head recursion does have its uses.</st> <st
    c="11410">However, it is generally considered less efficient due to the need to
    maintain a stack of pending operations until the recursive calls unwind.</st>
    <st c="11553">The following</st> **<st c="11567">head_recursive</st>** <st c="11581">is
    an example of this type of</st> <st c="11612">recursive function:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="11709">Linear recursion</st>**<st c="11726">: In this type of</st>
    <st c="11744">recursion, a function makes at most one recursive call</st> <st
    c="11799">during each invocation.</st> <st c="11824">This leads to a simple chain
    of recursive calls, resembling a straight line.</st> <st c="11901">The following
    is a simple example of</st> <st c="11938">linear recursion:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="12041">Tree recursion</st>**<st c="12056">: Unlike</st> <st c="12065">linear
    recursion, in tree recursion, a function calls</st> <st c="12120">itself multiple
    times within a single activation.</st> <st c="12170">This results in a branching
    structure of recursive calls, resembling a tree.</st> <st c="12247">Examples include
    the Fibonacci sequence calculation, tree traversals, and the quick</st> <st c="12331">sort
    algorithm:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="12410">Binary recursion</st>**<st c="12427">: This is a</st> <st c="12440">pattern
    where a function makes two recursive calls to</st> <st c="12493">itself within
    a single invocation.</st> <st c="12529">This approach is frequently employed in
    divide-and-conquer algorithms, which break down a problem into two smaller subproblems
    that are solved recursively.</st> <st c="12685">The solutions to these subproblems
    are then combined to obtain the</st> <st c="12752">solution to the</st> <st c="12768">original</st>
    <st c="12777">problem:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="12923">Multiple recursion</st>**<st c="12942">: This is a type of</st>
    <st c="12962">recursion where a function makes</st> <st c="12996">more than two
    recursive calls to itself within a single invocation.</st> <st c="13064">This
    pattern is less common than linear or binary recursion but can be useful for problems
    that inherently decompose into more than two subproblems.</st> <st c="13213">Each
    of these subproblems is then solved recursively, and their solutions are combined
    to obtain the final result.</st> <st c="13328">A simple multiple recursion has
    been implemented in the next</st> <st c="13389">example (</st>**<st c="13398">multiple_recursive</st>**<st
    c="13417">):</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="13562">A more sophisticated example is</st> <st c="13595">as follows:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14131">In this example, the</st> `<st c="14153">ternary_search</st>`
    <st c="14167">function performs a ternary search on a sorted array.</st> <st c="14222">It
    divides the array into three roughly equal parts and makes three recursive calls
    to</st> <st c="14309">search each part, illustrating the concept of a</st> <st
    c="14357">multiple recursion.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="14376">Nested recursion</st>**<st c="14393">: This</st> <st c="14400">is
    a more intricate form of recursion where a function’s</st> <st c="14458">recursive
    call doesn’t simply pass a modified argument, but includes another recursive call
    as part of the argument itself.</st> <st c="14582">This means the depth of recursion
    can increase rapidly, making it a less common and more complex type of recursion
    to analyze</st> <st c="14708">and understand:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14839">Indirect recursion</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`<st c="15199">functionA</st>` <st c="15208">calls</st> `<st c="15215">functionB</st>`<st
    c="15224">, and</st> `<st c="15230">functionB</st>` <st c="15239">calls</st> `<st
    c="15246">functionA</st>`<st c="15255">, forming an</st> <st c="15268">indirect
    recursion:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="15431">In the example of indirect recursion,</st> `<st c="15470">functionA</st>`
    <st c="15479">calls</st> `<st c="15486">functionB</st>`<st c="15495">, which then
    calls</st> `<st c="15514">functionA</st>` <st c="15523">again.</st> <st c="15531">This
    cycle continues until the base condition in either function is met (</st>`<st
    c="15604">n <= 0</st>`<st c="15611">), terminating the recursion.</st> <st c="15642">This
    form of recursion can involve more than two functions, creating a complex chain</st>
    <st c="15727">of calls.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15736">Some major use cases of indirect recursion are</st> <st c="15784">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15795">Useful for</st> <st c="15807">problems that require multiple stages
    of transformation</st> <st c="15863">or processing</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15876">Can be more difficult to trace and debug due to the involvement
    of</st> <st c="15944">multiple functions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15962">Commonly</st> <st c="15971">seen in mutually recursive algorithms</st>
    <st c="16009">and certain</st> <st c="16022">state machines</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16036">Understanding the differences between direct and indirect recursion
    allows for better selection of the appropriate recursive approach for a given
    problem.</st> <st c="16192">Direct recursion is straightforward and widely used,
    while indirect recursion, though more complex, can be powerful in specific scenarios
    requiring interdependent</st> <st c="16355">function calls.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16370">Recursive problem-solving</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="16396">Recursive problem-solving</st>** <st c="16422">often</st> <st
    c="16428">employs the</st> *<st c="16441">divide, conquer, and combine</st>* <st
    c="16469">strategy.</st> <st c="16480">This framework is highly effective for
    breaking down complex problems into simpler subproblems, solving these subproblems
    independently, and then combining their results to form the final solution.</st>
    <st c="16678">Let’s explore this framework</st> <st c="16707">in detail:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="16717">Divide</st>**<st c="16724">: In the</st> <st c="16733">divide
    step, the problem is broken down into smaller subproblems that are easier to solve.</st>
    <st c="16825">This step involves identifying how to partition the original problem
    into smaller parts.</st> <st c="16914">The key is to ensure that the subproblems
    are of the same nature as the original problem, but simpler or smaller</st> <st
    c="17027">in size.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="17035">Conquer</st>**<st c="17043">: In the</st> <st c="17053">conquer
    step, the subproblems are solved recursively.</st> <st c="17107">If the subproblems
    are still too large, they are further divided using the same divide, conquer,
    and combine approach.</st> <st c="17226">This process continues until the subproblems
    reach a base case, which can be solved directly without</st> <st c="17327">further
    recursion.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="17345">Combine</st>**<st c="17353">: In the</st> <st c="17362">combine
    step, the solutions to the subproblems are merged to form the solution to the
    original problem.</st> <st c="17467">This step involves integrating the results
    of the recursive calls to obtain the</st> <st c="17547">final answer.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17560">It is worth mentioning that the key element in this framework
    is to identify the</st> *<st c="17642">subproblem</st>*<st c="17652">. A</st>
    **<st c="17656">subproblem</st>** <st c="17666">is</st> <st c="17670">similar
    to the main problem but smaller in size.</st> <st c="17719">Essentially, a subproblem
    is a smaller instance of the</st> <st c="17774">original problem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17791">This framework will be explored in detail in upcoming chapters,
    especially in sorting algorithms such as merge sort.</st> <st c="17909">To give
    the reader a taste of this framework, consider the following merge sort algorithm,
    which will be discussed in</st> [*<st c="18027">Chapter 6</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="18036">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18574">Let’s briefly explain the divide, conquer, and</st> <st c="18622">combine
    framework in the merge</st> <st c="18653">sort algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="18668">Divide</st>**<st c="18675">: The</st> **<st c="18682">merge_sort</st>**
    <st c="18692">function splits the array into two halves,</st> **<st c="18736">left_half</st>**
    <st c="18745">and</st> **<st c="18750">right_half</st>**<st c="18760">. This is
    done using the midpoint of</st> <st c="18797">the array.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18807">Conquer</st>**<st c="18815">: The</st> **<st c="18822">merge_sort</st>**
    <st c="18832">function is called recursively on both halves.</st> <st c="18880">Each
    recursive call further divides the halves until the base case is reached, where
    the array length is</st> **<st c="18985">0</st>** <st c="18986">or</st> **<st
    c="18990">1</st>** <st c="18991">(</st><st c="18993">already sorted).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="19009">Combine</st>**<st c="19017">: The</st> **<st c="19024">merge</st>**
    <st c="19029">function is used to merge the sorted halves.</st> <st c="19075">It
    iterates through both halves, comparing elements and appending the smaller element
    to the sorted array.</st> <st c="19182">Any remaining elements from either half
    are</st> <st c="19226">then appended.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19240">In the upcoming chapters, we will illustrate how identifying these
    three components is crucial for the design and analysis of</st> <st c="19367">recursive
    algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19388">Advantages and challenges of recursion</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="19427">Recursion is a fundamental concept in computer science and algorithm
    design.</st> <st c="19505">While it offers several advantages, it also comes with
    its own set of challenges.</st> <st c="19587">Understanding both can help you
    decide when and how to use</st> <st c="19646">recursion effectively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19668">The following are three major advantages</st> <st c="19709">of</st>
    <st c="19713">recursive solutions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="19733">Simplicity and clarity</st>**<st c="19756">: Recursion often
    provides a more straightforward and intuitive solution for problems that have
    a repetitive or self-similar structure, such as tree traversals, factorial calculations,
    and the Fibonacci sequence.</st> <st c="19970">Recursive solutions can be also
    more concise and easier to read compared to iterative solutions.</st> <st c="20067">This
    can make the code more maintainable and easier</st> <st c="20119">to understand.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20133">Reduction of complex problems</st>**<st c="20163">: Recursion
    simplifies the process of breaking down complex problems into simpler subproblems.</st>
    <st c="20259">This is particularly useful in divide-and-conquer algorithms, such
    as merge sort and quicksort.</st> <st c="20355">Recursive functions can also lead
    to elegant and clean code, especially when the problem is naturally recursive,
    such as in dynamic programming and</st> <st c="20503">combinatorial problems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20526">Implicit state management</st>**<st c="20552">: Recursive calls
    inherently manage states through the call stack, eliminating the need for explicit
    state management in many cases.</st> <st c="20686">This can simplify the logic
    and reduce the chance of errors related to</st> <st c="20757">state</st> <st c="20763">handling.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20772">On the other side, recursive algorithms come with some challenges.</st>
    <st c="20840">The following are some major challenges</st> <st c="20880">and disadvantages:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="20898">Performance concerns</st>**<st c="20919">: Each</st> <st c="20927">recursive
    call adds a new frame to the call stack, which can result in significant overhead
    compared to iterative solutions, especially for deep recursion.</st> <st c="21083">Deep
    or unbounded recursion can lead to stack overflow errors if the recursion depth
    exceeds the maximum stack size.</st> <st c="21200">This is a common issue in languages
    with limited</st> <st c="21249">stack memory.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="21262">Complexity in debugging</st>**<st c="21286">: Debugging recursive
    functions can be challenging because it involves tracing multiple layers of function
    calls.</st> <st c="21401">Understanding the flow of execution and the state at
    each level of recursion can be difficult.</st> <st c="21496">Incorrectly defined
    base cases can also lead to infinite recursion or incorrect results.</st> <st
    c="21585">Ensuring that all base cases are correctly handled is crucial for the
    correctness of</st> <st c="21670">the algorithm.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="21684">Space complexity</st>**<st c="21701">: Recursive algorithms
    can have high space complexity due to the additional memory required for the call
    stack.</st> <st c="21814">This can be problematic for problems with large input
    sizes or deep recursion.</st> <st c="21893">Recursive functions often require
    additional memory for each recursive call, which can lead to increased auxiliary
    space usage compared to their</st> <st c="22038">iterative</st> <st c="22047">counterparts.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22061">In addition, when designing a recursive algorithm, we need to
    pay attention to the following practical issues.</st> <st c="22173">Some of them
    will be discussed in detail in</st> <st c="22217">upcoming chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="22235">Tail recursion</st>**<st c="22250">: Some</st> <st c="22257">languages
    and compilers optimize tail-recursive functions to iterative ones, reducing the
    call stack overhead.</st> <st c="22369">When possible, design recursive functions
    to</st> <st c="22414">be tail-recursive.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22432">Memoization</st>**<st c="22444">: Use memoization</st> <st
    c="22462">to store the results of expensive recursive calls and avoid redundant
    computations.</st> <st c="22547">This technique is especially useful in dynamic
    programming.</st> <st c="22607">For more information, see</st> [*<st c="22633">Chapter
    10</st>*](B22248_10.xhtml#_idTextAnchor149)<st c="22643">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22644">Iterative alternatives</st>**<st c="22667">: Consider</st>
    <st c="22679">iterative solutions when recursion leads to performance or memory
    issues.</st> <st c="22753">Iterative algorithms can often achieve the same results</st>
    <st c="22809">more efficiently.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22826">In this section, the concept of recursion</st> <st c="22868">was
    introduced, highlighting its importance in computer science and algorithm design.</st>
    <st c="22955">Recursion, a method where a function calls itself to solve smaller
    instances of the same problem, was explained with examples such as factorial calculations
    and the Fibonacci sequence.</st> <st c="23140">The section emphasized the divide,
    conquer, and combine framework, illustrating how problems are broken down into
    simpler subproblems, solved independently, and then combined to form the final
    solution, with merge sort as a</st> <st c="23364">key example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23376">Various types of recursion, including direct and indirect recursion,
    were examined, along with their respective examples.</st> <st c="23499">The advantages
    of recursion, such as simplicity, clarity, and effective problem decomposition,
    were discussed, alongside its challenges, such as function call overhead, potential
    stack overflow, and debugging complexity.</st> <st c="23720">Practical considerations,
    including tail recursion, memoization, and iterative alternatives, were provided
    to optimize</st> <st c="23839">recursive functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23859">In conclusion, this section offered a comprehensive overview of
    recursion, detailing its principles, advantages, and challenges.</st> <st c="23989">It
    laid a strong foundation for understanding and applying recursive problem-solving
    techniques in algorithm design.</st> <st c="24106">The next section will discuss
    running time models for recursive algorithms, called</st> **<st c="24189">recurrence
    functions</st>**<st c="24209">, essential for</st> <st c="24225">complexity</st>
    <st c="24235">analysis.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24245">Recurrence functions</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="24266">The function representing</st> <st c="24293">the running time
    of an incremental (non-recursive) algorithm can be determined straightforwardly
    due to the linear, sequential nature of these algorithms.</st> <st c="24448">For
    example, consider the incremental implementation of the factorial of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/439.png)<st
    c="24521"><st c="24522">.</st> *<st c="24524">Table 4.1</st>* <st c="24533">illustrates
    the algorithm along with the associated computational cost in the</st> <st c="24612">second
    column.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24626">The function describing the running time of recursive algorithms
    is not as straightforward as it is for incremental algorithms.</st> <st c="24755">To
    analyze the running time of recursive algorithms, we use</st> **<st c="24815">recurrence
    functions</st>** <st c="24835">or</st> **<st c="24839">recurrence relations</st>**<st
    c="24859">. These concepts are adapted</st> <st c="24888">from</st> <st c="24892">mathematics.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24905">In mathematics, a</st> **<st c="24924">recurrence function</st>**
    <st c="24943">is an equation that defines the</st> *<st c="24976">n</st>*<st c="24977">th
    term of a sequence in terms of its preceding terms.</st> <st c="25032">Typically,
    only the previous</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/440.png)
    <st c="25061"><st c="25062">terms of the sequence are involved in the equation,
    where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/441.png)
    <st c="25121"><st c="25122">is a parameter that does not depend on</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="25162"><st c="25163">. This parameter</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>k</mi></mrow></math>](img/443.png)<st
    c="25180"><st c="25181">is known as the order of the recurrence function.</st>
    <st c="25231">Once the values of the first</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/444.png)
    <st c="25260"><st c="25261">terms are known, the remaining terms of the sequence
    can be determined by repeatedly applying the</st> <st c="25360">recurrence function.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="25380">Instruction</st>** | **<st c="25392">Cost</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25397">def factorial_incremental(n):</st>` | <st c="25427">-</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25429">result = 1</st>` | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" display="block"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25441">for i in range(1, n +</st>` `<st c="25463">1):</st>` | ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/446.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25471">result *= i</st>` | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" display="block"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25532">return result</st>` | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" display="block"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25547">Running time</st>` `<st c="25560">function T(n)</st>` | ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>c</mml:mi></mml:math>](img/449.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="25590">Complexity</st>` | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" display="block"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '<st c="25602">Table 4.1: Incremental implementation of factorial of n and its
    running time</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25678">For example, the Fibonacci sequence can be defined by a recurrence
    function where each term is the sum of the two preceding terms.</st> <st c="25810">By
    knowing the first two terms, the entire sequence can be generated (See</st> *<st
    c="25884">Example 4.2</st>*<st c="25895">).</st> <st c="25899">Similarly, in algorithm
    analysis, recurrence functions help us model the running time of recursive algorithms
    by expressing the time complexity of a problem in terms of</st> <st c="26068">smaller
    subproblems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26088">In the context of recursive algorithms, a</st> <st c="26130">recurrence
    function captures the essence of how an algorithm divides a problem into subproblems,
    solves them recursively, and combines their solutions.</st> <st c="26283">This
    approach allows us to systematically analyze and predict the performance of recursive
    algorithms, even though their execution paths and computational costs are not
    as immediately apparent as those of</st> <st c="26488">incremental algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26511">Two major categories of recurrence functions</st> <st c="26557">are</st>
    **<st c="26561">subtractive recurrence</st>** <st c="26583">and</st> **<st c="26588">divide-and-conquer
    recurrence</st>** <st c="26617">functions.</st> <st c="26629">Both subtractive
    and divide-and-conquer</st> <st c="26669">recurrences are ways</st> <st c="26690">to
    define problems recursively, where the solution to a</st> <st c="26746">larger
    problem is expressed in terms of solutions to smaller subproblems.</st> <st c="26820">However,
    they differ in how they break down the problem and how the solutions to the subproblems
    are combined.</st> <st c="26931">Let’s explore these two types of recurrences</st>
    <st c="26976">in detail.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26986">Subtractive recurrence functions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**<st c="27019">Subtractive recurrence</st>** <st c="27042">functions (also
    called</st> **<st c="27066">subtract-and-conquer</st>** <st c="27086">and</st>
    **<st c="27091">decrease-and-conquer</st>**<st c="27111">) are a</st> <st c="27120">type
    of linear recurrence function where the next term in a sequence is a linear combination
    of previous terms.</st> <st c="27232">These</st> <st c="27238">functions are crucial
    in both mathematics and computer science for modeling problems that have</st>
    <st c="27333">recursive structures.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27354">A linear recurrence function is an equation that relates a term
    in a sequence to its preceding terms using linear coefficients.</st> <st c="27483">The
    general form of a linear recurrence function of order</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="27541"><st c="27542">is</st> <st c="27546">as follows:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>c</mi><mi>k</mi></msub><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow></mrow></math>](img/452.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27559">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math>](img/453.png)
    <st c="27565"><st c="27578">are constants, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="27597"><st c="27598">is the order of the</st> <st c="27619">recurrence
    function.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27639">The general form of a subtractive recurrence function is</st>
    <st c="27697">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/455.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27746">Here’s a detailed breakdown of</st> <st c="27777">the components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/456.png)<st
    c="27792"><st c="27794">: This is a positive integer where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn><mml:mo><</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo><</mml:mo><mml:mi>n</mml:mi></mml:math>](img/457.png)<st
    c="27829"><st c="27839">. It represents the step size by which the problem size
    is reduced in each recursive call.</st> <st c="27930">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>…</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:math>](img/458.png)<st
    c="27933"><st c="27934">, the linear recurrence function can be written</st> <st
    c="27982">as follows:</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/459.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27995">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="28001"><st c="28021">is the number of subproblems to</st> <st c="28053">be
    solved.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/461.png)<st
    c="28063"><st c="28079">: This is the recursive component of the recurrence function.</st>
    <st c="28141">It indicates that the function calls itself with a problem size
    reduced by</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/462.png)<st
    c="28216"><st c="28231">. This term captures the essence of the recursion, showing
    how the current problem depends on the solution to a</st> <st c="28343">smaller
    subproblem.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/463.png)<st
    c="28362"><st c="28368">: This represents</st> <st c="28386">the running time
    of the non-recursive component</st> <st c="28434">of the algorithm.</st> <st c="28452">It
    encompasses the time taken by all the operations that are performed in the function,
    excluding the time taken by the recursive call.</st> <st c="28588">This could
    include operations such as initialization, the combination of results, or any
    other processing that occurs outside of the</st> <st c="28721">recursive calls.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28737">The following are the main</st> <st c="28765">properties of subtractive</st>
    <st c="28791">recurrence functions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28812">A subtractive approach breaks the problem down by subtracting
    a constant value (such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)<st
    c="28901"><st c="28902">) from the original</st> <st c="28922">problem size</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28934">The solution to the smaller problem is then used to solve the
    original problem, often without needing to solve the remaining part of the original</st>
    <st c="29081">problem entirely</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29097">This approach is less common than divide-and-conquer, but it can
    be effective for specific problems where the solution can be derived from a solution
    to a slightly</st> <st c="29262">smaller problem</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29277">Let’s examine this type of recurrence function in two well-known
    Factorial and</st> <st c="29357">Fibonacci algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="29378">Example 4.1</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="29390">Implementing factorial of</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)**
    **<st c="29466">using linear recurrence</st>**<st c="29489">: The factorial of
    a number</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="29518"><st c="29567">can be described using a linear recurrence function.</st>
    <st c="29620">In this case, the problem size is reduced by</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/467.png)
    <st c="29665"><st c="29666">in each recursive step, making it a straightforward</st>
    <st c="29719">linear recurrence.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29737">The recurrence</st> <st c="29752">function for the</st> **<st
    c="29770">factorial function</st>** <st c="29788">can</st> <st c="29793">be written</st>
    <st c="29804">as</st> <st c="29806">follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow></mrow></mrow></math>](img/468.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="29832">Here’s</st> <st c="29839">the breakdown:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)
    <st c="29853"><st c="29855">is the number of subproblems in each recursion</st>
    <st c="29903">is 1.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/470.png)
    <st c="29908"><st c="29910">means the problem size is reduced by 1 in each</st>
    <st c="29958">recursive step.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></mrow></mrow></math>](img/471.png)
    <st c="29973"><st c="29981">is the recursive component.</st> <st c="30009">It
    shows that the factorial function calls itself</st> <st c="30059">with</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mrow></math>](img/472.png)<st
    c="30064"><st c="30065">.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/473.png)
    <st c="30066"><st c="30068">is the non-recursive component.</st> <st c="30101">It
    represents the constant time operations performed at each step, such as the multiplication
    and the function</st> <st c="30212">call overhead.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="30226">The following code is the Python implementation of the factorial
    function using</st> <st c="30307">linear recursion:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30516">This recurrence function indicates that the time complexity is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/474.png)<st
    c="30580"><st c="30581">, as the function makes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="30605"><st c="30606">recursive calls and performs a constant amount of
    work for</st> <st c="30666">each call.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30676">The running time of the</st> <st c="30701">factorial algorithm
    for both the incremental and recursive approaches cannot be better than</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/476.png)<st
    c="30792"><st c="30794">. This limitation arises from the nature of the problem
    itself.</st> <st c="30858">To compute the factorial of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/477.png)<st
    c="30886"><st c="30887">, it is necessary to process every single number from
    2 to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/478.png)<st
    c="30946"><st c="30947">. There</st> <st c="30955">are no shortcuts or optimizations
    that can reduce the computational cost below this linear</st> <st c="31046">time
    complexity.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31062">Example 4.2</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31074">The</st> **<st c="31079">Fibonacci sequence</st>** <st c="31097">is</st>
    <st c="31101">one of the most well-known examples of a linear recurrence function.</st>
    <st c="31170">It is defined by the following</st><st c="31200">ºu|</st> <st c="31205">recurrence
    function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/479.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31227">It is also defined with the</st> <st c="31255">initial conditions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/480.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/481.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31285">This means that</st> <st c="31301">each term in the Fibonacci
    sequence is the sum of the two preceding terms.</st> <st c="31376">The Fibonacci
    sequence can be implemented using a recursive algorithm</st> <st c="31446">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31596">The recurrence function for the linear recursive algorithm for
    the Fibonacci sequence is</st> <st c="31686">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/482.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31730">Here is</st> <st c="31738">the breakdown:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/483.png)
    <st c="31752"><st c="31761">represents the time complexity of computing the</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/484.png)<st
    c="31809"><st c="31810">th Fibonacci number.</st> <st c="31831">The function calls
    itself with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/485.png)
    <st c="31862"><st c="31863">as</st> <st c="31867">the argument.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/486.png)
    <st c="31880"><st c="31890">represents the time complexity of computing the</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/487.png)<st
    c="31938"><st c="31939">th Fibonacci number.</st> <st c="31960">The function calls
    itself with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:math>](img/488.png)
    <st c="31991"><st c="31992">as</st> <st c="31996">the argument.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/489.png)
    <st c="32009"><st c="32011">accounts for the constant time operations performed
    in each recursive call, such as adding the results of the recursive calls and
    any other</st> <st c="32152">constant-time operations.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32177">The recursive</st> <st c="32192">implementation of the Fibonacci
    sequence has exponential time complexity,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/490.png)<st
    c="32266"><st c="32267">. This inefficiency arises because the same</st> <st c="32311">calculations
    are</st> <st c="32328">repeated</st> <st c="32337">multiple times.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32352">Linear recurrence functions, such as the Fibonacci sequence, are
    not just theoretical constructs; they have practical applications in various fields
    in addition to algorithm design in computer science, such as predicting stock
    prices, analyzing investment strategies, and studying population growth in ecology</st>
    <st c="32663">and epidemiology.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32680">Divide-and-conquer recurrence functions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="32720">In divide-and-conquer</st> <st c="32742">recurrence functions,
    the</st> <st c="32769">problem size is divided into smaller subproblems, which
    are solved independently and then combined.</st> <st c="32869">These are typically
    represented</st> <st c="32901">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/491.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="32914">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="32920"><st c="32940">is the number of subproblems,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/493.png)
    <st c="32970"><st c="32971">is the factor by which the problem size is divided,
    and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)
    <st c="33028"><st c="33033">is the time complexity of dividing the problem and
    combining</st> <st c="33094">the results.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33106">It’s important to note that we generally have some constraints
    on</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="33173"><st c="33193">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/493.png)<st
    c="33197"><st c="33198">, which will be discussed in the next chapter when introducing
    the master theorem for solving recurrence functions.</st> <st c="33314">In simple
    terms, the constraints on the</st> <st c="33354">parameter are:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math>](img/497.png)
    <st c="33368"><st c="33370">means the number of subproblems cannot be smaller</st>
    <st c="33421">than one</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>></mml:mo><mml:mn>1</mml:mn></mml:math>](img/498.png)
    <st c="33429"><st c="33434">means each subproblem should be smaller than the original
    problem, ensuring that the algorithm</st> <st c="33529">eventually terminates</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33550">Additionally, both</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="33570"><st c="33590">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/493.png)
    <st c="33594"><st c="33595">should be constants and independent</st> <st c="33632">of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="33635"><st c="33684">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33685">The following are the main</st> <st c="33713">properties of divide-and-conquer</st>
    <st c="33746">recurrence functions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33767">A divide-and-conquer approach breaks the problem into two or more
    smaller subproblems of roughly</st> <st c="33865">equal size</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33875">The solutions to these subproblems are then combined to get the
    solution to the</st> <st c="33956">original problem</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33972">This approach is often used for problems that can be naturally
    divided into</st> <st c="34049">independent subproblems</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34072">Let’s examine the</st> <st c="34091">recurrence function of merge
    sort as an example, which demonstrates the</st> <st c="34163">divide-and-conquer
    approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="34191">Example 4.3</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34203">An example is the</st> <st c="34221">recurrence function seen
    in algorithms such as</st> <st c="34269">merge sort (see previous section), where
    the problem size is halved at each step, and the subproblems are solved recursively
    before being combined.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34417">The recurrence function for the merge sort algorithm is</st> <st
    c="34473">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/502.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="34507">Here is</st> <st c="34515">the breakdown:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/503.png)
    <st c="34529"><st c="34574">is the number of subproblems in</st> <st c="34606">each
    recursion.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/504.png)
    <st c="34621"><st c="34631">means that the problem is divided into two subproblems
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/505.png)<st
    c="34687"><st c="34689">), each of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:math>](img/506.png)<st
    c="34705"><st c="34709">. The time complexity for solving each subproblem</st>
    <st c="34759">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/507.png)<st
    c="34762"><st c="34771">.</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/508.png)
    <st c="34772"><st c="34774">accounts for the time taken to merge the sorted subarrays,
    which is linear with respect to the size of</st> <st c="34878">the array.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34888">In the previous example, a typical divide-and-conquer recurrence
    was demonstrated along with its key parameters.</st> <st c="35002">In the next
    example, we will examine the recurrence function for binary search, which also
    follows a divide-and-conquer approach similar to</st> <st c="35142">merge sort.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35153">Example 4.4</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35165">Binary search</st>** <st c="35179">is a</st> <st c="35184">classic</st>
    <st c="35192">example of a divide-and-conquer algorithm.</st> <st c="35236">Binary
    search works by repeatedly dividing the search interval</st> <st c="35299">in
    half and checking whether the target value is in the left or right half.</st>
    <st c="35375">Here’s the Python implementation of binary search using a</st> <st
    c="35433">recursive approach:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35734">The binary search algorithm splits the problem size in half with
    each recursive call.</st> <st c="35821">This can be expressed with the following</st>
    <st c="35862">recurrence function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/509.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="35884">Here is</st> <st c="35892">the breakdown:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/510.png)
    <st c="35906"><st c="35908">represents the recursive call to search within one-half
    of the array.</st> <st c="35979">From the recurrence function, we know that</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)
    <st c="36022"><st c="36023">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/512.png)<st
    c="36027"><st c="36028">.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/513.png)
    <st c="36029"><st c="36031">accounts for the constant time operations, such as
    comparing the target with the middle element and determining which half to</st>
    <st c="36158">search next.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36170">In this section, we explored recurrence functions, focusing on
    both subtractive and divide-and-conquer approaches.</st> <st c="36286">We learned
    how to identify each type and determine the parameters of their components.</st>
    <st c="36373">Through this analysis, we gained the ability to classify recurrence</st>
    <st c="36441">functions accurately.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36462">Additionally, we applied our understanding of recurrence functions
    to well-known algorithms, such as search and sort algorithms.</st> <st c="36592">We
    examined specific examples, such as merge sort and binary search, to see how recurrence
    functions operate in practice, allowing us to observe the direct impact of these
    concepts on the efficiency and complexity of these algorithms.</st> <st c="36827">This
    comprehensive study provided a solid foundation for analyzing and designing recursive</st>
    <st c="36918">algorithms effectively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36941">Unfolding recurrence functions</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="36972">So far, we have discussed the recursive structures in algorithm
    design and introduced different types of recursions.</st> <st c="37090">We then
    focused on two types of recurrence functions: subtractive and divide-and-conquer.</st>
    *<st c="37180">Table 4.2</st>* <st c="37189">provides a summary of the properties
    of these two recurrence functions.</st> <st c="37262">As</st> <st c="37264">the
    table illustrates, divide-and-conquer recurrences generally offer more efficient
    solutions, although the efficiency highly depends on the specific problem</st>
    <st c="37424">being solved.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37437">In this section, we will demystify recurrence functions.</st>
    <st c="37495">This understanding will be essential in the next chapter, where
    we will solve recurrence functions and estimate their computational complexity,
    or in other words, their rate of growth.</st> <st c="37680">By unfolding these
    functions, we can gain insights into how recursive algorithms operate and how
    their performance scales with input size.</st> <st c="37819">This knowledge will
    enable us to analyze and optimize algorithms</st> <st c="37884">more effectively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="37901">Regardless of the type of recurrence function, they consist of
    two main elements: the recursive component and the non-recursive component.</st>
    <st c="38041">The</st> **<st c="38045">recursive component</st>** <st c="38064">reduces
    the problem</st> <st c="38084">size, either through subtraction or division.</st>
    <st c="38131">On the other hand, the</st> **<st c="38154">non-recursive component</st>**<st
    c="38177">, also</st> <st c="38183">known as</st> <st c="38192">the</st> **<st
    c="38197">driving function</st>**<st c="38213">, is expressed as a function of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="38245"><st c="38294">, representing the size of</st> <st c="38321">the problem.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38333">The recursive component</st> <st c="38357">defines how the problem
    is broken down into smaller subproblems.</st> <st c="38423">For subtractive recurrence
    functions, this reduction is typically by a constant amount, such as</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/515.png)<st
    c="38519"><st c="38520">. For divide-and-conquer recurrence functions, the problem
    is divided by a factor, such as</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle><mo>)</mo></mrow></mrow></mrow></math>](img/516.png)<st
    c="38611"><st c="38624">. Since division reduces the problem size more rapidly
    than subtraction, divide-and-conquer recursion generally leads to more efficient
    algorithms.</st> <st c="38772">This is analogous to how multiplication grows faster
    than addition; in the same way, dividing the problem size tends to reduce it more
    quickly than subtracting a constant.</st> <st c="38944">Consequently, algorithms
    based on divide-and-conquer strategies are often more efficient than those using
    simple</st> <st c="39057">subtractive recursion.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="39079">Feature</st>** | **<st c="39087">Subtractive Recurrence</st>**
    | **<st c="39110">Divide-and-Conquer Recurrence</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39140">Problem breakdown</st> | <st c="39158">Decreases</st> <st c="39168">by
    a</st> <st c="39174">constant</st> <st c="39183">amount.</st> | <st c="39190">Divided
    into roughly</st> <st c="39212">equal-sized subproblems.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39236">Subproblem combination</st> | <st c="39259">A solution from
    one subproblem; others may</st> <st c="39303">be ignored.</st> | <st c="39314">Solutions
    combined to find the</st> <st c="39346">overall solution.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39363">Number</st> <st c="39371">of subproblems</st> | <st c="39385">One
    (in</st> <st c="39394">most cases).</st> | <st c="39406">Two</st> <st c="39411">or
    more.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39419">Applicability</st> | <st c="39433">Specific problems where
    the solution can be derived from a slightly</st> <st c="39502">smaller problem.</st>
    | <st c="39518">Problems that are naturally divisible into</st> <st c="39562">independent
    subproblems.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39586">Efficiency</st> | <st c="39597">Can be less efficient than
    divide-and-conquer for problems where dividing into subproblems leads to a faster
    overall solution.</st> <st c="39725">This is because the problem size decreases
    slowly in</st> <st c="39778">subtractive recurrence.</st> | <st c="39801">Generally,
    more efficient for problems that can be broken down into multiple subproblems.</st>
    <st c="39892">This is because it can leverage parallel processing and often leads
    to logarithmic or linearithmic time complexities.</st> <st c="40010">However,
    the overhead of dividing and combining subproblems can sometimes make it less
    efficient than subtractive recurrence for very small</st> <st c="40150">problem
    sizes.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="40164">Example algorithms</st> | <st c="40183">Factorial, binary</st>
    <st c="40202">search,</st> <st c="40210">and Fibonacci.</st> | <st c="40224">Merge
    sort, quick sort, and Strassen’s</st> <st c="40264">matrix</st> <st c="40271">multiplication
    algorithm.</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="40296">Table 4.2: Summarizing the key differences between subtractive
    and divide-and-conquer recurrence functions</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40403">The non-recursive component, or driving function,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/517.png)<st
    c="40454"><st c="40459">, represents the work done outside the recursive calls.</st>
    <st c="40515">It encompasses all the operations performed to divide the problem
    and combine the results of the subproblems.</st> <st c="40625">This function plays
    a crucial role in determining the overall time complexity of</st> <st c="40706">the
    algorithm.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40720">Let’s imagine the recurrence function as a mechanical vehicle.</st>
    <st c="40784">The recursive component acts as the engine.</st> <st c="40828">The
    larger the value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/518.png)<st
    c="40852"><st c="40853">, the slower the engine, meaning the recursive algorithm
    has to solve more subproblems.</st> <st c="40941">On the other hand,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/493.png)
    <st c="40960"><st c="40961">functions as the gears.</st> <st c="40986">The higher
    the value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/493.png)<st
    c="41010"><st c="41011">, the faster the engine works.</st> <st c="41042">This
    implies that with each step (or recursion), the problem size is reduced more rapidly
    into</st> <st c="41137">smaller subproblems.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41157">Now, you might wonder about the role of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/521.png)<st
    c="41198"><st c="41199">. The driving function, though the name might not seem
    very intuitive, represents the load of the vehicle.</st> <st c="41306">The larger</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)
    <st c="41317"><st c="41322">is in terms of its rate of growth, the more work the
    recursive algorithm must do to complete the task.</st> <st c="41425">This means
    that if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/523.png)
    <st c="41444"><st c="41445">grows quickly, the algorithm will need to exert more
    effort at each step, akin to a vehicle carrying a</st> <st c="41549">heavier load.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41562">Recursive algorithms offer elegant solutions to many problems,
    but their time complexity can be tricky to analyze.</st> <st c="41678">A helpful
    guideline is that the driving function, the work done outside the recursive calls,
    sets a lower bound on the overall complexity.</st> <st c="41817">In other words,
    a recursive algorithm cannot be faster than the time it takes to perform the</st>
    <st c="41910">non-recursive operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41935">However, the driving function is not the only factor determining
    the final complexity.</st> <st c="42023">The number of subproblems created in
    each recursive step (often denoted by</st> *<st c="42098">a</st>*<st c="42099">)
    and the reduction factor by which the problem size shrinks (denoted by</st> *<st
    c="42172">b</st>*<st c="42173">) play crucial roles.</st> <st c="42195">These
    parameters interact with the driving function, leading to different time complexities.</st>
    <st c="42288">For example, if the number of subproblems is small and the problem
    size reduces significantly at each step, the impact of the driving function might
    be overshadowed.</st> <st c="42454">On the other hand, if there are many subproblems
    or the problem size shrinks slowly, the driving function might become the</st>
    <st c="42577">dominant factor.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42593">To systematically analyze the interplay of all these factors and
    accurately estimate the time complexity of recursive algorithms, we turn to a
    powerful tool called the</st> **<st c="42762">master theorem</st>**<st c="42776">.
    This</st> <st c="42783">theorem provides a framework for solving recurrence functions,
    which are mathematical expressions that define the runtime of recursive algorithms
    in terms of</st> <st c="42941">their subproblems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42959">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="42967">In</st> [*<st c="42971">Chapter 4</st>*](B22248_04.xhtml#_idTextAnchor051)<st
    c="42980">, we explored the intricacies of recurrence functions and their crucial
    role in analyzing the complexity of recursive algorithms.</st> <st c="43110">We
    began by examining the structure of recursive algorithms, distinguishing between
    subtractive and divide-and-conquer recurrence functions.</st> <st c="43251">These
    concepts were illustrated through various examples, highlighting how different
    types of recurrence functions impact the overall efficiency of</st> <st c="43399">an
    algorithm.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43412">We then explained the components of recurrence functions, emphasizing
    the importance of both the recursive and non-recursive (driving) components.</st>
    <st c="43560">The chapter introduced the master theorem as a powerful tool for
    solving recurrence functions.</st> <st c="43655">By applying this theorem, we
    demonstrated how to estimate the computational complexity of recursive algorithms,
    taking into account the number of subproblems, the reduction scale, and the driving
    function.</st> <st c="43861">The detailed analysis and examples provided a comprehensive
    understanding of how to approach and solve recurrence functions, setting the stage
    for more advanced topics in algorithm design and</st> <st c="44053">complexity
    analysis.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44073">In the next chapter, we will explore how to solve recurrence functions.</st>
    <st c="44146">We will discuss several approaches to analyze recursive algorithms
    and estimate their running time, including the master theorem.</st> <st c="44276">Additionally,
    we will examine the applications of these methods to various recursive algorithms,
    gaining a deeper understanding of their</st> <st c="44413">time complexity.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44429">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="44460">Introduction to Algorithms</st>*<st c="44487">. By Thomas H.</st>
    <st c="44502">Cormen, Charles E.</st> <st c="44521">Leiserson, Ronald L.</st>
    <st c="44542">Rivest, and Clifford Stein.</st> <st c="44570">Fourth Edition.</st>
    <st c="44586">MIT</st> <st c="44590">Press.</st> <st c="44597">2022:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44602">Chapter</st>* *<st c="44611">4</st>*<st c="44612">,</st> *<st
    c="44614">Divide-and-Conquer</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44632">Chapter 34</st>*<st c="44643">,</st> *<st c="44645">Advanced
    Topics</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44660">Algorithm Design</st>*<st c="44677">. By Jon Kleinberg and Éva
    Tardos.</st> <st c="44712">First Edition.</st> <st c="44727">Pearson.</st> <st
    c="44736">2005:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44741">Chapter 5</st>*<st c="44751">,</st> *<st c="44753">Divide</st>*
    *<st c="44760">and Conquer</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44771">Chapter 6</st>*<st c="44781">,</st> *<st c="44783">Recurrence
    Relations and the</st>* *<st c="44812">Master Theorem</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44826">Algorithms</st>*<st c="44837">. By Robert Sedgewick and Kevin
    Wayne.</st> <st c="44876">Fourth Edition.</st> <st c="44892">Addison-Wesley</st>
    <st c="44907">Professional.</st> <st c="44921">2011:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44926">Chapter 2</st>*<st c="44936">,</st> *<st c="44938">Principles
    of</st>* *<st c="44952">Algorithm Analysis</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="44970">Chapter 4</st>*<st c="44980">,</st> *<st c="44982">Divide-and-Conquer
    Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="45011">The Art of Computer Programming, Volume 1: Fundamental Algorithms</st>*<st
    c="45077">. By Donald E.</st> <st c="45092">Knuth.</st> <st c="45099">Third edition.</st>
    <st c="45114">Addison-Wesley</st> <st c="45129">Professional.</st> <st c="45143">1997:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="45148">Chapter 1</st>*<st c="45158">,</st> *<st c="45160">Basic Concepts</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="45174">Chapter 2</st>*<st c="45184">,</st> *<st c="45186">Information
    Structures</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="45208">Introduction to the Design and Analysis of Algorithms</st>*<st
    c="45262">. By Anany Levitin.</st> <st c="45282">Third Edition.</st> <st c="45297">Pearson.</st>
    <st c="45306">2011:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="45311">Chapter</st>* *<st c="45320">5</st>*<st c="45321">,</st> *<st
    c="45323">Divide-and-Conquer</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
