- en: <st c="0">5</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Solving Recurrence Functions</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="30">In the previous chapter, we discussed the challenges of analyzing
    recursive algorithms, particularly in estimating their computational complexity.</st>
    <st c="178">In this chapter, we will explore three primary methods for solving
    recurrence functions: substitution method, master theorem, and visualization techniques
    using</st> <st c="339">recursion trees.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="355">The substitution method involves constructing rigorous proofs to
    solve recurrence functions.</st> <st c="449">This method, while sometimes intricate,
    is versatile and can handle a wide range of recurrence functions.</st> <st c="555">In
    the substitution method, we employ various techniques, including mathematical
    induction, to validate</st> <st c="659">our solutions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="673">The master theorem, also known as the master method, provides a
    systematic approach to determining the complexity of a recursive algorithm based
    on the parameters of its recurrence function.</st> <st c="865">This theorem offers
    a set of straightforward rules, making it a powerful tool for analyzing many common</st>
    <st c="969">recurrence functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="990">Lastly, recursion trees help visualize the complexity of a problem
    by breaking down the recurrence into a tree structure.</st> <st c="1113">Although
    recursion trees do not provide direct proofs, they offer valuable insights and
    intuitive understanding that can guide us toward a</st> <st c="1252">formal solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1268">Throughout this chapter, we will thoroughly examine the limitations
    of each method and present a comprehensive set of examples for practical application.</st>
    <st c="1423">By the end, readers will have a deeper understanding of how to effectively
    solve recurrence functions using</st> <st c="1531">these techniques.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1548">We will discuss the following topics in</st> <st c="1589">this
    chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1602">The</st> <st c="1607">substitution method</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1626">Recursion tree as a</st> <st c="1647">visualization technique</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1670">The</st> <st c="1675">master theorem</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1689">Beyond the master theorem – the</st> <st c="1722">Akra-Bazzi method</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1739">The substitution method</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1763">The</st> **<st c="1768">substitution method</st>** <st c="1787">encompasses</st>
    <st c="1800">a variety of techniques, including induction, to provide proofs for
    recurrence functions.</st> <st c="1890">Often, we need to be innovative in making
    variable substitutions to transform the recurrence function into a form for which
    we already know the solution.</st> <st c="2044">One key characteristic of this
    method is its flexibility – there can be multiple approaches to solving the same
    recurrence.</st> <st c="2168">Although it does not offer a uniform solution for
    all problems, the substitution method is a powerful tool.</st> <st c="2276">In
    fact, even the master theorem (discussed in the next section) is proven using</st>
    <st c="2357">this method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2369">By employing the substitution method, we can address a wide range
    of recurrence functions.</st> <st c="2461">The process typically involves hypothesizing
    a solution, substituting it into the original recurrence, and then using induction
    to prove that the hypothesis is correct.</st> <st c="2630">This approach allows
    for creativity and adaptability, making it a valuable technique in algorithm analysis.</st>
    <st c="2738">While the substitution method may require careful thought and ingenuity,
    it provides a robust framework for tackling complex recurrences.</st> <st c="2876">This
    method’s versatility and power underscore its importance in the broader context
    of algorithm design</st> <st c="2981">and analysis.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2994">Perhaps the best way to explore the substitution method is through
    practical application with several examples.</st> <st c="3107">By working through
    a variety of recurrence functions, we can better understand the nuances and techniques
    involved in this method.</st> <st c="3238">This hands-on approach will not only
    illustrate the versatility and power of the substitution method but also demonstrate
    how it can be applied to solve different types of problems effectively.</st> <st
    c="3432">Let’s examine some examples to see this method in action and gain a deeper
    appreciation of its utility in algorithm analysis.</st> <st c="3558">Readers should
    note that in this chapter, and throughout the rest of the book, when we refer
    to</st> *<st c="3654">solving a recurrence function</st>*<st c="3683">, we mean
    estimating the complexity or rate of growth.</st> <st c="3738">This generally
    involves determining</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/524.png)
    <st c="3774"><st c="3775">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/525.png)<st
    c="3779"><st c="3785">, and in rare</st> <st c="3799">cases,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="normal">Ω</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/526.png)<st
    c="3806"><st c="3807">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3808">Iteration approach or unrolling the recurrence</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3855">In the</st> <st c="3863">upcoming examples, the substitution method
    is applied by using the iterative approach, also known as</st> **<st c="3964">unrolling
    the recurrence function</st>**<st c="3997">. This</st> <st c="4004">technique
    involves expanding the recurrence step by step to reveal a pattern, which helps
    in deriving a closed-form solution.</st> <st c="4130">By iteratively substituting
    back into the original recurrence, we can systematically identify how the terms
    evolve and</st> <st c="4249">accumulate, leading to a clearer understanding of
    the function’s growth behavior.</st> <st c="4331">This method is particularly
    useful for solving and simplifying complex</st> <st c="4402">recurrence functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="4423">Example 5.1</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4435">Solve the following subtractive recurrence function:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/527.png)<st
    c="4489"><st c="4505">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="4506">Solution</st>**<st c="4515">: To solve the recurrence function,
    we can use the iteration method to find a pattern and derive a closed-form solution.</st>
    <st c="4637">Let’s start by expanding the recurrence step</st> <st c="4682">by
    step:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/528.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow></mrow></mrow></math>](img/529.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>6</mn><mo>)</mo><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>4</mn><mo>)</mo></mrow></mrow></mrow></math>](img/530.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4760">...</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4763">Substitute the following back into the</st> <st c="4803">original
    recurrence:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/527.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/532.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/533.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4900">...</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4903">Continuing this pattern, we get</st> <st c="4936">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/534.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4952">We stop when</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:math>](img/535.png)
    <st c="4965"><st c="4966">reaches the base case, which we assume is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/536.png)
    <st c="5009"><st c="5010">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/537.png)<st
    c="5014"><st c="5020">. For simplicity, let’s assume</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/538.png)<st
    c="5051"><st c="5052">. So, the pattern becomes</st> <st c="5078">the following:</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/539.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5094">Since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/538.png)<st
    c="5100"><st c="5101">, we have</st> <st c="5111">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/541.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5155">To find the number of terms in the sum, we solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mi>k</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/542.png)<st
    c="5204"><st c="5205">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/543.png)<st
    c="5207"><st c="5208">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5209">Thus, the sum becomes</st> <st c="5232">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/544.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5273">This is an</st> <st c="5284">arithmetic series where the first
    term</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/545.png)
    <st c="5323"><st c="5324">and the last term</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/546.png)<st
    c="5343"><st c="5344">. The number of terms</st> <st c="5366">is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="5369"><st c="5370">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5371">The sum of an arithmetic series is given by</st> <st c="5416">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>terms</mtext></mrow><mn>2</mn></mfrac><mo>×</mo><mfenced
    open="(" close=")"><mrow><mtext>first</mtext><mtext>term</mtext><mo>+</mo><mtext>last</mtext><mtext>term</mtext></mrow></mfenced></mrow></mrow></math>](img/548.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5480">So, the following is</st> <st c="5501">the case:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/549.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5528">Therefore, the closed-form solution for the recurrence function
    is</st> <st c="5595">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>4</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow></mrow></math>](img/550.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="5608">This provides us with the</st> <st c="5634">asymptotic complexity</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced open="("
    close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mn>2</mn></msup></mfenced></mrow></mrow></math>](img/551.png)<st
    c="5655"><st c="5657">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5658">In the previous example, we demonstrated how to prove a subtractive
    recurrence function using the</st> <st c="5757">substitution method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5777">Example 5.2</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5789">Solve the following subtractive recurrence function:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)<st
    c="5843"><st c="5863">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5864">Solution</st>**<st c="5873">: This recurrence function describes
    an algorithm where the problem of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="5950"><st c="5999">is reduced to a subproblem of size</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:math>](img/554.png)<st
    c="6034"><st c="6035">. The work done outside of the recursive call is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/555.png)<st
    c="6084"><st c="6085">. We can solve this recurrence using the substitution method
    using iteration or unrolling</st> <st c="6175">the recurrence.</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6190">Let’s expand the recurrence a</st> <st c="6221">few times:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/557.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/558.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="6288">...</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6291">If we continue</st> <st c="6306">this pattern, we eventually reach
    the base case</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/559.png)
    <st c="6355"><st c="6356">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/560.png)
    <st c="6360"><st c="6361">(depending on how the base case is defined).</st> <st
    c="6407">Notice that we get a sum</st> <st c="6432">of squares:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></mfenced><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mn>2</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup></mrow></mrow></math>](img/561.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="6492">The sum of squares from 1 to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="6521"><st c="6570">is a</st> <st c="6575">well-known formula:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/563.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="6638">Therefore, the following is</st> <st c="6666">the case:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></mfenced><mo>+</mo><mfrac><mrow><mi>n</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mfenced
    open="(" close=")"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mn>6</mn></mfrac></mrow></mrow></math>](img/564.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="6712">The exact solution depends on the value of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>)</mo></mrow></mrow></mrow></math>](img/565.png)<st
    c="6755"><st c="6769">, which is in constant time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/566.png)<st
    c="6798"><st c="6800">).</st> <st c="6803">Then, asymptotically, we can say</st>
    <st c="6836">the following:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/567.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="6864">In this example, to implement the substitution method, we iterate
    or unroll the recursion to identify the growth pattern.</st> <st c="6986">The
    recurrence function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)
    <st c="7010"><st c="7030">has a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/569.png)<st
    c="7055"><st c="7062">. This indicates that the algorithm’s runtime grows cubically
    with the</st> <st c="7133">input size.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7144">Example 5.3</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7156">Solve the following subtractive recurrence</st> <st c="7200">function:</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)<st
    c="7210"><st c="7227">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7228">Solution</st>**<st c="7237">: We can solve it by unrolling the
    recurrence and finding</st> <st c="7296">a pattern.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7306">Let’s explain the recurrence function.</st> <st c="7346">This recurrence
    function involves a logarithmic decrease in the subproblem size.</st> <st c="7427">The
    recurrence function</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/571.png)
    <st c="7451"><st c="7469">describes an algorithm where the following is</st> <st
    c="7515">the case:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7524">The problem of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="7545"><st c="7594">is reduced to a subproblem of</st> <st c="7624">size</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7636">The work done outside of the recursive call</st> <st c="7680">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7732">Let’s use an iterative approach by unrolling the recurrence to
    understand the behavior of</st> <st c="7822">the function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/576.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/577.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="7881">...</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7884">Note that each</st> <st c="7900">iteration applies the logarithm
    function to the argument of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi></mml:math>](img/578.png)<st
    c="7960"><st c="7964">. The number of iterations before we reach a base case (such
    as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/579.png)<st
    c="8028"><st c="8029">) is roughly the number of times we can take the logarithm
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="8091"><st c="8140">before it becomes a constant.</st> <st c="8170">This
    is approximately</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mi
    mathvariant="normal">*</mi></msup><mi>n</mi></mrow></mrow></math>](img/581.png)<st
    c="8192"><st c="8193">(the</st> <st c="8198">iterated logarithm).</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8218">The total work done in all iterations is approximately</st> <st
    c="8274">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mo>…</mo><mfenced
    open="(" close=")"><mrow><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mi
    mathvariant="normal">*</mi></msup><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>s</mi></mrow></mfenced></mrow></mrow></math>](img/582.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="8340">The dominant term in the preceding sum is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="8382"><st c="8383">. Each subsequent term grows much slower than the previous
    one due to the repeated application of the logarithm.</st> <st c="8496">Therefore,
    we can say</st> <st c="8518">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="8534">In the previous example, the algorithm’s runtime is primarily dominated
    by the work done outside the recursive calls (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/585.png)<st
    c="8652"><st c="8654">).</st> <st c="8657">The recursive calls do not significantly
    contribute to the overall runtime because the problem size decreases very rapidly
    with each recursion (logarithmically).</st> <st c="8819">The iterated logarithm
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/586.png)<st
    c="8843"><st c="8850">) is a very slow-growing function.</st> <st c="8885">For
    all practical purposes, it can be considered a constant.</st> <st c="8946">This
    is why we can say that the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/587.png)
    <st c="8997"><st c="8998">even though there are</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/588.png)
    <st c="9021"><st c="9027">terms in</st> <st c="9036">the summation.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9050">Guessing and induction approach</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="9082">Example 5.3</st>* <st c="9094">can be</st> <st c="9102">solved
    by guessing and induction approach.</st> <st c="9145">We solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/589.png)
    <st c="9154"><st c="9171">using the substitution method by guessing that</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/590.png)
    <st c="9218"><st c="9219">and proving it by induction.</st> <st c="9249">In</st>
    *<st c="9252">Example 5.4</st>*<st c="9263">, we demonstrate how to solve a recurrence
    function using the guessing and</st> <st c="9338">induction approach.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="9357">Example 5.4</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9369">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/591.png)
    <st c="9376"><st c="9394">by guessing</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/592.png)<st
    c="9406"><st c="9407">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9408">We solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/589.png)
    <st c="9418"><st c="9435">using the substitution method by guessing that</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)
    <st c="9482"><st c="9483">and then proving it</st> <st c="9504">by induction.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9517">Here is the</st> <st c="9530">step-by-step solution:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="9552">Guess</st>** **<st c="9559">the form</st>**<st c="9567">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="9569">We guess that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/584.png)<st
    c="9583"><st c="9584">. Specifically, let’s assume</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="9613"><st c="9614">for some</st> <st c="9624">constant</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/597.png)<st
    c="9633"><st c="9635">.</st></st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="9636">Base case</st>**<st c="9646">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="9648">We need to establish a base case.</st> <st c="9682">For small values
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="9702"><st c="9703">(e.g.,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/599.png)<st
    c="9711"><st c="9712">), the recurrence function simplifies.</st> <st c="9751">Assume</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/600.png)
    <st c="9758"><st c="9759">is a constant</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/601.png)<st
    c="9774"><st c="9775">. Since we are concerned with asymptotic behavior, we focus
    on larger values</st> <st c="9852">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="9855"><st c="9904">.</st></st></st></st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="9905">Induction hypothesis</st>**<st c="9926">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="9928">Assume that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:math>](img/603.png)
    <st c="9940"><st c="9941">holds for all</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></mrow></math>](img/604.png)<st
    c="9956"><st c="9957">. We need to show that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="9980"><st c="9981">also holds.</st></st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="9992">Induction step</st>**<st c="10007">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="10009">Using the recurrence function, we</st> <st c="10043">have</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/570.png)<st
    c="10048"><st c="10065">.</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10066">By the induction hypothesis,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/607.png)<st
    c="10096"><st c="10097">. Substituting this into the recurrence function, we</st>
    <st c="10150">get</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/608.png)<st
    c="10154"><st c="10155">.</st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10156">For our assumption</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:math>](img/596.png)
    <st c="10176"><st c="10177">to hold, we need</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>n</mi><mo>≤</mo><mi>c</mi><mi>n</mi></mrow></mrow></math>](img/610.png)<st
    c="10195"><st c="10196">.</st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="10197">Simplify</st>** **<st c="10207">the inequality</st>**<st c="10221">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="10223">To satisfy the inequality, we</st> <st c="10253">need</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/611.png)<st
    c="10258"><st c="10274">.</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10275">As</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)
    <st c="10279"><st c="10280">grows large,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/613.png)
    <st c="10294"><st c="10302">approaches</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn></mml:math>](img/614.png)<st
    c="10313"><st c="10314">. Therefore, there exists a sufficiently large</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/13.png)
    <st c="10361"><st c="10362">such</st> <st c="10368">that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/616.png)<st
    c="10373"><st c="10374">.</st></st></st></st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="10375">Choosing</st>** **<st c="10385">the constant</st>**<st c="10397">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="10399">We can choose</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    <st c="10413"><st c="10414">such that the preceding condition holds for sufficiently
    large</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="10478"><st c="10527">. For instance, for</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/619.png)<st
    c="10547"><st c="10548">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:math>](img/620.png)<st
    c="10550"><st c="10551">.</st></st></st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10552">This</st> <st c="10558">inequality holds for sufficiently large</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="10598"><st c="10599">. Therefore, our assumption that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/622.png)
    <st c="10632"><st c="10633">is valid.</st> <st c="10644">Thus, we have shown that
    the solution to the</st> <st c="10689">recurrence is</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced><mo>+</mo><mi>n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi>T</mi><mfenced open="("
    close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/623.png)<st
    c="10702"><st c="10735">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10736">By this method of guessing and using induction, we confirmed that
    our initial guess was correct and that the complexity of the recurrence is linear
    in terms</st> <st c="10894">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="10897"><st c="10946">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10947">The guessing step in the guessing and induction method is a critical
    part of solving recurrence functions It involves making an educated hypothesis
    about the form of the solution based on the structure of the recurrence function.</st>
    <st c="11178">Here’s how the guessing step is</st> <st c="11210">typically done:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11225">Understanding the recurrence function</st>**<st c="11263">:
    We begin by closely examining the recurrence function.</st> <st c="11321">We look
    at the components, such as how the problem size reduces in each recursive call
    and the non-recursive cost function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/625.png)<st
    c="11444"><st c="11450">. Then, we compare the recurrence to familiar patterns,
    such as those seen in common algorithms (e.g., divide-and-conquer algorithms such
    as merge sort or</st> <st c="11605">binary search).</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11620">Analyzing the growth rate</st>**<st c="11646">: We consider
    the terms in the recurrence function to infer how they might contribute to the
    overall complexity.</st> <st c="11760">For instance, if the recurrence involves
    terms such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
    <st c="11815"><st c="11816">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/627.png)<st
    c="11820"><st c="11821">, we might guess a logarithmic component in the solution
    since each step reduces the problem size by a factor.</st> <st c="11932">If the
    recurrence includes an additive linear term, such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="11992"><st c="12041">, this suggests the solution might involve a linear or
    non-linear</st> <st c="12107">growth</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math>](img/629.png)<st
    c="12114"><st c="12120">.</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12121">Leveraging experience and patterns</st>**<st c="12156">: We
    use our knowledge of common recurrence functions and their solutions.</st> <st
    c="12232">For example, if the recurrence looks like</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mi>n</mml:mi></mml:math>](img/630.png)<st
    c="12274"><st c="12287">, we might guess</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/631.png)
    <st c="12304"><st c="12320">because this form is typical for divide-and-conquer
    algorithms.</st> <st c="12384">For the recurrence</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mn>1</mml:mn></mml:math>](img/632.png)<st
    c="12403"><st c="12404">, we might guess</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/633.png)
    <st c="12421"><st c="12422">because each step reduces the problem size by one
    with a</st> <st c="12480">constant cost.</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12494">Making an educated guess</st>**<st c="12519">: Based on our
    analysis, we hypothesize a potential form for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/43.png)<st
    c="12581"><st c="12582">. This could be</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/635.png)<st
    c="12598"><st c="12611">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/636.png)<st
    c="12613"><st c="12629">, or even</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/637.png)<st
    c="12639"><st c="12654">. The guess should reflect the expected behavior of the
    recurrence’s growth.</st> <st c="12731">For example, if we see a recursive call
    with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
    <st c="12776"><st c="12777">and a linear term,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/78.png)
    <st c="12797"><st c="12798">might be a</st> <st c="12810">reasonable guess.</st></st></st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12827">Refining the guess</st>**<st c="12846">: Sometimes, we might
    need to refine our guess after initial attempts to validate it using induction.</st>
    <st c="12949">For example, if our guess</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/640.png)
    <st c="12975"><st c="12976">doesn’t satisfy the induction step, we might need
    to consider a higher-order term, such</st> <st c="13065">as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/78.png)<st
    c="13068"><st c="13069">.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="13070">By following</st> <st c="13084">these steps, we systematically
    arrive at a plausible solution that can be rigorously validated.</st> <st c="13180">The
    guessing step combines intuition, experience, and analysis to propose a solution
    that you can then confirm</st> <st c="13291">through induction.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13309">Variable change approach</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="13334">There are</st> <st c="13345">irregular recurrence functions that
    conventional methods, such as those outlined in</st> *<st c="13429">The master
    th</st>**<st c="13442">eorem</st>* <st c="13448">section or even the</st> *<st
    c="13469">Recursion tree as a visualization technique</st>* <st c="13512">section,
    are unable to solve.</st> <st c="13543">In these cases, the substitution method
    offers an alternative solution, alongside advanced, generalized methods, such
    as</st> <st c="13663">the</st> **<st c="13668">Akra-Bazzi method</st>** <st c="13685">(see
    the</st> *<st c="13695">Beyond the master theorem – the Akra-Bazzi</st>* *<st
    c="13738">method</st>* <st c="13744">section).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13754">The</st> **<st c="13759">substitution method</st>** <st c="13778">involves
    transforming the original recurrence into a more manageable form through variable
    change.</st> <st c="13878">This approach can reveal patterns and simplify the
    analysis, making it easier to find a closed-form solution.</st> <st c="13988">By
    carefully choosing new variables, we can convert complex recurrence functions
    into forms that are more straightforward</st> <st c="14110">to solve.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14119">In the next example, we demonstrate how to implement the substitution
    method using variable change to tackle irregular recurrence functions effectively.</st>
    <st c="14273">This example will illustrate the power and flexibility of the substitution
    method in dealing with complex recurrence functions that other methods</st> <st
    c="14419">cannot handle.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="14433">Example 5.5</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14445">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/642.png)<st
    c="14452"><st c="14473">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="14474">In the previous</st> <st c="14491">chapter, we categorized recurrence
    functions into two groups: subtracting (decreasing) and divide-and-conquer (dividing)
    recurrence functions.</st> <st c="14634">While the function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/643.png)
    <st c="14653"><st c="14673">could be considered a sub-category of divide-and-conquer
    recurrence functions, it more accurately belongs to a family of</st> **<st c="14794">substitution</st>**
    **<st c="14807">recurrence functions</st>**<st c="14827">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14828">To solve this recurrence function, we can use a change of variables
    to simplify the recurrence and make it easier</st> <st c="14943">to analyze.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14954">Let</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:math>](img/644.png)<st
    c="14959"><st c="14960">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14961">Then,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>=</mo><mi>m</mi></mrow></mrow></math>](img/645.png)<st
    c="14968"><st c="14975">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14976">Rewriting the recurrence in terms of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)<st
    c="15014"><st c="15015">, we get</st> <st c="15024">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/647.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15040">To simplify notation, let</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/648.png)<st
    c="15066"><st c="15067">. Then we have</st> <st c="15082">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/649.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15114">This is a familiar form of recurrence function for algorithms
    such as the merge sort algorithm (see</st> [*<st c="15214">Chapter 6</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="15223">), which has the recurrence</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/650.png)
    <st c="15252"><st c="15253">with an asymptotic bound of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/651.png)<st
    c="15282"><st c="15283">. Therefore,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/652.png)<st
    c="15296"><st c="15297">. By substituting</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/653.png)
    <st c="15315"><st c="15316">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/654.png)<st
    c="15322"><st c="15323">, we get</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/655.png)<st
    c="15332"><st c="15354">. However, for the sake of thoroughness, let’s assume
    we do not know this result and solve it</st> <st c="15448">in detail.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15458">Now, we solve this new recurrence function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>)</mml:mo></mml:math>](img/656.png)<st
    c="15502"><st c="15503">. Let’s unroll the recurrence a few steps to identify</st>
    <st c="15557">a pattern:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/657.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15569">Substitute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/658.png)
    <st c="15580"><st c="15585">into the</st> <st c="15594">first equation:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi></mml:math>](img/659.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:math>](img/660.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15632">Unroll it one</st> <st c="15646">more step:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/661.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15658">Substitute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>:</mml:mo></mml:math>](img/662.png)
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:math>](img/663.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>m</mml:mi></mml:math>](img/664.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15688">By unrolling</st> <st c="15701">this pattern, we can see that
    at each level, the coefficient of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi></mml:math>](img/665.png)
    <st c="15765"><st c="15766">decreases exponentially, while the coefficient of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="15817"><st c="15818">increases linearly.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15837">We can generalize this pattern after</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="15875"><st c="15876">steps:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mi>m</mml:mi></mml:math>](img/668.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15884">When</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math>](img/669.png)
    <st c="15889"><st c="15890">becomes 1, we have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math>](img/670.png)
    <st c="15910"><st c="15911">, which means</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></math>](img/671.png)<st
    c="15925"><st c="15926">.</st> <st c="15928">Substitute</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></math>](img/672.png)<st
    c="15938"><st c="15940">:</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mi>m</mml:mi></mml:math>](img/673.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>m</mml:mi></mml:math>](img/674.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15974">Given that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/675.png)<st
    c="15985"><st c="15986">, a constant, we denote it</st> <st c="16013">as</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)<st
    c="16016"><st c="16017">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16018">Thus, we have</st> <st c="16033">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>c</mi><mo>+</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi></mrow></mrow></mrow></math>](img/677.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>m</mi><mo>(</mo><mi>c</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow></mrow></mrow></math>](img/678.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="16050">Substitute</st> <st c="16061">back</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/679.png)<st
    c="16066"><st c="16078">:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/680.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="16080">Therefore, the solution to the recurrence function</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/642.png)
    <st c="16131"><st c="16152">is</st> <st c="16155">as follows:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">Θ</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/682.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="16190">In this section, we explained a powerful technique for solving
    recurrence functions by hypothesizing a solution and proving its correctness through
    mathematical induction.</st> <st c="16362">The method involves substituting the
    guessed solution back into the recurrence function to verify if it satisfies the
    original equation.</st> <st c="16499">This approach allows for flexibility and
    creativity in handling a wide variety of recurrence forms, including those that
    are not easily addressed by other methods, such as the master theorem or recursion
    trees.</st> <st c="16710">By iteratively refining the guess and employing induction,
    substitution methods provide a structured way to derive closed-form solutions
    and understand the growth behavior of</st> <st c="16885">recursive algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16906">Recursion tree as a visualization technique</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="16950">The</st> **<st c="16955">recursion tree method</st>** <st c="16976">is
    a</st> <st c="16982">powerful technique for solving and visualizing recurrence
    functions, particularly those that arise in the analysis of divide-and-conquer
    algorithms.</st> <st c="17131">It involves visualizing the recursive process as
    a tree, where each node represents a subproblem, and the edges represent the recursive
    calls.</st> <st c="17274">By summing the costs at each level of the tree, we can
    determine the overall complexity of</st> <st c="17365">the algorithm.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17379">Here’s the step-by-step</st> <st c="17404">explanation of the
    recursion</st> <st c="17433">tree method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="17445">Construct the</st>** **<st c="17460">recursion tree</st>**<st
    c="17474">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="17476">Begin by writing down the original</st> <st c="17511">recurrence
    function</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17530">Each node in the tree represents a call to</st> <st c="17574">the
    recurrence</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17588">The root of the tree corresponds to the original</st> <st c="17638">problem</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17647">The children of a node represent the subproblems generated by
    the</st> <st c="17713">recursive calls</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="17728">Identify</st>** **<st c="17738">the costs</st>**<st c="17747">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="17749">Determine the cost at each node.</st> <st c="17782">This cost
    typically corresponds to the non-recursive work done at that step, often denoted</st>
    <st c="17873">as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="17876"><st c="17879">.</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17880">Write down the cost at the root and propagate it through</st>
    <st c="17938">the tree.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="17947">Expand</st>** **<st c="17955">the tree</st>**<st c="17963">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="17965">Continue expanding the tree by breaking down each subproblem into
    its constituent parts according to the</st> <st c="18070">recurrence function</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18089">This process continues until the subproblems reach the base case
    of</st> <st c="18158">the recursion</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18171">Calculate the total cost at</st>** **<st c="18200">each level</st>**<st
    c="18210">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="18212">Sum the</st> <st c="18219">costs of all nodes at each level of</st>
    <st c="18256">the tree</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18264">Identify the number of nodes at each level and the cost</st> <st
    c="18321">per node</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18329">Sum the costs across</st>** **<st c="18351">all levels</st>**<st
    c="18361">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="18363">Add the costs from all levels of the tree to get the</st> <st
    c="18416">total cost</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18426">Analyze the sum to determine the overall</st> <st c="18468">asymptotic
    complexity</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18489">The recursion tree method involves visualizing the breakdown of
    a recursive problem into smaller subproblems in the form of a tree to analyze
    its complexity.</st> <st c="18648">Starting with the original problem at the root,
    the method entails drawing each level of recursion, where each node represents
    a subproblem and the edges represent recursive calls.</st> <st c="18829">At each
    level, the cost of solving all subproblems is calculated and summed.</st> <st
    c="18906">By expanding the tree until the base case is reached, and summing the
    costs across all levels, the total complexity of the algorithm can be determined.</st>
    <st c="19058">This method provides a clear and systematic way to understand the
    distribution of costs and the overall behavior of recursive algorithms, often
    resulting in identifying the asymptotic complexity of the recurrence.</st> <st
    c="19272">Let’s explore the method in the</st> <st c="19304">next example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="19317">Example 5.6</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19329">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/685.png)
    <st c="19336"><st c="19355">using the recursion</st> <st c="19375">tree method.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19387">Here is</st> <st c="19396">the solution:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="19409">Construct the</st>** **<st c="19424">recursion tree</st>**<st
    c="19438">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="19440">The root of the tree</st> <st c="19461">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19465">This breaks down into 4 subproblems, each of</st> <st c="19510">size</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19516">...</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19519">Level 0:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19530">/ | | \</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19538">Level 1:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mn>4</mn><mi
    mathvariant="normal">*</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo>)</mo></mrow></mrow></mrow></math>](img/689.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19558">/ / / / | | | | \ \ \ \</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19581">Level 2:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mn>4</mn><mi
    mathvariant="normal">*</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>4</mn><mo>)</mo></mrow></mrow></mrow></math>](img/690.png)
    <st c="19591"><st c="19628">(</st><st c="19629">16 subproblems)</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19644">...</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="19647">Identify</st>** **<st c="19657">the costs</st>**<st c="19666">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="19668">The cost</st> <st c="19676">at the root (Level 0)</st> <st c="19699">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19751">At Level 1, each of the 4 subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/626.png)<st
    c="19789"><st c="19790">has a cost</st> <st c="19801">of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mrow></math>](img/693.png)</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19805">At Level 2, each of the 16 subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/627.png)<st
    c="19844"><st c="19845">has a cost</st> <st c="19856">of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>4</mn></mfrac></mstyle></mrow></math>](img/695.png)</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19860">...</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="19863">Expand</st>** **<st c="19871">the tree</st>**<st c="19879">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="19881">Continue expanding until the subproblems reach the base case (</st><st
    c="19943">e.g.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/579.png)<st
    c="19950"><st c="19951">)</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19952">The number of levels in the tree is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/697.png)
    <st c="19988"><st c="19989">because the problem size is halved at</st> <st c="20028">each
    level</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20038">Calculate the total cost at</st>** **<st c="20067">each level</st>**<st
    c="20077">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="20079">Level 0</st>**<st c="20086">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20145">Level 1</st>**<st c="20152">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>4</mml:mn><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:math>](img/699.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20172">Level 2</st>**<st c="20179">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>16</mml:mn><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi></mml:math>](img/700.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20196">General Level</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)**<st
    c="20211">: Cost =</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/702.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20221">Sum the costs across</st>** **<st c="20242">all levels</st>**<st
    c="20252">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="20254">The total cost</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
    <st c="20269"><st c="20270">is the sum of the costs at</st> <st c="20298">all
    levels:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:math>](img/704.png)</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20342">This is a geometric series with the first term</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/705.png)
    <st c="20389"><st c="20390">and the common</st> <st c="20406">ratio</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>r</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/706.png)<st
    c="20412"><st c="20413">:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mo>=</mo><mi>a</mi><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mi>r</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mstyle></mrow></mrow></math>](img/707.png)</st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20415">In our case,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/705.png)<st
    c="20428"><st c="20429">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>r</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/706.png)<st
    c="20431"><st c="20432">,</st> <st c="20434">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/710.png)<st
    c="20438"><st c="20439">:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/711.png)</st></st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20441">Simplifying, we get the following:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mi>n</mml:mi></mml:math>](img/712.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20494">Asymptotically, the dominant term is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/713.png)<st
    c="20531"><st c="20535">, so we have the</st> <st c="20552">following:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/714.png)</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20564">The recursion tree method</st> <st c="20590">provides a clear
    visual representation of how a recursive algorithm breaks down a problem into
    subproblems.</st> <st c="20698">By summing the costs at each level of the tree,
    we can determine the total complexity of the algorithm.</st> <st c="20802">This
    method is particularly useful for understanding and solving complex recurrence
    functions, offering insight into the behavior and efficiency of</st> <st c="20950">divide-and-conquer
    algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20980">The master theorem</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="20999">In the</st> <st c="21007">analysis of algorithms, the</st> **<st
    c="21035">master theorem</st>** <st c="21049">plays a crucial role in solving
    recurrences for divide-and-conquer algorithms.</st> <st c="21129">Introduced in
    1980, it has become a mainstream approach for estimating the complexity of a wide
    range of recurrence functions.</st> <st c="21256">The master theorem provides
    a straightforward framework for determining the asymptotic behavior of recurrences
    of the</st> <st c="21374">following form:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/715.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21410">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math>](img/716.png)
    <st c="21416"><st c="21417">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>></mml:mo><mml:mn>1</mml:mn></mml:math>](img/717.png)
    <st c="21422"><st c="21426">are constants, and</st> *<st c="21445">f(n)</st>*<st
    c="21449">, the driving function, is an asymptotically positive function bounded
    by polynomial functions.</st> <st c="21545">This means there exist two polynomial
    functions</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/718.png)
    <st c="21593"><st c="21594">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/719.png)
    <st c="21599"><st c="21600">such that the following is</st> <st c="21628">the
    case:</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>g</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/720.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21639">The</st> <st c="21643">importance of the master theorem lies in
    its ability to simplify the complexity analysis of many common algorithms, such
    as merge sort, quicksort, and binary search, among others.</st> <st c="21823">By
    categorizing the behavior of the recurrence based on the relationship between</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="21904"><st c="21907">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="21911"><st c="21912">, the master theorem allows for quick and accurate complexity
    estimation without requiring detailed,</st> <st c="22013">case-by-case analysis.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22035">Although we do not provide proof of the master theorem here, readers
    can refer to the references at the end of this chapter for detailed proof and
    further reading.</st> <st c="22200">Understanding the master theorem and its applications
    is essential for anyone studying algorithm design and analysis, as it forms the
    foundation for evaluating the efficiency of many</st> <st c="22383">recursive
    algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22404">Let’s explore the key concepts of the master theorem, which are
    essential for understanding and describing the different cases of</st> <st c="22535">this
    method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="22547">Critical exponent (</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/723.png)****<st
    c="22569">)</st>**<st c="22570">: This value,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>w</mi><mo>=</mo><msub><mi>log</mi><mi>b</mi></msub><mi>a</mi></mrow></mrow></math>](img/724.png)<st
    c="22584"><st c="22585">, represents a threshold for comparing the</st> <st c="22628">growth
    rates of the driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="22665"><st c="22668">and the recursive part of the</st> <st c="22698">recurrence
    function.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22718">Watershed function (</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/726.png)****<st
    c="22741">)</st>**<st c="22742">: This function,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/727.png)<st
    c="22759"><st c="22770">, serves as a</st> *<st c="22784">dividing line</st>*
    <st c="22797">between the cases of</st> <st c="22818">the master theorem.</st>
    <st c="22839">It tells us the growth rate of the recursion if the driving function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)
    <st c="22908"><st c="22913">were negligible.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22929">Case 1 – dominance of recursive calls or leaf-heavy recursion
    trees</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="22997">In</st> *<st c="23001">Case 1</st>*<st c="23007">, the</st> <st
    c="23013">work done outside the recursive calls (the driving function</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)<st
    c="23073"><st c="23078">) is dominated by the work done within the recursive calls.</st>
    <st c="23138">The driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="23159"><st c="23164">grows polynomially but at a slower rate than the watershed
    function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/731.png)<st
    c="23232"><st c="23233">. More formally, this is</st> <st c="23258">as follows:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><msup><mi>n</mi><mi>c</mi></msup></mfenced></mrow></mrow></math>](img/732.png)<st
    c="23269"><st c="23271">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mi>w</mml:mi></mml:math>](img/733.png)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23278">Or, equivalently, this is</st> <st c="23304">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/734.png)
    <st c="23315"><st c="23328">for some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>ε</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/735.png)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23338">This means that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/736.png)
    <st c="23354"><st c="23358">is upper-bounded by a polynomial with a smaller exponent
    than</st> <st c="23420">the watershed.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23434">Why is</st> *<st c="23442">Case 1</st>* <st c="23448">leaf-heavy?</st>
    <st c="23461">To</st> <st c="23463">understand why</st> *<st c="23479">Case 1</st>*
    <st c="23485">is called</st> *<st c="23496">leaf-heavy</st>*<st c="23506">, imagine
    a recursion tree representing the algorithm’s execution.</st> <st c="23573">Each
    node represents a recursive call, and its children are the subproblems.</st> <st
    c="23650">In this case, the work done at each level of the tree (represented by</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="23720"><st c="23725">) is relatively small compared to the number of recursive
    calls.</st> <st c="23790">As a result, the majority of the work is done on the
    leaves of the recursion tree, hence the</st> <st c="23883">term</st> **<st c="23888">leaf-heavy</st>**<st
    c="23898">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23899">When the recursive calls dominate, the overall time complexity
    of the algorithm is determined by the number of leaves in the recursion tree.</st>
    <st c="24041">This number grows exponentially with the depth of the tree.</st>
    <st c="24101">Since the depth of the tree is logarithmic in the input size (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi></mml:math>](img/738.png)<st
    c="24163"><st c="24170">), the overall time complexity becomes</st> <st c="24209">the
    following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/739.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="24247">In other words, the time complexity is dominated by the recursive
    splitting of the problem into smaller subproblems.</st> <st c="24364">If the work
    done outside the recursive calls (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="24410"><st c="24414">) is small compared to the work done inside</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/741.png)<st
    c="24458"><st c="24459">, then most of the time is spent in the recursive calls,
    making the recursion tree leaf-heavy.</st> <st c="24554">In this scenario, the
    overall runtime is primarily determined by how many times you can divide the problem
    before reaching the base case.</st> <st c="24692">This is captured by the exponent</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:math>](img/742.png)<st
    c="24725"><st c="24737">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24738">Example 5.7</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24750">Consider this recurrence:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/743.png)<st
    c="24777"><st c="24778">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24779">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/744.png)<st
    c="24786"><st c="24787">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)<st
    c="24789"><st c="24790">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow></mrow></mrow></math>](img/746.png)<st
    c="24796"><st c="24797">. We have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>w</mi><mo>=</mo><msub><mi>log</mi><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/747.png)<st
    c="24807"><st c="24808">. Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/748.png)<st
    c="24816"><st c="24817">,</st> *<st c="24819">Case 1</st>* <st c="24825">applies,
    and the time complexity is</st> <st c="24862">as follows:</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/749.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="24875">Case 2 – balanced growth or balanced recursion trees</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="24927">Case 2</st>* <st c="24934">of the</st> <st c="24942">master
    theorem deals with scenarios where the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/750.png)<st
    c="25027"><st c="25033">) grows at roughly the same rate as the work done within
    the recursive calls.</st> <st c="25111">This leads to a balanced recursion tree,
    where each level contributes a comparable amount of work.</st> <st c="25210">In</st>
    *<st c="25213">Case 2</st>*<st c="25219">, the driving function</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/751.png)
    <st c="25242"><st c="25247">grows polynomially at the same rate as the watershed
    function, potentially with an additional logarithmic factor.</st> <st c="25361">More
    formally, this is</st> <st c="25384">as follows:</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/752.png)
    <st c="25395"><st c="25397">for</st> <st c="25402">some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></mrow></math>](img/753.png)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25408">This</st> <st c="25413">means that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/754.png)
    <st c="25424"><st c="25428">is tightly bounded (both above and below) by a function
    proportional to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/755.png)
    <st c="25500"><st c="25501">multiplied by a</st> <st c="25518">logarithmic factor.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25537">Why is</st> *<st c="25545">Case 2</st>* *<st c="25551">balanced</st>*<st
    c="25560">? In a recursion tree for</st> *<st c="25586">Case 2</st>*<st c="25592">,
    the work done at each level is roughly proportional to the number of nodes at
    that level.</st> <st c="25684">Since the number of nodes at each level increases
    exponentially with depth, the work done at each level also increases exponentially.</st>
    <st c="25818">However, the logarithmic factor in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/756.png)
    <st c="25853"><st c="25858">slows down this increase, leading to a more</st> **<st
    c="25902">balanced</st>** <st c="25910">distribution of work throughout</st> <st
    c="25943">the tree.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25952">When the work is balanced across the levels of the recursion tree,
    the overall time complexity is determined by the total work done across all levels.</st>
    <st c="26104">This can be calculated by summing the work at each level, which
    turns out to be</st> <st c="26184">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/757.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="26242">In other words, the time complexity is the product of the watershed
    function and an additional logarithmic factor that accounts for the work done
    at</st> <st c="26391">each level.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26402">If the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="26449"><st c="26455">) grows at roughly the same rate as the work done inside
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/759.png)<st
    c="26513"><st c="26521">, then the recursion tree is balanced.</st> <st c="26560">Each
    level contributes significantly to the overall runtime.</st> <st c="26621">The
    logarithmic factor in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/760.png)
    <st c="26647"><st c="26648">represents the extra work done at each level due to
    the balanced nature of</st> <st c="26724">the recursion.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="26738">Example 5.8</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26750">Consider this</st> <st c="26765">recurrence:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/761.png)<st
    c="26777"><st c="26782">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26783">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/762.png)<st
    c="26790"><st c="26791">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/763.png)<st
    c="26793"><st c="26794">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></mrow></math>](img/764.png)<st
    c="26800"><st c="26801">. We have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/765.png)<st
    c="26811"><st c="26823">. Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/766.png)<st
    c="26831"><st c="26857">,</st> *<st c="26859">Case 2</st>* <st c="26865">applies
    with k = 1, and the time complexity is</st> <st c="26913">as follows:</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/767.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="26955">Case 3 – dominance of non-recursive work or root-heavy recursion
    trees</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="27025">Case 3</st>* <st c="27032">of the</st> <st c="27039">master
    theorem addresses scenarios where the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/494.png)<st
    c="27124"><st c="27130">) significantly dominates the work done within the recursive
    calls.</st> <st c="27198">This leads to a “root-heavy” recursion tree, where the
    majority of the work is concentrated at the</st> <st c="27297">top levels.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27308">In</st> *<st c="27312">Case 3</st>*<st c="27318">, the driving
    function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="27341"><st c="27344">grows polynomially at a faster rate than the watershed
    function, potentially with an additional logarithmic factor.</st> <st c="27460">More
    formally, this is</st> <st c="27483">as follows:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/770.png)
    <st c="27494"><st c="27509">for</st> <st c="27513">some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>ε</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/735.png)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27519">This means that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)
    <st c="27535"><st c="27538">is lower-bounded by a polynomial with a larger exponent
    than</st> <st c="27599">the watershed.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27613">In addition to the growth rate condition,</st> *<st c="27656">Case
    3</st>* <st c="27662">also requires a regularity condition to hold:</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi mathvariant="normal">
    </mi><mi>a</mi><mi>f</mi><mfenced open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle></mfenced><mo>≤</mo><mi>c</mi><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/773.png) <st
    c="27708"><st c="27710">for some constant</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/774.png)
    <st c="27729"><st c="27730">and sufficiently</st> <st c="27748">large</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="27754"><st c="27803">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27804">This condition ensures that the work done at each level of the
    recursion tree does not grow too quickly as we move down</st> <st c="27925">the
    tree.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27934">Why is</st> *<st c="27942">Case 3</st>* <st c="27948">root-heavy?</st>
    <st c="27961">Imagine the recursion tree again.</st> <st c="27995">In</st> *<st
    c="27998">Case 3</st>*<st c="28004">, the work done at the root of the tree (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="28045"><st c="28051">) is much larger than the work done in the subproblems.</st>
    <st c="28107">As we go down the tree, the work done at each level decreases significantly.</st>
    <st c="28184">This concentration of work at the top levels is why</st> *<st c="28236">Case
    3</st>* <st c="28242">is</st> <st c="28246">called</st> **<st c="28253">root-heavy</st>**<st
    c="28263">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28264">When the non-recursive work dominates, the overall time complexity
    of the algorithm is primarily determined by the work done at the root of the recursion
    tree, which is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/777.png)<st
    c="28434"><st c="28439">. Therefore, the time complexity becomes</st> <st c="28480">the
    following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow></mrow></mrow></math>](img/778.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="28510">If the work done outside the recursive calls (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/779.png)<st
    c="28556"><st c="28562">) is much larger than the work</st> <st c="28593">done
    inside</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/780.png)<st
    c="28604"><st c="28608">), then most of the time is spent at the beginning, making
    the recursion tree “root-heavy.” In this scenario, the overall runtime is primarily
    determined by how much work is done before you start splitting the problem</st>
    <st c="28826">into subproblems.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="28843">Example 5.9</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28855">Consider the</st> <st c="28869">following recurrence:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/781.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="28892">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/782.png)<st
    c="28898"><st c="28899">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/783.png)<st
    c="28905"><st c="28911">. We have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/784.png)<st
    c="28921"><st c="28933">. Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/785.png)
    <st c="28941"><st c="28964">and if the regularity condition holds,</st> *<st c="29003">Case
    3</st>* <st c="29009">applies, and the time complexity is</st> <st c="29046">as
    follows:</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/786.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="29071">To evaluate</st> <st c="29083">the regularity condition, we check
    if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/787.png)
    <st c="29121"><st c="29127">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>≤</mml:mo><mml:mn>0.5</mml:mn></mml:math>](img/788.png)<st
    c="29133"><st c="29136">. The regularity condition holds and</st> *<st c="29173">Case
    3</st>* <st c="29179">applies to</st> <st c="29191">this problem.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29204">The regularity condition is crucial for</st> *<st c="29245">Case
    3</st>*<st c="29251">. Without it, the theorem’s conclusions might not hold.</st>
    <st c="29307">Some functions, such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)<st
    c="29331"><st c="29336">, might appear to fit</st> *<st c="29358">Case 3</st>*
    <st c="29364">at first but fail the</st> <st c="29387">regularity condition.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29408">Modified master theorem to solve subtracting recurrence functions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="29474">The master theorem</st> <st c="29494">can be extended to handle
    a special case of subtracting recurrence functions of the</st> <st c="29578">following
    form:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/790.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="29595">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/791.png)
    <st c="29601"><st c="29602">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></mrow></math>](img/753.png)<st
    c="29608"><st c="29609">. Let’s break this</st> <st c="29628">down further:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/793.png)
    <st c="29641"><st c="29643">represents the number of subproblems in the subtracting</st>
    <st c="29700">recursive function</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>></mo><mn>0</mn></mrow></mrow></math>](img/794.png)
    <st c="29718"><st c="29720">is the size of the reduction for each subproblem,
    with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mi>b</mi></mrow></mrow></math>](img/795.png)
    <st c="29776"><st c="29794">being the size of</st> <st c="29812">each subproblem</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29827">In this type of problem, we have three</st> <st c="29867">distinct
    cases:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="29882">Case 1</st>**<st c="29889">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="29895"><st c="29900">,</st> <st c="29902">then</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mi>k</mi></msup></mfenced></mrow></mrow></math>](img/797.png)<st
    c="29906"><st c="29920">.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29921">When the number of subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/798.png)
    <st c="29953"><st c="29954">is less than 1, the recurrence is dominated by the
    driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="30023"><st c="30026">. Thus, the overall complexity is directly given</st>
    <st c="30075">by</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/800.png)<st
    c="30078"><st c="30081">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="30082">Case 2</st>**<st c="30089">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)<st
    c="30095"><st c="30096">,</st> <st c="30098">then</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mfenced></mrow></mrow></math>](img/802.png)<st
    c="30102"><st c="30117">.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30118">When</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/803.png)
    <st c="30124"><st c="30125">equals 1, each subproblem contributes equally to the
    overall complexity, leading to an additional factor of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="30234"><st c="30283">in the final solution.</st> <st c="30306">Therefore,
    the complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/805.png)
    <st c="30335"><st c="30336">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="30337">Case 3</st>**<st c="30344">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>1</mn></mrow></mrow></math>](img/806.png)<st
    c="30350"><st c="30357">,</st> <st c="30359">then</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi mathvariant="normal">θ</mi><mfenced
    open="(" close=")"><mrow><msup><mi>a</mi><mrow><mi>n</mi><mo>/</mo><mi>b</mi></mrow></msup><mo>.</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mfenced></mrow></mrow></math>](img/807.png)<st
    c="30363"><st c="30386">.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30387">When the</st> <st c="30397">number of subproblems</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="30419"><st c="30439">is greater than 1, the recurrence function grows exponentially.</st>
    <st c="30503">The overall complexity is then influenced by the combination of
    the exponential growth factor</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup></mml:math>](img/809.png)
    <st c="30597"><st c="30598">and the driving function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="30624"><st c="30627">, leading</st> <st c="30637">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/811.png)<st
    c="30640"><st c="30651">.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="30652">Example 5.10</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30665">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/812.png)<st
    c="30672"><st c="30694">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="30695">Solution</st>**<st c="30704">: Let’s identify the</st> <st
    c="30726">key parameters:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>0.5</mn></mrow></mrow></math>](img/813.png)
    <st c="30741"><st c="30743">is the factor by which the number of subproblems decreases
    with</st> <st c="30808">each recursion</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/814.png)
    <st c="30822"><st c="30824">is the amount by which the problem size decreases
    with</st> <st c="30880">each recursion</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/470.png)
    <st c="30894"><st c="30896">is the exponent of the polynomial</st> <st c="30931">term</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="30985">Since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="30991"><st c="30996">, we can apply</st> *<st c="31011">Case 1</st>*<st c="31017">:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/818.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31020">In our example, we have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>0.5</mn></mrow></mrow></math>](img/819.png)<st
    c="31044"><st c="31045">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/820.png)<st
    c="31047"><st c="31048">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/821.png)<st
    c="31054"><st c="31070">. Since all the conditions are met,</st> *<st c="31106">Case
    1</st>* <st c="31112">tells us</st> <st c="31122">the following:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/749.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31138">This means that the time complexity of the algorithm described
    by the recurrence function is linear (i.e., it grows proportionally to the input
    size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)<st
    c="31287"><st c="31288">).</st> <st c="31291">The cost of the recursive calls
    diminishes rapidly due to the factor of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0.5</mml:mn></mml:math>](img/824.png)<st
    c="31363"><st c="31364">, and the linear term</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="31386"><st c="31435">ultimately dominates</st> <st c="31456">the runtime.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31468">Example 5.11</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31481">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/552.png)<st
    c="31488"><st c="31508">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31509">Solution</st>**<st c="31518">: Let’s identify the key parameters:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)<st
    c="31556"><st c="31557">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/512.png)<st
    c="31559"><st c="31560">,</st> <st c="31562">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:math>](img/829.png)<st
    c="31566"><st c="31567">.</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31568">Since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/469.png)<st
    c="31575"><st c="31576">, we can apply</st> *<st c="31591">Case 2</st>*<st c="31597">:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/831.png)<st
    c="31599"><st c="31600">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31601">Example 5.12</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31614">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:math>](img/832.png)<st
    c="31621"><st c="31622">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31623">Solution</st>**<st c="31632">: Let’s identify the key parameters:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math>](img/833.png)<st
    c="31670"><st c="31671">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/834.png)<st
    c="31673"><st c="31674">,</st> <st c="31676">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/835.png)<st
    c="31680"><st c="31681">.</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31682">In our</st> <st c="31690">problem, we have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/836.png)<st
    c="31707"><st c="31732">, which is greater than 1\.</st> <st c="31759">Therefore,
    we fall into</st> *<st c="31783">Case 3</st>* <st c="31789">of the modified master
    theorem.</st> <st c="31822">Substituting our values, we get</st> <st c="31854">the
    following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi
    mathvariant="normal">*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi
    mathvariant="normal">*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/837.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31881">The time complexity of this algorithm is exponential, specifically</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>*</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/838.png)<st
    c="31948"><st c="31964">. This means that the runtime grows incredibly quickly
    as the input size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)
    <st c="32037"><st c="32038">increases.</st> <st c="32050">The exponential term</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/840.png)
    <st c="32071"><st c="32072">dominates the growth, and the linear term</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="32115"><st c="32164">becomes negligible as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="32186"><st c="32235">gets larger.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32247">Master theorem limitations</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="32274">The</st> <st c="32278">master theorem is a powerful tool for analyzing
    divide-and-conquer algorithms.</st> <st c="32358">However, its effectiveness is
    confined to a specific class of recurrence functions.</st> <st c="32442">Recognizing
    these limitations is crucial for choosing the right approach when analyzing more</st>
    <st c="32535">complex algorithms:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="32554">Restrictions on the driving</st>** **<st c="32583">function</st>**
    **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">f</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/843.png)**<st
    c="32593">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32594">Non-polynomial functions</st>**<st c="32618">: The master theorem
    assumes that the work done outside the recursive calls (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)<st
    c="32696"><st c="32702">) is a polynomial function (e.g.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/845.png)<st
    c="32736"><st c="32737">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/846.png)<st
    c="32739"><st c="32748">).</st> <st c="32751">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="32754"><st c="32759">is exponential (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/848.png)<st
    c="32775"><st c="32777">), logarithmic (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/849.png)<st
    c="32793"><st c="32799">), factorial (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:math>](img/850.png)<st
    c="32813"><st c="32817">), or another non-polynomial form, the master theorem
    cannot be</st> <st c="32881">directly applied.</st></st></st></st></st></st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32898">Non-positive functions</st>**<st c="32921">: The master theorem
    requires</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/777.png)
    <st c="32952"><st c="32957">to be strictly positive for all relevant input sizes.</st>
    <st c="33011">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi></mml:math>](img/852.png)<st
    c="33014"><st c="33016">) becomes negative or zero, the theorem’s assumptions</st>
    <st c="33070">are violated.</st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33083">Non-smooth functions</st>**<st c="33104">: The master theorem
    assumes a certain level of smoothness in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/853.png)<st
    c="33167"><st c="33168">. Functions with abrupt changes, discontinuities, or piecewise
    definitions may not fit within the</st> <st c="33266">theorem’s framework.</st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33286">Irregular functions</st>**<st c="33306">: The theorem’s effectiveness
    hinges on</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/754.png)
    <st c="33347"><st c="33351">having a regular growth pattern compared to the recursive
    part of the function.</st> <st c="33431">Functions</st> <st c="33441">with oscillatory
    behavior or variable exponents can challenge the</st> <st c="33507">theorem’s
    applicability.</st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33531">Constraints on recurrence parameters (</st>****![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">a</mml:mi></mml:math>](img/855.png)****<st c="33572">and</st>**
    **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">b</mml:mi></mml:math>](img/856.png)****<st c="33577">)</st>**<st
    c="33578">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33579">Non-constant parameters</st>**<st c="33602">: The master theorem
    assumes that the number of subproblems (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/857.png)<st
    c="33664"><st c="33671">) and the factor by which the input size decreases (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/858.png)<st
    c="33723"><st c="33725">) are constants.</st> <st c="33742">If either of these
    depends on the input size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="33787"><st c="33836">, the master theorem is no</st> <st c="33863">longer applicable.</st></st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33881">Non-integer divisors</st>**<st c="33902">: The theorem assumes
    that the input is divided evenly into subproblems (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:math>](img/860.png)<st
    c="33976"><st c="33978">).</st> <st c="33981">Fractional or irrational values
    for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/861.png)
    <st c="34017"><st c="34018">can lead to complications that the theorem is not
    equipped</st> <st c="34078">to handle.</st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34088">Limitations on the recurrence</st>** **<st c="34119">function</st>**
    **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/862.png)**<st
    c="34129">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34130">Non-monotonic functions</st>**<st c="34153">: The master theorem
    assumes that the time complexity function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/683.png)
    <st c="34217"><st c="34218">is monotonically increasing, meaning the algorithm’s
    runtime doesn’t decrease as the input size increases.</st> <st c="34326">Functions
    such as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/864.png)
    <st c="34344"><st c="34358">violate</st> <st c="34366">this assumption.</st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34382">Alternative approaches</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="34405">When the master</st> <st c="34421">theorem’s conditions are not
    met, alternative methods can be used to analyze the</st> <st c="34503">recurrence
    function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="34523">The Akra-Bazzi method</st>**<st c="34545">: This</st> <st c="34552">method
    generalizes the master theorem and can handle a wider range of recurrence functions,
    including those with non-polynomial differences.</st> <st c="34694">It provides
    a systematic way to calculate the asymptotic complexity of</st> <st c="34765">these
    recurrences.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34783">The substitution method</st>**<st c="34807">: This</st> <st
    c="34814">involves guessing a solution for the recurrence and then proving its
    correctness using</st> <st c="34902">mathematical induction.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34925">The iteration method</st>**<st c="34946">: This involves repeatedly
    expanding the recurrence function to uncover a pattern that leads to a</st> <st
    c="35045">closed-form solution.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35066">The recursive tree method</st>**<st c="35092">: This</st> <st
    c="35099">visual approach helps understand the structure of the recursive calls
    and estimate the overall work done at</st> <st c="35208">each level.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35219">In the</st> <st c="35227">next section, we introduce the Akra-Bazzi
    method, which is a generalization of the master theorem.</st> <st c="35326">This
    method extends our capability to solve a broader range of recurrence functions,
    addressing many of the limitations found in the</st> <st c="35459">master theorem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35474">Let’s review several examples that demonstrate the limitations
    of the</st> <st c="35545">master theorem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35560">Example 5.13</st>**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="35573">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/865.png)<st
    c="35580"><st c="35581">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35582">Solution</st>**<st c="35591">: The master theorem does not
    apply here since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/866.png)
    <st c="35639"><st c="35640">is</st> <st c="35644">not constant.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35657">To solve this</st> <st c="35671">recurrence, we need to explore
    other methods such as the substitution method, the iteration method, or the Akra-Bazzi
    method, which can handle the variable nature of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi></mrow></math>](img/867.png)<st
    c="35838"><st c="35839">and the complex form</st> <st c="35860">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/868.png)<st
    c="35863"><st c="35872">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35873">Example 5.14</st>**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="35886">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mn>2</mn><mi>T</mi><mfenced
    open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mfenced><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/869.png)<st
    c="35893"><st c="35894">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35895">Solution</st>**<st c="35904">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35906">Before examining each case of the master theorem, let’s review
    the components of the</st> <st c="35991">recurrence function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/870.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36014">The critical exponent is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math>](img/731.png)
    <st c="36039"><st c="36040">where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>0</mn><mo><</mo><mi>w</mi><mo><</mo><msub><mi>log</mi><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/873.png)
    <st c="36047"><st c="36059">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mrow></mrow></mrow></math>](img/874.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36062">Now, let’s evaluate each case in the</st> <st c="36099">master
    theorem:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="36114">Case 1</st>**<st c="36121">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36123">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi>O</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mrow><mn>1</mn><mo>−</mo><mi>ε</mi></mrow></msup></mfenced></mrow></mrow></math>](img/875.png)
    <st c="36132"><st c="36149">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36150">This is</st> <st c="36159">not true because</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="36176"><st c="36181">grows faster</st> <st c="36194">than</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:math>](img/877.png)<st
    c="36199"><st c="36203">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="36204">Case 2</st>**<st c="36211">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36213">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi>θ</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>k</mi></msup><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/878.png)<st
    c="36222"><st c="36240">. We need to find a</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="36260"><st c="36261">such that the following</st> <st c="36286">is true:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>k</mi></msup><mi>n</mi><mo>≤</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac><mo>≤</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mrow><mfenced
    open="{" close="}"><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mi>n</mi></mrow></msup></mrow></mrow></math>](img/880.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36298">There is no such</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="36315"><st c="36316">that can sandwich</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="36335"><st c="36340">between</st> <st c="36348">these functions.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="36364">Case 3</st>**<st c="36371">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36373">Check if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle><mo>=</mo><mi
    mathvariant="normal">Ω</mi><mfenced open="(" close=")"><msup><mi mathvariant="normal">n</mi><mrow><mn>1</mn><mo>+</mo><mi>ε</mi></mrow></msup></mfenced></mrow></mrow></math>](img/883.png)<st
    c="36382"><st c="36400">. This might seem applicable because</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/884.png)
    <st c="36437"><st c="36442">grows faster than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msup></mml:math>](img/885.png)<st
    c="36460"><st c="36461">. However, we must also evaluate the</st> <st c="36498">regularity
    condition:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>a</mml:mi><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/886.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36531">Substituting, we get</st> <st c="36552">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/887.png)
    <st c="36566"><st c="36588">for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/888.png)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mn>1</mn><mrow><mi>log</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>≤</mo><mfrac><mi>c</mi><mrow><mi>log</mi><mi>n</mi></mrow></mfrac></mrow></mrow></math>](img/889.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36604">For large</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="36614"><st c="36663">, there is no constant</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/888.png)
    <st c="36686"><st c="36696">that satisfies this condition.</st> <st c="36727">Thus,</st>
    *<st c="36733">Case 3</st>* <st c="36739">does</st> <st c="36745">not apply.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="36755">The recurrence function of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math>](img/892.png)
    <st c="36783"><st c="36803">in the previous example does not fit any case of the
    master theorem.</st> <st c="36872">This demonstrates a limitation of the master
    theorem: it requires</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/893.png)
    <st c="36938"><st c="36943">to be bounded by polynomial functions and to have
    a polynomial difference with the critical exponent</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="italic">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="37044"><st c="37045">. Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/895.png)
    <st c="37053"><st c="37062">does not fit within these bounds, highlighting the
    need for alternative methods, such as the substitution method, the iteration method,
    or the Akra-Bazzi method to solve</st> <st c="37232">this recurrence.</st></st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37248">Example 5.15</st>**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="37261">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/896.png)<st
    c="37268"><st c="37273">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37274">Solution</st>**<st c="37283">: The master theorem does not
    apply</st> <st c="37320">since</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/897.png)<st
    c="37326"><st c="37327">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37328">Example 5.16</st>**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="37341">Solve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>64</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/898.png)<st
    c="37348"><st c="37371">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37372">Solution</st>**<st c="37381">: The</st> <st c="37388">master
    theorem does not apply</st> <st c="37418">because</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/899.png)<st
    c="37426"><st c="37435">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37436">Example 5.17</st>**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="37449">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/900.png)<st
    c="37456"><st c="37457">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37458">Solution</st>**<st c="37467">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37469">This recurrence function describes a divide-and-conquer algorithm
    where the following is</st> <st c="37558">the case:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37567">The problem of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="37588"><st c="37637">is divided into one subproblem of</st> <st c="37671">size</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:math>](img/902.png)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37680">The work done outside the recursive call</st> <st c="37721">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/903.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37736">Why doesn’t the master theorem</st> <st c="37767">directly apply?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37782">The master theorem works best with functions that have simple
    polynomial growth.</st> <st c="37864">In this case, the term</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/903.png)
    <st c="37887"><st c="37899">isn’t a straightforward polynomial due to the presence
    of the</st> <st c="37961">cosine function.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37977">One alternative approach is to simplify the non-recursive part
    of the recurrence function.</st> <st c="38069">We can leverage the fact that the
    cosine function oscillates between -1</st> <st c="38141">and 1:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38147">-</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>≤</mo><mn>1</mn></mrow></mrow></math>](img/905.png)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38150">Multiplying by -1 and adding 2, we get</st> <st c="38189">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>1</mn><mo>≤</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>≤</mo><mn>3</mn></mrow></mrow></math>](img/906.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="38205">Therefore, the following is</st> <st c="38233">the case:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>n</mi><mo>≤</mo><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo><mo>≤</mo><mn>3</mn><mi>n</mi></mrow></mrow></mrow></math>](img/907.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="38269">This tells us</st> <st c="38282">that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>n</mi><mo>(</mo><mn>2</mn><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/908.png)
    <st c="38288"><st c="38298">is bounded above and below by linear functions.</st>
    <st c="38346">Now, we apply the master theorem to the function with bounds.</st>
    <st c="38408">We can create two new recurrence functions based on the lower and
    upper bounds of the</st> <st c="38494">non-recursive term:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="38513">Lower bound</st>****![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>:</mo><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/909.png)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="38527">Upper</st>** **<st c="38533">bound</st>**<st c="38538">:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>n</mml:mi></mml:math>](img/910.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="38561">Now, both of these recurrences fit the form of the</st> <st c="38612">master
    theorem:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)
    <st c="38627"><st c="38629">(number</st> <st c="38638">of subproblems)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)
    <st c="38653"><st c="38655">(factor by which the input</st> <st c="38683">size
    decreases)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>n</mi></mrow></mrow></mrow></math>](img/746.png)
    <st c="38698"><st c="38700">(for the lower bound) and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>3</mn><mi>n</mi></mrow></mrow></mrow></math>](img/914.png)
    <st c="38727"><st c="38736">(for the</st> <st c="38745">upper bound)</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="38757">In both cases, we</st> <st c="38776">have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/915.png)<st
    c="38781"><st c="38782">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38783">Applying</st> *<st c="38793">Case 2</st>* <st c="38799">of the
    master theorem to both</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁻</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/916.png)
    <st c="38830"><st c="38850">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁺</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/917.png)<st
    c="38854"><st c="38874">, we get</st> <st c="38883">the following:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/918.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁺</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/919.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="38935">Since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mi
    mathvariant="normal">⁻</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>T</mi><mi
    mathvariant="normal">⁺</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/920.png)
    <st c="38941"><st c="38962">and</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/921.png)
    <st c="38965"><st c="38967">are sandwiched between two other functions, and both</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁻</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/922.png)
    <st c="39021"><st c="39038">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>⁺</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/917.png)
    <st c="39042"><st c="39062">are</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/924.png)<st
    c="39066"><st c="39077">, we can conclude</st> <st c="39095">the following:</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>Θ</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/925.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="39128">You should note that the oscillating nature of the cosine function
    in the previous example does not significantly affect the overall growth rate
    of the recurrence function.</st> <st c="39301">In the long run, the linear term</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/926.png)
    <st c="39334"><st c="39335">dominates the behavior, and the algorithm’s time complexity
    is primarily determined by the recursive splitting and the linear work done in</st>
    <st c="39475">each step.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="39485">Example 5.18</st>**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="39498">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/927.png)<st
    c="39505"><st c="39523">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="39524">Solution</st>**<st c="39533">: At first glance, the master
    theorem seems like the right tool.</st> <st c="39599">We have</st> <st c="39607">the
    following:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/836.png)
    <st c="39621"><st c="39647">(number</st> <st c="39655">of subproblems)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)
    <st c="39670"><st c="39672">(factor by which the input</st> <st c="39700">size
    decreases)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/930.png)
    <st c="39715"><st c="39717">(work done outside of the</st> <st c="39744">recursive
    calls)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39760">This gives</st> <st c="39772">us a</st> **<st c="39777">watershed</st>**
    <st c="39786">function</st> <st c="39796">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/931.png)<st
    c="39799"><st c="39808">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39809">Now, we compare</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/932.png)
    <st c="39826"><st c="39835">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/231.png)<st
    c="39838"><st c="39839">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39840">Similar to</st> *<st c="39852">Example 5.17</st>*<st c="39864">,
    the function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/934.png)
    <st c="39879"><st c="39884">doesn’t fit neatly into any of the three cases of
    the</st> <st c="39938">master theorem:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="39953">Case 1</st>**<st c="39960">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>-</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/935.png)
    <st c="39963"><st c="39985">but</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="39989"><st c="39994">grows faster than the</st> <st c="40016">watershed
    function</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40034">Case 2</st>**<st c="40041">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/937.png)
    <st c="40044"><st c="40055">but</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="40059"><st c="40064">doesn’t fit</st> <st c="40076">this form</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40085">Case 3</st>****![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>:</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/939.png)**
    <st c="40102">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/789.png)
    <st c="40106"><st c="40111">grows slower than the</st> <st c="40133">watershed
    function</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40151">Even though</st> *<st c="40164">Case 3</st>* <st c="40170">seems
    like a potential fit, the regularity condition fails.</st> <st c="40231">The condition
    requires that</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mi>f</mi><mfenced
    open="(" close=")"><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mi>b</mi></mfrac></mstyle></mfenced><mo>≤</mo><mi>c</mi><mi>f</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced></mrow></mrow></math>](img/941.png) <st
    c="40258"><st c="40269">for some constant</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/774.png)
    <st c="40287"><st c="40288">and sufficiently large n.</st> <st c="40315">In this
    case, it becomes</st> <st c="40340">the following:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>4</mn><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>/</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo><mo>≤</mo><mi>c</mi><mo>(</mo><mfrac><mi>n</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow></math>](img/943.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="40356">Simplifying, we get</st> <st c="40376">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:math>](img/944.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="40418">For large values of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/945.png)<st
    c="40438"><st c="40439">, we cannot find a constant</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/946.png)
    <st c="40467"><st c="40468">that satisfies this inequality.</st> <st c="40501">Therefore,</st>
    *<st c="40512">Case 3</st>* <st c="40518">of the master theorem</st> <st c="40541">doesn’t
    hold.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40554">This section explains a systematic approach for solving recurrences
    that commonly appear in the analysis of divide-and-conquer algorithms.</st> <st
    c="40694">The master method provides a set of straightforward rules to determine
    the asymptotic behavior of recurrences.</st> <st c="40805">It categorizes the
    recurrences into three cases based on the relative growth rates of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/947.png)
    <st c="40891"><st c="40894">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow/></mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:math>](img/948.png)<st
    c="40898"><st c="40907">, allowing for quick and accurate complexity estimation.</st>
    <st c="40964">The method’s utility lies in its ability to handle a wide range
    of problems without requiring detailed, case-by-case analysis, making it a valuable
    tool in algorithm design</st> <st c="41137">and analysis.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41150">Beyond the master theorem – the Akra-Bazzi method</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="41200">In the previous section, we</st> <st c="41229">discussed the limitations
    of the master theorem in solving recurrence functions.</st> <st c="41310">Although
    the master theorem can address a wide range of problems and is the most common
    approach, it does have its constraints.</st> <st c="41438">For example, it only
    applies to a specific class of divide-and-conquer</st> <st c="41509">recurrence
    functions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mi>b</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/949.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="41552">Here, the subproblem sizes are equal (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:math>](img/950.png)<st
    c="41590"><st c="41595">).</st> <st c="41598">As we showed in the previous section,
    we can solve special cases of subtracting recurrence functions using the master
    theorem.</st> <st c="41725">It also has limitations on the form of the function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/684.png)<st
    c="41777"><st c="41780">. Specifically, the master theorem struggles with</st>
    <st c="41830">the following:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="41844">Unequal subproblem sizes</st>**<st c="41869">: The recurrence
    splits into subproblems of significantly</st> <st c="41928">different sizes</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41943">More complex splitting</st>**<st c="41966">: There are more
    than two subproblems in</st> <st c="42008">the recursion</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42021">Non-polynomial work</st>**<st c="42041">: The function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/730.png)
    <st c="42057"><st c="42062">representing the work done outside the recursive calls
    isn’t easily categorized as polynomial</st> <st c="42156">or logarithmic</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42170">For cases where the master theorem falls short, the</st> **<st
    c="42223">Akra-Bazzi method</st>** <st c="42240">offers solutions for a broader
    spectrum of recurrence functions.</st> <st c="42306">This method extends our ability
    to solve more complex recurrences, providing a valuable tool for algorithm analysis.</st>
    <st c="42423">The Akra-Bazzi method can handle recurrences of the following more</st>
    <st c="42490">general form:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>](img/953.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="42536">Here, the following is</st> <st c="42559">the case:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="42568"><st c="42570">is the number of subproblems (can be greater</st>
    <st c="42616">than 2)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>></mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/955.png)
    <st c="42623"><st c="42628">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math>](img/227.png)
    <st c="42632"><st c="42633">is</st> <st c="42637">a constant</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/957.png)<st
    c="42647"><st c="42649">, a constant for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42670"><st c="42671">, is the number of times the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42700"><st c="42701">th</st> <st c="42704">subproblem appears</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn><mml:mo><</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo><</mml:mo><mml:mn>1</mml:mn></mml:math>](img/960.png)<st
    c="42722"><st c="42733">, a constant for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="42754"><st c="42755">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math>](img/962.png)<st
    c="42760"><st c="42761">, is the size of the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="42782"><st c="42783">th subproblem (different subproblems can have</st> <st
    c="42829">different sizes)</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mi>’</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math>](img/964.png)
    <st c="42845"><st c="42861">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/233.png)
    <st c="42867"><st c="42868">is</st> <st c="42872">a constant</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:math>](img/966.png)<st
    c="42882"><st c="42901">, for</st> <st c="42907">all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/968.png)
    <st c="42912"><st c="42915">is the non-recursive part of the recurrence or driving
    function and represents the work done outside the recursive calls, which has a
    wider range of</st> <st c="43064">allowable forms</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43079">The following</st> <st c="43093">are the steps to solve a recurrence
    function using the</st> <st c="43149">Akra-Bazzi method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="43167">Find</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="43174">: Solve</st> <st c="43182">the equation:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math>](img/970.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: <st c="43197">This</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="43202"><st c="43203">is crucial; it represents a “balancing point” for</st>
    <st c="43254">the recurrence.</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="43269">Calculate the integral</st>**<st c="43292">: Find the value
    of the</st> <st c="43317">following integral:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow></mml:math>](img/972.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**<st c="43348">Asymptotic bound</st>**<st c="43364">: The asymptotic complexity
    of T(n) is then</st> <st c="43409">the following:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>θ</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/973.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: <st c="43440">Please note the following about the</st> <st c="43476">Akra-Bazzi
    method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43494">The Akra-Bazzi method is a generalization of the</st> <st c="43544">master
    theorem</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43558">It handles recurrences with unequal subproblem sizes, more complex
    splitting, and broader types of</st> <st c="43658">work functions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43672">The</st> <st c="43676">method involves finding a balancing exponent</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/974.png)
    <st c="43722"><st c="43723">and integrating the work function to determine the</st>
    <st c="43775">asymptotic complexity</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43796">Why does it work?</st> <st c="43815">Intuition behind Akra-Bazzi</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="43842">Think of the recurrence function as a tree.</st> <st c="43887">Each
    node represents a recursive call, and its children are the subproblems.</st> <st
    c="43964">The value</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="43974"><st c="43975">acts like a weight balancing the contributions of
    different branches of the tree.</st> <st c="44058">The integral then aggregates
    the work done at each level of the tree, taking into account</st> <st c="44148">this
    balancing.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44163">Example 5.19</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44176">Let’s consider the</st> <st c="44196">following recurrence:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>3</mn><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>/</mo><mn>4</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow></mrow></mrow></math>](img/976.png)'
  prefs: []
  type: TYPE_IMG
- en: '**<st c="44247">Find</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="44253">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mfenced
    open="(" close=")"><mrow><mn>2</mn><mo>×</mo><msup><mn>3</mn><mi>p</mi></msup></mrow></mfenced><mo>+</mo><mfenced
    open="(" close=")"><mrow><mn>1</mn><mo>×</mo><msup><mn>4</mn><mi>p</mi></msup></mrow></mfenced><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/978.png)<st
    c="44255"><st c="44256">. Solving this (numerically) gives</st> <st c="44291">us</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>p</mi><mo>≈</mo><mn>1.207</mn></mrow></mrow></math>](img/979.png)<st
    c="44294"><st c="44302">.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44303">Calculate</st>** **<st c="44314">the integral</st>**<st c="44326">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><munderover><mo>∫</mo><mn>1</mn><mi>n</mi></munderover><mrow><mfenced
    open="(" close=")"><mfrac><mi>u</mi><msup><mi>u</mi><mrow><mn>1</mn><mo>+</mo><mn>1.207</mn></mrow></msup></mfrac></mfenced><mi>d</mi><mi>u</mi></mrow></mrow><mo>≈</mo><mn>0.828</mn><msup><mi>n</mi><mn>0.207</mn></msup></mrow></mrow></math>](img/980.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="44354">Asymptotic Bound:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>Θ</mi><mfenced open="(" close=")"><mrow><msup><mi>n</mi><mn>1.207</mn></msup><mfenced
    open="(" close=")"><mrow><mn>1</mn><mo>+</mo><mn>0.828</mn><msup><mi>n</mi><mn>0.207</mn></msup></mrow></mfenced></mrow></mfenced><mo>=</mo><mi>Θ</mi><mfenced
    open="(" close=")"><msup><mi>n</mi><mn>1.207</mn></msup></mfenced></mrow></mrow></math>](img/981.png)'
  prefs: []
  type: TYPE_IMG
- en: '**<st c="44415">Example 5.20</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44427">Solve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>T</mi><mo>(</mo><mstyle
    scriptlevel="+1"><mfrac><mi mathvariant="normal">n</mi><mn>2</mn></mfrac></mstyle><mo>)</mo><mo>+</mo><mstyle
    scriptlevel="+1"><mfrac><mi mathvariant="normal">n</mi><mrow><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>](img/982.png)<st
    c="44434"><st c="44453">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44454">Solution</st>**<st c="44463">: In the previous section, we
    saw that this recurrence function cannot be solved using the master theorem.</st>
    <st c="44571">On the other hand, the Akra-Bazzi method is a generalization of
    the master theorem that handles a broader class of recurrences.</st> <st c="44699">Let’s
    apply</st> <st c="44711">it here:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44719">Find</st>** **![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)**<st
    c="44726">: Solve the equation:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/984.png)<st
    c="44748"><st c="44752">. This gives</st> <st c="44765">us</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/985.png)<st
    c="44768"><st c="44769">.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44770">Calculate</st>** **<st c="44781">the integral</st>**<st c="44793">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>u</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mrow><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfrac><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mrow></mml:math>](img/986.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="44811">This integral is a bit tricky, but it evaluates to</st> <st c="44862">approximately</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/987.png)<st
    c="44876"><st c="44885">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44886">Asymptotic bound</st>**<st c="44903">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∫</mml:mo><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>u</mml:mi><mml:mo>/</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfenced><mml:mo>/</mml:mo></mml:mrow></mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mi>d</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/988.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/989.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/990.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="44984">This section detailed an</st> <st c="45009">advanced and generalized
    approach for solving more complex recurrence functions that cannot be addressed
    by the master theorem.</st> <st c="45137">This method is particularly useful for
    recurrences where the subproblem sizes are not uniform or when dealing with more
    intricate forms of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/991.png)<st
    c="45276"><st c="45281">. The Akra-Bazzi method extends the applicability of traditional
    recurrence-solving techniques by providing a framework that accommodates a broader
    range of functions and splitting ratios.</st> <st c="45470">By leveraging this
    method, one can derive precise asymptotic bounds for complex recurrences, making
    it a powerful tool for analyzing the performance of sophisticated recursive algorithms.</st>
    <st c="45658">The section includes practical examples to illustrate the method’s
    application and effectiveness in resolving recurrences beyond the reach of</st>
    <st c="45800">simpler methods.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45816">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="45824">In</st> [*<st c="45828">Chapter 5</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="45837">, the methods for solving recurrence functions in the context of algorithm
    analysis were discussed.</st> <st c="45937">The chapter outlined three primary
    techniques: the substitution method, the master theorem, and recursion trees.</st>
    <st c="46050">The substitution method involves constructing proofs through variable
    substitution and induction to solve recurrence functions.</st> <st c="46178">The
    master theorem provides a systematic approach to determining the complexity of
    recursive algorithms based on their recurrence functions.</st> <st c="46319">Recursion
    trees help visualize the breakdown of problems into subproblems, providing insights
    into their complexity without</st> <st c="46443">direct proof.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46456">The substitution method was elaborated upon, highlighting its
    flexibility and power in addressing various recurrence functions.</st> <st c="46585">The
    method involves hypothesizing a solution, substituting it into the recurrence,
    and using induction to prove its correctness.</st> <st c="46714">Practical examples
    illustrated the iterative approach, showing how unrolling the recurrence can reveal
    patterns and lead to closed-form solutions.</st> <st c="46861">This method’s versatility
    is emphasized through multiple examples, demonstrating its utility in solving
    complex recurrences that other methods might not</st> <st c="47014">handle effectively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47033">The chapter also explored the limitations of the master theorem,
    especially in dealing with non-polynomial, non-positive, non-smooth, or irregular
    driving functions, and when</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/992.png)
    <st c="47209"><st c="47210">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/993.png)
    <st c="47214"><st c="47215">are not constants.</st> <st c="47235">The Akra-Bazzi
    method was introduced as a generalization of the master theorem, capable of handling
    a wider range of recurrence functions, including those with unequal subproblem
    sizes or more complex splitting.</st> <st c="47447">Examples were provided to
    show the application of these methods, emphasizing the need for alternative approaches
    when the master theorem’s conditions are not met.</st> <st c="47610">The chapter
    concluded with the application of these advanced methods, ensuring a comprehensive
    understanding of solving recurrence functions in</st> <st c="47754">algorithm
    analysis.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="47773">In the next chapter, we will discuss one of the most fundamental
    families of algorithms: sorting.</st> <st c="47872">The skills we learned in this
    chapter, particularly in analyzing recurrence functions, will be utilized to analyze
    sorting algorithms and estimate</st> <st c="48019">their complexities.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48038">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="48069">Introduction to Algorithms</st>*<st c="48096">. By Thomas H.</st>
    <st c="48111">Cormen, Charles E.</st> <st c="48130">Leiserson, Ronald L.</st>
    <st c="48151">Rivest, and Clifford Stein.</st> <st c="48179">Fourth Edition.</st>
    <st c="48195">MIT</st> <st c="48199">Press.</st> <st c="48206">2022:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48211">Chapter</st>* *<st c="48220">4,</st>* *<st c="48222">Recurrences</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48234">Algorithms</st>*<st c="48245">. By R.</st> <st c="48253">Sedgewick,
    K.</st> <st c="48267">Wayne.</st> <st c="48274">Fourth Edition.</st> <st c="48290">Addison-Wesley.</st>
    <st c="48306">2011:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48311">Chapter 2, Principles of</st>* *<st c="48337">Algorithm Analysis</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48355">Chapter</st>* *<st c="48364">5, Sorting</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48374">The Algorithm Design Manual</st>*<st c="48402">. By S.</st>
    <st c="48410">S.</st> <st c="48413">Skiena.</st> <st c="48421">Second Edition.</st>
    <st c="48437">Springer.</st> <st c="48447">2008:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48452">Chapter 3, Data Structures</st>* *<st c="48480">and Recursion</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48493">Chapter 5,</st>* *<st c="48505">Graph Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48521">Algorithm Design</st>*<st c="48538">. By Jon Kleinberg and Éva
    Tardos.</st> <st c="48573">First Edition.</st> <st c="48588">Pearson.</st> <st
    c="48597">2005:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48602">Chapter 5, Divide</st>* *<st c="48621">and Conquer</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48632">Chapter</st>* *<st c="48641">7, Recurrences</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="48655">On the solution of linear recurrence equations</st>*<st c="48702">.
    Mohamad Akra, Louay Bazzi.</st> *<st c="48731">Computational Optimization and
    Applications</st>*<st c="48774">. Vol.</st> <st c="48781">10, No 2,</st> <st c="48791">pp.195–210\.</st>
    <st c="48803">1998.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
