<html><head></head><body>
		<div id="_idContainer1218" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-74" class="chapter-number"><a id="_idTextAnchor081" class="pcalibre pcalibre1 calibre6"/><st c="0">6</st></h1>
			<h1 id="_idParaDest-75" class="calibre5"><a id="_idTextAnchor082" class="pcalibre pcalibre1 calibre6"/><st c="2">Sorting Algorithms</st></h1>
			<p class="calibre3"><st c="20">A staggering 25% of global computing power is devoted to sorting data, underscoring its critical role in modern computational processes. </st><st c="158">This significant allocation of resources highlights the essential nature of efficient sorting algorithms in diverse applications, ranging from information retrieval and database management to scientific simulations and machine learning. </st><st c="395">This chapter systematically explores the most significant sorting algorithms, ranging from the basic bubble sort to the advanced quick sort, both in iterative and recursive approaches. </st><st c="580">Each algorithm is assessed for correctness and complexity. </st><st c="639">The chapter concludes with a discussion on sorting in linear time, providing context about </st><span><st c="730">data assumptions.</st></span></p>
			<p class="calibre3"><st c="747">Sorting algorithms are implemented using different approaches. </st><st c="811">Each algorithm possesses unique characteristics described by properties such as stability, in-place sorting, or adaptability, which determine its suitability for different tasks. </st><st c="990">This chapter explores these properties, elucidating the advantages and disadvantages of each sorting mechanism. </st><st c="1102">By understanding these nuances, you will be equipped to choose the optimal sorting approach for your specific use cases </st><span><st c="1222">and datasets.</st></span></p>
			<p class="calibre3"><st c="1235">Building upon this foundational overview, the chapter delves into the intricacies of both iterative and recursive sorting algorithms. </st><st c="1370">It begins with the simpler, more intuitive iterative methods, such as selection and insertion sort, gradually progressing toward the more efficient recursive approaches, such as merge sort and quick sort. </st><st c="1575">Additionally, it explores sorting algorithms capable of achieving linear time complexity under specific conditions, highlighting the significance of assumptions about the input data. </st><st c="1758">This comprehensive exploration ensures that you develop a robust understanding of various sorting techniques, equipping you to efficiently tackle a wide array of </st><span><st c="1920">computational challenges.</st></span></p>
			<p class="calibre3"><st c="1945">This chapter covers the </st><span><st c="1970">following topics:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="1987">The taxonomy of </st><span><st c="2004">sorting algorithms</st></span></li>
				<li class="calibre13"><st c="2022">Iterative </st><span><st c="2033">sorting algorithms</st></span></li>
				<li class="calibre13"><st c="2051">Recursive </st><span><st c="2062">sorting algorithms</st></span></li>
				<li class="calibre13"><st c="2080">Non-comparison-based </st><span><st c="2102">sorting algorithms</st></span></li>
			</ul>
			<h1 id="_idParaDest-76" class="calibre5"><a id="_idTextAnchor083" class="pcalibre pcalibre1 calibre6"/><st c="2120">The taxonomy of sorting algorithms</st></h1>
			<p class="calibre3"><st c="2155">To begin, let’s examine the key properties that distinguish different sorting algorithms, offering a thorough framework for understanding their distinct characteristics and practical applications. </st><st c="2353">We will explore six critical properties: comparison, recursion, adaptability, inversion, memory usage, and stability. </st><st c="2471">Comparison determines whether an algorithm relies on pairwise element comparisons to sort data, influencing its general applicability and time complexity bounds. </st><st c="2633">Recursion involves breaking down the sorting process into smaller, more manageable sub-problems, often leading to elegant, divide-and-conquer solutions. </st><st c="2786">Adaptability measures an algorithm’s ability to efficiently handle already partially sorted data, enhancing performance in real-world scenarios. </st><st c="2931">Inversion counts the number of element pairs that are out of order, serving as a metric for the algorithm’s efficiency in different contexts. </st><st c="3073">Memory usage examines the additional space required by an algorithm, distinguishing between in-place and non-in-place methods. </st><st c="3200">Finally, stability ensures that equal elements retain their original relative order, which is crucial for multi-level sorting tasks. </st><st c="3333">By understanding these properties, we can better appreciate the strengths and limitations of each sorting algorithm and make informed decisions about </st><span><st c="3483">their application.</st></span></p>
			<h2 id="_idParaDest-77" class="calibre5"><a id="_idTextAnchor084" class="pcalibre pcalibre1 calibre6"/><st c="3501">Comparison</st></h2>
			<p class="calibre3"><st c="3512">Comparison is a fundamental operation in both sorting and searching algorithms. </st><st c="3593">In sorting, comparison determines the relative order of elements through pairwise evaluations. </st><st c="3688">We can categorize sorting algorithms based on their use of comparisons to </st><span><st c="3762">establish order.</st></span></p>
			<p class="calibre3"><st c="3778">Sorting algorithms based on comparison, such as merge sort and quick sort, are versatile. </st><st c="3869">We can apply them to any data type with a defined comparison function. </st><st c="3940">These algorithms generally achieve </st><img src="image/994.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre772"/><st c="3975"/><st c="3986"> time complexity. </st><st c="4003">On the other hand, some algorithms are not based on comparisons. </st><st c="4068">Examples of linear time-sorting algorithms include counting sort and Radix sort. </st><st c="4149">They employ alternative techniques for sorting, often achieving linear time complexity (</st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="4237"/><st c="4239">) under </st><span><st c="4247">specific conditions.</st></span></p>
			<h3 class="calibre8"><st c="4267">Comparison-based sorting</st></h3>
			<p class="calibre3"><st c="4292">Comparison plays a central role in many sorting algorithms. </st><st c="4353">In a comparison-based sorting algorithm, the primary operation used to determine the order of elements is the comparison between pairs of elements. </st><st c="4501">The algorithm makes decisions about the positions of elements based on the outcomes of these comparisons, which typically involve relational operators such as </st><strong class="source-inline"><st c="4660">&lt;</st></strong><st c="4661">, </st><strong class="source-inline"><st c="4663">&gt;</st></strong><st c="4664">, </st><span><st c="4666">or </st></span><span><strong class="source-inline"><st c="4669">==</st></strong></span><span><st c="4671">.</st></span></p>
			<p class="calibre3"><st c="4672">These algorithms are based on comparing elements to decide their order. </st><st c="4745">Every comparison operation determines whether one element should be placed before or after another. </st><st c="4845">Comparison-based sorting algorithms can be applied to any data type for which a comparison function is defined. </st><st c="4957">This makes them versatile and </st><span><st c="4987">widely applicable.</st></span></p>
			<p class="calibre3"><st c="5005">We can show that there is a lower bound of </st><img src="image/996.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre774"/><st c="5049"/><st c="5058"> for the time complexity of comparison-based sorting algorithms. </st><st c="5122">This is due to the decision tree model of comparisons. </st><st c="5177">This means that, on average, at least </st><img src="image/997.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre775"/><st c="5215"/><st c="5224"> comparisons are required to sort </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="5257"/><st c="5306"> elements. </st><st c="5316">Let’s explain why the time complexity of any comparison-based sort cannot be better </st><span><st c="5400">than </st></span><span><img src="image/997.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre775"/><st c="5405"/></span><span><st c="5414">.</st></span></p>
			<p class="calibre3"><st c="5415">These algorithms are implemented based on comparing every pair of elements. </st><st c="5492">We can represent the decisions made by these algorithms as a binary decision tree. </st><st c="5575">The following are the elements of this </st><span><st c="5614">decision tree:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="5628">Each internal (non-terminal) node represents a comparison between two elements (</st><span><st c="5709">e.g., A&lt;B?)</st></span></li>
				<li class="calibre13"><st c="5721">Each branch represents the outcome of that comparison (yes </st><span><st c="5781">or no)</st></span></li>
				<li class="calibre13"><st c="5787">Each leaf (terminal) node represents a possible final sorted order of the </st><span><st c="5862">input array</st></span></li>
			</ul>
			<p class="calibre3"><st c="5873">Let’s explain the decision tree representation of comparison-based sorting by </st><span><st c="5952">an example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="5963">Example 6.1</st></strong></span></p>
			<p class="calibre3"><st c="5975">Let’s consider an array with three random numbers: A=[3, 1, 4]. </st><st c="6040">To sort this array using comparisons, we might start with the decision tree illustrated in </st><span><em class="italic"><st c="6131">Figure 6</st></em></span><span><em class="italic"><st c="6139">.1</st></em></span><span><st c="6141">.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1018" class="img---figure">
					<img src="image/B22248_06_1.jpg" alt="Figure 6.1: Decision tree to implement comparison-based sorting of an array with three elements (white boxes are internal nodes; the left branch is “yes” and the right branch is “no”)" class="calibre144"/><st c="6142"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="6271">Figure 6.1: Decision tree to implement comparison-based sorting of an array with three elements (white boxes are internal nodes; the left branch is “yes” and the right branch is “no”)</st></p>
			<p class="calibre3"><st c="6454">The tree</st><a id="_idIndexMarker276" class="pcalibre pcalibre1 calibre6"/><st c="6463"> will continue branching out, representing all possible comparison outcomes and leading to leaf nodes that represent different sorted orders of the input array. </st><st c="6624">Let’s estimate the lower-bound time complexity of sorting using this </st><span><st c="6693">decision tree:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="6707">For an array of size </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre776"/><st c="6729"/><st c="6778">, there are </st><img src="image/1001.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre777"/><st c="6790"/><st c="6793"> possible permutations (different orderings). </st><st c="6838">Each of these permutations could potentially be the correctly </st><span><st c="6900">sorted order.</st></span></li>
				<li class="calibre13"><st c="6913">In the decision tree, each leaf node represents one of these possible permutations. </st><st c="6998">Therefore, the tree must have at least </st><img src="image/1002.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre109"/><st c="7037"/><st c="7040"> leaves to cover all possibilities. </st><st c="7075">In our example, we will have </st><img src="image/1003.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;6&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre778"/><st c="7104"/><st c="7105"> possible permutations or </st><span><st c="7131">leaf nodes.</st></span></li>
				<li class="calibre13"><st c="7142">A binary tree with </st><img src="image/1004.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;L&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre779"/><st c="7162"/><st c="7163"> leaves has a minimum height of </st><img src="image/1005.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre780"/><st c="7195"/><st c="7201">. Since our decision tree needs at least </st><img src="image/1002.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre109"/><st c="7242"/><st c="7245"> leaves, its minimum height is </st><img src="image/1007.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;!&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre781"/><st c="7275"/><st c="7283">. Using Stirling’s approximation, we know that </st><span><st c="7330">l</st></span><span><st c="7331">o</st></span><span><st c="7332">g</st></span><span><st c="7333">(</st></span><span><st c="7334">n</st></span><span><st c="7335">!</st></span><span><st c="7336">)</st></span><st c="7337"> is approximately equal to </st><img src="image/1008.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre782"/><st c="7364"/><st c="7372"> (see </st><em class="italic"><st c="7377">Example 3.8</st></em><st c="7388"> from </st><a href="B22248_03_split_000.xhtml#_idTextAnchor033" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="7394">Chapter 3</st></em></span></a><span><st c="7403">).</st></span></li>
			</ul>
			<p class="calibre3"><st c="7406">Therefore, there is a lower-bound time complexity of </st><img src="image/1009.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;Ω&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre783"/><st c="7460"/><st c="7471">for all sorting algorithms </st><a id="_idIndexMarker277" class="pcalibre pcalibre1 calibre6"/><st c="7498">based on comparison. </st><st c="7519">This means no algorithm can consistently sort an array faster </st><span><st c="7581">than </st></span><span><img src="image/1010.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre784"/><st c="7586"/></span><span><st c="7597">.</st></span></p>
			<p class="calibre3"><st c="7598">The following are well-known comparison-based </st><span><st c="7645">sorting algorithms:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="7664">Bubble sort</st></strong><st c="7676">: The </st><a id="_idIndexMarker278" class="pcalibre pcalibre1 calibre6"/><st c="7683">adjacent elements in the array are repeatedly compared, and if they are in the wrong order, they are swapped. </st><st c="7793">With each pass, larger elements are gradually moved to the end of </st><span><st c="7859">the array.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7869">Insertion sort</st></strong><st c="7884">: This </st><a id="_idIndexMarker279" class="pcalibre pcalibre1 calibre6"/><st c="7892">algorithm progressively constructs a sorted array by iteratively comparing and inserting elements into their appropriate places within the already </st><span><st c="8039">sorted portion.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="8054">Quick sort</st></strong><st c="8065">: In</st><a id="_idIndexMarker280" class="pcalibre pcalibre1 calibre6"/><st c="8070"> the quick sort algorithm, comparisons are used to partition the array around a pivot element, followed by recursive sorting of the </st><span><st c="8202">resulting partitions.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="8223">Merge sort</st></strong><st c="8234">: In </st><a id="_idIndexMarker281" class="pcalibre pcalibre1 calibre6"/><st c="8240">this sorting algorithm, the array is split into two partitions of nearly the same size. </st><st c="8328">Each partition is recursively sorted, and then the sorted partitions are merged </st><span><st c="8408">using comparisons.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="8426">Heap sort</st></strong><st c="8436">: In this</st><a id="_idIndexMarker282" class="pcalibre pcalibre1 calibre6"/><st c="8446"> sorting algorithm, a max-heap (or min-heap) tree is built from the original array, and then the maximum (or minimum) element is repeatedly extracted. </st><st c="8597">Throughout the process, comparisons are used to maintain the heap property (see </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="8677">Chapter 13</st></em></span></a><span><st c="8687">).</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="8690">Non-comparison-based sorting</st></h3>
			<p class="calibre3"><st c="8719">Unlike </st><a id="_idIndexMarker283" class="pcalibre pcalibre1 calibre6"/><st c="8727">comparison-based methods, in </st><a id="_idIndexMarker284" class="pcalibre pcalibre1 calibre6"/><st c="8756">non-comparison-based algorithms, we do not directly compare elements to determine their order. </st><st c="8851">Instead, we use alternative techniques such as counting frequencies, employing hash functions, or leveraging specific properties of the data. </st><st c="8993">These methods make use of assumptions about the input data </st><a id="_idIndexMarker285" class="pcalibre pcalibre1 calibre6"/><st c="9052">to achieve efficient sorting, often reaching linear time complexity, </st><img src="image/1011.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre785"/><st c="9121"/><st c="9122">, under certain conditions. </st><st c="9150">The main </st><a id="_idIndexMarker286" class="pcalibre pcalibre1 calibre6"/><st c="9159">properties of non-comparison-based sorting algorithms include </st><span><st c="9221">the following:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="9235">Data-specific techniques</st></strong><st c="9260">: These algorithms frequently utilize specific properties of the data, such as the range (particularly for numerical, integer data) or the number of digits, to carry out the </st><span><st c="9435">sorting process</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="9450">Linear time complexity</st></strong><st c="9473">: Non-comparison-based sorting algorithms can achieve better than </st><img src="image/1012.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt; &lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre786"/><st c="9540"/><st c="9541"> time complexity, often </st><img src="image/1013.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre787"/><st c="9565"/><st c="9566">, by avoiding comparisons and using more direct methods of </st><span><st c="9625">ordering elements</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="9642">Memory usage</st></strong><st c="9655">: Although these algorithms can achieve linear time complexity, they often require temporary memory that is typically proportional to the input size or the range of the </st><span><st c="9825">data values</st></span></li>
			</ul>
			<p class="calibre3"><st c="9836">In this chapter, we</st><a id="_idIndexMarker287" class="pcalibre pcalibre1 calibre6"/><st c="9856"> introduce three well-known non-comparison-based sorting algorithms. </st><st c="9925">The first is counting sort, which counts the occurrences of each distinct element to place them in their correct positions, making it effective for integers within a known range. </st><st c="10104">Next is Radix sort, which processes each digit or character of the elements in a specific order (e.g., least significant digit first) and uses a stable sub-routine such as counting sort to sort the elements by each digit. </st><st c="10326">Finally, bucket sort distributes the elements of the input list into several buckets or bins based on their values. </st><st c="10442">Each bucket or bin is then sorted individually (often using a simple comparison-based sort), and all the sorted buckets are concatenated to build the final </st><span><st c="10598">sorted list.</st></span></p>
			<h2 id="_idParaDest-78" class="calibre5"><a id="_idTextAnchor085" class="pcalibre pcalibre1 calibre6"/><st c="10610">Recursion</st></h2>
			<p class="calibre3"><st c="10620">Recursion</st><a id="_idIndexMarker288" class="pcalibre pcalibre1 calibre6"/><st c="10630"> plays a vital role in many sorting algorithms, enabling</st><a id="_idIndexMarker289" class="pcalibre pcalibre1 calibre6"/><st c="10686"> them to efficiently break down and conquer the sorting problem through the divide-and-conquer strategy. </st><st c="10791">Recursive sorting algorithms offer clean and intuitive implementations but come with stack overhead and potential performance variability. </st><st c="10930">On the other side, non-recursive sorting algorithms avoid the complexities of recursion and stack management, offering memory efficiency and simplicity, though they may not perform as well on </st><span><st c="11122">large datasets.</st></span></p>
			<h3 class="calibre8"><st c="11137">Recursive sorting algorithms</st></h3>
			<p class="calibre3"><st c="11166">Recursion is </st><a id="_idIndexMarker290" class="pcalibre pcalibre1 calibre6"/><st c="11180">often employed in sorting algorithms to break down complex problems into simpler sub-problems. </st><st c="11275">In the context of sorting, recursion allows algorithms to divide the input array into smaller segments and sort these </st><a id="_idIndexMarker291" class="pcalibre pcalibre1 calibre6"/><st c="11393">segments independently. </st><st c="11417">The final sorted array is produced by merging the sorted segments. </st><st c="11484">Recursive sorting algorithms leverage the divide-and-conquer strategy, which helps in achieving efficient sorting with manageable</st><a id="_idIndexMarker292" class="pcalibre pcalibre1 calibre6"/><st c="11613"> code complexity. </st><st c="11631">Recursive sorting algorithms have the </st><span><st c="11669">following properties:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="11690">Divide-and-conquer strategy</st></strong><st c="11718">: As the name suggests, this strategy consists of three steps: first, breaking the problem (array) into smaller sub-problems (sub-arrays). </st><st c="11858">Second, recursively solving (sorting) each sub-problem (sub-array). </st><st c="11926">Third, combining the solutions to address the </st><span><st c="11972">original problem.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="11989">Base case and recursive case</st></strong><st c="12018">: Each recursive algorithm has a base case that terminates the recursion when the sub-problem is small enough (e.g., a single element or an empty array). </st><st c="12173">The recursive case continues to break down the problem and solve </st><span><st c="12238">the sub-problems.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="12255">Stack usage</st></strong><st c="12267">: Recursive calls consume stack space, which can lead to high memory usage, especially for deep recursion. </st><st c="12375">However, tail-recursive optimization and iterative approaches can mitigate this issue in </st><span><st c="12464">some cases.</st></span></li>
			</ul>
			<p class="calibre3"><em class="italic"><st c="12475">Table 6.1</st></em><st c="12485"> provides</st><a id="_idIndexMarker293" class="pcalibre pcalibre1 calibre6"/><st c="12494"> some examples of recursive </st><span><st c="12522">sorting algorithms:</st></span></p>
			<table id="table001-3" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="12541">Sorting </st></strong><span><strong class="bold"><st c="12550">algorithm</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="12559">Process</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="12567">Time and </st></strong><span><strong class="bold"><st c="12577">space complexity</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="12593">Merge sort</st></span></p>
						</td>
						<td class="t---table2">
							<ol class="calibre12">
								<li class="calibre13"><strong class="bold"><st c="12604">Divide</st></strong><st c="12611">: If the array has more than one element, split it into two roughly </st><span><st c="12680">equal halves.</st></span></li>
								<li class="calibre13"><strong class="bold"><st c="12693">Conquer</st></strong><st c="12701">: Recursively apply merge sort to each of the two halves. </st><st c="12760">This continues until each sub-array has only one element (a trivially </st><span><st c="12830">sorted array).</st></span></li>
								<li class="calibre13"><strong class="bold"><st c="12844">Combine</st></strong><st c="12852">: Merge the two sorted halves back into a single sorted array by comparing the elements from each half, taking the smaller one first, and placing it in the </st><span><st c="13009">new array.</st></span></li>
								<li class="calibre13"><st c="13019">Repeat this process until all elements from both halves have </st><span><st c="13081">been merged.</st></span></li>
							</ol>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="13093">Time: </st><img src="image/1014.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre788"/><st c="13100"/><st c="13111"> in all cases (best, average, </st><span><st c="13140">and worst).</st></span></p>
							<p class="calibre3"><st c="13151">Space: </st><img src="image/450.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre364"/><st c="13159"/><st c="13160"> for temporary memory of </st><span><st c="13185">merge component.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="13201">Quick sort</st></span></p>
						</td>
						<td class="t---table2">
							<ol class="calibre12">
								<li class="calibre13"><strong class="bold"><st c="13212">Choose pivot</st></strong><st c="13225">: From the array, select an element to serve as the pivot. </st><st c="13285">Common choices are the first, the last, or a randomly </st><span><st c="13339">chosen element.</st></span></li>
								<li class="calibre13"><strong class="bold"><st c="13354">Partition</st></strong><st c="13364">: Divide the array into two sub-arrays. </st><st c="13405">The elements of the first sub-array (left) are smaller than the pivot, and the elements of the second sub-array (right) are greater than the pivot. </st><st c="13553">The pivot is now in its final </st><span><st c="13583">sorted position.</st></span></li>
								<li class="calibre13"><strong class="bold"><st c="13599">Recursive sorting</st></strong><st c="13617">: Apply quick sort recursively to the left sub-array. </st><st c="13672">Apply quick sort recursively to the </st><span><st c="13708">right sub-array.</st></span></li>
								<li class="calibre13"><st c="13724">Continue this process until each sub-array is either empty or contains only one element (a trivially </st><span><st c="13826">sorted array).</st></span></li>
							</ol>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="13840">Time: </st><img src="image/1014.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre788"/><st c="13847"/><st c="13858"> on average, but </st><img src="image/1017.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre789"/><st c="13874"/><st c="13881"> in the </st><span><st c="13888">worst case.</st></span></p>
							<p class="calibre3"><st c="13899">Space: </st><img src="image/1018.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre790"/><st c="13907"/><st c="13916"> for the recursion stack in the </st><span><st c="13947">average case.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="13960">Heap sort</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="13970">Build max heap</st></strong><st c="13985">: Starting from the last non-leaf node, apply recursive heapify to each node in reverse level order. </st><st c="14087">This builds a max heap from the </st><span><st c="14119">input array.</st></span></p>
							<p class="calibre3"><strong class="bold"><st c="14131">Extract and rebuild</st></strong><st c="14151">: Repeat the following steps until the heap </st><span><st c="14196">is empty:</st></span></p>
							<ul class="calibre14">
								<li class="calibre13"><st c="14205">Swap the root (maximum element) with the last element of </st><span><st c="14263">the heap.</st></span></li>
								<li class="calibre13"><st c="14272">Reduce the heap size </st><span><st c="14294">by 1.</st></span></li>
								<li class="calibre13"><st c="14299">Apply recursive heapify to the root to restore the </st><span><st c="14351">max-heap property.</st></span></li>
							</ul>
							<p class="calibre3"><st c="14369">(Heap sort will be discussed in detail in </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="14412">Chapter 13</st></em></span></a><span><st c="14422">).</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="14425">Time: </st><img src="image/1019.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre791"/><st c="14432"/><st c="14443"> in </st><span><st c="14446">all cases.</st></span></p>
							<p class="calibre3"><st c="14456">Space: </st><img src="image/1020.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre792"/><st c="14464"/><st c="14465"> for the iterative version; the recursive heapify process uses </st><img src="image/1021.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt; &lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre793"/><st c="14528"/> <span><st c="14529">stack space.</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="14541">Table 6.1: Examples of recursive sorting algorithms</st></p>
			<h3 class="calibre8"><st c="14593">Non-recursive sorting algorithms</st></h3>
			<p class="calibre3"><st c="14626">Non-recursive sorting algorithms </st><a id="_idIndexMarker294" class="pcalibre pcalibre1 calibre6"/><st c="14660">do not use recursion to achieve sorting. </st><st c="14701">Instead, they rely on iterative techniques, using</st><a id="_idIndexMarker295" class="pcalibre pcalibre1 calibre6"/><st c="14750"> loops to manage the process of sorting. </st><st c="14791">These algorithms often have simpler space complexity because they avoid the stack overhead that is a problem with recursive strategies. </st><st c="14927">Non-recursive sorting algorithms use an iterative approach (implemented by loops) and they are generally memory efficient. </st><st c="15050">Technically speaking, non-recursive sorting algorithms have the </st><span><st c="15114">following</st></span><span><a id="_idIndexMarker296" class="pcalibre pcalibre1 calibre6"/></span><span><st c="15123"> characteristics:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="15140">Iterative approach</st></strong><st c="15159">: Non-recursive sorting algorithms use loops (e.g., </st><strong class="source-inline1"><st c="15212">for</st></strong><st c="15215"> loops or </st><strong class="source-inline1"><st c="15225">while</st></strong><st c="15230"> loops) to sort the array, eliminating the need for </st><span><st c="15282">recursive calls</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="15297">Memory efficiency</st></strong><st c="15315">: These algorithms are often more memory-efficient because they avoid the additional stack space required for </st><span><st c="15426">recursive calls</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="15441">Simpler stack management</st></strong><st c="15466">: By using an iterative approach, non-recursive algorithms avoid the complexities of managing recursive stack depth, which can lead to stack overflow when dealing with </st><span><st c="15635">large datasets</st></span></li>
			</ul>
			<p class="calibre3"><em class="italic"><st c="15649">Table 6.2</st></em><st c="15659"> provides a list of </st><a id="_idIndexMarker297" class="pcalibre pcalibre1 calibre6"/><st c="15679">well-known non-recursive </st><span><st c="15704">sorting algorithms:</st></span></p>
			<table id="table002-2" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="15723">Sorting </st></strong><span><strong class="bold"><st c="15732">algorithm</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="15741">Process</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="15749">Time and </st></strong><span><strong class="bold"><st c="15759">space complexity</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="15775">Insertion </st></strong><span><strong class="bold"><st c="15786">sort</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="15790">Start with the second element. </st><st c="15822">Assume the first element is </st><span><st c="15850">already sorted.</st></span></p>
							<p class="calibre3"><st c="15865">Iterate through the </st><span><st c="15886">unsorted portion:</st></span></p>
							<ul class="calibre14">
								<li class="calibre13"><st c="15903">Compare it with the elements in the sorted portion (to </st><span><st c="15959">its left).</st></span></li>
								<li class="calibre13"><st c="15969">Shift the elements in the sorted portion to the right until the element is in the </st><span><st c="16052">correct position.</st></span></li>
								<li class="calibre13"><st c="16069">Insert the current element into </st><span><st c="16102">that position.</st></span></li>
							</ul>
							<p class="calibre3"><st c="16116">Continue until the entire array is sorted. </st><st c="16160">Repeat step 2 for each element in the </st><span><st c="16198">unsorted portion.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="16215">Time: </st><img src="image/1022.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre794"/><st c="16222"/><st c="16228"> for both the average and worst cases, </st><img src="image/1023.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre795"/><st c="16266"/><st c="16267"> in the </st><span><st c="16275">best case.</st></span></p>
							<p class="calibre3"><st c="16285">Space: </st><img src="image/1020.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre792"/><st c="16293"/><st c="16294"> since it is </st><span><st c="16307">in-place sort.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="16321">Selection </st></strong><span><strong class="bold"><st c="16332">sort</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="16336">Find the</st><a id="_idIndexMarker298" class="pcalibre pcalibre1 calibre6"/><st c="16345"> smallest element (initially the </st><span><st c="16378">entire array).</st></span></p>
							<p class="calibre3"><strong class="bold"><st c="16392">Swap</st></strong><st c="16397">: Swap the smallest element with the leftmost element of the unsorted portion. </st><st c="16477">The leftmost element is now in its final </st><span><st c="16518">sorted position.</st></span></p>
							<p class="calibre3"><strong class="bold"><st c="16534">Repeat</st></strong><st c="16541">: Consider the remaining unsorted portion (excluding the elements already sorted). </st><st c="16625">Repeat steps 1 and 2 until the entire array </st><span><st c="16669">is sorted.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="16679">Time: </st><img src="image/1022.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre794"/><st c="16686"/><st c="16692"> in </st><span><st c="16695">all cases.</st></span></p>
							<p class="calibre3"><st c="16705">Space: </st><img src="image/1020.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre792"/><st c="16713"/><st c="16714"> since it is </st><span><st c="16727">in-place sort.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="16741">Bubble sort</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="16753">Compare </st></strong><span><strong class="bold"><st c="16762">and swap:</st></strong></span></p>
							<ul class="calibre14">
								<li class="calibre13"><st c="16771">Compare every two elements. </st><st c="16800">If they are in the wrong order, </st><span><st c="16832">swap them.</st></span></li>
								<li class="calibre13"><st c="16842">Continue this process until the last element of the array </st><span><st c="16901">is visited.</st></span></li>
							</ul>
							<p class="calibre3"><span><strong class="bold"><st c="16912">Repeat:</st></strong></span></p>
							<ul class="calibre14">
								<li class="calibre13"><st c="16920">After one pass through the array, the largest element will have “bubbled up” to </st><span><st c="17001">the end.</st></span></li>
								<li class="calibre13"><st c="17009">Repeat step 1, but this time, stop one position before the end of the array (since the last element is already in its </st><span><st c="17128">correct place).</st></span></li>
								<li class="calibre13"><st c="17143">Continue repeating step 1, reducing the comparison range by one element each time, until the entire array </st><span><st c="17250">is sorted.</st></span></li>
							</ul>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="17260">Time: </st><img src="image/1022.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre794"/><st c="17267"/><st c="17273"> for both the average and worst cases, </st><img src="image/1023.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre795"/><st c="17311"/><st c="17312"> in the </st><span><st c="17320">best case.</st></span></p>
							<p class="calibre3"><st c="17330">Space: </st><img src="image/1020.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre792"/><st c="17338"/><st c="17339"> since it is </st><span><st c="17352">in-place sort.</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="17366">Table 6.2: Examples of non-recursive sorting algorithms</st></p>
			<p class="calibre3"><st c="17422">Recursion is a key factor </st><a id="_idIndexMarker299" class="pcalibre pcalibre1 calibre6"/><st c="17449">that differentiates sorting algorithms. </st><st c="17489">In the following sub-section, we will explore other aspects, such </st><span><st c="17555">as adaptability.</st></span></p>
			<h2 id="_idParaDest-79" class="calibre5"><a id="_idTextAnchor086" class="pcalibre pcalibre1 calibre6"/><st c="17571">Adaptability</st></h2>
			<p class="calibre3"><st c="17584">In sorting, adaptability means an algorithm’s capacity to </st><a id="_idIndexMarker300" class="pcalibre pcalibre1 calibre6"/><st c="17643">leverage pre-existing order within the data to enhance its efficiency. </st><st c="17714">An adaptive sorting algorithm excels when the input is partially sorted or exhibits some underlying structure, requiring fewer operations to achieve complete sorting. </st><st c="17881">In essence, the more ordered the input, the faster the algorithm can complete </st><span><st c="17959">its task.</st></span></p>
			<p class="calibre3"><st c="17968">An</st><a id="_idIndexMarker301" class="pcalibre pcalibre1 calibre6"/><st c="17971"> adaptive sorting algorithm</st><a id="_idIndexMarker302" class="pcalibre pcalibre1 calibre6"/><st c="17998"> will have a faster average-case running time when the data is partially ordered compared to when the input is completely random. </st><st c="18128">In addition, these sorting algorithms make fewer comparisons and swaps when the data is closer to the sorted order, resulting in reduced computational effort. </st><st c="18287">Adaptive sorting algorithms are more efficient in real-world applications because many real-world datasets are not completely random and often have some existing order (e.g., time-series data or lists that are periodically updated). </st><st c="18520">Adaptive sorting algorithms can handle such datasets </st><span><st c="18573">more efficiently.</st></span></p>
			<p class="calibre3"><st c="18590">Let’s consider</st><a id="_idIndexMarker303" class="pcalibre pcalibre1 calibre6"/><st c="18605"> two adaptive sorting algorithms. </st><st c="18639">First is insertion sort, which is highly adaptive. </st><st c="18690">In the best-case scenario, when the input data is already ordered, its running time is </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="18777"/><st c="18778">, as it only needs to make </st><img src="image/1031.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre796"/><st c="18805"/><st c="18806"> comparisons. </st><st c="18820">For small or nearly sorted data, insertion sort is efficient since it performs few swaps and comparisons. </st><st c="18926">The next adaptive sorting algorithm is bubble sort, which is adaptive to some extent. </st><st c="19012">If the input data is already ordered, bubble sort can complete the sorting in </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="19090"/><st c="19091"> time, though this requires an optimization to stop early when no swaps are made in </st><span><st c="19175">a pass.</st></span></p>
			<p class="calibre3"><st c="19182">On the other hand, let’s </st><a id="_idIndexMarker304" class="pcalibre pcalibre1 calibre6"/><st c="19208">examine two non-adaptive sorting algorithms: quick sort and heap sort. </st><st c="19279">The complexity of quick sort is heavily influenced by the choice of pivot and the initial arrangement of elements. </st><st c="19394">However, it doesn’t inherently improve with partially sorted data. </st><st c="19461">Heap sort is another non-adaptive algorithm. </st><st c="19506">As we will see in </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="19524">Chapter 13</st></em></span></a><st c="19534">, pre-sorted data doesn’t offer any advantage in </st><span><st c="19583">this process.</st></span></p>
			<h2 id="_idParaDest-80" class="calibre5"><a id="_idTextAnchor087" class="pcalibre pcalibre1 calibre6"/><st c="19596">Inversion</st></h2>
			<p class="calibre3"><st c="19606">An </st><a id="_idIndexMarker305" class="pcalibre pcalibre1 calibre6"/><st c="19610">inversion</st><a id="_idIndexMarker306" class="pcalibre pcalibre1 calibre6"/><st c="19619"> in a sequence is a condition where a pair of elements is out of order. </st><st c="19691">Formally, given an array </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre797"/><st c="19716"/><st c="19717">, an inversion is defined as a pair of indices</st><img src="image/1034.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre798"/><st c="19763"/><st c="19765"> and </st><img src="image/1035.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre799"/><st c="19770"/><st c="19771">, such that </st><img src="image/1036.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre800"/><st c="19783"/><st c="19788"> and</st><img src="image/1037.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;&gt;&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre801"/><st c="19791"/><st c="19806">. In simpler terms, an inversion occurs when a larger element precedes a smaller one in the array. </st><st c="19905">Inversions are significant in sorting because they measure the degree of disorder within an array. </st><st c="20004">The total number of inversions provides insight into how far an array is from being sorted. </st><st c="20096">We can </st><a id="_idIndexMarker307" class="pcalibre pcalibre1 calibre6"/><st c="20103">consider </st><span><st c="20112">two scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="20126">Zero inversions</st></strong><st c="20142">: For all </st><img src="image/1036.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre802"/><st c="20153"/><st c="20158">, we have </st><img src="image/1039.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;≤&lt;/mml:mo&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre803"/><st c="20168"/><st c="20180">; in other words, the array </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre797"/><st c="20208"/><st c="20209"> is </st><span><st c="20213">fully sorted</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="20225">Maximum inversions</st></strong><st c="20244">: For all </st><img src="image/1041.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre804"/><st c="20255"/><st c="20260">, we have </st><img src="image/1042.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;&gt;&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre805"/><st c="20270"/><st c="20281">; in other words, the array </st><img src="image/1043.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre806"/><st c="20309"/><st c="20310">is sorted in </st><span><st c="20323">reverse order</st></span></li>
			</ul>
			<p class="calibre3"><st c="20336">The concept of inversions</st><a id="_idIndexMarker308" class="pcalibre pcalibre1 calibre6"/><st c="20362"> is essential to understanding sorting algorithms and their analysis. </st><st c="20432">Inversions refer to pairs of elements in an array that are out of order. </st><st c="20505">For instance, in bubble sort, the algorithm repeatedly swaps adjacent elements that are not in their correct order. </st><st c="20621">The total number of swaps performed during bubble sort directly corresponds to the number of inversions present in </st><span><st c="20736">the array.</st></span></p>
			<p class="calibre3"><st c="20746">In merge sort, inversions </st><a id="_idIndexMarker309" class="pcalibre pcalibre1 calibre6"/><st c="20773">can be counted during the mergin</st><a id="_idTextAnchor088" class="pcalibre pcalibre1 calibre6"/><st c="20805">g process. </st><st c="20817">Specifically, when an element from the right half of the array is inserted before an element from the left half, this indicates a number of inversions equal to the remaining elements in the left half. </st><st c="21018">This insight helps us quantify the disorder present within the array as it </st><span><st c="21093">undergoes sorting.</st></span></p>
			<p class="calibre3"><st c="21111">Inversions also impact the complexity of sorting algorithms. </st><st c="21173">The number of inversions in an array can be used to analyze the efficiency of these algorithms. </st><st c="21269">For instance, algorithms with </st><img src="image/1044.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre807"/><st c="21299"/><st c="21310"> complexity, such as merge sort and quick sort, can handle a large number of inversions efficiently. </st><st c="21410">In contrast, algorithms with </st><img src="image/1045.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre808"/><st c="21439"/><st c="21445"> complexity, such as bubble sort and insertion sort, may become increasingly inefficient as the number of </st><span><st c="21550">inversions rises.</st></span></p>
			<h2 id="_idParaDest-81" class="calibre5"><a id="_idTextAnchor089" class="pcalibre pcalibre1 calibre6"/><st c="21567">Memory usage</st></h2>
			<p class="calibre3"><st c="21580">Memory usage</st><a id="_idIndexMarker310" class="pcalibre pcalibre1 calibre6"/><st c="21593"> in sorting is measured by the amount of extra storage needed by the algorithm to process and arrange the input data. </st><st c="21711">This is closely tied to whether a sorting algorithm is classified as in place </st><span><st c="21789">or not.</st></span></p>
			<h3 class="calibre8"><st c="21796">In-place sorting</st></h3>
			<p class="calibre3"><st c="21813">In-place sorting algorithms </st><a id="_idIndexMarker311" class="pcalibre pcalibre1 calibre6"/><st c="21842">operate directly </st><a id="_idIndexMarker312" class="pcalibre pcalibre1 calibre6"/><st c="21859">within the input array. </st><st c="21883">They require only a fixed amount of additional storage. </st><st c="21939">These algorithms rearrange the elements within the given array using a fixed amount of additional space, typically </st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="22054"/> <span><st c="22055">extra space.</st></span></p>
			<p class="calibre3"><st c="22067">In-place sorting algorithms are memory efficient, requiring minimal extra space. </st><st c="22149">This is particularly important in environments with limited memory resources or when dealing with large datasets. </st><st c="22263">These algorithms often achieve sorting by swapping elements within the input array. </st><st c="22347">Common techniques include partitioning and incrementally placing elements in their correct positions. </st><st c="22449">Insertion sort, quick sort, and heap sort are examples of in-place algorithms. </st><st c="22528">Quick sort, with its in-place partitioning scheme, typically sorts the array without requiring additional storage proportional to the input size. </st><st c="22674">However, it uses </st><img src="image/1047.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre810"/><st c="22691"/><st c="22700"> extra space for the recursive stack. </st><st c="22737">Insertion sort inserts elements into their correct positions within the array, requiring no extra space beyond a few variables for looping and swapping. </st><st c="22890">Finally, heap sort transforms the array into a heap structure and then sorts it in place. </st><st c="22980">This is achieved by repeatedly removing the maximum element (or minimum, depending on the desired order) and then restoring the heap property to maintain </st><span><st c="23134">the structure.</st></span></p>
			<h3 class="calibre8"><st c="23148">Non-in-place sorting</st></h3>
			<p class="calibre3"><st c="23169">Sorting algorithms</st><a id="_idIndexMarker313" class="pcalibre pcalibre1 calibre6"/><st c="23188"> that operate outside the input data and require additional memory space, either linearly or non-linearly </st><a id="_idIndexMarker314" class="pcalibre pcalibre1 calibre6"/><st c="23294">proportional to the input size, are referred to as non-in-place sorting algorithms. </st><st c="23378">These algorithms use extra space to store copies of the data or intermediate results during the sorting process. </st><st c="23491">Non-in-place sorting algorithms consume more memory because they need additional storage to hold temporary copies of the data or intermediate structures. </st><st c="23645">On the other hand, these algorithms can be simpler to implement and understand, and they often preserve the stability of the sort more easily than </st><span><st c="23792">in-place algorithms.</st></span></p>
			<p class="calibre3"><st c="23812">Examples of non-in-place sorting are merge sort, counting sort, and Radix sort. </st><st c="23893">Merge </st><span><st c="23899">sort uses</st></span>
<img src="image/1048.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre811"/><st c="23908"/><st c="23910"> extra memory to hold the two partitions of the input being merged. </st><st c="23978">Each recursive step requires additional space to store intermediate results, leading to higher overall memory usage. </st><st c="24095">Counting sort uses additional memory proportional to the range of the input values, typically </st><img src="image/1049.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre812"/><st c="24189"/><st c="24195">, where </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="24203"/><st c="24204"> is the range of the input data. </st><st c="24237">Radix sort, like counting sort, requires extra space to hold temporary data for each digit or character being processed, resulting in </st><img src="image/1051.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre813"/><st c="24371"/> <span><st c="24377">memory usage.</st></span></p>
			<p class="calibre3"><st c="24390">When choosing between in-place and non-in-place sorting algorithms, there are several trade-offs </st><span><st c="24488">to consider:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="24500">In environments with memory constraints, in-place sorting algorithms are preferred due to their minimal </st><span><st c="24605">memory footprint.</st></span></li>
				<li class="calibre13"><st c="24622">Non-in-place algorithms may be simpler to implement and understand, particularly for complex </st><span><st c="24716">sorting tasks.</st></span></li>
				<li class="calibre13"><st c="24730">In some cases, non-in-place algorithms can offer better performance due to their ability to efficiently handle large or complex datasets, despite their higher </st><span><st c="24890">memory usage.</st></span></li>
				<li class="calibre13"><st c="24903">Non-in-place algorithms often preserve the relative order of equal elements more easily, making them stable. </st><st c="25013">Ensuring stability in in-place algorithms can be </st><span><st c="25062">more challenging.</st></span></li>
			</ul>
			<p class="calibre3"><st c="25079">Memory usage</st><a id="_idIndexMarker315" class="pcalibre pcalibre1 calibre6"/><st c="25092"> is a crucial consideration </st><a id="_idIndexMarker316" class="pcalibre pcalibre1 calibre6"/><st c="25120">when choosing a sorting algorithm. </st><st c="25155">In-place sorting methods are efficient in terms of memory consumption, as they manipulate the input array directly with minimal extra space. </st><st c="25296">However, non-in-place methods, such as merge sort and counting sort, require extra memory proportional to the input size, although they can provide advantages in terms of simplicity and stability. </st><st c="25493">The choice between in-place and non-in-place sorting depends on the specific problem. </st><st c="25579">For instance, if memory is limited, in-place sorting should </st><span><st c="25639">be considered.</st></span></p>
			<h3 class="calibre8"><st c="25653">Stability</st></h3>
			<p class="calibre3"><st c="25663">Stability in </st><a id="_idIndexMarker317" class="pcalibre pcalibre1 calibre6"/><st c="25677">sorting refers to maintaining the original relative order of elements with identical values. </st><st c="25770">A sorting algorithm is considered stable if it ensures </st><a id="_idIndexMarker318" class="pcalibre pcalibre1 calibre6"/><st c="25825">that elements with the same value keep their initial order relative to one another after sorting. </st><st c="25923">Stable algorithms include insertion sort, merge sort, and bubble sort. </st><st c="25994">In contrast, quick sort, heap sort, and selection sort are examples of </st><span><st c="26065">unstable algorithms.</st></span></p>
			<p class="calibre3"><st c="26085">The distinction between stable and unstable sorting algorithms lies in their ability to maintain the original order of equal elements. </st><st c="26221">Stable algorithms guarantee this preservation, ensuring that the relative positions of equal elements remain unchanged during sorting. </st><st c="26356">In contrast, unstable algorithms may alter the relative positions of </st><span><st c="26425">equal elements.</st></span></p>
			<p class="calibre3"><st c="26440">Consider the following list of tuples, where each tuple contains a letter and a number: [(‘A’, 3), (‘B’, 1), (‘C’, 3), (‘D’, 2), (‘</st><span><st c="26572">E’, 1)]</st></span></p>
			<p class="calibre3"><st c="26580">If we sort this list by the number (the second element in each tuple) in ascending order using a stable sorting algorithm, the result might be </st><span><st c="26724">as follows:</st></span></p>
			<p class="calibre3"><st c="26735">[(‘B’, 1), (‘E’, 1), (‘D’, 2), (‘A’, 3), (‘</st><span><st c="26779">C’, 3)]</st></span></p>
			<p class="calibre3"><st c="26787">Observe that for tuples with identical numbers (such as (‘A’, 3) and (‘C’, 3)), their original order is maintained after sorting. </st><st c="26918">In other words, (‘A’, 3) precedes (‘C’, 3) in the sorted list, just as it did in the original list. </st><st c="27018">If an unstable sorting algorithm is used, the resulting order may be </st><span><st c="27087">as follows:</st></span></p>
			<p class="calibre3"><st c="27098">[(‘E’, 1), (‘B’, 1), (‘D’, 2), (‘C’, 3), (‘</st><span><st c="27142">A’, 3)]</st></span></p>
			<p class="calibre3"><st c="27150">Here, the relative order of (‘A’, 3) and (‘C’, 3) is </st><span><st c="27204">not preserved.</st></span></p>
			<p class="calibre3"><st c="27218">Stability is</st><a id="_idIndexMarker319" class="pcalibre pcalibre1 calibre6"/><st c="27231"> particularly important in the </st><span><st c="27262">following scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="27282">Multiple key sorts</st></strong><st c="27301">: When </st><a id="_idIndexMarker320" class="pcalibre pcalibre1 calibre6"/><st c="27309">performing multi-level sorting (e.g., sorting first by one attribute and then by another), stability ensures that the order from the previous sort is preserved. </st><st c="27470">For example, if you first sort a list of employees by their employment status and then by their employee numbers, a stable sort will maintain the employment status order while sorting </st><span><st c="27654">by id.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="27660">Preserving input order</st></strong><st c="27683">: In</st><a id="_idIndexMarker321" class="pcalibre pcalibre1 calibre6"/><st c="27688"> some applications, the order of input elements carries significance beyond their sorted position. </st><st c="27787">Stability ensures that this significance </st><span><st c="27828">is preserved.</st></span></li>
			</ul>
			<p class="calibre3"><st c="27841">Stability is crucial in applications requiring multiple levels of sorting or where the input order carries additional information. </st><st c="27973">Stable sorting algorithms are preferred in such contexts to ensure data integrity </st><span><st c="28055">and correctness.</st></span></p>
			<h1 id="_idParaDest-82" class="calibre5"><a id="_idTextAnchor090" class="pcalibre pcalibre1 calibre6"/><st c="28071">Iterative sorting algorithms</st></h1>
			<p class="calibre3"><st c="28100">Iterative sorting algorithms </st><a id="_idIndexMarker322" class="pcalibre pcalibre1 calibre6"/><st c="28130">are renowned for their simplicity, making them easy to understand, implement, and debug. </st><st c="28219">The major advantage of iterative sorting methods is their space efficiency; they typically require minimal additional memory, which can be a significant benefit in memory-constrained environments. </st><st c="28416">However, these algorithms often exhibit poor performance in terms of time complexity, especially when handling large datasets. </st><st c="28543">This limitation can be particularly problematic in scenarios where data size and processing time are critical factors. </st><st c="28662">This section introduces three common iterative sorting algorithms: bubble sort, selection sort, and </st><span><st c="28762">insertion sort.</st></span></p>
			<h2 id="_idParaDest-83" class="calibre5"><a id="_idTextAnchor091" class="pcalibre pcalibre1 calibre6"/><st c="28777">Bubble sort</st></h2>
			<p class="calibre3"><st c="28789">Bubble sort is a</st><a id="_idIndexMarker323" class="pcalibre pcalibre1 calibre6"/><st c="28806"> simple comparison-based algorithm </st><a id="_idIndexMarker324" class="pcalibre pcalibre1 calibre6"/><st c="28841">that repeatedly scans through an array, comparing and swapping adjacent elements if they are in the wrong order. </st><st c="28954">This process is repeated until the entire array is sorted. </st><st c="29013">The analogy of “bubbling” arises from how smaller elements gradually ascend to the top while larger ones descend to </st><span><st c="29129">the bottom.</st></span></p>
			<p class="calibre3"><st c="29140">Despite its</st><a id="_idIndexMarker325" class="pcalibre pcalibre1 calibre6"/><st c="29152"> simplicity, bubble sort is generally </st><a id="_idIndexMarker326" class="pcalibre pcalibre1 calibre6"/><st c="29190">inefficient for sorting datasets, exhibiting a quadratic running time, </st><img src="image/1052.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;²&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre814"/><st c="29261"/><st c="29262"> in both average and worst-case scenarios. </st><st c="29305">Nonetheless, its ease of comprehension and implementation make it a valuable educational tool and a viable option for sorting small datasets. </st><st c="29447">As we have seen in the previous section, bubble sort is a stable and in-place algorithm and its space complexity </st><span><st c="29560">is </st></span><span><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="29563"/></span><span><st c="29564">.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="29565">Example 6.2</st></strong></span></p>
			<p class="calibre3"><em class="italic"><st c="29577">Table 6.3</st></em><st c="29587"> illustrates</st><a id="_idIndexMarker327" class="pcalibre pcalibre1 calibre6"/><st c="29599"> the step-by-step process of bubble sort for the array [</st><strong class="source-inline"><st c="29655">5, 3, 8, 4, 2, 7, </st></strong><span><strong class="source-inline"><st c="29674">1, 6</st></strong></span><span><st c="29678">]:</st></span></p>
			<table id="table003-1" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="29681">Pass</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="29686">Description of </st></strong><span><strong class="bold"><st c="29702">the operation</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="29715">Content of </st></strong><span><strong class="bold"><st c="29727">the array</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="29736">1</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="29738">5 vs 3, </st><span><st c="29746">swap them</st></span></p>
							<p class="calibre3"><st c="29755">5 vs 8, </st><span><st c="29764">no swap</st></span></p>
							<p class="calibre3"><st c="29771">8 vs 4, </st><span><st c="29780">swap them</st></span></p>
							<p class="calibre3"><st c="29789">8 vs 2, </st><span><st c="29798">swap them</st></span></p>
							<p class="calibre3"><st c="29807">8 vs 7, </st><span><st c="29816">swap them</st></span></p>
							<p class="calibre3"><st c="29825">8 vs 1, </st><span><st c="29834">swap them</st></span></p>
							<p class="calibre3"><st c="29843">8 vs 6, </st><span><st c="29852">swap them</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="29861">[3, 5, 8, 4, 2, 7, </st><span><st c="29881">1, 6]</st></span></p>
							<p class="calibre3"><st c="29886">[3, 5, 8, 4, 2, 7, </st><span><st c="29906">1, 6]</st></span></p>
							<p class="calibre3"><st c="29911">[3, 5, 4, 8, 2, 7, </st><span><st c="29931">1, 6]</st></span></p>
							<p class="calibre3"><st c="29936">[3, 5, 4, 2, 8, 7, </st><span><st c="29956">1, 6]</st></span></p>
							<p class="calibre3"><st c="29961">[3, 5, 4, 2, 7, 8, </st><span><st c="29981">1, 6]</st></span></p>
							<p class="calibre3"><st c="29986">[3, 5, 4, 2, 7, 1, </st><span><st c="30006">8, 6]</st></span></p>
							<p class="calibre3"><st c="30011">[3, 5, 4, 2, 7, 1, </st><span><st c="30031">6, 8]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="30036">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30038">3 vs 5, </st><span><st c="30046">no swap</st></span></p>
							<p class="calibre3"><st c="30053">5 vs 4, </st><span><st c="30062">swap them</st></span></p>
							<p class="calibre3"><st c="30071">5 vs 2, </st><span><st c="30080">swap them</st></span></p>
							<p class="calibre3"><st c="30089">5 vs 7, </st><span><st c="30098">no swap</st></span></p>
							<p class="calibre3"><st c="30105">7 vs 1, </st><span><st c="30114">swap them</st></span></p>
							<p class="calibre3"><st c="30123">7 vs 6, </st><span><st c="30132">swap them</st></span></p>
							<p class="calibre3"><st c="30141">8 is now in its </st><span><st c="30158">correct position</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30174">[3, 5, 4, 2, 7, 1, </st><span><st c="30194">6, 8]</st></span></p>
							<p class="calibre3"><st c="30199">[3, 4, 5, 2, 7, 1, </st><span><st c="30219">6, 8]</st></span></p>
							<p class="calibre3"><st c="30224">[3, 4, 2, 5, 7, 1, </st><span><st c="30244">6, 8]</st></span></p>
							<p class="calibre3"><st c="30249">[3, 4, 2, 5, 7, 1, </st><span><st c="30269">6, 8]</st></span></p>
							<p class="calibre3"><st c="30274">[3, 4, 2, 5, 1, 7, </st><span><st c="30294">6, 8]</st></span></p>
							<p class="calibre3"><st c="30299">[3, 4, 2, 5, 1, 6, </st><span><st c="30319">7, 8]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="30324">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30326">3 vs 4, </st><span><st c="30334">no swap</st></span></p>
							<p class="calibre3"><st c="30341">4 vs 2, </st><span><st c="30350">swap them</st></span></p>
							<p class="calibre3"><st c="30359">4 vs 5, </st><span><st c="30368">no swap</st></span></p>
							<p class="calibre3"><st c="30375">5 vs 1, </st><span><st c="30384">swap them</st></span></p>
							<p class="calibre3"><st c="30393">5 vs 6, </st><span><st c="30402">no swap</st></span></p>
							<p class="calibre3"><st c="30409">7 and 8 are now in their </st><span><st c="30435">correct positions</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30452">[3, 4, 2, 5, 1, 6, </st><span><st c="30472">7, 8]</st></span></p>
							<p class="calibre3"><st c="30477">[3, 2, 4, 5, 1, 6, </st><span><st c="30497">7, 8]</st></span></p>
							<p class="calibre3"><st c="30502">[3, 2, 4, 5, 1, 6, </st><span><st c="30522">7, 8]</st></span></p>
							<p class="calibre3"><st c="30527">[3, 2, 4, 1, 5, 6, </st><span><st c="30547">7, 8]</st></span></p>
							<p class="calibre3"><st c="30552">[3, 2, 4, 1, 5, 6, </st><span><st c="30572">7, 8]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="30577">4</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30579">3 vs 2, </st><span><st c="30587">swap them</st></span></p>
							<p class="calibre3"><st c="30596">3 vs 4, </st><span><st c="30605">no swap</st></span></p>
							<p class="calibre3"><st c="30612">4 vs 1, </st><span><st c="30621">swap them</st></span></p>
							<p class="calibre3"><st c="30630">4 vs 5, </st><span><st c="30639">no swap</st></span></p>
							<p class="calibre3"><st c="30646">6, 7, and 8 are now in their </st><span><st c="30676">correct positions</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30693">[2, 3, 4, 1, 5, 6, </st><span><st c="30713">7, 8]</st></span></p>
							<p class="calibre3"><st c="30718">[2, 3, 4, 1, 5, 6, </st><span><st c="30738">7, 8]</st></span></p>
							<p class="calibre3"><st c="30743">[2, 3, 1, 4, 5, 6, </st><span><st c="30763">7, 8]</st></span></p>
							<p class="calibre3"><st c="30768">[2, 3, 1, 4, 5, 6, </st><span><st c="30788">7, 8]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="30793">5</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30795">2 vs 3, </st><span><st c="30803">no swap</st></span></p>
							<p class="calibre3"><st c="30810">3 vs 1, </st><span><st c="30819">swap them</st></span></p>
							<p class="calibre3"><st c="30828">3 vs 4, </st><span><st c="30837">no swap</st></span></p>
							<p class="calibre3"><st c="30844">5, 6, 7, and 8 are now in their </st><span><st c="30877">correct positions</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30894">[2, 3, 1, 4, 5, 6, </st><span><st c="30914">7, 8]</st></span></p>
							<p class="calibre3"><st c="30919">[2, 1, 3, 4, 5, 6, </st><span><st c="30939">7, 8]</st></span></p>
							<p class="calibre3"><st c="30944">[2, 1, 3, 4, 5, 6, </st><span><st c="30964">7, 8]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="30969">6</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="30971">2 vs 1, </st><span><st c="30979">swap them</st></span></p>
							<p class="calibre3"><st c="30988">2 vs 3, </st><span><st c="30997">no swap</st></span></p>
							<p class="calibre3"><st c="31004">4, 5, 6, 7, and 8 are now in their </st><span><st c="31040">correct positions</st></span></p>
							<p class="calibre3"><st c="31057">Now the array </st><span><st c="31072">is sorted.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="31082">[1, 2, 3, 4, 5, 6, </st><span><st c="31102">7, 8]</st></span></p>
							<p class="calibre3"><st c="31107">[1, 2, 3, 4, 5, 6, </st><span><st c="31127">7, 8]</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="31132">Table 6.3: Demonstrating an example of bubble sort</st></p>
			<p class="calibre3"><st c="31183">Here is the </st><a id="_idIndexMarker328" class="pcalibre pcalibre1 calibre6"/><st c="31196">Python implementation of the bubble </st><span><st c="31232">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="31247" class="calibre11">
def bubble_sort_iterative(a):
    n = len(a)
    for i in range(n):
        elements_swapped = False
        for j in range(0, n - i - 1):
            if a[j] &gt; a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                elements_swapped = True
        if not elements_swapped:
            break
    return a</st></pre>			<p class="calibre3"><st c="31478">The bubble sort algorithm is quite simple. </st><st c="31522">It consists of two nested loops; the outer loop always</st><a id="_idIndexMarker329" class="pcalibre pcalibre1 calibre6"/><st c="31576"> executes </st><img src="image/1054.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre815"/><st c="31586"/><st c="31587"> times, while the inner loop can terminate early if the array is already sorted or nearly sorted (indicating no swaps </st><span><st c="31705">are necessary).</st></span></p>
			<p class="calibre3"><st c="31720">Now, let’s analyze the correctness of bubble sort and evaluate its </st><span><st c="31788">time complexity.</st></span></p>
			<h3 class="calibre8"><st c="31804">Proof of correctness</st></h3>
			<p class="calibre3"><st c="31825">As</st><a id="_idIndexMarker330" class="pcalibre pcalibre1 calibre6"/><st c="31828"> discussed in </st><a href="B22248_02.xhtml#_idTextAnchor023" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="31842">Chapter 2</st></em></span></a><st c="31851">, we utilize the concept of a loop invariant to prove the correctness of algorithms. </st><st c="31936">A loop invariant is a condition that remains true before and after each iteration of </st><span><st c="32021">a loop.</st></span></p>
			<p class="calibre3"><st c="32028">The loop invariant for bubble sort states that at the beginning of each iteration of the outer loop (</st><strong class="source-inline"><st c="32130">for i in range(n):</st></strong><st c="32149">), the last </st><strong class="source-inline"><st c="32162">i</st></strong><st c="32163"> elements are sorted and in their final positions. </st><st c="32214">To establish the correctness of the algorithm, we need to assess </st><span><st c="32279">three conditions:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="32296">Initialization</st></strong><st c="32311">: Before the first iteration (</st><em class="italic"><st c="32342">i</st></em><st c="32344"> = 0), no elements have been processed. </st><st c="32384">The invariant trivially holds since the empty sub-array </st><span><st c="32440">is sorted.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="32450">Maintenance</st></strong><st c="32462">: Assume the invariant holds before the </st><em class="italic"><st c="32503">i</st></em><span class="superscript"><st c="32504" class="calibre11">th</st></span><st c="32506"> iteration. </st><st c="32518">During the </st><em class="italic"><st c="32529">i</st></em><span class="superscript"><st c="32530" class="calibre11">th</st></span><st c="32532"> iteration, the adjacent elements are compared and swapped if they are not in the right order. </st><st c="32627">By the end of the </st><em class="italic"><st c="32645">i</st></em><span class="superscript"><st c="32646" class="calibre11">th</st></span><st c="32648"> pass, the largest unsorted element is “bubbled up” to its correct position in the array, ensuring that the last </st><em class="italic"><st c="32761">i</st></em><st c="32762"> elements are sorted. </st><st c="32784">Thus, the invariant </st><span><st c="32804">is maintained.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="32818">Termination</st></strong><st c="32830">: The algorithm terminates after </st><img src="image/1055.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre816"/><st c="32864"/><st c="32865"> iterations of the outer loop, where </st><img src="image/1055.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre816"/><st c="32902"/><st c="32903"> is the size of input data. </st><st c="32931">At this point, the invariant guarantees that the entire array is sorted, as the last </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="33016"/><st c="33065"> elements (i.e., the entire array) are in their </st><span><st c="33112">correct positions.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="33130">Complexity analysis</st></h3>
			<p class="calibre3"><st c="33150">To understand </st><a id="_idIndexMarker331" class="pcalibre pcalibre1 calibre6"/><st c="33165">time complexity, we can analyze it in the </st><span><st c="33207">following scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="33227">Best case</st></strong><st c="33237">: </st><img src="image/1011.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre817"/><st c="33240"/><st c="33241"> – This happens when the array is already sorted. </st><st c="33291">The algorithm will make a single pass through the array without performing any swaps and terminate early, as no out-of-order pairs (“bubbles”) will </st><span><st c="33439">be found</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="33447">Average case</st></strong><st c="33460">: </st><img src="image/1059.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre818"/><st c="33463"/><st c="33469"> – This occurs when input data is random. </st><st c="33510">The algorithm will need to make multiple passes, each involving </st><img src="image/1060.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre819"/><st c="33574"/> <span><st c="33575">comparisons.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="33587">Worst case</st></strong><st c="33598">: </st><img src="image/1061.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre820"/><st c="33601"/><st c="33607"> – This occurs when the array is sorted in reverse order. </st><st c="33664">Bubble sort needs to perform the maximum number of comparisons and swaps during each pass through </st><span><st c="33762">the array.</st></span></li>
			</ul>
			<p class="calibre3"><st c="33772">To determine</st><a id="_idIndexMarker332" class="pcalibre pcalibre1 calibre6"/><st c="33785"> space complexity, we need to evaluate the auxiliary or temporary memory used during sorting. </st><st c="33879">Bubble sort is recognized as an in-place algorithm, meaning it works directly on the input array and only requires a constant amount of extra space for </st><span><st c="34031">swapping elements.</st></span></p>
			<h2 id="_idParaDest-84" class="calibre5"><a id="_idTextAnchor092" class="pcalibre pcalibre1 calibre6"/><st c="34049">Selection sort</st></h2>
			<p class="calibre3"><st c="34064">Selection sort</st><a id="_idIndexMarker333" class="pcalibre pcalibre1 calibre6"/><st c="34079"> is a comparison-based method that </st><a id="_idIndexMarker334" class="pcalibre pcalibre1 calibre6"/><st c="34114">divides a list into two parts: a sorted section, which starts empty and grows, and an unsorted section, which starts with all the elements and shrinks. </st><st c="34266">In each step, the algorithm finds the smallest (or largest) item in the unsorted part and moves it to the end of the sorted part. </st><st c="34396">This continues until the entire list </st><span><st c="34433">is sorted.</st></span></p>
			<p class="calibre3"><st c="34443">Selection sort, characterized by its simplicity, consistently exhibits a quadratic running time, </st><img src="image/1062.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;²&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre821"/><st c="34541"/><st c="34542">in the best, average, and worst-case scenarios. </st><st c="34590">While inefficient for large datasets, its straightforward nature makes it easy to grasp and implement. </st><st c="34693">This algorithm is not adaptive, meaning it doesn’t exploit any existing order within the data. </st><st c="34788">However, selection sort operates directly within the input data, requiring only a small, constant amount of additional memory (</st><img src="image/1063.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre822"/><st c="34915"/><st c="34917">). </st><st c="34920">It is important to note that selection sort is unstable and does not guarantee maintaining the original order of identical elements. </st><st c="35053">Despite its drawbacks, selection sort is useful for sorting small data sets and easy </st><span><st c="35138">to implement.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="35151">Example 6.3</st></strong></span></p>
			<p class="calibre3"><em class="italic"><st c="35163">Table 6.4</st></em><st c="35173"> illustrates</st><a id="_idIndexMarker335" class="pcalibre pcalibre1 calibre6"/><st c="35185"> the step-by-step process of selection sort for the array [</st><strong class="source-inline"><st c="35244">29, 10, 14, 37, </st></strong><span><strong class="source-inline"><st c="35261">13, 5</st></strong></span><span><st c="35266">]:</st></span></p>
			<table id="table004-1" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="35269">Pass</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="35274">Description of </st></strong><span><strong class="bold"><st c="35290">the operation</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="35303">Content of </st></strong><span><strong class="bold"><st c="35315">the array</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="35324">1</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35326">Find the minimum in [29, 10, 14, 37, 13, 5] (which is 5), and swap the minimum with the </st><span><st c="35414">first element</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35427">[5, 10, 14, 37, </st><span><st c="35444">13, 29]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="35451">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35453">Find the minimum element in [10, 14, 37, 13, 29] (which is 10), and swap the minimum with the second element (no swap needed as it’s already </st><span><st c="35594">in place)</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35603">[5, 10, 14, 37, </st><span><st c="35620">13, 29]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="35627">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35629">Find the minimum in [14, 37, 13, 29] (which is 13), and swap the minimum with the </st><span><st c="35711">third element</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35724">[5, 10, 13, 37, </st><span><st c="35741">14, 29]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="35748">4</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35750">Find the minimum in [37, 14, 29] (which is 14), and swap the minimum with the </st><span><st c="35828">fourth element</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35842">[5, 10, 13, 14, </st><span><st c="35859">29, 37]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="35866">5</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35868">Find the minimum in [37, 29] (which is 29), and swap the minimum with the </st><span><st c="35942">fifth element</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="35955">[5, 10, 13, 14, </st><span><st c="35972">37, 29]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="35979">Now the array </st><span><st c="35994">is sorted.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="36004">[5, 10, 13, 14, </st><span><st c="36021">29, 37]</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="36028">Table 6.4: Demonstrating an example of selection sort</st></p>
			<p class="calibre3"><st c="36082">The </st><a id="_idIndexMarker336" class="pcalibre pcalibre1 calibre6"/><st c="36087">following </st><a id="_idIndexMarker337" class="pcalibre pcalibre1 calibre6"/><st c="36097">is the Python implementation of the selection </st><span><st c="36143">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="36158" class="calibre11">
def selection_sort_iterative(a):
    n = len(a)
    for i in range(n):
        min_id = i
        for j in range(i + 1, n):
            if a[j] &lt; a[min_id]:
                min_id = j
        a[i], a[min_id] = a[min_id], a[i]
    return a</st></pre>			<p class="calibre3"><st c="36333">The selection sort algorithm is straightforward. </st><st c="36383">The outer loop, </st><strong class="source-inline"><st c="36399">for i in range(n):</st></strong><st c="36417">, traverses the array, </st><strong class="source-inline"><st c="36440">a</st></strong><st c="36441">, and the inner loop, </st><strong class="source-inline"><st c="36463">for j in range(i + 1, n):</st></strong><st c="36488">, finds the element with the minimum value. </st><st c="36532">Then, the minimum and the element at the top of </st><a id="_idIndexMarker338" class="pcalibre pcalibre1 calibre6"/><st c="36580">the sub-array are swapped: </st><strong class="source-inline"><st c="36607">a[i], a[min_id] = </st></strong><span><strong class="source-inline"><st c="36625">a[min_id], a[i]</st></strong></span><span><st c="36640">.</st></span></p>
			<p class="calibre3"><st c="36641">Let’s examine the correctness of the algorithm and also evaluate </st><span><st c="36707">its complexities.</st></span></p>
			<h3 class="calibre8"><st c="36724">Proof of correctness</st></h3>
			<p class="calibre3"><st c="36745">The</st><a id="_idIndexMarker339" class="pcalibre pcalibre1 calibre6"/><st c="36749"> loop invariant in selection sort states that at the beginning of each iteration of the outer loop (</st><strong class="source-inline"><st c="36849">for i in range(n):</st></strong><st c="36868">), the sub-array, </st><strong class="source-inline"><st c="36887">a[0:i]</st></strong><st c="36893">, consists of the smallest </st><strong class="source-inline"><st c="36920">i</st></strong><st c="36921"> elements from the original array, arranged in ascending order. </st><st c="36985">We need to evaluate three conditions for the </st><span><st c="37030">algorithm’s correctness:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="37054">Initialization</st></strong><st c="37069">: Before the first iteration (</st><em class="italic"><st c="37100">i</st></em><st c="37102"> = 0), the sub-array, </st><strong class="source-inline1"><st c="37124">a[0:0]</st></strong><st c="37130">, is empty. </st><st c="37142">The invariant trivially holds since the empty sub-array </st><span><st c="37198">is sorted.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="37208">Maintenance</st></strong><st c="37220">: Let’s assume the invariant holds true before the </st><img src="image/1064.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre823"/><st c="37272"/><st c="37276"> iteration. </st><st c="37287">During this iteration, the algorithm identifies the smallest element within the sub-array, </st><strong class="source-inline1"><st c="37378">a[i:n]</st></strong><st c="37384">, and swaps it with </st><strong class="source-inline1"><st c="37404">a[i]</st></strong><st c="37408">. Consequently, </st><strong class="source-inline1"><st c="37424">a[i]</st></strong><st c="37428"> becomes the smallest element in </st><strong class="source-inline1"><st c="37461">a[i:n]</st></strong><st c="37467">, and the sub-array, </st><strong class="source-inline1"><st c="37488">a[0:i+1]</st></strong><st c="37496">, is sorted. </st><st c="37509">This ensures the invariant </st><span><st c="37536">is maintained.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="37550">Termination</st></strong><st c="37562">: The algorithm terminates after </st><em class="italic"><st c="37596">n</st></em><st c="37597"> iterations of the outer loop. </st><st c="37628">At this point, the invariant guarantees that the entire array, </st><strong class="source-inline1"><st c="37691">a[0:n]</st></strong><st c="37697">, is sorted, as all elements have </st><span><st c="37731">been processed.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="37746">Complexity analysis</st></h3>
			<p class="calibre3"><st c="37766">To </st><a id="_idIndexMarker340" class="pcalibre pcalibre1 calibre6"/><st c="37770">evaluate the time complexity of selection sort, consider the two nested loops. </st><st c="37849">The outer loop runs </st><img src="image/1065.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre672"/><st c="37869"/><st c="37870"> times, and for each iteration, the inner loop runs </st><img src="image/1066.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre824"/><st c="37922"/><st c="37923"> times, leading to a total of </st><img src="image/1067.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre825"/><st c="37953"/><st c="37964"> comparisons. </st><st c="37977">Since this operation dominates the algorithm’s runtime, the time complexity for the best, average, and worst cases </st><span><st c="38092">is </st></span><span><img src="image/1068.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre826"/><st c="38095"/></span><span><st c="38101">.</st></span></p>
			<p class="calibre3"><st c="38102">For space complexity, we need to determine the auxiliary or temporary memory used to execute selection sort. </st><st c="38212">Since it uses an in-place approach, it only needs a constant amount of extra space for swapping elements, making its space </st><span><st c="38335">complexity </st></span><span><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="38346"/></span><span><st c="38347">.</st></span></p>
			<h2 id="_idParaDest-85" class="calibre5"><a id="_idTextAnchor093" class="pcalibre pcalibre1 calibre6"/><st c="38348">Insertion sort</st></h2>
			<p class="calibre3"><st c="38363">Insertion sort</st><a id="_idIndexMarker341" class="pcalibre pcalibre1 calibre6"/><st c="38378"> is a simple and intuitive algorithm that builds the final ordered list gradually, one element at a time. </st><st c="38484">Insertion sort</st><a id="_idIndexMarker342" class="pcalibre pcalibre1 calibre6"/><st c="38498"> operates by splitting the array into a sorted section and an unsorted section. </st><st c="38578">With each step, the algorithm takes the next element from the unsorted section and inserts it into its proper place within the sorted section. </st><st c="38721">This process is analogous to how one might sort playing cards, placing each card in the correct place relative to the cards </st><span><st c="38845">already sorted.</st></span></p>
			<p class="calibre3"><st c="38860">The time complexity of insertion sort is </st><img src="image/1070.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;²&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre827"/><st c="38902"/><st c="38903"> for both average and worst-case scenarios. </st><st c="38947">However, it demonstrates impressive efficiency with a time complexity of </st><img src="image/1071.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre828"/><st c="39020"/><st c="39021"> when dealing with nearly sorted or </st><span><st c="39057">small datasets.</st></span></p>
			<p class="calibre3"><st c="39072">A key advantage of insertion sort is its stability as a sorting method. </st><st c="39145">Moreover, it is an in-place algorithm, requiring only a constant amount of additional memory. </st><st c="39239">Its simplicity and efficiency with small datasets make insertion sort valuable in specific situations and an excellent educational tool for understanding fundamental </st><span><st c="39405">sorting concepts.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="39422">Example 6.4</st></strong></span></p>
			<p class="calibre3"><em class="italic"><st c="39434">Table 6.5</st></em><st c="39444"> illustrates</st><a id="_idIndexMarker343" class="pcalibre pcalibre1 calibre6"/><st c="39456"> the step-by-step process of insertion sort for the array [</st><strong class="source-inline"><st c="39515">8, 3, 1, 7, </st></strong><span><strong class="source-inline"><st c="39528">0, 10</st></strong></span><span><st c="39533">]:</st></span></p>
			<table id="table005-1" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="39536">Pass</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="39541">Description of </st></strong><span><strong class="bold"><st c="39557">the operation</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="39570">Content of </st></strong><span><strong class="bold"><st c="39582">the array</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="39591">1</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39593">Key = 3, compare 3 with 8, and move 8 to </st><span><st c="39634">the right.</st></span></p>
							<p class="calibre3"><st c="39644">Insert 3 at the </st><span><st c="39661">correct position.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39678">[3, 8, 1, 7, </st><span><st c="39692">0, 10]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="39698">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39700">Key = 1, compare 1 with 8, and move 8 to </st><span><st c="39741">the right.</st></span></p>
							<p class="calibre3"><st c="39751">Compare 1 with 3, and move 3 to </st><span><st c="39784">the right.</st></span></p>
							<p class="calibre3"><st c="39794">Insert 1 at the </st><span><st c="39811">correct position.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39828">[1, 3, 8, 7, </st><span><st c="39842">0, 10]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="39848">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39850">Key = 7, compare 7 with 8, and move 8 to </st><span><st c="39891">the right.</st></span></p>
							<p class="calibre3"><st c="39901">Insert 7 at the </st><span><st c="39918">correct position.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39935">[1, 3, 7, 8, </st><span><st c="39949">0, 10]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="39955">4</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="39957">Key = 0, compare 0 with 8, and move 8 to </st><span><st c="39998">the right.</st></span></p>
							<p class="calibre3"><st c="40008">Compare 0 with 7, and move 7 to </st><span><st c="40041">the right.</st></span></p>
							<p class="calibre3"><st c="40051">Compare 0 with 3, and move 3 to </st><span><st c="40084">the right.</st></span></p>
							<p class="calibre3"><st c="40094">Compare 0 with 1, and move 1 to </st><span><st c="40127">the right.</st></span></p>
							<p class="calibre3"><st c="40137">Insert 0 at the </st><span><st c="40154">correct position.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="40171">[0, 1, 3, 7, </st><span><st c="40185">8, 10]</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="40191">5</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="40193">Key = 10, no elements to move, insert 10 at the correct position. </st><st c="40259">Now the array </st><span><st c="40273">is sorted.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="40283">[0, 1, 3, 7, </st><span><st c="40297">8, 10]</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="40303">Table 6.5: Demonstrating an example of insertion sort</st></p>
			<p class="calibre3"><st c="40357">The</st><a id="_idIndexMarker344" class="pcalibre pcalibre1 calibre6"/><st c="40361"> following is a simple Python implementation of</st><a id="_idIndexMarker345" class="pcalibre pcalibre1 calibre6"/> <span><st c="40408">insertion sort:</st></span></p>
			<pre class="source-code"><st c="40424" class="calibre11">
def insertion_sort_iterative(a):
    n = len(a)
    for i in range(1, n):
        pointer = a[i]
        j = i - 1
        while j &gt;= 0 and pointer &lt; a[j]:
            a[j + 1] = a[j]
            j -= 1
        a[j + 1] = pointer
    return a</st></pre>			<p class="calibre3"><st c="40599">The core of the insertion sort algorithm lies in its inner </st><strong class="source-inline"><st c="40659">while</st></strong><st c="40664"> loop (</st><strong class="source-inline"><st c="40671">while j &gt;= 0 and key &lt; a[j]:</st></strong><st c="40700">). </st><st c="40704">The condition in the </st><strong class="source-inline"><st c="40725">while</st></strong><st c="40730"> loop ensures that if the data is pre-sorted (or nearly sorted), the algorithm performs linearly in terms of time complexity. </st><st c="40856">Let’s discuss the algorithm’s correctness and its complexity </st><span><st c="40917">in detail.</st></span></p>
			<h3 class="calibre8"><st c="40927">Proof of correctness</st></h3>
			<p class="calibre3"><st c="40948">The</st><a id="_idIndexMarker346" class="pcalibre pcalibre1 calibre6"/><st c="40952"> loop invariant for insertion sort states that at the beginning of each iteration of the outer loop (</st><strong class="source-inline"><st c="41053">for i in range(1, n):</st></strong><st c="41075">), the elements in </st><strong class="source-inline"><st c="41095">a[0:i]</st></strong><st c="41101"> consist of the same elements that can be found in </st><strong class="source-inline"><st c="41152">a[0:i]</st></strong><st c="41158">, but now in sorted order. </st><st c="41185">To establish the correctness of the algorithm, we need to assess the following </st><span><st c="41264">three conditions:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="41281">Initialization</st></strong><st c="41296">: Before the first iteration (i = 1), the sub-array, </st><strong class="source-inline1"><st c="41350">a[0:1]</st></strong><st c="41356">, is just the first element of the array, which is trivially in the correct </st><span><st c="41432">position (sorted).</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="41450">Maintenance</st></strong><st c="41462">: Let’s assume the loop invariant holds before the </st><em class="italic"><st c="41514">i</st></em><span class="superscript"><st c="41515" class="calibre11">th</st></span><em class="italic"> </em><st c="41517">iteration. </st><st c="41529">The algorithm inserts </st><strong class="source-inline1"><st c="41551">a[i]</st></strong><st c="41555"> into the sorted sub-array, </st><strong class="source-inline1"><st c="41583">a[0:i]</st></strong><st c="41589">, by moving elements that are greater than </st><strong class="source-inline1"><st c="41632">a[i]</st></strong><st c="41636"> one position to the right. </st><st c="41664">This insertion ensures that </st><strong class="source-inline1"><st c="41692">a[0:i+1]</st></strong><st c="41700"> is sorted. </st><st c="41712">Thus, the invariant </st><span><st c="41732">is maintained.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="41746">Termination</st></strong><st c="41758">: The algorithm terminates after </st><img src="image/1072.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre829"/><st c="41792"/><st c="41793"> iterations of the outer loop, where </st><img src="image/1072.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre829"/><st c="41830"/><st c="41831"> is the length of the array. </st><st c="41860">At this point, the invariant guarantees that the entire array, </st><strong class="source-inline1"><st c="41923">a[0:n]</st></strong><st c="41929">, is sorted, as all elements have </st><span><st c="41963">been processed.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="41978">Complexity analysis</st></h3>
			<p class="calibre3"><st c="41998">To understand</st><a id="_idIndexMarker347" class="pcalibre pcalibre1 calibre6"/><st c="42012"> the time complexity, we can analyze it in the </st><span><st c="42059">following scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="42079">Best case</st></strong><st c="42089">: </st><img src="image/1074.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre830"/><st c="42092"/><st c="42093"> – As previously demonstrated, the condition in the </st><strong class="source-inline1"><st c="42145">while</st></strong><st c="42150"> loop ensures that if the input is already sorted, the </st><strong class="source-inline1"><st c="42205">while</st></strong><st c="42210"> loop does not execute, guaranteeing a linear </st><span><st c="42256">time complexity.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="42272">Average case</st></strong><st c="42285">: </st><img src="image/1075.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre831"/><st c="42288"/><st c="42294"> – The algorithm performs </st><img src="image/1076.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre832"/><st c="42319"/><st c="42328"> comparisons and </st><img src="image/1076.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre833"/><st c="42344"/><st c="42353"> swaps </st><span><st c="42359">on average.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="42370">Worst case</st></strong><st c="42381">: </st><img src="image/1078.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre834"/><st c="42384"/><st c="42390"> – This occurs when the input array is sorted in reverse order. </st><st c="42453">In this scenario, the condition of the </st><strong class="source-inline1"><st c="42492">while</st></strong><st c="42497"> loop causes it to execute </st><img src="image/485.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre362"/><st c="42524"/><st c="42525"> times in each iteration. </st><st c="42551">Given that the outer loop runs </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="42582"/><st c="42631"> times, the maximum number of comparisons and swaps will </st><span><st c="42687">be </st></span><span><img src="image/1081.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre835"/><st c="42690"/></span><span><st c="42701">.</st></span></li>
			</ul>
			<p class="calibre3"><st c="42702">To assess </st><a id="_idIndexMarker348" class="pcalibre pcalibre1 calibre6"/><st c="42713">the space complexity, we need to evaluate the auxiliary or temporary space required to run insertion sort. </st><st c="42820">Given that insertion sort is an in-place algorithm, it only requires a constant amount of extra space for element swapping. </st><st c="42944">Consequently, its space complexity </st><span><st c="42979">is </st></span><span><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="42982"/></span><span><st c="42983">.</st></span></p>
			<p class="calibre3"><st c="42984">Having covered the major iterative sorting algorithms, we will now shift our focus to discussing recursive </st><span><st c="43092">sorting methods.</st></span></p>
			<h1 id="_idParaDest-86" class="calibre5"><a id="_idTextAnchor094" class="pcalibre pcalibre1 calibre6"/><st c="43108">Recursive sorting algorithms</st></h1>
			<p class="calibre3"><st c="43137">The</st><a id="_idIndexMarker349" class="pcalibre pcalibre1 calibre6"/><st c="43141"> iterative, non-recursive sorting algorithms, while typically space efficient, often fall short in terms of time complexity, particularly when handling large datasets. </st><st c="43309">This limitation becomes critical in scenarios involving substantial amounts of data, where more efficient sorting mechanisms are necessary. </st><st c="43449">In </st><em class="italic"><st c="43452">Table 6.1</st></em><st c="43461">, we discussed the general characteristics of recursive sorting algorithms, highlighting their potential to overcome the time complexity issues associated with </st><span><st c="43621">iterative methods.</st></span></p>
			<p class="calibre3"><st c="43639">In this section, we analyze two major recursive sorting algorithms: merge sort and quick sort. </st><st c="43735">Both algorithms leverage the divide-and-conquer strategy to achieve superior performance compared to their iterative counterparts. </st><st c="43866">Merge sort, with its consistent </st><img src="image/1083.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre836"/><st c="43898"/><st c="43909"> time complexity, provides stable and predictable sorting efficiency. </st><st c="43978">Quick sort is known for its average-case </st><img src="image/1084.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre837"/><st c="44019"/><st c="44030"> performance and combines simplicity </st><span><st c="44066">with efficiency.</st></span></p>
			<p class="calibre3"><st c="44082">It’s also worth mentioning that another significant recursive sorting algorithm, heap sort, will be introduced in </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="44197">Chapter 13</st></em></span></a><st c="44207"> when we discuss heap structures. </st><st c="44241">Heap sort, like merge sort and quick sort, utilizes the divide-and-conquer approach but does so through the use of a binary heap data structure, providing an efficient and space-conscious </st><span><st c="44429">sorting solution.</st></span></p>
			<h2 id="_idParaDest-87" class="calibre5"><a id="_idTextAnchor095" class="pcalibre pcalibre1 calibre6"/><st c="44446">Merge sort</st></h2>
			<p class="calibre3"><st c="44457">Merge sort </st><a id="_idIndexMarker350" class="pcalibre pcalibre1 calibre6"/><st c="44469">is a comparison-based sorting </st><a id="_idIndexMarker351" class="pcalibre pcalibre1 calibre6"/><st c="44499">algorithm that utilizes the divide-and-conquer strategy. </st><st c="44556">It operates by recursively splitting the unsorted array into two roughly equal partitions until each sub-array consists of a single element (which is naturally sorted). </st><st c="44725">The algorithm then merges these sub-arrays to</st><a id="_idIndexMarker352" class="pcalibre pcalibre1 calibre6"/><st c="44770"> create new sorted sub-arrays, continuing this process until only one sorted array remains, which represents the original array in sorted order. </st><st c="44915">At the merge step, the smallest elements of each sub-array are compared and then two sub-arrays </st><span><st c="45011">are combined.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="45024">Example 6.5</st></strong></span></p>
			<p class="calibre3"><em class="italic"><st c="45036">Table 6.6</st></em><st c="45046"> illustrates</st><a id="_idIndexMarker353" class="pcalibre pcalibre1 calibre6"/><st c="45058"> the step-by-step process of merge sort for the array [</st><strong class="source-inline"><st c="45113">38, 27, 43, 3, </st></strong><span><strong class="source-inline"><st c="45129">9, 82</st></strong></span><span><st c="45134">]:</st></span></p>
			<table id="table006" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="45137">Split/merge</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="45149">Content of </st></strong><span><strong class="bold"><st c="45161">the (sub)array</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="45175">First split</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="45187">Split [38, 27, 43, 3, 9, 82] into [38, 27, 43] and [3, </st><span><st c="45243">9, 82].</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="45250">Second split (</st><span><st c="45265">left half)</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="45276">Split [38, 27, 43] into [38] and [</st><span><st c="45311">27, 43].</st></span></p>
							<p class="calibre3"><st c="45320">Split [27, 43] into [27] </st><span><st c="45346">and [43].</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="45355">Merge</st></span></p>
							<p class="calibre3"><st c="45361">(</st><span><st c="45363">left half)</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="45373">Merge [27] and [43] to get [</st><span><st c="45402">27, 43].</st></span></p>
							<p class="calibre3"><st c="45411">Merge [38] and [27, 43] to get [27, </st><span><st c="45448">38, 43].</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="45456">Second split (</st><span><st c="45471">right half)</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="45483">Split [3, 9, 82] into [3] and [</st><span><st c="45515">9, 82].</st></span></p>
							<p class="calibre3"><st c="45523">Split [9, 82] into [9] </st><span><st c="45547">and [82].</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="45556">Merge</st></span></p>
							<p class="calibre3"><st c="45562">(</st><span><st c="45564">Right half)</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="45575">Merge [9] and [82] to get [</st><span><st c="45603">9, 82].</st></span></p>
							<p class="calibre3"><st c="45611">Merge [3] and [9, 82] to get [3, </st><span><st c="45645">9, 82].</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="45652">Final merge</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="45664">Merge [27, 38, 43] and [3, 9, 82] to get [3, 9, 27, 38, </st><span><st c="45721">43, 82].</st></span></p>
							<p class="calibre3"><st c="45729">Now the array is sorted: [3, 9, 27, 38, </st><span><st c="45770">43, 82].</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="45778">Table 6.6: Demonstrating an example of merge sort</st></p>
			<p class="calibre3"><st c="45828">Here is the Python implementation of the merge </st><span><st c="45876">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="45891" class="calibre11">
import numpy as np
def merge(A,p,q,r):
    n1=q-p+1
    n2=r-q
    n11=n1+1
    n22=n2+1
    left = [0 for i in range(n11)]
    right = [0 for i in range(n22)]
    for i in range(n1):
        left[i]=A[p+i-1]
    for j in range(n2):
        right[j]=A[q+j]
    left[n11-1]=1000  #very large number
    right[n22-1]=1000 #very large number
    i=0
    j=0
    for k in range(p-1,r):
        if left[i]&lt;=right[j]:
            A[k]=left[i]
            i=i+1
        else:
            A[k]=right[j]
            j=j+1
    return(A)
def mergeSort(A,p,r):
    if p&lt;r:
        q=int(np.floor((p+r)/2))
        mergeSort(A,p,q)
        mergeSort(A,q+1,r)
        merge(A,p,q,r)
    return(A)</st></pre>			<p class="calibre3"><st c="46397">While </st><a id="_idIndexMarker354" class="pcalibre pcalibre1 calibre6"/><st c="46404">there are numerous implementations</st><a id="_idIndexMarker355" class="pcalibre pcalibre1 calibre6"/><st c="46438"> of merge sort, the version we presented is quite straightforward. </st><st c="46505">The key component of the algorithm is a function called </st><strong class="source-inline"><st c="46561">merge </st></strong><st c="46567">used to merge the two partitions that have been </st><span><st c="46615">recursively sorted.</st></span></p>
			<h3 class="calibre8"><st c="46634">Proof of correctness</st></h3>
			<p class="calibre3"><st c="46655">The loop</st><a id="_idIndexMarker356" class="pcalibre pcalibre1 calibre6"/><st c="46664"> invariant definition in merge sort states that at the start of each iteration of the merging process, the </st><strong class="source-inline"><st c="46771">left_partition</st></strong><st c="46785"> and </st><strong class="source-inline"><st c="46790">right_partition</st></strong><st c="46805"> sub-arrays are sorted. </st><st c="46829">We need to evaluate three conditions for the </st><span><st c="46874">algorithm’s correctness:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="46898">Initialization</st></strong><st c="46913">: Before the first merge operation, the sub-arrays contain single elements, which are </st><span><st c="47000">inherently sorted.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="47018">Maintenance</st></strong><st c="47030">: Assume the invariant holds before merging two sub-arrays. </st><st c="47091">During the merge process, the smallest remaining element from either sub-array is selected and added to the merged array. </st><st c="47213">This maintains the sorted order of the merged array. </st><st c="47266">The invariant holds because each selection step ensures the merged array </st><span><st c="47339">remains sorted.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="47354">Termination</st></strong><st c="47366">: The algorithm terminates after all sub-arrays have been merged into a single sorted array. </st><st c="47460">At this point, the invariant guarantees that the entire array </st><span><st c="47522">is sorted.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="47532">Complexity analysis</st></h3>
			<p class="calibre3"><st c="47552">Merge sort is a recursive sorting algorithm that operates according to the recurrence function </st><img src="image/1085.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre838"/><st c="47648"/><st c="47666">. At each recursive step, merge sort divides the problem into two </st><a id="_idIndexMarker357" class="pcalibre pcalibre1 calibre6"/><st c="47732">nearly equal sub-problems, reflecting the general divide-and-conquer relation </st><img src="image/1086.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre839"/><st c="47810"/><st c="47829"> with </st><img src="image/1087.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre840"/><st c="47834"/><st c="47835"> and </st><img src="image/1088.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre841"/><st c="47840"/><st c="47841">. The division of the array and the merging of the sorted sub-arrays are both linear time operations, </st><span><st c="47943">hence </st></span><span><img src="image/1089.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre842"/><st c="47949"/></span><span><st c="47950">.</st></span></p>
			<p class="calibre3"><st c="47951">To evaluate the running time complexity of merge sort, we need to solve this recurrence function using methods such as the master theorem. </st><st c="48091">The master theorem provides a straightforward way to solve recurrences of the form </st><img src="image/1090.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre843"/><st c="48174"/><st c="48189"> by comparing </st><img src="image/1091.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre844"/><st c="48202"/> <span><st c="48206">to </st></span><span><img src="image/722.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre569"/><st c="48209"/></span><span><st c="48210">.</st></span></p>
			<p class="calibre3"><st c="48211">In the case of merge sort, </st><img src="image/870.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre637"/><st c="48239"/><st c="48240">, </st><img src="image/745.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre646"/><st c="48242"/><st c="48243">, </st><span><st c="48245">and </st></span><span><img src="image/1089.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre842"/><st c="48249"/></span><span><st c="48250">.</st></span></p>
			<p class="calibre3"><st c="48251">We calculate </st><img src="image/1096.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre845"/><st c="48265"/><st c="48281">. The following apply according to the </st><span><st c="48320">master theorem:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="48335">If </st><img src="image/1097.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre846"/><st c="48339"/><st c="48349"> where </st><img src="image/1098.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;mml:mo&gt;&lt;&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:math&gt;" class="calibre847"/><st c="48355"/><st c="48364">, </st><span><st c="48366">then </st></span><span><img src="image/1099.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre848"/><st c="48371"/></span></li>
				<li class="calibre13"><st c="48372">If </st><img src="image/1100.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre849"/><st c="48375"/><st c="48394">, </st><span><st c="48396">then </st></span><span><img src="image/1101.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre850"/><st c="48401"/></span></li>
				<li class="calibre13"><st c="48420">If </st><img src="image/1102.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Ω&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre851"/><st c="48423"/><st c="48432"> where </st><img src="image/1103.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;mml:mo&gt;&gt;&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:math&gt;" class="calibre852"/><st c="48438"/><st c="48447">, and if </st><img src="image/1104.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;≤&lt;/mml:mo&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre853"/><st c="48456"/><st c="48467"> for some </st><img src="image/946.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre737"/><st c="48476"/><st c="48477"> and sufficiently large </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre854"/><st c="48501"/><st c="48550">, </st><span><st c="48552">then </st></span><span><img src="image/1107.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre855"/><st c="48557"/></span></li>
			</ul>
			<p class="calibre3"><st c="48571">In our case, </st><img src="image/1108.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre856"/><st c="48584"/><st c="48585"> matches the second case of the master theorem because </st><img src="image/1109.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre857"/><st c="48640"/><st c="48645"> is </st><img src="image/1110.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre858"/><st c="48648"/><st c="48664">. Thus, case 2 applies, leading to the </st><span><st c="48703">following conclusion:</st></span></p>
			<p class="calibre3"><img src="image/1111.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre859"/><st c="48724"/><st c="48741">.</st></p>
			<p class="calibre3"><st c="48742">To assess the time complexity of merge sort, we can analyze it in the </st><span><st c="48813">following scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="48833">Best case</st></strong><st c="48843">: </st><img src="image/1112.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre860"/><st c="48846"/><st c="48856"> – Merge sort consistently divides the array and merges sub-arrays in </st><span><st c="48925">logarithmic steps</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="48942">Average case</st></strong><st c="48955">: </st><img src="image/1113.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre861"/><st c="48958"/><st c="48968"> – The algorithm performs consistently in all cases due to its </st><span><st c="49030">divide-and-conquer approach</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="49057">Worst case</st></strong><st c="49068">: </st><img src="image/1114.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre862"/><st c="49071"/><st c="49081"> – Merge sort is not adaptive, meaning its performance remains consistent regardless of the initial order of </st><span><st c="49189">the elements</st></span></li>
			</ul>
			<p class="calibre3"><st c="49201">To determine the space complexity, we need to consider the auxiliary or temporary space required to execute merge sort. </st><st c="49322">In the merge sort algorithm, two arrays, </st><strong class="source-inline"><st c="49363">left_partition</st></strong><st c="49377"> and </st><strong class="source-inline"><st c="49382">right_partition</st></strong><st c="49397">, are used as temporary storage during the merge operation. </st><st c="49457">The combined size of these two arrays is equal to the input size, resulting in a space complexity </st><span><st c="49555">of </st></span><span><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="49558"/></span><span><st c="49559">.</st></span></p>
			<p class="calibre3"><st c="49560">In summary, merge sort </st><a id="_idIndexMarker358" class="pcalibre pcalibre1 calibre6"/><st c="49584">is a highly efficient and stable sorting algorithm with a time complexity of</st><img src="image/1116.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre863"/><st c="49660"/><span><img src="image/1117.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre864"/><st c="49662"/></span><st c="49670"> in the best, average, and worst cases. </st><st c="49709">It employs a divide-and-conquer approach, dividing the array into smaller sub-arrays, sorting them recursively, and then merging them in sequence. </st><st c="49856">￼Although it necessitates</st><img src="image/1118.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre865"/><st c="49881"/><st c="49883"> additional space, its consistent performance and stability make it an excellent choice for sorting large datasets, especially when stability is essential. </st><st c="50039">The recursive nature and dependable performance of merge sort make it a foundational algorithm in </st><span><st c="50137">computer science.</st></span></p>
			<h2 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor096" class="pcalibre pcalibre1 calibre6"/><st c="50154">Quick sort</st></h2>
			<p class="calibre3"><st c="50165">Quick sort is</st><a id="_idIndexMarker359" class="pcalibre pcalibre1 calibre6"/><st c="50179"> a highly efficient divide-and-conquer</st><a id="_idIndexMarker360" class="pcalibre pcalibre1 calibre6"/><st c="50217"> sorting algorithm that, like merge sort, relies on comparisons. </st><st c="50282">It recursively selects a pivot element from the array and partitions the remaining elements into two sub-arrays based on whether they are smaller or larger than the pivot. </st><st c="50454">These sub-arrays are then sorted recursively. </st><st c="50500">This process repeats until the base case of an empty or single-element sub-array, which is inherently sorted, is reached. </st><st c="50622">The effectiveness of quick sort depends largely on the choice of pivot and the method used </st><span><st c="50713">for partitioning.</st></span></p>
			<p class="calibre3"><st c="50730">The quick sort algorithm is comprised of three </st><span><st c="50778">key components:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="50793">Pivot selection</st></strong><st c="50809">: This</st><a id="_idIndexMarker361" class="pcalibre pcalibre1 calibre6"/><st c="50816"> step involves choosing an element as the pivot from the array. </st><st c="50880">Common choices include the first, last, middle, or a randomly selected element. </st><st c="50960">The specific pivot selection strategy can influence the algorithm’s overall performance. </st><st c="51049">In the probabilistic quick sort, a pivot is randomly selected (see </st><a href="B22248_09.xhtml#_idTextAnchor129" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="51116">Chapter 9</st></em></span></a><span><st c="51125">).</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="51128">Partitioning</st></strong><st c="51141">: During</st><a id="_idIndexMarker362" class="pcalibre pcalibre1 calibre6"/><st c="51150"> this step, the array is divided into two smaller sub-arrays. </st><st c="51212">All elements smaller than the pivot are placed in one sub-array, while those greater than the pivot are placed in the other. </st><st c="51337">After this step, the pivot is in its final sorted position within </st><span><st c="51403">the array.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="51413">Recursion</st></strong><st c="51423">: The </st><a id="_idIndexMarker363" class="pcalibre pcalibre1 calibre6"/><st c="51430">partitioning step is repeated recursively until all sub-arrays are either empty or contain a single element, ultimately resulting in a fully </st><span><st c="51571">sorted array.</st></span></li>
			</ul>
			<p class="calibre3"><span><strong class="bold"><st c="51584">Example 6.6</st></strong></span></p>
			<p class="calibre3"><st c="51596">Let’s illustrate the</st><a id="_idIndexMarker364" class="pcalibre pcalibre1 calibre6"/><st c="51617"> operation with an array of six random numbers—[</st><strong class="source-inline"><st c="51665">35, 12, 99, 42, </st></strong><span><strong class="source-inline"><st c="51682">5, 8</st></strong></span><span><st c="51686">]:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="51689">Choose</st><a id="_idIndexMarker365" class="pcalibre pcalibre1 calibre6"/><st c="51696"> a pivot (e.g., </st><strong class="source-inline1"><st c="51712">8</st></strong><st c="51713">) and rearrange the array so that elements less than the pivot come before it and elements greater come </st><span><st c="51817">after it.</st></span></li>
				<li class="calibre13"><st c="51826">Recursively sort left </st><span><st c="51849">sub-array </st></span><span><strong class="source-inline1"><st c="51859">[5]</st></strong></span><span><st c="51862">:</st></span><p class="calibre3"><strong class="source-inline"><st c="51864">[5]</st></strong><st c="51867"> is </st><span><st c="51871">already sorted.</st></span></p></li>
				<li class="calibre13"><st c="51886">Recursively sort right sub-array </st><strong class="source-inline1"><st c="51920">[99, 42, </st></strong><span><strong class="source-inline1"><st c="51929">35, 12]</st></strong></span><span><st c="51936">:</st></span><p class="calibre3"><st c="51938">Choose a pivot (e.g., </st><strong class="source-inline"><st c="51960">35</st></strong><st c="51962">) and rearrange: </st><strong class="source-inline"><st c="51980">[5, 8, 12, 35, </st></strong><span><strong class="source-inline"><st c="51995">42, 99]</st></strong></span><span><st c="52002">.</st></span></p></li>
				<li class="calibre13"><st c="52003">Recursively sort sub-arrays </st><strong class="source-inline1"><st c="52032">[12]</st></strong><st c="52036"> and </st><strong class="source-inline1"><st c="52041">[</st></strong><span><strong class="source-inline1"><st c="52042">42, 99]</st></strong></span><span><st c="52049">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="source-inline1"><st c="52051">[12]</st></strong><st c="52055"> is </st><span><st c="52059">already sorted.</st></span></li><li class="calibre13"><st c="52074">Choose a pivot (e.g., </st><strong class="source-inline1"><st c="52097">42</st></strong><st c="52099">) and rearrange </st><strong class="source-inline1"><st c="52116">[42, 99]</st></strong><st c="52124">: </st><strong class="source-inline1"><st c="52127">[5, 8, 12, 35, </st></strong><span><strong class="source-inline1"><st c="52142">42, 99]</st></strong></span><span><st c="52149">.</st></span></li></ul></li>
				<li class="calibre13"><st c="52150">Now the array is sorted: </st><strong class="source-inline1"><st c="52176">[5, 8, 12, 35, </st></strong><span><strong class="source-inline1"><st c="52191">42, 99]</st></strong></span><span><st c="52198">.</st></span></li>
			</ol>
			<p class="calibre3"><st c="52199">Here is the Python implementation of the quick </st><span><st c="52247">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="52262" class="calibre11">
def quick_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x &lt; pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x &gt; pivot]
        return quick_sort(left) + middle + quick_sort(right)</st></pre>			<p class="calibre3"><st c="52513">As demonstrated, the</st><a id="_idIndexMarker366" class="pcalibre pcalibre1 calibre6"/><st c="52534"> core concept in the quick sort algorithm is selecting a pivot element for partitioning. </st><st c="52623">This process is then </st><span><st c="52644">repeated recursively.</st></span></p>
			<h3 class="calibre8"><st c="52665">Proof of correctness</st></h3>
			<p class="calibre3"><st c="52686">The loop invariant</st><a id="_idIndexMarker367" class="pcalibre pcalibre1 calibre6"/><st c="52705"> definition in merge sort guarantees that at the beginning of each iteration of the partitioning process, all elements in </st><strong class="source-inline"><st c="52827">left_partition</st></strong><st c="52841"> are not greater than the </st><strong class="source-inline"><st c="52867">pivot</st></strong><st c="52872">, and all elements in </st><strong class="source-inline"><st c="52894">right_partition</st></strong><st c="52909"> are not less than the </st><strong class="source-inline"><st c="52932">pivot</st></strong><st c="52937">. We need to evaluate three conditions for the </st><span><st c="52984">algorithm’s correctness:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="53008">Initialization</st></strong><st c="53023">: Before the first partitioning operation, the sub-array is the entire array, and the loop invariant trivially holds since no elements have been </st><span><st c="53169">processed yet.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="53183">Maintenance</st></strong><st c="53195">: During the partitioning process, elements are compared to the pivot and swapped as necessary. </st><st c="53292">This ensures that the two sub-arrays, </st><strong class="source-inline1"><st c="53330">left_partition</st></strong><st c="53344"> and </st><strong class="source-inline1"><st c="53349">right_partition</st></strong><st c="53364">, are maintained according to the definition; </st><strong class="source-inline1"><st c="53410">left_partition</st></strong><st c="53424"> contains elements smaller than the </st><strong class="source-inline1"><st c="53460">pivot</st></strong><st c="53465">, and </st><strong class="source-inline1"><st c="53471">right_partition</st></strong><st c="53486"> contains elements greater than </st><span><st c="53518">the </st></span><span><strong class="source-inline1"><st c="53522">pivot</st></strong></span><span><st c="53527">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="53528">Termination</st></strong><st c="53540">: The algorithm terminates when sub-arrays of length 0 or 1 are reached, which are inherently sorted. </st><st c="53643">The loop invariant guarantees that the elements are correctly partitioned at each step, ensuring the entire array is sorted </st><span><st c="53767">upon completion.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="53783">Complexity analysis</st></h3>
			<p class="calibre3"><st c="53803">Quick sort is</st><a id="_idIndexMarker368" class="pcalibre pcalibre1 calibre6"/><st c="53817"> characterized by the following </st><span><st c="53849">recurrence function:</st></span></p>
			<p class="calibre3"><img src="image/1119.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre866"/><st c="53869"/></p>
			<p class="calibre3"><st c="53900">Here, </st><img src="image/441.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre867"/><st c="53906"/><st c="53907"> is the number of elements smaller than the pivot. </st><st c="53958">To simplify the analysis, we assume an ideal scenario where the pivot always splits the list into two equal partitions, leading to the following </st><span><st c="54103">recurrence function:</st></span></p>
			<p class="calibre3"><img src="image/1121.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre868"/><st c="54123"/></p>
			<p class="calibre3"><st c="54141">This can</st><a id="_idIndexMarker369" class="pcalibre pcalibre1 calibre6"/><st c="54149"> be expressed in the general form of a </st><span><st c="54188">divide-and-conquer function:</st></span></p>
			<p class="calibre3"><img src="image/1090.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre843"/><st c="54216"/><st c="54232"> with </st><img src="image/870.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre637"/><st c="54237"/><st c="54238">, </st><img src="image/745.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre646"/><st c="54240"/><st c="54241">, </st><span><st c="54243">and </st></span><span><img src="image/1089.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre842"/><st c="54247"/></span></p>
			<p class="calibre3"><st c="54248">To determine the time complexity, we apply the master theorem. </st><st c="54311">The master theorem helps solve recurrences of the form </st><img src="image/1126.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre869"/><st c="54366"/><st c="54381"> by comparing </st><img src="image/1127.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre870"/><st c="54394"/><st c="54399"> to </st><img src="image/1128.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre871"/><st c="54402"/><st c="54409">. In the case of quick sort, </st><img src="image/870.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre637"/><st c="54438"/><st c="54439">, </st><img src="image/745.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre646"/><st c="54441"/><st c="54442">, </st><span><st c="54444">and </st></span><span><img src="image/1089.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre842"/><st c="54448"/></span><span><st c="54449">.</st></span></p>
			<p class="calibre3"><st c="54450">In our case, </st><img src="image/1132.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre872"/><st c="54464"/><st c="54465"> matches the second case of the master theorem because </st><img src="image/1133.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre873"/><st c="54520"/><st c="54525"> is </st><img src="image/1134.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre874"/><st c="54528"/><st c="54545">. Thus, case 2 applies, leading to the </st><span><st c="54584">following conclusion:</st></span></p>
			<p class="calibre3"><img src="image/1111.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre859"/><st c="54605"/></p>
			<p class="calibre3"><st c="54622">This indicates that the average-case time complexity of quick sort is </st><img src="image/1136.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre875"/><st c="54692"/><st c="54701">. Due to this efficiency, quick sort is highly effective for large datasets. </st><st c="54778">However, in the worst-case scenario, which occurs with poor pivot selection, resulting in consistently unbalanced partitions (e.g., always choosing the smallest or largest element as the pivot), the recurrence relation becomes </st><span><st c="55005">the following:</st></span></p>
			<p class="calibre3"><img src="image/1137.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre876"/><st c="55019"/></p>
			<p class="calibre3"><st c="55051">This simplifies to </st><span><st c="55070">the following:</st></span></p>
			<p class="calibre3"><img src="image/1138.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre877"/><st c="55084"/></p>
			<p class="calibre3"><st c="55086">Solving this recurrence relation yields </st><span><st c="55126">the following:</st></span></p>
			<p class="calibre3"><img src="image/1139.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre878"/><st c="55140"/></p>
			<p class="calibre3"><st c="55142">Therefore, the worst-case time complexity of quick sort is </st><img src="image/1140.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre831"/><st c="55201"/><st c="55207">. However, strategies such as random pivot selection or the median-of-three method can greatly reduce the chances of encountering this worst-case scenario, helping to preserve the algorithm’s average-case performance. </st><st c="55425">The following is a summary of quick sort’s </st><span><st c="55468">time complexity:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="55484">Best case</st></strong><st c="55494">:</st><img src="image/1141.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt; &lt;/mml:mi&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre879"/><st c="55496"/><st c="55505"> – This occurs when the pivot consistently splits the array into two nearly </st><span><st c="55580">equal halves</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="55592">Average case</st></strong><st c="55605">: </st><img src="image/1142.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre880"/><st c="55608"/><st c="55619"> – The algorithm performs well on average with random </st><span><st c="55672">pivot selection</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="55687">Worst case</st></strong><st c="55698">: </st><img src="image/1143.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre881"/><st c="55701"/><st c="55707"> – Occurs when the pivot selection consistently results in the most unbalanced partitions (e.g., the smallest or </st><span><st c="55819">largest element)</st></span></li>
			</ul>
			<p class="calibre3"><st c="55835">Quick sort is a</st><a id="_idIndexMarker370" class="pcalibre pcalibre1 calibre6"/><st c="55851"> recursive algorithm characterized by the recurrence relation </st><img src="image/1144.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre882"/><st c="55913"/><st c="55933">. In each recursion step, quick sort divides the problem into two nearly equal sub-problems, leading to the relation </st><img src="image/1145.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre839"/><st c="56050"/><st c="56069">, with </st><img src="image/1146.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre883"/><st c="56076"/><st c="56083">. The dividing and merging operations occur in linear time, represented by </st><img src="image/1147.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre884"/><st c="56158"/><st c="56159">. To understand the time complexity, we can analyze it in the </st><span><st c="56221">following scenarios.</st></span></p>
			<p class="calibre3"><st c="56241">For the space complexity, we need to consider the auxiliary or temporary space required to execute quick sort. </st><st c="56353">Quick sort requires additional space for the recursion stack. </st><st c="56415">In the average case, the stack depth is </st><img src="image/1148.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre885"/><st c="56455"/><st c="56464">. However, in the worst case (e.g., unbalanced partitions), the stack depth can </st><span><st c="56544">be </st></span><span><img src="image/1149.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre886"/><st c="56547"/></span><span><st c="56548">.</st></span></p>
			<p class="calibre3"><st c="56549">In summary, the performance of quick sort is significantly influenced by the choice of pivot and partitioning method. </st><st c="56668">Poor pivot selection can result in a worst-case time complexity of </st><img src="image/1150.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;²&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre887"/><st c="56735"/><st c="56736">, while the average-case performance is </st><img src="image/1151.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre888"/><st c="56776"/><st c="56785">. Techniques such as random pivot selection or the median-of-three method can help mitigate the risk of poor pivot selection. </st><st c="56911">Although quick sort is not a stable sorting algorithm, it is in-place and requires </st><img src="image/1152.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre889"/><st c="56994"/><st c="57003"> auxiliary space for the recursion stack in the average case. </st><st c="57064">Its efficiency and simplicity make quick sort a popular choice for sorting large datasets in </st><span><st c="57157">various applications.</st></span></p>
			<p class="calibre3"><st c="57178">All the sorting algorithms we’ve discussed so far, whether recursive or non-recursive, have been comparison-based. </st><st c="57294">Now, we turn to another significant topic in sorting algorithms – non-comparison-based methods, which can achieve sorting in </st><span><st c="57419">linear time.</st></span></p>
			<h1 id="_idParaDest-89" class="calibre5"><a id="_idTextAnchor097" class="pcalibre pcalibre1 calibre6"/><st c="57431">Non-comparison-based sorting</st></h1>
			<p class="calibre3"><st c="57460">We have noted </st><a id="_idIndexMarker371" class="pcalibre pcalibre1 calibre6"/><st c="57475">that all comparison-based sorting algorithms have a lower-bound time complexity of </st><img src="image/1153.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Ω&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre890"/><st c="57558"/><st c="57567">, which means no comparison-based algorithm can achieve better performance than </st><img src="image/1154.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:math&gt;" class="calibre891"/><st c="57647"/><st c="57653"> in the general case. </st><st c="57674">However, there are sorting algorithms that do not depend on comparisons. </st><st c="57747">These non-comparison-based algorithms leverage certain assumptions or information about the data to achieve </st><span><st c="57855">better performance.</st></span></p>
			<p class="calibre3"><st c="57874">Unlike</st><a id="_idIndexMarker372" class="pcalibre pcalibre1 calibre6"/><st c="57881"> comparison-based algorithms, non-comparison-based algorithms can achieve a lower bound as efficiently as linear time. </st><st c="58000">This remarkable efficiency is why they are sometimes referred to as linear-time sorting algorithms. </st><st c="58100">By making use of specific properties of the data, such as a limited range of integer values or the distribution of digits, these algorithms can bypass the comparison limit and sort much faster under the right conditions. </st><st c="58321">In this section, we will explore three well-known non-comparison-based sorting algorithms: counting sort, Radix sort, and </st><span><st c="58443">bucket sort.</st></span></p>
			<h2 id="_idParaDest-90" class="calibre5"><a id="_idTextAnchor098" class="pcalibre pcalibre1 calibre6"/><st c="58455">Counting sort</st></h2>
			<p class="calibre3"><st c="58469">Counting sort </st><a id="_idIndexMarker373" class="pcalibre pcalibre1 calibre6"/><st c="58484">is the</st><a id="_idIndexMarker374" class="pcalibre pcalibre1 calibre6"/><st c="58490"> first non-comparison-based sorting algorithm we will discuss in this section. </st><st c="58569">It sorts a collection of elements in an array by counting the frequency of each distinct element in the input array. </st><st c="58686">This frequency count is then used to determine the correct position of each element in the sorted output. </st><st c="58792">As a result, no comparison operations are involved in this sorting process. </st><st c="58868">Counting sort is particularly effective for sorting integers within a specific range and is known for its linear time complexity, making it highly efficient under the right conditions. </st><st c="59053">Unlike other sorting algorithms, counting sort does not perform comparisons between elements, thus bypassing the </st><img src="image/1155.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Ω&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre892"/><st c="59166"/><st c="59175"> lower bound for comparison-based sorts. </st><st c="59215">Let’s demonstrate the counting sort algorithm step by step with </st><span><st c="59279">an example.</st></span></p>
			<p class="calibre3"><st c="59290">Counting sort is an efficient algorithm with a time complexity of </st><img src="image/1156.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre893"/><st c="59357"/><st c="59363">. It is also a stable sorting method with minimal additional memory usage. </st><st c="59438">Although it requires extra space proportional to the range of input values, it maintains linear space complexity. </st><st c="59552">Due to its linear time complexity, counting sort is widely used for sorting large datasets with a limited range of elements. </st><st c="59677">Its simplicity and efficiency under the right conditions make it a valuable tool for </st><a id="_idIndexMarker375" class="pcalibre pcalibre1 calibre6"/><st c="59762">algorithm designers. </st><st c="59783">Let’s explain the counting sort algorithm in the </st><span><st c="59832">following example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="59850">Example 6.7</st></strong></span></p>
			<p class="calibre3"><st c="59862">Let’s illustrate the operation of counting sort with an array of six random numbers—[</st><strong class="source-inline"><st c="59948">4, 2, 2, 8, </st></strong><span><strong class="source-inline"><st c="59961">3, 3</st></strong></span><span><st c="59965">]:</st></span></p>
			<p class="calibre3"><st c="59968">Determine </st><span><st c="59979">the range:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="59989">Find the</st><a id="_idIndexMarker376" class="pcalibre pcalibre1 calibre6"/><st c="59998"> maximum element (</st><strong class="source-inline1"><st c="60016">8</st></strong><st c="60018">) and the minimum </st><span><st c="60036">element (</st></span><span><strong class="source-inline1"><st c="60045">2</st></strong></span><span><st c="60047">)</st></span></li>
				<li class="calibre13"><st c="60048">Create a count array with size </st><img src="image/1157.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre894"/><st c="60079"/><st c="60080">, initialized </st><span><st c="60094">to </st></span><span><strong class="source-inline1"><st c="60097">0</st></strong></span></li>
			</ul>
			<p class="calibre3"><span><st c="60098">Count occurrences:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="60116">Count each element’s occurrences and store them in the </st><span><st c="60172">count array</st></span></li>
				<li class="calibre13"><st c="60183">Count array: </st><strong class="source-inline1"><st c="60197">[2, 2, 1, 0, 0, </st></strong><span><strong class="source-inline1"><st c="60213">0, 1]</st></strong></span></li>
				<li class="calibre13"><st c="60218">This corresponds to elements </st><strong class="source-inline1"><st c="60248">2, 3, 4, 5, 6, </st></strong><span><strong class="source-inline1"><st c="60263">7, 8</st></strong></span></li>
			</ul>
			<p class="calibre3"><span><st c="60267">Cumulative count:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="60285">Modify the count array by adding the count of the previous element to each element. </st><st c="60370">This helps in determining the positions </st><span><st c="60410">of elements.</st></span></li>
				<li class="calibre13"><st c="60422">Cumulative count array: </st><strong class="source-inline1"><st c="60447">[2, 4, 5, 5, 5, </st></strong><span><strong class="source-inline1"><st c="60463">5, 6]</st></strong></span><span><st c="60468">.</st></span></li>
			</ul>
			<p class="calibre3"><st c="60469">Build the </st><span><st c="60480">output array:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="60493">Place each element in its correct position in the output array based on the cumulative count. </st><st c="60588">We start from the last element down to the </st><span><st c="60631">first element.</st></span></li>
			</ul>
			<p class="calibre3"><em class="italic"><st c="60645">Table 6.7</st></em><st c="60655"> illustrates the step-by-step process of counting sort for the array [</st><strong class="source-inline"><st c="60725">4, 2, 2, 8, </st></strong><span><strong class="source-inline"><st c="60738">3, 3</st></strong></span><span><st c="60742">]:</st></span></p>
			<table id="table007" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="60745">Element </st></strong><span><strong class="bold"><st c="60754">in array</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="60762">Cumulative </st></strong><span><strong class="bold"><st c="60774">count array</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="60785">Output array</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="60798">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60800">2, 3, 5, 5, 5, </st><span><st c="60815">5, 6</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60819">0, 0, 0, 3, </st><span><st c="60832">0, 0</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="60836">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60838">2, 2, 5, 5, 5, </st><span><st c="60853">5, 6</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60857">0, 0, 3, 3, </st><span><st c="60870">0, 0</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="60874">8</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60876">2, 2, 5, 5, 5, </st><span><st c="60891">5, 5</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60895">0, 0, 3, 3, </st><span><st c="60908">0, 8</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="60912">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60914">1, 2, 5, 5, 5, </st><span><st c="60929">5, 5</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60933">0, 2, 3, 3, </st><span><st c="60946">0, 8</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="60950">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60952">0, 2, 5, 5, 5, </st><span><st c="60967">5, 5</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60971">2, 2, 3, 3, </st><span><st c="60984">0, 8</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="60988">4</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="60990">0, 2, 4, 5, 5, </st><span><st c="61005">5, 5</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="61009">2, 2, 3, 3, </st><span><st c="61022">4, 8</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="61026">Table 6.7: Demonstrating an example of counting sort in operation</st></p>
			<p class="calibre3"><st c="61092">The following is</st><a id="_idIndexMarker377" class="pcalibre pcalibre1 calibre6"/><st c="61109"> a simple Python implementation of the counting </st><span><st c="61157">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="61172" class="calibre11">
def counting_sort(arr):
    if not arr:
        return arr
    max_val = max(arr)
    min_val = min(arr)
    range_of_elements = max_val - min_val + 1
    # Create a count array to store count of individual elements and initialize it to 0
    count = [0] * range_of_elements
    output = [0] * len(arr)
    # Store the count of each element
    for num in arr:
        count[num - min_val] += 1
    # Change count[i] so that count[i] contains the actual position of this element in the output array
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    # Build the output array
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1
    # Copy the output array to arr, so that arr contains sorted numbers
    for i in range(len(arr)):
        arr[i] = output[i]
    return arr</st></pre>			<p class="calibre3"><st c="61911">The </st><strong class="source-inline"><st c="61916">counting_sort</st></strong><st c="61929"> algorithm </st><a id="_idIndexMarker378" class="pcalibre pcalibre1 calibre6"/><st c="61940">is quite simple. </st><st c="61957">The first two loops (</st><strong class="source-inline"><st c="61978">for i in range(1, len(count)):</st></strong><st c="62009"> and </st><strong class="source-inline"><st c="62014">for i in range(1, len(count)):</st></strong><st c="62044">) build a cumulative count array. </st><st c="62079">This array is then used in the third loop (</st><strong class="source-inline"><st c="62122">for k in reversed(a):</st></strong><st c="62144">) to construct the </st><span><st c="62164">sorted array.</st></span></p>
			<h3 class="calibre8"><st c="62177">Proof of correctness</st></h3>
			<p class="calibre3"><st c="62198">The loop invariant in</st><a id="_idIndexMarker379" class="pcalibre pcalibre1 calibre6"/><st c="62220"> counting sort states that after processing each element, the cumulative </st><strong class="source-inline"><st c="62293">count</st></strong><st c="62298"> array correctly reflects the number of elements less than or equal to each value in the array, and the output array contains elements in sorted order up to the current index. </st><st c="62474">We need to evaluate three conditions for the </st><span><st c="62519">algorithm’s correctness:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="62543">Initialization</st></strong><st c="62558">: Before any elements are processed, the </st><strong class="source-inline1"><st c="62600">count</st></strong><st c="62605"> array is initialized to 0, and the output array is empty. </st><st c="62664">The invariant </st><span><st c="62678">trivially holds.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="62694">Maintenance</st></strong><st c="62706">: As each element is processed, the cumulative </st><strong class="source-inline1"><st c="62754">count</st></strong><st c="62759"> array is updated to reflect the correct count of elements. </st><st c="62819">During the construction of the output array, elements are placed in their correct positions based on the cumulative counts, ensuring that the sorted order </st><span><st c="62974">is maintained.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="62988">Termination</st></strong><st c="63000">: The algorithm terminates after all elements have been processed and placed in the output array. </st><st c="63099">At this point, the invariant guarantees that the output array is sorted, and the cumulative </st><strong class="source-inline1"><st c="63191">count</st></strong><st c="63196"> array accurately reflects the positions </st><span><st c="63237">of elements.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="63249">Complexity analysis</st></h3>
			<p class="calibre3"><st c="63269">Counting sort </st><a id="_idIndexMarker380" class="pcalibre pcalibre1 calibre6"/><st c="63284">has a linear time complexity that is influenced by both the size of the array (</st><img src="image/1158.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre736"/><st c="63363"/><st c="63365">) and the range of the input values </st><img src="image/1159.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre895"/><st c="63401"/><st c="63402"> (where </st><img src="image/1160.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;max&lt;/mml:mtext&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mtext&gt;min&lt;/mml:mtext&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre896"/><st c="63410"/><st c="63425">). </st><st c="63428">Let’s analyze the time complexity of counting sort in </st><span><st c="63482">three scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="63498">Best case</st></strong><st c="63508">: In the best-case scenario, counting sort iterates through the input array to compute the frequency of each element (</st><strong class="source-inline1"><st c="63627">count</st></strong><st c="63633">), then iterates through the </st><strong class="source-inline1"><st c="63663">count</st></strong><st c="63668"> array to calculate cumulative counts, and finally iterates through the input array again to place elements in their correct positions in the output array. </st><st c="63824">This process involves </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="63846"/><st c="63847"> time to count elements, </st><img src="image/1162.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre897"/><st c="63872"/><st c="63873"> time to compute cumulative counts, and </st><img src="image/1163.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre898"/><st c="63913"/><st c="63914"> time to build the output array, resulting in a total time complexity </st><span><st c="63984">of </st></span><span><img src="image/1051.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre813"/><st c="63987"/></span><span><st c="63993">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="63994">Average case</st></strong><st c="64007">: The average-case time complexity of counting sort remains </st><img src="image/1165.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre899"/><st c="64068"/><st c="64074"> because the steps involved (counting elements, computing cumulative counts, and building the output array) are consistent regardless of the initial order or distribution of elements within the range. </st><st c="64274">Each element in the input array is processed a constant number </st><span><st c="64337">of times.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="64346">Worst case</st></strong><st c="64357">: In the worst-case scenario, counting sort still performs with </st><img src="image/1166.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre900"/><st c="64422"/><st c="64428"> time complexity. </st><st c="64445">The worst case occurs when the range of input values is large compared to the size of the input array. </st><st c="64548">Despite this, the operations of counting, computing cumulative counts, and placing elements in the output array are performed in linear time relative to the number of elements and the range </st><span><st c="64738">of values.</st></span></li>
			</ul>
			<p class="calibre3"><st c="64748">Now, we need to estimate the space complexity of counting sort. </st><st c="64813">Counting sort requires additional space to store both the </st><strong class="source-inline"><st c="64871">count</st></strong><st c="64876"> array and the output array (</st><strong class="source-inline"><st c="64905">temp</st></strong><st c="64910">), leading to an auxiliary space complexity of </st><img src="image/1156.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre901"/><st c="64958"/><st c="64964">. Let’s look at the auxiliary space we need in counting sort. </st><st c="65026">First is the count array, which is used to store the frequency of each element within the range </st><img src="image/1168.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mfenced open=&quot;[&quot; close=&quot;]&quot;&gt;&lt;mrow&gt;&lt;mtext&gt;min&lt;/mtext&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mtext&gt;max&lt;/mtext&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre902"/><st c="65122"/><st c="65133">. The size of the </st><strong class="source-inline"><st c="65151">count</st></strong><st c="65156"> array is proportional to the range of input values, which is </st><img src="image/1169.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre903"/><st c="65218"/><st c="65219">. The second auxiliary memory space is the output array. </st><st c="65276">An output array (</st><strong class="source-inline"><st c="65293">temp</st></strong><st c="65298">) of the same size as the input array is used to store the sorted elements. </st><st c="65375">This requires </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="65389"/><st c="65390"> additional space. </st><st c="65409">Then, the total auxiliary space required by counting sort is the sum of the space for the count array and the output array, resulting </st><span><st c="65543">in </st></span><span><img src="image/1051.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre813"/><st c="65546"/></span><span><st c="65552">.</st></span></p>
			<p class="calibre3"><st c="65553">Counting sort is an efficient linear time sorting algorithm, but it has a major limitation: its efficiency is </st><a id="_idIndexMarker381" class="pcalibre pcalibre1 calibre6"/><st c="65664">highly dependent on the range of elements in the array to be sorted. </st><st c="65733">Additionally, counting sort is limited to integer numerical data. </st><st c="65799">In the next sub-section, we will discuss Radix sort, which can address some of the limitations inherent in </st><span><st c="65906">counting sort.</st></span></p>
			<h2 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor099" class="pcalibre pcalibre1 calibre6"/><st c="65920">Radix sort</st></h2>
			<p class="calibre3"><strong class="bold"><st c="65931">Radix sort</st></strong><st c="65942">, another </st><a id="_idIndexMarker382" class="pcalibre pcalibre1 calibre6"/><st c="65952">non-comparative</st><a id="_idIndexMarker383" class="pcalibre pcalibre1 calibre6"/><st c="65967"> sorting technique, sorts elements by sequentially processing individual digits or characters. </st><st c="66062">It leverages the concept that sorting can be achieved one position at a time, beginning with the least significant and progressing toward the most significant. </st><st c="66222">By employing a stable sorting algorithm such as counting sort for each position, Radix sort maintains the original order of elements, sharing the same digit or character. </st><st c="66393">This approach renders Radix sort highly efficient for datasets comprised of numbers or strings with a fixed or </st><span><st c="66504">limited length.</st></span></p>
			<p class="calibre3"><st c="66519">Radix sort is particularly effective for sorting large numbers of integers or strings with a fixed number of digits or characters. </st><st c="66651">The algorithm leverages counting sort to maintain stability and achieve linear time complexity for each digit. </st><st c="66762">While Radix sort requires additional space for the output and count arrays, its overall efficiency makes it an excellent choice for specific types of data where the number of digits or characters is known and limited. </st><st c="66980">Understanding Radix sort and its mechanisms can provide significant performance advantages</st><a id="_idIndexMarker384" class="pcalibre pcalibre1 calibre6"/><st c="67070"> in </st><span><st c="67074">appropriate scenarios.</st></span></p>
			<p class="calibre3"><st c="67096">Besides its linear time complexity and stability, the Radix sort algorithm offers several other advantages, including </st><span><st c="67215">the following:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="67229">Suitable for large data</st></strong><st c="67253">: Radix sort is especially effective for sorting large datasets where the range of input values is not significantly larger than the number of elements. </st><st c="67407">It handles large amounts of data well, particularly when the keys are integers or strings of a </st><span><st c="67502">fixed length.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="67515">Predictable performance</st></strong><st c="67539">: Radix sort consistently performs well, with no worst-case degradation, as seen in quick sort. </st><st c="67636">Its time complexity is predictable and does not depend on the input data’s </st><span><st c="67711">initial order.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="67725">Extensibility</st></strong><st c="67739">: Radix sort can be easily adapted to sort data types other than integers, such as strings </st><a id="_idIndexMarker385" class="pcalibre pcalibre1 calibre6"/><st c="67831">or other sequences, by using different bases or treating each character as </st><span><st c="67906">a “digit.”</st></span></li>
			</ul>
			<p class="calibre3"><st c="67916">Let’s demonstrate the Radix sort algorithm step by step with </st><span><st c="67978">an example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="67989">Example 6.8</st></strong></span></p>
			<p class="calibre3"><st c="68001">Let’s illustrate</st><a id="_idIndexMarker386" class="pcalibre pcalibre1 calibre6"/><st c="68018"> the operation of Radix sort with an array of six random numbers—[</st><strong class="source-inline"><st c="68084">170, 45, 75, 90, </st></strong><span><strong class="source-inline"><st c="68102">802, 24</st></strong></span><span><st c="68109">]:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="68112">Sort the original array by the least significant digit (</st><span><st c="68169">1’s place):</st></span><p class="calibre3"><st c="68181">Apply counting sort to the least significant digit: [</st><strong class="source-inline"><st c="68235">170, 90, 802, 24, </st></strong><span><strong class="source-inline"><st c="68254">45, 75</st></strong></span><span><st c="68260">]</st></span></p></li>
				<li class="calibre13"><st c="68262">Sort by second least significant digit (</st><span><st c="68302">10’s place):</st></span><p class="calibre3"><st c="68315">Apply counting sort to the second least significant digit: [</st><strong class="source-inline"><st c="68376">802, 24, 45, 75, </st></strong><span><strong class="source-inline"><st c="68394">170, 90</st></strong></span><span><st c="68401">]</st></span></p></li>
				<li class="calibre13"><st c="68403">Sort by most significant digit (</st><span><st c="68435">100’s place):</st></span><p class="calibre3"><st c="68449">Apply counting sort to the most significant digit: [</st><strong class="source-inline"><st c="68502">24, 45, 75, 90, </st></strong><span><strong class="source-inline"><st c="68519">170, 802</st></strong></span><span><st c="68527">]</st></span></p></li>
			</ol>
			<p class="calibre3"><st c="68529">Now the array is sorted: [</st><strong class="source-inline"><st c="68555">24, 45, 75, 90, </st></strong><span><strong class="source-inline"><st c="68572">170, 802</st></strong></span><span><st c="68580">].</st></span></p>
			<p class="calibre3"><st c="68583">Here is the Python implementation of the Radix </st><span><st c="68631">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="68646" class="calibre11">
def count_sort(a, e):
    size = len(a)
    result = [0] * size
    count = [0] * 10  # For digits 0-9
    for i in range(size):
        digit = (a[i] // e) % 10
        count[digit] += 1
    for i in range(1, 10):
        count[i] += count[i - 1]
    for i in range(size - 1, -1, -1):
        digit = (a[i] // e) % 10
        result[count[digit] - 1] = a[i]
        count[digit] -= 1
    for i in range(size):
        a[i] = result[i]
def radix_sort(a):
    maxv = max(a)
    e = 1
    while maxv // e &gt; 0:
        count_sort(a, e)
        e *= 10</st></pre>			<p class="calibre3"><st c="69082">In the</st><a id="_idIndexMarker387" class="pcalibre pcalibre1 calibre6"/><st c="69089"> preceding Radix sort algorithm implementation, the </st><strong class="source-inline"><st c="69141">radix_sort(a)</st></strong><st c="69154"> function takes the input array (</st><strong class="source-inline"><st c="69187">a</st></strong><st c="69189">) and applies counting sort (</st><strong class="source-inline"><st c="69218">count_sort(a, e)</st></strong><st c="69235">), starting from the least significant digit. </st><st c="69282">It sorts the data by each digit in the appropriate </st><span><st c="69333">place (</st></span><span><strong class="source-inline"><st c="69340">e</st></strong></span><span><st c="69342">).</st></span></p>
			<h3 class="calibre8"><st c="69344">Proof of correctness</st></h3>
			<p class="calibre3"><st c="69365">The</st><a id="_idIndexMarker388" class="pcalibre pcalibre1 calibre6"/><st c="69369"> loop invariant is defined in Radix sort as after sorting by each digit (starting from the least significant to the most significant), the array is partially sorted with respect to that digit, while maintaining the relative order of elements with the same digit. </st><st c="69632">We need to evaluate three conditions for the </st><span><st c="69677">algorithm’s correctness:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="69701">Initialization</st></strong><st c="69716">: Before any digits are processed, the array is unsorted. </st><st c="69775">The invariant trivially holds as there is no </st><span><st c="69820">partial sorting.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="69836">Maintenance</st></strong><st c="69848">: During each iteration, counting sort is applied to sort elements based on the current digit. </st><st c="69944">Since counting sort is stable, it maintains the relative order of elements with the same digit. </st><st c="70040">This ensures that after each pass, the array is partially sorted with respect to </st><span><st c="70121">that digit.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="70132">Termination</st></strong><st c="70144">: The algorithm terminates after sorting by the most significant digit. </st><st c="70217">At this point, the invariant guarantees that the array is fully sorted because all</st><a id="_idIndexMarker389" class="pcalibre pcalibre1 calibre6"/><st c="70299"> digits have been processed in order </st><span><st c="70336">of significance.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="70352">Complexity analysis</st></h3>
			<p class="calibre3"><st c="70372">Radix sort </st><a id="_idIndexMarker390" class="pcalibre pcalibre1 calibre6"/><st c="70384">has a time complexity that depends on the number of digits in the largest number, </st><img src="image/1172.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre904"/><st c="70466"/><st c="70467">, the number of elements, </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre35"/><st c="70493"/><st c="70494">, and the range of digit values, </st><img src="image/1174.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre905"/><st c="70527"/><st c="70528">. Let’s analyze the time complexity of Radix sort in </st><span><st c="70581">three scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="70597">Best case</st></strong><st c="70607">: In the best case, Radix sort processes each digit of the numbers in the array. </st><st c="70689">For each digit, it uses counting sort, which operates in </st><img src="image/1175.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre906"/><st c="70746"/><st c="70754"> time. </st><st c="70760">Since there are </st><img src="image/1172.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre907"/><st c="70776"/><st c="70777"> digits, the overall time complexity </st><span><st c="70814">is </st></span><span><img src="image/1177.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;⋅&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre908"/><st c="70817"/></span><span><st c="70827">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="70828">Average case</st></strong><st c="70841">: The average-case time complexity of Radix sort remains </st><img src="image/1177.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;⋅&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre908"/><st c="70899"/><st c="70909"> because the steps involved (sorting by each digit using counting sort) are consistently executed for each digit, regardless of the distribution of the </st><span><st c="71060">input values.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="71073">Worst case</st></strong><st c="71084">: In the worst case, Radix sort still performs with </st><img src="image/1179.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;⋅&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre909"/><st c="71137"/><st c="71147"> time complexity. </st><st c="71164">This is because each digit is processed in linear time by counting sort, and the process is repeated </st><img src="image/1172.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre904"/><st c="71265"/><st c="71266"> times for </st><img src="image/1172.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre904"/><st c="71277"/> <span><st c="71278">digits.</st></span></li>
			</ul>
			<p class="calibre3"><st c="71285">Speaking about the space complexity of Radix sort, it requires additional space to store the count array and the output array used by counting sort, resulting in an auxiliary space complexity </st><span><st c="71478">of </st></span><span><img src="image/1051.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre813"/><st c="71481"/></span><span><st c="71487">.</st></span></p>
			<p class="calibre3"><st c="71488">Radix sort is more efficient when the elements of the array are spread out over a wide range, meaning the values are sparse. </st><st c="71614">If the elements are densely packed within the range, an alternative approach is bucket sort, which will be discussed in the </st><span><st c="71738">next sub-section.</st></span></p>
			<h2 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor100" class="pcalibre pcalibre1 calibre6"/><st c="71755">Bucket sort</st></h2>
			<p class="calibre3"><st c="71767">The</st><a id="_idIndexMarker391" class="pcalibre pcalibre1 calibre6"/><st c="71771"> final non-comparison-based sorting</st><a id="_idIndexMarker392" class="pcalibre pcalibre1 calibre6"/><st c="71806"> algorithm we will examine is bucket sort. </st><st c="71849">This approach involves distributing the elements of an array into multiple containers, known as “buckets,” each associated with a specific range of values. </st><st c="72005">The elements within each bucket are then sorted independently, often using another sorting algorithm, and subsequently combined to produce the fully sorted array. </st><st c="72168">Bucket sort demonstrates exceptional efficiency when the input data is evenly spread across a known range. </st><st c="72275">It capitalizes on the divide-and-conquer strategy, simplifying the sorting task by breaking it down into smaller, more </st><span><st c="72394">manageable sub-problems.</st></span></p>
			<p class="calibre3"><st c="72418">Bucket sort</st><a id="_idIndexMarker393" class="pcalibre pcalibre1 calibre6"/><st c="72430"> is particularly effective for sorting large datasets with uniformly distributed values, providing significant performance advantages over comparison-based sorting algorithms in these scenarios. </st><st c="72625">Understanding Bucket sort and its mechanisms can help optimize sorting performance in suitable applications. </st><st c="72734">Let’s demonstrate the bucket sort algorithm step by step with </st><span><st c="72796">an example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="72807">Example 6.9</st></strong></span></p>
			<p class="calibre3"><st c="72819">Let’s</st><a id="_idIndexMarker394" class="pcalibre pcalibre1 calibre6"/><st c="72825"> illustrate the operation of bucket sort with an array of six random numbers— [</st><strong class="source-inline"><st c="72904">0.78, 0.17, 0.39, 0.26, </st></strong><span><strong class="source-inline"><st c="72929">0.72, 0.94</st></strong></span><span><st c="72939">]:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="72942">Distribute elements </st><span><st c="72963">into buckets:</st></span><p class="calibre3"><st c="72976">Create an empty list </st><span><st c="72998">of buckets.</st></span></p><p class="calibre3"><st c="73009">Distribute each element into the appropriate bucket based on </st><span><st c="73071">its value.</st></span></p><p class="calibre3"><st c="73081">Buckets: </st><strong class="source-inline"><st c="73091">[[0.17, 0.26], [0.39], [0.72, </st></strong><span><strong class="source-inline"><st c="73121">0.78], [0.94]]</st></strong></span><span><st c="73135">.</st></span></p></li>
				<li class="calibre13"><st c="73136">Sort </st><span><st c="73142">each bucket:</st></span><p class="calibre3"><st c="73154">Sort the elements within each bucket. </st><st c="73193">This can be done using another sorting algorithm such as </st><span><st c="73250">insertion sort.</st></span></p><p class="calibre3"><st c="73265">Sorted buckets: </st><strong class="source-inline"><st c="73282">[[0.17, 0.26], [0.39], [0.72, </st></strong><span><strong class="source-inline"><st c="73312">0.78], [0.94]]</st></strong></span><span><st c="73326">.</st></span></p></li>
				<li class="calibre13"><st c="73327">Concatenate </st><span><st c="73340">sorted buckets:</st></span><p class="calibre3"><st c="73355">Concatenate all the sorted buckets to form the final </st><span><st c="73409">sorted array:</st></span></p><p class="calibre3"><strong class="source-inline"><st c="73422">[0.17, 0.26, 0.39, 0.72, </st></strong><span><strong class="source-inline"><st c="73448">0.78, 0.94]</st></strong></span></p></li>
			</ol>
			<p class="calibre3"><st c="73459">The array is </st><span><st c="73473">now sorted.</st></span></p>
			<p class="calibre3"><st c="73484">The following</st><a id="_idIndexMarker395" class="pcalibre pcalibre1 calibre6"/><st c="73498"> is a simple Python implementation of the bucket </st><span><st c="73547">sort algorithm:</st></span></p>
			<pre class="source-code"><st c="73562" class="calibre11">
def bucket_sort(a):
    number_of_buckts = len(a)
    buckts = [[] for _ in range(number_of_buckts)]
    for i in a:
        idx = int(i * number_of_buckts)
        buckts[idx].append(i)
    sorted_a = []
    for b in buckts:
        sorted_a.extend(insertion_sort(b))
    return sorted_a</st></pre>			<p class="calibre3"><st c="73803">The algorithm is straightforward. </st><st c="73838">Initially, the buckets are set up, and the elements of the array, </st><strong class="source-inline"><st c="73904">a</st></strong><st c="73905">, are distributed into these buckets (</st><strong class="source-inline"><st c="73943">for I in a:</st></strong><st c="73955">). </st><st c="73959">Each bucket is then sorted using insertion sort and concatenated (</st><strong class="source-inline"><st c="74025">for b in buckts:</st></strong><st c="74042">). </st><st c="74046">Finally, the sorted buckets are </st><span><st c="74078">concatenated together.</st></span></p>
			<h3 class="calibre8"><st c="74100">Proof of correctness</st></h3>
			<p class="calibre3"><st c="74121">The</st><a id="_idIndexMarker396" class="pcalibre pcalibre1 calibre6"/><st c="74125"> loop invariant in bucket sort is defined as at the start of each iteration, the elements in each bucket are partially sorted with respect to their position within the bucket. </st><st c="74301">We need to evaluate three conditions for the </st><span><st c="74346">algorithm’s correctness:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="74370">Initialization</st></strong><st c="74385">: Before any elements are processed, the buckets are empty. </st><st c="74446">The invariant trivially holds as there is no </st><span><st c="74491">partial sorting.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="74507">Maintenance</st></strong><st c="74519">: During each iteration, elements are distributed into buckets based on their values. </st><st c="74606">Sorting each bucket individually ensures that the elements within each bucket are sorted. </st><st c="74696">This maintains </st><span><st c="74711">the invariant.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="74725">Termination</st></strong><st c="74737">: The algorithm terminates after all buckets have been sorted and concatenated. </st><st c="74818">At </st><a id="_idIndexMarker397" class="pcalibre pcalibre1 calibre6"/><st c="74821">this point, the invariant guarantees that the entire array is sorted because each bucket is sorted, and the buckets are concatenated </st><span><st c="74954">in order.</st></span></li>
			</ul>
			<h3 class="calibre8"><st c="74963">Complexity analysis</st></h3>
			<p class="calibre3"><st c="74983">Bucket sort</st><a id="_idIndexMarker398" class="pcalibre pcalibre1 calibre6"/><st c="74995"> has a time complexity that depends on both the number of elements, </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="75063"/><st c="75112">, and the number of buckets, </st><img src="image/1184.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre910"/><st c="75141"/><st c="75142">. The distribution of elements among the buckets also plays a crucial role in determining the overall time complexity. </st><st c="75261">Let’s examine the time complexity of Radix sort in the following </st><span><st c="75326">three scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="75342">Best case</st></strong><st c="75352">: In the best-case scenario, the elements are uniformly distributed across the buckets, and each bucket contains a roughly equal number of elements. </st><st c="75502">Sorting each bucket individually takes constant time if an efficient sorting algorithm such as insertion sort is used within the buckets. </st><st c="75640">As a result, the overall time complexity </st><span><st c="75681">is </st></span><span><img src="image/1051.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre813"/><st c="75684"/></span><span><st c="75690">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="75691">Average case</st></strong><st c="75704">: On average, the time complexity of bucket sort remains </st><img src="image/1186.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre911"/><st c="75762"/><st c="75771"> as long as the elements are evenly distributed, and the number of buckets, </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="75846"/><st c="75847">, is proportional to the number of elements, </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre912"/><st c="75892"/><st c="75893">. Each element is placed into a bucket in </st><img src="image/1189.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre913"/><st c="75935"/><st c="75936"> time, and each bucket is sorted individually in linear time relative to the number of elements </st><span><st c="76032">it contains.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="76044">Worst case</st></strong><st c="76055">: In the worst-case scenario, if all elements are placed into a single bucket, the algorithm’s time complexity degrades to </st><img src="image/1190.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre914"/><st c="76179"/><st c="76185">. This is because the entire array would need to be sorted within one bucket, resulting in quadratic time complexity when using a sorting algorithm such as insertion sort within </st><span><st c="76363">that bucket.</st></span></li>
			</ul>
			<p class="calibre3"><st c="76375">For the space complexity of bucket sort, we know that it requires additional space to store the buckets and the output array, leading to an auxiliary space complexity of </st><img src="image/1165.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre915"/><st c="76546"/><st c="76552">. The auxiliary space has two components: the first is the buckets. </st><st c="76620">The buckets are </st><a id="_idIndexMarker399" class="pcalibre pcalibre1 calibre6"/><st c="76636">used to store elements within specific value ranges. </st><st c="76689">The number of buckets, </st><img src="image/1174.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre675"/><st c="76712"/><st c="76713">, is typically chosen based on the range and distribution of input values. </st><st c="76788">The second auxiliary space is the output array. </st><st c="76836">An output array of the same size as the input array is used to store the sorted elements temporarily. </st><st c="76938">This requires </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="76952"/><st c="76953"> additional space. </st><st c="76972">Then, the total auxiliary space required by bucket sort is the sum of the space needed for the buckets and the output array, resulting </st><span><st c="77107">in </st></span><span><img src="image/1051.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre813"/><st c="77110"/></span><span><st c="77116">.</st></span></p>
			<p class="calibre3"><st c="77117">This concludes our discussion on non-comparison sorting algorithms. </st><st c="77186">These algorithms provide better time complexities compared to comparison-based sorts but come with certain limitations. </st><st c="77306">They are restricted to specific data types and rely on assumptions about the data, which can narrow their range </st><span><st c="77418">of applications.</st></span></p>
			<h1 id="_idParaDest-93" class="calibre5"><a id="_idTextAnchor101" class="pcalibre pcalibre1 calibre6"/><st c="77434">Summary</st></h1>
			<p class="calibre3"><st c="77442">This chapter provided a comprehensive exploration of various sorting algorithms, highlighting their underlying principles, efficiencies, and practical implementations. </st><st c="77611">The chapter began by discussing the fundamental properties that differentiate sorting algorithms, such as comparison versus non-comparison-based methods, stability, adaptability, and memory usage. </st><st c="77808">These properties were crucial for understanding why certain algorithms are more suitable for specific types of data and applications. </st><st c="77942">The chapter emphasized the importance of time complexity, particularly noting that comparison-based algorithms have a lower-bound complexity of </st><img src="image/1155.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Ω&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre916"/><st c="78086"/><st c="78095">, while non-comparison-based algorithms can achieve linear time complexity under the </st><span><st c="78180">right conditions.</st></span></p>
			<p class="calibre3"><st c="78197">The chapter then discussed specific sorting algorithms, starting with the iterative methods: bubble sort, selection sort, and insertion sort. </st><st c="78340">These algorithms, despite their simplicity and ease of implementation, were shown to be inefficient for large datasets due to their </st><img src="image/1068.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre917"/><st c="78472"/><st c="78478"> time complexity. </st><st c="78495">The explanations included detailed step-by-step operations, code implementations, and proofs of correctness using loop invariants. </st><st c="78626">Each algorithm’s unique characteristics, such as stability and space efficiency, were discussed, providing a clear understanding of their strengths </st><span><st c="78774">and limitations.</st></span></p>
			<p class="calibre3"><st c="78790">Finally, the chapter explored the more advanced recursive sorting algorithms, including merge sort and quick sort. </st><st c="78906">These algorithms leveraged the divide-and-conquer strategy to achieve more efficient sorting with an average time complexity of </st><img src="image/1197.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre786"/><st c="79034"/><st c="79045">. Merge sort’s consistent performance and stability were contrasted with quick sort’s potential for </st><img src="image/1198.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre918"/><st c="79145"/><st c="79151"> worst-case time complexity, which could be mitigated by good pivot selection strategies. </st><st c="79240">Additionally, the chapter touched on non-comparison-based algorithms such as counting sort, Radix sort, and bucket sort, explaining how they achieve linear time complexity by utilizing specific data properties. </st><st c="79451">The chapter concluded by reinforcing the importance of choosing the right sorting algorithm based on the dataset characteristics and the specific requirements of </st><span><st c="79613">the application.</st></span></p>
			<p class="calibre3"><st c="79629">In the next chapter, we focus on another core problem in algorithm design—searching. </st><st c="79715">Then, </st><a href="B22248_08.xhtml#_idTextAnchor118" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="79721">Chapter 8</st></em></span></a><st c="79730"> examines the relationship between sorting and searching, uncovering fascinating patterns </st><span><st c="79820">and connections.</st></span></p>
			<h1 id="_idParaDest-94" class="calibre5"><a id="_idTextAnchor102" class="pcalibre pcalibre1 calibre6"/><st c="79836">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><em class="italic"><st c="79867">Introduction to Algorithms</st></em><st c="79894">. By Thomas H. </st><st c="79909">Cormen, Charles E. </st><st c="79928">Leiserson, Ronald L. </st><st c="79949">Rivest, and Clifford Stein. </st><st c="79977">Fourth Edition. </st><st c="79993">MIT </st><span><st c="79997">Press. </st><st c="80004">2022.</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="80009">Chapter 2, </st></em><span><em class="italic"><st c="80021">Getting Started</st></em></span></li><li class="calibre13"><em class="italic"><st c="80036">Chapter 4, Divide-and-Conquer (includes </st></em><span><em class="italic"><st c="80077">merge sort)</st></em></span></li><li class="calibre13"><em class="italic"><st c="80088">Chapter </st></em><span><em class="italic"><st c="80097">7, Quicksort</st></em></span></li><li class="calibre13"><em class="italic"><st c="80109">Chapter 8,Sorting in </st></em><span><em class="italic"><st c="80131">Linear Time</st></em></span></li><li class="calibre13"><em class="italic"><st c="80142">Chapter 9, Medians and </st></em><span><em class="italic"><st c="80166">Order Statistics</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="80182">Algorithms</st></em><st c="80193">. By R. </st><st c="80201">Sedgewick and K. </st><st c="80218">Wayne. </st><st c="80225">Fourth Edition. </st><span><st c="80241">Addison-Wesley. </st><st c="80257">2011.</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="80262">Chapter 2: </st></em><span><em class="italic"><st c="80274">Elementary Sorts</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="80290">The Art of Computer Programming, Volume 3: Sorting and Searching</st></em><st c="80355">. By Donald </st><span><st c="80367">E. </st><st c="80370">Knuth.</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="80376">Chapter </st></em><span><em class="italic"><st c="80385">5, Sorting</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="80395">Data Structures and Algorithm Analysis in C++</st></em><st c="80441">. By Mark </st><span><st c="80451">Allen Weiss</st></span><span><em class="italic"><st c="80462">.</st></em></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="80463">Chapter </st></em><span><em class="italic"><st c="80472">7, Sorting</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="80482">Algorithm Design Manual</st></em><st c="80506">. By Steven </st><span><st c="80518">S. </st><st c="80521">Skiena.</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="80528">Chapter 4, Sorting </st></em><span><em class="italic"><st c="80548">and Searching</st></em></span></li></ul></li>
			</ul>
		</div>
	<div id="charCountTotal" value="80561" class="calibre2"/></body></html>