["```py\n def bubble_sort_iterative(a):\n    n = len(a)\n    for i in range(n):\n        elements_swapped = False\n        for j in range(0, n - i - 1):\n            if a[j] > a[j + 1]:\n                a[j], a[j + 1] = a[j + 1], a[j]\n                elements_swapped = True\n        if not elements_swapped:\n            break\n    return a\n```", "```py\n def selection_sort_iterative(a):\n    n = len(a)\n    for i in range(n):\n        min_id = i\n        for j in range(i + 1, n):\n            if a[j] < a[min_id]:\n                min_id = j\n        a[i], a[min_id] = a[min_id], a[i]\n    return a\n```", "```py\n def insertion_sort_iterative(a):\n    n = len(a)\n    for i in range(1, n):\n        pointer = a[i]\n        j = i - 1\n        while j >= 0 and pointer < a[j]:\n            a[j + 1] = a[j]\n            j -= 1\n        a[j + 1] = pointer\n    return a\n```", "```py\n import numpy as np\ndef merge(A,p,q,r):\n    n1=q-p+1\n    n2=r-q\n    n11=n1+1\n    n22=n2+1\n    left = [0 for i in range(n11)]\n    right = [0 for i in range(n22)]\n    for i in range(n1):\n        left[i]=A[p+i-1]\n    for j in range(n2):\n        right[j]=A[q+j]\n    left[n11-1]=1000  #very large number\n    right[n22-1]=1000 #very large number\n    i=0\n    j=0\n    for k in range(p-1,r):\n        if left[i]<=right[j]:\n            A[k]=left[i]\n            i=i+1\n        else:\n            A[k]=right[j]\n            j=j+1\n    return(A)\ndef mergeSort(A,p,r):\n    if p<r:\n        q=int(np.floor((p+r)/2))\n        mergeSort(A,p,q)\n        mergeSort(A,q+1,r)\n        merge(A,p,q,r)\n    return(A)\n```", "```py\n def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[len(arr) // 2]\n        left = [x for x in arr if x < pivot]\n        middle = [x for x in arr if x == pivot]\n        right = [x for x in arr if x > pivot]\n        return quick_sort(left) + middle + quick_sort(right)\n```", "```py\n def counting_sort(arr):\n    if not arr:\n        return arr\n    max_val = max(arr)\n    min_val = min(arr)\n    range_of_elements = max_val - min_val + 1\n    # Create a count array to store count of individual elements and initialize it to 0\n    count = [0] * range_of_elements\n    output = [0] * len(arr)\n    # Store the count of each element\n    for num in arr:\n        count[num - min_val] += 1\n    # Change count[i] so that count[i] contains the actual position of this element in the output array\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    # Build the output array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n    # Copy the output array to arr, so that arr contains sorted numbers\n    for i in range(len(arr)):\n        arr[i] = output[i]\n    return arr\n```", "```py\n def count_sort(a, e):\n    size = len(a)\n    result = [0] * size\n    count = [0] * 10  # For digits 0-9\n    for i in range(size):\n        digit = (a[i] // e) % 10\n        count[digit] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    for i in range(size - 1, -1, -1):\n        digit = (a[i] // e) % 10\n        result[count[digit] - 1] = a[i]\n        count[digit] -= 1\n    for i in range(size):\n        a[i] = result[i]\ndef radix_sort(a):\n    maxv = max(a)\n    e = 1\n    while maxv // e > 0:\n        count_sort(a, e)\n        e *= 10\n```", "```py\n def bucket_sort(a):\n    number_of_buckts = len(a)\n    buckts = [[] for _ in range(number_of_buckts)]\n    for i in a:\n        idx = int(i * number_of_buckts)\n        buckts[idx].append(i)\n    sorted_a = []\n    for b in buckts:\n        sorted_a.extend(insertion_sort(b))\n    return sorted_a\n```"]