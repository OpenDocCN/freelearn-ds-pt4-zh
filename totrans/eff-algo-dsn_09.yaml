- en: <st c="0">6</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Sorting Algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="20">A staggering 25% of global computing power is devoted to sorting
    data, underscoring its critical role in modern computational processes.</st> <st
    c="158">This significant allocation of resources highlights the essential nature
    of efficient sorting algorithms in diverse applications, ranging from information
    retrieval and database management to scientific simulations and machine learning.</st>
    <st c="395">This chapter systematically explores the most significant sorting
    algorithms, ranging from the basic bubble sort to the advanced quick sort, both
    in iterative and recursive approaches.</st> <st c="580">Each algorithm is assessed
    for correctness and complexity.</st> <st c="639">The chapter concludes with a
    discussion on sorting in linear time, providing context about</st> <st c="730">data
    assumptions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="747">Sorting algorithms are implemented using different approaches.</st>
    <st c="811">Each algorithm possesses unique characteristics described by properties
    such as stability, in-place sorting, or adaptability, which determine its suitability
    for different tasks.</st> <st c="990">This chapter explores these properties,
    elucidating the advantages and disadvantages of each sorting mechanism.</st> <st
    c="1102">By understanding these nuances, you will be equipped to choose the optimal
    sorting approach for your specific use cases</st> <st c="1222">and datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1235">Building upon this foundational overview, the chapter delves into
    the intricacies of both iterative and recursive sorting algorithms.</st> <st c="1370">It
    begins with the simpler, more intuitive iterative methods, such as selection and
    insertion sort, gradually progressing toward the more efficient recursive approaches,
    such as merge sort and quick sort.</st> <st c="1575">Additionally, it explores
    sorting algorithms capable of achieving linear time complexity under specific
    conditions, highlighting the significance of assumptions about the input data.</st>
    <st c="1758">This comprehensive exploration ensures that you develop a robust
    understanding of various sorting techniques, equipping you to efficiently tackle
    a wide array of</st> <st c="1920">computational challenges.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1945">This chapter covers the</st> <st c="1970">following topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1987">The taxonomy of</st> <st c="2004">sorting algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2022">Iterative</st> <st c="2033">sorting algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2051">Recursive</st> <st c="2062">sorting algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2080">Non-comparison-based</st> <st c="2102">sorting algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2120">The taxonomy of sorting algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="2155">To begin, let’s examine the key properties that distinguish different
    sorting algorithms, offering a thorough framework for understanding their distinct
    characteristics and practical applications.</st> <st c="2353">We will explore
    six critical properties: comparison, recursion, adaptability, inversion, memory
    usage, and stability.</st> <st c="2471">Comparison determines whether an algorithm
    relies on pairwise element comparisons to sort data, influencing its general applicability
    and time complexity bounds.</st> <st c="2633">Recursion involves breaking down
    the sorting process into smaller, more manageable sub-problems, often leading
    to elegant, divide-and-conquer solutions.</st> <st c="2786">Adaptability measures
    an algorithm’s ability to efficiently handle already partially sorted data, enhancing
    performance in real-world scenarios.</st> <st c="2931">Inversion counts the number
    of element pairs that are out of order, serving as a metric for the algorithm’s
    efficiency in different contexts.</st> <st c="3073">Memory usage examines the
    additional space required by an algorithm, distinguishing between in-place and
    non-in-place methods.</st> <st c="3200">Finally, stability ensures that equal
    elements retain their original relative order, which is crucial for multi-level
    sorting tasks.</st> <st c="3333">By understanding these properties, we can better
    appreciate the strengths and limitations of each sorting algorithm and make informed
    decisions about</st> <st c="3483">their application.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3501">Comparison</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3512">Comparison is a fundamental operation in both sorting and searching
    algorithms.</st> <st c="3593">In sorting, comparison determines the relative order
    of elements through pairwise evaluations.</st> <st c="3688">We can categorize
    sorting algorithms based on their use of comparisons to</st> <st c="3762">establish
    order.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3778">Sorting algorithms based on comparison, such as merge sort and
    quick sort, are versatile.</st> <st c="3869">We can apply them to any data type
    with a defined comparison function.</st> <st c="3940">These algorithms generally
    achieve</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/994.png)
    <st c="3975"><st c="3986">time complexity.</st> <st c="4003">On the other hand,
    some algorithms are not based on comparisons.</st> <st c="4068">Examples of linear
    time-sorting algorithms include counting sort and Radix sort.</st> <st c="4149">They
    employ alternative techniques for sorting, often achieving linear time complexity
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="4237"><st c="4239">) under</st> <st c="4247">specific conditions.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4267">Comparison-based sorting</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="4292">Comparison plays a central role in many sorting algorithms.</st>
    <st c="4353">In a comparison-based sorting algorithm, the primary operation used
    to determine the order of elements is the comparison between pairs of elements.</st>
    <st c="4501">The algorithm makes decisions about the positions of elements based
    on the outcomes of these comparisons, which typically involve relational operators
    such as</st> `<st c="4660"><</st>`<st c="4661">,</st> `<st c="4663">></st>`<st
    c="4664">,</st> <st c="4666">or</st> `<st c="4669">==</st>`<st c="4671">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4672">These algorithms are based on comparing elements to decide their
    order.</st> <st c="4745">Every comparison operation determines whether one element
    should be placed before or after another.</st> <st c="4845">Comparison-based sorting
    algorithms can be applied to any data type for which a comparison function is
    defined.</st> <st c="4957">This makes them versatile and</st> <st c="4987">widely
    applicable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5005">We can show that there is a lower bound of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/996.png)
    <st c="5049"><st c="5058">for the time complexity of comparison-based sorting
    algorithms.</st> <st c="5122">This is due to the decision tree model of comparisons.</st>
    <st c="5177">This means that, on average, at least</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/997.png)
    <st c="5215"><st c="5224">comparisons are required to sort</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="5257"><st c="5306">elements.</st> <st c="5316">Let’s explain why the time
    complexity of any comparison-based sort cannot be better</st> <st c="5400">than</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/997.png)<st
    c="5405"><st c="5414">.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5415">These algorithms are implemented based on comparing every pair
    of elements.</st> <st c="5492">We can represent the decisions made by these algorithms
    as a binary decision tree.</st> <st c="5575">The following are the elements of
    this</st> <st c="5614">decision tree:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5628">Each internal (non-terminal) node represents a comparison between
    two elements (</st><st c="5709">e.g., A<B?)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5721">Each branch represents the outcome of that comparison (yes</st>
    <st c="5781">or no)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5787">Each leaf (terminal) node represents a possible final sorted order
    of the</st> <st c="5862">input array</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5873">Let’s explain the decision tree representation of comparison-based
    sorting by</st> <st c="5952">an example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5963">Example 6.1</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="5975">Let’s consider an array with three random numbers: A=[3, 1, 4].</st>
    <st c="6040">To sort this array using comparisons, we might start with the decision
    tree illustrated in</st> *<st c="6131">Figure 6</st>**<st c="6139">.1</st>*<st
    c="6141">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Decision tree to implement comparison-based sorting of an array
    with three elements (white boxes are internal nodes; the left branch is “yes”
    and the right branch is “no”)](img/B22248_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="6271">Figure 6.1: Decision tree to implement comparison-based sorting
    of an array with three elements (white boxes are internal nodes; the left branch
    is “yes” and the right branch is “no”)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6454">The tree</st> <st c="6463">will continue branching out, representing
    all possible comparison outcomes and leading to leaf nodes that represent different
    sorted orders of the input array.</st> <st c="6624">Let’s estimate the lower-bound
    time complexity of sorting using this</st> <st c="6693">decision tree:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6707">For an array of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="6729"><st c="6778">, there are</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:math>](img/1001.png)
    <st c="6790"><st c="6793">possible permutations (different orderings).</st> <st
    c="6838">Each of these permutations could potentially be the correctly</st> <st
    c="6900">sorted order.</st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="6913">In the decision tree, each leaf node represents one of these possible
    permutations.</st> <st c="6998">Therefore, the tree must have at least</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:math>](img/1002.png)
    <st c="7037"><st c="7040">leaves to cover all possibilities.</st> <st c="7075">In
    our example, we will have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mo>!</mml:mo><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:math>](img/1003.png)
    <st c="7104"><st c="7105">possible permutations or</st> <st c="7131">leaf nodes.</st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7142">A binary tree with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>L</mml:mi></mml:math>](img/1004.png)
    <st c="7162"><st c="7163">leaves has a minimum height of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>L</mi></mrow></mrow></math>](img/1005.png)<st
    c="7195"><st c="7201">. Since our decision tree needs at least</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:math>](img/1002.png)
    <st c="7242"><st c="7245">leaves, its minimum height is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>!</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1007.png)<st
    c="7275"><st c="7283">. Using Stirling’s approximation, we know that</st> <st
    c="7330">l</st><st c="7331">o</st><st c="7332">g</st><st c="7333">(</st><st c="7334">n</st><st
    c="7335">!</st><st c="7336">)</st> <st c="7337">is approximately equal to</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/1008.png)
    <st c="7364"><st c="7372">(see</st> *<st c="7377">Example 3.8</st>* <st c="7388">from</st>
    [*<st c="7394">Chapter 3</st>*](B22248_03_split_000.xhtml#_idTextAnchor033)<st
    c="7403">).</st></st></st></st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7406">Therefore, there is a lower-bound time complexity of</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>Ω</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1009.png)<st
    c="7460"><st c="7471">for all sorting algorithms</st> <st c="7498">based on comparison.</st>
    <st c="7519">This means no algorithm can consistently sort an array faster</st>
    <st c="7581">than</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1010.png)<st
    c="7586"><st c="7597">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7598">The following are well-known comparison-based</st> <st c="7645">sorting
    algorithms:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7664">Bubble sort</st>**<st c="7676">: The</st> <st c="7683">adjacent
    elements in the array are repeatedly compared, and if they are in the wrong order,
    they are swapped.</st> <st c="7793">With each pass, larger elements are gradually
    moved to the end of</st> <st c="7859">the array.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7869">Insertion sort</st>**<st c="7884">: This</st> <st c="7892">algorithm
    progressively constructs a sorted array by iteratively comparing and inserting
    elements into their appropriate places within the already</st> <st c="8039">sorted
    portion.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8054">Quick sort</st>**<st c="8065">: In</st> <st c="8070">the quick
    sort algorithm, comparisons are used to partition the array around a pivot element,
    followed by recursive sorting of the</st> <st c="8202">resulting partitions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8223">Merge sort</st>**<st c="8234">: In</st> <st c="8240">this sorting
    algorithm, the array is split into two partitions of nearly the same size.</st>
    <st c="8328">Each partition is recursively sorted, and then the sorted partitions
    are merged</st> <st c="8408">using comparisons.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8426">Heap sort</st>**<st c="8436">: In this</st> <st c="8446">sorting
    algorithm, a max-heap (or min-heap) tree is built from the original array, and
    then the maximum (or minimum) element is repeatedly extracted.</st> <st c="8597">Throughout
    the process, comparisons are used to maintain the heap property (see</st> [*<st
    c="8677">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="8687">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8690">Non-comparison-based sorting</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="8719">Unlike</st> <st c="8727">comparison-based methods, in</st> <st
    c="8756">non-comparison-based algorithms, we do not directly compare elements
    to determine their order.</st> <st c="8851">Instead, we use alternative techniques
    such as counting frequencies, employing hash functions, or leveraging specific
    properties of the data.</st> <st c="8993">These methods make use of assumptions
    about the input data</st> <st c="9052">to achieve efficient sorting, often reaching
    linear time complexity,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)<st
    c="9121"><st c="9122">, under certain conditions.</st> <st c="9150">The main</st>
    <st c="9159">properties of non-comparison-based sorting algorithms include</st>
    <st c="9221">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="9235">Data-specific techniques</st>**<st c="9260">: These algorithms
    frequently utilize specific properties of the data, such as the range (particularly
    for numerical, integer data) or the number of digits, to carry out the</st> <st
    c="9435">sorting process</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9450">Linear time complexity</st>**<st c="9473">: Non-comparison-based
    sorting algorithms can achieve better than</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi
    mathvariant="normal"> </mi><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1012.png)
    <st c="9540"><st c="9541">time complexity, often</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1013.png)<st
    c="9565"><st c="9566">, by avoiding comparisons and using more direct methods
    of</st> <st c="9625">ordering elements</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9642">Memory usage</st>**<st c="9655">: Although these algorithms
    can achieve linear time complexity, they often require temporary memory that is
    typically proportional to the input size or the range of the</st> <st c="9825">data
    values</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9836">In this chapter, we</st> <st c="9856">introduce three well-known
    non-comparison-based sorting algorithms.</st> <st c="9925">The first is counting
    sort, which counts the occurrences of each distinct element to place them in their
    correct positions, making it effective for integers within a known range.</st>
    <st c="10104">Next is Radix sort, which processes each digit or character of the
    elements in a specific order (e.g., least significant digit first) and uses a
    stable sub-routine such as counting sort to sort the elements by each digit.</st>
    <st c="10326">Finally, bucket sort distributes the elements of the input list
    into several buckets or bins based on their values.</st> <st c="10442">Each bucket
    or bin is then sorted individually (often using a simple comparison-based sort),
    and all the sorted buckets are concatenated to build the final</st> <st c="10598">sorted
    list.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10610">Recursion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10620">Recursion</st> <st c="10630">plays a vital role in many sorting
    algorithms, enabling</st> <st c="10686">them to efficiently break down and conquer
    the sorting problem through the divide-and-conquer strategy.</st> <st c="10791">Recursive
    sorting algorithms offer clean and intuitive implementations but come with stack
    overhead and potential performance variability.</st> <st c="10930">On the other
    side, non-recursive sorting algorithms avoid the complexities of recursion and
    stack management, offering memory efficiency and simplicity, though they may not
    perform as well on</st> <st c="11122">large datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11137">Recursive sorting algorithms</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="11166">Recursion is</st> <st c="11180">often employed in sorting algorithms
    to break down complex problems into simpler sub-problems.</st> <st c="11275">In
    the context of sorting, recursion allows algorithms to divide the input array
    into smaller segments and sort these</st> <st c="11393">segments independently.</st>
    <st c="11417">The final sorted array is produced by merging the sorted segments.</st>
    <st c="11484">Recursive sorting algorithms leverage the divide-and-conquer strategy,
    which helps in achieving efficient sorting with manageable</st> <st c="11613">code
    complexity.</st> <st c="11631">Recursive sorting algorithms have the</st> <st
    c="11669">following properties:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11690">Divide-and-conquer strategy</st>**<st c="11718">: As the name
    suggests, this strategy consists of three steps: first, breaking the problem (array)
    into smaller sub-problems (sub-arrays).</st> <st c="11858">Second, recursively
    solving (sorting) each sub-problem (sub-array).</st> <st c="11926">Third, combining
    the solutions to address the</st> <st c="11972">original problem.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11989">Base case and recursive case</st>**<st c="12018">: Each recursive
    algorithm has a base case that terminates the recursion when the sub-problem is
    small enough (e.g., a single element or an empty array).</st> <st c="12173">The
    recursive case continues to break down the problem and solve</st> <st c="12238">the
    sub-problems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12255">Stack usage</st>**<st c="12267">: Recursive calls consume stack
    space, which can lead to high memory usage, especially for deep recursion.</st>
    <st c="12375">However, tail-recursive optimization and iterative approaches can
    mitigate this issue in</st> <st c="12464">some cases.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="12475">Table 6.1</st>* <st c="12485">provides</st> <st c="12494">some
    examples of recursive</st> <st c="12522">sorting algorithms:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="12541">Sorting</st>** **<st c="12550">algorithm</st>** | **<st c="12559">Process</st>**
    | **<st c="12567">Time and</st>** **<st c="12577">space complexity</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="12593">Merge sort</st> |'
  prefs: []
  type: TYPE_TB
- en: '**<st c="12604">Divide</st>**<st c="12611">: If the array has more than one
    element, split it into two roughly</st> <st c="12680">equal halves.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="12693">Conquer</st>**<st c="12701">: Recursively apply merge sort
    to each of the two halves.</st> <st c="12760">This continues until each sub-array
    has only one element (a trivially</st> <st c="12830">sorted array).</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="12844">Combine</st>**<st c="12852">: Merge the two sorted halves back
    into a single sorted array by comparing the elements from each half, taking the
    smaller one first, and placing it in the</st> <st c="13009">new array.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="13019">Repeat this process until all elements from both halves have</st>
    <st c="13081">been merged.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| <st c="13093">Time:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1014.png)
    <st c="13100"><st c="13111">in all cases (best, average,</st> <st c="13140">and
    worst).</st></st><st c="13151">Space:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)
    <st c="13159"><st c="13160">for temporary memory of</st> <st c="13185">merge component.</st></st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="13201">Quick sort</st> |'
  prefs: []
  type: TYPE_TB
- en: '**<st c="13212">Choose pivot</st>**<st c="13225">: From the array, select an
    element to serve as the pivot.</st> <st c="13285">Common choices are the first,
    the last, or a randomly</st> <st c="13339">chosen element.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="13354">Partition</st>**<st c="13364">: Divide the array into two sub-arrays.</st>
    <st c="13405">The elements of the first sub-array (left) are smaller than the
    pivot, and the elements of the second sub-array (right) are greater than the pivot.</st>
    <st c="13553">The pivot is now in its final</st> <st c="13583">sorted position.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="13599">Recursive sorting</st>**<st c="13617">: Apply quick sort recursively
    to the left sub-array.</st> <st c="13672">Apply quick sort recursively to the</st>
    <st c="13708">right sub-array.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="13724">Continue this process until each sub-array is either empty or
    contains only one element (a trivially</st> <st c="13826">sorted array).</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| <st c="13840">Time:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1014.png)
    <st c="13847"><st c="13858">on average, but</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="&#124;"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1017.png)
    <st c="13874"><st c="13881">in the</st> <st c="13888">worst case.</st></st></st><st
    c="13899">Space:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1018.png)
    <st c="13907"><st c="13916">for the recursion stack in the</st> <st c="13947">average
    case.</st></st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="13960">Heap sort</st> | **<st c="13970">Build max heap</st>**<st c="13985">:
    Starting from the last non-leaf node, apply recursive heapify to each node in
    reverse level order.</st> <st c="14087">This builds a max heap from the</st> <st
    c="14119">input array.</st>**<st c="14131">Extract and rebuild</st>**<st c="14151">:
    Repeat the following steps until the heap</st> <st c="14196">is empty:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14205">Swap the root (maximum element) with the last element of</st>
    <st c="14263">the heap.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="14272">Reduce the heap size</st> <st c="14294">by 1.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="14299">Apply recursive heapify to the root to restore the</st> <st c="14351">max-heap
    property.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="14369">(Heap sort will be discussed in detail in</st> [*<st c="14412">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="14422">).</st> | <st c="14425">Time:</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1019.png)
    <st c="14432"><st c="14443">in</st> <st c="14446">all cases.</st></st><st c="14456">Space:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1020.png)
    <st c="14464"><st c="14465">for the iterative version; the recursive heapify process
    uses</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi
    mathvariant="normal"> </mi><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1021.png)
    <st c="14528"><st c="14529">stack space.</st></st></st> |
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="14541">Table 6.1: Examples of recursive sorting algorithms</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14593">Non-recursive sorting algorithms</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="14626">Non-recursive sorting algorithms</st> <st c="14660">do not use
    recursion to achieve sorting.</st> <st c="14701">Instead, they rely on iterative
    techniques, using</st> <st c="14750">loops to manage the process of sorting.</st>
    <st c="14791">These algorithms often have simpler space complexity because they
    avoid the stack overhead that is a problem with recursive strategies.</st> <st
    c="14927">Non-recursive sorting algorithms use an iterative approach (implemented
    by loops) and they are generally memory efficient.</st> <st c="15050">Technically
    speaking, non-recursive sorting algorithms have the</st> <st c="15114">following</st>
    <st c="15123">characteristics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15140">Iterative approach</st>**<st c="15159">: Non-recursive sorting
    algorithms use loops (e.g.,</st> **<st c="15212">for</st>** <st c="15215">loops
    or</st> **<st c="15225">while</st>** <st c="15230">loops) to sort the array, eliminating
    the need for</st> <st c="15282">recursive calls</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15297">Memory efficiency</st>**<st c="15315">: These algorithms are
    often more memory-efficient because they avoid the additional stack space required
    for</st> <st c="15426">recursive calls</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15441">Simpler stack management</st>**<st c="15466">: By using an
    iterative approach, non-recursive algorithms avoid the complexities of managing
    recursive stack depth, which can lead to stack overflow when dealing with</st>
    <st c="15635">large datasets</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="15649">Table 6.2</st>* <st c="15659">provides a list of</st> <st c="15679">well-known
    non-recursive</st> <st c="15704">sorting algorithms:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="15723">Sorting</st>** **<st c="15732">algorithm</st>** | **<st c="15741">Process</st>**
    | **<st c="15749">Time and</st>** **<st c="15759">space complexity</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="15775">Insertion</st>** **<st c="15786">sort</st>** | <st c="15790">Start
    with the second element.</st> <st c="15822">Assume the first element is</st> <st
    c="15850">already sorted.</st><st c="15865">Iterate through the</st> <st c="15886">unsorted
    portion:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15903">Compare it with the elements in the sorted portion (to</st> <st
    c="15959">its left).</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15969">Shift the elements in the sorted portion to the right until the
    element is in the</st> <st c="16052">correct position.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16069">Insert the current element into</st> <st c="16102">that position.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16116">Continue until the entire array is sorted.</st> <st c="16160">Repeat
    step 2 for each element in the</st> <st c="16198">unsorted portion.</st> | <st
    c="16215">Time:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="&#124;"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1022.png)
    <st c="16222"><st c="16228">for both the average and worst cases,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1023.png)
    <st c="16266"><st c="16267">in the</st> <st c="16275">best case.</st></st></st><st
    c="16285">Space:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1020.png)
    <st c="16293"><st c="16294">since it is</st> <st c="16307">in-place sort.</st></st>
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="16321">Selection</st>** **<st c="16332">sort</st>** | <st c="16336">Find
    the</st> <st c="16345">smallest element (initially the</st> <st c="16378">entire
    array).</st>**<st c="16392">Swap</st>**<st c="16397">: Swap the smallest element
    with the leftmost element of the unsorted portion.</st> <st c="16477">The leftmost
    element is now in its final</st> <st c="16518">sorted position.</st>**<st c="16534">Repeat</st>**<st
    c="16541">: Consider the remaining unsorted portion (excluding the elements already
    sorted).</st> <st c="16625">Repeat steps 1 and 2 until the entire array</st> <st
    c="16669">is sorted.</st> | <st c="16679">Time:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="&#124;"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1022.png)
    <st c="16686"><st c="16692">in</st> <st c="16695">all cases.</st></st><st c="16705">Space:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1020.png)
    <st c="16713"><st c="16714">since it is</st> <st c="16727">in-place sort.</st></st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="16741">Bubble sort</st>** | **<st c="16753">Compare</st>** **<st
    c="16762">and swap:</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16771">Compare every two elements.</st> <st c="16800">If they are in
    the wrong order,</st> <st c="16832">swap them.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16842">Continue this process until the last element of the array</st>
    <st c="16901">is visited.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16912">Repeat:</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16920">After one pass through the array, the largest element will have
    “bubbled up” to</st> <st c="17001">the end.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17009">Repeat step 1, but this time, stop one position before the end
    of the array (since the last element is already in its</st> <st c="17128">correct
    place).</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17143">Continue repeating step 1, reducing the comparison range by one
    element each time, until the entire array</st> <st c="17250">is sorted.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| <st c="17260">Time:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="&#124;"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1022.png)
    <st c="17267"><st c="17273">for both the average and worst cases,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1023.png)
    <st c="17311"><st c="17312">in the</st> <st c="17320">best case.</st></st></st><st
    c="17330">Space:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1020.png)
    <st c="17338"><st c="17339">since it is</st> <st c="17352">in-place sort.</st></st>
    |'
  prefs: []
  type: TYPE_TB
- en: '<st c="17366">Table 6.2: Examples of non-recursive sorting algorithms</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17422">Recursion is a key factor</st> <st c="17449">that differentiates
    sorting algorithms.</st> <st c="17489">In the following sub-section, we will explore
    other aspects, such</st> <st c="17555">as adaptability.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17571">Adaptability</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17584">In sorting, adaptability means an algorithm’s capacity to</st>
    <st c="17643">leverage pre-existing order within the data to enhance its efficiency.</st>
    <st c="17714">An adaptive sorting algorithm excels when the input is partially
    sorted or exhibits some underlying structure, requiring fewer operations to achieve
    complete sorting.</st> <st c="17881">In essence, the more ordered the input, the
    faster the algorithm can complete</st> <st c="17959">its task.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17968">An</st> <st c="17971">adaptive sorting algorithm</st> <st c="17998">will
    have a faster average-case running time when the data is partially ordered compared
    to when the input is completely random.</st> <st c="18128">In addition, these
    sorting algorithms make fewer comparisons and swaps when the data is closer to
    the sorted order, resulting in reduced computational effort.</st> <st c="18287">Adaptive
    sorting algorithms are more efficient in real-world applications because many
    real-world datasets are not completely random and often have some existing order
    (e.g., time-series data or lists that are periodically updated).</st> <st c="18520">Adaptive
    sorting algorithms can handle such datasets</st> <st c="18573">more efficiently.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18590">Let’s consider</st> <st c="18605">two adaptive sorting algorithms.</st>
    <st c="18639">First is insertion sort, which is highly adaptive.</st> <st c="18690">In
    the best-case scenario, when the input data is already ordered, its running time
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="18777"><st c="18778">, as it only needs to make</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1031.png)
    <st c="18805"><st c="18806">comparisons.</st> <st c="18820">For small or nearly
    sorted data, insertion sort is efficient since it performs few swaps and comparisons.</st>
    <st c="18926">The next adaptive sorting algorithm is bubble sort, which is adaptive
    to some extent.</st> <st c="19012">If the input data is already ordered, bubble
    sort can complete the sorting in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="19090"><st c="19091">time, though this requires an optimization to stop
    early when no swaps are made in</st> <st c="19175">a pass.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="19182">On the other hand, let’s</st> <st c="19208">examine two non-adaptive
    sorting algorithms: quick sort and heap sort.</st> <st c="19279">The complexity
    of quick sort is heavily influenced by the choice of pivot and the initial arrangement
    of elements.</st> <st c="19394">However, it doesn’t inherently improve with partially
    sorted data.</st> <st c="19461">Heap sort is another non-adaptive algorithm.</st>
    <st c="19506">As we will see in</st> [*<st c="19524">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="19534">, pre-sorted data doesn’t offer any advantage in</st> <st c="19583">this
    process.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19596">Inversion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="19606">An</st> <st c="19610">inversion</st> <st c="19619">in a sequence
    is a condition where a pair of elements is out of order.</st> <st c="19691">Formally,
    given an array</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)<st
    c="19716"><st c="19717">, an inversion is defined as a pair of indices</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>,</mo><mi>i</mi></mrow></mrow></math>](img/1034.png)
    <st c="19763"><st c="19765">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="19770"><st c="19771">, such that</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>i</mi><mo><</mo><mi>j</mi></mrow></mrow></math>](img/1036.png)
    <st c="19783"><st c="19788">and</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>></mo><mi>A</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mrow></mrow></math>](img/1037.png)<st
    c="19791"><st c="19806">. In simpler terms, an inversion occurs when a larger
    element precedes a smaller one in the array.</st> <st c="19905">Inversions are
    significant in sorting because they measure the degree of disorder within an array.</st>
    <st c="20004">The total number of inversions provides insight into how far an
    array is from being sorted.</st> <st c="20096">We can</st> <st c="20103">consider</st>
    <st c="20112">two scenarios:</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="20126">Zero inversions</st>**<st c="20142">: For all</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>i</mi><mo><</mo><mi>j</mi></mrow></mrow></math>](img/1036.png)<st
    c="20153"><st c="20158">, we have</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1039.png)<st
    c="20168"><st c="20180">; in other words, the array</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="20208"><st c="20209">is</st> <st c="20213">fully sorted</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20225">Maximum inversions</st>**<st c="20244">: For all</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>i</mi><mo><</mo><mi>j</mi></mrow></mrow></math>](img/1041.png)<st
    c="20255"><st c="20260">, we have</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>></mo><mi>A</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mrow></mrow></math>](img/1042.png)<st
    c="20270"><st c="20281">; in other words, the array</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi></mrow></math>](img/1043.png)<st
    c="20309"><st c="20310">is sorted in</st> <st c="20323">reverse order</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20336">The concept of inversions</st> <st c="20362">is essential to understanding
    sorting algorithms and their analysis.</st> <st c="20432">Inversions refer to
    pairs of elements in an array that are out of order.</st> <st c="20505">For instance,
    in bubble sort, the algorithm repeatedly swaps adjacent elements that are not
    in their correct order.</st> <st c="20621">The total number of swaps performed
    during bubble sort directly corresponds to the number of inversions present in</st>
    <st c="20736">the array.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20746">In merge sort, inversions</st> <st c="20773">can be counted during
    the mergin</st><st c="20805">g process.</st> <st c="20817">Specifically, when
    an element from the right half of the array is inserted before an element from
    the left half, this indicates a number of inversions equal to the remaining elements
    in the left half.</st> <st c="21018">This insight helps us quantify the disorder
    present within the array as it</st> <st c="21093">undergoes sorting.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21111">Inversions also impact the complexity of sorting algorithms.</st>
    <st c="21173">The number of inversions in an array can be used to analyze the
    efficiency of these algorithms.</st> <st c="21269">For instance, algorithms with</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1044.png)
    <st c="21299"><st c="21310">complexity, such as merge sort and quick sort, can
    handle a large number of inversions efficiently.</st> <st c="21410">In contrast,
    algorithms with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1045.png)
    <st c="21439"><st c="21445">complexity, such as bubble sort and insertion sort,
    may become increasingly inefficient as the number of</st> <st c="21550">inversions
    rises.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21567">Memory usage</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21580">Memory usage</st> <st c="21593">in sorting is measured by the
    amount of extra storage needed by the algorithm to process and arrange the input
    data.</st> <st c="21711">This is closely tied to whether a sorting algorithm is
    classified as in place</st> <st c="21789">or not.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21796">In-place sorting</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="21813">In-place sorting algorithms</st> <st c="21842">operate directly</st>
    <st c="21859">within the input array.</st> <st c="21883">They require only a fixed
    amount of additional storage.</st> <st c="21939">These algorithms rearrange the
    elements within the given array using a fixed amount of additional space, typically</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)
    <st c="22054"><st c="22055">extra space.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22067">In-place sorting algorithms are memory efficient, requiring minimal
    extra space.</st> <st c="22149">This is particularly important in environments
    with limited memory resources or when dealing with large datasets.</st> <st c="22263">These
    algorithms often achieve sorting by swapping elements within the input array.</st>
    <st c="22347">Common techniques include partitioning and incrementally placing
    elements in their correct positions.</st> <st c="22449">Insertion sort, quick
    sort, and heap sort are examples of in-place algorithms.</st> <st c="22528">Quick
    sort, with its in-place partitioning scheme, typically sorts the array without
    requiring additional storage proportional to the input size.</st> <st c="22674">However,
    it uses</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1047.png)
    <st c="22691"><st c="22700">extra space for the recursive stack.</st> <st c="22737">Insertion
    sort inserts elements into their correct positions within the array, requiring
    no extra space beyond a few variables for looping and swapping.</st> <st c="22890">Finally,
    heap sort transforms the array into a heap structure and then sorts it in place.</st>
    <st c="22980">This is achieved by repeatedly removing the maximum element (or
    minimum, depending on the desired order) and then restoring the heap property
    to maintain</st> <st c="23134">the structure.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23148">Non-in-place sorting</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="23169">Sorting algorithms</st> <st c="23188">that operate outside the
    input data and require additional memory space, either linearly or non-linearly</st>
    <st c="23294">proportional to the input size, are referred to as non-in-place
    sorting algorithms.</st> <st c="23378">These algorithms use extra space to store
    copies of the data or intermediate results during the sorting process.</st> <st
    c="23491">Non-in-place sorting algorithms consume more memory because they need
    additional storage to hold temporary copies of the data or intermediate structures.</st>
    <st c="23645">On the other hand, these algorithms can be simpler to implement
    and understand, and they often preserve the stability of the sort more easily
    than</st> <st c="23792">in-place algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23812">Examples of non-in-place sorting are merge sort, counting sort,
    and Radix sort.</st> <st c="23893">Merge</st> <st c="23899">sort uses</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1048.png)
    <st c="23908"><st c="23910">extra memory to hold the two partitions of the input
    being merged.</st> <st c="23978">Each recursive step requires additional space
    to store intermediate results, leading to higher overall memory usage.</st> <st
    c="24095">Counting sort uses additional memory proportional to the range of the
    input values, typically</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1049.png)<st
    c="24189"><st c="24195">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="24203"><st c="24204">is the range of the input data.</st> <st c="24237">Radix
    sort, like counting sort, requires extra space to hold temporary data for each
    digit or character being processed, resulting in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1051.png)
    <st c="24371"><st c="24377">memory usage.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24390">When choosing between in-place and non-in-place sorting algorithms,
    there are several trade-offs</st> <st c="24488">to consider:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24500">In environments with memory constraints, in-place sorting algorithms
    are preferred due to their minimal</st> <st c="24605">memory footprint.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="24622">Non-in-place algorithms may be simpler to implement and understand,
    particularly for complex</st> <st c="24716">sorting tasks.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="24730">In some cases, non-in-place algorithms can offer better performance
    due to their ability to efficiently handle large or complex datasets, despite
    their higher</st> <st c="24890">memory usage.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="24903">Non-in-place algorithms often preserve the relative order of equal
    elements more easily, making them stable.</st> <st c="25013">Ensuring stability
    in in-place algorithms can be</st> <st c="25062">more challenging.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25079">Memory usage</st> <st c="25092">is a crucial consideration</st>
    <st c="25120">when choosing a sorting algorithm.</st> <st c="25155">In-place sorting
    methods are efficient in terms of memory consumption, as they manipulate the input
    array directly with minimal extra space.</st> <st c="25296">However, non-in-place
    methods, such as merge sort and counting sort, require extra memory proportional
    to the input size, although they can provide advantages in terms of simplicity
    and stability.</st> <st c="25493">The choice between in-place and non-in-place
    sorting depends on the specific problem.</st> <st c="25579">For instance, if memory
    is limited, in-place sorting should</st> <st c="25639">be considered.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25653">Stability</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="25663">Stability in</st> <st c="25677">sorting refers to maintaining
    the original relative order of elements with identical values.</st> <st c="25770">A
    sorting algorithm is considered stable if it ensures</st> <st c="25825">that elements
    with the same value keep their initial order relative to one another after sorting.</st>
    <st c="25923">Stable algorithms include insertion sort, merge sort, and bubble
    sort.</st> <st c="25994">In contrast, quick sort, heap sort, and selection sort
    are examples of</st> <st c="26065">unstable algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26085">The distinction between stable and unstable sorting algorithms
    lies in their ability to maintain the original order of equal elements.</st> <st
    c="26221">Stable algorithms guarantee this preservation, ensuring that the relative
    positions of equal elements remain unchanged during sorting.</st> <st c="26356">In
    contrast, unstable algorithms may alter the relative positions of</st> <st c="26425">equal
    elements.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="26440">Consider the following list of tuples, where each tuple contains
    a letter and a number: [(‘A’, 3), (‘B’, 1), (‘C’, 3), (‘D’, 2), (‘</st><st c="26572">E’,
    1)]</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26580">If we sort this list by the number (the second element in each
    tuple) in ascending order using a stable sorting algorithm, the result might be</st>
    <st c="26724">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26735">[(‘B’, 1), (‘E’, 1), (‘D’, 2), (‘A’, 3), (‘</st><st c="26779">C’,
    3)]</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26787">Observe that for tuples with identical numbers (such as (‘A’,
    3) and (‘C’, 3)), their original order is maintained after sorting.</st> <st c="26918">In
    other words, (‘A’, 3) precedes (‘C’, 3) in the sorted list, just as it did in
    the original list.</st> <st c="27018">If an unstable sorting algorithm is used,
    the resulting order may be</st> <st c="27087">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27098">[(‘E’, 1), (‘B’, 1), (‘D’, 2), (‘C’, 3), (‘</st><st c="27142">A’,
    3)]</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27150">Here, the relative order of (‘A’, 3) and (‘C’, 3) is</st> <st
    c="27204">not preserved.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27218">Stability is</st> <st c="27231">particularly important in the</st>
    <st c="27262">following scenarios:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="27282">Multiple key sorts</st>**<st c="27301">: When</st> <st c="27309">performing
    multi-level sorting (e.g., sorting first by one attribute and then by another),
    stability ensures that the order from the previous sort is preserved.</st> <st
    c="27470">For example, if you first sort a list of employees by their employment
    status and then by their employee numbers, a stable sort will maintain the employment
    status order while sorting</st> <st c="27654">by id.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27660">Preserving input order</st>**<st c="27683">: In</st> <st c="27688">some
    applications, the order of input elements carries significance beyond their sorted
    position.</st> <st c="27787">Stability ensures that this significance</st> <st
    c="27828">is preserved.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27841">Stability is crucial in applications requiring multiple levels
    of sorting or where the input order carries additional information.</st> <st c="27973">Stable
    sorting algorithms are preferred in such contexts to ensure data integrity</st>
    <st c="28055">and correctness.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28071">Iterative sorting algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="28100">Iterative sorting algorithms</st> <st c="28130">are renowned
    for their simplicity, making them easy to understand, implement, and debug.</st>
    <st c="28219">The major advantage of iterative sorting methods is their space
    efficiency; they typically require minimal additional memory, which can be a significant
    benefit in memory-constrained environments.</st> <st c="28416">However, these
    algorithms often exhibit poor performance in terms of time complexity, especially
    when handling large datasets.</st> <st c="28543">This limitation can be particularly
    problematic in scenarios where data size and processing time are critical factors.</st>
    <st c="28662">This section introduces three common iterative sorting algorithms:
    bubble sort, selection sort, and</st> <st c="28762">insertion sort.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28777">Bubble sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="28789">Bubble sort is a</st> <st c="28806">simple comparison-based algorithm</st>
    <st c="28841">that repeatedly scans through an array, comparing and swapping adjacent
    elements if they are in the wrong order.</st> <st c="28954">This process is repeated
    until the entire array is sorted.</st> <st c="29013">The analogy of “bubbling”
    arises from how smaller elements gradually ascend to the top while larger ones
    descend to</st> <st c="29129">the bottom.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29140">Despite its</st> <st c="29152">simplicity, bubble sort is generally</st>
    <st c="29190">inefficient for sorting datasets, exhibiting a quadratic running
    time,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>²</mml:mo><mml:mo>)</mml:mo><mml:mo>,</mml:mo></mml:math>](img/1052.png)
    <st c="29261"><st c="29262">in both average and worst-case scenarios.</st> <st
    c="29305">Nonetheless, its ease of comprehension and implementation make it a
    valuable educational tool and a viable option for sorting small datasets.</st>
    <st c="29447">As we have seen in the previous section, bubble sort is a stable
    and in-place algorithm and its space complexity</st> <st c="29560">is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="29563"><st c="29564">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="29565">Example 6.2</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="29577">Table 6.3</st>* <st c="29587">illustrates</st> <st c="29599">the
    step-by-step process of bubble sort for the array [</st>`<st c="29655">5, 3, 8,
    4, 2, 7,</st>` `<st c="29674">1, 6</st>`<st c="29678">]:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="29681">Pass</st>** | **<st c="29686">Description of</st>** **<st
    c="29702">the operation</st>** | **<st c="29715">Content of</st>** **<st c="29727">the
    array</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="29736">1</st> | <st c="29738">5 vs 3,</st> <st c="29746">swap them</st><st
    c="29755">5 vs 8,</st> <st c="29764">no swap</st><st c="29771">8 vs 4,</st> <st
    c="29780">swap them</st><st c="29789">8 vs 2,</st> <st c="29798">swap them</st><st
    c="29807">8 vs 7,</st> <st c="29816">swap them</st><st c="29825">8 vs 1,</st>
    <st c="29834">swap them</st><st c="29843">8 vs 6,</st> <st c="29852">swap them</st>
    | <st c="29861">[3, 5, 8, 4, 2, 7,</st> <st c="29881">1, 6]</st><st c="29886">[3,
    5, 8, 4, 2, 7,</st> <st c="29906">1, 6]</st><st c="29911">[3, 5, 4, 8, 2, 7,</st>
    <st c="29931">1, 6]</st><st c="29936">[3, 5, 4, 2, 8, 7,</st> <st c="29956">1,
    6]</st><st c="29961">[3, 5, 4, 2, 7, 8,</st> <st c="29981">1, 6]</st><st c="29986">[3,
    5, 4, 2, 7, 1,</st> <st c="30006">8, 6]</st><st c="30011">[3, 5, 4, 2, 7, 1,</st>
    <st c="30031">6, 8]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="30036">2</st> | <st c="30038">3 vs 5,</st> <st c="30046">no swap</st><st
    c="30053">5 vs 4,</st> <st c="30062">swap them</st><st c="30071">5 vs 2,</st>
    <st c="30080">swap them</st><st c="30089">5 vs 7,</st> <st c="30098">no swap</st><st
    c="30105">7 vs 1,</st> <st c="30114">swap them</st><st c="30123">7 vs 6,</st>
    <st c="30132">swap them</st><st c="30141">8 is now in its</st> <st c="30158">correct
    position</st> | <st c="30174">[3, 5, 4, 2, 7, 1,</st> <st c="30194">6, 8]</st><st
    c="30199">[3, 4, 5, 2, 7, 1,</st> <st c="30219">6, 8]</st><st c="30224">[3, 4,
    2, 5, 7, 1,</st> <st c="30244">6, 8]</st><st c="30249">[3, 4, 2, 5, 7, 1,</st>
    <st c="30269">6, 8]</st><st c="30274">[3, 4, 2, 5, 1, 7,</st> <st c="30294">6,
    8]</st><st c="30299">[3, 4, 2, 5, 1, 6,</st> <st c="30319">7, 8]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="30324">3</st> | <st c="30326">3 vs 4,</st> <st c="30334">no swap</st><st
    c="30341">4 vs 2,</st> <st c="30350">swap them</st><st c="30359">4 vs 5,</st>
    <st c="30368">no swap</st><st c="30375">5 vs 1,</st> <st c="30384">swap them</st><st
    c="30393">5 vs 6,</st> <st c="30402">no swap</st><st c="30409">7 and 8 are now
    in their</st> <st c="30435">correct positions</st> | <st c="30452">[3, 4, 2, 5,
    1, 6,</st> <st c="30472">7, 8]</st><st c="30477">[3, 2, 4, 5, 1, 6,</st> <st c="30497">7,
    8]</st><st c="30502">[3, 2, 4, 5, 1, 6,</st> <st c="30522">7, 8]</st><st c="30527">[3,
    2, 4, 1, 5, 6,</st> <st c="30547">7, 8]</st><st c="30552">[3, 2, 4, 1, 5, 6,</st>
    <st c="30572">7, 8]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="30577">4</st> | <st c="30579">3 vs 2,</st> <st c="30587">swap them</st><st
    c="30596">3 vs 4,</st> <st c="30605">no swap</st><st c="30612">4 vs 1,</st> <st
    c="30621">swap them</st><st c="30630">4 vs 5,</st> <st c="30639">no swap</st><st
    c="30646">6, 7, and 8 are now in their</st> <st c="30676">correct positions</st>
    | <st c="30693">[2, 3, 4, 1, 5, 6,</st> <st c="30713">7, 8]</st><st c="30718">[2,
    3, 4, 1, 5, 6,</st> <st c="30738">7, 8]</st><st c="30743">[2, 3, 1, 4, 5, 6,</st>
    <st c="30763">7, 8]</st><st c="30768">[2, 3, 1, 4, 5, 6,</st> <st c="30788">7,
    8]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="30793">5</st> | <st c="30795">2 vs 3,</st> <st c="30803">no swap</st><st
    c="30810">3 vs 1,</st> <st c="30819">swap them</st><st c="30828">3 vs 4,</st>
    <st c="30837">no swap</st><st c="30844">5, 6, 7, and 8 are now in their</st> <st
    c="30877">correct positions</st> | <st c="30894">[2, 3, 1, 4, 5, 6,</st> <st c="30914">7,
    8]</st><st c="30919">[2, 1, 3, 4, 5, 6,</st> <st c="30939">7, 8]</st><st c="30944">[2,
    1, 3, 4, 5, 6,</st> <st c="30964">7, 8]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="30969">6</st> | <st c="30971">2 vs 1,</st> <st c="30979">swap them</st><st
    c="30988">2 vs 3,</st> <st c="30997">no swap</st><st c="31004">4, 5, 6, 7, and
    8 are now in their</st> <st c="31040">correct positions</st><st c="31057">Now
    the array</st> <st c="31072">is sorted.</st> | <st c="31082">[1, 2, 3, 4, 5, 6,</st>
    <st c="31102">7, 8]</st><st c="31107">[1, 2, 3, 4, 5, 6,</st> <st c="31127">7,
    8]</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="31132">Table 6.3: Demonstrating an example of bubble sort</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31183">Here is the</st> <st c="31196">Python implementation of the bubble</st>
    <st c="31232">sort algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31478">The bubble sort algorithm is quite simple.</st> <st c="31522">It
    consists of two nested loops; the outer loop always</st> <st c="31576">executes</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1054.png)
    <st c="31586"><st c="31587">times, while the inner loop can terminate early if
    the array is already sorted or nearly sorted (indicating no swaps</st> <st c="31705">are
    necessary).</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31720">Now, let’s analyze the correctness of bubble sort and evaluate
    its</st> <st c="31788">time complexity.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31804">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="31825">As</st> <st c="31828">discussed in</st> [*<st c="31842">Chapter
    2</st>*](B22248_02.xhtml#_idTextAnchor023)<st c="31851">, we utilize the concept
    of a loop invariant to prove the correctness of algorithms.</st> <st c="31936">A
    loop invariant is a condition that remains true before and after each iteration
    of</st> <st c="32021">a loop.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32028">The loop invariant for bubble sort states that at the beginning
    of each iteration of the outer loop (</st>`<st c="32130">for i in range(n):</st>`<st
    c="32149">), the last</st> `<st c="32162">i</st>` <st c="32163">elements are sorted
    and in their final positions.</st> <st c="32214">To establish the correctness
    of the algorithm, we need to assess</st> <st c="32279">three conditions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="32296">Initialization</st>**<st c="32311">: Before the first iteration
    (</st>*<st c="32342">i</st>* <st c="32344">= 0), no elements have been processed.</st>
    <st c="32384">The invariant trivially holds since the empty sub-array</st> <st
    c="32440">is sorted.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32450">Maintenance</st>**<st c="32462">: Assume the invariant holds
    before the</st> *<st c="32503">i</st>*<st c="32504" class="calibre11">th</st>
    <st c="32506">iteration.</st> <st c="32518">During the</st> *<st c="32529">i</st>*<st
    c="32530" class="calibre11">th</st> <st c="32532">iteration, the adjacent elements
    are compared and swapped if they are not in the right order.</st> <st c="32627">By
    the end of the</st> *<st c="32645">i</st>*<st c="32646" class="calibre11">th</st>
    <st c="32648">pass, the largest unsorted element is “bubbled up” to its correct
    position in the array, ensuring that the last</st> *<st c="32761">i</st>* <st
    c="32762">elements are sorted.</st> <st c="32784">Thus, the invariant</st> <st
    c="32804">is maintained.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32818">Termination</st>**<st c="32830">: The algorithm terminates
    after</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1055.png)
    <st c="32864"><st c="32865">iterations of the outer loop, where</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1055.png)
    <st c="32902"><st c="32903">is the size of input data.</st> <st c="32931">At this
    point, the invariant guarantees that the entire array is sorted, as the last</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="33016"><st c="33065">elements (i.e., the entire array) are in their</st>
    <st c="33112">correct positions.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33130">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="33150">To understand</st> <st c="33165">time complexity, we can analyze
    it in the</st> <st c="33207">following scenarios:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="33227">Best case</st>**<st c="33237">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="33240"><st c="33241">– This happens when the array is already sorted.</st>
    <st c="33291">The algorithm will make a single pass through the array without
    performing any swaps and terminate early, as no out-of-order pairs (“bubbles”)
    will</st> <st c="33439">be found</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33447">Average case</st>**<st c="33460">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1059.png)
    <st c="33463"><st c="33469">– This occurs when input data is random.</st> <st
    c="33510">The algorithm will need to make multiple passes, each involving</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></mrow></math>](img/1060.png)
    <st c="33574"><st c="33575">comparisons.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33587">Worst case</st>**<st c="33598">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1061.png)
    <st c="33601"><st c="33607">– This occurs when the array is sorted in reverse
    order.</st> <st c="33664">Bubble sort needs to perform the maximum number of comparisons
    and swaps during each pass through</st> <st c="33762">the array.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33772">To determine</st> <st c="33785">space complexity, we need to evaluate
    the auxiliary or temporary memory used during sorting.</st> <st c="33879">Bubble
    sort is recognized as an in-place algorithm, meaning it works directly on the
    input array and only requires a constant amount of extra space for</st> <st c="34031">swapping
    elements.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34049">Selection sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="34064">Selection sort</st> <st c="34079">is a comparison-based method
    that</st> <st c="34114">divides a list into two parts: a sorted section, which
    starts empty and grows, and an unsorted section, which starts with all the elements
    and shrinks.</st> <st c="34266">In each step, the algorithm finds the smallest
    (or largest) item in the unsorted part and moves it to the end of the sorted part.</st>
    <st c="34396">This continues until the entire list</st> <st c="34433">is sorted.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34443">Selection sort, characterized by its simplicity, consistently
    exhibits a quadratic running time,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi
    mathvariant="normal">²</mi><mo>)</mo><mo>,</mo></mrow></mrow></mrow></math>](img/1062.png)<st
    c="34541"><st c="34542">in the best, average, and worst-case scenarios.</st> <st
    c="34590">While inefficient for large datasets, its straightforward nature makes
    it easy to grasp and implement.</st> <st c="34693">This algorithm is not adaptive,
    meaning it doesn’t exploit any existing order within the data.</st> <st c="34788">However,
    selection sort operates directly within the input data, requiring only a small,
    constant amount of additional memory (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1063.png)<st
    c="34915"><st c="34917">).</st> <st c="34920">It is important to note that selection
    sort is unstable and does not guarantee maintaining the original order of identical
    elements.</st> <st c="35053">Despite its drawbacks, selection sort is useful for
    sorting small data sets and easy</st> <st c="35138">to implement.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35151">Example 6.3</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="35163">Table 6.4</st>* <st c="35173">illustrates</st> <st c="35185">the
    step-by-step process of selection sort for the array [</st>`<st c="35244">29,
    10, 14, 37,</st>` `<st c="35261">13, 5</st>`<st c="35266">]:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="35269">Pass</st>** | **<st c="35274">Description of</st>** **<st
    c="35290">the operation</st>** | **<st c="35303">Content of</st>** **<st c="35315">the
    array</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="35324">1</st> | <st c="35326">Find the minimum in [29, 10, 14, 37,
    13, 5] (which is 5), and swap the minimum with the</st> <st c="35414">first element</st>
    | <st c="35427">[5, 10, 14, 37,</st> <st c="35444">13, 29]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="35451">2</st> | <st c="35453">Find the minimum element in [10, 14,
    37, 13, 29] (which is 10), and swap the minimum with the second element (no swap
    needed as it’s already</st> <st c="35594">in place)</st> | <st c="35603">[5, 10,
    14, 37,</st> <st c="35620">13, 29]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="35627">3</st> | <st c="35629">Find the minimum in [14, 37, 13, 29]
    (which is 13), and swap the minimum with the</st> <st c="35711">third element</st>
    | <st c="35724">[5, 10, 13, 37,</st> <st c="35741">14, 29]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="35748">4</st> | <st c="35750">Find the minimum in [37, 14, 29] (which
    is 14), and swap the minimum with the</st> <st c="35828">fourth element</st> |
    <st c="35842">[5, 10, 13, 14,</st> <st c="35859">29, 37]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="35866">5</st> | <st c="35868">Find the minimum in [37, 29] (which
    is 29), and swap the minimum with the</st> <st c="35942">fifth element</st> |
    <st c="35955">[5, 10, 13, 14,</st> <st c="35972">37, 29]</st> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <st c="35979">Now the array</st> <st c="35994">is sorted.</st> | <st c="36004">[5,
    10, 13, 14,</st> <st c="36021">29, 37]</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="36028">Table 6.4: Demonstrating an example of selection sort</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36082">The</st> <st c="36087">following</st> <st c="36097">is the Python
    implementation of the selection</st> <st c="36143">sort algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36333">The selection sort algorithm is straightforward.</st> <st c="36383">The
    outer loop,</st> `<st c="36399">for i in range(n):</st>`<st c="36417">, traverses
    the array,</st> `<st c="36440">a</st>`<st c="36441">, and the inner loop,</st>
    `<st c="36463">for j in range(i + 1, n):</st>`<st c="36488">, finds the element
    with the minimum value.</st> <st c="36532">Then, the minimum and the element at
    the top of</st> <st c="36580">the sub-array are swapped:</st> `<st c="36607">a[i],
    a[min_id] =</st>` `<st c="36625">a[min_id], a[i]</st>`<st c="36640">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36641">Let’s examine the correctness of the algorithm and also evaluate</st>
    <st c="36707">its complexities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36724">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="36745">The</st> <st c="36749">loop invariant in selection sort states
    that at the beginning of each iteration of the outer loop (</st>`<st c="36849">for
    i in range(n):</st>`<st c="36868">), the sub-array,</st> `<st c="36887">a[0:i]</st>`<st
    c="36893">, consists of the smallest</st> `<st c="36920">i</st>` <st c="36921">elements
    from the original array, arranged in ascending order.</st> <st c="36985">We need
    to evaluate three conditions for the</st> <st c="37030">algorithm’s correctness:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37054">Initialization</st>**<st c="37069">: Before the first iteration
    (</st>*<st c="37100">i</st>* <st c="37102">= 0), the sub-array,</st> **<st c="37124">a[0:0]</st>**<st
    c="37130">, is empty.</st> <st c="37142">The invariant trivially holds since the
    empty sub-array</st> <st c="37198">is sorted.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="37208">Maintenance</st>**<st c="37220">: Let’s assume the invariant
    holds true before the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1064.png)
    <st c="37272"><st c="37276">iteration.</st> <st c="37287">During this iteration,
    the algorithm identifies the smallest element within the sub-array,</st> **<st
    c="37378">a[i:n]</st>**<st c="37384">, and swaps it with</st> **<st c="37404">a[i]</st>**<st
    c="37408">. Consequently,</st> **<st c="37424">a[i]</st>** <st c="37428">becomes
    the smallest element in</st> **<st c="37461">a[i:n]</st>**<st c="37467">, and
    the sub-array,</st> **<st c="37488">a[0:i+1]</st>**<st c="37496">, is sorted.</st>
    <st c="37509">This ensures the invariant</st> <st c="37536">is maintained.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="37550">Termination</st>**<st c="37562">: The algorithm terminates
    after</st> *<st c="37596">n</st>* <st c="37597">iterations of the outer loop.</st>
    <st c="37628">At this point, the invariant guarantees that the entire array,</st>
    **<st c="37691">a[0:n]</st>**<st c="37697">, is sorted, as all elements have</st>
    <st c="37731">been processed.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37746">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="37766">To</st> <st c="37770">evaluate the time complexity of selection
    sort, consider the two nested loops.</st> <st c="37849">The outer loop runs</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1065.png)
    <st c="37869"><st c="37870">times, and for each iteration, the inner loop runs</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1066.png)
    <st c="37922"><st c="37923">times, leading to a total of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1067.png)
    <st c="37953"><st c="37964">comparisons.</st> <st c="37977">Since this operation
    dominates the algorithm’s runtime, the time complexity for the best, average,
    and worst cases</st> <st c="38092">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1068.png)<st
    c="38095"><st c="38101">.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38102">For space complexity, we need to determine the auxiliary or temporary
    memory used to execute selection sort.</st> <st c="38212">Since it uses an in-place
    approach, it only needs a constant amount of extra space for swapping elements,
    making its space</st> <st c="38335">complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="38346"><st c="38347">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38348">Insertion sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="38363">Insertion sort</st> <st c="38378">is a simple and intuitive algorithm
    that builds the final ordered list gradually, one element at a time.</st> <st
    c="38484">Insertion sort</st> <st c="38498">operates by splitting the array into
    a sorted section and an unsorted section.</st> <st c="38578">With each step, the
    algorithm takes the next element from the unsorted section and inserts it into
    its proper place within the sorted section.</st> <st c="38721">This process is
    analogous to how one might sort playing cards, placing each card in the correct
    place relative to the cards</st> <st c="38845">already sorted.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38860">The time complexity of insertion sort is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>²</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1070.png)
    <st c="38902"><st c="38903">for both average and worst-case scenarios.</st> <st
    c="38947">However, it demonstrates impressive efficiency with a time complexity
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)
    <st c="39020"><st c="39021">when dealing with nearly sorted or</st> <st c="39057">small
    datasets.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39072">A key advantage of insertion sort is its stability as a sorting
    method.</st> <st c="39145">Moreover, it is an in-place algorithm, requiring only
    a constant amount of additional memory.</st> <st c="39239">Its simplicity and
    efficiency with small datasets make insertion sort valuable in specific situations
    and an excellent educational tool for understanding fundamental</st> <st c="39405">sorting
    concepts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="39422">Example 6.4</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="39434">Table 6.5</st>* <st c="39444">illustrates</st> <st c="39456">the
    step-by-step process of insertion sort for the array [</st>`<st c="39515">8, 3,
    1, 7,</st>` `<st c="39528">0, 10</st>`<st c="39533">]:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="39536">Pass</st>** | **<st c="39541">Description of</st>** **<st
    c="39557">the operation</st>** | **<st c="39570">Content of</st>** **<st c="39582">the
    array</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39591">1</st> | <st c="39593">Key = 3, compare 3 with 8, and move
    8 to</st> <st c="39634">the right.</st><st c="39644">Insert 3 at the</st> <st
    c="39661">correct position.</st> | <st c="39678">[3, 8, 1, 7,</st> <st c="39692">0,
    10]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39698">2</st> | <st c="39700">Key = 1, compare 1 with 8, and move
    8 to</st> <st c="39741">the right.</st><st c="39751">Compare 1 with 3, and move
    3 to</st> <st c="39784">the right.</st><st c="39794">Insert 1 at the</st> <st
    c="39811">correct position.</st> | <st c="39828">[1, 3, 8, 7,</st> <st c="39842">0,
    10]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39848">3</st> | <st c="39850">Key = 7, compare 7 with 8, and move
    8 to</st> <st c="39891">the right.</st><st c="39901">Insert 7 at the</st> <st
    c="39918">correct position.</st> | <st c="39935">[1, 3, 7, 8,</st> <st c="39949">0,
    10]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="39955">4</st> | <st c="39957">Key = 0, compare 0 with 8, and move
    8 to</st> <st c="39998">the right.</st><st c="40008">Compare 0 with 7, and move
    7 to</st> <st c="40041">the right.</st><st c="40051">Compare 0 with 3, and move
    3 to</st> <st c="40084">the right.</st><st c="40094">Compare 0 with 1, and move
    1 to</st> <st c="40127">the right.</st><st c="40137">Insert 0 at the</st> <st
    c="40154">correct position.</st> | <st c="40171">[0, 1, 3, 7,</st> <st c="40185">8,
    10]</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="40191">5</st> | <st c="40193">Key = 10, no elements to move, insert
    10 at the correct position.</st> <st c="40259">Now the array</st> <st c="40273">is
    sorted.</st> | <st c="40283">[0, 1, 3, 7,</st> <st c="40297">8, 10]</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="40303">Table 6.5: Demonstrating an example of insertion sort</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40357">The</st> <st c="40361">following is a simple Python implementation
    of</st> <st c="40408">insertion sort:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40599">The core of the insertion sort algorithm lies in its inner</st>
    `<st c="40659">while</st>` <st c="40664">loop (</st>`<st c="40671">while j >=
    0 and key < a[j]:</st>`<st c="40700">).</st> <st c="40704">The condition in the</st>
    `<st c="40725">while</st>` <st c="40730">loop ensures that if the data is pre-sorted
    (or nearly sorted), the algorithm performs linearly in terms of time complexity.</st>
    <st c="40856">Let’s discuss the algorithm’s correctness and its complexity</st>
    <st c="40917">in detail.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40927">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="40948">The</st> <st c="40952">loop invariant for insertion sort states
    that at the beginning of each iteration of the outer loop (</st>`<st c="41053">for
    i in range(1, n):</st>`<st c="41075">), the elements in</st> `<st c="41095">a[0:i]</st>`
    <st c="41101">consist of the same elements that can be found in</st> `<st c="41152">a[0:i]</st>`<st
    c="41158">, but now in sorted order.</st> <st c="41185">To establish the correctness
    of the algorithm, we need to assess the following</st> <st c="41264">three conditions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="41281">Initialization</st>**<st c="41296">: Before the first iteration
    (i = 1), the sub-array,</st> **<st c="41350">a[0:1]</st>**<st c="41356">, is just
    the first element of the array, which is trivially in the correct</st> <st c="41432">position
    (sorted).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41450">Maintenance</st>**<st c="41462">: Let’s assume the loop invariant
    holds before the</st> *<st c="41514">i</st>*<st c="41515" class="calibre11">th</st><st
    c="41517">iteration.</st> <st c="41529">The algorithm inserts</st> **<st c="41551">a[i]</st>**
    <st c="41555">into the sorted sub-array,</st> **<st c="41583">a[0:i]</st>**<st
    c="41589">, by moving elements that are greater than</st> **<st c="41632">a[i]</st>**
    <st c="41636">one position to the right.</st> <st c="41664">This insertion ensures
    that</st> **<st c="41692">a[0:i+1]</st>** <st c="41700">is sorted.</st> <st c="41712">Thus,
    the invariant</st> <st c="41732">is maintained.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41746">Termination</st>**<st c="41758">: The algorithm terminates
    after</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1072.png)
    <st c="41792"><st c="41793">iterations of the outer loop, where</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1072.png)
    <st c="41830"><st c="41831">is the length of the array.</st> <st c="41860">At
    this point, the invariant guarantees that the entire array,</st> **<st c="41923">a[0:n]</st>**<st
    c="41929">, is sorted, as all elements have</st> <st c="41963">been processed.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41978">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="41998">To understand</st> <st c="42012">the time complexity, we can analyze
    it in the</st> <st c="42059">following scenarios:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="42079">Best case</st>**<st c="42089">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1074.png)
    <st c="42092"><st c="42093">– As previously demonstrated, the condition in the</st>
    **<st c="42145">while</st>** <st c="42150">loop ensures that if the input is already
    sorted, the</st> **<st c="42205">while</st>** <st c="42210">loop does not execute,
    guaranteeing a linear</st> <st c="42256">time complexity.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42272">Average case</st>**<st c="42285">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1075.png)
    <st c="42288"><st c="42294">– The algorithm performs</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1076.png)
    <st c="42319"><st c="42328">comparisons and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1076.png)
    <st c="42344"><st c="42353">swaps</st> <st c="42359">on average.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42370">Worst case</st>**<st c="42381">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1078.png)
    <st c="42384"><st c="42390">– This occurs when the input array is sorted in reverse
    order.</st> <st c="42453">In this scenario, the condition of the</st> **<st c="42492">while</st>**
    <st c="42497">loop causes it to execute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/485.png)
    <st c="42524"><st c="42525">times in each iteration.</st> <st c="42551">Given
    that the outer loop runs</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="42582"><st c="42631">times, the maximum number of comparisons and swaps
    will</st> <st c="42687">be</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1081.png)<st
    c="42690"><st c="42701">.</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42702">To assess</st> <st c="42713">the space complexity, we need to
    evaluate the auxiliary or temporary space required to run insertion sort.</st>
    <st c="42820">Given that insertion sort is an in-place algorithm, it only requires
    a constant amount of extra space for element swapping.</st> <st c="42944">Consequently,
    its space complexity</st> <st c="42979">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="42982"><st c="42983">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42984">Having covered the major iterative sorting algorithms, we will
    now shift our focus to discussing recursive</st> <st c="43092">sorting methods.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43108">Recursive sorting algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="43137">The</st> <st c="43141">iterative, non-recursive sorting algorithms,
    while typically space efficient, often fall short in terms of time complexity,
    particularly when handling large datasets.</st> <st c="43309">This limitation
    becomes critical in scenarios involving substantial amounts of data, where more
    efficient sorting mechanisms are necessary.</st> <st c="43449">In</st> *<st c="43452">Table
    6.1</st>*<st c="43461">, we discussed the general characteristics of recursive
    sorting algorithms, highlighting their potential to overcome the time complexity
    issues associated with</st> <st c="43621">iterative methods.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="43639">In this section, we analyze two major recursive sorting algorithms:
    merge sort and quick sort.</st> <st c="43735">Both algorithms leverage the divide-and-conquer
    strategy to achieve superior performance compared to their iterative counterparts.</st>
    <st c="43866">Merge sort, with its consistent</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1083.png)
    <st c="43898"><st c="43909">time complexity, provides stable and predictable sorting
    efficiency.</st> <st c="43978">Quick sort is known for its average-case</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1084.png)
    <st c="44019"><st c="44030">performance and combines simplicity</st> <st c="44066">with
    efficiency.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44082">It’s also worth mentioning that another significant recursive
    sorting algorithm, heap sort, will be introduced in</st> [*<st c="44197">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200) <st c="44207">when we discuss heap
    structures.</st> <st c="44241">Heap sort, like merge sort and quick sort, utilizes
    the divide-and-conquer approach but does so through the use of a binary heap data
    structure, providing an efficient and space-conscious</st> <st c="44429">sorting
    solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44446">Merge sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="44457">Merge sort</st> <st c="44469">is a comparison-based sorting</st>
    <st c="44499">algorithm that utilizes the divide-and-conquer strategy.</st> <st
    c="44556">It operates by recursively splitting the unsorted array into two roughly
    equal partitions until each sub-array consists of a single element (which is naturally
    sorted).</st> <st c="44725">The algorithm then merges these sub-arrays to</st>
    <st c="44770">create new sorted sub-arrays, continuing this process until only
    one sorted array remains, which represents the original array in sorted order.</st>
    <st c="44915">At the merge step, the smallest elements of each sub-array are compared
    and then two sub-arrays</st> <st c="45011">are combined.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="45024">Example 6.5</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="45036">Table 6.6</st>* <st c="45046">illustrates</st> <st c="45058">the
    step-by-step process of merge sort for the array [</st>`<st c="45113">38, 27,
    43, 3,</st>` `<st c="45129">9, 82</st>`<st c="45134">]:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="45137">Split/merge</st>** | **<st c="45149">Content of</st>** **<st
    c="45161">the (sub)array</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="45175">First split</st> | <st c="45187">Split [38, 27, 43, 3, 9, 82]
    into [38, 27, 43] and [3,</st> <st c="45243">9, 82].</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="45250">Second split (</st><st c="45265">left half)</st> | <st c="45276">Split
    [38, 27, 43] into [38] and [</st><st c="45311">27, 43].</st><st c="45320">Split
    [27, 43] into [27]</st> <st c="45346">and [43].</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="45355">Merge</st><st c="45361">(</st><st c="45363">left half)</st>
    | <st c="45373">Merge [27] and [43] to get [</st><st c="45402">27, 43].</st><st
    c="45411">Merge [38] and [27, 43] to get [27,</st> <st c="45448">38, 43].</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="45456">Second split (</st><st c="45471">right half)</st> | <st c="45483">Split
    [3, 9, 82] into [3] and [</st><st c="45515">9, 82].</st><st c="45523">Split [9,
    82] into [9]</st> <st c="45547">and [82].</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="45556">Merge</st><st c="45562">(</st><st c="45564">Right half)</st>
    | <st c="45575">Merge [9] and [82] to get [</st><st c="45603">9, 82].</st><st
    c="45611">Merge [3] and [9, 82] to get [3,</st> <st c="45645">9, 82].</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="45652">Final merge</st> | <st c="45664">Merge [27, 38, 43] and [3,
    9, 82] to get [3, 9, 27, 38,</st> <st c="45721">43, 82].</st><st c="45729">Now
    the array is sorted: [3, 9, 27, 38,</st> <st c="45770">43, 82].</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="45778">Table 6.6: Demonstrating an example of merge sort</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45828">Here is the Python implementation of the merge</st> <st c="45876">sort
    algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46397">While</st> <st c="46404">there are numerous implementations</st>
    <st c="46438">of merge sort, the version we presented is quite straightforward.</st>
    <st c="46505">The key component of the algorithm is a function called</st> `<st
    c="46561">merge</st>` <st c="46567">used to merge the two partitions that have
    been</st> <st c="46615">recursively sorted.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46634">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="46655">The loop</st> <st c="46664">invariant definition in merge sort
    states that at the start of each iteration of the merging process, the</st> `<st
    c="46771">left_partition</st>` <st c="46785">and</st> `<st c="46790">right_partition</st>`
    <st c="46805">sub-arrays are sorted.</st> <st c="46829">We need to evaluate three
    conditions for the</st> <st c="46874">algorithm’s correctness:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="46898">Initialization</st>**<st c="46913">: Before the first merge
    operation, the sub-arrays contain single elements, which are</st> <st c="47000">inherently
    sorted.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="47018">Maintenance</st>**<st c="47030">: Assume the invariant holds
    before merging two sub-arrays.</st> <st c="47091">During the merge process, the
    smallest remaining element from either sub-array is selected and added to the
    merged array.</st> <st c="47213">This maintains the sorted order of the merged
    array.</st> <st c="47266">The invariant holds because each selection step ensures
    the merged array</st> <st c="47339">remains sorted.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="47354">Termination</st>**<st c="47366">: The algorithm terminates
    after all sub-arrays have been merged into a single sorted array.</st> <st c="47460">At
    this point, the invariant guarantees that the entire array</st> <st c="47522">is
    sorted.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47532">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="47552">Merge sort is a recursive sorting algorithm that operates according
    to the recurrence function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1085.png)<st
    c="47648"><st c="47666">. At each recursive step, merge sort divides the problem
    into two</st> <st c="47732">nearly equal sub-problems, reflecting the general
    divide-and-conquer relation</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1086.png)
    <st c="47810"><st c="47829">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1087.png)
    <st c="47834"><st c="47835">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1088.png)<st
    c="47840"><st c="47841">. The division of the array and the merging of the sorted
    sub-arrays are both linear time operations,</st> <st c="47943">hence</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1089.png)<st
    c="47949"><st c="47950">.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47951">To evaluate the running time complexity of merge sort, we need
    to solve this recurrence function using methods such as the master theorem.</st>
    <st c="48091">The master theorem provides a straightforward way to solve recurrences
    of the form</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1090.png)
    <st c="48174"><st c="48189">by comparing</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1091.png)
    <st c="48202"><st c="48206">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:math>](img/722.png)<st
    c="48209"><st c="48210">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48211">In the case of merge sort,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/870.png)<st
    c="48239"><st c="48240">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)<st
    c="48242"><st c="48243">,</st> <st c="48245">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1089.png)<st
    c="48249"><st c="48250">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48251">We calculate</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1096.png)<st
    c="48265"><st c="48281">. The following apply according to the</st> <st c="48320">master
    theorem:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48335">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1097.png)
    <st c="48339"><st c="48349">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo><</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:math>](img/1098.png)<st
    c="48355"><st c="48364">,</st> <st c="48366">then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1099.png)</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="48372">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1100.png)<st
    c="48375"><st c="48394">,</st> <st c="48396">then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msup><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1101.png)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="48420">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Ω</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1102.png)
    <st c="48423"><st c="48432">where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mo>></mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:mrow></mml:math>](img/1103.png)<st
    c="48438"><st c="48447">, and if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1104.png)
    <st c="48456"><st c="48467">for some</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>c</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/946.png)
    <st c="48476"><st c="48477">and sufficiently large</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="48501"><st c="48550">,</st> <st c="48552">then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1107.png)</st></st></st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="48571">In our case,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1108.png)
    <st c="48584"><st c="48585">matches the second case of the master theorem because</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1109.png)
    <st c="48640"><st c="48645">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1110.png)<st
    c="48648"><st c="48664">. Thus, case 2 applies, leading to the</st> <st c="48703">following
    conclusion:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1111.png)<st
    c="48724"><st c="48741">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48742">To assess the time complexity of merge sort, we can analyze it
    in the</st> <st c="48813">following scenarios:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="48833">Best case</st>**<st c="48843">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1112.png)
    <st c="48846"><st c="48856">– Merge sort consistently divides the array and merges
    sub-arrays in</st> <st c="48925">logarithmic steps</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="48942">Average case</st>**<st c="48955">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1113.png)
    <st c="48958"><st c="48968">– The algorithm performs consistently in all cases
    due to its</st> <st c="49030">divide-and-conquer approach</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="49057">Worst case</st>**<st c="49068">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1114.png)
    <st c="49071"><st c="49081">– Merge sort is not adaptive, meaning its performance
    remains consistent regardless of the initial order of</st> <st c="49189">the elements</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="49201">To determine the space complexity, we need to consider the auxiliary
    or temporary space required to execute merge sort.</st> <st c="49322">In the merge
    sort algorithm, two arrays,</st> `<st c="49363">left_partition</st>` <st c="49377">and</st>
    `<st c="49382">right_partition</st>`<st c="49397">, are used as temporary storage
    during the merge operation.</st> <st c="49457">The combined size of these two
    arrays is equal to the input size, resulting in a space complexity</st> <st c="49555">of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="49558"><st c="49559">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49560">In summary, merge sort</st> <st c="49584">is a highly efficient
    and stable sorting algorithm with a time complexity of</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>O</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mi>log</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/1116.png)<st
    c="49660">![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>O</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mi>log</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/1117.png)
    <st c="49662"><st c="49670">in the best, average, and worst cases.</st> <st c="49709">It
    employs a divide-and-conquer approach, dividing the array into smaller sub-arrays,
    sorting them recursively, and then merging them in sequence.</st> <st c="49856">￼Although
    it necessitates</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi
    mathvariant="normal">O</mi><mo>(</mo><mi mathvariant="normal">n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1118.png)
    <st c="49881"><st c="49883">additional space, its consistent performance and stability
    make it an excellent choice for sorting large datasets, especially when stability
    is essential.</st> <st c="50039">The recursive nature and dependable performance
    of merge sort make it a foundational algorithm in</st> <st c="50137">computer
    science.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50154">Quick sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="50165">Quick sort is</st> <st c="50179">a highly efficient divide-and-conquer</st>
    <st c="50217">sorting algorithm that, like merge sort, relies on comparisons.</st>
    <st c="50282">It recursively selects a pivot element from the array and partitions
    the remaining elements into two sub-arrays based on whether they are smaller or
    larger than the pivot.</st> <st c="50454">These sub-arrays are then sorted recursively.</st>
    <st c="50500">This process repeats until the base case of an empty or single-element
    sub-array, which is inherently sorted, is reached.</st> <st c="50622">The effectiveness
    of quick sort depends largely on the choice of pivot and the method used</st>
    <st c="50713">for partitioning.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50730">The quick sort algorithm is comprised of three</st> <st c="50778">key
    components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="50793">Pivot selection</st>**<st c="50809">: This</st> <st c="50816">step
    involves choosing an element as the pivot from the array.</st> <st c="50880">Common
    choices include the first, last, middle, or a randomly selected element.</st>
    <st c="50960">The specific pivot selection strategy can influence the algorithm’s
    overall performance.</st> <st c="51049">In the probabilistic quick sort, a pivot
    is randomly selected (see</st> [*<st c="51116">Chapter 9</st>*](B22248_09.xhtml#_idTextAnchor129)<st
    c="51125">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51128">Partitioning</st>**<st c="51141">: During</st> <st c="51150">this
    step, the array is divided into two smaller sub-arrays.</st> <st c="51212">All
    elements smaller than the pivot are placed in one sub-array, while those greater
    than the pivot are placed in the other.</st> <st c="51337">After this step, the
    pivot is in its final sorted position within</st> <st c="51403">the array.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51413">Recursion</st>**<st c="51423">: The</st> <st c="51430">partitioning
    step is repeated recursively until all sub-arrays are either empty or contain
    a single element, ultimately resulting in a fully</st> <st c="51571">sorted array.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51584">Example 6.6</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51596">Let’s illustrate the</st> <st c="51617">operation with an array
    of six random numbers—[</st>`<st c="51665">35, 12, 99, 42,</st>` `<st c="51682">5,
    8</st>`<st c="51686">]:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51689">Choose</st> <st c="51696">a pivot (e.g.,</st> **<st c="51712">8</st>**<st
    c="51713">) and rearrange the array so that elements less than the pivot come
    before it and elements greater come</st> <st c="51817">after it.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="51826">Recursively sort left</st> <st c="51849">sub-array</st> `<st c="51864">[5]</st>`
    <st c="51867">is</st> <st c="51871">already sorted.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="51886">Recursively sort right sub-array</st> `<st c="51960">35</st>`<st
    c="51962">) and rearrange:</st> `<st c="51980">[5, 8, 12, 35,</st>` `<st c="51995">42,
    99]</st>`<st c="52002">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="52003">Recursively sort sub-arrays</st> **<st c="52032">[12]</st>** <st
    c="52036">and</st> **<st c="52041">[</st>****<st c="52042">42, 99]</st>**<st c="52049">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="52051">[12]</st>** <st c="52055">is</st> <st c="52059">already sorted.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52074">Choose a pivot (e.g.,</st> **<st c="52097">42</st>**<st c="52099">)
    and rearrange</st> **<st c="52116">[42, 99]</st>**<st c="52124">:</st> **<st c="52127">[5,
    8, 12, 35,</st>** **<st c="52142">42, 99]</st>**<st c="52149">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52150">Now the array is sorted:</st> **<st c="52176">[5, 8, 12, 35,</st>**
    **<st c="52191">42, 99]</st>**<st c="52198">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="52199">Here is the Python implementation of the quick</st> <st c="52247">sort
    algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="52513">As demonstrated, the</st> <st c="52534">core concept in the quick
    sort algorithm is selecting a pivot element for partitioning.</st> <st c="52623">This
    process is then</st> <st c="52644">repeated recursively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52665">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="52686">The loop invariant</st> <st c="52705">definition in merge sort
    guarantees that at the beginning of each iteration of the partitioning process,
    all elements in</st> `<st c="52827">left_partition</st>` <st c="52841">are not
    greater than the</st> `<st c="52867">pivot</st>`<st c="52872">, and all elements
    in</st> `<st c="52894">right_partition</st>` <st c="52909">are not less than the</st>
    `<st c="52932">pivot</st>`<st c="52937">. We need to evaluate three conditions
    for the</st> <st c="52984">algorithm’s correctness:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="53008">Initialization</st>**<st c="53023">: Before the first partitioning
    operation, the sub-array is the entire array, and the loop invariant trivially
    holds since no elements have been</st> <st c="53169">processed yet.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53183">Maintenance</st>**<st c="53195">: During the partitioning process,
    elements are compared to the pivot and swapped as necessary.</st> <st c="53292">This
    ensures that the two sub-arrays,</st> **<st c="53330">left_partition</st>** <st
    c="53344">and</st> **<st c="53349">right_partition</st>**<st c="53364">, are maintained
    according to the definition;</st> **<st c="53410">left_partition</st>** <st c="53424">contains
    elements smaller than the</st> **<st c="53460">pivot</st>**<st c="53465">, and</st>
    **<st c="53471">right_partition</st>** <st c="53486">contains elements greater
    than</st> <st c="53518">the</st> **<st c="53522">pivot</st>**<st c="53527">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53528">Termination</st>**<st c="53540">: The algorithm terminates
    when sub-arrays of length 0 or 1 are reached, which are inherently sorted.</st>
    <st c="53643">The loop invariant guarantees that the elements are correctly partitioned
    at each step, ensuring the entire array is sorted</st> <st c="53767">upon completion.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53783">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="53803">Quick sort is</st> <st c="53817">characterized by the following</st>
    <st c="53849">recurrence function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1119.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="53900">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/441.png)
    <st c="53906"><st c="53907">is the number of elements smaller than the pivot.</st>
    <st c="53958">To simplify the analysis, we assume an ideal scenario where the
    pivot always splits the list into two equal partitions, leading to the following</st>
    <st c="54103">recurrence function:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1121.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="54141">This can</st> <st c="54149">be expressed in the general form of
    a</st> <st c="54188">divide-and-conquer function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1090.png)
    <st c="54216"><st c="54232">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/870.png)<st
    c="54237"><st c="54238">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)<st
    c="54240"><st c="54241">,</st> <st c="54243">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1089.png)</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54248">To determine the time complexity, we apply the master theorem.</st>
    <st c="54311">The master theorem helps solve recurrences of the form</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1126.png)
    <st c="54366"><st c="54381">by comparing</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1127.png)
    <st c="54394"><st c="54399">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:math>](img/1128.png)<st
    c="54402"><st c="54409">. In the case of quick sort,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/870.png)<st
    c="54438"><st c="54439">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/745.png)<st
    c="54441"><st c="54442">,</st> <st c="54444">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1089.png)<st
    c="54448"><st c="54449">.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54450">In our case,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1132.png)
    <st c="54464"><st c="54465">matches the second case of the master theorem because</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1133.png)
    <st c="54520"><st c="54525">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1134.png)<st
    c="54528"><st c="54545">. Thus, case 2 applies, leading to the</st> <st c="54584">following
    conclusion:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1111.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="54622">This indicates that the average-case time complexity of quick
    sort is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1136.png)<st
    c="54692"><st c="54701">. Due to this efficiency, quick sort is highly effective
    for large datasets.</st> <st c="54778">However, in the worst-case scenario, which
    occurs with poor pivot selection, resulting in consistently unbalanced partitions
    (e.g., always choosing the smallest or largest element as the pivot), the recurrence
    relation becomes</st> <st c="55005">the following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1137.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="55051">This simplifies to</st> <st c="55070">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1138.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="55086">Solving this recurrence relation yields</st> <st c="55126">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1139.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="55142">Therefore, the worst-case time complexity of quick sort is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1140.png)<st
    c="55201"><st c="55207">. However, strategies such as random pivot selection or
    the median-of-three method can greatly reduce the chances of encountering this
    worst-case scenario, helping to preserve the algorithm’s average-case performance.</st>
    <st c="55425">The following is a summary of quick sort’s</st> <st c="55468">time
    complexity:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="55484">Best case</st>**<st c="55494">:</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi> </mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1141.png)
    <st c="55496"><st c="55505">– This occurs when the pivot consistently splits the
    array into two nearly</st> <st c="55580">equal halves</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="55592">Average case</st>**<st c="55605">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1142.png)
    <st c="55608"><st c="55619">– The algorithm performs well on average with random</st>
    <st c="55672">pivot selection</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="55687">Worst case</st>**<st c="55698">:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1143.png)
    <st c="55701"><st c="55707">– Occurs when the pivot selection consistently results
    in the most unbalanced partitions (e.g., the smallest or</st> <st c="55819">largest
    element)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55835">Quick sort is a</st> <st c="55851">recursive algorithm characterized
    by the recurrence relation</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1144.png)<st
    c="55913"><st c="55933">. In each recursion step, quick sort divides the problem
    into two nearly equal sub-problems, leading to the relation</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1145.png)<st
    c="56050"><st c="56069">, with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1146.png)<st
    c="56076"><st c="56083">. The dividing and merging operations occur in linear
    time, represented by</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1147.png)<st
    c="56158"><st c="56159">. To understand the time complexity, we can analyze it
    in the</st> <st c="56221">following scenarios.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56241">For the space complexity, we need to consider the auxiliary or
    temporary space required to execute quick sort.</st> <st c="56353">Quick sort
    requires additional space for the recursion stack.</st> <st c="56415">In the average
    case, the stack depth is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1148.png)<st
    c="56455"><st c="56464">. However, in the worst case (e.g., unbalanced partitions),
    the stack depth can</st> <st c="56544">be</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1149.png)<st
    c="56547"><st c="56548">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56549">In summary, the performance of quick sort is significantly influenced
    by the choice of pivot and partitioning method.</st> <st c="56668">Poor pivot
    selection can result in a worst-case time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>²</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1150.png)<st
    c="56735"><st c="56736">, while the average-case performance is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1151.png)<st
    c="56776"><st c="56785">. Techniques such as random pivot selection or the median-of-three
    method can help mitigate the risk of poor pivot selection.</st> <st c="56911">Although
    quick sort is not a stable sorting algorithm, it is in-place and requires</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1152.png)
    <st c="56994"><st c="57003">auxiliary space for the recursion stack in the average
    case.</st> <st c="57064">Its efficiency and simplicity make quick sort a popular
    choice for sorting large datasets in</st> <st c="57157">various applications.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57178">All the sorting algorithms we’ve discussed so far, whether recursive
    or non-recursive, have been comparison-based.</st> <st c="57294">Now, we turn
    to another significant topic in sorting algorithms – non-comparison-based methods,
    which can achieve sorting in</st> <st c="57419">linear time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57431">Non-comparison-based sorting</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="57460">We have noted</st> <st c="57475">that all comparison-based sorting
    algorithms have a lower-bound time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1153.png)<st
    c="57558"><st c="57567">, which means no comparison-based algorithm can achieve
    better performance than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math>](img/1154.png)
    <st c="57647"><st c="57653">in the general case.</st> <st c="57674">However, there
    are sorting algorithms that do not depend on comparisons.</st> <st c="57747">These
    non-comparison-based algorithms leverage certain assumptions or information about
    the data to achieve</st> <st c="57855">better performance.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="57874">Unlike</st> <st c="57881">comparison-based algorithms, non-comparison-based
    algorithms can achieve a lower bound as efficiently as linear time.</st> <st c="58000">This
    remarkable efficiency is why they are sometimes referred to as linear-time sorting
    algorithms.</st> <st c="58100">By making use of specific properties of the data,
    such as a limited range of integer values or the distribution of digits, these
    algorithms can bypass the comparison limit and sort much faster under the right
    conditions.</st> <st c="58321">In this section, we will explore three well-known
    non-comparison-based sorting algorithms: counting sort, Radix sort, and</st> <st
    c="58443">bucket sort.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58455">Counting sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="58469">Counting sort</st> <st c="58484">is the</st> <st c="58490">first
    non-comparison-based sorting algorithm we will discuss in this section.</st> <st
    c="58569">It sorts a collection of elements in an array by counting the frequency
    of each distinct element in the input array.</st> <st c="58686">This frequency
    count is then used to determine the correct position of each element in the sorted
    output.</st> <st c="58792">As a result, no comparison operations are involved
    in this sorting process.</st> <st c="58868">Counting sort is particularly effective
    for sorting integers within a specific range and is known for its linear time
    complexity, making it highly efficient under the right conditions.</st> <st c="59053">Unlike
    other sorting algorithms, counting sort does not perform comparisons between elements,
    thus bypassing the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1155.png)
    <st c="59166"><st c="59175">lower bound for comparison-based sorts.</st> <st c="59215">Let’s
    demonstrate the counting sort algorithm step by step with</st> <st c="59279">an
    example.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59290">Counting sort is an efficient algorithm with a time complexity
    of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1156.png)<st
    c="59357"><st c="59363">. It is also a stable sorting method with minimal additional
    memory usage.</st> <st c="59438">Although it requires extra space proportional
    to the range of input values, it maintains linear space complexity.</st> <st c="59552">Due
    to its linear time complexity, counting sort is widely used for sorting large
    datasets with a limited range of elements.</st> <st c="59677">Its simplicity and
    efficiency under the right conditions make it a valuable tool for</st> <st c="59762">algorithm
    designers.</st> <st c="59783">Let’s explain the counting sort algorithm in the</st>
    <st c="59832">following example.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="59850">Example 6.7</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59862">Let’s illustrate the operation of counting sort with an array
    of six random numbers—[</st>`<st c="59948">4, 2, 2, 8,</st>` `<st c="59961">3,
    3</st>`<st c="59965">]:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59968">Determine</st> <st c="59979">the range:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59989">Find the</st> <st c="59998">maximum element (</st>**<st c="60016">8</st>**<st
    c="60018">) and the minimum</st> <st c="60036">element (</st>**<st c="60045">2</st>**<st
    c="60047">)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60048">Create a count array with size</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>8</mn><mo>−</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>7</mn></mrow></mrow></math>](img/1157.png)<st
    c="60079"><st c="60080">, initialized</st> <st c="60094">to</st> **<st c="60097">0</st>**</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60098">Count occurrences:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60116">Count each element’s occurrences and store them in the</st> <st
    c="60172">count array</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60183">Count array:</st> **<st c="60197">[2, 2, 1, 0, 0,</st>** **<st
    c="60213">0, 1]</st>**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60218">This corresponds to elements</st> **<st c="60248">2, 3, 4, 5,
    6,</st>** **<st c="60263">7, 8</st>**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60267">Cumulative count:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60285">Modify the count array by adding the count of the previous element
    to each element.</st> <st c="60370">This helps in determining the positions</st>
    <st c="60410">of elements.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60422">Cumulative count array:</st> **<st c="60447">[2, 4, 5, 5, 5,</st>**
    **<st c="60463">5, 6]</st>**<st c="60468">.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60469">Build the</st> <st c="60480">output array:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60493">Place each element in its correct position in the output array
    based on the cumulative count.</st> <st c="60588">We start from the last element
    down to the</st> <st c="60631">first element.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="60645">Table 6.7</st>* <st c="60655">illustrates the step-by-step process
    of counting sort for the array [</st>`<st c="60725">4, 2, 2, 8,</st>` `<st c="60738">3,
    3</st>`<st c="60742">]:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="60745">Element</st>** **<st c="60754">in array</st>** | **<st c="60762">Cumulative</st>**
    **<st c="60774">count array</st>** | **<st c="60785">Output array</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="60798">3</st> | <st c="60800">2, 3, 5, 5, 5,</st> <st c="60815">5,
    6</st> | <st c="60819">0, 0, 0, 3,</st> <st c="60832">0, 0</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="60836">3</st> | <st c="60838">2, 2, 5, 5, 5,</st> <st c="60853">5,
    6</st> | <st c="60857">0, 0, 3, 3,</st> <st c="60870">0, 0</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="60874">8</st> | <st c="60876">2, 2, 5, 5, 5,</st> <st c="60891">5,
    5</st> | <st c="60895">0, 0, 3, 3,</st> <st c="60908">0, 8</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="60912">2</st> | <st c="60914">1, 2, 5, 5, 5,</st> <st c="60929">5,
    5</st> | <st c="60933">0, 2, 3, 3,</st> <st c="60946">0, 8</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="60950">2</st> | <st c="60952">0, 2, 5, 5, 5,</st> <st c="60967">5,
    5</st> | <st c="60971">2, 2, 3, 3,</st> <st c="60984">0, 8</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="60988">4</st> | <st c="60990">0, 2, 4, 5, 5,</st> <st c="61005">5,
    5</st> | <st c="61009">2, 2, 3, 3,</st> <st c="61022">4, 8</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="61026">Table 6.7: Demonstrating an example of counting sort in operation</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61092">The following is</st> <st c="61109">a simple Python implementation
    of the counting</st> <st c="61157">sort algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="61911">The</st> `<st c="61916">counting_sort</st>` <st c="61929">algorithm</st>
    <st c="61940">is quite simple.</st> <st c="61957">The first two loops (</st>`<st
    c="61978">for i in range(1, len(count)):</st>` <st c="62009">and</st> `<st c="62014">for
    i in range(1, len(count)):</st>`<st c="62044">) build a cumulative count array.</st>
    <st c="62079">This array is then used in the third loop (</st>`<st c="62122">for
    k in reversed(a):</st>`<st c="62144">) to construct the</st> <st c="62164">sorted
    array.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62177">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="62198">The loop invariant in</st> <st c="62220">counting sort states
    that after processing each element, the cumulative</st> `<st c="62293">count</st>`
    <st c="62298">array correctly reflects the number of elements less than or equal
    to each value in the array, and the output array contains elements in sorted order
    up to the current index.</st> <st c="62474">We need to evaluate three conditions
    for the</st> <st c="62519">algorithm’s correctness:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="62543">Initialization</st>**<st c="62558">: Before any elements are
    processed, the</st> **<st c="62600">count</st>** <st c="62605">array is initialized
    to 0, and the output array is empty.</st> <st c="62664">The invariant</st> <st
    c="62678">trivially holds.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="62694">Maintenance</st>**<st c="62706">: As each element is processed,
    the cumulative</st> **<st c="62754">count</st>** <st c="62759">array is updated
    to reflect the correct count of elements.</st> <st c="62819">During the construction
    of the output array, elements are placed in their correct positions based on the
    cumulative counts, ensuring that the sorted order</st> <st c="62974">is maintained.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="62988">Termination</st>**<st c="63000">: The algorithm terminates
    after all elements have been processed and placed in the output array.</st> <st
    c="63099">At this point, the invariant guarantees that the output array is sorted,
    and the cumulative</st> **<st c="63191">count</st>** <st c="63196">array accurately
    reflects the positions</st> <st c="63237">of elements.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="63249">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="63269">Counting sort</st> <st c="63284">has a linear time complexity
    that is influenced by both the size of the array (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1158.png)<st
    c="63363"><st c="63365">) and the range of the input values</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1159.png)
    <st c="63401"><st c="63402">(where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mo>-</mml:mo><mml:mtext>min</mml:mtext><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1160.png)<st
    c="63410"><st c="63425">).</st> <st c="63428">Let’s analyze the time complexity
    of counting sort in</st> <st c="63482">three scenarios:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="63498">Best case</st>**<st c="63508">: In the best-case scenario,
    counting sort iterates through the input array to compute the frequency of each
    element (</st>**<st c="63627">count</st>**<st c="63633">), then iterates through
    the</st> **<st c="63663">count</st>** <st c="63668">array to calculate cumulative
    counts, and finally iterates through the input array again to place elements in
    their correct positions in the output array.</st> <st c="63824">This process involves</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="63846"><st c="63847">time to count elements,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1162.png)
    <st c="63872"><st c="63873">time to compute cumulative counts, and</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1163.png)
    <st c="63913"><st c="63914">time to build the output array, resulting in a total
    time complexity</st> <st c="63984">of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1051.png)<st
    c="63987"><st c="63993">.</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="63994">Average case</st>**<st c="64007">: The average-case time complexity
    of counting sort remains</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1165.png)
    <st c="64068"><st c="64074">because the steps involved (counting elements, computing
    cumulative counts, and building the output array) are consistent regardless of
    the initial order or distribution of elements within the range.</st> <st c="64274">Each
    element in the input array is processed a constant number</st> <st c="64337">of
    times.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="64346">Worst case</st>**<st c="64357">: In the worst-case scenario,
    counting sort still performs with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1166.png)
    <st c="64422"><st c="64428">time complexity.</st> <st c="64445">The worst case
    occurs when the range of input values is large compared to the size of the input
    array.</st> <st c="64548">Despite this, the operations of counting, computing
    cumulative counts, and placing elements in the output array are performed in linear
    time relative to the number of elements and the range</st> <st c="64738">of values.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="64748">Now, we need to estimate the space complexity of counting sort.</st>
    <st c="64813">Counting sort requires additional space to store both the</st> `<st
    c="64871">count</st>` <st c="64876">array and the output array (</st>`<st c="64905">temp</st>`<st
    c="64910">), leading to an auxiliary space complexity of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1156.png)<st
    c="64958"><st c="64964">. Let’s look at the auxiliary space we need in counting
    sort.</st> <st c="65026">First is the count array, which is used to store the
    frequency of each element within the range</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfenced
    open="[" close="]"><mrow><mtext>min</mtext><mo>,</mo><mtext>max</mtext></mrow></mfenced></mrow></math>](img/1168.png)<st
    c="65122"><st c="65133">. The size of the</st> `<st c="65151">count</st>` <st
    c="65156">array is proportional to the range of input values, which is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1169.png)<st
    c="65218"><st c="65219">. The second auxiliary memory space is the output array.</st>
    <st c="65276">An output array (</st>`<st c="65293">temp</st>`<st c="65298">) of
    the same size as the input array is used to store the sorted elements.</st> <st
    c="65375">This requires</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="65389"><st c="65390">additional space.</st> <st c="65409">Then, the total
    auxiliary space required by counting sort is the sum of the space for the count
    array and the output array, resulting</st> <st c="65543">in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1051.png)<st
    c="65546"><st c="65552">.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65553">Counting sort is an efficient linear time sorting algorithm,
    but it has a major limitation: its efficiency is</st> <st c="65664">highly dependent
    on the range of elements in the array to be sorted.</st> <st c="65733">Additionally,
    counting sort is limited to integer numerical data.</st> <st c="65799">In the
    next sub-section, we will discuss Radix sort, which can address some of the limitations
    inherent in</st> <st c="65906">counting sort.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65920">Radix sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**<st c="65931">Radix sort</st>**<st c="65942">, another</st> <st c="65952">non-comparative</st>
    <st c="65967">sorting technique, sorts elements by sequentially processing individual
    digits or characters.</st> <st c="66062">It leverages the concept that sorting
    can be achieved one position at a time, beginning with the least significant and
    progressing toward the most significant.</st> <st c="66222">By employing a stable
    sorting algorithm such as counting sort for each position, Radix sort maintains
    the original order of elements, sharing the same digit or character.</st> <st
    c="66393">This approach renders Radix sort highly efficient for datasets comprised
    of numbers or strings with a fixed or</st> <st c="66504">limited length.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66519">Radix sort is particularly effective for sorting large numbers
    of integers or strings with a fixed number of digits or characters.</st> <st c="66651">The
    algorithm leverages counting sort to maintain stability and achieve linear time
    complexity for each digit.</st> <st c="66762">While Radix sort requires additional
    space for the output and count arrays, its overall efficiency makes it an excellent
    choice for specific types of data where the number of digits or characters is
    known and limited.</st> <st c="66980">Understanding Radix sort and its mechanisms
    can provide significant performance advantages</st> <st c="67070">in</st> <st
    c="67074">appropriate scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67096">Besides its linear time complexity and stability, the Radix sort
    algorithm offers several other advantages, including</st> <st c="67215">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="67229">Suitable for large data</st>**<st c="67253">: Radix sort is
    especially effective for sorting large datasets where the range of input values
    is not significantly larger than the number of elements.</st> <st c="67407">It
    handles large amounts of data well, particularly when the keys are integers or
    strings of a</st> <st c="67502">fixed length.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="67515">Predictable performance</st>**<st c="67539">: Radix sort consistently
    performs well, with no worst-case degradation, as seen in quick sort.</st> <st
    c="67636">Its time complexity is predictable and does not depend on the input
    data’s</st> <st c="67711">initial order.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="67725">Extensibility</st>**<st c="67739">: Radix sort can be easily
    adapted to sort data types other than integers, such as strings</st> <st c="67831">or
    other sequences, by using different bases or treating each character as</st> <st
    c="67906">a “digit.”</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="67916">Let’s demonstrate the Radix sort algorithm step by step with</st>
    <st c="67978">an example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="67989">Example 6.8</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68001">Let’s illustrate</st> <st c="68018">the operation of Radix sort
    with an array of six random numbers—[</st>`<st c="68084">170, 45, 75, 90,</st>`
    `<st c="68102">802, 24</st>`<st c="68109">]:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68112">Sort the original array by the least significant digit (</st><st
    c="68169">1’s place):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="68181">Apply counting sort to the least significant digit: [</st>`<st
    c="68235">170, 90, 802, 24,</st>` `<st c="68254">45, 75</st>`<st c="68260">]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="68262">Sort by second least significant digit (</st><st c="68302">10’s
    place):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="68315">Apply counting sort to the second least significant digit: [</st>`<st
    c="68376">802, 24, 45, 75,</st>` `<st c="68394">170, 90</st>`<st c="68401">]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="68403">Sort by most significant digit (</st><st c="68435">100’s place):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="68449">Apply counting sort to the most significant digit: [</st>`<st
    c="68502">24, 45, 75, 90,</st>` `<st c="68519">170, 802</st>`<st c="68527">]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="68529">Now the array is sorted: [</st>`<st c="68555">24, 45, 75, 90,</st>`
    `<st c="68572">170, 802</st>`<st c="68580">].</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68583">Here is the Python implementation of the Radix</st> <st c="68631">sort
    algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="69082">In the</st> <st c="69089">preceding Radix sort algorithm implementation,
    the</st> `<st c="69141">radix_sort(a)</st>` <st c="69154">function takes the input
    array (</st>`<st c="69187">a</st>`<st c="69189">) and applies counting sort (</st>`<st
    c="69218">count_sort(a, e)</st>`<st c="69235">), starting from the least significant
    digit.</st> <st c="69282">It sorts the data by each digit in the appropriate</st>
    <st c="69333">place (</st>`<st c="69340">e</st>`<st c="69342">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69344">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="69365">The</st> <st c="69369">loop invariant is defined in Radix sort
    as after sorting by each digit (starting from the least significant to the most
    significant), the array is partially sorted with respect to that digit, while
    maintaining the relative order of elements with the same digit.</st> <st c="69632">We
    need to evaluate three conditions for the</st> <st c="69677">algorithm’s correctness:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="69701">Initialization</st>**<st c="69716">: Before any digits are
    processed, the array is unsorted.</st> <st c="69775">The invariant trivially holds
    as there is no</st> <st c="69820">partial sorting.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="69836">Maintenance</st>**<st c="69848">: During each iteration, counting
    sort is applied to sort elements based on the current digit.</st> <st c="69944">Since
    counting sort is stable, it maintains the relative order of elements with the
    same digit.</st> <st c="70040">This ensures that after each pass, the array is
    partially sorted with respect to</st> <st c="70121">that digit.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="70132">Termination</st>**<st c="70144">: The algorithm terminates
    after sorting by the most significant digit.</st> <st c="70217">At this point,
    the invariant guarantees that the array is fully sorted because all</st> <st c="70299">digits
    have been processed in order</st> <st c="70336">of significance.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70352">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="70372">Radix sort</st> <st c="70384">has a time complexity that depends
    on the number of digits in the largest number,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)<st
    c="70466"><st c="70467">, the number of elements,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="70493"><st c="70494">, and the range of digit values,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1174.png)<st
    c="70527"><st c="70528">. Let’s analyze the time complexity of Radix sort in</st>
    <st c="70581">three scenarios:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="70597">Best case</st>**<st c="70607">: In the best case, Radix sort
    processes each digit of the numbers in the array.</st> <st c="70689">For each
    digit, it uses counting sort, which operates in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1175.png)
    <st c="70746"><st c="70754">time.</st> <st c="70760">Since there are</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="70776"><st c="70777">digits, the overall time complexity</st> <st c="70814">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>⋅</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1177.png)<st
    c="70817"><st c="70827">.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="70828">Average case</st>**<st c="70841">: The average-case time complexity
    of Radix sort remains</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>⋅</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1177.png)
    <st c="70899"><st c="70909">because the steps involved (sorting by each digit
    using counting sort) are consistently executed for each digit, regardless of the
    distribution of the</st> <st c="71060">input values.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="71073">Worst case</st>**<st c="71084">: In the worst case, Radix sort
    still performs with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>⋅</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1179.png)
    <st c="71137"><st c="71147">time complexity.</st> <st c="71164">This is because
    each digit is processed in linear time by counting sort, and the process is repeated</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="71265"><st c="71266">times for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="71277"><st c="71278">digits.</st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71285">Speaking about the space complexity of Radix sort, it requires
    additional space to store the count array and the output array used by counting
    sort, resulting in an auxiliary space complexity</st> <st c="71478">of</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1051.png)<st
    c="71481"><st c="71487">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71488">Radix sort is more efficient when the elements of the array are
    spread out over a wide range, meaning the values are sparse.</st> <st c="71614">If
    the elements are densely packed within the range, an alternative approach is bucket
    sort, which will be discussed in the</st> <st c="71738">next sub-section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71755">Bucket sort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="71767">The</st> <st c="71771">final non-comparison-based sorting</st>
    <st c="71806">algorithm we will examine is bucket sort.</st> <st c="71849">This
    approach involves distributing the elements of an array into multiple containers,
    known as “buckets,” each associated with a specific range of values.</st> <st
    c="72005">The elements within each bucket are then sorted independently, often
    using another sorting algorithm, and subsequently combined to produce the fully
    sorted array.</st> <st c="72168">Bucket sort demonstrates exceptional efficiency
    when the input data is evenly spread across a known range.</st> <st c="72275">It
    capitalizes on the divide-and-conquer strategy, simplifying the sorting task by
    breaking it down into smaller, more</st> <st c="72394">manageable sub-problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72418">Bucket sort</st> <st c="72430">is particularly effective for sorting
    large datasets with uniformly distributed values, providing significant performance
    advantages over comparison-based sorting algorithms in these scenarios.</st> <st
    c="72625">Understanding Bucket sort and its mechanisms can help optimize sorting
    performance in suitable applications.</st> <st c="72734">Let’s demonstrate the
    bucket sort algorithm step by step with</st> <st c="72796">an example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="72807">Example 6.9</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72819">Let’s</st> <st c="72825">illustrate the operation of bucket sort
    with an array of six random numbers— [</st>`<st c="72904">0.78, 0.17, 0.39, 0.26,</st>`
    `<st c="72929">0.72, 0.94</st>`<st c="72939">]:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72942">Distribute elements</st> <st c="72963">into buckets:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="72976">Create an empty list</st> <st c="72998">of buckets.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73009">Distribute each element into the appropriate bucket based on</st>
    <st c="73071">its value.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73081">Buckets:</st> `<st c="73091">[[0.17, 0.26], [0.39], [0.72,</st>`
    `<st c="73121">0.78], [0.94]]</st>`<st c="73135">.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73136">Sort</st> <st c="73142">each bucket:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="73154">Sort the elements within each bucket.</st> <st c="73193">This
    can be done using another sorting algorithm such as</st> <st c="73250">insertion
    sort.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73265">Sorted buckets:</st> `<st c="73282">[[0.17, 0.26], [0.39], [0.72,</st>`
    `<st c="73312">0.78], [0.94]]</st>`<st c="73326">.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73327">Concatenate</st> <st c="73340">sorted buckets:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="73355">Concatenate all the sorted buckets to form the final</st> <st
    c="73409">sorted array:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="73422">[0.17, 0.26, 0.39, 0.72,</st>` `<st c="73448">0.78, 0.94]</st>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73459">The array is</st> <st c="73473">now sorted.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73484">The following</st> <st c="73498">is a simple Python implementation
    of the bucket</st> <st c="73547">sort algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="73803">The algorithm is straightforward.</st> <st c="73838">Initially,
    the buckets are set up, and the elements of the array,</st> `<st c="73904">a</st>`<st
    c="73905">, are distributed into these buckets (</st>`<st c="73943">for I in a:</st>`<st
    c="73955">).</st> <st c="73959">Each bucket is then sorted using insertion sort
    and concatenated (</st>`<st c="74025">for b in buckts:</st>`<st c="74042">).</st>
    <st c="74046">Finally, the sorted buckets are</st> <st c="74078">concatenated
    together.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74100">Proof of correctness</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="74121">The</st> <st c="74125">loop invariant in bucket sort is defined
    as at the start of each iteration, the elements in each bucket are partially sorted
    with respect to their position within the bucket.</st> <st c="74301">We need to
    evaluate three conditions for the</st> <st c="74346">algorithm’s correctness:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="74370">Initialization</st>**<st c="74385">: Before any elements are
    processed, the buckets are empty.</st> <st c="74446">The invariant trivially holds
    as there is no</st> <st c="74491">partial sorting.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74507">Maintenance</st>**<st c="74519">: During each iteration, elements
    are distributed into buckets based on their values.</st> <st c="74606">Sorting
    each bucket individually ensures that the elements within each bucket are sorted.</st>
    <st c="74696">This maintains</st> <st c="74711">the invariant.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74725">Termination</st>**<st c="74737">: The algorithm terminates
    after all buckets have been sorted and concatenated.</st> <st c="74818">At</st>
    <st c="74821">this point, the invariant guarantees that the entire array is sorted
    because each bucket is sorted, and the buckets are concatenated</st> <st c="74954">in
    order.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74963">Complexity analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="74983">Bucket sort</st> <st c="74995">has a time complexity that depends
    on both the number of elements,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="75063"><st c="75112">, and the number of buckets,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1184.png)<st
    c="75141"><st c="75142">. The distribution of elements among the buckets also
    plays a crucial role in determining the overall time complexity.</st> <st c="75261">Let’s
    examine the time complexity of Radix sort in the following</st> <st c="75326">three
    scenarios:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="75342">Best case</st>**<st c="75352">: In the best-case scenario,
    the elements are uniformly distributed across the buckets, and each bucket contains
    a roughly equal number of elements.</st> <st c="75502">Sorting each bucket individually
    takes constant time if an efficient sorting algorithm such as insertion sort is
    used within the buckets.</st> <st c="75640">As a result, the overall time complexity</st>
    <st c="75681">is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1051.png)<st
    c="75684"><st c="75690">.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="75691">Average case</st>**<st c="75704">: On average, the time complexity
    of bucket sort remains</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1186.png)
    <st c="75762"><st c="75771">as long as the elements are evenly distributed, and
    the number of buckets,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)<st
    c="75846"><st c="75847">, is proportional to the number of elements,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="75892"><st c="75893">. Each element is placed into a bucket in</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)
    <st c="75935"><st c="75936">time, and each bucket is sorted individually in linear
    time relative to the number of elements</st> <st c="76032">it contains.</st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="76044">Worst case</st>**<st c="76055">: In the worst-case scenario,
    if all elements are placed into a single bucket, the algorithm’s time complexity
    degrades to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1190.png)<st
    c="76179"><st c="76185">. This is because the entire array would need to be sorted
    within one bucket, resulting in quadratic time complexity when using a sorting
    algorithm such as insertion sort within</st> <st c="76363">that bucket.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="76375">For the space complexity of bucket sort, we know that it requires
    additional space to store the buckets and the output array, leading to an auxiliary
    space complexity of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1165.png)<st
    c="76546"><st c="76552">. The auxiliary space has two components: the first is
    the buckets.</st> <st c="76620">The buckets are</st> <st c="76636">used to store
    elements within specific value ranges.</st> <st c="76689">The number of buckets,</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1174.png)<st
    c="76712"><st c="76713">, is typically chosen based on the range and distribution
    of input values.</st> <st c="76788">The second auxiliary space is the output array.</st>
    <st c="76836">An output array of the same size as the input array is used to store
    the sorted elements temporarily.</st> <st c="76938">This requires</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="76952"><st c="76953">additional space.</st> <st c="76972">Then, the total
    auxiliary space required by bucket sort is the sum of the space needed for the
    buckets and the output array, resulting</st> <st c="77107">in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1051.png)<st
    c="77110"><st c="77116">.</st></st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77117">This concludes our discussion on non-comparison sorting algorithms.</st>
    <st c="77186">These algorithms provide better time complexities compared to comparison-based
    sorts but come with certain limitations.</st> <st c="77306">They are restricted
    to specific data types and rely on assumptions about the data, which can narrow
    their range</st> <st c="77418">of applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77434">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="77442">This chapter provided a comprehensive exploration of various sorting
    algorithms, highlighting their underlying principles, efficiencies, and practical
    implementations.</st> <st c="77611">The chapter began by discussing the fundamental
    properties that differentiate sorting algorithms, such as comparison versus non-comparison-based
    methods, stability, adaptability, and memory usage.</st> <st c="77808">These properties
    were crucial for understanding why certain algorithms are more suitable for specific
    types of data and applications.</st> <st c="77942">The chapter emphasized the
    importance of time complexity, particularly noting that comparison-based algorithms
    have a lower-bound complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Ω</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1155.png)<st
    c="78086"><st c="78095">, while non-comparison-based algorithms can achieve linear
    time complexity under the</st> <st c="78180">right conditions.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="78197">The chapter then discussed specific sorting algorithms, starting
    with the iterative methods: bubble sort, selection sort, and insertion sort.</st>
    <st c="78340">These algorithms, despite their simplicity and ease of implementation,
    were shown to be inefficient for large datasets due to their</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1068.png)
    <st c="78472"><st c="78478">time complexity.</st> <st c="78495">The explanations
    included detailed step-by-step operations, code implementations, and proofs of
    correctness using loop invariants.</st> <st c="78626">Each algorithm’s unique
    characteristics, such as stability and space efficiency, were discussed, providing
    a clear understanding of their strengths</st> <st c="78774">and limitations.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78790">Finally, the chapter explored the more advanced recursive sorting
    algorithms, including merge sort and quick sort.</st> <st c="78906">These algorithms
    leveraged the divide-and-conquer strategy to achieve more efficient sorting with
    an average time complexity of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1197.png)<st
    c="79034"><st c="79045">. Merge sort’s consistent performance and stability were
    contrasted with quick sort’s potential for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1198.png)
    <st c="79145"><st c="79151">worst-case time complexity, which could be mitigated
    by good pivot selection strategies.</st> <st c="79240">Additionally, the chapter
    touched on non-comparison-based algorithms such as counting sort, Radix sort,
    and bucket sort, explaining how they achieve linear time complexity by utilizing
    specific data properties.</st> <st c="79451">The chapter concluded by reinforcing
    the importance of choosing the right sorting algorithm based on the dataset characteristics
    and the specific requirements of</st> <st c="79613">the application.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79629">In the next chapter, we focus on another core problem in algorithm
    design—searching.</st> <st c="79715">Then,</st> [*<st c="79721">Chapter 8</st>*](B22248_08.xhtml#_idTextAnchor118)
    <st c="79730">examines the relationship between sorting and searching, uncovering
    fascinating patterns</st> <st c="79820">and connections.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79836">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="79867">Introduction to Algorithms</st>*<st c="79894">. By Thomas H.</st>
    <st c="79909">Cormen, Charles E.</st> <st c="79928">Leiserson, Ronald L.</st>
    <st c="79949">Rivest, and Clifford Stein.</st> <st c="79977">Fourth Edition.</st>
    <st c="79993">MIT</st> <st c="79997">Press.</st> <st c="80004">2022.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80009">Chapter 2,</st>* *<st c="80021">Getting Started</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80036">Chapter 4, Divide-and-Conquer (includes</st>* *<st c="80077">merge
    sort)</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80088">Chapter</st>* *<st c="80097">7, Quicksort</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80109">Chapter 8,Sorting in</st>* *<st c="80131">Linear Time</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80142">Chapter 9, Medians and</st>* *<st c="80166">Order Statistics</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80182">Algorithms</st>*<st c="80193">. By R.</st> <st c="80201">Sedgewick
    and K.</st> <st c="80218">Wayne.</st> <st c="80225">Fourth Edition.</st> <st c="80241">Addison-Wesley.</st>
    <st c="80257">2011.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80262">Chapter 2:</st>* *<st c="80274">Elementary Sorts</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80290">The Art of Computer Programming, Volume 3: Sorting and Searching</st>*<st
    c="80355">. By Donald</st> <st c="80367">E.</st> <st c="80370">Knuth.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80376">Chapter</st>* *<st c="80385">5, Sorting</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80395">Data Structures and Algorithm Analysis in C++</st>*<st c="80441">.
    By Mark</st> <st c="80451">Allen Weiss</st>*<st c="80462">.</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80463">Chapter</st>* *<st c="80472">7, Sorting</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80482">Algorithm Design Manual</st>*<st c="80506">. By Steven</st>
    <st c="80518">S.</st> <st c="80521">Skiena.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="80528">Chapter 4, Sorting</st>* *<st c="80548">and Searching</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
