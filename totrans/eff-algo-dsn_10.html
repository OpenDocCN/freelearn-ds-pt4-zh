<html><head></head><body>
		<div id="_idContainer1448" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-95" class="chapter-number"><a id="_idTextAnchor103" class="pcalibre pcalibre1 calibre6"/><st c="0">7</st></h1>
			<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor104" class="pcalibre pcalibre1 calibre6"/><st c="2">Search Algorithms</st></h1>
			<p class="calibre3"><st c="19">In the data and information processing domain, search and information retrieval play a very crucial role. </st><st c="126">The efficiency and accuracy of search algorithms directly impact the effectiveness of various applications, from database management systems to search engines. </st><st c="286">This chapter discusses the critical importance of search algorithms, clarifying their fundamental properties through a series </st><span><st c="412">of examples.</st></span></p>
			<p class="calibre3"><st c="424">Search algorithms are designed to optimize the retrieval process, making it faster and more efficient. </st><st c="528">A crucial aspect of this optimization is sorting, which organizes data in a manner that facilitates rapid search operations. </st><st c="653">The interplay between sorting and searching is evident in numerous applications where sorted data allows for more sophisticated and quicker search techniques. </st><st c="812">We will explore this essential relationship between sorting and searching in the next chapter. </st><st c="907">However, when we separate the concept of search from sorting, we are often left with the basic sequential search. </st><st c="1021">Sequential search operates in linear time, scanning each element one by one until the desired result is found. </st><st c="1132">This method, while straightforward, is not always the most efficient, especially for </st><span><st c="1217">large datasets.</st></span></p>
			<p class="calibre3"><st c="1232">To address the limitations of sequential search, we can leverage data assumptions to devise more advanced techniques such as hashing. </st><st c="1367">Hashing transforms data into a fixed-size value or hash code (hash value), allowing for constant time search operations under ideal conditions. </st><st c="1511">This chapter explores these advanced techniques, illustrating how assumptions about data can significantly enhance search performance. </st><st c="1646">By employing hashing functions, we can achieve constant time complexity, drastically improving the efficiency of search operations in </st><span><st c="1780">many applications.</st></span></p>
			<p class="calibre3"><st c="1798">In this chapter, search algorithms are categorized into three primary groups: linear-time search algorithms, sub-linear (e.g., logarithmic time) search algorithms, and constant-time search algorithms that utilize hashing. </st><st c="2021">Each category is examined in detail, with a focus on its properties, use cases, and performance characteristics. </st><st c="2134">The chapter is structured </st><span><st c="2160">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="2171">Properties of </st><span><st c="2186">search algorithms</st></span></li>
				<li class="calibre13"><st c="2203">Linear-time and logarithmic </st><span><st c="2232">search algorithms</st></span></li>
				<li class="calibre13"><span><st c="2249">Hashing</st></span></li>
			</ul>
			<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor105" class="pcalibre pcalibre1 calibre6"/><st c="2257">Properties of search algorithms</st></h1>
			<p class="calibre3"><st c="2289">Before diving into search algorithms and their properties, it’s important to differentiate between two types of search in computer science: </st><strong class="bold"><st c="2430">algorithmic</st></strong><st c="2441"> search and search in </st><strong class="bold"><st c="2463">artificial intelligence</st></strong><st c="2486"> (</st><strong class="bold"><st c="2488">AI</st></strong><st c="2490">). </st><st c="2494">While these two types of </st><a id="_idIndexMarker400" class="pcalibre pcalibre1 calibre6"/><st c="2519">search share some similarities, they have distinct differences </st><span><st c="2582">and objectives.</st></span></p>
			<p class="calibre3"><st c="2597">The concept of </st><em class="italic"><st c="2613">search</st></em><st c="2619"> in algorithms and </st><em class="italic"><st c="2638">search</st></em><st c="2644"> in AI can</st><a id="_idIndexMarker401" class="pcalibre pcalibre1 calibre6"/><st c="2654"> differ significantly in terms of their goals, methodologies, and applications. </st><st c="2734">Here’s a comparison highlighting the </st><span><st c="2771">key differences.</st></span></p>
			<p class="calibre3"><st c="2787">Algorithmic search refers to the process of finding a specific element or set of elements within a data structure, such as an array, list, or tree. </st><st c="2936">The primary goal is to locate the desired element(s) as quickly as possible, often measured by time complexity (e.g., </st><img src="image/1199.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre919"/><st c="3054"/><st c="3055">, </st><img src="image/1200.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre920"/><st c="3057"/><st c="3066">). </st><st c="3069">On the other hand, the correctness of algorithmic search is to ensure the algorithm correctly identifies the presence or absence of the </st><span><st c="3205">target element.</st></span></p>
			<p class="calibre3"><st c="3220">We implement algorithmic search using one of the </st><span><st c="3270">following methods:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="3288">Linear search</st></strong><st c="3302">: Iterates</st><a id="_idIndexMarker402" class="pcalibre pcalibre1 calibre6"/><st c="3313"> through each element until the target is found or the end of the structure </st><span><st c="3389">is reached</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="3399">Binary search</st></strong><st c="3413">: Efficiently</st><a id="_idIndexMarker403" class="pcalibre pcalibre1 calibre6"/><st c="3427"> locates elements in sorted arrays by repeatedly dividing the search interval </st><span><st c="3505">in half</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="3512">Hashing</st></strong><st c="3520">: Uses </st><a id="_idIndexMarker404" class="pcalibre pcalibre1 calibre6"/><st c="3528">hash functions to map elements to specific positions for </st><span><st c="3585">quick access</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="3597">Tree traversal</st></strong><st c="3612">: Searches</st><a id="_idIndexMarker405" class="pcalibre pcalibre1 calibre6"/><st c="3623"> within tree structures, such as binary search trees, AVL trees, and </st><span><st c="3692">red-black trees</st></span></li>
			</ul>
			<p class="calibre3"><st c="3707">The major application of algorithmic search is in data retrieval, which is used in databases, filesystems, and general data </st><span><st c="3832">processing tasks.</st></span></p>
			<p class="calibre3"><st c="3849">On the other hand, we have </st><a id="_idIndexMarker406" class="pcalibre pcalibre1 calibre6"/><st c="3877">search algorithms in AI, or simply AI search. </st><st c="3923">AI search involves finding a sequence of actions or a path from an initial state to a goal state within a problem space. </st><st c="4044">It often deals with more complex and dynamic environments and has different objectives from algorithmic search. </st><st c="4156">The primary objective of AI search is problem-solving – finding a solution to a complex problem that may involve navigating through a large state space. </st><st c="4309">Additionally, AI search aims to find the best or most efficient solution among many possible options and must be capable of handling dynamic and uncertain environments where conditions and goals </st><span><st c="4504">may change.</st></span></p>
			<p class="calibre3"><st c="4515">AI search algorithms </st><a id="_idIndexMarker407" class="pcalibre pcalibre1 calibre6"/><st c="4537">are implemented with different </st><a id="_idIndexMarker408" class="pcalibre pcalibre1 calibre6"/><st c="4568">strategies depending on the problem type and our knowledge of the goal state. </st><st c="4646">Although these methods can be categorized in various ways, the most well-known AI search families are uninformed search and informed search. </st><st c="4787">Uninformed search techniques, such </st><a id="_idIndexMarker409" class="pcalibre pcalibre1 calibre6"/><st c="4822">as </st><strong class="bold"><st c="4825">breadth-first search</st></strong><st c="4845"> (</st><strong class="bold"><st c="4847">BFS</st></strong><st c="4850">) and </st><strong class="bold"><st c="4857">depth-first search</st></strong><st c="4875"> (</st><strong class="bold"><st c="4877">DFS</st></strong><st c="4880">), explore </st><a id="_idIndexMarker410" class="pcalibre pcalibre1 calibre6"/><st c="4892">the search space without specific knowledge about the goal. </st><st c="4952">In contrast, informed search techniques, such as </st><strong class="bold"><st c="5001">A* search</st></strong><st c="5010"> and </st><strong class="bold"><st c="5015">greedy search</st></strong><st c="5028">, use</st><a id="_idIndexMarker411" class="pcalibre pcalibre1 calibre6"/><st c="5033"> heuristics to guide the search</st><a id="_idIndexMarker412" class="pcalibre pcalibre1 calibre6"/><st c="5064"> process toward the goal more efficiently. </st><st c="5107">Heuristics provide an estimated cost to reach the goal, helping to prioritize paths that appear </st><span><st c="5203">more promising.</st></span></p>
			<p class="calibre3"><st c="5218">AI search has many applications. </st><st c="5252">For example, in robotics, search helps agents navigate and perform tasks in dynamic environments. </st><st c="5350">In game playing, AI agents search for optimal moves in games such as chess, Go, and </st><span><st c="5434">video games.</st></span></p>
			<p class="calibre3"><st c="5446">In conclusion, algorithmic search focuses on efficiently finding specific elements within structured data using well-defined procedures and data structures. </st><st c="5604">In contrast, AI search involves exploring large and often unstructured problem spaces to find optimal or feasible solutions to complex problems, using both uninformed and informed techniques, often incorporating heuristics and </st><span><st c="5831">learning methods.</st></span></p>
			<p class="calibre3"><st c="5848">In essence, while both types of search aim to find solutions, algorithmic search is typically more concerned with data retrieval and manipulation within well-defined constraints, whereas AI search addresses broader and more complex problem-solving scenarios, often requiring adaptability </st><span><st c="6137">and learning.</st></span></p>
			<p class="calibre3"><st c="6150">In this section, we introduce several properties to evaluate and compare different algorithmic search algorithms (in this chapter, we will use </st><em class="italic"><st c="6294">search</st></em><st c="6300"> to refer to algorithmic search). </st><st c="6334">These properties, in addition to time and space complexities, provide a baseline to understand the behavior and efficiency of search algorithms. </st><st c="6479">By considering these properties, we can</st><a id="_idIndexMarker413" class="pcalibre pcalibre1 calibre6"/><st c="6518"> choose the most suitable algorithm for a </st><span><st c="6560">given scenario:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="6575">Data structure requirement</st></strong><st c="6602">: Different search algorithms may require specific data structures to operate efficiently. </st><st c="6694">For example, binary search necessitates a sorted array to function correctly, whereas sequential search can work with any linear data structure, such as arrays or </st><span><st c="6857">l</st><a id="_idTextAnchor106" class="pcalibre pcalibre1 calibre6"/><st c="6858">inked lists.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="6870">Adaptability</st></strong><st c="6883">: Some search algorithms have the ability to adapt to the characteristics of the input data, thereby improving their performance. </st><st c="7014">For example, interpolation search adapts to the distribution of data and can perform significantly better than binary search on uniformly </st><span><st c="7152">distributed datasets.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7173">Implementation complexity</st></strong><st c="7199">: The complexity of implementing an algorithm is a practical consideration, especially in time-constrained situations. </st><st c="7319">Simpler algorithms such as sequential search are easy to implement and understand, while more complex algorithms such as balanced search trees (see </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="7467">Chapter 13</st></em></span></a><st c="7477">) or hashing require a deeper understanding of data structures and </st><span><st c="7545">algorithm design.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7562">Preprocessing requirements</st></strong><st c="7589">: Certain search algorithms require preprocessing of the data before they can be applied. </st><st c="7680">For example, binary search requires the data to be sorted, which adds to the overall time complexity. </st><st c="7782">Preprocessing steps can sometimes negate the benefits of a faster search time, especially if the data changes frequently and requires </st><span><st c="7916">constant re-sorting.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7936">Optimality</st></strong><st c="7947">: Some algorithms are considered optimal for specific scenarios based on their time complexity and performance characteristics. </st><st c="8076">Binary search, for instance, is </st><a id="_idIndexMarker414" class="pcalibre pcalibre1 calibre6"/><st c="8108">optimal for searching within a sorted array due to its logarithmic time complexity. </st><st c="8192">However, optimality can vary based on the context and specific requirements of the application. </st><st c="8288">An algorithm that is optimal in one scenario may not be the best choice in another if the underlying assumptions or </st><span><st c="8404">conditions change.</st></span></li>
			</ul>
			<p class="calibre3"><st c="8422">By examining these key characteristics – data structure requirements, adaptability, implementation complexity, preprocessing requirements, and optimality – we can make informed decisions about which search algorithms to use in different contexts. </st><st c="8670">This comprehensive understanding ensures that we select the most efficient and effective search techniques for our data </st><span><st c="8790">processing needs.</st></span></p>
			<p class="calibre3"><st c="8807">Among the </st><a id="_idIndexMarker415" class="pcalibre pcalibre1 calibre6"/><st c="8818">properties of search algorithms, time complexity stands out as the most critical factor. </st><st c="8907">The efficiency of a search algorithm is predominantly determined by its time complexity, which dictates how quickly an algorithm can locate an element within a dataset. </st><st c="9076">As a result, search algorithms are often classified according to their time complexities to facilitate a clear understanding of their performance under </st><span><st c="9228">different conditions.</st></span></p>
			<p class="calibre3"><st c="9249">In the upcoming sections, we will explore search algorithms categorized by their time complexities. </st><st c="9350">These categories provide a structured way to analyze and compare various </st><span><st c="9423">search techniques:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="9441">Linear-time search algorithms</st></strong><st c="9471">: These</st><a id="_idIndexMarker416" class="pcalibre pcalibre1 calibre6"/><st c="9479"> algorithms, such as the sequential search, operate in </st><img src="image/1201.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre921"/><st c="9534"/><st c="9535"> time, meaning the time</st><a id="_idIndexMarker417" class="pcalibre pcalibre1 calibre6"/><st c="9558"> required to find an element grows linearly with the size of the dataset. </st><st c="9632">We will explore scenarios where linear-time algorithms are suitable and their </st><span><st c="9710">implementation details.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="9733">Sub-linear time search algorithms</st></strong><st c="9767">: This category includes algorithms such as binary search, which</st><a id="_idIndexMarker418" class="pcalibre pcalibre1 calibre6"/><st c="9832"> operate in </st><img src="image/1202.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre922"/><st c="9844"/><st c="9853"> time. </st><st c="9859">Binary search is particularly efficient for sorted datasets and leverages the divide-and-conquer strategy to quickly narrow down the search space. </st><st c="10006">In </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="10009">Chapter 13</st></em></span></a><st c="10019">, we will discuss a search algorithm based on a specific data structure </st><a id="_idIndexMarker419" class="pcalibre pcalibre1 calibre6"/><st c="10091">called </st><strong class="bold"><st c="10098">binary search trees</st></strong><st c="10117"> (</st><strong class="bold"><st c="10119">BSTs</st></strong><st c="10123">). </st><st c="10127">BSTs maintain a sorted order of elements, allowing for efficient search, insertion, and </st><span><st c="10215">deletion operations.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="10235">Constant-time search algorithms</st></strong><st c="10267">: These</st><a id="_idIndexMarker420" class="pcalibre pcalibre1 calibre6"/><st c="10275"> algorithms aim to achieve </st><img src="image/1063.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre923"/><st c="10302"/><st c="10303"> time complexity, where the time</st><a id="_idIndexMarker421" class="pcalibre pcalibre1 calibre6"/><st c="10335"> required to find an element remains constant regardless of the dataset size. </st><st c="10413">Hashing </st><a id="_idIndexMarker422" class="pcalibre pcalibre1 calibre6"/><st c="10421">is a primary technique used to achieve constant-time search operations. </st><st c="10493">We will examine how hashing functions work, their implementation, and the conditions under which they provide </st><span><st c="10603">optimal performance.</st></span></li>
			</ul>
			<p class="calibre3"><st c="10623">By understanding and categorizing search algorithms based on their time complexities, we can better appreciate their strengths and limitations. </st><st c="10768">This structured approach allows us to select the most appropriate algorithm for a given application, ensuring efficient and effective </st><span><st c="10902">data retrieval.</st></span></p>
			<h1 id="_idParaDest-98" class="calibre5"><a id="_idTextAnchor107" class="pcalibre pcalibre1 calibre6"/><st c="10917">Linear-time and logarithmic search algorithms</st></h1>
			<p class="calibre3"><st c="10963">In the</st><a id="_idIndexMarker423" class="pcalibre pcalibre1 calibre6"/><st c="10970"> study of search algorithms, understanding both linear and sub-linear search methods is crucial for selecting the most</st><a id="_idIndexMarker424" class="pcalibre pcalibre1 calibre6"/><st c="11088"> efficient approach for a given problem. </st><st c="11129">Linear search, the most straightforward method, involves checking each element in a dataset sequentially until the target is found or the end of the dataset is reached. </st><st c="11298">While simple and effective for small or unsorted datasets, its </st><img src="image/1204.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre924"/><st c="11361"/><st c="11362"> time complexity makes it impractical for large datasets. </st><st c="11420">In contrast, sub-linear search algorithms, such as binary search and jump search, offer more efficient solutions with time complexities better than </st><img src="image/1205.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre925"/><st c="11568"/><st c="11569">, typically exploiting the properties of sorted data to significantly reduce the number of comparisons needed. </st><st c="11680">By comparing these two classes of algorithms, we can appreciate the advancements in search techniques and their applications in optimizing data </st><span><st c="11824">retrieval processes.</st></span></p>
			<h2 id="_idParaDest-99" class="calibre5"><a id="_idTextAnchor108" class="pcalibre pcalibre1 calibre6"/><st c="11844">Linear or sequential search</st></h2>
			<p class="calibre3"><st c="11872">A </st><a id="_idIndexMarker425" class="pcalibre pcalibre1 calibre6"/><st c="11875">general search algorithm, regardless of any assumptions about data (whether sorted or unsorted), has an asymptotic upper bound of </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="12005"/><st c="12006">. This is because, in the worst case, we may need to visit and evaluate every single element in the dataset to determine whether the target element is present. </st><st c="12166">Therefore, the time complexity of a linear search algorithm is </st><img src="image/1207.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre926"/><st c="12229"/><st c="12230">. Let’s examine this in both recursive and iterative (non-recursive) implementations of linear </st><span><st c="12325">search algorithms.</st></span></p>
			<p class="calibre3"><st c="12343">The iterative (non-recursive) implementation of linear search involves incrementing through each element of the array and checking whether it matches the target element. </st><st c="12514">The following is a simple Python implementation of </st><span><st c="12565">linear search:</st></span></p>
			<pre class="source-code"><st c="12579" class="calibre11">
def iterative_linear_search(a, target):
    for index in range(len(a)):
        if a[index] == target:
            return index
    return -1</st></pre>			<p class="calibre3"><st c="12693">Estimating</st><a id="_idIndexMarker426" class="pcalibre pcalibre1 calibre6"/><st c="12704"> the time complexity of iterative linear search is straightforward. </st><st c="12772">The algorithm consists of a loop that executes all commands inside it </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="12842"/><st c="12891"> times, where </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="12904"/><st c="12953"> is the number of elements in the array. </st><st c="12993">Additionally, the final instruction after the loop runs once. </st><st c="13055">This results in an upper bound for the running time </st><span><st c="13107">of </st></span><span><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="13110"/></span><span><st c="13111">.</st></span></p>
			<p class="calibre3"><st c="13112">The recursive implementation of linear search involves checking the current element and making a recursive call to check the next element if the target is not found. </st><st c="13279">The following is a Python code to implement recursive </st><span><st c="13333">sequential search:</st></span></p>
			<pre class="source-code"><st c="13351" class="calibre11">
def recursive_linear_search(a, target, index=0):
    if index &gt;= len(a):
        return -1
    if a[index] == target:
        return index
    return recursive_linear_search(a, target, index + 1)</st></pre>			<p class="calibre3"><st c="13519">The </st><strong class="source-inline"><st c="13524">recursive_linear_search</st></strong><st c="13547"> function takes three parameters: </st><strong class="source-inline"><st c="13581">a</st></strong><st c="13582"> (the array to search), </st><strong class="source-inline"><st c="13606">target</st></strong><st c="13612"> (the element to search for), and </st><strong class="source-inline"><st c="13646">index</st></strong><st c="13651"> (the current index in the array, defaulting to </st><strong class="source-inline"><st c="13699">0</st></strong><st c="13700">). </st><st c="13703">If </st><strong class="source-inline"><st c="13706">index</st></strong><st c="13711"> is greater than or equal to the length of the array, it means we have reached the end of the array and the target is not found. </st><st c="13840">The function returns </st><strong class="source-inline"><st c="13861">-1</st></strong><st c="13863">. If the current element at </st><strong class="source-inline"><st c="13891">a[index]</st></strong><st c="13899"> matches </st><strong class="source-inline"><st c="13908">target</st></strong><st c="13914">, the function returns the current </st><strong class="source-inline"><st c="13949">index</st></strong><st c="13954">. If the current element does not match the target, the function calls itself recursively, moving to the next index (</st><strong class="source-inline"><st c="14071">index + 1</st></strong><st c="14081">). </st><st c="14085">The algorithm can be described using a subtractive recurrence function, specifically </st><span><st c="14170">the following:</st></span></p>
			<p class="calibre3"> <img src="image/1211.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre927"/><st c="14184"/><st c="14186">.</st></p>
			<p class="calibre3"><st c="14187">This recurrence relation indicates that with each recursion, the size of the problem is reduced by one (i.e., the amount of data to be evaluated against the search criteria decreases by one). </st><st c="14380">This fits the following </st><span><st c="14404">general form:</st></span></p>
			<p class="calibre3"><img src="image/1212.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre928"/><st c="14417"/><st c="14444">.</st></p>
			<p class="calibre3"><st c="14445">Using the </st><a id="_idIndexMarker427" class="pcalibre pcalibre1 calibre6"/><st c="14456">Master Theorem for subtractive recurrences, we can identify which </st><span><st c="14522">case applies:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="14535">Case 1</st></strong><st c="14542">: If </st><img src="image/796.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre631"/><st c="14548"/><st c="14553">, </st><span><st c="14555">then </st></span><span><img src="image/1214.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre929"/><st c="14560"/></span></li>
				<li class="calibre13"><strong class="bold"><st c="14571">Case 2</st></strong><st c="14577">: If </st><img src="image/801.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre637"/><st c="14583"/><st c="14584">, </st><span><st c="14586">then </st></span><span><img src="image/1216.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre930"/><st c="14591"/></span></li>
				<li class="calibre13"><strong class="bold"><st c="14606">Case 3</st></strong><st c="14612">: If </st><img src="image/806.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;&gt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre631"/><st c="14618"/><st c="14625">, </st><span><st c="14627">then </st></span><span><img src="image/1218.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;/&lt;/mml:mo&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;.&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre931"/><st c="14632"/></span></li>
			</ul>
			<p class="calibre3"><st c="14650">With the </st><img src="image/1219.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre932"/><st c="14659"/><st c="14660">, </st><img src="image/1220.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre933"/><st c="14662"/><st c="14663">, and </st><img src="image/1221.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre934"/><st c="14669"/><st c="14670"> parameters in the subtractive recurrence function, </st><em class="italic"><st c="14722">Case 1</st></em><st c="14728"> applies. </st><st c="14738">Thus, the time complexity </st><img src="image/1222.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre543"/><st c="14764"/><st c="14765"> is </st><img src="image/1223.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre935"/><st c="14769"/><st c="14770">, confirming that the running time of the algorithm </st><span><st c="14822">is linear.</st></span></p>
			<p class="calibre3"><st c="14832">Both implementations demonstrate </st><img src="image/1204.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre936"/><st c="14866"/><st c="14867"> time complexity, meaning that in the worst case, every element in the array must be checked to find the target element. </st><st c="14988">However, both implementations have a </st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="15025"/><st c="15026"> or constant space complexity, which is a significant advantage. </st><st c="15091">Linear search is simple and easy to understand, requiring no specific data format, preprocessing, or </st><span><st c="15192">prior sorting.</st></span></p>
			<p class="calibre3"><st c="15206">Linear search is used in scenarios where simplicity and ease of implementation are priorities, and when the dataset is relatively small or unsorted. </st><st c="15356">It is particularly useful in the </st><span><st c="15389">following situations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="15410">Unsorted or unstructured data</st></strong><st c="15440">: When the data is not sorted or stored in a specific structure that facilitates faster search methods, linear search is a straightforward and </st><span><st c="15584">viable option</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="15597">Small datasets</st></strong><st c="15612">: For small datasets, the overhead of more complex search algorithms may not be justified, making linear search an </st><span><st c="15728">efficient choice</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="15744">First occurrence search</st></strong><st c="15768">: When you need to find the first occurrence of an element in an array or list, linear search </st><span><st c="15863">is appropriate</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="15877">Single or few searches</st></strong><st c="15900">: If you only need to perform a single search or a few searches, the simplicity of linear search can outweigh the benefits of more complex algorithms that require preprocessing (such </st><span><st c="16084">as sorting)</st></span></li>
			</ul>
			<p class="calibre3"><st c="16095">Linear search is used in various applications where the preceding conditions apply. </st><st c="16180">Some common applications</st><a id="_idIndexMarker428" class="pcalibre pcalibre1 calibre6"/><st c="16204"> include </st><span><st c="16213">the following:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="16227">Scanners and parsers</st></strong><st c="16248">: Linear search is often used in lexical scanners and parsers to find tokens or specific patterns within a sequence of characters </st><span><st c="16379">or data</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="16386">Lookup operations in unsorted lists</st></strong><st c="16422">: When working with unsorted lists or arrays, linear search is used to find specific elements </st><span><st c="16517">or values</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="16526">Validation and verification</st></strong><st c="16554">: Linear search is used to validate input or verify the presence of an element in a list, such as checking whether a user-entered value exists in a database </st><span><st c="16712">or list</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="16719">Real-time systems</st></strong><st c="16737">: In real-time systems where data is constantly changing and sorting is not feasible, linear search provides a quick way to find elements without </st><span><st c="16884">requiring preprocessing</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="16907">Embedded systems</st></strong><st c="16924">: In embedded systems with limited resources, the constant space complexity of linear search makes it a suitable choice for </st><span><st c="17049">searching operations</st></span></li>
			</ul>
			<p class="calibre3"><st c="17069">While linear search may not be the most efficient algorithm for large or sorted datasets, its simplicity, constant space complexity, and flexibility make it a valuable tool in various applications, particularly when working with unsorted or </st><span><st c="17311">small datasets.</st></span></p>
			<h2 id="_idParaDest-100" class="calibre5"><a id="_idTextAnchor109" class="pcalibre pcalibre1 calibre6"/><st c="17326">Sub-linear search</st></h2>
			<p class="calibre3"><st c="17344">In algorithm design, sub-linear search algorithms represent a class of techniques that offer </st><a id="_idIndexMarker429" class="pcalibre pcalibre1 calibre6"/><st c="17438">search solutions more efficiently than linear time. </st><st c="17490">These algorithms are particularly powerful because they can locate an element without needing to examine every item in the dataset. </st><st c="17622">By leveraging the properties of sorted data and advanced partitioning strategies, sub-linear search algorithms reduce the number of comparisons required, thereby accelerating the search process. </st><st c="17817">This efficiency makes them invaluable in handling large datasets where linear search methods would be </st><span><st c="17919">impractically slow.</st></span></p>
			<p class="calibre3"><st c="17938">Sub-linear search algorithms, such as binary search, jump search, and Fibonacci search, exploit different</st><a id="_idIndexMarker430" class="pcalibre pcalibre1 calibre6"/><st c="18044"> strategies to minimize the search space quickly. </st><st c="18094">Binary search, for instance, repeatedly divides the array into two halves, while jump search segments the data into blocks and performs linear searches within these smaller sections. </st><st c="18277">Fibonacci search utilizes the Fibonacci sequence to determine the range of the search space, optimizing for data that fits well into memory blocks. </st><st c="18425">Each of these algorithms offers unique advantages and is suited to specific types of problems, highlighting the versatility and power of sub-linear search methods in computational efficiency. </st><st c="18617">Let’s deep dive into the most well-known sub-linear </st><span><st c="18669">search algorithms.</st></span></p>
			<h3 class="calibre8"><st c="18687">Binary search</st></h3>
			<p class="calibre3"><strong class="bold"><st c="18701">Binary search</st></strong><st c="18715"> is an </st><a id="_idIndexMarker431" class="pcalibre pcalibre1 calibre6"/><st c="18722">effective method for locating an element in a sorted array. </st><st c="18782">The algorithm operates by continuously </st><a id="_idIndexMarker432" class="pcalibre pcalibre1 calibre6"/><st c="18821">halving the search space. </st><st c="18847">If the middle element matches the target value, the search is complete. </st><st c="18919">If not, the search proceeds in the half of the array where the target value is likely to be found. </st><st c="19018">Binary search is often implemented recursively. </st><st c="19066">The</st><a id="_idIndexMarker433" class="pcalibre pcalibre1 calibre6"/><st c="19069"> following is a recursive implementation of </st><span><st c="19113">binary search:</st></span></p>
			<pre class="source-code"><st c="19127" class="calibre11">
def recursive_binary_search(a, target, left, right):
    if right &gt;= left:
        mid = left + (right - left) // 2
        if a[mid] == target:
            return mid
        elif a[mid] &gt; target:
            return recursive_binary_search(a, target, left, mid - 1)
        else:
            return recursive_binary_search(a, target, mid + 1, right)
    return -1</st></pre>			<p class="calibre3"><st c="19416">Binary </st><a id="_idIndexMarker434" class="pcalibre pcalibre1 calibre6"/><st c="19424">search</st><a id="_idIndexMarker435" class="pcalibre pcalibre1 calibre6"/><st c="19430"> works by repeatedly dividing the search interval in half. </st><st c="19489">The time complexity of binary search is </st><img src="image/1226.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre937"/><st c="19529"/><st c="19538">. Let’s analyze and prove this time complexity </st><span><st c="19585">in detail.</st></span></p>
			<p class="calibre3"><st c="19595">Given a sorted array, </st><strong class="source-inline"><st c="19618">a</st></strong><st c="19619">, and a target value, </st><strong class="source-inline"><st c="19641">target</st></strong><st c="19647">, binary search follows </st><span><st c="19671">these steps:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="19683">Initialization</st></strong><st c="19698">: Set two pointers, </st><strong class="source-inline1"><st c="19719">left</st></strong><st c="19723"> and </st><strong class="source-inline1"><st c="19728">right</st></strong><st c="19733">, at the beginning and end of the </st><span><st c="19767">array, respectively.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="19787">Middle element</st></strong><st c="19802">: Calculate the middle index, </st><strong class="source-inline1"><st c="19833">mid = left + (right - left) // </st></strong><span><strong class="source-inline1"><st c="19864">2</st></strong></span><span><st c="19865">.</st></span></li>
				<li class="calibre13"><span><strong class="bold"><st c="19866">Comparison</st></strong></span><span><st c="19877">:</st></span><ul class="calibre50"><li class="calibre13"><st c="19879">If </st><strong class="source-inline1"><st c="19882">a[mid] == target</st></strong><st c="19898">, the target is found, and the </st><strong class="source-inline1"><st c="19929">mid</st></strong><st c="19932"> index </st><span><st c="19939">is returned</st></span></li><li class="calibre13"><st c="19950"> If </st><strong class="source-inline1"><st c="19954">a[mid] &lt; target</st></strong><st c="19969">, update </st><strong class="source-inline1"><st c="19978">left</st></strong><st c="19982"> to </st><strong class="source-inline1"><st c="19986">mid + 1</st></strong><st c="19993"> and repeat </st><span><st c="20005">the process</st></span></li><li class="calibre13"><st c="20016"> If </st><strong class="source-inline1"><st c="20020">a[mid] &gt; target</st></strong><st c="20035">, update </st><strong class="source-inline1"><st c="20044">right</st></strong><st c="20049"> to </st><strong class="source-inline1"><st c="20053">mid - 1</st></strong><st c="20060"> and repeat </st><span><st c="20072">the process</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="20083">Termination</st></strong><st c="20095">: The process continues until </st><strong class="source-inline1"><st c="20126">left &gt; right</st></strong><st c="20138">. If the target is not found, </st><span><st c="20168">return </st></span><span><strong class="source-inline1"><st c="20175">-1</st></strong></span><span><st c="20177">.</st></span></li>
			</ol>
			<p class="calibre3"><st c="20178">The initial search space is the entire array of size </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre776"/><st c="20232"/><st c="20281">. At each step, the algorithm compares the target with the middle element. </st><st c="20356">Based on the comparison, the search space is halved; either the left half or the right half </st><span><st c="20448">is discarded:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="20461">After the first step, the search space </st><span><st c="20501">is </st></span><span><img src="image/693.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre547"/><st c="20504"/></span></li>
				<li class="calibre13"><st c="20505">After the second step, the search space </st><span><st c="20545">is </st></span><span><img src="image/695.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre549"/><st c="20548"/></span></li>
				<li class="calibre13"><st c="20549">After the </st><img src="image/1230.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre938"/><st c="20559"/><st c="20560"> step, the search space </st><span><st c="20584">is </st></span><span><img src="image/1231.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre532"/><st c="20587"/></span></li>
			</ul>
			<p class="calibre3"><st c="20588">The algorithm stops when the search space is reduced to 1 element, i.e., </st><img src="image/1232.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre939"/><st c="20661"/><st c="20664">. Now we solve it for </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="20686"/><st c="20687">: </st><img src="image/1234.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;⟹&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;⟹&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre940"/><st c="20689"/><st c="20718">. Therefore, the binary search algorithm performs at most </st><img src="image/573.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre458"/><st c="20776"/> <span><st c="20783">comparisons.</st></span></p>
			<p class="calibre3"><st c="20795">We can</st><a id="_idIndexMarker436" class="pcalibre pcalibre1 calibre6"/><st c="20802"> also </st><a id="_idIndexMarker437" class="pcalibre pcalibre1 calibre6"/><st c="20808">prove the time complexity using a recurrence function. </st><st c="20863">Let’s define </st><img src="image/1236.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre941"/><st c="20876"/><st c="20877"> as the time complexity of binary search on an array of size </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="20938"/><st c="20987">. If the array size is 1 (</st><img src="image/1238.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre942"/><st c="21013"/><st c="21015">), the time complexity is </st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="21041"/><st c="21042"> because it involves a single </st><span><st c="21072">comparison: </st></span><span><img src="image/1240.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre943"/><st c="21084"/></span><span><st c="21085">.</st></span></p>
			<p class="calibre3"><st c="21086">For an array of size </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="21108"/><st c="21157">, we perform one comparison to check the middle element, then we recursively search in the left or right half, each of size </st><img src="image/547.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre944"/><st c="21281"/><st c="21282">. Then, the recurrence function of recursive binary search is </st><span><st c="21344">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1243.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre945"/><st c="21355"/><st c="21373">.</st></p>
			<p class="calibre3"><st c="21374">Using the Master Theorem for divide-and-conquer recurrence relations, </st><em class="italic"><st c="21445">Case 2</st></em><st c="21451"> applies. </st><st c="21461">Therefore, the </st><span><st c="21476">following applies:</st></span></p>
			<p class="calibre3"><img src="image/1244.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre946"/><st c="21494"/><st c="21510">.</st></p>
			<p class="calibre3"><st c="21511">Unlike linear search, binary search is highly efficient, making it suitable for large datasets. </st><st c="21608">The algorithm is straightforward to implement and understand. </st><st c="21670">The iterative version uses constant space, </st><img src="image/1245.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre947"/><st c="21713"/><st c="21714">, and even the recursive version has relatively low space overhead, </st><img src="image/1246.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre948"/><st c="21782"/><st c="21791">. The primary use case for binary search is finding an element in a sorted array or list. </st><st c="21881">Binary search is also used in dictionary operations such as finding words in a sorted list </st><span><st c="21972">of entries.</st></span></p>
			<p class="calibre3"><st c="21983">On the other hand, binary search only works on sorted arrays. </st><st c="22046">If the data is unsorted, it must first be sorted, which adds additional overhead. </st><st c="22128">Binary search is best suited for static arrays where the data does not change frequently. </st><st c="22218">Frequent insertions and deletions would require re-sorting the array, increasing the sorting overhead. </st><st c="22321">Additionally, binary search is less efficient with linked lists or other non-contiguous memory structures because it relies on efficient random access provided </st><span><st c="22481">by arrays.</st></span></p>
			<p class="calibre3"><st c="22491">The concept of dividing a dataset at the midpoint can be extended to partitioning the dataset into more than two segments. </st><st c="22615">Ternary search is an example of this approach. </st><st c="22662">It is a divide-and-conquer search algorithm that operates on a sorted array by dividing the array into three parts and determining in which part the target element lies, thereby reducing the search space to one-third. </st><st c="22880">This process is repeated until the target element is found or the search space is exhausted. </st><st c="22973">Consequently, the time complexity of ternary search </st><span><st c="23025">is </st></span><span><img src="image/1247.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre949"/><st c="23028"/></span><span><st c="23037">.</st></span></p>
			<h3 class="calibre8"><st c="23038">Interpolation search</st></h3>
			<p class="calibre3"><st c="23059">Interpolation search</st><a id="_idIndexMarker438" class="pcalibre pcalibre1 calibre6"/><st c="23080"> is an improvement over binary search for searching a target value within a sorted array. </st><st c="23170">While binary search always probes the middle element, interpolation</st><a id="_idIndexMarker439" class="pcalibre pcalibre1 calibre6"/><st c="23237"> search makes an educated guess about where the target value might be located based on the values at the array’s boundaries and the target </st><span><st c="23376">value itself.</st></span></p>
			<p class="calibre3"><st c="23389">The following is </st><a id="_idIndexMarker440" class="pcalibre pcalibre1 calibre6"/><st c="23407">a recursive implementation of </st><span><st c="23437">interpolation search:</st></span></p>
			<pre class="source-code"><st c="23458" class="calibre11">
def recursive_interpolation_search(a, target, low, high):
    if low &lt;= high and target &gt;= a[low] and target &lt;= a[high]:
        pos = low + ((high - low) // (a[high] - a[low]) * (target - a[low]))
        if a[pos] == target:
            return pos
        if a[pos] &lt; target:
            return recursive_interpolation_search(a, target, pos + 1, high)
        return recursive_interpolation_search(a, target, low, pos - 1)
    return -1  # Target not found</st></pre>			<p class="calibre3"><st c="23852">When comparing the code for interpolation search and binary search, the main difference lies in how the midpoint (or position) is calculated in each algorithm. </st><st c="24013">This difference reflects the approach each algorithm takes to locate the target element. </st><st c="24102">In binary search, the midpoint is calculated as the average of the left and </st><span><st c="24178">right indices:</st></span></p>
			<p class="calibre3"><strong class="source-inline"><st c="24192">mid = left + (right - left) // 2</st></strong></p>
			<p class="calibre3"><st c="24225">Binary search assumes a uniform distribution of elements and divides the search interval in half, regardless of the actual values of the elements. </st><st c="24373">In interpolation search, the midpoint (represented by </st><strong class="source-inline"><st c="24427">pos</st></strong><st c="24430">) is estimated based on the value of the target element relative to the values at the current low and </st><span><st c="24533">high indices:</st></span></p>
			<p class="calibre3"><strong class="source-inline"><st c="24546">pos = low + ((high - low) // (arr[high] - a[low]) * (target - </st></strong><span><strong class="source-inline"><st c="24609">a[low]))</st></strong></span></p>
			<p class="calibre3"><st c="24617">Interpolation search attempts</st><a id="_idIndexMarker441" class="pcalibre pcalibre1 calibre6"/><st c="24647"> to improve the midpoint estimation by considering the distribution of the elements. </st><st c="24732">This makes it more efficient for uniformly distributed datasets, as it can potentially reduce the number of comparisons by jumping closer to the </st><span><st c="24877">target element.</st></span></p>
			<p class="calibre3"><st c="24892">Let’s explore the</st><a id="_idIndexMarker442" class="pcalibre pcalibre1 calibre6"/><st c="24910"> intuition behind interpolation search. </st><st c="24950">Imagine the array as a number line. </st><st c="24986">Interpolation search estimates the position of the target value based on its relative position between the minimum and maximum values in the array. </st><st c="25134">When the values are uniformly distributed, this estimation tends to be quite accurate, resulting in faster convergence compared to </st><span><st c="25265">binary search.</st></span></p>
			<p class="calibre3"><st c="25279">We know that the time complexity of binary search is </st><img src="image/1248.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre950"/><st c="25333"/><st c="25342">. Now the question is: what is the time complexity of interpolation search? </st><st c="25418">First, we need to find the recurrence function describing the behavior of the interpolation search algorithm. </st><st c="25528">Interpolation search operates by estimating the position of the target value within the array and then recursively or iteratively refining this estimate. </st><st c="25682">The efficiency of this process depends significantly on the distribution of the values within the array. </st><st c="25787">For uniformly distributed data, the estimated position is close to the actual position of the target, leading to fewer comparisons. </st><st c="25919">The position estimate is given by </st><span><st c="25953">the following:</st></span></p>
			<p class="calibre3"><img src="image/1249.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;i&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;g&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;l&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;o&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;a&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;i&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;g&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;a&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;l&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;o&lt;/mml:mi&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;×&lt;/mml:mo&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;r&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre951"/><st c="25967"/></p>
			<p class="calibre3"><st c="26041">In each iteration, the size of the search interval is reduced proportionally based on the estimated position. </st><st c="26151">On average, interpolation search reduces the search space more significantly than binary search. </st><st c="26248">However, the estimated position heavily depends on the distribution of the data. </st><st c="26329">In the worst-case scenario, when the distribution is highly skewed, the time complexity is </st><img src="image/1250.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre952"/><st c="26420"/><st c="26421">, making interpolation search no better than </st><span><st c="26466">linear search.</st></span></p>
			<p class="calibre3"><st c="26480">In a more realistic average case, where the data distribution is closer to uniform, interpolation search performs better. </st><st c="26603">To analyze this, we need to determine the recurrence function for this scenario. </st><st c="26684">For uniformly distributed data, we assume that the problem size is reduced by the square root of the original problem size in each recursion. </st><st c="26826">This suggests the following recurrence relation for interpolation search in the </st><span><st c="26906">average-case scenario:</st></span></p>
			<p class="calibre3"><img src="image/1251.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre953"/><st c="26928"/></p>
			<p class="calibre3"><st c="26948">Since</st><a id="_idIndexMarker443" class="pcalibre pcalibre1 calibre6"/><st c="26953"> the</st><a id="_idIndexMarker444" class="pcalibre pcalibre1 calibre6"/><st c="26957"> recurrence function does not fit the standard format of the Master Theorem, we need to use alternative approaches, such as the substitution method, to </st><span><st c="27109">solve it.</st></span></p>
			<p class="calibre3"><st c="27118">Let’s perform a variable change: </st><img src="image/644.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre509"/><st c="27152"/><st c="27153">. We can then rewrite the recurrence function </st><span><st c="27199">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1253.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre954"/><st c="27210"/></p>
			<p class="calibre3"><st c="27212">Next, make another variable change: </st><img src="image/1254.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;S&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre955"/><st c="27248"/><st c="27249">. The recurrence relation now becomes </st><span><st c="27287">the following:</st></span></p>
			<p class="calibre3"><img src="image/1255.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;S&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;S&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre956"/><st c="27301"/></p>
			<p class="calibre3"><st c="27320">This is a familiar recurrence function (similar to binary search), and we can conclude </st><span><st c="27407">the following:</st></span></p>
			<p class="calibre3"><img src="image/1256.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre957"/><st c="27421"/></p>
			<p class="calibre3"><st c="27438">Replacing </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre511"/><st c="27448"/><st c="27449"> back with </st><img src="image/573.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre458"/><st c="27460"/><st c="27467">, we </st><span><st c="27472">get this:</st></span></p>
			<p class="calibre3"><img src="image/1259.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msup&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre958"/><st c="27481"/></p>
			<p class="calibre3"><st c="27525">In the worst case, if the distribution of elements is highly skewed or not uniform, the position estimates can be inaccurate, leading to a linear search behavior. </st><st c="27688">This results in a worst-case time complexity of </st><img src="image/1260.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre959"/><st c="27736"/><st c="27737">. On the other hand, the space complexity is </st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="27782"/><st c="27783"> because interpolation search only needs to keep the </st><strong class="source-inline"><st c="27836">pos</st></strong><st c="27839"> variable in memory, which does not depend on the size of </st><span><st c="27897">the data.</st></span></p>
			<p class="calibre3"><st c="27906">Interpolation search is highly efficient for uniformly distributed data but can degrade to linear search performance for non-uniform distributions. </st><st c="28055">This analysis shows that while interpolation search has potential advantages, its efficiency is highly dependent on the </st><span><st c="28175">data distribution.</st></span></p>
			<h3 class="calibre8"><st c="28193">Exponential search</st></h3>
			<p class="calibre3"><strong class="bold"><st c="28212">Exponential search</st></strong><st c="28231">, also </st><a id="_idIndexMarker445" class="pcalibre pcalibre1 calibre6"/><st c="28238">known as </st><strong class="bold"><st c="28247">galloping search</st></strong><st c="28263"> or </st><strong class="bold"><st c="28267">doubling search</st></strong><st c="28282">, is an</st><a id="_idIndexMarker446" class="pcalibre pcalibre1 calibre6"/><st c="28289"> algorithm </st><a id="_idIndexMarker447" class="pcalibre pcalibre1 calibre6"/><st c="28300">for finding a range in a sorted array where a target value might be located. </st><st c="28377">It works by </st><a id="_idIndexMarker448" class="pcalibre pcalibre1 calibre6"/><st c="28389">initially checking the first element and then repeatedly doubling the interval size until it finds a range that may contain the target. </st><st c="28525">Once this range is found, binary search is used within the range to locate the </st><span><st c="28604">target value.</st></span></p>
			<p class="calibre3"><st c="28617">The time complexity of exponential search is </st><img src="image/1262.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre960"/><st c="28663"/><st c="28672"> in both the worst-case and average-case scenarios. </st><st c="28723">This efficiency is due to the algorithm’s approach of rapidly increasing the interval size and then using a binary search within the </st><span><st c="28856">identified range.</st></span></p>
			<p class="calibre3"><st c="28873">Exponential search first finds a range where the target element might be located by repeatedly doubling the index. </st><st c="28989">This step takes </st><img src="image/1263.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre961"/><st c="29005"/><st c="29013"> time because the doubling process essentially performs a binary search on the indices. </st><st c="29100">Once the range is found, a binary search within that range takes another </st><img src="image/1264.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre962"/><st c="29173"/><st c="29181"> time. </st><st c="29187">However, since the range-finding step already reduces the problem size significantly, the overall time complexity </st><span><st c="29301">remains </st></span><span><img src="image/1265.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre963"/><st c="29309"/></span><span><st c="29317">.</st></span></p>
			<p class="calibre3"><st c="29318">The space complexity of exponential search depends on the implementation method. </st><st c="29400">In the iterative approach, the space complexity is </st><img src="image/1266.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre964"/><st c="29451"/><st c="29452">. The following is a simple iterative implementation of </st><a id="_idIndexMarker449" class="pcalibre pcalibre1 calibre6"/><span><st c="29508">exponential search:</st></span></p>
			<pre class="source-code"><st c="29527" class="calibre11">
def iterative_exponential_search(a, target):
    if a[0] == target:
        return 0
    n = len(a)
    i = 1
    while i &lt; n and a[i] &lt;= target:
        i = i * 2
    return binary_search(a, i // 2, min(i, n - 1), target)</st></pre>			<p class="calibre3"><st c="29714">Let’s briefly explain the code. </st><st c="29747">The key part of the code is the line </st><strong class="source-inline"><st c="29784">while i &lt; n and a[i] &lt;= target:</st></strong><st c="29815">, where the exponential growth occurs: </st><strong class="source-inline"><st c="29854">i = i * 2</st></strong><st c="29863">. In this step, the index doubles (</st><strong class="source-inline"><st c="29898">1</st></strong><st c="29900">, </st><strong class="source-inline"><st c="29902">2</st></strong><st c="29903">, </st><strong class="source-inline"><st c="29905">4</st></strong><st c="29906">, </st><strong class="source-inline"><st c="29908">8</st></strong><st c="29909">, and so on) until a value larger than or equal to the target is found. </st><st c="29981">Once this range is identified, </st><strong class="source-inline"><st c="30012">binary_search</st></strong><st c="30025"> is performed within that range to locate the </st><span><st c="30071">target element.</st></span></p>
			<p class="calibre3"><st c="30086">The</st><a id="_idIndexMarker450" class="pcalibre pcalibre1 calibre6"/><st c="30090"> iterative implementation uses a</st><a id="_idIndexMarker451" class="pcalibre pcalibre1 calibre6"/><st c="30122"> constant amount of extra space regardless of the size of the input array. </st><st c="30197">The only additional memory required is for a few variables to keep track of the indices and the </st><span><st c="30293">target element.</st></span></p>
			<p class="calibre3"><st c="30308">Unlike the iterative approach, in the recursive method, the space complexity is </st><img src="image/1265.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre965"/><st c="30389"/><st c="30397">. Let’s have a look at the </st><span><st c="30424">recursive implementation:</st></span></p>
			<pre class="source-code"><st c="30449" class="calibre11">
def recursive_exponential_search(a, target, i=1):
    n = len(a)
    if a[0] == target:
        return 0
    if i &lt; n and a[i] &lt;= target:
        return recursive_exponential_search(a, target, i * 2)
    return binary_search(a, i // 2, min(i, n - 1), target)</st></pre>			<p class="calibre3"><st c="30676">The recursive implementation uses additional space on the call stack for each recursive call. </st><st c="30771">Since the depth of the recursion is proportional to </st><img src="image/573.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre458"/><st c="30823"/><st c="30830">, the space complexity </st><span><st c="30853">is </st></span><span><img src="image/1226.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre937"/><st c="30856"/></span><span><st c="30865">.</st></span></p>
			<p class="calibre3"><st c="30866">Exponential search is an effective algorithm for quickly narrowing down the search range in large, sorted arrays. </st><st c="30981">By combining the strengths of exponential and binary search, it offers both efficiency and flexibility. </st><st c="31085">Its main advantage lies in its ability to handle large datasets efficiently, although it requires the data to be sorted and introduces some complexity with its dual-phase </st><span><st c="31256">search approach.</st></span></p>
			<h3 class="calibre8"><st c="31272">Jump search</st></h3>
			<p class="calibre3"><strong class="bold"><st c="31284">Jump search</st></strong><st c="31296"> is an</st><a id="_idIndexMarker452" class="pcalibre pcalibre1 calibre6"/><st c="31302"> algorithm for finding an element in a sorted array. </st><st c="31355">It works by </st><a id="_idIndexMarker453" class="pcalibre pcalibre1 calibre6"/><st c="31367">dividing the array into blocks of a fixed size, jumping ahead by that block size, and then performing a linear search within the block where the target element might be located. </st><st c="31545">The optimal step size for jumping is typically </st><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre966"/><st c="31592"/><st c="31593">, where </st><img src="image/1271.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre967"/><st c="31601"/><st c="31602"> is the number of elements in the array. </st><st c="31643">This method aims</st><a id="_idIndexMarker454" class="pcalibre pcalibre1 calibre6"/><st c="31659"> to reduce the number of comparisons by skipping over large sections of the array initially. </st><st c="31752">We will prove that the time complexity of jump search is </st><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre968"/><st c="31809"/><st c="31815">. The iterative</st><a id="_idIndexMarker455" class="pcalibre pcalibre1 calibre6"/><st c="31830"> implementation of jump search is </st><span><st c="31864">as follows:</st></span></p>
			<pre class="source-code"><st c="31875" class="calibre11">
import math
def jump_search(a, target):
    n = len(a)
    step = int(math.sqrt(n))
    prev = 0
    while a[min(step, n) - 1] &lt; target:
        prev = step
        step += int(math.sqrt(n))
        if prev &gt;= n:
            return -1
    while a[prev] &lt; target:
        prev += 1
        if prev == min(step, n):
            return -1
    if a[prev] == target:
        return prev
    return -1</st></pre>			<p class="calibre3"><st c="32171">Recursive implementation of jump search is less common due to the nature of the algorithm. </st><st c="32263">However, it can be implemented </st><span><st c="32294">as follows:</st></span></p>
			<pre class="source-code"><st c="32305" class="calibre11">
import math
def recursive_jump_search(a, target, prev=0, step=None):
    n = len(a)
    if step is None:
        step = int(math.sqrt(n))  # Block size to jump
    if prev &gt;= n:
        return -1
    if a[min(step, n) - 1] &lt; target:
        return recursive_jump_search(a, target, step, step + int(math.sqrt(n)))
    while prev &lt; min(step, n) and a[prev] &lt; target:
        prev += 1
    if prev &lt; n and a[prev] == target:
        return prev
    return -1</st></pre>			<p class="calibre3"><st c="32692">Let’s </st><a id="_idIndexMarker456" class="pcalibre pcalibre1 calibre6"/><st c="32699">analyze</st><a id="_idIndexMarker457" class="pcalibre pcalibre1 calibre6"/><st c="32706"> the algorithm and then estimate the time complexity of jump search. </st><st c="32775">The algorithm is implemented in </st><span><st c="32807">three steps:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><span><strong class="bold"><st c="32819">Initialization</st></strong></span><span><st c="32834">:</st></span><ul class="calibre50"><li class="calibre13"><st c="32836">Set the block size </st><span><st c="32855">to </st></span><span><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="32858"/></span><span><st c="32859">.</st></span></li><li class="calibre13"><st c="32860">Initialize </st><strong class="source-inline1"><st c="32872">prev</st></strong><st c="32876"> to </st><strong class="source-inline1"><st c="32880">0</st></strong><st c="32881"> and </st><strong class="source-inline1"><st c="32886">step</st></strong> <span><st c="32890">to </st></span><span><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="32894"/></span><span><st c="32895">.</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="32896">Jumping phase</st></strong><st c="32910">: Jump ahead by the block size until the value at the current position is greater than or equal to the target or the end of the array </st><span><st c="33045">is reached.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="33056">Linear search phase</st></strong><st c="33076">: Perform a linear search within the </st><span><st c="33114">identified block.</st></span></li>
			</ol>
			<p class="calibre3"><st c="33131">Now, let’s analyze the time complexity. </st><st c="33172">We know that the size of each block is </st><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre970"/><st c="33211"/><st c="33212">. In the worst case, we may need to jump through the entire array to find the block containing the target element. </st><st c="33327">The number of jumps required to reach the target block is </st><img src="image/1276.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mfenced open=&quot;⌈&quot; close=&quot;⌉&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mfenced open=&quot;⌈&quot; close=&quot;⌉&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre971"/><st c="33385"/><st c="33386">. Each jump involves a comparison, and thus the number of comparisons in the jumping phase </st><span><st c="33477">is </st></span><span><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="33480"/></span><span><st c="33481">.</st></span></p>
			<p class="calibre3"><st c="33482">At this stage, we </st><a id="_idIndexMarker458" class="pcalibre pcalibre1 calibre6"/><st c="33501">are ready to start the linear search phase. </st><st c="33545">After identifying the potential block, a linear search is performed within this block. </st><st c="33632">The</st><a id="_idIndexMarker459" class="pcalibre pcalibre1 calibre6"/><st c="33635"> maximum number of elements to search within a block is </st><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="33691"/><st c="33692">. Thus, the number of comparisons in the linear search phase is, at </st><span><st c="33760">most, </st></span><span><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="33766"/></span><span><st c="33767">.</st></span></p>
			<p class="calibre3"><st c="33768">We had two </st><span><st c="33780">following phases:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="33797">Jumping phase </st><span><st c="33812">comparisons: </st></span><span><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre968"/><st c="33825"/></span></li>
				<li class="calibre13"><st c="33831">Linear search phase </st><span><st c="33851">comparisons: </st></span><span><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre968"/><st c="33864"/></span></li>
			</ul>
			<p class="calibre3"><st c="33870">We add two phases together; the total number of comparisons is </st><span><st c="33933">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1282.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre972"/><st c="33944"/></p>
			<p class="calibre3"><st c="33965">The total time complexity of the jump search algorithm is </st><img src="image/1283.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre973"/><st c="34023"/><st c="34029">. This is because the algorithm performs up to </st><img src="image/1284.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre974"/><st c="34076"/><st c="34077"> comparisons during the jumping phase and up to </st><img src="image/1284.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre975"/><st c="34125"/><st c="34126"> comparisons during the linear search phase within the block. </st><st c="34188">The combination of these phases results in an overall time complexity of </st><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre968"/><st c="34261"/><st c="34267">. This analysis shows that jump search is less efficient than binary search, </st><span><st c="34344">O</st></span><span><st c="34345">(</st></span><span><st c="34346">l</st></span><span><st c="34347">o</st></span><span><st c="34348">g</st></span><span> </span><span><st c="34349">n</st></span><span><st c="34350">)</st></span><st c="34351">, but can still be useful in scenarios where the simplicity of implementation and constant space complexity </st><img src="image/1189.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre976"/><st c="34459"/> <span><st c="34460">are advantageous.</st></span></p>
			<p class="calibre3"><st c="34477">Jump search is more efficient than linear search for large arrays because it reduces the number of comparisons by skipping over blocks of elements. </st><st c="34626">The jump search algorithm is relatively simple to implement and understand and, unlike binary search, jump search does not require any preprocessing of the data other than ensuring it </st><span><st c="34810">is sorted.</st></span></p>
			<p class="calibre3"><st c="34820">However, jump search comes with some limitations. </st><st c="34871">Like binary search, jump search only works on sorted arrays. </st><st c="34932">Also, the efficiency of jump search depends on choosing an optimal block size, which is generally </st><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="35030"/><st c="35031">, but this might not always be the most efficient in practice. </st><st c="35094">For very small arrays, the overhead of calculating the block size and performing the jumps might make it less efficient than simpler algorithms such as </st><span><st c="35246">linear search.</st></span></p>
			<p class="calibre3"><st c="35260">Jump search is useful when searching in large sorted arrays where binary search might be less intuitive or when the data is accessed sequentially. </st><st c="35408">In databases, jump search can be used for indexing and querying sorted data efficiently. </st><st c="35497">The other use case for jump search is in memory-constrained environments. </st><st c="35571">Given its </st><img src="image/1289.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre977"/><st c="35581"/><st c="35582"> space complexity, jump search is suitable for memory-constrained environments where additional space for data structures </st><a id="_idIndexMarker460" class="pcalibre pcalibre1 calibre6"/><st c="35704">such as binary search trees or hash tables is </st><span><st c="35750">not available.</st></span></p>
			<p class="calibre3"><st c="35764">In summary, jump search</st><a id="_idIndexMarker461" class="pcalibre pcalibre1 calibre6"/><st c="35788"> is an effective algorithm for searching in sorted arrays, striking a balance between the simplicity of linear search and the efficiency of binary search. </st><st c="35943">Its primary advantage lies in its </st><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre978"/><st c="35977"/><st c="35983"> time complexity, making it suitable for certain applications where sorted data needs to be </st><span><st c="36074">searched quickly.</st></span></p>
			<h3 class="calibre8"><st c="36091">Recap</st></h3>
			<p class="calibre3"><st c="36097">All sub-linear search algorithms rely on sorted data, which means they must first sort the data if it is not already sorted. </st><st c="36223">This poses a significant limitation when the data is dynamically changing. </st><st c="36298">We will discuss this in detail in the </st><span><st c="36336">next chapter.</st></span></p>
			<p class="calibre3"><st c="36349">Most sub-linear search algorithms are improvements or extensions of binary search, except for jump search, which is based on segmenting the data and then searching within each segment. </st><st c="36535">The main idea behind binary search and its variants is to find the most optimal estimation of the mid position in the array. </st><st c="36660">This differentiates binary search from interpolation and exponential search. </st><st c="36737">On the other hand, the goal of every search algorithm is to reduce the search space or scope we are looking in for the target and to minimize the risk of missing it. </st><st c="36903">In all variants of binary search, this is done by one or more midpoints, while in jump search, this is achieved by evenly splitting the </st><span><st c="37039">search space.</st></span></p>
			<p class="calibre3"><st c="37052">If we split the search space (dataset) into many partitions, for example, </st><img src="image/1270.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:math&gt;" class="calibre969"/><st c="37127"/><st c="37128">, we are referring to jump search. </st><st c="37163">While it may seem similar to binary search, which has a single midpoint, jump search divides the dataset into multiple partitions and uses multiple midpoints (</st><em class="italic"><st c="37322">number of partitions = number of midpoints + 1</st></em><st c="37369">). </st><st c="37373">This distinction leads to a different time complexity pattern for jump search, which is </st><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre968"/><st c="37461"/><st c="37467">, compared to the </st><img src="image/1226.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre937"/><st c="37485"/><st c="37494"> complexity of binary search and </st><span><st c="37526">its variations.</st></span></p>
			<p class="calibre3"><st c="37541">An interesting approach is to use the Fibonacci sequence to partition the search space. </st><st c="37630">This leads us to the Fibonacci search. </st><st c="37669">Fibonacci search is an efficient search algorithm that works on sorted arrays. </st><st c="37748">It leverages the properties of Fibonacci numbers to divide the array into smaller sections, making it similar to both binary and jump searches. </st><st c="37892">The main advantage of Fibonacci search is its efficiency when dealing with arrays that fit well into </st><span><st c="37993">memory blocks.</st></span></p>
			<h1 id="_idParaDest-101" class="calibre5"><a id="_idTextAnchor110" class="pcalibre pcalibre1 calibre6"/><st c="38007">Hashing</st></h1>
			<p class="calibre3"><st c="38015">In the previous</st><a id="_idIndexMarker462" class="pcalibre pcalibre1 calibre6"/><st c="38031"> two sections, we explored two groups of search algorithms: those with linear time complexity and those with more efficient, sub-linear time complexity. </st><st c="38184">Linear search algorithms, such as the simple sequential search, operate with </st><img src="image/1294.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre979"/><st c="38261"/><st c="38262"> time complexity, making them straightforward but less efficient for large datasets. </st><st c="38347">On the other hand, sub-linear search algorithms, such as binary search and jump search, offer significantly better time complexities, often </st><img src="image/1246.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre980"/><st c="38487"/><st c="38496"> or </st><img src="image/1272.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msqrt&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:msqrt&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre968"/><st c="38499"/><st c="38505">, by leveraging the properties of sorted data to minimize the number of </st><span><st c="38577">comparisons needed.</st></span></p>
			<p class="calibre3"><st c="38596">However, achieving this improved time complexity comes with a cost: the time required to sort the data. </st><st c="38701">Sorting is a prerequisite for the efficiency of sub-linear search algorithms. </st><st c="38779">Without sorted data, the theoretical benefits of sub-linear time complexity cannot be realized. </st><st c="38875">The process of sorting itself can be time-consuming, typically </st><img src="image/1297.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre981"/><st c="38938"/><st c="38949"> for efficient algorithms such as quick sort or merge sort. </st><st c="39008">Therefore, while sub-linear search algorithms provide faster search times, they are only practical when the data can be sorted efficiently or when the data remains relatively static, allowing the sorting step to be amortized over multiple searches. </st><st c="39257">This trade-off between sorting time and search efficiency is a critical consideration in the design and application of </st><span><st c="39376">search algorithms.</st></span></p>
			<p class="calibre3"><st c="39394">The question now arises: can we achieve even better performance than sub-linear search algorithms? </st><st c="39494">Specifically, is it possible to perform a search in constant time, or </st><img src="image/1298.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre982"/><st c="39564"/><st c="39565">? To answer this question, we need to review the objective of the search operation. </st><st c="39649">The objective of any search algorithm is to efficiently find the index or address of a key within a data structure. </st><st c="39765">One approach to achieving constant time search is through a technique known </st><span><st c="39841">as hashing.</st></span></p>
			<p class="calibre3"><st c="39852">In hashing, we use a hash function that takes the target key as input and computes a value that directly corresponds to the location of the key in the data structure. </st><st c="40020">This value, known as the hash value (or hash code), is then used to index into a hash table, allowing for constant time access to </st><span><st c="40150">the data.</st></span></p>
			<p class="calibre3"><st c="40159">Before diving into the subject of hashing, let’s define some </st><span><st c="40221">basic terms:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="40233">Key</st></strong><st c="40237">: In the</st><a id="_idIndexMarker463" class="pcalibre pcalibre1 calibre6"/><st c="40246"> context of search algorithms and data structures, a key is a unique identifier used to search, access, or manage elements within a collection, such as an array, list, or database. </st><st c="40427">Keys are essential for efficient data retrieval and manipulation. </st><st c="40493">For example, in a dictionary, the key might be a word, and the associated value could be the definition of that word. </st><st c="40611">Keys are used in various data structures, such as hash tables, where they are input into a hash function to generate </st><span><st c="40728">an index.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="40737">Index</st></strong><st c="40743">: An</st><a id="_idIndexMarker464" class="pcalibre pcalibre1 calibre6"/><st c="40748"> index is a numerical representation of a position within a data structure, such as an array or list. </st><st c="40850">It indicates where a particular element is stored within that structure. </st><st c="40923">For example, in an array of </st><strong class="source-inline1"><st c="40951">[10, 20, 30, 40]</st></strong><st c="40967">, the index of the </st><strong class="source-inline1"><st c="40986">30</st></strong><st c="40988"> element is </st><strong class="source-inline1"><st c="41000">2</st></strong><st c="41001">. Indexes are crucial for accessing elements directly in data structures that support random access, such as arrays </st><span><st c="41117">and lists.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="41127">Address</st></strong><st c="41135">: An address </st><a id="_idIndexMarker465" class="pcalibre pcalibre1 calibre6"/><st c="41149">refers to a specific location in memory where a data element is stored. </st><st c="41221">In the context of search and data structures, the address is often the actual memory location corresponding to a particular index or key. </st><st c="41359">In low-level programming, such as C or C++, an address might be something such as </st><strong class="source-inline1"><st c="41441">0x7ffee44b8b60</st></strong><st c="41455">, indicating the exact memory location of a variable. </st><st c="41509">Addresses are used to directly access and manipulate data stored in memory. </st><st c="41585">In higher-level programming, addresses are often abstracted away, but understanding them is crucial for optimizing performance and understanding </st><span><st c="41730">memory management.</st></span></li>
			</ul>
			<p class="calibre3"><st c="41748">In hash tables, a key is passed through a hash function to generate an index. </st><st c="41827">This index is then used to locate the corresponding data in the hash table. </st><st c="41903">On the other hand, in arrays, an index directly corresponds to an address in memory where the data element </st><span><st c="42010">is stored.</st></span></p>
			<h2 id="_idParaDest-102" class="calibre5"><a id="_idTextAnchor111" class="pcalibre pcalibre1 calibre6"/><st c="42020">Hash functions</st></h2>
			<p class="calibre3"><st c="42035">A </st><strong class="bold"><st c="42038">hash function</st></strong><st c="42051"> is a</st><a id="_idIndexMarker466" class="pcalibre pcalibre1 calibre6"/><st c="42056"> mathematical function that transforms an input key into a numerical value, called</st><a id="_idIndexMarker467" class="pcalibre pcalibre1 calibre6"/><st c="42138"> a </st><strong class="bold"><st c="42141">hash value</st></strong><st c="42151">. The hash value is then mapped to an index in a hash table. </st><st c="42212">A good hash function distributes keys uniformly across the hash table to minimize collisions, where two or more keys hash to the same index. </st><st c="42353">An effective hash function has several </st><span><st c="42392">key properties:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="42407">Deterministic</st></strong><st c="42421">: A </st><a id="_idIndexMarker468" class="pcalibre pcalibre1 calibre6"/><st c="42426">hash function must consistently produce the same output (hash value) for the same input. </st><st c="42515">This ensures predictability and reliability in applications such as data retrieval </st><span><st c="42598">and verification.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="42615">Fixed output size</st></strong><st c="42633">: Regardless of the size of the input data, the output hash value should have a fixed length. </st><st c="42728">This makes hash values easy to store and compare, enhancing efficiency in </st><span><st c="42802">various algorithms.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="42821">Efficiency</st></strong><st c="42832">: Hash functions should be computationally fast, allowing for quick generation of hash values even for large inputs. </st><st c="42950">This is essential for real-time applications and algorithms that rely on hashing </st><span><st c="43031">for performance.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="43047">Uniformity</st></strong><st c="43058">: A good hash function distributes its output values uniformly across the output space. </st><st c="43147">Even a small change in the input should result in a significantly different hash value, preventing patterns and making it difficult to reverse-engineer </st><span><st c="43299">the input.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="43309">Collision resistance</st></strong><st c="43330">: It should be computationally infeasible to find two different inputs that produce the same hash value (a collision). </st><st c="43450">Collision resistance is critical for security applications such as password storage and </st><span><st c="43538">digital signatures.</st></span></li>
			</ul>
			<p class="calibre3"><st c="43557">There are additional properties that are particularly important for cryptographic hash functions (beyond the scope of </st><span><st c="43676">this book):</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="43687">Pre-image resistance</st></strong><st c="43708">: Given a hash value, it should be difficult to find the original input that produced it. </st><st c="43799">This property protects against attacks that attempt to recover the original data from </st><span><st c="43885">its hash.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="43894">Second pre-image resistance</st></strong><st c="43922">: Given one input and its hash value, it should be difficult to find a second input that produces the </st><span><st c="44025">same hash.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="44035">Non-correlation</st></strong><st c="44051">: There should be no correlation between different parts of the input and the resulting </st><span><st c="44140">hash value.</st></span></li>
			</ul>
			<p class="calibre3"><st c="44151">By </st><a id="_idIndexMarker469" class="pcalibre pcalibre1 calibre6"/><st c="44155">applying a hash function to the input data, we construct a hash table. </st><st c="44226">A hash table is a data structure that stores key-value pairs. </st><st c="44288">Each key is processed by the hash function to generate a hash value, which determines the index where the corresponding value is stored. </st><st c="44425">The primary advantage of a hash table is that it enables search, insert, and delete operations to be performed in average-case </st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="44552"/> <span><st c="44553">time complexity.</st></span></p>
			<p class="calibre3"><st c="44569">The efficiency of a hash table depends on how well the hash function distributes keys across the table. </st><st c="44674">Ideally, a good hash function will minimize the number of empty cells (making the table less sparse) and reduce the number of collisions (where multiple keys hash to the same index). </st><st c="44857">The art of designing a good hash function lies in achieving a balance between these factors to ensure </st><span><st c="44959">optimal performance.</st></span></p>
			<p class="calibre3"><st c="44979">Meanwhile, it is crucial to note that when selecting a hash function for a specific algorithm, it is important to consider the application. </st><st c="45120">Different applications may require different properties. </st><st c="45177">For example, cryptographic applications demand strong collision resistance, while data structures might </st><span><st c="45281">prioritize speed.</st></span></p>
			<h2 id="_idParaDest-103" class="calibre5"><a id="_idTextAnchor112" class="pcalibre pcalibre1 calibre6"/><st c="45298">Constant time search using hashing</st></h2>
			<p class="calibre3"><st c="45333">The primary goal of </st><a id="_idIndexMarker470" class="pcalibre pcalibre1 calibre6"/><st c="45354">hashing is to achieve constant time search by directly mapping keys to their locations in a hash table using a hash function. </st><st c="45480">The </st><a id="_idIndexMarker471" class="pcalibre pcalibre1 calibre6"/><st c="45484">most straightforward hash function is </st><img src="image/1300.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre983"/><st c="45522"/><st c="45536">, where </st><img src="image/1301.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre984"/><st c="45544"/><st c="45545"> is the hash function. </st><st c="45568">This method is known as direct addressing, and the resulting hash table is called a </st><span><st c="45652">direct-address table.</st></span></p>
			<p class="calibre3"><st c="45673">While direct addressing is simple and easy to understand, it comes with several </st><span><st c="45754">significant limitations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="45778">Sparse hash table</st></strong><st c="45796">: Direct addressing often creates a very sparse hash table, meaning that the table size must be as large as the range of possible input keys. </st><st c="45939">For example, if the input keys range from 1 to 1,000,000, the hash table must have 1,000,000 slots, even if only a few keys are actually used. </st><st c="46082">This results in inefficient use </st><span><st c="46114">of memory.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="46124">High likelihood of collisions</st></strong><st c="46154">: In direct addressing, if two different keys map to the same location (collision), it can cause issues with data retrieval and insertion. </st><st c="46294">Although direct addressing assumes that each key is unique, in practice, collisions are </st><span><st c="46382">often unavoidable.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="46400">Limited to numerical data</st></strong><st c="46426">: Direct addressing is only effective for numerical, integer data. </st><st c="46494">It does not work well with other data types, such as strings or composite objects, limiting its applicability in many </st><span><st c="46612">real-world scenarios.</st></span></li>
			</ul>
			<p class="calibre3"><st c="46633">Implementing </st><a id="_idIndexMarker472" class="pcalibre pcalibre1 calibre6"/><st c="46647">constant time search using hashing involves two key steps. </st><st c="46706">First, it is essential to design an efficient hash function that satisfies as </st><a id="_idIndexMarker473" class="pcalibre pcalibre1 calibre6"/><st c="46784">many of the desirable properties as possible. </st><st c="46830">Despite efforts to create a good hash function, collisions are inevitable. </st><st c="46905">Therefore, the second step is to handle collisions effectively during data structure operations, including search </st><span><st c="47019">and retrieval.</st></span></p>
			</div>
	

<div id="_idContainer1448" epub:type="chapter" class="calibre2">
<h3 class="calibre8"><st c="47033">Types of hash function used in search</st></h3>
			<p class="calibre3"><st c="47071">Hash functions are </st><a id="_idIndexMarker474" class="pcalibre pcalibre1 calibre6"/><st c="47091">crucial in determining the efficiency of hash-based search algorithms. </st><st c="47162">Let’s explore some commonly employed hash functions, along with explanations </st><span><st c="47239">and examples.</st></span></p>
			<h4 class="calibre985"><st c="47252">Division-remainder (modulo) method</st></h4>
			<p class="calibre3"><st c="47287">The </st><strong class="bold"><st c="47292">division-remainder (modulo) method</st></strong><st c="47326"> is a</st><a id="_idIndexMarker475" class="pcalibre pcalibre1 calibre6"/><st c="47331"> straightforward and commonly used technique </st><a id="_idIndexMarker476" class="pcalibre pcalibre1 calibre6"/><st c="47376">for generating hash values. </st><st c="47404">In this method, the hash value is obtained by taking the remainder of the division of the key by the size of the hash table. </st><st c="47529">The formula used is </st><span><st c="47549">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1302.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre986"/><st c="47560"/></p>
			<p class="calibre3"><st c="47581">Here, </st><img src="image/1301.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre987"/><st c="47587"/><st c="47588"> is the hash function, </st><img src="image/1304.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre988"/><st c="47611"/><st c="47615"> is the input data, and </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre989"/><st c="47638"/><st c="47639"> is the size of the hash table. </st><st c="47671">Let’s consider an</st><a id="_idIndexMarker477" class="pcalibre pcalibre1 calibre6"/><st c="47688"> example to illustrate how this </st><span><st c="47720">method works.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="47733">Example 7.1</st></strong></span></p>
			<p class="calibre3"><st c="47745">Using the division-remainder hash method, we determine the hash value for the example key, </st><em class="italic"><st c="47837">987654321</st></em><st c="47846">, with a hash table size </st><span><st c="47871">of </st></span><span><em class="italic"><st c="47874">100</st></em></span><span><st c="47877">.</st></span></p>
			<p class="calibre3"><st c="47878">Let’s determine the hash value step </st><span><st c="47915">by step:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="47923">Apply the modulo operation</st></strong><st c="47950">: Calculate the hash value by taking the key modulo the size of the </st><span><st c="48019">hash table:</st></span><p class="calibre3"><img src="image/1306.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;987654321&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;987654321&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre990"/><st c="48030"/></p></li>
				<li class="calibre13"><strong class="bold"><st c="48065">Calculate the remainder</st></strong><st c="48088">: Perform the division and find </st><span><st c="48121">the remainder:</st></span><p class="calibre3"><img src="image/1307.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;987654321&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;21&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre991"/><st c="48135"/></p></li>
			</ol>
			<p class="calibre3"><st c="48137">Therefore, the hash value for the key </st><img src="image/1308.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;987654321&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre992"/><st c="48175"/><st c="48176"> with a hash table size of </st><img src="image/1309.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;100&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre993"/><st c="48203"/> <span><st c="48204">is </st></span><span><img src="image/1310.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;21&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre994"/><st c="48207"/></span><span><st c="48208">.</st></span></p>
			<p class="calibre3"><st c="48209">The modulo operation is straightforward and easy to implement, making this method simple and efficient. </st><st c="48314">It is also computationally efficient, as the modulo operation is relatively fast. </st><st c="48396">Moreover, the same input key will always produce the same hash value, ensuring consistency in the </st><span><st c="48494">hash table.</st></span></p>
			<p class="calibre3"><st c="48505">However, the </st><a id="_idIndexMarker478" class="pcalibre pcalibre1 calibre6"/><st c="48519">modulo method has limitations. </st><st c="48550">If the size of the hash table is poorly chosen (e.g., a power of 2), the hash values may not be uniformly distributed, leading to clustering. </st><st c="48692">To mitigate this issue, prime numbers are typically recommended for the table size. </st><st c="48776">Additionally, if the input keys have patterns or common factors, this method may lead to collisions and clustering, reducing the efficiency of the hash table. </st><st c="48935">Like all hash functions, the division-remainder method can result in collisions. </st><st c="49016">Effective collision handling strategies, such as chaining or open addressing, are necessary to </st><span><st c="49111">maintain performance.</st></span></p>
			<p class="calibre3"><st c="49132">The </st><a id="_idIndexMarker479" class="pcalibre pcalibre1 calibre6"/><st c="49137">division-remainder (modulo) method is a simple and efficient hash function commonly used in various applications. </st><st c="49251">It generates hash values by taking the remainder of the division of the key by the hash table size. </st><st c="49351">While it offers simplicity and computational efficiency, it is important to choose an appropriate table size (preferably a prime number) to ensure a uniform distribution of hash values. </st><st c="49537">Additionally, collision-handling mechanisms are essential to address the inherent limitations of </st><span><st c="49634">this method.</st></span></p>
			<h4 class="calibre985"><st c="49646">Multiplication method</st></h4>
			<p class="calibre3"><st c="49668">The </st><strong class="bold"><st c="49673">multiplication hash method</st></strong><st c="49699"> is a technique used to generate hash values by multiplying</st><a id="_idIndexMarker480" class="pcalibre pcalibre1 calibre6"/><st c="49758"> the key by a constant fraction </st><a id="_idIndexMarker481" class="pcalibre pcalibre1 calibre6"/><st c="49790">and then extracting an appropriate portion of the result to produce the hash code. </st><st c="49873">This method aims to distribute keys more uniformly across the hash table. </st><st c="49947">Let’s explain this method step </st><span><st c="49978">by step:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="49986">Multiply the key by a constant, </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre797"/><st c="50019"/><st c="50020">, </st><span><st c="50022">where </st></span><span><img src="image/1312.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre995"/><st c="50028"/></span><span><st c="50029">.</st></span></li>
				<li class="calibre13"><st c="50030">Extract the fractional part of </st><span><st c="50062">the product.</st></span></li>
				<li class="calibre13"><st c="50074">Multiply the fractional part by the hash table </st><span><st c="50122">size </st></span><span><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre511"/><st c="50127"/></span><span><st c="50128">.</st></span></li>
				<li class="calibre13"><st c="50129">Take the floor of the result to get the </st><span><st c="50170">hash value.</st></span></li>
			</ol>
			<p class="calibre3"><st c="50181">The formula for the hash function is </st><span><st c="50219">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1314.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;⌊&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;⌋&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre996"/><st c="50230"/></p>
			<p class="calibre3"><st c="50261">He</st><a id="_idTextAnchor113" class="pcalibre pcalibre1 calibre6"/><st c="50263">re, </st><img src="image/1315.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0.618033&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre997"/><st c="50268"/><st c="50269"> (an approximation of the golden ratio). </st><st c="50310">Let’s see this method in </st><span><st c="50335">an example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="50346">Example 7.2</st></strong></span></p>
			<p class="calibre3"><st c="50358">Using the</st><a id="_idIndexMarker482" class="pcalibre pcalibre1 calibre6"/><st c="50368"> multiplication </st><a id="_idIndexMarker483" class="pcalibre pcalibre1 calibre6"/><st c="50384">hash method, we d</st><a id="_idTextAnchor114" class="pcalibre pcalibre1 calibre6"/><st c="50401">etermine the hash value for the example key, </st><em class="italic"><st c="50447">123456</st></em><st c="50453">, and a hash table size </st><span><st c="50477">of </st></span><span><em class="italic"><st c="50480">100</st></em></span><span><st c="50483">.</st></span></p>
			<p class="calibre3"><st c="50484">Let’s determine the hash value step </st><span><st c="50521">by step:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="50529">Multiply the key by </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre797"/><st c="50550"/><st c="50551">: </st><img src="image/1317.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;123456&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;0.618033&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;76293.192648&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre998"/><st c="50553"/></li>
				<li class="calibre13"><st c="50554">Extract the fractional </st><span><st c="50577">part: </st></span><span><img src="image/1318.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;0.192648&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre999"/><st c="50583"/></span></li>
				<li class="calibre13"><st c="50584">Multiply by table </st><span><st c="50602">size: </st></span><span><img src="image/1319.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;0.192648&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;19.2648&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1000"/><st c="50608"/></span></li>
				<li class="calibre13"><st c="50609">Take the </st><span><st c="50618">floor: </st></span><span><img src="image/1320.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfenced open=&quot;⌊&quot; close=&quot;⌋&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;19.2648&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;19&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1001"/><st c="50625"/></span></li>
			</ol>
			<p class="calibre3"><st c="50642">Therefore, the hash value for the key </st><em class="italic"><st c="50680">123456</st></em><st c="50686"> with a hash table size of </st><em class="italic"><st c="50713">100</st></em> <span><st c="50716">is </st></span><span><em class="italic"><st c="50720">19</st></em></span><span><st c="50722">.</st></span></p>
			<p class="calibre3"><st c="50723">The multiplication method tends to distribute keys more uniformly across the hash table, thereby reducing clustering. </st><st c="50842">Additionally, unlike the division method, the effectiveness of the multiplication method is less dependent on the table size being a prime number. </st><st c="50989">Moreover, the multiplication and modulo operations are </st><span><st c="51044">computationally efficient.</st></span></p>
			<p class="calibre3"><st c="51070">However, the multiplication method has some limitations. </st><st c="51128">Its effectiveness heavily depends on the choice of the constant </st><img src="image/1321.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1002"/><st c="51192"/><st c="51193">. While the golden ratio is commonly used, other values may need to be tested for optimal performance. </st><st c="51296">For very large keys or highly precise values of </st><img src="image/1322.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1002"/><st c="51344"/><st c="51345">, precision issues in floating-point arithmetic could affect the hash values. </st><st c="51423">Lastly, the need to handle floating-point arithmetic can make the implementation slightly more complex compared to the </st><span><st c="51542">division method.</st></span></p>
			<h4 class="calibre985"><st c="51558">Mid-square method</st></h4>
			<p class="calibre3"><st c="51576">The </st><a id="_idIndexMarker484" class="pcalibre pcalibre1 calibre6"/><st c="51581">mid-square hash function</st><a id="_idIndexMarker485" class="pcalibre pcalibre1 calibre6"/><st c="51605"> is a technique used to generate hash values by squaring the key and then extracting an appropriate number of middle digits or bits from the result. </st><st c="51754">This method aims to distribute keys more uniformly across the hash table, leveraging the properties of squaring to spread out the values. </st><st c="51892">Let’s consider an example to illustrate the mid-square </st><span><st c="51947">hash function.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="51961">Example 7.3</st></strong></span></p>
			<p class="calibre3"><st c="51973">Using the mid-square</st><a id="_idIndexMarker486" class="pcalibre pcalibre1 calibre6"/><st c="51994"> hash method, we determine the hash value for the example key </st><em class="italic"><st c="52056">456</st></em><st c="52059"> with a hash table size </st><span><st c="52083">of </st></span><span><em class="italic"><st c="52086">100</st></em></span><span><st c="52089">:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="52091">Square the key</st></strong><st c="52105">: Square the key to obtain a large </st><span><st c="52141">number: </st></span><span><img src="image/1323.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;456&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;207936&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1003"/><st c="52149"/></span><span><st c="52150">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="52151">Extract the middle digits</st></strong><st c="52177">: Extract an appropriate number of middle digits from the squared value. </st><st c="52251">The number of digits to extract can depend on the size of the hash table. </st><st c="52325">For simplicity, let’s extract two </st><span><st c="52359">middle digits:</st></span><ul class="calibre50"><li class="calibre13"><st c="52373">Squared </st><span><st c="52382">value: </st></span><span><em class="italic"><st c="52389">207936</st></em></span></li><li class="calibre13"><st c="52395">Middle digits: </st><em class="italic"><st c="52411">07</st></em><st c="52413"> (from the middle of the </st><span><st c="52438">squared number)</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="52453">Use the middle digits as the hash value</st></strong><st c="52493">: Use these middle digits to determine the index in the hash table. </st><st c="52562">Therefore, the key </st><em class="italic"><st c="52581">456</st></em><st c="52584"> is mapped to index </st><em class="italic"><st c="52604">07</st></em><st c="52606"> in the </st><span><st c="52614">hash table.</st></span></li>
			</ol>
			<p class="calibre3"><st c="52625">Key</st><a id="_idIndexMarker487" class="pcalibre pcalibre1 calibre6"/><st c="52629"> properties of the mid-square hash function are </st><span><st c="52677">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="52688">Uniform distribution</st></strong><st c="52709">: By squaring the key and extracting the middle digits, this method tends to produce a more uniform distribution of keys, as squaring helps to spread out </st><span><st c="52864">the values.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="52875">Simplicity</st></strong><st c="52886">: The mid-square method is straightforward to implement. </st><st c="52944">It involves squaring the key and then extracting the middle portion of </st><span><st c="53015">the result.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="53026">Independence from key size</st></strong><st c="53053">: This method is relatively independent of the size of the key, making it suitable for various </st><span><st c="53149">key lengths.</st></span></li>
			</ul>
			<p class="calibre3"><st c="53161">On the </st><a id="_idIndexMarker488" class="pcalibre pcalibre1 calibre6"/><st c="53169">other hand, the mid-square method has </st><span><st c="53207">some limitations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="53224">Dependent on middle digits</st></strong><st c="53251">: The efficiency of this method relies on the middle digits of the squared value. </st><st c="53334">If the middle digits are not well distributed, it can lead </st><span><st c="53393">to clustering.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="53407">Selection of digits</st></strong><st c="53427">: Deciding the number of middle digits to extract can be challenging and may require experimentation to optimize for </st><span><st c="53545">specific applications.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="53567">Limited key range</st></strong><st c="53585">: For very small keys, the squared value might not provide enough digits to extract, reducing the effectiveness of </st><span><st c="53701">the method.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="53712">Computational cost</st></strong><st c="53731">: Squaring the key can be computationally expensive for very large keys, especially in environments where processing power </st><span><st c="53855">is limited.</st></span></li>
			</ul>
			<p class="calibre3"><st c="53866">The</st><a id="_idIndexMarker489" class="pcalibre pcalibre1 calibre6"/><st c="53870"> mid-square hash function is an effective method for generating hash codes by squaring the key and extracting the middle digits. </st><st c="53999">This technique leverages the properties of squaring to spread out the values and achieve a more uniform distribution of keys across the hash table. </st><st c="54147">Despite its simplicity and independence from key size, the method’s efficiency depends on the distribution of the middle digits and may involve some computational cost for large keys. </st><st c="54331">Overall, the mid-square hash function remains a useful tool in the design of hash functions for </st><span><st c="54427">various applications.</st></span></p>
			<h4 class="calibre985"><st c="54448">Folding method</st></h4>
			<p class="calibre3"><st c="54463">The</st><a id="_idIndexMarker490" class="pcalibre pcalibre1 calibre6"/><st c="54467"> folding hash function is a technique used to generate</st><a id="_idIndexMarker491" class="pcalibre pcalibre1 calibre6"/><st c="54521"> hash codes by splitting the key into several parts, adding these parts together, and then taking the modulus with the table size to produce the hash code. </st><st c="54677">This method is particularly useful for large keys, such as phone numbers or identification numbers, and aims to distribute keys more uniformly across the hash table. </st><st c="54843">Let’s consider a practical example to illustrate the folding </st><span><st c="54904">hash function.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="54918">Example 7.4</st></strong></span></p>
			<p class="calibre3"><st c="54930">Using the folding</st><a id="_idIndexMarker492" class="pcalibre pcalibre1 calibre6"/><st c="54948"> hash method, we determine the hash value for the example key </st><em class="italic"><st c="55010">987654321</st></em><st c="55019"> with a hash table size </st><span><st c="55043">of </st></span><span><em class="italic"><st c="55046">100</st></em></span><span><st c="55049">:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="55051">Split the key</st></strong><st c="55064">: Divide the key into equal parts. </st><st c="55100">For simplicity, let’s split it into parts of 3 digits </st><span><st c="55154">each: </st></span><span><img src="image/1324.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;987&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;654&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;321&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1004"/><st c="55160"/></span></li>
				<li class="calibre13"><strong class="bold"><st c="55161">Add the parts</st></strong><st c="55174">: Sum the parts </st><span><st c="55191">together: </st></span><span><img src="image/1325.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;987&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;654&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;321&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1962&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1005"/><st c="55201"/></span></li>
				<li class="calibre13"><strong class="bold"><st c="55202">Take the modulus</st></strong><st c="55218">: Take the modulus of the sum with the table size to get the hash </st><span><st c="55285">code: </st></span><span><img src="image/1326.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;1962&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;62&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1006"/><st c="55291"/></span><span><span><img src="image/1327.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;1962&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;62&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1007"/><st c="55292"/></span></span></li>
			</ol>
			<p class="calibre3"><st c="55305">Therefore, the</st><a id="_idIndexMarker493" class="pcalibre pcalibre1 calibre6"/><st c="55319"> key </st><img src="image/1308.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;987654321&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre992"/><st c="55324"/><st c="55325"> is mapped to index </st><img src="image/1329.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;62&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre110"/><st c="55345"/><st c="55346"> in the </st><span><st c="55354">hash table.</st></span></p>
			<p class="calibre3"><st c="55365">The </st><a id="_idIndexMarker494" class="pcalibre pcalibre1 calibre6"/><st c="55370">folding </st><a id="_idIndexMarker495" class="pcalibre pcalibre1 calibre6"/><st c="55378">hash method has the </st><span><st c="55398">following properties:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="55419">Uniform distribution</st></strong><st c="55440">: The folding method aims to produce a more uniform distribution of keys by ensuring that all parts of the key contribute to the hash value. </st><st c="55582">This helps to reduce clustering and improve the overall performance of the </st><span><st c="55657">hash table.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="55668">Simplicity</st></strong><st c="55679">: The algorithm is straightforward to implement and understand. </st><st c="55744">It simply involves splitting, summing, and taking </st><span><st c="55794">the modulus.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="55806">Flexibility</st></strong><st c="55818">: It can handle keys of various sizes by adjusting the way the key is split </st><span><st c="55895">into parts.</st></span></li>
			</ul>
			<p class="calibre3"><st c="55906">On the other side, folding </st><a id="_idIndexMarker496" class="pcalibre pcalibre1 calibre6"/><st c="55934">hash comes with </st><span><st c="55950">its limitations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="55966">Dependent on key structure</st></strong><st c="55993">: The efficiency of the folding hash function depends on the structure of the keys. </st><st c="56078">If the parts of the key have similar patterns or values, it may not distribute the </st><span><st c="56161">keys uniformly.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="56176">Not ideal for small keys</st></strong><st c="56201">: For small keys, the overhead of splitting and summing may not provide significant benefits over simpler hash functions such </st><span><st c="56328">as division-remainder.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="56350">Handling different lengths</st></strong><st c="56377">: If keys have varying lengths, it might be challenging to decide how to split them uniformly, potentially leading to </st><span><st c="56496">uneven distribution.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="56516">Sum overflow</st></strong><st c="56529">: For very large keys, the sum of the parts might exceed the typical integer range, causing overflow issues. </st><st c="56639">However, this can be mitigated by using modular </st><a id="_idIndexMarker497" class="pcalibre pcalibre1 calibre6"/><st c="56687">arithmetic at </st><span><st c="56701">each step.</st></span></li>
			</ul>
			<p class="calibre3"><st c="56711">The folding hash function is an effective and straightforward method for hashing large keys. </st><st c="56805">By</st><a id="_idIndexMarker498" class="pcalibre pcalibre1 calibre6"/><st c="56807"> splitting the key into parts, summing these parts, and then taking the modulus, it can produce a relatively uniform distribution of hash values, improving the performance of hash tables. </st><st c="56995">However, its efficiency can be affected by the structure of the keys, the need to handle different key lengths, and potential overflow issues. </st><st c="57138">Despite these limitations, the folding method remains a valuable tool in the design of hash functions for </st><span><st c="57244">various applications.</st></span></p>
			<h4 class="calibre985"><st c="57265">Universal hashing</st></h4>
			<p class="calibre3"><st c="57283">The</st><a id="_idIndexMarker499" class="pcalibre pcalibre1 calibre6"/><st c="57287"> universal hash method is a technique designed</st><a id="_idIndexMarker500" class="pcalibre pcalibre1 calibre6"/><st c="57333"> to minimize the probability of collisions in a hash table. </st><st c="57393">It involves using a family of hash functions and randomly selecting one of these functions for hashing. </st><st c="57497">This method provides a probabilistic guarantee that the number of collisions will be low, making it particularly useful in applications where security and performance are critical. </st><st c="57678">The following is the step-by-step implementation of the </st><span><st c="57734">universal method:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="57751">Define a family of hash functions </st><img src="image/1330.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;H&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1008"/><st c="57786"/><st c="57787"> from which a specific function </st><img src="image/1331.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mi mathvariant=&quot;bold-italic&quot;&gt;H&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1009"/><st c="57819"/><st c="57820"> is chosen. </st><st c="57832">Each hash function </st><img src="image/1332.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1010"/><st c="57851"/><st c="57852"> in the family should be able to map keys uniformly across the </st><span><st c="57915">hash table.</st></span></li>
				<li class="calibre13"><st c="57926">Randomly select a hash function </st><img src="image/1332.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1010"/><st c="57959"/><st c="57960"> from the family </st><img src="image/1334.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;H&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1011"/><st c="57977"/><st c="57978"> to use for hashing </st><span><st c="57998">the keys.</st></span></li>
				<li class="calibre13"><st c="58007">Use the selected hash function </st><img src="image/1332.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1010"/><st c="58039"/><st c="58040"> to compute the hash values of </st><span><st c="58071">the keys.</st></span></li>
			</ul>
			<p class="calibre3"><span><strong class="bold"><st c="58080">Example 7.5</st></strong></span></p>
			<p class="calibre3"><st c="58092">Using the folding </st><a id="_idIndexMarker501" class="pcalibre pcalibre1 calibre6"/><st c="58111">hash method, let’s determine the hash value for the example key </st><em class="italic"><st c="58175">123456</st></em><st c="58181"> with a hash table size </st><span><st c="58205">of </st></span><span><em class="italic"><st c="58208">100</st></em></span><span><st c="58211">.</st></span></p>
			<p class="calibre3"><st c="58212">Let’s </st><span><st c="58219">calculate </st></span><span><img src="image/1336.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1012"/><st c="58229"/></span></p>
			<p class="calibre3"><st c="58260">Here,</st><img src="image/1337.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1013"/><st c="58265"/><st c="58267"> is a prime number larger than any possible key,</st><img src="image/1338.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1014"/><st c="58315"/><st c="58317"> and </st><img src="image/993.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1015"/><st c="58322"/><st c="58323"> are randomly chosen integers such that </st><img src="image/1340.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1016"/><st c="58363"/><st c="58372"> and  </st><img src="image/1341.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;&lt;&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1017"/><st c="58376"/><st c="58386">, and</st><img src="image/1342.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1018"/><st c="58391"/><st c="58393"> is the size of the </st><span><st c="58413">hash table.</st></span></p>
			<p class="calibre3"><st c="58424">Now, we use the following parameters in </st><span><st c="58465">this example:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><span><st c="58478">Key: </st></span><span><em class="italic"><st c="58484">123456</st></em></span></li>
				<li class="calibre13"><st c="58490">Table size </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre511"/><st c="58502"/><st c="58503">: </st><span><em class="italic"><st c="58505">100</st></em></span></li>
				<li class="calibre13"><st c="58508">Prime number </st><img src="image/969.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre751"/><st c="58522"/><st c="58523">: </st><span><em class="italic"><st c="58525">101</st></em></span></li>
				<li class="calibre13"><st c="58528">Randomly chosen </st><img src="image/460.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre372"/><st c="58545"/><st c="58565"> and </st><img src="image/493.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre398"/><st c="58569"/><st c="58570">: Let’s assume </st><img src="image/1347.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;34&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1019"/><st c="58585"/> <span><st c="58586">and </st></span><span><img src="image/1348.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre646"/><st c="58590"/></span></li>
				<li class="calibre13"><st c="58591">We compute the </st><span><st c="58606">hash value:</st></span><p class="calibre3"><img src="image/1349.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;34,7&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;123456&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;34&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;123456&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;101&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1020"/><st c="58617"/></p></li>
				<li class="calibre13"><st c="58668">First, we calculate the </st><span><st c="58692">intermediate values:</st></span><p class="calibre3"><img src="image/1350.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;34&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;123456&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;41&lt;/mn&gt;&lt;mn&gt;97503&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1021"/><st c="58712"/></p><p class="calibre3"><img src="image/1351.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;97503&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;101&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;90&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1022"/><st c="58714"/></p></li>
				<li class="calibre13"><st c="58715">Then, we calculate the final hash </st><span><st c="58749">value: </st></span><span><img src="image/1352.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;90&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;90&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1023"/><st c="58756"/></span><p class="calibre3"><st c="58757">Therefore, the hash value for the key </st><em class="italic"><st c="58795">123456</st></em><st c="58801"> with the selected parameters </st><span><st c="58831">is </st></span><span><em class="italic"><st c="58834">90</st></em></span><span><st c="58836">.</st></span></p></li>
			</ul>
			<p class="calibre3"><st c="58837">Universal hashing </st><a id="_idIndexMarker502" class="pcalibre pcalibre1 calibre6"/><st c="58856">significantly reduces the probability of </st><a id="_idIndexMarker503" class="pcalibre pcalibre1 calibre6"/><st c="58897">collisions, offering a strong probabilistic guarantee that different keys will hash to different values. </st><st c="59002">By randomly selecting a hash function from a family, it also provides resistance against adversarial attacks, making it useful in cryptographic applications. </st><st c="59160">Furthermore, this method can be adapted to various key distributions by choosing an appropriate family of </st><span><st c="59266">hash functions.</st></span></p>
			<p class="calibre3"><st c="59281">However, universal hashing has some limitations. </st><st c="59331">Defining and implementing a family of hash functions is more complex compared to simpler methods such as division-remainder or multiplication. </st><st c="59474">Additionally, the need to randomly select a hash function and compute potentially more complex hash values can introduce additional computational overhead. </st><st c="59630">Lastly, the effectiveness of universal hashing relies on the true randomness of the chosen hash function, which may be difficult to achieve in </st><span><st c="59773">some environments.</st></span></p>
			<p class="calibre3"><st c="59791">The next two methods are tailored for hashing string data, where characters in the string contribute to the </st><span><st c="59900">hash code.</st></span></p>
			<h4 class="calibre985"><st c="59910">Polynomial hashing for strings</st></h4>
			<p class="calibre3"><strong class="bold"><st c="59941">Polynomial hashing</st></strong><st c="59960"> (also known as </st><strong class="bold"><st c="59976">Rabin-Karp rolling hash</st></strong><st c="59999">) is a</st><a id="_idIndexMarker504" class="pcalibre pcalibre1 calibre6"/><st c="60006"> technique to efficiently </st><a id="_idIndexMarker505" class="pcalibre pcalibre1 calibre6"/><st c="60032">calculate </st><a id="_idIndexMarker506" class="pcalibre pcalibre1 calibre6"/><st c="60042">hash values for substrings within a larger string. </st><st c="60093">It treats the characters of the string as coefficients of a polynomial, where each character’s ASCII (or Unicode) value is multiplied by a prime number raised to a power corresponding to its position in the string. </st><st c="60308">In the polynomial hashing method, each character in the string is treated as a coefficient in a polynomial. </st><st c="60416">The hash</st><a id="_idIndexMarker507" class="pcalibre pcalibre1 calibre6"/><st c="60424"> code is the polynomial evaluated at a certain value. </st><st c="60478">For the string </st><em class="italic"><st c="60493">abcd</st></em><st c="60497"> and a chosen base of </st><img src="image/1353.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;31&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1024"/><st c="60519"/><st c="60520">, the hash code can be calculated as </st><span><st c="60557">the following:</st></span></p>
			<p class="calibre3"><img src="image/1354.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mtext&gt;abcd&lt;/mtext&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;31&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;31&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;31&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1025"/><st c="60571"/></p>
			<p class="calibre3"><st c="60627">Polynomial hashing is </st><a id="_idIndexMarker508" class="pcalibre pcalibre1 calibre6"/><st c="60649">implemented in the </st><span><st c="60668">following steps:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="60684">Initialization</st></strong><st c="60699">: Choose a prime number </st><img src="image/1355.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1026"/><st c="60724"/><st c="60725"> (commonly 11 or 31) and a modulus </st><img src="image/1356.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1027"/><st c="60760"/><st c="60761"> (often a large prime number to minimize collisions that corresponds to the size of the </st><span><st c="60849">hash table).</st></span></li>
				<li class="calibre13"><span><strong class="bold"><st c="60861">Hash calculation</st></strong></span><span><st c="60878">:</st></span><ol class="calibre1028"><li class="upper-roman"><st c="60880">Initialize the hash value </st><span><st c="60906">to </st></span><span><em class="italic"><st c="60909">0</st></em></span><span><st c="60910">.</st></span></li><li class="upper-roman"><st c="60911">Iterate over each character in </st><span><st c="60943">the string.</st></span></li><li class="upper-roman"><st c="60954">For each character, do </st><span><st c="60978">the following:</st></span></li></ol><ul class="calibre50"><li class="calibre13"><st c="60992">Multiply the current hash value </st><span><st c="61025">by </st></span><span><img src="image/969.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre751"/><st c="61028"/></span><span><st c="61029">.</st></span></li><li class="calibre13"><st c="61030">Add the ASCII value of </st><span><st c="61054">the character.</st></span></li><li class="calibre13"><st c="61068">Apply the modulo </st><img src="image/1358.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1029"/><st c="61086"/><st c="61087"> operation to the result to ensure the hash value remains within a </st><span><st c="61154">manageable range.</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="61171">Rolling hash</st></strong><st c="61184">: To compute the hash of a substring, we can subtract the hash of the characters that are no longer part of the substring and add the hash of the newly included characters. </st><st c="61358">This “rolling” update is efficient and allows for fast comparisons of </st><span><st c="61428">different substrings.</st></span></li>
			</ol>
			<p class="calibre3"><st c="61449">The following is</st><a id="_idIndexMarker509" class="pcalibre pcalibre1 calibre6"/><st c="61466"> a Python example of </st><span><st c="61487">polynomial hashing:</st></span></p>
			<pre class="source-code"><st c="61506" class="calibre11">
def polynomial_hash(string, p=11, m=2**31):
  hash_value = 0
  for char in string:
    hash_value = (hash_value * p + ord(char)) % m
  return hash_value
# Example usage
string = "Hello"
hash_value = polynomial_hash(string)
print(f"The polynomial hash value of '{string}' is: {hash_value}")</st></pre>			<p class="calibre3"><st c="61786">Let’s explain</st><a id="_idIndexMarker510" class="pcalibre pcalibre1 calibre6"/><st c="61800"> the example </st><span><st c="61813">Python code:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="61825">The </st><strong class="source-inline1"><st c="61830">polynomial_hash</st></strong><st c="61845"> function takes a string as input along with optional parameters, </st><strong class="source-inline1"><st c="61911">p</st></strong><st c="61912"> (prime number) and </st><span><strong class="source-inline1"><st c="61932">m</st></strong></span><span><st c="61933"> (modulus)</st></span></li>
				<li class="calibre13"><st c="61943">It initializes </st><strong class="source-inline1"><st c="61959">hash_value</st></strong> <span><st c="61969">to </st></span><span><strong class="source-inline1"><st c="61973">0</st></strong></span></li>
				<li class="calibre13"><st c="61974">It iterates over each character (</st><strong class="source-inline1"><st c="62007">char</st></strong><st c="62012">) in </st><span><st c="62018">the string</st></span></li>
				<li class="calibre13"><st c="62028">For each character, it performs the hash </st><span><st c="62070">update calculation:</st></span><ul class="calibre50"><li class="calibre13"><strong class="source-inline1"><st c="62089">hash_value * p</st></strong><st c="62104"> effectively shifts the previous characters one position to the left in </st><span><st c="62176">the polynomial</st></span></li><li class="calibre13"><strong class="source-inline1"><st c="62190">ord</st></strong><st c="62194">(char) gets the ASCII value of </st><span><st c="62226">the character</st></span></li><li class="calibre13"><st c="62239">The result is taken modulo </st><strong class="source-inline1"><st c="62267">m</st></strong><st c="62268"> to prevent overflow and ensure a consistent range for the </st><span><st c="62327">hash values</st></span></li><li class="calibre13"><st c="62338">Finally, it returns the computed </st><span><st c="62372">hash value</st></span></li><li class="calibre13"><st c="62382">The polynomial hash value of </st><strong class="source-inline1"><st c="62412">"Hello"</st></strong> <span><st c="62419">is </st></span><span><strong class="source-inline1"><st c="62423">99162322</st></strong></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="62431">Polynomial hashing is </st><a id="_idIndexMarker511" class="pcalibre pcalibre1 calibre6"/><st c="62454">particularly efficient for comparing substrings within a larger string. </st><st c="62526">It avoids recalculating the entire hash for each substring, making it suitable for applications such as plagiarism detection or pattern matching. </st><st c="62672">Collisions are still possible, especially if the modulus </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre511"/><st c="62729"/><st c="62730"> is not chosen carefully. </st><st c="62756">Using a large prime number for </st><img src="image/1360.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1030"/><st c="62787"/><st c="62788"> can help reduce collision frequency. </st><st c="62826">The choice of prime number </st><img src="image/969.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1031"/><st c="62853"/><st c="62854"> and modulus </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1032"/><st c="62867"/><st c="62868"> can affect performance and collision probability. </st><st c="62919">Experimentation might be needed to find optimal values for </st><span><st c="62978">specific applications.</st></span></p>
			<h4 class="calibre985"><st c="63000">DJB2 hash function for strings</st></h4>
			<p class="calibre3"><st c="63031">The </st><strong class="bold"><st c="63036">DJB2 hash function</st></strong><st c="63054"> is a </st><a id="_idIndexMarker512" class="pcalibre pcalibre1 calibre6"/><st c="63060">simple and effective algorithm </st><a id="_idIndexMarker513" class="pcalibre pcalibre1 calibre6"/><st c="63091">for generating hash values (numeric representations) from strings. </st><st c="63158">It is known for its speed and decent distribution of hash values, making it suitable for various applications such as hash tables. </st><st c="63289">The following are the four steps of this </st><span><st c="63330">hash function:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="63344">Initialization</st></strong><st c="63359">: The </st><a id="_idIndexMarker514" class="pcalibre pcalibre1 calibre6"/><st c="63366">hash value is initialized to a starting value of </st><em class="italic"><st c="63415">5381</st></em><st c="63419">. This initial value was chosen somewhat arbitrarily but has proven to work well </st><span><st c="63500">in practice.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="63512">Iteration</st></strong><st c="63522">: The function iterates over each character in the </st><span><st c="63574">input string.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="63587">Hash update</st></strong><st c="63599">: For each character, the current hash value is multiplied by 33 (left-shifted by 5 bits and then added to itself). </st><st c="63716">The ASCII value of the character is added to the </st><span><st c="63765">hash value.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="63776">Finalization</st></strong><st c="63789">: After processing all characters, the hash value is typically masked to ensure it fits within a 32-bit unsigned </st><span><st c="63903">integer range.</st></span></li>
			</ol>
			<p class="calibre3"><st c="63917">The following is a Python example of this </st><span><st c="63960">hash function:</st></span></p>
			<pre class="source-code"><st c="63974" class="calibre11">
def djb2(string):
  hash = 5381
  for char in string:
    hash = ((hash &lt;&lt; 5) + hash) + ord(char)
  return hash &amp; 0xFFFFFFFF</st></pre>			<p class="calibre3"><st c="64089">The </st><strong class="source-inline"><st c="64094">djb2</st></strong><st c="64098"> function takes a string as input. </st><st c="64133">It initializes the hash variable to </st><strong class="source-inline"><st c="64169">5381</st></strong><st c="64173">. It iterates over each character (</st><strong class="source-inline"><st c="64208">char</st></strong><st c="64213">) in the string. </st><st c="64231">For each character, it performs the hash update calculation: </st><strong class="source-inline"><st c="64292">(hash &lt;&lt; 5) + hash</st></strong><st c="64310"> is equivalent to multiplying </st><strong class="source-inline"><st c="64340">hash</st></strong> <span><st c="64344">by </st></span><span><strong class="source-inline"><st c="64348">33</st></strong></span><span><st c="64350">.</st></span></p>
			<p class="calibre3"><strong class="source-inline"><st c="64351">ord(char)</st></strong><st c="64361"> gets</st><a id="_idIndexMarker515" class="pcalibre pcalibre1 calibre6"/><st c="64366"> the ASCII value of the character. </st><st c="64401">Finally, it returns the hash value after masking it to a 32-bit unsigned integer. </st><st c="64483">For example, if </st><strong class="source-inline"><st c="64499">string = "Hello"</st></strong><st c="64515">, the DJB2 hash function generates </st><strong class="source-inline"><st c="64550">99162322</st></strong> <span><st c="64558">as output.</st></span></p>
			<p class="calibre3"><st c="64569">DJB2 is </st><a id="_idIndexMarker516" class="pcalibre pcalibre1 calibre6"/><st c="64578">relatively easy to understand and implement. </st><st c="64623">It’s computationally fast, which is advantageous in performance-critical scenarios. </st><st c="64707">While DJB2 generally performs well, it’s not perfect and collisions can occur, especially with very </st><span><st c="64807">large datasets.</st></span></p>
			<h3 class="calibre8"><st c="64822">Collision handling</st></h3>
			<p class="calibre3"><st c="64841">One of the primary challenges in using hash functions is dealing with collisions. </st><st c="64924">Collisions</st><a id="_idIndexMarker517" class="pcalibre pcalibre1 calibre6"/><st c="64934"> occur when two different </st><a id="_idIndexMarker518" class="pcalibre pcalibre1 calibre6"/><st c="64960">keys produce the same hash value, leading to potential conflicts in data retrieval and storage. </st><st c="65056">Efficiently handling collisions is crucial for maintaining the performance and reliability of hash tables. </st><st c="65163">Various strategies, such as chaining and open addressing, are employed to address this problem, but each comes with its own set of trade-offs and complexities. </st><st c="65323">Understanding and mitigating the collision problem is essential for designing robust and efficient hash-based data structures. </st><st c="65450">Here are the main types of collision handling techniques, each explained with examples, limitations, </st><span><st c="65551">and properties.</st></span></p>
			<h4 class="calibre985"><st c="65566">Chaining</st></h4>
			<p class="calibre3"><st c="65575">In</st><a id="_idIndexMarker519" class="pcalibre pcalibre1 calibre6"/><st c="65578"> chaining, each position in the hash table points to a linked list (or chain) of </st><a id="_idIndexMarker520" class="pcalibre pcalibre1 calibre6"/><st c="65659">elements that hash to the same index. </st><st c="65697">When a collision occurs, the new element is simply added to the end of </st><span><st c="65768">the list.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="65777">Example 7.6</st></strong></span></p>
			<p class="calibre3"><st c="65789">Here, we are</st><a id="_idIndexMarker521" class="pcalibre pcalibre1 calibre6"/><st c="65802"> handling collision</st><a id="_idIndexMarker522" class="pcalibre pcalibre1 calibre6"/><st c="65821"> using chaining for a hash table of size </st><em class="italic"><st c="65862">10</st></em><st c="65864"> and keys </st><em class="italic"><st c="65874">12</st></em><st c="65876">, </st><em class="italic"><st c="65878">22</st></em><st c="65880">, and </st><em class="italic"><st c="65886">32</st></em><st c="65888"> (all produce a hash value of </st><em class="italic"><st c="65918">2</st></em> <span><st c="65919">with </st></span><span><img src="image/1363.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1033"/><st c="65924"/></span><span><st c="65940">).</st></span></p>
			<table id="table001-4" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="65942">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="65948">Hash table</st></strong></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65959">0</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65961">1</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65962">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="65963">12 </st><span lang="ar-SA" xml:lang="ar-SA"><st c="65966">à</st></span> <span><st c="65967">22</st></span><span lang="ar-SA" xml:lang="ar-SA"><st c="65969">à</st></span><span><st c="65971"> 32</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65974">3</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65976">4</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65977">5</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65978">6</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65979">7</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65980">8</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="65981">9</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="65982">Table 7.1 – An example of handling collision using chaining</st></p>
			<p class="calibre3"><st c="66041">Chaining is</st><a id="_idIndexMarker523" class="pcalibre pcalibre1 calibre6"/><st c="66053"> straightforward to implement and supports dynamic sizing, allowing the lists to grow as more elements are added. </st><st c="66167">However, this approach requires additional memory for the linked lists. </st><st c="66239">Moreover, if many collisions occur, chains can become long, leading to </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="66310"/><st c="66311"> time complexity in the worst case. </st><st c="66347">In the average case, the running time for insert, delete, and search operations is </st><img src="image/1365.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1034"/><st c="66430"/><st c="66431"> if the chains are short. </st><st c="66457">For a more precise analysis, it is essential to introduce the </st><span><st c="66519">load factor.</st></span></p>
			<p class="calibre3"><st c="66531">The load factor, often denoted as </st><img src="image/1366.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;λ&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1015"/><st c="66566"/><st c="66567">, is a crucial concept in the context of hash tables, including those using chaining for collision handling. </st><st c="66676">It measures how full the hash table is and is defined as the ratio of the number of elements </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="66769"/><st c="66818"> in the hash table to the number of slots </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre511"/><st c="66859"/><st c="66860"> in </st><span><st c="66864">the table:</st></span></p>
			<p class="calibre3"><img src="image/1369.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;λ&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1035"/><st c="66874"/></p>
			<p class="calibre3"><st c="66881">The load factor helps in understanding the performance of the hash table. </st><st c="66955">A low load factor indicates that the table has many empty slots, leading to shorter chains and faster average search times. </st><st c="67079">A high load factor, on the other hand, indicates longer chains and potentially slower </st><span><st c="67165">search times.</st></span></p>
			<p class="calibre3"><st c="67178">Revisiting</st><a id="_idIndexMarker524" class="pcalibre pcalibre1 calibre6"/><st c="67189"> the running time of basic operations (insert, delete, and search) with </st><a id="_idIndexMarker525" class="pcalibre pcalibre1 calibre6"/><st c="67261">chaining for collision handling, the average running time is </st><img src="image/1370.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;λ&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1036"/><st c="67322"/><st c="67323"> This includes the constant time to access a slot in the hash table and </st><img src="image/1366.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;λ&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1037"/><st c="67395"/><st c="67396"> to scan the chain, which is, on average, of size </st><img src="image/1366.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;λ&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1037"/><st c="67446"/><st c="67447">, assuming that data is uniformly distributed across slots to create evenly </st><span><st c="67523">sized chains.</st></span></p>
			<p class="calibre3"><st c="67536">In many implementations, the load factor is used as a threshold to decide when to resize the hash table. </st><st c="67642">When the load factor exceeds a certain value, the hash table is resized (typically doubled in size) to maintain </st><span><st c="67754">efficient operations.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="67775">Example 7.7</st></strong></span></p>
			<p class="calibre3"><st c="67787">Consider a hash table with 10 slots (size </st><img src="image/1373.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1038"/><st c="67830"/><st c="67831">) and the following keys: </st><em class="italic"><st c="67857">12</st></em><st c="67859">, </st><em class="italic"><st c="67861">22</st></em><st c="67863">, </st><em class="italic"><st c="67865">32</st></em><st c="67867">, </st><em class="italic"><st c="67869">42</st></em><st c="67871">, and </st><em class="italic"><st c="67877">52</st></em><st c="67879">. Let’s use a simple </st><span><st c="67900">hash function:</st></span></p>
			<p class="calibre3"><img src="image/1374.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1039"/><st c="67914"/><st c="67936">:</st></p>
			<p class="calibre3"><st c="67937">The hash values are </st><em class="italic"><st c="67957">2</st></em><st c="67958">, </st><em class="italic"><st c="67960">2</st></em><st c="67961">, </st><em class="italic"><st c="67963">2</st></em><st c="67964">, </st><em class="italic"><st c="67966">2</st></em><st c="67967">, and </st><em class="italic"><st c="67973">2</st></em><st c="67974">. All keys are stored in the chain at </st><span><st c="68012">index </st></span><span><em class="italic"><st c="68018">2</st></em></span><span><st c="68019">:</st></span></p>
			<table id="table002-3" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="68020">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="68025">Hash table</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68036">0</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68038">1</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68039">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="68040">12 </st><span lang="ar-SA" xml:lang="ar-SA"><st c="68043">à</st></span><st c="68044"> 22</st><span lang="ar-SA" xml:lang="ar-SA"><st c="68047">à</st></span> <span><st c="68049">32</st></span><span lang="ar-SA" xml:lang="ar-SA"><st c="68051">à</st></span><span><st c="68053">42</st></span><span lang="ar-SA" xml:lang="ar-SA"><st c="68055">à</st></span><span><st c="68057"> 52</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68060">3</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68062">4</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68063">5</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68064">6</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68065">7</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68066">8</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="68067">9</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="68068">Table 7.2 – An example of handling collision using simple chaining</st></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="68134">Number of elements:  </st><img src="image/1375.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1040"/><st c="68155"/></li>
				<li class="calibre13"><st c="68156">Number of slots:  </st><img src="image/1376.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1041"/><st c="68173"/></li>
				<li class="calibre13"><st c="68174">Load factor:  </st><img src="image/1377.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;λ&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;5&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;10&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0.5&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1042"/><st c="68187"/></li>
			</ul>
			<p class="calibre3"><st c="68188">The </st><a id="_idIndexMarker526" class="pcalibre pcalibre1 calibre6"/><st c="68192">properties </st><a id="_idIndexMarker527" class="pcalibre pcalibre1 calibre6"/><st c="68203">of the load factor are </st><span><st c="68226">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="68237">A lower load factor generally means higher efficiency, as chains are shorter and search times </st><span><st c="68332">are quicker</st></span></li>
				<li class="calibre13"><st c="68343">A higher load factor indicates better memory utilization, as more slots are being used, but it can also lead to decreased performance due to </st><span><st c="68485">longer chains</st></span></li>
				<li class="calibre13"><st c="68498">Maintaining an optimal load factor (typically below 0.75) often involves dynamic resizing of the hash table to balance between performance and </st><span><st c="68642">memory utilization</st></span></li>
			</ul>
			<p class="calibre3"><st c="68660">However, the</st><a id="_idIndexMarker528" class="pcalibre pcalibre1 calibre6"/><st c="68673"> load factor </st><span><st c="68686">has limitations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="68702">As the load factor increases, the chains at each index grow longer, leading to increased search, insertion, and </st><span><st c="68815">deletion times</st></span></li>
				<li class="calibre13"><st c="68829">A higher load factor increases the likelihood of collisions, which can degrade the performance of the </st><span><st c="68932">hash table</st></span></li>
				<li class="calibre13"><st c="68942">Frequent resizing to maintain an optimal load factor can introduce overhead and impact performance during the </st><span><st c="69053">resize operation</st></span></li>
			</ul>
			<p class="calibre3"><st c="69069">Many hash table implementations set a threshold load factor (e.g., </st><em class="italic"><st c="69137">0.75</st></em><st c="69141">). </st><st c="69145">When the load factor exceeds this threshold, the table is resized. </st><st c="69212">Upon resizing, a common strategy is to double the size of the hash table and rehash all existing elements to the </st><span><st c="69325">new table.</st></span></p>
			<h4 class="calibre985"><st c="69335">Open addressing</st></h4>
			<p class="calibre3"><st c="69351">Open addressing</st><a id="_idIndexMarker529" class="pcalibre pcalibre1 calibre6"/><st c="69367"> handles collisions directly within the</st><a id="_idIndexMarker530" class="pcalibre pcalibre1 calibre6"/><st c="69406"> hash table by using a systematic sequence of probes to find an empty slot for each key. </st><st c="69495">When a collision occurs, the algorithm probes the table according to a specific strategy until it finds an empty slot. </st><st c="69614">Here, we introduce three common types of open addressing – linear probing, quadratic probing, and </st><span><st c="69712">double hashing:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="69727">Linear probing</st></strong><st c="69742">: When</st><a id="_idIndexMarker531" class="pcalibre pcalibre1 calibre6"/><st c="69749"> a collision occurs, linear probing checks the next slot in the table, continuing this process until an empty slot </st><span><st c="69864">is found.</st></span><p class="calibre3"><span><strong class="bold"><st c="69873">Example 7.8</st></strong></span></p><p class="calibre3"><st c="69885">To </st><a id="_idIndexMarker532" class="pcalibre pcalibre1 calibre6"/><st c="69889">handle </st><a id="_idIndexMarker533" class="pcalibre pcalibre1 calibre6"/><st c="69896">collisions using linear probing for a </st><a id="_idIndexMarker534" class="pcalibre pcalibre1 calibre6"/><st c="69934">hash table of size </st><em class="italic"><st c="69953">10</st></em><st c="69955"> and keys </st><em class="italic"><st c="69965">12</st></em><st c="69967">, </st><em class="italic"><st c="69969">13</st></em><st c="69971">, </st><em class="italic"><st c="69973">22</st></em><st c="69975">, and </st><em class="italic"><st c="69981">32</st></em><st c="69983">, we use the hash function </st><img src="image/1378.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1043"/><st c="70010"/><st c="70026">. The hash values for these keys are </st><em class="italic"><st c="70063">2</st></em><st c="70064">, </st><em class="italic"><st c="70066">3</st></em><st c="70067">, </st><em class="italic"><st c="70069">2</st></em><st c="70070">, and </st><span><em class="italic"><st c="70076">2</st></em></span><span><st c="70077">, respectively.</st></span></p></li>
			</ul>
			<ol class="calibre12">
				<li class="calibre13"><st c="70092">Calculate </st><span><st c="70103">hash values:</st></span><ul class="calibre50"><li class="calibre13"><st c="70115">For key </st><em class="italic"><st c="70124">12</st></em><st c="70126">: </st><img src="image/1379.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1044"/><st c="70129"/><st c="70130"> 2</st></li><li class="calibre13"><st c="70132">For key </st><span><em class="italic"><st c="70140">13</st></em></span><span><st c="70142">: </st></span><span><img src="image/1380.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1045"/><st c="70145"/></span></li><li class="calibre13"><st c="70146">For key </st><span><em class="italic"><st c="70154">22</st></em></span><span><st c="70156">: </st></span><span><img src="image/1381.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1045"/><st c="70159"/></span></li><li class="calibre13"><st c="70160">For key </st><span><em class="italic"><st c="70168">32</st></em></span><span><st c="70170">: </st></span><span><img src="image/1382.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1044"/><st c="70173"/></span><span><st c="70174">2</st></span></li></ul></li>
				<li class="calibre13"><st c="70175">Handle collisions using </st><span><st c="70199">linear probing:</st></span><ul class="calibre50"><li class="calibre13"><st c="70214">Key </st><em class="italic"><st c="70219">12</st></em><st c="70221"> hashes to index </st><em class="italic"><st c="70238">2</st></em><st c="70239">, so it is placed at </st><span><st c="70260">index </st></span><span><em class="italic"><st c="70266">2</st></em></span><span><st c="70267">.</st></span></li><li class="calibre13"><st c="70268">Key </st><em class="italic"><st c="70273">13</st></em><st c="70275"> hashes to index </st><em class="italic"><st c="70292">3</st></em><st c="70293">, so it is placed at </st><span><st c="70314">index </st></span><span><em class="italic"><st c="70320">3</st></em></span><span><st c="70321">.</st></span></li><li class="calibre13"><st c="70322">Key </st><em class="italic"><st c="70327">22</st></em><st c="70329"> hashes to index </st><em class="italic"><st c="70346">2</st></em><st c="70347">, which is already occupied by </st><em class="italic"><st c="70378">12</st></em><st c="70380">. Using linear probing, we check the next slot (index </st><em class="italic"><st c="70434">3</st></em><st c="70435">), which is occupied by </st><em class="italic"><st c="70459">13</st></em><st c="70461">. We then check the next slot (index </st><em class="italic"><st c="70498">4</st></em><st c="70499">), which is empty, so </st><em class="italic"><st c="70521">22</st></em><st c="70523"> is placed at </st><span><st c="70537">index </st></span><span><em class="italic"><st c="70543">4</st></em></span><span><st c="70544">.</st></span></li><li class="calibre13"><st c="70545">Key </st><em class="italic"><st c="70550">32</st></em><st c="70552"> hashes to index </st><em class="italic"><st c="70569">2</st></em><st c="70570">, which is occupied by </st><em class="italic"><st c="70593">12</st></em><st c="70595">. Using linear probing, we check the next slots (index </st><em class="italic"><st c="70650">3</st></em><st c="70651">, occupied by </st><em class="italic"><st c="70665">13</st></em><st c="70667">, and index </st><em class="italic"><st c="70679">4</st></em><st c="70680">, occupied by </st><em class="italic"><st c="70694">22</st></em><st c="70696">). </st><st c="70700">The next empty slot is at index </st><em class="italic"><st c="70732">5</st></em><st c="70733">, so </st><em class="italic"><st c="70738">32</st></em><st c="70740"> is placed at </st><span><st c="70754">index </st></span><span><em class="italic"><st c="70760">5</st></em></span><span><st c="70761">.</st></span></li></ul></li>
				<li class="calibre13"><st c="70762"> Here is the resulting </st><span><st c="70785">hash table:</st></span></li>
			</ol>
			<table id="table003-2" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="70796">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="70802">Hash table</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70813">0</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70815">1</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70816">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="70817">12</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70819">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="70821">13</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70823">4</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="70825">22</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70827">5</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="70829">32</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70831">6</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70833">7</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70834">8</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="70835">9</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="70836">Table 7.3 – An example of handling collision using linear probing</st></p>
			<p class="calibre3"><st c="70901">The example</st><a id="_idIndexMarker535" class="pcalibre pcalibre1 calibre6"/><st c="70913"> demonstrates how linear probing resolves collisions by sequentially checking the next available slot in the </st><span><st c="71022">hash table.</st></span></p>
			<p class="calibre3"><st c="71033">Linear probing is </st><a id="_idIndexMarker536" class="pcalibre pcalibre1 calibre6"/><st c="71052">straightforward and easy to implement. </st><st c="71091">It accesses </st><a id="_idIndexMarker537" class="pcalibre pcalibre1 calibre6"/><st c="71103">contiguous memory locations, making it cache-friendly. </st><st c="71158">However, it can lead to primary clustering, where groups of filled slots form, resulting in longer probe sequences. </st><st c="71274">In the worst-case scenario, its running time degrades to </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="71331"/><st c="71332"> as the table </st><span><st c="71346">fills up.</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="71355">Quadratic probing</st></strong><st c="71373">: This</st><a id="_idIndexMarker538" class="pcalibre pcalibre1 calibre6"/><st c="71380"> is similar to linear probing but uses a quadratic function to determine the next slot. </st><st c="71468">The probe sequence is </st><img src="image/1384.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1046"/><st c="71490"/><st c="71515">, where </st><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre553"/><st c="71523"/><st c="71524"> is the </st><span><st c="71532">probe number.</st></span><p class="calibre3"><span><strong class="bold"><st c="71545">Example 7.9</st></strong></span></p><p class="calibre3"><st c="71557">To handle collisions using </st><a id="_idIndexMarker539" class="pcalibre pcalibre1 calibre6"/><st c="71585">quadratic probing for a hash table of size </st><em class="italic"><st c="71628">10</st></em><st c="71630"> and keys </st><em class="italic"><st c="71640">12</st></em><st c="71642">, </st><em class="italic"><st c="71644">13</st></em><st c="71646">, </st><em class="italic"><st c="71648">22</st></em><st c="71650">, and </st><em class="italic"><st c="71656">32</st></em><st c="71658">, we use the hash function </st><img src="image/1378.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mspace width=&quot;0.125em&quot; /&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1043"/><st c="71685"/><st c="71701">. The hash values for these keys are </st><em class="italic"><st c="71738">2</st></em><st c="71739">, </st><em class="italic"><st c="71741">3</st></em><st c="71742">, </st><em class="italic"><st c="71744">2</st></em><st c="71745">, and </st><span><em class="italic"><st c="71751">2</st></em></span><span><st c="71752">, respectively:</st></span></p></li>
			</ul>
			<ol class="calibre12">
				<li class="calibre13"><st c="71767">Calculate </st><span><st c="71778">hash values:</st></span><ul class="calibre50"><li class="calibre13"><st c="71790">For key </st><span><st c="71799">12: </st></span><span><img src="image/1387.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1047"/><st c="71803"/></span></li><li class="calibre13"><st c="71804">For key </st><span><st c="71812">13: </st></span><span><img src="image/1388.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1047"/><st c="71816"/></span></li><li class="calibre13"><st c="71817">For key </st><span><st c="71825">22: </st></span><span><img src="image/1389.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1047"/><st c="71829"/></span></li><li class="calibre13"><st c="71830">For key </st><span><st c="71838">32: </st></span><span><img src="image/1390.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1047"/><st c="71842"/></span></li></ul></li>
				<li class="calibre13"><st c="71843">Handle collisions </st><a id="_idIndexMarker540" class="pcalibre pcalibre1 calibre6"/><st c="71861">using </st><span><st c="71867">quadratic probing:</st></span><ul class="calibre50"><li class="calibre13"><st c="71885">Key 12 hashes to index 2, so it is placed at </st><span><st c="71931">index 2.</st></span></li><li class="calibre13"><st c="71939">Key 13 hashes to index 3, so it is placed at </st><span><st c="71985">index 3.</st></span></li><li class="calibre13"><st c="71993">Key 22 hashes to index 2, which is already occupied by 12. </st><st c="72053">Using quadratic probing, we check the next slots </st><span><st c="72102">as follows:</st></span><p class="calibre3"><img src="image/1391.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;22,1&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1048"/><st c="72113"/><st c="72146">, which is occupied </st><span><st c="72166">by 13</st></span></p><p class="calibre3"><img src="image/1392.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;22,2&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1048"/><st c="72171"/><st c="72200">, which is empty, so 22 is placed at </st><span><st c="72237">index 6</st></span></p></li><li class="calibre13"><st c="72244">Key 32 hashes to index 2, which is occupied by 12. </st><st c="72296">Using quadratic probing, we check the </st><a id="_idIndexMarker541" class="pcalibre pcalibre1 calibre6"/><st c="72334">next slots </st><span><st c="72345">as follows:</st></span><p class="calibre3"><img src="image/1393.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;32,1&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1048"/><st c="72356"/><st c="72385">, which is occupied </st><span><st c="72405">by 13</st></span></p><p class="calibre3"><img src="image/1394.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;32,2&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1048"/><st c="72410"/><st c="72438">, which is occupied </st><span><st c="72458">by 22</st></span></p><p class="calibre3"><img src="image/1395.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;32,3&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1048"/><st c="72463"/><st c="72496">, which is empty, so 32 is placed at </st><span><st c="72533">index 1</st></span></p></li></ul></li>
				<li class="calibre13"><st c="72540">Here is the resulting </st><span><st c="72563">hash table:</st></span></li>
			</ol>
			<table id="table004-2" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="72574">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="72580">Hash table</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72591">0</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72593">1</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="72594">32</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72596">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="72598">12</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72600">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="72602">13</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72604">4</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72606">5</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72607">6</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="72608">22</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72610">7</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72612">8</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="72613">9</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="72614">Table 7.4 – An example of handling collision using quadratic probing</st></p>
			<p class="calibre3"><st c="72682">This example</st><a id="_idIndexMarker542" class="pcalibre pcalibre1 calibre6"/><st c="72695"> demonstrates how quadratic probing resolves collisions by checking progressively further slots, using a quadratic function to determine the </st><span><st c="72836">probe sequence.</st></span></p>
			<p class="calibre3"><st c="72851">In </st><a id="_idIndexMarker543" class="pcalibre pcalibre1 calibre6"/><st c="72855">quadratic probing, the likelihood of primary clustering is reduced compared to linear probing. </st><st c="72950">However, its access pattern is les</st><a id="_idTextAnchor115" class="pcalibre pcalibre1 calibre6"/><st c="72984">s cache-friendly. </st><st c="73003">While quadratic probing mitigates primary clustering, it can still experience secondary clustering, where elements hashing to the same initial index follow the same probe sequence. </st><st c="73184">Additionally, quadratic probing is more complex to implement compared to </st><span><st c="73257">linear probing.</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="73272">Double hashing</st></strong><st c="73287">: This </st><a id="_idIndexMarker544" class="pcalibre pcalibre1 calibre6"/><st c="73295">uses a secondary hash function to determine the probe sequence, reducing clustering further. </st><st c="73388">The probe sequence is </st><span><st c="73410">as</st></span><span><a id="_idIndexMarker545" class="pcalibre pcalibre1 calibre6"/></span><span><st c="73412"> follows:</st></span><p class="calibre3"><img src="image/1396.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1049"/><st c="73421"/><st c="73458">.</st></p><p class="calibre3"><span><strong class="bold"><st c="73459">Example 7.10</st></strong></span></p><p class="calibre3"><st c="73472">To handle collisions using double hashing for a hash table of size 10 and keys 12, 13, 22, and 32, we use the </st><a id="_idIndexMarker546" class="pcalibre pcalibre1 calibre6"/><st c="73583">primary hash function </st><img src="image/1397.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1050"/><st c="73605"/><st c="73626">. The hash values for these keys are 2, 3, 2, and 2, respectively. </st><st c="73693">We also use a secondary hash function, </st><span><st c="73732">h</st></span><span/><span><st c="73733">2</st></span><span><st c="73734">(</st></span><span><st c="73735">k</st></span><span><st c="73736">e</st></span><span><st c="73737">y</st></span><span><st c="73738">)</st></span><span> </span><span><st c="73739">=</st></span><span> </span><span><st c="73740">1</st></span><span> </span><span><st c="73741">+</st></span><span> </span><span><st c="73742">(</st></span><span><st c="73743">k</st></span><span><st c="73744">e</st></span><span><st c="73745">y</st></span><span> </span><span><st c="73746">m</st></span><span><st c="73747">o</st></span><span><st c="73748">d</st></span><span> </span><span><st c="73749">9</st></span><span><st c="73750">)</st></span><st c="73751">, to determine the </st><span><st c="73770">probe sequence:</st></span></p></li>
			</ul>
			<ol class="calibre12">
				<li class="calibre13"><st c="73785">Calculate the primary </st><span><st c="73808">hash values:</st></span><ul class="calibre50"><li class="calibre13"><st c="73820">For key </st><span><st c="73829">12: </st></span><span><img src="image/1398.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1051"/><st c="73833"/></span></li><li class="calibre13"><st c="73847">For key </st><span><st c="73855">13: </st></span><span><img src="image/1399.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1051"/><st c="73859"/></span></li><li class="calibre13"><st c="73871">For key </st><span><st c="73879">22: </st></span><span><img src="image/1400.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1051"/><st c="73883"/></span></li><li class="calibre13"><st c="73895">For key </st><span><st c="73903">32: </st></span><span><img src="image/1401.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1051"/><st c="73907"/></span></li></ul></li>
				<li class="calibre13"><st c="73919">Handle collisions using </st><span><st c="73943">double hashing:</st></span><ul class="calibre50"><li class="calibre13"><st c="73958">Key 12 hashes to index 2, so it is placed at </st><span><st c="74004">index 2.</st></span></li><li class="calibre13"><st c="74012">Key 13 hashes to index 3, so it is placed at </st><span><st c="74058">index 3.</st></span></li><li class="calibre13"><st c="74066">Key 22 hashes </st><a id="_idIndexMarker547" class="pcalibre pcalibre1 calibre6"/><st c="74081">to index 2, which is already occupied by 12. </st><st c="74126">Using the secondary hash function, we calculate the </st><span><st c="74178">probe sequence:</st></span><p class="calibre3"><st c="74193">Secondary hash </st><span><st c="74209">for 22:</st></span></p><p class="calibre3"><img src="image/1402.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;_&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1052"/><st c="74216"/></p><p class="calibre3"><span><st c="74243">Probe sequence:</st></span></p><p class="calibre3"><img src="image/1403.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1053"/><st c="74258"/></p><p class="calibre3"><st c="74294">First probe: </st><img src="image/1404.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1054"/><st c="74307"/><st c="74308">, which is empty, so 22 is placed at </st><span><st c="74345">index 7</st></span></p></li><li class="calibre13"><st c="74352">Key 32 hashes to index 2, which is occupied by 12. </st><st c="74404">Using the secondary hash function, we calculate the </st><span><st c="74456">probe sequence:</st></span><p class="calibre3"><st c="74471">Secondary hash </st><span><st c="74487">for 32:</st></span></p><p class="calibre3"><img src="image/1405.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;_&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1055"/><st c="74494"/></p><p class="calibre3"><span><st c="74522">Probe sequence:</st></span></p><p class="calibre3"><img src="image/1406.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;/mfenced&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1053"/><st c="74537"/></p><p class="calibre3"><st c="74575">First probe: </st><img src="image/1407.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1054"/><st c="74588"/><st c="74589">, which is empty, so 32 is placed at </st><span><st c="74626">index 8</st></span></p></li></ul></li>
				<li class="calibre13"><st c="74633">Here is the</st><a id="_idIndexMarker548" class="pcalibre pcalibre1 calibre6"/><st c="74645"> resulting </st><span><st c="74656">hash table:</st></span></li>
			</ol>
			<table id="table005-2" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="74667">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="74673">Hash table</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74684">0</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74686">1</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74687">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="74688">12</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74690">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="74692">13</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74694">4</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74696">5</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74697">6</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74698">7</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="74699">22</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74701">8</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="74703">32</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="74705">9</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="74707">Table 7.5 – An example of handling collision using double hashing</st></p>
			<p class="calibre3"><st c="74772">The example </st><a id="_idIndexMarker549" class="pcalibre pcalibre1 calibre6"/><st c="74785">demonstrates how double hashing resolves collisions by using a secondary hash function to determine the probe sequence, reducing the likelihood </st><span><st c="74929">of clustering.</st></span></p>
			<p class="calibre3"><st c="74943">The major</st><a id="_idIndexMarker550" class="pcalibre pcalibre1 calibre6"/><st c="74953"> advantage of double hashing is that it significantly reduces both primary and secondary clustering. </st><st c="75054">It maintains </st><img src="image/1408.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1056"/><st c="75067"/><st c="75068"> average-case performance for insert, delete, and search operations. </st><st c="75137">However, double hashing is more complex to implement due to the need for two hash functions. </st><st c="75230">Additionally, it may be less cache-efficient because of non-contiguous </st><span><st c="75301">memory accesses.</st></span></p>
			<h4 class="calibre985"><st c="75317">Cuckoo hashing – the bird-inspired collision resolution</st></h4>
			<p class="calibre3"><strong class="bold"><st c="75373">Cuckoo hashing</st></strong><st c="75388"> is a </st><a id="_idIndexMarker551" class="pcalibre pcalibre1 calibre6"/><st c="75394">unique open addressing scheme </st><a id="_idIndexMarker552" class="pcalibre pcalibre1 calibre6"/><st c="75424">for handling collisions in hash tables, inspired by the </st><a id="_idIndexMarker553" class="pcalibre pcalibre1 calibre6"/><st c="75480">behavior of cuckoo birds. </st><st c="75506">Just like a cuckoo chick pushes other eggs out of a nest, cuckoo hashing allows a new key to “kick out” an existing key to make space for itself. </st><st c="75652">Let’s explain how it works step </st><span><st c="75684">by step:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="75692">Two hash functions</st></strong><st c="75711">: Cuckoo hashing employs two independent hash functions (</st><img src="image/1409.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1057"/><st c="75769"/><st c="75771"> and </st><img src="image/1410.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1058"/><st c="75776"/><st c="75777">) that map keys to slots in the hash table. </st><st c="75821">This gives each key two potential locations where it can </st><span><st c="75878">be stored.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="75888">Insertion</st></strong><st c="75898">: When inserting a key, the algorithm first tries to place it in the slot determined </st><span><st c="75984">by </st></span><span><img src="image/1411.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1059"/><st c="75987"/></span><span><st c="75995">:</st></span><ul class="calibre50"><li class="calibre13"><st c="75996">If the slot is empty, the key </st><span><st c="76026">is inserted</st></span></li><li class="calibre13"><st c="76037">If the slot is occupied, the existing key is “kicked out” and the new key takes </st><span><st c="76118">its place</st></span></li></ul><p class="calibre3"><st c="76127">The kicked-out key is then attempted to be inserted into its alternate location based on </st><img src="image/1412.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1059"/><st c="76217"/><st c="76225">. This process continues, potentially displacing more keys until an empty slot is found or a maximum number of displacements </st><span><st c="76350">is reached.</st></span></p></li>
				<li class="calibre13"><strong class="bold"><st c="76361">Lookup</st></strong><st c="76368">: To find a key, the algorithm checks both possible locations (</st><img src="image/1411.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1059"/><st c="76432"/><st c="76441"> and </st><img src="image/1412.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1059"/><st c="76445"/><st c="76453">). </st><st c="76456">If the key is found in either location, the lookup </st><span><st c="76507">is successful.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="76521">Deletion</st></strong><st c="76530">: Deleting a key is straightforward; simply remove it from the slot where </st><span><st c="76605">it’s found.</st></span></li>
			</ol>
			<p class="calibre3"><st c="76616">Let’s illustrate this hashing method in the </st><span><st c="76661">following example.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="76679">Example 7.11</st></strong></span></p>
			<p class="calibre3"><st c="76692">Let’s handle collisions </st><a id="_idIndexMarker554" class="pcalibre pcalibre1 calibre6"/><st c="76717">using cuckoo hashing for a hash table of size 10 and keys 12, 13, 22, </st><span><st c="76787">and 32:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="76794">We use the following </st><span><st c="76816">hash functions:</st></span><ul class="calibre50"><li class="calibre13"> <img src="image/1415.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1060"/><st c="76831"/></li><li class="calibre13"> <img src="image/1416.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1061"/><st c="76853"/><st c="76879">  (‘/’ is </st><span><st c="76887">integer division)</st></span></li></ul></li>
				<li class="calibre13"> <span><st c="76904">Insertion steps:</st></span><ul class="calibre50"><li class="calibre13"><span><st c="76921">Key 12:</st></span><p class="calibre3"><st c="76929">Hash </st><span><st c="76935">values: </st></span><span><img src="image/1417.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1062"/><st c="76943"/></span></p><p class="calibre3"><st c="76967">Place 12 in Table 1 at </st><span><st c="76990">index 2.</st></span></p></li><li class="calibre13"><span><st c="76998">Key 13:</st></span><p class="calibre3"><st c="77006">Hash </st><span><st c="77012">values: </st></span><span><img src="image/1418.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;13&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1063"/><st c="77020"/></span></p><p class="calibre3"><st c="77045">Place 13 in Table 1 at </st><span><st c="77068">index 3.</st></span></p></li><li class="calibre13"><span><st c="77076">Key 22:</st></span><p class="calibre3"><st c="77084">Hash </st><span><st c="77090">values: </st></span><span><img src="image/1419.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1064"/><st c="77098"/></span></p><p class="calibre3"><st c="77122">Index 2 in Table 1 is occupied by 12. </st><st c="77160">Kick out 12 and place 22 in </st><span><st c="77188">Table 1</st></span></p></li><li class="calibre13"><span><st c="77195">index 2.</st></span><p class="calibre3"><st c="77204">Reinsert 12 using </st><img src="image/1420.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1065"/><st c="77223"/><st c="77224"> : </st><img src="image/1421.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;12&lt;/mn&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1066"/><st c="77227"/></p><p class="calibre3"><st c="77255">Place 12 in Table 2 at </st><span><st c="77278">index 1.</st></span></p></li><li class="calibre13"><span><st c="77286">Key 32:</st></span><p class="calibre3"><st c="77294">Hash </st><span><st c="77300">values: </st></span><span><img src="image/1422.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;32&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1064"/><st c="77308"/></span></p><p class="calibre3"><st c="77332">Index 2 in Table 1 is occupied by 22. </st><st c="77370">Kick out 22 and place 32 in Table </st><span><st c="77404">1 at</st></span></p></li><li class="calibre13"><span><st c="77408">index 2.</st></span><p class="calibre3"><st c="77417">Reinsert 22 using </st><img src="image/1420.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1065"/><st c="77436"/><st c="77437">: </st><img src="image/1424.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;22&lt;/mn&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1066"/><st c="77439"/></p><p class="calibre3"><st c="77468">Index 2 in Table 2 is empty, so place 22 in Table 2 at </st><span><st c="77523">index 2.</st></span></p></li></ul></li>
				<li class="calibre13"><st c="77531">Here are</st><a id="_idIndexMarker555" class="pcalibre pcalibre1 calibre6"/><st c="77540"> the </st><a id="_idIndexMarker556" class="pcalibre pcalibre1 calibre6"/><st c="77545">resulting </st><span><st c="77555">hash tables:</st></span></li>
			</ol>
			<table id="table006-1" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<thead class="calibre53">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="77567">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="77573">Hash </st></strong><span><strong class="bold"><st c="77579">table (1)</st></strong></span></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="77588">Index</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><strong class="bold"><st c="77594">Hash </st></strong><span><strong class="bold"><st c="77600">table (2)</st></strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77609">0</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77611">0</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77612">1</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77613">1</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="77614">12</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77616">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="77618">32</st></span></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77620">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="77622">22</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77624">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="77626">13</st></span></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77628">3</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77630">4</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77631">4</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77632">5</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77633">5</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77634">6</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77635">6</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77636">7</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77637">7</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77638">8</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77639">8</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="77640">9</st></p>
						</td>
						<td class="t---table2"/>
						<td class="t---table2"/>
						<td class="t---table2">
							<p class="calibre3"><st c="77641">9</st></p>
						</td>
						<td class="t---table2"/>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="77642">Table 7.6 – An example of handling collision using cuckoo hashing</st></p>
			<p class="calibre3"><st c="77707">Cuckoo hashing </st><a id="_idIndexMarker557" class="pcalibre pcalibre1 calibre6"/><st c="77723">offers constant </st><img src="image/1425.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1067"/><st c="77739"/><st c="77740"> worst-case lookup time, which is a significant advantage over other collision resolution techniques such as linear probing or chaining. </st><st c="77877">It also eliminates clustering by ensuring that each key can reside in one of two possible locations. </st><st c="77978">However, cuckoo hashing requires a relatively low load factor to function effectively, meaning the table might need to be larger compared to other methods. </st><st c="78134">Additionally, if the table becomes too full or cycles are detected, a rehashing operation is necessary, which can </st><span><st c="78248">be costly.</st></span></p>
			<p class="calibre3"><st c="78258">Cuckoo hashing is an excellent choice when extremely fast lookups and deletions are required, even under heavy load. </st><st c="78376">However, it is important to be aware of the limitations regarding load factor and the potential overhead </st><span><st c="78481">of rehashing.</st></span></p>
			<h3 class="calibre8"><st c="78494">Recap</st></h3>
			<p class="calibre3"><st c="78500">Hashing offers several advantages, most notably its speed. </st><st c="78560">Hashing provides average-case </st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="78590"/><st c="78591"> time complexity for search, insert, and delete operations, making it extremely fast. </st><st c="78677">Hash tables can handle a large number of entries efficiently, provided the load factor (the ratio of entries to table size) is managed well. </st><st c="78818">Additionally, hash tables are versatile and can be used in various applications, such as implementing dictionaries, caches, </st><span><st c="78942">and sets.</st></span></p>
			<p class="calibre3"><st c="78951">However, hashing also has its limitations. </st><st c="78995">Collisions, while minimized, can still occur and must be managed efficiently to maintain performance. </st><st c="79097">Hash tables may require more memory than other data structures, particularly if the table is sparsely populated. </st><st c="79210">In the worst-case scenario, where many collisions occur, the time complexity can degrade </st><span><st c="79299">to </st></span><span><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="79302"/></span><span><st c="79303">.</st></span></p>
			<p class="calibre3"><st c="79304">Despite these challenges, hashing remains a powerful method for achieving constant time search operations. </st><st c="79412">Hash tables are widely used in applications such as database indexing (where they enable fast record retrieval) and caching, where they help quickly locate cached data. </st><st c="79581">They are also essential in compilers and interpreters for storing information about identifiers and in many programming languages for implementing sets and associative arrays (maps). </st><st c="79764">The efficiency and versatility of hashing make it an indispensable technique in computer science for fast and efficient </st><span><st c="79884">data retrieval.</st></span></p>
			<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor116" class="pcalibre pcalibre1 calibre6"/><st c="79899">Summary</st></h1>
			<p class="calibre3"><st c="79907">In this chapter, we explored the fundamental concepts of search and search algorithms, beginning with an overview of linear and sub-linear search methods. </st><st c="80063">We examined how linear search, despite its simplicity and ease of implementation, has limitations in efficiency, especially for large datasets. </st><st c="80207">We then discussed sub-linear search algorithms, such as binary search, jump search, and interpolation search, highlighting their improved time complexities and discussing the conditions under which they </st><span><st c="80410">performed best.</st></span></p>
			<p class="calibre3"><st c="80425">Lastly, we introduced the concept of hashing and its critical role in achieving constant time complexity for search, insert, and delete operations. </st><st c="80574">We covered different hashing methods, including division-remainder, multiplication, mid-square, and universal hashing, explaining how each method worked and their respective strengths </st><span><st c="80758">and weaknesses.</st></span></p>
			<p class="calibre3"><st c="80773">We also discussed various techniques for handling collisions, such as linear probing, quadratic probing, double hashing, and cuckoo hashing. </st><st c="80915">Each method’s advantages and limitations were analyzed, showing how they addressed the challenges of search operations in different scenarios. </st><st c="81058">These techniques demonstrated how sophisticated strategies could optimize search operations by efficiently managing the search space and </st><span><st c="81195">minimizing collisions.</st></span></p>
			<p class="calibre3"><st c="81217">The chapter concluded by emphasizing the importance of hashing in various applications, such as database indexing, caching, symbol tables, and implementing sets and maps in programming languages. </st><st c="81414">Despite challenges such as collision handling and memory overhead, hashing was shown to be a versatile and efficient technique in computer science for fast </st><span><st c="81570">data retrieval.</st></span></p>
			<p class="calibre3"><st c="81585">In the next chapter, we will explore the relationship between sorting and searching in computational systems and algorithm design. </st><st c="81717">We will examine how to strike a balance between these two processes to minimize </st><span><st c="81797">computational costs.</st></span></p>
			<h1 id="_idParaDest-105" class="calibre5"><a id="_idTextAnchor117" class="pcalibre pcalibre1 calibre6"/><st c="81817">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><em class="italic"><st c="81848">Introduction to Algorithms</st></em><st c="81875">. By Thomas H. </st><st c="81890">Cormen, Charles E. </st><st c="81909">Leiserson, Ronald L. </st><st c="81930">Rivest, and Clifford Stein. </st><st c="81958">Fourth Edition. </st><st c="81974">MIT </st><span><st c="81978">Press. </st><st c="81985">2022:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="81990">Chapter 11</st></em><st c="82001">, </st><span><em class="italic"><st c="82003">Hash Tables</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="82014">The Art of Computer Programming</st></em><st c="82046">. By D. </st><st c="82054">E. </st><st c="82057">Knuth. </st><st c="82064">Volume 3: Sorting and Searching (Second ed.). </st><span><st c="82110">Addison-Wesley. </st><st c="82126">1998:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="82131">Section </st></em><span><em class="italic"><st c="82140">6.1</st></em></span><span><st c="82143">, </st></span><span><em class="italic"><st c="82145">Searching</st></em></span></li><li class="calibre13"><em class="italic"><st c="82154">Section 6.2</st></em><st c="82166">, </st><span><em class="italic"><st c="82168">Binary Search</st></em></span></li><li class="calibre13"><em class="italic"><st c="82181">Section </st></em><span><em class="italic"><st c="82190">6.4</st></em></span><span><st c="82193">, </st></span><span><em class="italic"><st c="82195">Hashing</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="82202">Data Structures and Algorithm Analysis in C++</st></em><st c="82248">. By M. </st><st c="82256">A. </st><st c="82259">Weiss. </st><st c="82266">(Fourth ed.). </st><span><st c="82280">Pearson. </st><st c="82289">2012:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="82294">Chapter </st></em><span><em class="italic"><st c="82303">5</st></em></span><span><st c="82304">, </st></span><span><em class="italic"><st c="82306">Hashing</st></em></span></li><li class="calibre13"><em class="italic"><st c="82313">Chapter 7</st></em><st c="82323">, </st><span><em class="italic"><st c="82325">Search Trees</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="82337">Algorithms</st></em><st c="82348">. By R. </st><st c="82356">Sedgewick, K. </st><st c="82370">Wayne. </st><st c="82377">Fourth Edition. </st><span><st c="82393">Addison-Wesley. </st><st c="82409">2011:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="82414">Section 3.4</st></em><st c="82426">, </st><span><em class="italic"><st c="82428">Hash Tables</st></em></span></li></ul></li>
			</ul>
		</div>
	<div id="charCountTotal" value="82439" class="calibre2"/></body></html>