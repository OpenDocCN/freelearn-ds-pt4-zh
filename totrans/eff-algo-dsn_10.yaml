- en: <st c="0">7</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Search Algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="19">In the data and information processing domain, search and information
    retrieval play a very crucial role.</st> <st c="126">The efficiency and accuracy
    of search algorithms directly impact the effectiveness of various applications,
    from database management systems to search engines.</st> <st c="286">This chapter
    discusses the critical importance of search algorithms, clarifying their fundamental
    properties through a series</st> <st c="412">of examples.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="424">Search algorithms are designed to optimize the retrieval process,
    making it faster and more efficient.</st> <st c="528">A crucial aspect of this
    optimization is sorting, which organizes data in a manner that facilitates rapid
    search operations.</st> <st c="653">The interplay between sorting and searching
    is evident in numerous applications where sorted data allows for more sophisticated
    and quicker search techniques.</st> <st c="812">We will explore this essential
    relationship between sorting and searching in the next chapter.</st> <st c="907">However,
    when we separate the concept of search from sorting, we are often left with the
    basic sequential search.</st> <st c="1021">Sequential search operates in linear
    time, scanning each element one by one until the desired result is found.</st>
    <st c="1132">This method, while straightforward, is not always the most efficient,
    especially for</st> <st c="1217">large datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1232">To address the limitations of sequential search, we can leverage
    data assumptions to devise more advanced techniques such as hashing.</st> <st
    c="1367">Hashing transforms data into a fixed-size value or hash code (hash value),
    allowing for constant time search operations under ideal conditions.</st> <st
    c="1511">This chapter explores these advanced techniques, illustrating how assumptions
    about data can significantly enhance search performance.</st> <st c="1646">By
    employing hashing functions, we can achieve constant time complexity, drastically
    improving the efficiency of search operations in</st> <st c="1780">many applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="1798">In this chapter, search algorithms are categorized into three
    primary groups: linear-time search algorithms, sub-linear (e.g., logarithmic time)
    search algorithms, and constant-time search algorithms that utilize hashing.</st>
    <st c="2021">Each category is examined in detail, with a focus on its properties,
    use cases, and performance characteristics.</st> <st c="2134">The chapter is structured</st>
    <st c="2160">as follows:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2171">Properties of</st> <st c="2186">search algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2203">Linear-time and logarithmic</st> <st c="2232">search algorithms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2249">Hashing</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2257">Properties of search algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2289">Before diving into search algorithms and their properties, it’s
    important to differentiate between two types of search in computer science:</st>
    **<st c="2430">algorithmic</st>** <st c="2441">search and search in</st> **<st
    c="2463">artificial intelligence</st>** <st c="2486">(</st>**<st c="2488">AI</st>**<st
    c="2490">).</st> <st c="2494">While these two types of</st> <st c="2519">search
    share some similarities, they have distinct differences</st> <st c="2582">and
    objectives.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2597">The concept of</st> *<st c="2613">search</st>* <st c="2619">in
    algorithms and</st> *<st c="2638">search</st>* <st c="2644">in AI can</st> <st
    c="2654">differ significantly in terms of their goals, methodologies, and applications.</st>
    <st c="2734">Here’s a comparison highlighting the</st> <st c="2771">key differences.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2787">Algorithmic search refers to the process of finding a specific
    element or set of elements within a data structure, such as an array, list, or
    tree.</st> <st c="2936">The primary goal is to locate the desired element(s) as
    quickly as possible, often measured by time complexity (e.g.,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1199.png)<st
    c="3054"><st c="3055">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1200.png)<st
    c="3057"><st c="3066">).</st> <st c="3069">On the other hand, the correctness
    of algorithmic search is to ensure the algorithm correctly identifies the presence
    or absence of the</st> <st c="3205">target element.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3220">We implement algorithmic search using one of the</st> <st c="3270">following
    methods:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="3288">Linear search</st>**<st c="3302">: Iterates</st> <st c="3313">through
    each element until the target is found or the end of the structure</st> <st c="3389">is
    reached</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="3399">Binary search</st>**<st c="3413">: Efficiently</st> <st c="3427">locates
    elements in sorted arrays by repeatedly dividing the search interval</st> <st
    c="3505">in half</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="3512">Hashing</st>**<st c="3520">: Uses</st> <st c="3528">hash functions
    to map elements to specific positions for</st> <st c="3585">quick access</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="3597">Tree traversal</st>**<st c="3612">: Searches</st> <st c="3623">within
    tree structures, such as binary search trees, AVL trees, and</st> <st c="3692">red-black
    trees</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3707">The major application of algorithmic search is in data retrieval,
    which is used in databases, filesystems, and general data</st> <st c="3832">processing
    tasks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3849">On the other hand, we have</st> <st c="3877">search algorithms
    in AI, or simply AI search.</st> <st c="3923">AI search involves finding a sequence
    of actions or a path from an initial state to a goal state within a problem space.</st>
    <st c="4044">It often deals with more complex and dynamic environments and has
    different objectives from algorithmic search.</st> <st c="4156">The primary objective
    of AI search is problem-solving – finding a solution to a complex problem that
    may involve navigating through a large state space.</st> <st c="4309">Additionally,
    AI search aims to find the best or most efficient solution among many possible
    options and must be capable of handling dynamic and uncertain environments where
    conditions and goals</st> <st c="4504">may change.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4515">AI search algorithms</st> <st c="4537">are implemented with different</st>
    <st c="4568">strategies depending on the problem type and our knowledge of the
    goal state.</st> <st c="4646">Although these methods can be categorized in various
    ways, the most well-known AI search families are uninformed search and informed
    search.</st> <st c="4787">Uninformed search techniques, such</st> <st c="4822">as</st>
    **<st c="4825">breadth-first search</st>** <st c="4845">(</st>**<st c="4847">BFS</st>**<st
    c="4850">) and</st> **<st c="4857">depth-first search</st>** <st c="4875">(</st>**<st
    c="4877">DFS</st>**<st c="4880">), explore</st> <st c="4892">the search space
    without specific knowledge about the goal.</st> <st c="4952">In contrast, informed
    search techniques, such as</st> **<st c="5001">A* search</st>** <st c="5010">and</st>
    **<st c="5015">greedy search</st>**<st c="5028">, use</st> <st c="5033">heuristics
    to guide the search</st> <st c="5064">process toward the goal more efficiently.</st>
    <st c="5107">Heuristics provide an estimated cost to reach the goal, helping to
    prioritize paths that appear</st> <st c="5203">more promising.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5218">AI search has many applications.</st> <st c="5252">For example,
    in robotics, search helps agents navigate and perform tasks in dynamic environments.</st>
    <st c="5350">In game playing, AI agents search for optimal moves in games such
    as chess, Go, and</st> <st c="5434">video games.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5446">In conclusion, algorithmic search focuses on efficiently finding
    specific elements within structured data using well-defined procedures and data
    structures.</st> <st c="5604">In contrast, AI search involves exploring large
    and often unstructured problem spaces to find optimal or feasible solutions to
    complex problems, using both uninformed and informed techniques, often incorporating
    heuristics and</st> <st c="5831">learning methods.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5848">In essence, while both types of search aim to find solutions, algorithmic
    search is typically more concerned with data retrieval and manipulation within
    well-defined constraints, whereas AI search addresses broader and more complex
    problem-solving scenarios, often requiring adaptability</st> <st c="6137">and
    learning.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6150">In this section, we introduce several properties to evaluate and
    compare different algorithmic search algorithms (in this chapter, we will use</st>
    *<st c="6294">search</st>* <st c="6300">to refer to algorithmic search).</st>
    <st c="6334">These properties, in addition to time and space complexities, provide
    a baseline to understand the behavior and efficiency of search algorithms.</st>
    <st c="6479">By considering these properties, we can</st> <st c="6518">choose
    the most suitable algorithm for a</st> <st c="6560">given scenario:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="6575">Data structure requirement</st>**<st c="6602">: Different search
    algorithms may require specific data structures to operate efficiently.</st> <st
    c="6694">For example, binary search necessitates a sorted array to function correctly,
    whereas sequential search can work with any linear data structure, such as arrays
    or</st> <st c="6857">l</st><st c="6858">inked lists.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6870">Adaptability</st>**<st c="6883">: Some search algorithms have
    the ability to adapt to the characteristics of the input data, thereby improving
    their performance.</st> <st c="7014">For example, interpolation search adapts
    to the distribution of data and can perform significantly better than binary search
    on uniformly</st> <st c="7152">distributed datasets.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7173">Implementation complexity</st>**<st c="7199">: The complexity
    of implementing an algorithm is a practical consideration, especially in time-constrained
    situations.</st> <st c="7319">Simpler algorithms such as sequential search are
    easy to implement and understand, while more complex algorithms such as balanced
    search trees (see</st> [*<st c="7467">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="7477">) or hashing require a deeper understanding of data structures and</st>
    <st c="7545">algorithm design.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7562">Preprocessing requirements</st>**<st c="7589">: Certain search
    algorithms require preprocessing of the data before they can be applied.</st>
    <st c="7680">For example, binary search requires the data to be sorted, which
    adds to the overall time complexity.</st> <st c="7782">Preprocessing steps can
    sometimes negate the benefits of a faster search time, especially if the data
    changes frequently and requires</st> <st c="7916">constant re-sorting.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7936">Optimality</st>**<st c="7947">: Some algorithms are considered
    optimal for specific scenarios based on their time complexity and performance
    characteristics.</st> <st c="8076">Binary search, for instance, is</st> <st c="8108">optimal
    for searching within a sorted array due to its logarithmic time complexity.</st>
    <st c="8192">However, optimality can vary based on the context and specific requirements
    of the application.</st> <st c="8288">An algorithm that is optimal in one scenario
    may not be the best choice in another if the underlying assumptions or</st> <st
    c="8404">conditions change.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8422">By examining these key characteristics – data structure requirements,
    adaptability, implementation complexity, preprocessing requirements, and optimality
    – we can make informed decisions about which search algorithms to use in different
    contexts.</st> <st c="8670">This comprehensive understanding ensures that we select
    the most efficient and effective search techniques for our data</st> <st c="8790">processing
    needs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8807">Among the</st> <st c="8818">properties of search algorithms, time
    complexity stands out as the most critical factor.</st> <st c="8907">The efficiency
    of a search algorithm is predominantly determined by its time complexity, which
    dictates how quickly an algorithm can locate an element within a dataset.</st>
    <st c="9076">As a result, search algorithms are often classified according to
    their time complexities to facilitate a clear understanding of their performance
    under</st> <st c="9228">different conditions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9249">In the upcoming sections, we will explore search algorithms categorized
    by their time complexities.</st> <st c="9350">These categories provide a structured
    way to analyze and compare various</st> <st c="9423">search techniques:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="9441">Linear-time search algorithms</st>**<st c="9471">: These</st>
    <st c="9479">algorithms, such as the sequential search, operate in</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1201.png)
    <st c="9534"><st c="9535">time, meaning the time</st> <st c="9558">required to
    find an element grows linearly with the size of the dataset.</st> <st c="9632">We
    will explore scenarios where linear-time algorithms are suitable and their</st>
    <st c="9710">implementation details.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9733">Sub-linear time search algorithms</st>**<st c="9767">: This
    category includes algorithms such as binary search, which</st> <st c="9832">operate
    in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1202.png)
    <st c="9844"><st c="9853">time.</st> <st c="9859">Binary search is particularly
    efficient for sorted datasets and leverages the divide-and-conquer strategy to
    quickly narrow down the search space.</st> <st c="10006">In</st> [*<st c="10009">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="10019">, we will discuss a search
    algorithm based on a specific data structure</st> <st c="10091">called</st> **<st
    c="10098">binary search trees</st>** <st c="10117">(</st>**<st c="10119">BSTs</st>**<st
    c="10123">).</st> <st c="10127">BSTs maintain a sorted order of elements, allowing
    for efficient search, insertion, and</st> <st c="10215">deletion operations.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10235">Constant-time search algorithms</st>**<st c="10267">: These</st>
    <st c="10275">algorithms aim to achieve</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1063.png)
    <st c="10302"><st c="10303">time complexity, where the time</st> <st c="10335">required
    to find an element remains constant regardless of the dataset size.</st> <st c="10413">Hashing</st>
    <st c="10421">is a primary technique used to achieve constant-time search operations.</st>
    <st c="10493">We will examine how hashing functions work, their implementation,
    and the conditions under which they provide</st> <st c="10603">optimal performance.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10623">By understanding and categorizing search algorithms based on their
    time complexities, we can better appreciate their strengths and limitations.</st>
    <st c="10768">This structured approach allows us to select the most appropriate
    algorithm for a given application, ensuring efficient and effective</st> <st c="10902">data
    retrieval.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10917">Linear-time and logarithmic search algorithms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="10963">In the</st> <st c="10970">study of search algorithms, understanding
    both linear and sub-linear search methods is crucial for selecting the most</st>
    <st c="11088">efficient approach for a given problem.</st> <st c="11129">Linear
    search, the most straightforward method, involves checking each element in a dataset
    sequentially until the target is found or the end of the dataset is reached.</st>
    <st c="11298">While simple and effective for small or unsorted datasets, its</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1204.png)
    <st c="11361"><st c="11362">time complexity makes it impractical for large datasets.</st>
    <st c="11420">In contrast, sub-linear search algorithms, such as binary search
    and jump search, offer more efficient solutions with time complexities better
    than</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1205.png)<st
    c="11568"><st c="11569">, typically exploiting the properties of sorted data to
    significantly reduce the number of comparisons needed.</st> <st c="11680">By comparing
    these two classes of algorithms, we can appreciate the advancements in search
    techniques and their applications in optimizing data</st> <st c="11824">retrieval
    processes.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11844">Linear or sequential search</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11872">A</st> <st c="11875">general search algorithm, regardless of any
    assumptions about data (whether sorted or unsorted), has an asymptotic upper bound
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="12005"><st c="12006">. This is because, in the worst case, we may need to visit
    and evaluate every single element in the dataset to determine whether the target
    element is present.</st> <st c="12166">Therefore, the time complexity of a linear
    search algorithm is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1207.png)<st
    c="12229"><st c="12230">. Let’s examine this in both recursive and iterative (non-recursive)
    implementations of linear</st> <st c="12325">search algorithms.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12343">The iterative (non-recursive) implementation of linear search
    involves incrementing through each element of the array and checking whether it
    matches the target element.</st> <st c="12514">The following is a simple Python
    implementation of</st> <st c="12565">linear search:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="12693">Estimating</st> <st c="12704">the time complexity of iterative
    linear search is straightforward.</st> <st c="12772">The algorithm consists of
    a loop that executes all commands inside it</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="12842"><st c="12891">times, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="12904"><st c="12953">is the number of elements in the array.</st> <st c="12993">Additionally,
    the final instruction after the loop runs once.</st> <st c="13055">This results
    in an upper bound for the running time</st> <st c="13107">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="13110"><st c="13111">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13112">The recursive implementation of linear search involves checking
    the current element and making a recursive call to check the next element if the
    target is not found.</st> <st c="13279">The following is a Python code to implement
    recursive</st> <st c="13333">sequential search:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13519">The</st> `<st c="13524">recursive_linear_search</st>` <st c="13547">function
    takes three parameters:</st> `<st c="13581">a</st>` <st c="13582">(the array to
    search),</st> `<st c="13606">target</st>` <st c="13612">(the element to search
    for), and</st> `<st c="13646">index</st>` <st c="13651">(the current index in
    the array, defaulting to</st> `<st c="13699">0</st>`<st c="13700">).</st> <st
    c="13703">If</st> `<st c="13706">index</st>` <st c="13711">is greater than or
    equal to the length of the array, it means we have reached the end of the array
    and the target is not found.</st> <st c="13840">The function returns</st> `<st
    c="13861">-1</st>`<st c="13863">. If the current element at</st> `<st c="13891">a[index]</st>`
    <st c="13899">matches</st> `<st c="13908">target</st>`<st c="13914">, the function
    returns the current</st> `<st c="13949">index</st>`<st c="13954">. If the current
    element does not match the target, the function calls itself recursively, moving
    to the next index (</st>`<st c="14071">index + 1</st>`<st c="14081">).</st> <st
    c="14085">The algorithm can be described using a subtractive recurrence function,
    specifically</st> <st c="14170">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1211.png)<st
    c="14184"><st c="14186">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14187">This recurrence relation indicates that with each recursion, the
    size of the problem is reduced by one (i.e., the amount of data to be evaluated
    against the search criteria decreases by one).</st> <st c="14380">This fits the
    following</st> <st c="14404">general form:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1212.png)<st
    c="14417"><st c="14444">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14445">Using the</st> <st c="14456">Master Theorem for subtractive recurrences,
    we can identify which</st> <st c="14522">case applies:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="14535">Case 1</st>**<st c="14542">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/796.png)<st
    c="14548"><st c="14553">,</st> <st c="14555">then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1214.png)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14571">Case 2</st>**<st c="14577">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/801.png)<st
    c="14583"><st c="14584">,</st> <st c="14586">then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1216.png)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14606">Case 3</st>**<st c="14612">: If</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>></mo><mn>1</mn></mrow></mrow></math>](img/806.png)<st
    c="14618"><st c="14625">,</st> <st c="14627">then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1218.png)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="14650">With the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1219.png)<st
    c="14659"><st c="14660">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1220.png)<st
    c="14662"><st c="14663">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1221.png)
    <st c="14669"><st c="14670">parameters in the subtractive recurrence function,</st>
    *<st c="14722">Case 1</st>* <st c="14728">applies.</st> <st c="14738">Thus, the
    time complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1222.png)
    <st c="14764"><st c="14765">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1223.png)<st
    c="14769"><st c="14770">, confirming that the running time of the algorithm</st>
    <st c="14822">is linear.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14832">Both implementations demonstrate</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1204.png)
    <st c="14866"><st c="14867">time complexity, meaning that in the worst case, every
    element in the array must be checked to find the target element.</st> <st c="14988">However,
    both implementations have a</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)
    <st c="15025"><st c="15026">or constant space complexity, which is a significant
    advantage.</st> <st c="15091">Linear search is simple and easy to understand,
    requiring no specific data format, preprocessing, or</st> <st c="15192">prior
    sorting.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15206">Linear search is used in scenarios where simplicity and ease of
    implementation are priorities, and when the dataset is relatively small or unsorted.</st>
    <st c="15356">It is particularly useful in the</st> <st c="15389">following situations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15410">Unsorted or unstructured data</st>**<st c="15440">: When the
    data is not sorted or stored in a specific structure that facilitates faster search
    methods, linear search is a straightforward and</st> <st c="15584">viable option</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15597">Small datasets</st>**<st c="15612">: For small datasets, the
    overhead of more complex search algorithms may not be justified, making linear
    search an</st> <st c="15728">efficient choice</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15744">First occurrence search</st>**<st c="15768">: When you need
    to find the first occurrence of an element in an array or list, linear search</st>
    <st c="15863">is appropriate</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15877">Single or few searches</st>**<st c="15900">: If you only need
    to perform a single search or a few searches, the simplicity of linear search
    can outweigh the benefits of more complex algorithms that require preprocessing
    (such</st> <st c="16084">as sorting)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16095">Linear search is used in various applications where the preceding
    conditions apply.</st> <st c="16180">Some common applications</st> <st c="16204">include</st>
    <st c="16213">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="16227">Scanners and parsers</st>**<st c="16248">: Linear search is
    often used in lexical scanners and parsers to find tokens or specific patterns
    within a sequence of characters</st> <st c="16379">or data</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16386">Lookup operations in unsorted lists</st>**<st c="16422">: When
    working with unsorted lists or arrays, linear search is used to find specific
    elements</st> <st c="16517">or values</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16526">Validation and verification</st>**<st c="16554">: Linear search
    is used to validate input or verify the presence of an element in a list, such
    as checking whether a user-entered value exists in a database</st> <st c="16712">or
    list</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16719">Real-time systems</st>**<st c="16737">: In real-time systems
    where data is constantly changing and sorting is not feasible, linear search provides
    a quick way to find elements without</st> <st c="16884">requiring preprocessing</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16907">Embedded systems</st>**<st c="16924">: In embedded systems
    with limited resources, the constant space complexity of linear search makes it
    a suitable choice for</st> <st c="17049">searching operations</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17069">While linear search may not be the most efficient algorithm for
    large or sorted datasets, its simplicity, constant space complexity, and flexibility
    make it a valuable tool in various applications, particularly when working with
    unsorted or</st> <st c="17311">small datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17326">Sub-linear search</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17344">In algorithm design, sub-linear search algorithms represent a
    class of techniques that offer</st> <st c="17438">search solutions more efficiently
    than linear time.</st> <st c="17490">These algorithms are particularly powerful
    because they can locate an element without needing to examine every item in the
    dataset.</st> <st c="17622">By leveraging the properties of sorted data and advanced
    partitioning strategies, sub-linear search algorithms reduce the number of comparisons
    required, thereby accelerating the search process.</st> <st c="17817">This efficiency
    makes them invaluable in handling large datasets where linear search methods would
    be</st> <st c="17919">impractically slow.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17938">Sub-linear search algorithms, such as binary search, jump search,
    and Fibonacci search, exploit different</st> <st c="18044">strategies to minimize
    the search space quickly.</st> <st c="18094">Binary search, for instance, repeatedly
    divides the array into two halves, while jump search segments the data into blocks
    and performs linear searches within these smaller sections.</st> <st c="18277">Fibonacci
    search utilizes the Fibonacci sequence to determine the range of the search space,
    optimizing for data that fits well into memory blocks.</st> <st c="18425">Each
    of these algorithms offers unique advantages and is suited to specific types of
    problems, highlighting the versatility and power of sub-linear search methods
    in computational efficiency.</st> <st c="18617">Let’s deep dive into the most
    well-known sub-linear</st> <st c="18669">search algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18687">Binary search</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="18701">Binary search</st>** <st c="18715">is an</st> <st c="18722">effective
    method for locating an element in a sorted array.</st> <st c="18782">The algorithm
    operates by continuously</st> <st c="18821">halving the search space.</st> <st
    c="18847">If the middle element matches the target value, the search is complete.</st>
    <st c="18919">If not, the search proceeds in the half of the array where the target
    value is likely to be found.</st> <st c="19018">Binary search is often implemented
    recursively.</st> <st c="19066">The</st> <st c="19069">following is a recursive
    implementation of</st> <st c="19113">binary search:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="19416">Binary</st> <st c="19424">search</st> <st c="19430">works by repeatedly
    dividing the search interval in half.</st> <st c="19489">The time complexity of
    binary search is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1226.png)<st
    c="19529"><st c="19538">. Let’s analyze and prove this time complexity</st> <st
    c="19585">in detail.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19595">Given a sorted array,</st> `<st c="19618">a</st>`<st c="19619">,
    and a target value,</st> `<st c="19641">target</st>`<st c="19647">, binary search
    follows</st> <st c="19671">these steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="19683">Initialization</st>**<st c="19698">: Set two pointers,</st>
    **<st c="19719">left</st>** <st c="19723">and</st> **<st c="19728">right</st>**<st
    c="19733">, at the beginning and end of the</st> <st c="19767">array, respectively.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="19787">Middle element</st>**<st c="19802">: Calculate the middle index,</st>
    **<st c="19833">mid = left + (right - left) //</st>** **<st c="19864">2</st>**<st
    c="19865">.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="19866">Comparison</st>**<st c="19877">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="19879">If</st> **<st c="19882">a[mid] == target</st>**<st c="19898">,
    the target is found, and the</st> **<st c="19929">mid</st>** <st c="19932">index</st>
    <st c="19939">is returned</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19950">If</st> **<st c="19954">a[mid] < target</st>**<st c="19969">,
    update</st> **<st c="19978">left</st>** <st c="19982">to</st> **<st c="19986">mid
    + 1</st>** <st c="19993">and repeat</st> <st c="20005">the process</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20016">If</st> **<st c="20020">a[mid] > target</st>**<st c="20035">,
    update</st> **<st c="20044">right</st>** <st c="20049">to</st> **<st c="20053">mid
    - 1</st>** <st c="20060">and repeat</st> <st c="20072">the process</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20083">Termination</st>**<st c="20095">: The process continues until</st>
    **<st c="20126">left > right</st>**<st c="20138">. If the target is not found,</st>
    <st c="20168">return</st> **<st c="20175">-1</st>**<st c="20177">.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="20178">The initial search space is the entire array of size</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="20232"><st c="20281">. At each step, the algorithm compares the target with
    the middle element.</st> <st c="20356">Based on the comparison, the search space
    is halved; either the left half or the right half</st> <st c="20448">is discarded:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20461">After the first step, the search space</st> <st c="20501">is</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mrow></math>](img/693.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20505">After the second step, the search space</st> <st c="20545">is</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle scriptlevel="+1"><mfrac><mi>n</mi><mn>4</mn></mfrac></mstyle></mrow></math>](img/695.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20549">After the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1230.png)
    <st c="20559"><st c="20560">step, the search space</st> <st c="20584">is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math>](img/1231.png)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20588">The algorithm stops when the search space is reduced to 1 element,
    i.e.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1232.png)<st
    c="20661"><st c="20664">. Now we solve it for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)<st
    c="20686"><st c="20687">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mi>n</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac></mstyle><mo>=</mo><mn>1</mn><mo>⟹</mo><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>⟹</mo><mi>k</mi><mo>=</mo><mi>log</mi><mi>n</mi></mrow></mrow></math>](img/1234.png)<st
    c="20689"><st c="20718">. Therefore, the binary search algorithm performs at most</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)
    <st c="20776"><st c="20783">comparisons.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20795">We can</st> <st c="20802">also</st> <st c="20808">prove the time
    complexity using a recurrence function.</st> <st c="20863">Let’s define</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1236.png)
    <st c="20876"><st c="20877">as the time complexity of binary search on an array
    of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="20938"><st c="20987">. If the array size is 1 (</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/1238.png)<st
    c="21013"><st c="21015">), the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)
    <st c="21041"><st c="21042">because it involves a single</st> <st c="21072">comparison:</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow></mrow></mrow></math>](img/1240.png)<st
    c="21084"><st c="21085">.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21086">For an array of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="21108"><st c="21157">, we perform one comparison to check the middle element,
    then we recursively search in the left or right half, each of size</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="21281"><st c="21282">. Then, the recurrence function of recursive binary search
    is</st> <st c="21344">as follows:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1243.png)<st
    c="21355"><st c="21373">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21374">Using the Master Theorem for divide-and-conquer recurrence relations,</st>
    *<st c="21445">Case 2</st>* <st c="21451">applies.</st> <st c="21461">Therefore,
    the</st> <st c="21476">following applies:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Θ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1244.png)<st
    c="21494"><st c="21510">.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21511">Unlike linear search, binary search is highly efficient, making
    it suitable for large datasets.</st> <st c="21608">The algorithm is straightforward
    to implement and understand.</st> <st c="21670">The iterative version uses constant
    space,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1245.png)<st
    c="21713"><st c="21714">, and even the recursive version has relatively low space
    overhead,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1246.png)<st
    c="21782"><st c="21791">. The primary use case for binary search is finding an
    element in a sorted array or list.</st> <st c="21881">Binary search is also used
    in dictionary operations such as finding words in a sorted list</st> <st c="21972">of
    entries.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21983">On the other hand, binary search only works on sorted arrays.</st>
    <st c="22046">If the data is unsorted, it must first be sorted, which adds additional
    overhead.</st> <st c="22128">Binary search is best suited for static arrays where
    the data does not change frequently.</st> <st c="22218">Frequent insertions and
    deletions would require re-sorting the array, increasing the sorting overhead.</st>
    <st c="22321">Additionally, binary search is less efficient with linked lists
    or other non-contiguous memory structures because it relies on efficient random
    access provided</st> <st c="22481">by arrays.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22491">The concept of dividing a dataset at the midpoint can be extended
    to partitioning the dataset into more than two segments.</st> <st c="22615">Ternary
    search is an example of this approach.</st> <st c="22662">It is a divide-and-conquer
    search algorithm that operates on a sorted array by dividing the array into three
    parts and determining in which part the target element lies, thereby reducing
    the search space to one-third.</st> <st c="22880">This process is repeated until
    the target element is found or the search space is exhausted.</st> <st c="22973">Consequently,
    the time complexity of ternary search</st> <st c="23025">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1247.png)<st
    c="23028"><st c="23037">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23038">Interpolation search</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="23059">Interpolation search</st> <st c="23080">is an improvement over
    binary search for searching a target value within a sorted array.</st> <st c="23170">While
    binary search always probes the middle element, interpolation</st> <st c="23237">search
    makes an educated guess about where the target value might be located based on
    the values at the array’s boundaries and the target</st> <st c="23376">value itself.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23389">The following is</st> <st c="23407">a recursive implementation
    of</st> <st c="23437">interpolation search:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23852">When comparing the code for interpolation search and binary search,
    the main difference lies in how the midpoint (or position) is calculated in each
    algorithm.</st> <st c="24013">This difference reflects the approach each algorithm
    takes to locate the target element.</st> <st c="24102">In binary search, the midpoint
    is calculated as the average of the left and</st> <st c="24178">right indices:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="24192">mid = left + (right - left) // 2</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24225">Binary search assumes a uniform distribution of elements and divides
    the search interval in half, regardless of the actual values of the elements.</st>
    <st c="24373">In interpolation search, the midpoint (represented by</st> `<st
    c="24427">pos</st>`<st c="24430">) is estimated based on the value of the target
    element relative to the values at the current low and</st> <st c="24533">high
    indices:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="24546">pos = low + ((high - low) // (arr[high] - a[low]) * (target
    -</st>` `<st c="24609">a[low]))</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24617">Interpolation search attempts</st> <st c="24647">to improve the
    midpoint estimation by considering the distribution of the elements.</st> <st
    c="24732">This makes it more efficient for uniformly distributed datasets, as
    it can potentially reduce the number of comparisons by jumping closer to the</st>
    <st c="24877">target element.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24892">Let’s explore the</st> <st c="24910">intuition behind interpolation
    search.</st> <st c="24950">Imagine the array as a number line.</st> <st c="24986">Interpolation
    search estimates the position of the target value based on its relative position
    between the minimum and maximum values in the array.</st> <st c="25134">When the
    values are uniformly distributed, this estimation tends to be quite accurate,
    resulting in faster convergence compared to</st> <st c="25265">binary search.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="25279">We know that the time complexity of binary search is</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1248.png)<st
    c="25333"><st c="25342">. Now the question is: what is the time complexity of
    interpolation search?</st> <st c="25418">First, we need to find the recurrence
    function describing the behavior of the interpolation search algorithm.</st> <st
    c="25528">Interpolation search operates by estimating the position of the target
    value within the array and then recursively or iteratively refining this estimate.</st>
    <st c="25682">The efficiency of this process depends significantly on the distribution
    of the values within the array.</st> <st c="25787">For uniformly distributed data,
    the estimated position is close to the actual position of the target, leading
    to fewer comparisons.</st> <st c="25919">The position estimate is given by</st>
    <st c="25953">the following:</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi
    mathvariant="bold-italic">h</mml:mi><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mi
    mathvariant="bold-italic">g</mml:mi><mml:mi mathvariant="bold-italic">h</mml:mi><mml:mo>-</mml:mo><mml:mi
    mathvariant="bold-italic">l</mml:mi><mml:mi mathvariant="bold-italic">o</mml:mi><mml:mi
    mathvariant="bold-italic">w</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi mathvariant="bold-italic">h</mml:mi><mml:mi
    mathvariant="bold-italic">i</mml:mi><mml:mi mathvariant="bold-italic">g</mml:mi><mml:mi
    mathvariant="bold-italic">h</mml:mi></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mi
    mathvariant="bold-italic">a</mml:mi><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mi
    mathvariant="bold-italic">l</mml:mi><mml:mi mathvariant="bold-italic">o</mml:mi><mml:mi
    mathvariant="bold-italic">w</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mi>a</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1249.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="26041">In each iteration, the size of the search interval is reduced
    proportionally based on the estimated position.</st> <st c="26151">On average,
    interpolation search reduces the search space more significantly than binary search.</st>
    <st c="26248">However, the estimated position heavily depends on the distribution
    of the data.</st> <st c="26329">In the worst-case scenario, when the distribution
    is highly skewed, the time complexity is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1250.png)<st
    c="26420"><st c="26421">, making interpolation search no better than</st> <st
    c="26466">linear search.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26480">In a more realistic average case, where the data distribution
    is closer to uniform, interpolation search performs better.</st> <st c="26603">To
    analyze this, we need to determine the recurrence function for this scenario.</st>
    <st c="26684">For uniformly distributed data, we assume that the problem size
    is reduced by the square root of the original problem size in each recursion.</st>
    <st c="26826">This suggests the following recurrence relation for interpolation
    search in the</st> <st c="26906">average-case scenario:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi mathvariant="bold-italic">n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1251.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="26948">Since</st> <st c="26953">the</st> <st c="26957">recurrence function
    does not fit the standard format of the Master Theorem, we need to use alternative
    approaches, such as the substitution method, to</st> <st c="27109">solve it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27118">Let’s perform a variable change:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:math>](img/644.png)<st
    c="27152"><st c="27153">. We can then rewrite the recurrence function</st> <st
    c="27199">as follows:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1253.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27212">Next, make another variable change:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1254.png)<st
    c="27248"><st c="27249">. The recurrence relation now becomes</st> <st c="27287">the
    following:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>S</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1255.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27320">This is a familiar recurrence function (similar to binary search),
    and we can conclude</st> <st c="27407">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>S</mi><mo>(</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1256.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27438">Replacing</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="27448"><st c="27449">back with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)<st
    c="27460"><st c="27467">, we</st> <st c="27472">get this:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>S</mi><mfenced
    open="(" close=")"><mi>m</mi></mfenced><mo>=</mo><mi>T</mi><mfenced open="(" close=")"><msup><mn>2</mn><mi>m</mi></msup></mfenced><mo>=</mo><mi>T</mi><mfenced
    open="(" close=")"><msup><mn>2</mn><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></msup></mfenced><mo>=</mo><mi>T</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>O</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/1259.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27525">In the worst case, if the distribution of elements is highly skewed
    or not uniform, the position estimates can be inaccurate, leading to a linear
    search behavior.</st> <st c="27688">This results in a worst-case time complexity
    of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1260.png)<st
    c="27736"><st c="27737">. On the other hand, the space complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)
    <st c="27782"><st c="27783">because interpolation search only needs to keep the</st>
    `<st c="27836">pos</st>` <st c="27839">variable in memory, which does not depend
    on the size of</st> <st c="27897">the data.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27906">Interpolation search is highly efficient for uniformly distributed
    data but can degrade to linear search performance for non-uniform distributions.</st>
    <st c="28055">This analysis shows that while interpolation search has potential
    advantages, its efficiency is highly dependent on the</st> <st c="28175">data
    distribution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28193">Exponential search</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="28212">Exponential search</st>**<st c="28231">, also</st> <st c="28238">known
    as</st> **<st c="28247">galloping search</st>** <st c="28263">or</st> **<st c="28267">doubling
    search</st>**<st c="28282">, is an</st> <st c="28289">algorithm</st> <st c="28300">for
    finding a range in a sorted array where a target value might be located.</st>
    <st c="28377">It works by</st> <st c="28389">initially checking the first element
    and then repeatedly doubling the interval size until it finds a range that may
    contain the target.</st> <st c="28525">Once this range is found, binary search
    is used within the range to locate the</st> <st c="28604">target value.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28617">The time complexity of exponential search is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1262.png)
    <st c="28663"><st c="28672">in both the worst-case and average-case scenarios.</st>
    <st c="28723">This efficiency is due to the algorithm’s approach of rapidly increasing
    the interval size and then using a binary search within the</st> <st c="28856">identified
    range.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28873">Exponential search first finds a range where the target element
    might be located by repeatedly doubling the index.</st> <st c="28989">This step
    takes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1263.png)
    <st c="29005"><st c="29013">time because the doubling process essentially performs
    a binary search on the indices.</st> <st c="29100">Once the range is found, a
    binary search within that range takes another</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1264.png)
    <st c="29173"><st c="29181">time.</st> <st c="29187">However, since the range-finding
    step already reduces the problem size significantly, the overall time complexity</st>
    <st c="29301">remains</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1265.png)<st
    c="29309"><st c="29317">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29318">The space complexity of exponential search depends on the implementation
    method.</st> <st c="29400">In the iterative approach, the space complexity is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1266.png)<st
    c="29451"><st c="29452">. The following is a simple iterative implementation of</st>
    <st c="29508">exponential search:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29714">Let’s briefly explain the code.</st> <st c="29747">The key part
    of the code is the line</st> `<st c="29784">while i < n and a[i] <= target:</st>`<st
    c="29815">, where the exponential growth occurs:</st> `<st c="29854">i = i * 2</st>`<st
    c="29863">. In this step, the index doubles (</st>`<st c="29898">1</st>`<st c="29900">,</st>
    `<st c="29902">2</st>`<st c="29903">,</st> `<st c="29905">4</st>`<st c="29906">,</st>
    `<st c="29908">8</st>`<st c="29909">, and so on) until a value larger than or
    equal to the target is found.</st> <st c="29981">Once this range is identified,</st>
    `<st c="30012">binary_search</st>` <st c="30025">is performed within that range
    to locate the</st> <st c="30071">target element.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30086">The</st> <st c="30090">iterative implementation uses a</st> <st
    c="30122">constant amount of extra space regardless of the size of the input array.</st>
    <st c="30197">The only additional memory required is for a few variables to keep
    track of the indices and the</st> <st c="30293">target element.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30308">Unlike the iterative approach, in the recursive method, the space
    complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1265.png)<st
    c="30389"><st c="30397">. Let’s have a look at the</st> <st c="30424">recursive
    implementation:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30676">The recursive implementation uses additional space on the call
    stack for each recursive call.</st> <st c="30771">Since the depth of the recursion
    is proportional to</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)<st
    c="30823"><st c="30830">, the space complexity</st> <st c="30853">is</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1226.png)<st
    c="30856"><st c="30865">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30866">Exponential search is an effective algorithm for quickly narrowing
    down the search range in large, sorted arrays.</st> <st c="30981">By combining
    the strengths of exponential and binary search, it offers both efficiency and
    flexibility.</st> <st c="31085">Its main advantage lies in its ability to handle
    large datasets efficiently, although it requires the data to be sorted and introduces
    some complexity with its dual-phase</st> <st c="31256">search approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31272">Jump search</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="31284">Jump search</st>** <st c="31296">is an</st> <st c="31302">algorithm
    for finding an element in a sorted array.</st> <st c="31355">It works by</st>
    <st c="31367">dividing the array into blocks of a fixed size, jumping ahead by
    that block size, and then performing a linear search within the block where the
    target element might be located.</st> <st c="31545">The optimal step size for
    jumping is typically</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="31592"><st c="31593">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1271.png)
    <st c="31601"><st c="31602">is the number of elements in the array.</st> <st c="31643">This
    method aims</st> <st c="31659">to reduce the number of comparisons by skipping
    over large sections of the array initially.</st> <st c="31752">We will prove that
    the time complexity of jump search is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)<st
    c="31809"><st c="31815">. The iterative</st> <st c="31830">implementation of jump
    search is</st> <st c="31864">as follows:</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32171">Recursive implementation of jump search is less common due to
    the nature of the algorithm.</st> <st c="32263">However, it can be implemented</st>
    <st c="32294">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32692">Let’s</st> <st c="32699">analyze</st> <st c="32706">the algorithm
    and then estimate the time complexity of jump search.</st> <st c="32775">The algorithm
    is implemented in</st> <st c="32807">three steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="32819">Initialization</st>**<st c="32834">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="32836">Set the block size</st> <st c="32855">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="32858"><st c="32859">.</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32860">Initialize</st> **<st c="32872">prev</st>** <st c="32876">to</st>
    **<st c="32880">0</st>** <st c="32881">and</st> **<st c="32886">step</st>** <st
    c="32890">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="32894"><st c="32895">.</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32896">Jumping phase</st>**<st c="32910">: Jump ahead by the block
    size until the value at the current position is greater than or equal to the target
    or the end of the array</st> <st c="33045">is reached.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="33056">Linear search phase</st>**<st c="33076">: Perform a linear
    search within the</st> <st c="33114">identified block.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="33131">Now, let’s analyze the time complexity.</st> <st c="33172">We
    know that the size of each block is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="33211"><st c="33212">. In the worst case, we may need to jump through the entire
    array to find the block containing the target element.</st> <st c="33327">The
    number of jumps required to reach the target block is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mfenced
    open="⌈" close="⌉" separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="⌈" close="⌉" separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/1276.png)<st
    c="33385"><st c="33386">. Each jump involves a comparison, and thus the number
    of comparisons in the jumping phase</st> <st c="33477">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="33480"><st c="33481">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33482">At this stage, we</st> <st c="33501">are ready to start the linear
    search phase.</st> <st c="33545">After identifying the potential block, a linear
    search is performed within this block.</st> <st c="33632">The</st> <st c="33635">maximum
    number of elements to search within a block is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="33691"><st c="33692">. Thus, the number of comparisons in the linear search
    phase is, at</st> <st c="33760">most,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="33766"><st c="33767">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33768">We had two</st> <st c="33780">following phases:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33797">Jumping phase</st> <st c="33812">comparisons:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33831">Linear search phase</st> <st c="33851">comparisons:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33870">We add two phases together; the total number of comparisons is</st>
    <st c="33933">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1282.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="33965">The total time complexity of the jump search algorithm is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1283.png)<st
    c="34023"><st c="34029">. This is because the algorithm performs up to</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1284.png)
    <st c="34076"><st c="34077">comparisons during the jumping phase and up to</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1284.png)
    <st c="34125"><st c="34126">comparisons during the linear search phase within
    the block.</st> <st c="34188">The combination of these phases results in an overall
    time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)<st
    c="34261"><st c="34267">. This analysis shows that jump search is less efficient
    than binary search,</st> <st c="34344">O</st><st c="34345">(</st><st c="34346">l</st><st
    c="34347">o</st><st c="34348">g</st> <st c="34349">n</st><st c="34350">)</st><st
    c="34351">, but can still be useful in scenarios where the simplicity of implementation
    and constant space complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)
    <st c="34459"><st c="34460">are advantageous.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34477">Jump search is more efficient than linear search for large arrays
    because it reduces the number of comparisons by skipping over blocks of elements.</st>
    <st c="34626">The jump search algorithm is relatively simple to implement and
    understand and, unlike binary search, jump search does not require any preprocessing
    of the data other than ensuring it</st> <st c="34810">is sorted.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34820">However, jump search comes with some limitations.</st> <st c="34871">Like
    binary search, jump search only works on sorted arrays.</st> <st c="34932">Also,
    the efficiency of jump search depends on choosing an optimal block size, which
    is generally</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="35030"><st c="35031">, but this might not always be the most efficient in practice.</st>
    <st c="35094">For very small arrays, the overhead of calculating the block size
    and performing the jumps might make it less efficient than simpler algorithms
    such as</st> <st c="35246">linear search.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35260">Jump search is useful when searching in large sorted arrays where
    binary search might be less intuitive or when the data is accessed sequentially.</st>
    <st c="35408">In databases, jump search can be used for indexing and querying
    sorted data efficiently.</st> <st c="35497">The other use case for jump search
    is in memory-constrained environments.</st> <st c="35571">Given its</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1289.png)
    <st c="35581"><st c="35582">space complexity, jump search is suitable for memory-constrained
    environments where additional space for data structures</st> <st c="35704">such
    as binary search trees or hash tables is</st> <st c="35750">not available.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35764">In summary, jump search</st> <st c="35788">is an effective algorithm
    for searching in sorted arrays, striking a balance between the simplicity of linear
    search and the efficiency of binary search.</st> <st c="35943">Its primary advantage
    lies in its</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)
    <st c="35977"><st c="35983">time complexity, making it suitable for certain applications
    where sorted data needs to be</st> <st c="36074">searched quickly.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36091">Recap</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="36097">All sub-linear search algorithms rely on sorted data, which means
    they must first sort the data if it is not already sorted.</st> <st c="36223">This
    poses a significant limitation when the data is dynamically changing.</st> <st
    c="36298">We will discuss this in detail in the</st> <st c="36336">next chapter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36349">Most sub-linear search algorithms are improvements or extensions
    of binary search, except for jump search, which is based on segmenting the data
    and then searching within each segment.</st> <st c="36535">The main idea behind
    binary search and its variants is to find the most optimal estimation of the mid
    position in the array.</st> <st c="36660">This differentiates binary search from
    interpolation and exponential search.</st> <st c="36737">On the other hand, the
    goal of every search algorithm is to reduce the search space or scope we are looking
    in for the target and to minimize the risk of missing it.</st> <st c="36903">In
    all variants of binary search, this is done by one or more midpoints, while in
    jump search, this is achieved by evenly splitting the</st> <st c="37039">search
    space.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37052">If we split the search space (dataset) into many partitions, for
    example,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:math>](img/1270.png)<st
    c="37127"><st c="37128">, we are referring to jump search.</st> <st c="37163">While
    it may seem similar to binary search, which has a single midpoint, jump search
    divides the dataset into multiple partitions and uses multiple midpoints (</st>*<st
    c="37322">number of partitions = number of midpoints + 1</st>*<st c="37369">).</st>
    <st c="37373">This distinction leads to a different time complexity pattern for
    jump search, which is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)<st
    c="37461"><st c="37467">, compared to the</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1226.png)
    <st c="37485"><st c="37494">complexity of binary search and</st> <st c="37526">its
    variations.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37541">An interesting approach is to use the Fibonacci sequence to partition
    the search space.</st> <st c="37630">This leads us to the Fibonacci search.</st>
    <st c="37669">Fibonacci search is an efficient search algorithm that works on
    sorted arrays.</st> <st c="37748">It leverages the properties of Fibonacci numbers
    to divide the array into smaller sections, making it similar to both binary and
    jump searches.</st> <st c="37892">The main advantage of Fibonacci search is its
    efficiency when dealing with arrays that fit well into</st> <st c="37993">memory
    blocks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38007">Hashing</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="38015">In the previous</st> <st c="38031">two sections, we explored
    two groups of search algorithms: those with linear time complexity and those with
    more efficient, sub-linear time complexity.</st> <st c="38184">Linear search algorithms,
    such as the simple sequential search, operate with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1294.png)
    <st c="38261"><st c="38262">time complexity, making them straightforward but less
    efficient for large datasets.</st> <st c="38347">On the other hand, sub-linear
    search algorithms, such as binary search and jump search, offer significantly
    better time complexities, often</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1246.png)
    <st c="38487"><st c="38496">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfenced></mml:math>](img/1272.png)<st
    c="38499"><st c="38505">, by leveraging the properties of sorted data to minimize
    the number of</st> <st c="38577">comparisons needed.</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="38596">However, achieving this improved time complexity comes with a
    cost: the time required to sort the data.</st> <st c="38701">Sorting is a prerequisite
    for the efficiency of sub-linear search algorithms.</st> <st c="38779">Without
    sorted data, the theoretical benefits of sub-linear time complexity cannot be
    realized.</st> <st c="38875">The process of sorting itself can be time-consuming,
    typically</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>O</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mfenced></mrow></mrow></math>](img/1297.png)
    <st c="38938"><st c="38949">for efficient algorithms such as quick sort or merge
    sort.</st> <st c="39008">Therefore, while sub-linear search algorithms provide
    faster search times, they are only practical when the data can be sorted efficiently
    or when the data remains relatively static, allowing the sorting step to be amortized
    over multiple searches.</st> <st c="39257">This trade-off between sorting time
    and search efficiency is a critical consideration in the design and application
    of</st> <st c="39376">search algorithms.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="39394">The question now arises: can we achieve even better performance
    than sub-linear search algorithms?</st> <st c="39494">Specifically, is it possible
    to perform a search in constant time, or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1298.png)<st
    c="39564"><st c="39565">? To answer this question, we need to review the objective
    of the search operation.</st> <st c="39649">The objective of any search algorithm
    is to efficiently find the index or address of a key within a data structure.</st>
    <st c="39765">One approach to achieving constant time search is through a technique
    known</st> <st c="39841">as hashing.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39852">In hashing, we use a hash function that takes the target key as
    input and computes a value that directly corresponds to the location of the key
    in the data structure.</st> <st c="40020">This value, known as the hash value
    (or hash code), is then used to index into a hash table, allowing for constant
    time access to</st> <st c="40150">the data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40159">Before diving into the subject of hashing, let’s define some</st>
    <st c="40221">basic terms:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="40233">Key</st>**<st c="40237">: In the</st> <st c="40246">context
    of search algorithms and data structures, a key is a unique identifier used to
    search, access, or manage elements within a collection, such as an array, list,
    or database.</st> <st c="40427">Keys are essential for efficient data retrieval
    and manipulation.</st> <st c="40493">For example, in a dictionary, the key might
    be a word, and the associated value could be the definition of that word.</st>
    <st c="40611">Keys are used in various data structures, such as hash tables, where
    they are input into a hash function to generate</st> <st c="40728">an index.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40737">Index</st>**<st c="40743">: An</st> <st c="40748">index is
    a numerical representation of a position within a data structure, such as an array
    or list.</st> <st c="40850">It indicates where a particular element is stored
    within that structure.</st> <st c="40923">For example, in an array of</st> **<st
    c="40951">[10, 20, 30, 40]</st>**<st c="40967">, the index of the</st> **<st c="40986">30</st>**
    <st c="40988">element is</st> **<st c="41000">2</st>**<st c="41001">. Indexes
    are crucial for accessing elements directly in data structures that support random
    access, such as arrays</st> <st c="41117">and lists.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41127">Address</st>**<st c="41135">: An address</st> <st c="41149">refers
    to a specific location in memory where a data element is stored.</st> <st c="41221">In
    the context of search and data structures, the address is often the actual memory
    location corresponding to a particular index or key.</st> <st c="41359">In low-level
    programming, such as C or C++, an address might be something such as</st> **<st
    c="41441">0x7ffee44b8b60</st>**<st c="41455">, indicating the exact memory location
    of a variable.</st> <st c="41509">Addresses are used to directly access and manipulate
    data stored in memory.</st> <st c="41585">In higher-level programming, addresses
    are often abstracted away, but understanding them is crucial for optimizing performance
    and understanding</st> <st c="41730">memory management.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41748">In hash tables, a key is passed through a hash function to generate
    an index.</st> <st c="41827">This index is then used to locate the corresponding
    data in the hash table.</st> <st c="41903">On the other hand, in arrays, an index
    directly corresponds to an address in memory where the data element</st> <st c="42010">is
    stored.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42020">Hash functions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="42035">A</st> **<st c="42038">hash function</st>** <st c="42051">is a</st>
    <st c="42056">mathematical function that transforms an input key into a numerical
    value, called</st> <st c="42138">a</st> **<st c="42141">hash value</st>**<st c="42151">.
    The hash value is then mapped to an index in a hash table.</st> <st c="42212">A
    good hash function distributes keys uniformly across the hash table to minimize
    collisions, where two or more keys hash to the same index.</st> <st c="42353">An
    effective hash function has several</st> <st c="42392">key properties:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="42407">Deterministic</st>**<st c="42421">: A</st> <st c="42426">hash
    function must consistently produce the same output (hash value) for the same input.</st>
    <st c="42515">This ensures predictability and reliability in applications such
    as data retrieval</st> <st c="42598">and verification.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42615">Fixed output size</st>**<st c="42633">: Regardless of the size
    of the input data, the output hash value should have a fixed length.</st> <st
    c="42728">This makes hash values easy to store and compare, enhancing efficiency
    in</st> <st c="42802">various algorithms.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42821">Efficiency</st>**<st c="42832">: Hash functions should be computationally
    fast, allowing for quick generation of hash values even for large inputs.</st>
    <st c="42950">This is essential for real-time applications and algorithms that
    rely on hashing</st> <st c="43031">for performance.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="43047">Uniformity</st>**<st c="43058">: A good hash function distributes
    its output values uniformly across the output space.</st> <st c="43147">Even a
    small change in the input should result in a significantly different hash value,
    preventing patterns and making it difficult to reverse-engineer</st> <st c="43299">the
    input.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="43309">Collision resistance</st>**<st c="43330">: It should be computationally
    infeasible to find two different inputs that produce the same hash value (a collision).</st>
    <st c="43450">Collision resistance is critical for security applications such
    as password storage and</st> <st c="43538">digital signatures.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43557">There are additional properties that are particularly important
    for cryptographic hash functions (beyond the scope of</st> <st c="43676">this
    book):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="43687">Pre-image resistance</st>**<st c="43708">: Given a hash value,
    it should be difficult to find the original input that produced it.</st> <st c="43799">This
    property protects against attacks that attempt to recover the original data from</st>
    <st c="43885">its hash.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="43894">Second pre-image resistance</st>**<st c="43922">: Given one
    input and its hash value, it should be difficult to find a second input that produces
    the</st> <st c="44025">same hash.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="44035">Non-correlation</st>**<st c="44051">: There should be no correlation
    between different parts of the input and the resulting</st> <st c="44140">hash
    value.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44151">By</st> <st c="44155">applying a hash function to the input data,
    we construct a hash table.</st> <st c="44226">A hash table is a data structure
    that stores key-value pairs.</st> <st c="44288">Each key is processed by the hash
    function to generate a hash value, which determines the index where the corresponding
    value is stored.</st> <st c="44425">The primary advantage of a hash table is that
    it enables search, insert, and delete operations to be performed in average-case</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)
    <st c="44552"><st c="44553">time complexity.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44569">The efficiency of a hash table depends on how well the hash function
    distributes keys across the table.</st> <st c="44674">Ideally, a good hash function
    will minimize the number of empty cells (making the table less sparse) and reduce
    the number of collisions (where multiple keys hash to the same index).</st> <st
    c="44857">The art of designing a good hash function lies in achieving a balance
    between these factors to ensure</st> <st c="44959">optimal performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44979">Meanwhile, it is crucial to note that when selecting a hash function
    for a specific algorithm, it is important to consider the application.</st> <st
    c="45120">Different applications may require different properties.</st> <st c="45177">For
    example, cryptographic applications demand strong collision resistance, while
    data structures might</st> <st c="45281">prioritize speed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45298">Constant time search using hashing</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="45333">The primary goal of</st> <st c="45354">hashing is to achieve constant
    time search by directly mapping keys to their locations in a hash table using
    a hash function.</st> <st c="45480">The</st> <st c="45484">most straightforward
    hash function is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi></mml:math>](img/1300.png)<st
    c="45522"><st c="45536">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1301.png)
    <st c="45544"><st c="45545">is the hash function.</st> <st c="45568">This method
    is known as direct addressing, and the resulting hash table is called a</st> <st
    c="45652">direct-address table.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45673">While direct addressing is simple and easy to understand, it comes
    with several</st> <st c="45754">significant limitations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="45778">Sparse hash table</st>**<st c="45796">: Direct addressing often
    creates a very sparse hash table, meaning that the table size must be as large
    as the range of possible input keys.</st> <st c="45939">For example, if the input
    keys range from 1 to 1,000,000, the hash table must have 1,000,000 slots, even
    if only a few keys are actually used.</st> <st c="46082">This results in inefficient
    use</st> <st c="46114">of memory.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="46124">High likelihood of collisions</st>**<st c="46154">: In direct
    addressing, if two different keys map to the same location (collision), it can
    cause issues with data retrieval and insertion.</st> <st c="46294">Although direct
    addressing assumes that each key is unique, in practice, collisions are</st> <st
    c="46382">often unavoidable.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="46400">Limited to numerical data</st>**<st c="46426">: Direct addressing
    is only effective for numerical, integer data.</st> <st c="46494">It does not
    work well with other data types, such as strings or composite objects, limiting
    its applicability in many</st> <st c="46612">real-world scenarios.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="46633">Implementing</st> <st c="46647">constant time search using hashing
    involves two key steps.</st> <st c="46706">First, it is essential to design an
    efficient hash function that satisfies as</st> <st c="46784">many of the desirable
    properties as possible.</st> <st c="46830">Despite efforts to create a good hash
    function, collisions are inevitable.</st> <st c="46905">Therefore, the second
    step is to handle collisions effectively during data structure operations, including
    search</st> <st c="47019">and retrieval.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47033">Types of hash function used in search</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="47071">Hash functions are</st> <st c="47091">crucial in determining the
    efficiency of hash-based search algorithms.</st> <st c="47162">Let’s explore some
    commonly employed hash functions, along with explanations</st> <st c="47239">and
    examples.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47252">Division-remainder (modulo) method</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="47287">The</st> **<st c="47292">division-remainder (modulo) method</st>**
    <st c="47326">is a</st> <st c="47331">straightforward and commonly used technique</st>
    <st c="47376">for generating hash values.</st> <st c="47404">In this method, the
    hash value is obtained by taking the remainder of the division of the key by the
    size of the hash table.</st> <st c="47529">The formula used is</st> <st c="47549">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mrow></mrow></math>](img/1302.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="47581">Here,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1301.png)
    <st c="47587"><st c="47588">is the hash function,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi></mml:math>](img/1304.png)
    <st c="47611"><st c="47615">is the input data, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="47638"><st c="47639">is the size of the hash table.</st> <st c="47671">Let’s
    consider an</st> <st c="47688">example to illustrate how this</st> <st c="47720">method
    works.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="47733">Example 7.1</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47745">Using the division-remainder hash method, we determine the hash
    value for the example key,</st> *<st c="47837">987654321</st>*<st c="47846">,
    with a hash table size</st> <st c="47871">of</st> *<st c="47874">100</st>*<st
    c="47877">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47878">Let’s determine the hash value step</st> <st c="47915">by step:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="47923">Apply the modulo operation</st>**<st c="47950">: Calculate
    the hash value by taking the key modulo the size of the</st> <st c="48019">hash
    table:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mn>987654321</mn><mo>)</mo><mo>=</mo><mn>987654321</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>100</mn></mrow></mrow></mrow></math>](img/1306.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**<st c="48065">Calculate the remainder</st>**<st c="48088">: Perform the division
    and find</st> <st c="48121">the remainder:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>987654321</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>100</mn><mo>=</mo><mn>21</mn></mrow></mrow></math>](img/1307.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: <st c="48137">Therefore, the hash value for the key</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>987654321</mml:mn></mml:math>](img/1308.png)
    <st c="48175"><st c="48176">with a hash table size of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>100</mml:mn></mml:math>](img/1309.png)
    <st c="48203"><st c="48204">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>21</mml:mn></mml:math>](img/1310.png)<st
    c="48207"><st c="48208">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48209">The modulo operation is straightforward and easy to implement,
    making this method simple and efficient.</st> <st c="48314">It is also computationally
    efficient, as the modulo operation is relatively fast.</st> <st c="48396">Moreover,
    the same input key will always produce the same hash value, ensuring consistency
    in the</st> <st c="48494">hash table.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48505">However, the</st> <st c="48519">modulo method has limitations.</st>
    <st c="48550">If the size of the hash table is poorly chosen (e.g., a power of
    2), the hash values may not be uniformly distributed, leading to clustering.</st>
    <st c="48692">To mitigate this issue, prime numbers are typically recommended
    for the table size.</st> <st c="48776">Additionally, if the input keys have patterns
    or common factors, this method may lead to collisions and clustering, reducing
    the efficiency of the hash table.</st> <st c="48935">Like all hash functions,
    the division-remainder method can result in collisions.</st> <st c="49016">Effective
    collision handling strategies, such as chaining or open addressing, are necessary
    to</st> <st c="49111">maintain performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49132">The</st> <st c="49137">division-remainder (modulo) method is a
    simple and efficient hash function commonly used in various applications.</st>
    <st c="49251">It generates hash values by taking the remainder of the division
    of the key by the hash table size.</st> <st c="49351">While it offers simplicity
    and computational efficiency, it is important to choose an appropriate table size
    (preferably a prime number) to ensure a uniform distribution of hash values.</st>
    <st c="49537">Additionally, collision-handling mechanisms are essential to address
    the inherent limitations of</st> <st c="49634">this method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49646">Multiplication method</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="49668">The</st> **<st c="49673">multiplication hash method</st>** <st
    c="49699">is a technique used to generate hash values by multiplying</st> <st
    c="49758">the key by a constant fraction</st> <st c="49790">and then extracting
    an appropriate portion of the result to produce the hash code.</st> <st c="49873">This
    method aims to distribute keys more uniformly across the hash table.</st> <st
    c="49947">Let’s explain this method step</st> <st c="49978">by step:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49986">Multiply the key by a constant,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)<st
    c="50019"><st c="50020">,</st> <st c="50022">where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>0</mn><mo><</mo><mi>A</mi><mo><</mo><mn>1</mn></mrow></mrow></math>](img/1312.png)<st
    c="50028"><st c="50029">.</st></st></st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50030">Extract the fractional part of</st> <st c="50062">the product.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50074">Multiply the fractional part by the hash table</st> <st c="50122">size</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)<st
    c="50127"><st c="50128">.</st></st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50129">Take the floor of the result to get the</st> <st c="50170">hash
    value.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50181">The formula for the hash function is</st> <st c="50219">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo>=</mo><mo>⌊</mo><mi>m</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>⋅</mo><mi>A</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>1</mn><mo>)</mo><mo>⌋</mo></mrow></mrow></mrow></math>](img/1314.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="50261">He</st><st c="50263">re,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mn>0.618033</mml:mn></mml:math>](img/1315.png)
    <st c="50268"><st c="50269">(an approximation of the golden ratio).</st> <st c="50310">Let’s
    see this method in</st> <st c="50335">an example.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="50346">Example 7.2</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50358">Using the</st> <st c="50368">multiplication</st> <st c="50384">hash
    method, we d</st><st c="50401">etermine the hash value for the example key,</st>
    *<st c="50447">123456</st>*<st c="50453">, and a hash table size</st> <st c="50477">of</st>
    *<st c="50480">100</st>*<st c="50483">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50484">Let’s determine the hash value step</st> <st c="50521">by step:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50529">Multiply the key by</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)<st
    c="50550"><st c="50551">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>123456</mn><mo>×</mo><mn>0.618033</mn><mo>=</mo><mn>76293.192648</mn></mrow></mrow></math>](img/1317.png)</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50554">Extract the fractional</st> <st c="50577">part:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0.192648</mml:mn></mml:math>](img/1318.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50584">Multiply by table</st> <st c="50602">size:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>0.192648</mn><mo>×</mo><mn>100</mn><mo>=</mo><mn>19.2648</mn></mrow></mrow></math>](img/1319.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50609">Take the</st> <st c="50618">floor:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="⌊" close="⌋" separators="|"><mml:mrow><mml:mn>19.2648</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>19</mml:mn></mml:math>](img/1320.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50642">Therefore, the hash value for the key</st> *<st c="50680">123456</st>*
    <st c="50686">with a hash table size of</st> *<st c="50713">100</st>* <st c="50716">is</st>
    *<st c="50720">19</st>*<st c="50722">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50723">The multiplication method tends to distribute keys more uniformly
    across the hash table, thereby reducing clustering.</st> <st c="50842">Additionally,
    unlike the division method, the effectiveness of the multiplication method is
    less dependent on the table size being a prime number.</st> <st c="50989">Moreover,
    the multiplication and modulo operations are</st> <st c="51044">computationally
    efficient.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51070">However, the multiplication method has some limitations.</st>
    <st c="51128">Its effectiveness heavily depends on the choice of the constant</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1321.png)<st
    c="51192"><st c="51193">. While the golden ratio is commonly used, other values
    may need to be tested for optimal performance.</st> <st c="51296">For very large
    keys or highly precise values of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1322.png)<st
    c="51344"><st c="51345">, precision issues in floating-point arithmetic could
    affect the hash values.</st> <st c="51423">Lastly, the need to handle floating-point
    arithmetic can make the implementation slightly more complex compared to the</st>
    <st c="51542">division method.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51558">Mid-square method</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="51576">The</st> <st c="51581">mid-square hash function</st> <st c="51605">is
    a technique used to generate hash values by squaring the key and then extracting
    an appropriate number of middle digits or bits from the result.</st> <st c="51754">This
    method aims to distribute keys more uniformly across the hash table, leveraging
    the properties of squaring to spread out the values.</st> <st c="51892">Let’s
    consider an example to illustrate the mid-square</st> <st c="51947">hash function.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="51961">Example 7.3</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51973">Using the mid-square</st> <st c="51994">hash method, we determine
    the hash value for the example key</st> *<st c="52056">456</st>* <st c="52059">with
    a hash table size</st> <st c="52083">of</st> *<st c="52086">100</st>*<st c="52089">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="52091">Square the key</st>**<st c="52105">: Square the key to obtain
    a large</st> <st c="52141">number:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>456</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>207936</mml:mn></mml:math>](img/1323.png)<st
    c="52149"><st c="52150">.</st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="52151">Extract the middle digits</st>**<st c="52177">: Extract an
    appropriate number of middle digits from the squared value.</st> <st c="52251">The
    number of digits to extract can depend on the size of the hash table.</st> <st
    c="52325">For simplicity, let’s extract two</st> <st c="52359">middle digits:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="52373">Squared</st> <st c="52382">value:</st> *<st c="52389">207936</st>*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52395">Middle digits:</st> *<st c="52411">07</st>* <st c="52413">(from
    the middle of the</st> <st c="52438">squared number)</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="52453">Use the middle digits as the hash value</st>**<st c="52493">:
    Use these middle digits to determine the index in the hash table.</st> <st c="52562">Therefore,
    the key</st> *<st c="52581">456</st>* <st c="52584">is mapped to index</st> *<st
    c="52604">07</st>* <st c="52606">in the</st> <st c="52614">hash table.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="52625">Key</st> <st c="52629">properties of the mid-square hash function
    are</st> <st c="52677">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="52688">Uniform distribution</st>**<st c="52709">: By squaring the
    key and extracting the middle digits, this method tends to produce a more uniform
    distribution of keys, as squaring helps to spread out</st> <st c="52864">the values.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="52875">Simplicity</st>**<st c="52886">: The mid-square method is straightforward
    to implement.</st> <st c="52944">It involves squaring the key and then extracting
    the middle portion of</st> <st c="53015">the result.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53026">Independence from key size</st>**<st c="53053">: This method
    is relatively independent of the size of the key, making it suitable for various</st>
    <st c="53149">key lengths.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53161">On the</st> <st c="53169">other hand, the mid-square method has</st>
    <st c="53207">some limitations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="53224">Dependent on middle digits</st>**<st c="53251">: The efficiency
    of this method relies on the middle digits of the squared value.</st> <st c="53334">If
    the middle digits are not well distributed, it can lead</st> <st c="53393">to
    clustering.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53407">Selection of digits</st>**<st c="53427">: Deciding the number
    of middle digits to extract can be challenging and may require experimentation
    to optimize for</st> <st c="53545">specific applications.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53567">Limited key range</st>**<st c="53585">: For very small keys,
    the squared value might not provide enough digits to extract, reducing the effectiveness
    of</st> <st c="53701">the method.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53712">Computational cost</st>**<st c="53731">: Squaring the key can
    be computationally expensive for very large keys, especially in environments where
    processing power</st> <st c="53855">is limited.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53866">The</st> <st c="53870">mid-square hash function is an effective
    method for generating hash codes by squaring the key and extracting the middle
    digits.</st> <st c="53999">This technique leverages the properties of squaring
    to spread out the values and achieve a more uniform distribution of keys across
    the hash table.</st> <st c="54147">Despite its simplicity and independence from
    key size, the method’s efficiency depends on the distribution of the middle digits
    and may involve some computational cost for large keys.</st> <st c="54331">Overall,
    the mid-square hash function remains a useful tool in the design of hash functions
    for</st> <st c="54427">various applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54448">Folding method</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="54463">The</st> <st c="54467">folding hash function is a technique used
    to generate</st> <st c="54521">hash codes by splitting the key into several parts,
    adding these parts together, and then taking the modulus with the table size to
    produce the hash code.</st> <st c="54677">This method is particularly useful for
    large keys, such as phone numbers or identification numbers, and aims to distribute
    keys more uniformly across the hash table.</st> <st c="54843">Let’s consider a
    practical example to illustrate the folding</st> <st c="54904">hash function.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="54918">Example 7.4</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54930">Using the folding</st> <st c="54948">hash method, we determine
    the hash value for the example key</st> *<st c="55010">987654321</st>* <st c="55019">with
    a hash table size</st> <st c="55043">of</st> *<st c="55046">100</st>*<st c="55049">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="55051">Split the key</st>**<st c="55064">: Divide the key into equal
    parts.</st> <st c="55100">For simplicity, let’s split it into parts of 3 digits</st>
    <st c="55154">each:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>987</mn><mo>,</mo><mn>654</mn><mo>,</mo><mn>321</mn></mrow></mrow></math>](img/1324.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="55161">Add the parts</st>**<st c="55174">: Sum the parts</st> <st
    c="55191">together:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>987</mn><mo>+</mo><mn>654</mn><mo>+</mo><mn>321</mn><mo>=</mo><mn>1962</mn></mrow></mrow></math>](img/1325.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="55202">Take the modulus</st>**<st c="55218">: Take the modulus of
    the sum with the table size to get the hash</st> <st c="55285">code:</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1962</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>100</mn><mo>=</mo><mn>62</mn></mrow></mrow></math>](img/1326.png)<st
    c="55291">![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1962</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>100</mn><mo>=</mo><mn>62</mn></mrow></mrow></math>](img/1327.png)</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="55305">Therefore, the</st> <st c="55319">key</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>987654321</mml:mn></mml:math>](img/1308.png)
    <st c="55324"><st c="55325">is mapped to index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>62</mml:mn></mml:math>](img/1329.png)
    <st c="55345"><st c="55346">in the</st> <st c="55354">hash table.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55365">The</st> <st c="55370">folding</st> <st c="55378">hash method
    has the</st> <st c="55398">following properties:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="55419">Uniform distribution</st>**<st c="55440">: The folding method
    aims to produce a more uniform distribution of keys by ensuring that all parts
    of the key contribute to the hash value.</st> <st c="55582">This helps to reduce
    clustering and improve the overall performance of the</st> <st c="55657">hash
    table.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="55668">Simplicity</st>**<st c="55679">: The algorithm is straightforward
    to implement and understand.</st> <st c="55744">It simply involves splitting,
    summing, and taking</st> <st c="55794">the modulus.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="55806">Flexibility</st>**<st c="55818">: It can handle keys of various
    sizes by adjusting the way the key is split</st> <st c="55895">into parts.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55906">On the other side, folding</st> <st c="55934">hash comes with</st>
    <st c="55950">its limitations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="55966">Dependent on key structure</st>**<st c="55993">: The efficiency
    of the folding hash function depends on the structure of the keys.</st> <st c="56078">If
    the parts of the key have similar patterns or values, it may not distribute the</st>
    <st c="56161">keys uniformly.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="56176">Not ideal for small keys</st>**<st c="56201">: For small keys,
    the overhead of splitting and summing may not provide significant benefits over
    simpler hash functions such</st> <st c="56328">as division-remainder.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="56350">Handling different lengths</st>**<st c="56377">: If keys have
    varying lengths, it might be challenging to decide how to split them uniformly,
    potentially leading to</st> <st c="56496">uneven distribution.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="56516">Sum overflow</st>**<st c="56529">: For very large keys, the
    sum of the parts might exceed the typical integer range, causing overflow issues.</st>
    <st c="56639">However, this can be mitigated by using modular</st> <st c="56687">arithmetic
    at</st> <st c="56701">each step.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56711">The folding hash function is an effective and straightforward
    method for hashing large keys.</st> <st c="56805">By</st> <st c="56807">splitting
    the key into parts, summing these parts, and then taking the modulus, it can produce
    a relatively uniform distribution of hash values, improving the performance of
    hash tables.</st> <st c="56995">However, its efficiency can be affected by the
    structure of the keys, the need to handle different key lengths, and potential
    overflow issues.</st> <st c="57138">Despite these limitations, the folding method
    remains a valuable tool in the design of hash functions for</st> <st c="57244">various
    applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57265">Universal hashing</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="57283">The</st> <st c="57287">universal hash method is a technique designed</st>
    <st c="57333">to minimize the probability of collisions in a hash table.</st>
    <st c="57393">It involves using a family of hash functions and randomly selecting
    one of these functions for hashing.</st> <st c="57497">This method provides a
    probabilistic guarantee that the number of collisions will be low, making it particularly
    useful in applications where security and performance are critical.</st> <st c="57678">The
    following is the step-by-step implementation of the</st> <st c="57734">universal
    method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57751">Define a family of hash functions</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">H</mml:mi></mml:math>](img/1330.png)
    <st c="57786"><st c="57787">from which a specific function</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi
    mathvariant="bold-italic">h</mi><mo>∈</mo><mi mathvariant="bold-italic">H</mi></mrow></mrow></math>](img/1331.png)
    <st c="57819"><st c="57820">is chosen.</st> <st c="57832">Each hash function</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold-italic">h</mml:mi></mml:math>](img/1332.png) <st c="57851"><st
    c="57852">in the family should be able to map keys uniformly across the</st> <st
    c="57915">hash table.</st></st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57926">Randomly select a hash function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">h</mml:mi></mml:math>](img/1332.png)
    <st c="57959"><st c="57960">from the family</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">H</mml:mi></mml:math>](img/1334.png)
    <st c="57977"><st c="57978">to use for hashing</st> <st c="57998">the keys.</st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58007">Use the selected hash function</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">h</mml:mi></mml:math>](img/1332.png)
    <st c="58039"><st c="58040">to compute the hash values of</st> <st c="58071">the
    keys.</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="58080">Example 7.5</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58092">Using the folding</st> <st c="58111">hash method, let’s determine
    the hash value for the example key</st> *<st c="58175">123456</st>* <st c="58181">with
    a hash table size</st> <st c="58205">of</st> *<st c="58208">100</st>*<st c="58211">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58212">Let’s</st> <st c="58219">calculate</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow></msub><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mfenced
    open="(" close=")"><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mi>p</mi></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>.</mo></mrow></mrow></math>](img/1336.png)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58260">Here,</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi></mrow></math>](img/1337.png)
    <st c="58265"><st c="58267">is a prime number larger than any possible key,</st>![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi></mrow></math>](img/1338.png)
    <st c="58315"><st c="58317">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/993.png)
    <st c="58322"><st c="58323">are randomly chosen integers such that</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo><</mo><mi>p</mi></mrow></mrow></math>](img/1340.png)
    <st c="58363"><st c="58372">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>0</mn><mo>≤</mo><mi>b</mi><mo><</mo><mi>p</mi></mrow></mrow></math>](img/1341.png)<st
    c="58376"><st c="58386">, and</st>![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow></math>](img/1342.png)
    <st c="58391"><st c="58393">is the size of the</st> <st c="58413">hash table.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58424">Now, we use the following parameters in</st> <st c="58465">this
    example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58478">Key:</st> *<st c="58484">123456</st>*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58490">Table size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)<st
    c="58502"><st c="58503">:</st> *<st c="58505">100</st>*</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58508">Prime number</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)<st
    c="58522"><st c="58523">:</st> *<st c="58525">101</st>*</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="58528">Randomly chosen</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>a</mml:mi></mml:math>](img/460.png)
    <st c="58545"><st c="58565">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi></mml:math>](img/493.png)<st
    c="58569"><st c="58570">: Let’s assume</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo><mn>34</mn></mrow></mrow></math>](img/1347.png)
    <st c="58585"><st c="58586">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>7</mn></mrow></mrow></math>](img/1348.png)</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58591">We compute the</st> <st c="58606">hash value:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>h</mi><mn>34,7</mn></msub><mfenced
    open="(" close=")"><mn>123456</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mfenced
    open="(" close=")"><mrow><mn>34</mn><mo>×</mo><mn>123456</mn><mo>+</mo><mn>7</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>101</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>100</mn></mrow></mrow></math>](img/1349.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: <st c="58668">First, we calculate the</st> <st c="58692">intermediate values:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>34</mn><mo>×</mo><mn>123456</mn><mo>+</mo><mn>7</mn><mo>=</mo><mn>41</mn><mn>97503</mn></mrow></mrow></math>](img/1350.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>97503</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>101</mn><mo>=</mo><mn>90</mn></mrow></mrow></math>](img/1351.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: <st c="58715">Then, we calculate the final hash</st> <st c="58749">value:</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>90</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>100</mn><mo>=</mo><mn>90</mn></mrow></mrow></math>](img/1352.png)
    <st c="58756"><st c="58757">Therefore, the hash value for the key</st> *<st c="58795">123456</st>*
    <st c="58801">with the selected parameters</st> <st c="58831">is</st> *<st c="58834">90</st>*<st
    c="58836">.</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58837">Universal hashing</st> <st c="58856">significantly reduces the
    probability of</st> <st c="58897">collisions, offering a strong probabilistic
    guarantee that different keys will hash to different values.</st> <st c="59002">By
    randomly selecting a hash function from a family, it also provides resistance
    against adversarial attacks, making it useful in cryptographic applications.</st>
    <st c="59160">Furthermore, this method can be adapted to various key distributions
    by choosing an appropriate family of</st> <st c="59266">hash functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59281">However, universal hashing has some limitations.</st> <st c="59331">Defining
    and implementing a family of hash functions is more complex compared to simpler
    methods such as division-remainder or multiplication.</st> <st c="59474">Additionally,
    the need to randomly select a hash function and compute potentially more complex
    hash values can introduce additional computational overhead.</st> <st c="59630">Lastly,
    the effectiveness of universal hashing relies on the true randomness of the chosen
    hash function, which may be difficult to achieve in</st> <st c="59773">some environments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59791">The next two methods are tailored for hashing string data, where
    characters in the string contribute to the</st> <st c="59900">hash code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59910">Polynomial hashing for strings</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**<st c="59941">Polynomial hashing</st>** <st c="59960">(also known as</st>
    **<st c="59976">Rabin-Karp rolling hash</st>**<st c="59999">) is a</st> <st c="60006">technique
    to efficiently</st> <st c="60032">calculate</st> <st c="60042">hash values for
    substrings within a larger string.</st> <st c="60093">It treats the characters
    of the string as coefficients of a polynomial, where each character’s ASCII (or
    Unicode) value is multiplied by a prime number raised to a power corresponding
    to its position in the string.</st> <st c="60308">In the polynomial hashing method,
    each character in the string is treated as a coefficient in a polynomial.</st>
    <st c="60416">The hash</st> <st c="60424">code is the polynomial evaluated at
    a certain value.</st> <st c="60478">For the string</st> *<st c="60493">abcd</st>*
    <st c="60497">and a chosen base of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>31</mml:mn></mml:math>](img/1353.png)<st
    c="60519"><st c="60520">, the hash code can be calculated as</st> <st c="60557">the
    following:</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mtext>abcd</mtext></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mi>a</mi><mo>×</mo><msup><mn>31</mn><mn>3</mn></msup><mo>+</mo><mi>b</mi><mo>×</mo><msup><mn>31</mn><mn>2</mn></msup><mo>+</mo><mi>c</mi><mo>×</mo><mn>31</mn><mo>+</mo><mi>d</mi></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mrow></math>](img/1354.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="60627">Polynomial hashing is</st> <st c="60649">implemented in the</st>
    <st c="60668">following steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="60684">Initialization</st>**<st c="60699">: Choose a prime number</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/1355.png)
    <st c="60724"><st c="60725">(commonly 11 or 31) and a modulus</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1356.png)
    <st c="60760"><st c="60761">(often a large prime number to minimize collisions
    that corresponds to the size of the</st> <st c="60849">hash table).</st></st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="60861">Hash calculation</st>**<st c="60878">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60880">Initialize the hash value</st> <st c="60906">to</st> *<st c="60909">0</st>*<st
    c="60910">.</st>
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60911">Iterate over each character in</st> <st c="60943">the string.</st>
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60954">For each character, do</st> <st c="60978">the following:</st>
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60992">Multiply the current hash value</st> <st c="61025">by</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)<st
    c="61028"><st c="61029">.</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61030">Add the ASCII value of</st> <st c="61054">the character.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61068">Apply the modulo</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1358.png)
    <st c="61086"><st c="61087">operation to the result to ensure the hash value remains
    within a</st> <st c="61154">manageable range.</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="61171">Rolling hash</st>**<st c="61184">: To compute the hash of a
    substring, we can subtract the hash of the characters that are no longer part
    of the substring and add the hash of the newly included characters.</st> <st c="61358">This
    “rolling” update is efficient and allows for fast comparisons of</st> <st c="61428">different
    substrings.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="61449">The following is</st> <st c="61466">a Python example of</st> <st
    c="61487">polynomial hashing:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="61786">Let’s explain</st> <st c="61800">the example</st> <st c="61813">Python
    code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61825">The</st> **<st c="61830">polynomial_hash</st>** <st c="61845">function
    takes a string as input along with optional parameters,</st> **<st c="61911">p</st>**
    <st c="61912">(prime number) and</st> **<st c="61932">m</st>** <st c="61933">(modulus)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61943">It initializes</st> **<st c="61959">hash_value</st>** <st c="61969">to</st>
    **<st c="61973">0</st>**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61974">It iterates over each character (</st>**<st c="62007">char</st>**<st
    c="62012">) in</st> <st c="62018">the string</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="62028">For each character, it performs the hash</st> <st c="62070">update
    calculation:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="62089">hash_value * p</st>** <st c="62104">effectively shifts the
    previous characters one position to the left in</st> <st c="62176">the polynomial</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="62190">ord</st>**<st c="62194">(char) gets the ASCII value of</st>
    <st c="62226">the character</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="62239">The result is taken modulo</st> **<st c="62267">m</st>** <st c="62268">to
    prevent overflow and ensure a consistent range for the</st> <st c="62327">hash
    values</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="62338">Finally, it returns the computed</st> <st c="62372">hash value</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="62382">The polynomial hash value of</st> **<st c="62412">"Hello"</st>**
    <st c="62419">is</st> **<st c="62423">99162322</st>**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="62431">Polynomial hashing is</st> <st c="62454">particularly efficient
    for comparing substrings within a larger string.</st> <st c="62526">It avoids
    recalculating the entire hash for each substring, making it suitable for applications
    such as plagiarism detection or pattern matching.</st> <st c="62672">Collisions
    are still possible, especially if the modulus</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="62729"><st c="62730">is not chosen carefully.</st> <st c="62756">Using
    a large prime number for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1360.png)
    <st c="62787"><st c="62788">can help reduce collision frequency.</st> <st c="62826">The
    choice of prime number</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/969.png)
    <st c="62853"><st c="62854">and modulus</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="62867"><st c="62868">can affect performance and collision probability.</st>
    <st c="62919">Experimentation might be needed to find optimal values for</st>
    <st c="62978">specific applications.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63000">DJB2 hash function for strings</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="63031">The</st> **<st c="63036">DJB2 hash function</st>** <st c="63054">is
    a</st> <st c="63060">simple and effective algorithm</st> <st c="63091">for generating
    hash values (numeric representations) from strings.</st> <st c="63158">It is known
    for its speed and decent distribution of hash values, making it suitable for various
    applications such as hash tables.</st> <st c="63289">The following are the four
    steps of this</st> <st c="63330">hash function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="63344">Initialization</st>**<st c="63359">: The</st> <st c="63366">hash
    value is initialized to a starting value of</st> *<st c="63415">5381</st>*<st
    c="63419">. This initial value was chosen somewhat arbitrarily but has proven
    to work well</st> <st c="63500">in practice.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="63512">Iteration</st>**<st c="63522">: The function iterates over
    each character in the</st> <st c="63574">input string.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="63587">Hash update</st>**<st c="63599">: For each character, the current
    hash value is multiplied by 33 (left-shifted by 5 bits and then added to itself).</st>
    <st c="63716">The ASCII value of the character is added to the</st> <st c="63765">hash
    value.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="63776">Finalization</st>**<st c="63789">: After processing all characters,
    the hash value is typically masked to ensure it fits within a 32-bit unsigned</st>
    <st c="63903">integer range.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="63917">The following is a Python example of this</st> <st c="63960">hash
    function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="64089">The</st> `<st c="64094">djb2</st>` <st c="64098">function takes
    a string as input.</st> <st c="64133">It initializes the hash variable to</st>
    `<st c="64169">5381</st>`<st c="64173">. It iterates over each character (</st>`<st
    c="64208">char</st>`<st c="64213">) in the string.</st> <st c="64231">For each
    character, it performs the hash update calculation:</st> `<st c="64292">(hash
    << 5) + hash</st>` <st c="64310">is equivalent to multiplying</st> `<st c="64340">hash</st>`
    <st c="64344">by</st> `<st c="64348">33</st>`<st c="64350">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="64351">ord(char)</st>` <st c="64361">gets</st> <st c="64366">the ASCII
    value of the character.</st> <st c="64401">Finally, it returns the hash value
    after masking it to a 32-bit unsigned integer.</st> <st c="64483">For example,
    if</st> `<st c="64499">string = "Hello"</st>`<st c="64515">, the DJB2 hash function
    generates</st> `<st c="64550">99162322</st>` <st c="64558">as output.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64569">DJB2 is</st> <st c="64578">relatively easy to understand and implement.</st>
    <st c="64623">It’s computationally fast, which is advantageous in performance-critical
    scenarios.</st> <st c="64707">While DJB2 generally performs well, it’s not perfect
    and collisions can occur, especially with very</st> <st c="64807">large datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64822">Collision handling</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="64841">One of the primary challenges in using hash functions is dealing
    with collisions.</st> <st c="64924">Collisions</st> <st c="64934">occur when two
    different</st> <st c="64960">keys produce the same hash value, leading to potential
    conflicts in data retrieval and storage.</st> <st c="65056">Efficiently handling
    collisions is crucial for maintaining the performance and reliability of hash
    tables.</st> <st c="65163">Various strategies, such as chaining and open addressing,
    are employed to address this problem, but each comes with its own set of trade-offs
    and complexities.</st> <st c="65323">Understanding and mitigating the collision
    problem is essential for designing robust and efficient hash-based data structures.</st>
    <st c="65450">Here are the main types of collision handling techniques, each explained
    with examples, limitations,</st> <st c="65551">and properties.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65566">Chaining</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="65575">In</st> <st c="65578">chaining, each position in the hash table
    points to a linked list (or chain) of</st> <st c="65659">elements that hash to
    the same index.</st> <st c="65697">When a collision occurs, the new element is
    simply added to the end of</st> <st c="65768">the list.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="65777">Example 7.6</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65789">Here, we are</st> <st c="65802">handling collision</st> <st c="65821">using
    chaining for a hash table of size</st> *<st c="65862">10</st>* <st c="65864">and
    keys</st> *<st c="65874">12</st>*<st c="65876">,</st> *<st c="65878">22</st>*<st
    c="65880">, and</st> *<st c="65886">32</st>* <st c="65888">(all produce a hash
    value of</st> *<st c="65918">2</st>* <st c="65919">with</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>=</mo><mi>k</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></mrow></math>](img/1363.png)<st
    c="65924"><st c="65940">).</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="65942">Index</st>** | **<st c="65948">Hash table</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65959">0</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65961">1</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65962">2</st> | <st c="65963">12</st> <st c="65966">à</st> <st c="65967">22</st><st
    c="65969">à</st> <st c="65971">32</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65974">3</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65976">4</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65977">5</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65978">6</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65979">7</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65980">8</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="65981">9</st> |  |'
  prefs: []
  type: TYPE_TB
- en: <st c="65982">Table 7.1 – An example of handling collision using chaining</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66041">Chaining is</st> <st c="66053">straightforward to implement and
    supports dynamic sizing, allowing the lists to grow as more elements are added.</st>
    <st c="66167">However, this approach requires additional memory for the linked
    lists.</st> <st c="66239">Moreover, if many collisions occur, chains can become
    long, leading to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="66310"><st c="66311">time complexity in the worst case.</st> <st c="66347">In
    the average case, the running time for insert, delete, and search operations is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1365.png)
    <st c="66430"><st c="66431">if the chains are short.</st> <st c="66457">For a
    more precise analysis, it is essential to introduce the</st> <st c="66519">load
    factor.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66531">The load factor, often denoted as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">λ</mml:mi></mml:math>](img/1366.png)<st
    c="66566"><st c="66567">, is a crucial concept in the context of hash tables,
    including those using chaining for collision handling.</st> <st c="66676">It measures
    how full the hash table is and is defined as the ratio of the number of elements</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="66769"><st c="66818">in the hash table to the number of slots</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="66859"><st c="66860">in</st> <st c="66864">the table:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="normal">λ</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow></mrow></math>](img/1369.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="66881">The load factor helps in understanding the performance of the
    hash table.</st> <st c="66955">A low load factor indicates that the table has
    many empty slots, leading to shorter chains and faster average search times.</st>
    <st c="67079">A high load factor, on the other hand, indicates longer chains and
    potentially slower</st> <st c="67165">search times.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67178">Revisiting</st> <st c="67189">the running time of basic operations
    (insert, delete, and search) with</st> <st c="67261">chaining for collision handling,
    the average running time is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi mathvariant="normal">λ</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1370.png)
    <st c="67322"><st c="67323">This includes the constant time to access a slot in
    the hash table and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">λ</mml:mi></mml:math>](img/1366.png)
    <st c="67395"><st c="67396">to scan the chain, which is, on average, of size</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="normal">λ</mml:mi></mml:math>](img/1366.png)<st c="67446"><st c="67447">,
    assuming that data is uniformly distributed across slots to create evenly</st>
    <st c="67523">sized chains.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67536">In many implementations, the load factor is used as a threshold
    to decide when to resize the hash table.</st> <st c="67642">When the load factor
    exceeds a certain value, the hash table is resized (typically doubled in size)
    to maintain</st> <st c="67754">efficient operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="67775">Example 7.7</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67787">Consider a hash table with 10 slots (size</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mn>10</mn></mrow></mrow></math>](img/1373.png)<st
    c="67830"><st c="67831">) and the following keys:</st> *<st c="67857">12</st>*<st
    c="67859">,</st> *<st c="67861">22</st>*<st c="67863">,</st> *<st c="67865">32</st>*<st
    c="67867">,</st> *<st c="67869">42</st>*<st c="67871">, and</st> *<st c="67877">52</st>*<st
    c="67879">. Let’s use a simple</st> <st c="67900">hash function:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></mrow></math>](img/1374.png)<st
    c="67914"><st c="67936">:</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67937">The hash values are</st> *<st c="67957">2</st>*<st c="67958">,</st>
    *<st c="67960">2</st>*<st c="67961">,</st> *<st c="67963">2</st>*<st c="67964">,</st>
    *<st c="67966">2</st>*<st c="67967">, and</st> *<st c="67973">2</st>*<st c="67974">.
    All keys are stored in the chain at</st> <st c="68012">index</st> *<st c="68018">2</st>*<st
    c="68019">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="68020">Index</st>** | **<st c="68025">Hash table</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68036">0</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68038">1</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68039">2</st> | <st c="68040">12</st> <st c="68043">à</st> <st c="68044">22</st><st
    c="68047">à</st> <st c="68049">32</st><st c="68051">à</st><st c="68053">42</st><st
    c="68055">à</st> <st c="68057">52</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68060">3</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68062">4</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68063">5</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68064">6</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68065">7</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68066">8</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="68067">9</st> |  |'
  prefs: []
  type: TYPE_TB
- en: <st c="68068">Table 7.2 – An example of handling collision using simple chaining</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68134">Number of elements:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1375.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68156">Number of slots:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mn>10</mn></mrow></mrow></math>](img/1376.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68174">Load factor:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">λ</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>5</mml:mn></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:math>](img/1377.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68188">The</st> <st c="68192">properties</st> <st c="68203">of the load
    factor are</st> <st c="68226">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68237">A lower load factor generally means higher efficiency, as chains
    are shorter and search times</st> <st c="68332">are quicker</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68343">A higher load factor indicates better memory utilization, as more
    slots are being used, but it can also lead to decreased performance due to</st>
    <st c="68485">longer chains</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68498">Maintaining an optimal load factor (typically below 0.75) often
    involves dynamic resizing of the hash table to balance between performance and</st>
    <st c="68642">memory utilization</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68660">However, the</st> <st c="68673">load factor</st> <st c="68686">has
    limitations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68702">As the load factor increases, the chains at each index grow longer,
    leading to increased search, insertion, and</st> <st c="68815">deletion times</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68829">A higher load factor increases the likelihood of collisions, which
    can degrade the performance of the</st> <st c="68932">hash table</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="68942">Frequent resizing to maintain an optimal load factor can introduce
    overhead and impact performance during the</st> <st c="69053">resize operation</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="69069">Many hash table implementations set a threshold load factor (e.g.,</st>
    *<st c="69137">0.75</st>*<st c="69141">).</st> <st c="69145">When the load factor
    exceeds this threshold, the table is resized.</st> <st c="69212">Upon resizing,
    a common strategy is to double the size of the hash table and rehash all existing
    elements to the</st> <st c="69325">new table.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69335">Open addressing</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="69351">Open addressing</st> <st c="69367">handles collisions directly
    within the</st> <st c="69406">hash table by using a systematic sequence of probes
    to find an empty slot for each key.</st> <st c="69495">When a collision occurs,
    the algorithm probes the table according to a specific strategy until it finds
    an empty slot.</st> <st c="69614">Here, we introduce three common types of open
    addressing – linear probing, quadratic probing, and</st> <st c="69712">double
    hashing:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="69727">Linear probing</st>**<st c="69742">: When</st> <st c="69749">a
    collision occurs, linear probing checks the next slot in the table, continuing
    this process until an empty slot</st> <st c="69864">is found.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="69873">Example 7.8</st>**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="69885">To</st> <st c="69889">handle</st> <st c="69896">collisions using
    linear probing for a</st> <st c="69934">hash table of size</st> *<st c="69953">10</st>*
    <st c="69955">and keys</st> *<st c="69965">12</st>*<st c="69967">,</st> *<st c="69969">13</st>*<st
    c="69971">,</st> *<st c="69973">22</st>*<st c="69975">, and</st> *<st c="69981">32</st>*<st
    c="69983">, we use the hash function</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>=</mo><mi>k</mi><mi>m</mi><mi>o</mi><mi>d</mi><mspace
    width="0.125em" /><mspace width="0.125em" /><mn>10</mn></mrow></mrow></mrow></math>](img/1378.png)<st
    c="70010"><st c="70026">. The hash values for these keys are</st> *<st c="70063">2</st>*<st
    c="70064">,</st> *<st c="70066">3</st>*<st c="70067">,</st> *<st c="70069">2</st>*<st
    c="70070">, and</st> *<st c="70076">2</st>*<st c="70077">, respectively.</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="70092">Calculate</st> <st c="70103">hash values:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="70115">For key</st> *<st c="70124">12</st>*<st c="70126">:</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>12</mn><mi>m</mi><mi>o</mi><mi>d</mi><mspace
    width="0.125em" /><mspace width="0.125em" /><mn>10</mn><mo>=</mo></mrow></mrow></math>](img/1379.png)
    <st c="70129"><st c="70130">2</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70132">For key</st> *<st c="70140">13</st>*<st c="70142">:</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mspace
    width="0.125em" /><mspace width="0.125em" /><mn>10</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1380.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70146">For key</st> *<st c="70154">22</st>*<st c="70156">:</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mspace
    width="0.125em" /><mspace width="0.125em" /><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1381.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70160">For key</st> *<st c="70168">32</st>*<st c="70170">:</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>32</mn><mi>m</mi><mi>o</mi><mi>d</mi><mspace
    width="0.125em" /><mspace width="0.125em" /><mn>10</mn><mo>=</mo></mrow></mrow></math>](img/1382.png)<st
    c="70173"><st c="70174">2</st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70175">Handle collisions using</st> <st c="70199">linear probing:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="70214">Key</st> *<st c="70219">12</st>* <st c="70221">hashes to index</st>
    *<st c="70238">2</st>*<st c="70239">, so it is placed at</st> <st c="70260">index</st>
    *<st c="70266">2</st>*<st c="70267">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70268">Key</st> *<st c="70273">13</st>* <st c="70275">hashes to index</st>
    *<st c="70292">3</st>*<st c="70293">, so it is placed at</st> <st c="70314">index</st>
    *<st c="70320">3</st>*<st c="70321">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70322">Key</st> *<st c="70327">22</st>* <st c="70329">hashes to index</st>
    *<st c="70346">2</st>*<st c="70347">, which is already occupied by</st> *<st c="70378">12</st>*<st
    c="70380">. Using linear probing, we check the next slot (index</st> *<st c="70434">3</st>*<st
    c="70435">), which is occupied by</st> *<st c="70459">13</st>*<st c="70461">.
    We then check the next slot (index</st> *<st c="70498">4</st>*<st c="70499">),
    which is empty, so</st> *<st c="70521">22</st>* <st c="70523">is placed at</st>
    <st c="70537">index</st> *<st c="70543">4</st>*<st c="70544">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70545">Key</st> *<st c="70550">32</st>* <st c="70552">hashes to index</st>
    *<st c="70569">2</st>*<st c="70570">, which is occupied by</st> *<st c="70593">12</st>*<st
    c="70595">. Using linear probing, we check the next slots (index</st> *<st c="70650">3</st>*<st
    c="70651">, occupied by</st> *<st c="70665">13</st>*<st c="70667">, and index</st>
    *<st c="70679">4</st>*<st c="70680">, occupied by</st> *<st c="70694">22</st>*<st
    c="70696">).</st> <st c="70700">The next empty slot is at index</st> *<st c="70732">5</st>*<st
    c="70733">, so</st> *<st c="70738">32</st>* <st c="70740">is placed at</st> <st
    c="70754">index</st> *<st c="70760">5</st>*<st c="70761">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="70762">Here is the resulting</st> <st c="70785">hash table:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **<st c="70796">Index</st>** | **<st c="70802">Hash table</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70813">0</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70815">1</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70816">2</st> | <st c="70817">12</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70819">3</st> | <st c="70821">13</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70823">4</st> | <st c="70825">22</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70827">5</st> | <st c="70829">32</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70831">6</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70833">7</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70834">8</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="70835">9</st> |  |'
  prefs: []
  type: TYPE_TB
- en: <st c="70836">Table 7.3 – An example of handling collision using linear probing</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70901">The example</st> <st c="70913">demonstrates how linear probing
    resolves collisions by sequentially checking the next available slot in the</st>
    <st c="71022">hash table.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71033">Linear probing is</st> <st c="71052">straightforward and easy
    to implement.</st> <st c="71091">It accesses</st> <st c="71103">contiguous memory
    locations, making it cache-friendly.</st> <st c="71158">However, it can lead to
    primary clustering, where groups of filled slots form, resulting in longer probe
    sequences.</st> <st c="71274">In the worst-case scenario, its running time degrades
    to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="71331"><st c="71332">as the table</st> <st c="71346">fills up.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="71355">Quadratic probing</st>**<st c="71373">: This</st> <st c="71380">is
    similar to linear probing but uses a quadratic function to determine the next
    slot.</st> <st c="71468">The probe sequence is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mi>k</mi></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mi>h</mi><mfenced
    open="(" close=")"><mi>k</mi></mfenced><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mrow></math>](img/1384.png)<st
    c="71490"><st c="71515">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="71523"><st c="71524">is the</st> <st c="71532">probe number.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="71545">Example 7.9</st>**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="71557">To handle collisions using</st> <st c="71585">quadratic probing
    for a hash table of size</st> *<st c="71628">10</st>* <st c="71630">and keys</st>
    *<st c="71640">12</st>*<st c="71642">,</st> *<st c="71644">13</st>*<st c="71646">,</st>
    *<st c="71648">22</st>*<st c="71650">, and</st> *<st c="71656">32</st>*<st c="71658">,
    we use the hash function</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>h</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>=</mo><mi>k</mi><mi>m</mi><mi>o</mi><mi>d</mi><mspace
    width="0.125em" /><mspace width="0.125em" /><mn>10</mn></mrow></mrow></mrow></math>](img/1378.png)<st
    c="71685"><st c="71701">. The hash values for these keys are</st> *<st c="71738">2</st>*<st
    c="71739">,</st> *<st c="71741">3</st>*<st c="71742">,</st> *<st c="71744">2</st>*<st
    c="71745">, and</st> *<st c="71751">2</st>*<st c="71752">, respectively:</st></st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="71767">Calculate</st> <st c="71778">hash values:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71790">For key</st> <st c="71799">12:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>12</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1387.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71804">For key</st> <st c="71812">13:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1388.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71817">For key</st> <st c="71825">22:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1389.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71830">For key</st> <st c="71838">32:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>32</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1390.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71843">Handle collisions</st> <st c="71861">using</st> <st c="71867">quadratic
    probing:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71885">Key 12 hashes to index 2, so it is placed at</st> <st c="71931">index
    2.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71939">Key 13 hashes to index 3, so it is placed at</st> <st c="71985">index
    3.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="71993">Key 22 hashes to index 2, which is already occupied by 12\.</st>
    <st c="72053">Using quadratic probing, we check the next slots</st> <st c="72102">as
    follows:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mn>22,1</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>2</mn><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1391.png)<st
    c="72113"><st c="72146">, which is occupied</st> <st c="72166">by 13</st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mn>22,2</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>2</mn><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></mrow></math>](img/1392.png)<st
    c="72171"><st c="72200">, which is empty, so 22 is placed at</st> <st c="72237">index
    6</st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="72244">Key 32 hashes to index 2, which is occupied by 12\.</st> <st c="72296">Using
    quadratic probing, we check the</st> <st c="72334">next slots</st> <st c="72345">as
    follows:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mn>32,1</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>2</mn><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1393.png)<st
    c="72356"><st c="72385">, which is occupied</st> <st c="72405">by 13</st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mn>32,2</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>2</mn><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></mrow></math>](img/1394.png)<st
    c="72410"><st c="72438">, which is occupied</st> <st c="72458">by 22</st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mn>32,3</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>2</mn><mo>+</mo><msup><mn>3</mn><mn>2</mn></msup></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/1395.png)<st
    c="72463"><st c="72496">, which is empty, so 32 is placed at</st> <st c="72533">index
    1</st></st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="72540">Here is the resulting</st> <st c="72563">hash table:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **<st c="72574">Index</st>** | **<st c="72580">Hash table</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72591">0</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72593">1</st> | <st c="72594">32</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72596">2</st> | <st c="72598">12</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72600">3</st> | <st c="72602">13</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72604">4</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72606">5</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72607">6</st> | <st c="72608">22</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72610">7</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72612">8</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="72613">9</st> |  |'
  prefs: []
  type: TYPE_TB
- en: <st c="72614">Table 7.4 – An example of handling collision using quadratic probing</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72682">This example</st> <st c="72695">demonstrates how quadratic probing
    resolves collisions by checking progressively further slots, using a quadratic
    function to determine the</st> <st c="72836">probe sequence.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72851">In</st> <st c="72855">quadratic probing, the likelihood of primary
    clustering is reduced compared to linear probing.</st> <st c="72950">However,
    its access pattern is les</st><st c="72984">s cache-friendly.</st> <st c="73003">While
    quadratic probing mitigates primary clustering, it can still experience secondary
    clustering, where elements hashing to the same initial index follow the same probe
    sequence.</st> <st c="73184">Additionally, quadratic probing is more complex to
    implement compared to</st> <st c="73257">linear probing.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="73272">Double hashing</st>**<st c="73287">: This</st> <st c="73295">uses
    a secondary hash function to determine the probe sequence, reducing clustering
    further.</st> <st c="73388">The probe sequence is</st> <st c="73410">as</st> <st
    c="73412">follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>,</mo><mi>i</mi></mrow></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow></mfenced><mo>+</mo><mi>i</mi><mo>⋅</mo><msub><mi>h</mi><mn>2</mn></msub><mfenced
    open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow></mfenced></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mrow></math>](img/1396.png)<st
    c="73421"><st c="73458">.</st></st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="73459">Example 7.10</st>**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73472">To handle collisions using double hashing for a hash table of
    size 10 and keys 12, 13, 22, and 32, we use the</st> <st c="73583">primary hash
    function</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced
    open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow></mfenced><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></math>](img/1397.png)<st
    c="73605"><st c="73626">. The hash values for these keys are 2, 3, 2, and 2, respectively.</st>
    <st c="73693">We also use a secondary hash function,</st> <st c="73732">h</st><st
    c="73733">2</st><st c="73734">(</st><st c="73735">k</st><st c="73736">e</st><st
    c="73737">y</st><st c="73738">)</st> <st c="73739">=</st> <st c="73740">1</st>
    <st c="73741">+</st> <st c="73742">(</st><st c="73743">k</st><st c="73744">e</st><st
    c="73745">y</st> <st c="73746">m</st><st c="73747">o</st><st c="73748">d</st>
    <st c="73749">9</st><st c="73750">)</st><st c="73751">, to determine the</st>
    <st c="73770">probe sequence:</st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="73785">Calculate the primary</st> <st c="73808">hash values:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="73820">For key</st> <st c="73829">12:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>12</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1398.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="73847">For key</st> <st c="73855">13:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1399.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="73871">For key</st> <st c="73879">22:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1400.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="73895">For key</st> <st c="73903">32:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>32</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1401.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="73919">Handle collisions using</st> <st c="73943">double hashing:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="73958">Key 12 hashes to index 2, so it is placed at</st> <st c="74004">index
    2.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74012">Key 13 hashes to index 3, so it is placed at</st> <st c="74058">index
    3.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74066">Key 22 hashes</st> <st c="74081">to index 2, which is already
    occupied by 12\.</st> <st c="74126">Using the secondary hash function, we calculate
    the</st> <st c="74178">probe sequence:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74193">Secondary hash</st> <st c="74209">for 22:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>h</mi><mo>_</mo><mn>2</mn><mo>(</mo><mn>22</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mo>(</mo><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>9</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>4</mn><mo>=</mo><mn>5</mn></mrow></mrow></mrow></math>](img/1402.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="74243">Probe sequence:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mrow><mn>22</mn><mo>,</mo><mi>i</mi></mrow></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced open="(" close=")"><mn>22</mn></mfenced><mo>+</mo><mi>i</mi><mo>⋅</mo><msub><mi>h</mi><mn>2</mn></msub><mfenced
    open="(" close=")"><mn>22</mn></mfenced></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></math>](img/1403.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="74294">First probe:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mfenced
    open="(" close=")"><mrow><mn>2</mn><mo>+</mo><mn>1</mn><mo>×</mo><mn>5</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></mrow></math>](img/1404.png)<st
    c="74307"><st c="74308">, which is empty, so 22 is placed at</st> <st c="74345">index
    7</st></st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="74352">Key 32 hashes to index 2, which is occupied by 12\.</st> <st c="74404">Using
    the secondary hash function, we calculate the</st> <st c="74456">probe sequence:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74471">Secondary hash</st> <st c="74487">for 32:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>h</mi><mo>_</mo><mn>2</mn><mo>(</mo><mn>32</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mo>(</mo><mn>32</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>9</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>5</mn><mo>=</mo><mn>6</mn></mrow></mrow></mrow></math>](img/1405.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="74522">Probe sequence:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>h</mi><mfenced
    open="(" close=")"><mrow><mn>32</mn><mo>,</mo><mi>i</mi></mrow></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced open="(" close=")"><mn>32</mn></mfenced><mo>+</mo><mi>i</mi><mo>⋅</mo><msub><mi>h</mi><mn>2</mn></msub><mfenced
    open="(" close=")"><mn>32</mn></mfenced></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></math>](img/1406.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="74575">First probe:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mfenced
    open="(" close=")"><mrow><mn>2</mn><mo>+</mo><mn>1</mn><mo>×</mo><mn>6</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>8</mn></mrow></mrow></math>](img/1407.png)<st
    c="74588"><st c="74589">, which is empty, so 32 is placed at</st> <st c="74626">index
    8</st></st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="74633">Here is the</st> <st c="74645">resulting</st> <st c="74656">hash
    table:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **<st c="74667">Index</st>** | **<st c="74673">Hash table</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74684">0</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74686">1</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74687">2</st> | <st c="74688">12</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74690">3</st> | <st c="74692">13</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74694">4</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74696">5</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74697">6</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74698">7</st> | <st c="74699">22</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74701">8</st> | <st c="74703">32</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="74705">9</st> |  |'
  prefs: []
  type: TYPE_TB
- en: <st c="74707">Table 7.5 – An example of handling collision using double hashing</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74772">The example</st> <st c="74785">demonstrates how double hashing
    resolves collisions by using a secondary hash function to determine the probe
    sequence, reducing the likelihood</st> <st c="74929">of clustering.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74943">The major</st> <st c="74953">advantage of double hashing is that
    it significantly reduces both primary and secondary clustering.</st> <st c="75054">It
    maintains</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1408.png)
    <st c="75067"><st c="75068">average-case performance for insert, delete, and search
    operations.</st> <st c="75137">However, double hashing is more complex to implement
    due to the need for two hash functions.</st> <st c="75230">Additionally, it may
    be less cache-efficient because of non-contiguous</st> <st c="75301">memory accesses.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75317">Cuckoo hashing – the bird-inspired collision resolution</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**<st c="75373">Cuckoo hashing</st>** <st c="75388">is a</st> <st c="75394">unique
    open addressing scheme</st> <st c="75424">for handling collisions in hash tables,
    inspired by the</st> <st c="75480">behavior of cuckoo birds.</st> <st c="75506">Just
    like a cuckoo chick pushes other eggs out of a nest, cuckoo hashing allows a new
    key to “kick out” an existing key to make space for itself.</st> <st c="75652">Let’s
    explain how it works step</st> <st c="75684">by step:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="75692">Two hash functions</st>**<st c="75711">: Cuckoo hashing employs
    two independent hash functions (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mn>1</mml:mn></mml:math>](img/1409.png)
    <st c="75769"><st c="75771">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mn>2</mml:mn></mml:math>](img/1410.png)<st
    c="75776"><st c="75777">) that map keys to slots in the hash table.</st> <st c="75821">This
    gives each key two potential locations where it can</st> <st c="75878">be stored.</st></st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="75888">Insertion</st>**<st c="75898">: When inserting a key, the algorithm
    first tries to place it in the slot determined</st> <st c="75984">by</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1411.png)<st
    c="75987"><st c="75995">:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="75996">If the slot is empty, the key</st> <st c="76026">is inserted</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="76037">If the slot is occupied, the existing key is “kicked out” and
    the new key takes</st> <st c="76118">its place</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="76127">The kicked-out key is then attempted to be inserted into its alternate
    location based on</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1412.png)<st
    c="76217"><st c="76225">. This process continues, potentially displacing more
    keys until an empty slot is found or a maximum number of displacements</st> <st
    c="76350">is reached.</st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="76361">Lookup</st>**<st c="76368">: To find a key, the algorithm checks
    both possible locations (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mn>1</mml:mn><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1411.png)
    <st c="76432"><st c="76441">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi><mml:mn>2</mml:mn><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1412.png)<st
    c="76445"><st c="76453">).</st> <st c="76456">If the key is found in either location,
    the lookup</st> <st c="76507">is successful.</st></st></st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="76521">Deletion</st>**<st c="76530">: Deleting a key is straightforward;
    simply remove it from the slot where</st> <st c="76605">it’s found.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="76616">Let’s illustrate this hashing method in the</st> <st c="76661">following
    example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="76679">Example 7.11</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76692">Let’s handle collisions</st> <st c="76717">using cuckoo hashing
    for a hash table of size 10 and keys 12, 13, 22,</st> <st c="76787">and 32:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76794">We use the following</st> <st c="76816">hash functions:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced
    open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow></mfenced><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></math>](img/1415.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>2</mn></msub><mfenced
    open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>/</mo><mn>10</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></mrow></math>](img/1416.png)
    <st c="76853"><st c="76879">(‘/’ is</st> <st c="76887">integer division)</st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="76904">Insertion steps:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="76921">Key 12:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="76929">Hash</st> <st c="76935">values:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced
    open="(" close=")"><mn>12</mn></mfenced><mo>=</mo><mn>12</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1417.png)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="76967">Place 12 in Table 1 at</st> <st c="76990">index 2.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="76998">Key 13:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="77006">Hash</st> <st c="77012">values:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced
    open="(" close=")"><mn>13</mn></mfenced><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1418.png)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77045">Place 13 in Table 1 at</st> <st c="77068">index 3.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77076">Key 22:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="77084">Hash</st> <st c="77090">values:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced
    open="(" close=")"><mn>22</mn></mfenced><mo>=</mo><mn>22</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo>.</mo></mrow></mrow></math>](img/1419.png)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77122">Index 2 in Table 1 is occupied by 12\.</st> <st c="77160">Kick
    out 12 and place 22 in</st> <st c="77188">Table 1</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77195">index 2.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="77204">Reinsert 12 using</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/1420.png)
    <st c="77223"><st c="77224">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>2</mn></msub><mfenced
    open="(" close=")"><mn>12</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>12</mn><mo>/</mo><mn>10</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn><mo>.</mo></mrow></mrow></math>](img/1421.png)</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77255">Place 12 in Table 2 at</st> <st c="77278">index 1.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77286">Key 32:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="77294">Hash</st> <st c="77300">values:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mfenced
    open="(" close=")"><mn>32</mn></mfenced><mo>=</mo><mn>32</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo>.</mo></mrow></mrow></math>](img/1422.png)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77332">Index 2 in Table 1 is occupied by 22\.</st> <st c="77370">Kick
    out 22 and place 32 in Table</st> <st c="77404">1 at</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77408">index 2.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="77417">Reinsert 22 using</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/1420.png)<st
    c="77436"><st c="77437">:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>h</mi><mn>2</mn></msub><mfenced
    open="(" close=")"><mn>22</mn></mfenced><mo>=</mo><mfenced open="(" close=")"><mrow><mn>22</mn><mo>/</mo><mn>10</mn></mrow></mfenced><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo>.</mo></mrow></mrow></math>](img/1424.png)</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77468">Index 2 in Table 2 is empty, so place 22 in Table 2 at</st> <st
    c="77523">index 2.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="77531">Here are</st> <st c="77540">the</st> <st c="77545">resulting</st>
    <st c="77555">hash tables:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **<st c="77567">Index</st>** | **<st c="77573">Hash</st>** **<st c="77579">table
    (1)</st>** |  | **<st c="77588">Index</st>** | **<st c="77594">Hash</st>** **<st
    c="77600">table (2)</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77609">0</st> |  |  | <st c="77611">0</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77612">1</st> |  |  | <st c="77613">1</st> | <st c="77614">12</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77616">2</st> | <st c="77618">32</st> |  | <st c="77620">2</st> |
    <st c="77622">22</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77624">3</st> | <st c="77626">13</st> |  | <st c="77628">3</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77630">4</st> |  |  | <st c="77631">4</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77632">5</st> |  |  | <st c="77633">5</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77634">6</st> |  |  | <st c="77635">6</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77636">7</st> |  |  | <st c="77637">7</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77638">8</st> |  |  | <st c="77639">8</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="77640">9</st> |  |  | <st c="77641">9</st> |  |'
  prefs: []
  type: TYPE_TB
- en: <st c="77642">Table 7.6 – An example of handling collision using cuckoo hashing</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77707">Cuckoo hashing</st> <st c="77723">offers constant</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)
    <st c="77739"><st c="77740">worst-case lookup time, which is a significant advantage
    over other collision resolution techniques such as linear probing or chaining.</st>
    <st c="77877">It also eliminates clustering by ensuring that each key can reside
    in one of two possible locations.</st> <st c="77978">However, cuckoo hashing requires
    a relatively low load factor to function effectively, meaning the table might
    need to be larger compared to other methods.</st> <st c="78134">Additionally,
    if the table becomes too full or cycles are detected, a rehashing operation is
    necessary, which can</st> <st c="78248">be costly.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78258">Cuckoo hashing is an excellent choice when extremely fast lookups
    and deletions are required, even under heavy load.</st> <st c="78376">However,
    it is important to be aware of the limitations regarding load factor and the potential
    overhead</st> <st c="78481">of rehashing.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78494">Recap</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="78500">Hashing offers several advantages, most notably its speed.</st>
    <st c="78560">Hashing provides average-case</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)
    <st c="78590"><st c="78591">time complexity for search, insert, and delete operations,
    making it extremely fast.</st> <st c="78677">Hash tables can handle a large number
    of entries efficiently, provided the load factor (the ratio of entries to table
    size) is managed well.</st> <st c="78818">Additionally, hash tables are versatile
    and can be used in various applications, such as implementing dictionaries, caches,</st>
    <st c="78942">and sets.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78951">However, hashing also has its limitations.</st> <st c="78995">Collisions,
    while minimized, can still occur and must be managed efficiently to maintain performance.</st>
    <st c="79097">Hash tables may require more memory than other data structures,
    particularly if the table is sparsely populated.</st> <st c="79210">In the worst-case
    scenario, where many collisions occur, the time complexity can degrade</st> <st
    c="79299">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="79302"><st c="79303">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79304">Despite these challenges, hashing remains a powerful method for
    achieving constant time search operations.</st> <st c="79412">Hash tables are
    widely used in applications such as database indexing (where they enable fast
    record retrieval) and caching, where they help quickly locate cached data.</st>
    <st c="79581">They are also essential in compilers and interpreters for storing
    information about identifiers and in many programming languages for implementing
    sets and associative arrays (maps).</st> <st c="79764">The efficiency and versatility
    of hashing make it an indispensable technique in computer science for fast and
    efficient</st> <st c="79884">data retrieval.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79899">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="79907">In this chapter, we explored the fundamental concepts of search
    and search algorithms, beginning with an overview of linear and sub-linear search
    methods.</st> <st c="80063">We examined how linear search, despite its simplicity
    and ease of implementation, has limitations in efficiency, especially for large
    datasets.</st> <st c="80207">We then discussed sub-linear search algorithms, such
    as binary search, jump search, and interpolation search, highlighting their improved
    time complexities and discussing the conditions under which they</st> <st c="80410">performed
    best.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80425">Lastly, we introduced the concept of hashing and its critical
    role in achieving constant time complexity for search, insert, and delete operations.</st>
    <st c="80574">We covered different hashing methods, including division-remainder,
    multiplication, mid-square, and universal hashing, explaining how each method
    worked and their respective strengths</st> <st c="80758">and weaknesses.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80773">We also discussed various techniques for handling collisions,
    such as linear probing, quadratic probing, double hashing, and cuckoo hashing.</st>
    <st c="80915">Each method’s advantages and limitations were analyzed, showing
    how they addressed the challenges of search operations in different scenarios.</st>
    <st c="81058">These techniques demonstrated how sophisticated strategies could
    optimize search operations by efficiently managing the search space and</st> <st
    c="81195">minimizing collisions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81217">The chapter concluded by emphasizing the importance of hashing
    in various applications, such as database indexing, caching, symbol tables, and
    implementing sets and maps in programming languages.</st> <st c="81414">Despite
    challenges such as collision handling and memory overhead, hashing was shown to
    be a versatile and efficient technique in computer science for fast</st> <st c="81570">data
    retrieval.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81585">In the next chapter, we will explore the relationship between
    sorting and searching in computational systems and algorithm design.</st> <st
    c="81717">We will examine how to strike a balance between these two processes
    to minimize</st> <st c="81797">computational costs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81817">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="81848">Introduction to Algorithms</st>*<st c="81875">. By Thomas H.</st>
    <st c="81890">Cormen, Charles E.</st> <st c="81909">Leiserson, Ronald L.</st>
    <st c="81930">Rivest, and Clifford Stein.</st> <st c="81958">Fourth Edition.</st>
    <st c="81974">MIT</st> <st c="81978">Press.</st> <st c="81985">2022:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="81990">Chapter 11</st>*<st c="82001">,</st> *<st c="82003">Hash Tables</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82014">The Art of Computer Programming</st>*<st c="82046">. By D.</st>
    <st c="82054">E.</st> <st c="82057">Knuth.</st> <st c="82064">Volume 3: Sorting
    and Searching (Second ed.).</st> <st c="82110">Addison-Wesley.</st> <st c="82126">1998:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82131">Section</st>* *<st c="82140">6.1</st>*<st c="82143">,</st> *<st
    c="82145">Searching</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82154">Section 6.2</st>*<st c="82166">,</st> *<st c="82168">Binary
    Search</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82181">Section</st>* *<st c="82190">6.4</st>*<st c="82193">,</st> *<st
    c="82195">Hashing</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82202">Data Structures and Algorithm Analysis in C++</st>*<st c="82248">.
    By M.</st> <st c="82256">A.</st> <st c="82259">Weiss.</st> <st c="82266">(Fourth
    ed.).</st> <st c="82280">Pearson.</st> <st c="82289">2012:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82294">Chapter</st>* *<st c="82303">5</st>*<st c="82304">,</st> *<st
    c="82306">Hashing</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82313">Chapter 7</st>*<st c="82323">,</st> *<st c="82325">Search Trees</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82337">Algorithms</st>*<st c="82348">. By R.</st> <st c="82356">Sedgewick,
    K.</st> <st c="82370">Wayne.</st> <st c="82377">Fourth Edition.</st> <st c="82393">Addison-Wesley.</st>
    <st c="82409">2011:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="82414">Section 3.4</st>*<st c="82426">,</st> *<st c="82428">Hash Tables</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
