<html><head></head><body>
		<div id="_idContainer1490" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-106" class="chapter-number"><a id="_idTextAnchor118" class="pcalibre pcalibre1 calibre6"/><st c="0">8</st></h1>
			<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor119" class="pcalibre pcalibre1 calibre6"/><st c="2">Symbiotic Relationship between Sort and Search</st></h1>
			<p class="calibre3"><st c="48">With some estimates indicating that sorting consumes a significant portion of global computing power, this chapter examines the symbiotic relationship between sorting and searching. </st><st c="231">We will provide an overview of these fundamental operations and explore how they interact and complement each other. </st><st c="348">The discussion will emphasize real-world examples to illustrate how to balance these crucial tasks in </st><span><st c="450">data processing.</st></span></p>
			<p class="calibre3"><st c="466">This chapter serves as a practical guide for applying analytical techniques to address complex real-world problems. </st><st c="583">You will compare the complexities of sorting and searching to understand how to achieve equilibrium in their application. </st><st c="705">By examining real-world scenarios, you will gain insights into how algorithm analysis can be effectively utilized in decision-making. </st><st c="839">Through these examples, the chapter aims to highlight the importance of choosing the right approach for specific situations, optimizing both sorting and searching processes to enhance overall efficiency </st><span><st c="1042">and performance.</st></span></p>
			<p class="calibre3"><st c="1058">We will explore the following topics in </st><span><st c="1099">this chapter:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="1112">Striking the right balance between sorting </st><span><st c="1156">and searching</st></span></li>
				<li class="calibre13"><st c="1169">The efficiency dilemma – to organize </st><span><st c="1207">or not?</st></span></li>
			</ul>
			<h1 id="_idParaDest-108" class="calibre5"><a id="_idTextAnchor120" class="pcalibre pcalibre1 calibre6"/><st c="1214">Striking the right balance between sorting and searching</st></h1>
			<p class="calibre3"><st c="1271">Let’s take a moment to reflect on our interactions with various information systems, ranging from local databases to search engines and libraries. </st><st c="1419">How many of these interactions involve search-related tasks? </st><st c="1480">Consider decision-making processes. </st><st c="1516">Can we assume that, in most cases, making a decision involves searching for the best possible option? </st><st c="1618">Similarly, can we infer that most problem-solving tasks involve some form </st><span><st c="1692">of search?</st></span></p>
			<p class="calibre3"><st c="1702">In the previous chapter, we explored the differences between algorithmic search and AI-driven search. </st><st c="1805">While this chapter focuses on algorithmic search, some of the questions we pose will be relevant to AI search </st><span><st c="1915">as well.</st></span></p>
			<p class="calibre3"><st c="1923">The answer to the questions we posed earlier is, yes, most of our interactions with computers involve</st><a id="_idIndexMarker558" class="pcalibre pcalibre1 calibre6"/><st c="2025"> direct search tasks or can be framed as search problems, such as </st><em class="italic"><st c="2091">optimization</st></em><st c="2103"> and </st><em class="italic"><st c="2108">constraint-satisfaction problems</st></em><st c="2140">. The concept of search extends beyond just computer </st><a id="_idIndexMarker559" class="pcalibre pcalibre1 calibre6"/><st c="2193">systems. </st><st c="2202">In our everyday lives, we frequently solve search problems. </st><st c="2262">Whether it’s searching for the right shirt in a cluttered closet on a cold winter day or finding the electric bill amid a stack of important documents, flyers, and miscellaneous papers, we are constantly engaging in search activities. </st><st c="2497">This demonstrates how fundamental and pervasive search operations are, both in computing and in our </st><span><st c="2597">daily routines.</st></span></p>
			<p class="calibre3"><st c="2612">This highlights the substantial computational and human effort invested in search tasks. </st><st c="2702">In algorithm design and analysis, this effort is often measured in time and space complexities. </st><st c="2798">While ther</st><a id="_idTextAnchor121" class="pcalibre pcalibre1 calibre6"/><st c="2808">e are additional cost factors involved, these are beyond the scope of our </st><span><st c="2883">current discussion.</st></span></p>
			<h2 id="_idParaDest-109" class="calibre5"><st c="2902">Symbiotic link between sorting and searchin</st><a id="_idTextAnchor122" class="pcalibre pcalibre1 calibre6"/><st c="2946">g</st></h2>
			<p class="calibre3"><st c="2948">The primary objective of this section is</st><a id="_idIndexMarker560" class="pcalibre pcalibre1 calibre6"/><st c="2988"> to analyze the cost of search operations, focusing on their time and space complexity from a practical perspective. </st><st c="3105">Understanding these costs is crucial for optimizing search algorithms and improving overall </st><span><st c="3197">system efficiency.</st></span></p>
			<p class="calibre3"><st c="3215">In the previous chapter, we demonstrated that the time complexity of a linear search without any pre-processing, such as sorting, is </st><img src="image/1071.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1068"/><st c="3349"/><st c="3350"> in the worst case. </st><st c="3370">This means that we may need to make up to </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre854"/><st c="3412"/><st c="3461"> comparisons to locate the target key. </st><st c="3499">Additionally, if we search for all items with the same key, the number of comparisons remains </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="3593"/><st c="3642"> and cannot </st><span><st c="3653">be reduced.</st></span></p>
			<p class="calibre3"><st c="3664">However, we can achieve better performance than </st><img src="image/1071.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre828"/><st c="3713"/><st c="3714"> by investing some computational resources to sort the data before performing any search operations. </st><st c="3815">As discussed in </st><a href="B22248_06.xhtml#_idTextAnchor081" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="3831">Chapter 6</st></em></span></a><st c="3840">, </st><em class="italic"><st c="3842">Merge Sort</st></em><st c="3852">, is one of</st><a id="_idIndexMarker561" class="pcalibre pcalibre1 calibre6"/><st c="3863"> the most efficient sorting algorithms, with a running time of </st><img src="image/1432.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1069"/><st c="3926"/><st c="3937">. Once the data is sorted, we can utilize more efficient search algorithms, such as those in the binary search family. </st><st c="4056">For instance, a </st><a id="_idIndexMarker562" class="pcalibre pcalibre1 calibre6"/><st c="4072">standard </st><em class="italic"><st c="4081">binary search</st></em><st c="4094"> has a running time of </st><img src="image/1248.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1070"/><st c="4117"/><st c="4126">. Furthermore, for data that is uniformly distributed, we could employ even more efficient algorithms such </st><a id="_idIndexMarker563" class="pcalibre pcalibre1 calibre6"/><st c="4233">as </st><em class="italic"><st c="4236">interpolation search</st></em><st c="4256">, which has an average-case running time </st><span><st c="4297">of </st></span><span><img src="image/1434.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1071"/><st c="4300"/></span><span><st c="4313">.</st></span></p>
			<p class="calibre3"><st c="4314">For the purposes of this discussion, let’s assume we opt for the standard binary search with its </st><img src="image/1435.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1072"/><st c="4412"/><st c="4421"> running time. </st><st c="4435">By combining sorting with efficient search algorithms, we can significantly reduce the overall computational cost compared to using linear search on unsorted data. </st><st c="4599">As we can see, sorting and searching exhibit a </st><span><st c="4646">symbiotic relationship.</st></span></p>
			<p class="calibre3"><st c="4669">We</st><a id="_idIndexMarker564" class="pcalibre pcalibre1 calibre6"/><st c="4672"> borrowed the term “symbiotic” from biological systems. </st><st c="4728">In biology, a symbiotic relationship refers to a mutually beneficial interaction between two different organisms, species, or entities. </st><st c="4864">In such relationships, both parties typically derive some form of benefit, which can vary in nature. </st><st c="4965">There are three main types </st><span><st c="4992">of symbiosis:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="5005">Mutualism</st></strong><st c="5015">: Both organisms </st><a id="_idIndexMarker565" class="pcalibre pcalibre1 calibre6"/><st c="5033">benefit from the relationship. </st><st c="5064">For example, bees and flowers have a mutualistic relationship; bees get nectar from the flowers, and flowers get pollinated by </st><span><st c="5191">the bees.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="5200">Commensalism</st></strong><st c="5213">: One </st><a id="_idIndexMarker566" class="pcalibre pcalibre1 calibre6"/><st c="5220">organism benefits while the other is neither helped nor harmed. </st><st c="5284">For example, barnacles attach to a whale and benefit from being transported to different feeding grounds without affecting </st><span><st c="5407">the whale.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="5417">Parasitism</st></strong><st c="5428">: One organism</st><a id="_idIndexMarker567" class="pcalibre pcalibre1 calibre6"/><st c="5443"> benefits at the expense of the other. </st><st c="5482">For example, ticks feed on the blood of mammals, benefiting the tick but potentially harming </st><span><st c="5575">the host.</st></span></li>
			</ul>
			<p class="calibre3"><st c="5584">In a broader sense, “symbiotic” can describe relationships in various contexts where cooperation and mutual benefit</st><a id="_idTextAnchor123" class="pcalibre pcalibre1 calibre6"/><st c="5700"> are key. </st><st c="5710">However, sorting and searching can be considered to have a unique form of a symbiotic relationship, akin to parasitism. </st><st c="5830">In this relationship, sorting benefits searching because sorted data can significantly enhance the efficiency of search operations. </st><st c="5962">For instance, binary search requires sorted data to function and can quickly locate an element in logarithmic time, which is much faster than a linear search in unsorted data. </st><st c="6138">Additionally, certain search algorithms, such as those used in databases or for specific applications, inherently involve sorting as a pre-processing step to optimize the </st><span><st c="6309">search process.</st></span></p>
			<p class="calibre3"><st c="6324">However, the reverse is not true. </st><st c="6359">Efficient search algorithms do not improve the efficiency of sorting algorithms. </st><st c="6440">In comparison-based sorting algorithms, the performance of sorting algorithms remains unaffected by the efficiency of search algorithms. </st><st c="6577">Sorting has its inherent complexity, and the costs associated with it do not diminish through advancements in search techniques. </st><st c="6706">Thus, while sorting provides a significant advantage to searching, the benefit is one-sided. </st><st c="6799">The symbiotic relationship here is more parasitic, with searching reaping the benefits of sorted data without reciprocating any </st><a id="_idIndexMarker568" class="pcalibre pcalibre1 calibre6"/><st c="6927">advantage to the </st><span><st c="6944">sorting process.</st></span></p>
			<p class="calibre3"><st c="6960">Here is how searching and </st><span><st c="6987">sorting interact:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="7004">Efficiency of search operations</st></strong><st c="7036">: The binary search algorithm requires data to be sorted to work correctly. </st><st c="7113">When data is sorted, binary search can quickly locate an element in </st><img src="image/1436.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1073"/><st c="7181"/><st c="7190"> time, which is much faster than the </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="7226"/><st c="7227"> time complexity of a linear search in </st><span><st c="7266">unsorted data.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7280">Sorting as a pre-processing step</st></strong><st c="7313">: Many search-related problems benefit from sorting as a preliminary step. </st><st c="7389">For instance, when dealing with range queries or searching for multiple elements, sorting the data first can lead to more </st><span><st c="7511">efficient algorithms.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7532">Complex algorithms</st></strong><st c="7551">: Some complex algorithms combine sorting and searching to solve problems more efficiently. </st><st c="7644">For example, algorithms for finding the median, mode, or other statistics often start with </st><span><st c="7735">sorting data.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7748">Data structures</st></strong><st c="7764">: Data structures such as balanced binary search trees (e.g., AVL trees and red-black trees) inherently maintain a sorted order, allowing efficient search, insertion, and deletion operations. </st><st c="7957">Similarly, B-trees used in databases maintain sorted data to optimize </st><span><st c="8027">search operations.</st></span></li>
			</ul>
			<p class="calibre3"><st c="8045">Sorting and searching are not the only concepts in computer science with symbiotic ties. </st><st c="8135">There are other pairs of concepts that exhibit similar mutually beneficial relationships. </st><st c="8225">Let’s take a look at some </st><span><st c="8251">of them:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="8259">Exploration and exploitation in </st></strong><span><strong class="bold"><st c="8292">AI search</st></strong></span><span><st c="8301">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="8303">Exploration</st></strong><st c="8314">: Implemented by algorithms such as </st><strong class="bold"><st c="8351">Breadth-First Search</st></strong><st c="8371"> (</st><strong class="bold"><st c="8373">BFS</st></strong><st c="8376">), exploration involves</st><a id="_idIndexMarker569" class="pcalibre pcalibre1 calibre6"/><st c="8400"> examining a wide area of the search space. </st><st c="8444">The more we invest in exploration, the less we need to rely on exploitation, which can </st><span><st c="8531">be risky.</st></span></li><li class="calibre13"><strong class="bold"><st c="8540">Exploitation</st></strong><st c="8553">: Implemented by algorithms such as </st><strong class="bold"><st c="8590">Depth-First Search</st></strong><st c="8608"> (</st><strong class="bold"><st c="8610">DFS</st></strong><st c="8613">), exploitation</st><a id="_idIndexMarker570" class="pcalibre pcalibre1 calibre6"/><st c="8629"> focuses on exploring one path deeply before trying others. </st><st c="8689">Balancing exploration and exploitation is crucial to avoid the risk of failed searches and ensure </st><span><st c="8787">efficient problem-solving.</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="8813">Cost versus heuristics in AI </st></strong><span><strong class="bold"><st c="8843">search strategies</st></strong></span><span><st c="8860">:</st></span><ul class="calibre50"><li class="calibre13"><st c="8862">In AI search strategies, there exists a symbiotic relationship between the cost of search and the use of heuristics. </st><st c="8979">Early in the search process, investing in well-chosen heuristics can significantly lower the overall search cost by steering the search in more productive directions. </st><st c="9146">This balance leads to more efficient problem-solving. </st><st c="9200">A prime example is the A* search algorithm, which optimally combines both heuristics and path cost to find the most </st><span><st c="9316">efficient solution.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="9335">These examples </st><a id="_idIndexMarker571" class="pcalibre pcalibre1 calibre6"/><st c="9351">demonstrate that the symbiotic relationship between different concepts is a common theme in computer science. </st><st c="9461">Balancing and optimizing these relationships are key to developing efficient algorithms and solving complex </st><span><st c="9569">computational problems.</st></span></p>
			<p class="calibre3"><st c="9592">Let’s conclude this section with an illustrative example. </st><st c="9651">Imagine that there is a hypothetical currency used to pay for the computational complexity of tasks, and this currency is called “comparison.” When searching and retrieving an item from an unsorted database, we pay a cost of </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="9876"/><st c="9925"> comparisons, where </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1074"/><st c="9944"/><st c="9945"> is the size of the dataset. </st><st c="9974">However, if we invest in sorting the data beforehand using an efficient sorting algorithm, the cost of searching can be reduced to </st><img src="image/573.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre458"/><st c="10105"/> <span><st c="10112">comparisons.</st></span></p>
			<p class="calibre3"><st c="10124">But this reduction in search cost comes with an upfront cost. </st><st c="10187">Sorting the data efficiently requires approximately </st><img src="image/1441.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1075"/><st c="10239"/><st c="10248"> comparisons. </st><st c="10261">Therefore, the total cost of first sorting and then searching is </st><img src="image/1442.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1076"/><st c="10326"/><st c="10333"> (for sorting) plus </st><img src="image/1443.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1077"/><st c="10352"/><st c="10357"> (for searching), which simplifies to approximately </st><img src="image/1444.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1078"/><st c="10408"/><st c="10415"> comparisons, since </st><img src="image/573.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre458"/><st c="10434"/><st c="10441"> is relatively small compared </st><span><st c="10470">to </st></span><span><img src="image/1446.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1079"/><st c="10473"/></span><span><st c="10482">.</st></span></p>
			<p class="calibre3"><st c="10483">Given this, you might wonder about the benefit of investing in sorting. </st><st c="10556">The benefit of sorting becomes evident when multiple search operations are needed. </st><st c="10639">If we sort the data once and then perform many searches, the initial sorting cost is amortized over numerous searches, making each individual search operation significantly faster and more efficient. </st><st c="10839">Thus, the upfront investment in sorting pays off in scenarios where frequent searches are required, highlighting the symbiotic relationship where sorting optimizes the overall efficiency of </st><span><st c="11029">search tasks.</st></span></p>
			<p class="calibre3"><st c="11042">However, there is a strong underlying assumption in this scenario that may not hold true in many real-world applications – the assumption that data is static and does not change. </st><st c="11222">In reality, datasets are often dynamic, requiring not only search operations but also frequent insertions </st><span><st c="11328">and deletions.</st></span></p>
			<p class="calibre3"><st c="11342">When dealing with unsorted data, inserting a new item is straightforward and incurs no comparison cost, as the new item is simply added to the end of the collection. </st><st c="11509">Deleting an item, however, requires searching for it, which can take up to </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="11584"/><st c="11633"> comparisons, followed by </st><span><st c="11658">its removal.</st></span></p>
			<p class="calibre3"><st c="11670">In contrast, with sorted data, inserting a new item necessitates maintaining the order, which often means re-sorting the data or finding the appropriate position for the new item, incurring additional comparison costs. </st><st c="11890">Deleting an item from a sorted dataset involves searching for it in logarithmic time, thanks to the order, but it does not require re-sorting </st><span><st c="12032">after removal.</st></span></p>
			<p class="calibre3"><st c="12046">In conclusion, while </st><a id="_idIndexMarker572" class="pcalibre pcalibre1 calibre6"/><st c="12068">sorting data upfront can significantly reduce the cost of search operations when searches are frequent, this benefit diminishes in dynamic datasets. </st><st c="12217">Every insertion may require additional sorting, increasing the overall cost. </st><st c="12294">Therefore, in environments where data is frequently modified, the advantage of pre-sorting for efficient searching must be weighed against the ongoing costs of maintaining the sorted order. </st><st c="12484">This consideration challenges the impact of sorting on improving search efficiency in </st><span><st c="12570">dynamic scenarios.</st></span></p>
			<p class="calibre3"><st c="12588">In the next section, we will demonstrate how achieving a balance between sorting and searching can lead to the design of efficient algorithms. </st><st c="12732">We will explore this balance through real-world examples, both within and outside of information systems, to help make more effective and </st><span><st c="12870">efficient decisions.</st></span></p>
			<h1 id="_idParaDest-110" class="calibre5"><a id="_idTextAnchor124" class="pcalibre pcalibre1 calibre6"/><st c="12890">The efficiency dilemma – to organize or not?</st></h1>
			<p class="calibre3"><st c="12935">We have observed</st><a id="_idIndexMarker573" class="pcalibre pcalibre1 calibre6"/><st c="12952"> numerous professionals and university professors maintaining cluttered offices with papers, books, and bills scattered everywhere. </st><st c="13084">They often struggle to locate the items they need, spending considerable amounts of time in the process. </st><st c="13189">Fearing the potential loss of something important, they tend to hold onto almost everything. </st><st c="13282">In contrast, some individuals place great emphasis on organization (i.e., sorting). </st><st c="13366">They invest substantial amounts of time in arranging and categorizing their belongings. </st><st c="13454">However, the time they dedicate to organizing is rewarded when it comes to retrieving the things </st><span><st c="13551">they need.</st></span></p>
			<p class="calibre3"><st c="13561">A fundamental question is, which approach is more efficient – being organized or disorganized? </st><st c="13657">In this section, I aim to explore the notion that the value placed on organization may be overestimated, drawing insights from the symbiotic relationship between sorting </st><span><st c="13827">and searching.</st></span></p>
			<p class="calibre3"><st c="13841">Professionals with cluttered offices often operate in an environment where immediate retrieval of specific items is challenging. </st><st c="13971">This disorganized approach can lead to inefficiencies, as significant time is spent searching for necessary documents or tools. </st><st c="14099">Despite the apparent chaos, there is often an underlying system that makes sense to the individual, although it may not be immediately apparent </st><span><st c="14243">to others.</st></span></p>
			<p class="calibre3"><st c="14253">Conversely, individuals who prioritize organization invest time upfront to categorize and sort their items. </st><st c="14362">This methodical approach can initially seem time-consuming, but it pays off when they need to retrieve something quickly. </st><st c="14484">The efficiency gained in retrieval often justifies the time spent organizing. </st><st c="14562">By having a well-structured system, they minimize the search time, making their workflow smoother and </st><span><st c="14664">more predictable.</st></span></p>
			<p class="calibre3"><st c="14681">The core question of whether organization or disorganization is more efficient depends on the context and the specific needs of the individual. </st><st c="14826">For some, a cluttered workspace may stimulate creativity and flexibility, while for others, an organized environment provides clarity </st><span><st c="14960">and efficiency.</st></span></p>
			<p class="calibre3"><st c="14975">Drawing parallels from sorting and search algorithms, we can see that the effectiveness of each approach can vary. </st><st c="15091">In computational terms, an organized system (such as a sorted array) allows for faster search times (using algorithms such as binary search), whereas a disorganized system (such as an unsorted array) might require more exhaustive search methods (such as linear search). </st><st c="15361">However, the initial sorting process itself has a cost, and the decision to sort depends on the frequency and urgency of </st><span><st c="15482">search operations.</st></span></p>
			<p class="calibre3"><st c="15500">In conclusion, the value of organization versus disorganization can be seen as analogous to the trade-offs between sorting and searching in algorithms. </st><st c="15653">Both approaches have their merits and drawbacks, and the optimal strategy often involves finding a balance that suits the specific requirements and constraints of the situation. </st><st c="15831">By understanding the symbiotic relationship between sorting and searching, we can make more informed decisions about how</st><a id="_idIndexMarker574" class="pcalibre pcalibre1 calibre6"/><st c="15951"> to manage our resources and </st><span><st c="15980">time effectively.</st></span></p>
			<h2 id="_idParaDest-111" class="calibre5"><a id="_idTextAnchor125" class="pcalibre pcalibre1 calibre6"/><st c="15997">Think like a computer scientist</st></h2>
			<p class="calibre3"><st c="16029">Let’s consider the following scenario – Janet is a professor of mathematics who receives a pile of scientific papers; let’s assume, on average, she receives </st><img src="image/1448.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1080"/><st c="16187"/><st c="16188"> papers each day. </st><st c="16206">She needs to retrieve a couple of papers daily for her research. </st><st c="16271">The number of papers she picks varies, but on average, she retrieves </st><img src="image/1449.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1081"/><st c="16340"/><st c="16341"> papers per day. </st><st c="16358">A few papers are her favorites, which she references more often, while the majority are </st><span><st c="16446">rarely accessed.</st></span></p>
			<p class="calibre3"><st c="16462">Applying our understanding of searching, sorting, and their computational costs, we aim to assist Janet in making efficient decisions. </st><st c="16598">First, Janet needs to decide whether she should sort the collection of papers on her desk and, if so, how often. </st><st c="16711">This decision will depend on balancing the cost of sorting against the efficiency gained in retrieving papers. </st><st c="16822">Second, she wants to calculate the total running time of her operations over </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="16899"/><st c="16900"> days, considering both sorting and retrieving </st><span><st c="16947">the times.</st></span></p>
			<p class="calibre3"><st c="16957">The following are </st><span><st c="16976">our assumptions:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="16992">Average number of new papers received per </st><span><st c="17035">day: p</st></span></li>
				<li class="calibre13"><st c="17041">Average number of scientific papers accessed per </st><span><st c="17091">day: s</st></span></li>
				<li class="calibre13"><st c="17097">Total number of </st><span><st c="17114">days: k</st></span></li>
			</ul>
			<p class="calibre3"><st c="17121">If the papers are not sorted, accessing each paper would take </st><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="17184"/><st c="17185"> time, where </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="17198"/><st c="17247"> is the total number of papers on her desk. </st><st c="17290">After </st><img src="image/1172.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre771"/><st c="17296"/><st c="17297"> days, the total number of papers is approximately </st><img src="image/1454.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mo&gt;.&lt;/mml:mo&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1082"/><st c="17348"/><st c="17352">. If the papers are sorted, accessing each paper would take </st><img src="image/1152.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1083"/><st c="17412"/><st c="17421"> time due to binary search. </st><st c="17448">Sorting </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1084"/><st c="17456"/><st c="17505"> papers takes </st><img src="image/1457.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1085"/><st c="17518"/> <span><st c="17528">time.</st></span></p>
			<p class="calibre3"><st c="17533">Let’s estimate the total running time without sorting. </st><st c="17589">The total access time for one day is </st><img src="image/1458.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mo&gt;.&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1086"/><st c="17626"/><st c="17633">. Over </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="17640"/><st c="17641"> days, the running </st><span><st c="17660">time is:</st></span></p>
			<p class="calibre3"><img src="image/1460.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mrow&gt;&lt;mml:munderover&gt;&lt;mml:mo stretchy=&quot;false&quot;&gt;∑&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:munderover&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;.&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;≈&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1087"/><st c="17668"/></p>
			<p class="calibre3"><st c="17689">If Janet sorts her papers every day, then sorting time for one day is </st><img src="image/1461.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1088"/><st c="17759"/><st c="17774">. Access time for one day can be </st><span><st c="17807">estimated as:</st></span></p>
			<p class="calibre3"> <img src="image/1462.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mo&gt;.&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;log&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1089"/><st c="17820"/><st c="17836">, and over </st><img src="image/422.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre345"/><st c="17847"/> <span><st c="17848">days:</st></span></p>
			<p class="calibre3"><img src="image/1464.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mrow&gt;&lt;mml:munderover&gt;&lt;mml:mo stretchy=&quot;false&quot;&gt;∑&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:munderover&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;≈&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;o&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;p&lt;/mml:mi&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;k&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1090"/><st c="17853"/></p>
			<p class="calibre3"><st c="17907">Sorting papers frequently</st><a id="_idIndexMarker575" class="pcalibre pcalibre1 calibre6"/><st c="17932"> can be beneficial if the number of papers that Janet accesses is large compared to the number she receives. </st><st c="18041">More precisely, if </st><img src="image/1465.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;&gt;&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1091"/><st c="18060"/><st c="18071">, where </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="18079"/><st c="18128"> is the total number of papers, then sorting is advantageous. </st><st c="18189">For instance, if Janet has </st><img src="image/1467.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;10,000&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1092"/><st c="18216"/><st c="18222"> papers in her archive and retrieves more than 100 papers in one day (since </st><img src="image/1468.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;10,000&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;100&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1093"/><st c="18297"/><st c="18313">), sorting becomes beneficial. </st><st c="18344">However, this number will increase daily, which is not </st><span><st c="18399">very realistic.</st></span></p>
			<p class="calibre3"><st c="18414">Regardless of this, we have made several implicit assumptions about </st><span><st c="18483">Janet’s situation:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="18501">Sorting capability</st></strong><st c="18520">: We assumed that Janet could sort her papers using an efficient algorithm such as merge sort. </st><st c="18616">However, humans typically sort items no better than simple algorithms such as bubble sort, which is much </st><span><st c="18721">less efficient.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="18736">Equal access probability</st></strong><st c="18761">: We assumed that all papers have the same likelihood of being accessed. </st><st c="18835">In reality, some papers are referenced frequently while others are rarely or never retrieved, possibly following a power </st><span><st c="18956">law distribution.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="18973">Returning papers to the top</st></strong><st c="19001">: In the unsorted scenario, we assumed Janet usually returns a used paper to the top of the pile. </st><st c="19100">This means she wouldn’t have to search through the entire pile to find</st><a id="_idTextAnchor126" class="pcalibre pcalibre1 calibre6"/><st c="19170"> the paper again. </st><st c="19188">Additionally, while humans are poor at systematic sorting, they often have a strong ability to locate items among a random assortment, similar to a mental </st><span><st c="19343">hashing mechanism.</st></span></li>
			</ul>
			<p class="calibre3"><st c="19361">Considering these points, the initial analysis that favors frequent sorting may not hold. </st><st c="19452">The natural human ability to locate frequently used items, and the impracticality of maintaining a sorted system in a dynamic environment, suggest that sorting may not always be the most efficient approach </st><span><st c="19658">for Janet.</st></span></p>
			<p class="calibre3"><st c="19668">It is important to note that the example provided is a computational analysis that can certainly inform decision-making, but it is not the sole factor to consider. </st><st c="19833">In other words, computational efficiency does not necessarily translate to productivity when a human is involved or when a human is part of the process. </st><st c="19986">Having a neat and organized environment can psychologically improve our mood, help us concentrate, and foster </st><span><st c="20096">deep work.</st></span></p>
			<p class="calibre3"><st c="20106">It is not surprising</st><a id="_idIndexMarker576" class="pcalibre pcalibre1 calibre6"/><st c="20127"> that, even in hypothetical scenarios involving robot uprisings, the robots themselves may exhibit disorder and lack </st><span><st c="20244">of organization!</st></span></p>
			<p class="calibre3"><st c="20260">While our analysis suggests that sorting may not always be the most efficient approach from a purely computational standpoint, human factors such as the need for a tidy workspace and the psychological benefits of organization should not be overlooked. </st><st c="20513">These factors can significantly enhance overall productivity and well-being, making the decision to sort and organize papers more complex than simple computational efficiency </st><span><st c="20688">would suggest.</st></span></p>
			<h1 id="_idParaDest-112" class="calibre5"><a id="_idTextAnchor127" class="pcalibre pcalibre1 calibre6"/><st c="20702">Summary</st></h1>
			<p class="calibre3"><st c="20710">In this chapter, we examined the symbiotic relationship between sorting and searching in detail. </st><st c="20808">It was demonstrated that while sorting can significantly reduce the time complexity of search operations, the overall efficiency gained from sorting must be carefully weighed against the costs of maintaining a sorted dataset, especially in dynamic environments where data is frequently updated. </st><st c="21103">Through various scenarios and examples, we highlighted the trade-offs involved in deciding whether and how often to sort data. </st><st c="21230">We also pointed out that the computational benefits of sorting do not necessarily translate to practical efficiency when human factors and psychological impacts are considered. </st><st c="21407">Our analysis revealed that humans’ natural ability to locate items and the psychological advantages of an organized workspace add layers of complexity to the </st><span><st c="21565">decision-making process.</st></span></p>
			<p class="calibre3"><st c="21589">The chapter concluded with a recognition that while computational analysis provides valuable insights, it is not the sole determinant of productivity, especially when humans are involved. </st><st c="21778">The hypothetical benefits of sorting must be balanced with practical considerations and the inherent strengths and preferences of individuals. </st><st c="21921">As we move forward, the next chapter will introduce randomized algorithms, offering a new perspective on handling computational problems. </st><st c="22059">These algorithms leverage randomness to achieve efficient solutions and provide an exciting contrast to the deterministic approaches discussed </st><span><st c="22202">thus far.</st></span></p>
			<h1 id="_idParaDest-113" class="calibre5"><a id="_idTextAnchor128" class="pcalibre pcalibre1 calibre6"/><st c="22211">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><em class="italic"><st c="22242">Algorithms to Live By: The Computer Science of Human Decisions</st></em><st c="22305">. By Brian Christian and Tom Griffiths. </st><st c="22345">Henry Holt and </st><span><st c="22360">Co. </st><st c="22364">2016</st></span></li>
				<li class="calibre13"><em class="italic"><st c="22368">Deep Work: Rules for Focused Success in a Distracted World</st></em><st c="22427">. By Cal Newport, Grand Central </st><span><st c="22459">Publishing, 2016</st></span></li>
			</ul>
		</div>
	<div id="charCountTotal" value="22475" class="calibre2"/></body></html>