- en: <st c="0">8</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Symbiotic Relationship between Sort and Search</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="48">With some estimates indicating that sorting consumes a significant
    portion of global computing power, this chapter examines the symbiotic relationship
    between sorting and searching.</st> <st c="231">We will provide an overview of
    these fundamental operations and explore how they interact and complement each
    other.</st> <st c="348">The discussion will emphasize real-world examples to illustrate
    how to balance these crucial tasks in</st> <st c="450">data processing.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="466">This chapter serves as a practical guide for applying analytical
    techniques to address complex real-world problems.</st> <st c="583">You will compare
    the complexities of sorting and searching to understand how to achieve equilibrium
    in their application.</st> <st c="705">By examining real-world scenarios, you
    will gain insights into how algorithm analysis can be effectively utilized in
    decision-making.</st> <st c="839">Through these examples, the chapter aims to
    highlight the importance of choosing the right approach for specific situations,
    optimizing both sorting and searching processes to enhance overall efficiency</st>
    <st c="1042">and performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1058">We will explore the following topics in</st> <st c="1099">this
    chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1112">Striking the right balance between sorting</st> <st c="1156">and
    searching</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1169">The efficiency dilemma – to organize</st> <st c="1207">or not?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1214">Striking the right balance between sorting and searching</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1271">Let’s take a moment to reflect on our interactions with various
    information systems, ranging from local databases to search engines and libraries.</st>
    <st c="1419">How many of these interactions involve search-related tasks?</st>
    <st c="1480">Consider decision-making processes.</st> <st c="1516">Can we assume
    that, in most cases, making a decision involves searching for the best possible
    option?</st> <st c="1618">Similarly, can we infer that most problem-solving tasks
    involve some form</st> <st c="1692">of search?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1702">In the previous chapter, we explored the differences between algorithmic
    search and AI-driven search.</st> <st c="1805">While this chapter focuses on algorithmic
    search, some of the questions we pose will be relevant to AI search</st> <st c="1915">as
    well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1923">The answer to the questions we posed earlier is, yes, most of our
    interactions with computers involve</st> <st c="2025">direct search tasks or can
    be framed as search problems, such as</st> *<st c="2091">optimization</st>* <st
    c="2103">and</st> *<st c="2108">constraint-satisfaction problems</st>*<st c="2140">.
    The concept of search extends beyond just computer</st> <st c="2193">systems.</st>
    <st c="2202">In our everyday lives, we frequently solve search problems.</st>
    <st c="2262">Whether it’s searching for the right shirt in a cluttered closet
    on a cold winter day or finding the electric bill amid a stack of important documents,
    flyers, and miscellaneous papers, we are constantly engaging in search activities.</st>
    <st c="2497">This demonstrates how fundamental and pervasive search operations
    are, both in computing and in our</st> <st c="2597">daily routines.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2612">This highlights the substantial computational and human effort
    invested in search tasks.</st> <st c="2702">In algorithm design and analysis,
    this effort is often measured in time and space complexities.</st> <st c="2798">While
    ther</st><st c="2808">e are additional cost factors involved, these are beyond
    the scope of our</st> <st c="2883">current discussion.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2902">Symbiotic link between sorting and searchin</st><st c="2946">g</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2948">The primary objective of this section is</st> <st c="2988">to analyze
    the cost of search operations, focusing on their time and space complexity from
    a practical perspective.</st> <st c="3105">Understanding these costs is crucial
    for optimizing search algorithms and improving overall</st> <st c="3197">system
    efficiency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3215">In the previous chapter, we demonstrated that the time complexity
    of a linear search without any pre-processing, such as sorting, is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)
    <st c="3349"><st c="3350">in the worst case.</st> <st c="3370">This means that
    we may need to make up to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="3412"><st c="3461">comparisons to locate the target key.</st> <st c="3499">Additionally,
    if we search for all items with the same key, the number of comparisons remains</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="3593"><st c="3642">and cannot</st> <st c="3653">be reduced.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3664">However, we can achieve better performance than</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)
    <st c="3713"><st c="3714">by investing some computational resources to sort the
    data before performing any search operations.</st> <st c="3815">As discussed in</st>
    [*<st c="3831">Chapter 6</st>*](B22248_06.xhtml#_idTextAnchor081)<st c="3840">,</st>
    *<st c="3842">Merge Sort</st>*<st c="3852">, is one of</st> <st c="3863">the most
    efficient sorting algorithms, with a running time of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1432.png)<st
    c="3926"><st c="3937">. Once the data is sorted, we can utilize more efficient
    search algorithms, such as those in the binary search family.</st> <st c="4056">For
    instance, a</st> <st c="4072">standard</st> *<st c="4081">binary search</st>*
    <st c="4094">has a running time of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1248.png)<st
    c="4117"><st c="4126">. Furthermore, for data that is uniformly distributed, we
    could employ even more efficient algorithms such</st> <st c="4233">as</st> *<st
    c="4236">interpolation search</st>*<st c="4256">, which has an average-case running
    time</st> <st c="4297">of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1434.png)<st
    c="4300"><st c="4313">.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4314">For the purposes of this discussion, let’s assume we opt for the
    standard binary search with its</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1435.png)
    <st c="4412"><st c="4421">running time.</st> <st c="4435">By combining sorting
    with efficient search algorithms, we can significantly reduce the overall computational
    cost compared to using linear search on unsorted data.</st> <st c="4599">As we
    can see, sorting and searching exhibit a</st> <st c="4646">symbiotic relationship.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4669">We</st> <st c="4672">borrowed the term “symbiotic” from biological
    systems.</st> <st c="4728">In biology, a symbiotic relationship refers to a mutually
    beneficial interaction between two different organisms, species, or entities.</st>
    <st c="4864">In such relationships, both parties typically derive some form of
    benefit, which can vary in nature.</st> <st c="4965">There are three main types</st>
    <st c="4992">of symbiosis:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5005">Mutualism</st>**<st c="5015">: Both organisms</st> <st c="5033">benefit
    from the relationship.</st> <st c="5064">For example, bees and flowers have a
    mutualistic relationship; bees get nectar from the flowers, and flowers get pollinated
    by</st> <st c="5191">the bees.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5200">Commensalism</st>**<st c="5213">: One</st> <st c="5220">organism
    benefits while the other is neither helped nor harmed.</st> <st c="5284">For example,
    barnacles attach to a whale and benefit from being transported to different feeding
    grounds without affecting</st> <st c="5407">the whale.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5417">Parasitism</st>**<st c="5428">: One organism</st> <st c="5443">benefits
    at the expense of the other.</st> <st c="5482">For example, ticks feed on the
    blood of mammals, benefiting the tick but potentially harming</st> <st c="5575">the
    host.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5584">In a broader sense, “symbiotic” can describe relationships in various
    contexts where cooperation and mutual benefit</st> <st c="5700">are key.</st>
    <st c="5710">However, sorting and searching can be considered to have a unique
    form of a symbiotic relationship, akin to parasitism.</st> <st c="5830">In this
    relationship, sorting benefits searching because sorted data can significantly
    enhance the efficiency of search operations.</st> <st c="5962">For instance, binary
    search requires sorted data to function and can quickly locate an element in logarithmic
    time, which is much faster than a linear search in unsorted data.</st> <st c="6138">Additionally,
    certain search algorithms, such as those used in databases or for specific applications,
    inherently involve sorting as a pre-processing step to optimize the</st> <st c="6309">search
    process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6324">However, the reverse is not true.</st> <st c="6359">Efficient search
    algorithms do not improve the efficiency of sorting algorithms.</st> <st c="6440">In
    comparison-based sorting algorithms, the performance of sorting algorithms remains
    unaffected by the efficiency of search algorithms.</st> <st c="6577">Sorting has
    its inherent complexity, and the costs associated with it do not diminish through
    advancements in search techniques.</st> <st c="6706">Thus, while sorting provides
    a significant advantage to searching, the benefit is one-sided.</st> <st c="6799">The
    symbiotic relationship here is more parasitic, with searching reaping the benefits
    of sorted data without reciprocating any</st> <st c="6927">advantage to the</st>
    <st c="6944">sorting process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6960">Here is how searching and</st> <st c="6987">sorting interact:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7004">Efficiency of search operations</st>**<st c="7036">: The binary
    search algorithm requires data to be sorted to work correctly.</st> <st c="7113">When
    data is sorted, binary search can quickly locate an element in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1436.png)
    <st c="7181"><st c="7190">time, which is much faster than the</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="7226"><st c="7227">time complexity of a linear search in</st> <st c="7266">unsorted
    data.</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7280">Sorting as a pre-processing step</st>**<st c="7313">: Many search-related
    problems benefit from sorting as a preliminary step.</st> <st c="7389">For instance,
    when dealing with range queries or searching for multiple elements, sorting the
    data first can lead to more</st> <st c="7511">efficient algorithms.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7532">Complex algorithms</st>**<st c="7551">: Some complex algorithms
    combine sorting and searching to solve problems more efficiently.</st> <st c="7644">For
    example, algorithms for finding the median, mode, or other statistics often start
    with</st> <st c="7735">sorting data.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7748">Data structures</st>**<st c="7764">: Data structures such as
    balanced binary search trees (e.g., AVL trees and red-black trees) inherently
    maintain a sorted order, allowing efficient search, insertion, and deletion operations.</st>
    <st c="7957">Similarly, B-trees used in databases maintain sorted data to optimize</st>
    <st c="8027">search operations.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8045">Sorting and searching are not the only concepts in computer science
    with symbiotic ties.</st> <st c="8135">There are other pairs of concepts that
    exhibit similar mutually beneficial relationships.</st> <st c="8225">Let’s take
    a look at some</st> <st c="8251">of them:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="8259">Exploration and exploitation in</st>** **<st c="8292">AI search</st>**<st
    c="8301">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8303">Exploration</st>**<st c="8314">: Implemented by algorithms such
    as</st> **<st c="8351">Breadth-First Search</st>** <st c="8371">(</st>**<st c="8373">BFS</st>**<st
    c="8376">), exploration involves</st> <st c="8400">examining a wide area of the
    search space.</st> <st c="8444">The more we invest in exploration, the less we
    need to rely on exploitation, which can</st> <st c="8531">be risky.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8540">Exploitation</st>**<st c="8553">: Implemented by algorithms
    such as</st> **<st c="8590">Depth-First Search</st>** <st c="8608">(</st>**<st
    c="8610">DFS</st>**<st c="8613">), exploitation</st> <st c="8629">focuses on exploring
    one path deeply before trying others.</st> <st c="8689">Balancing exploration
    and exploitation is crucial to avoid the risk of failed searches and ensure</st>
    <st c="8787">efficient problem-solving.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8813">Cost versus heuristics in AI</st>** **<st c="8843">search strategies</st>**<st
    c="8860">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8862">In AI search strategies, there exists a symbiotic relationship
    between the cost of search and the use of heuristics.</st> <st c="8979">Early
    in the search process, investing in well-chosen heuristics can significantly lower
    the overall search cost by steering the search in more productive directions.</st>
    <st c="9146">This balance leads to more efficient problem-solving.</st> <st c="9200">A
    prime example is the A* search algorithm, which optimally combines both heuristics
    and path cost to find the most</st> <st c="9316">efficient solution.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9335">These examples</st> <st c="9351">demonstrate that the symbiotic
    relationship between different concepts is a common theme in computer science.</st>
    <st c="9461">Balancing and optimizing these relationships are key to developing
    efficient algorithms and solving complex</st> <st c="9569">computational problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9592">Let’s conclude this section with an illustrative example.</st>
    <st c="9651">Imagine that there is a hypothetical currency used to pay for the
    computational complexity of tasks, and this currency is called “comparison.” When
    searching and retrieving an item from an unsorted database, we pay a cost of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="9876"><st c="9925">comparisons, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="9944"><st c="9945">is the size of the dataset.</st> <st c="9974">However,
    if we invest in sorting the data beforehand using an efficient sorting algorithm,
    the cost of searching can be reduced to</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)
    <st c="10105"><st c="10112">comparisons.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10124">But this reduction in search cost comes with an upfront cost.</st>
    <st c="10187">Sorting the data efficiently requires approximately</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>.</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/1441.png)
    <st c="10239"><st c="10248">comparisons.</st> <st c="10261">Therefore, the total
    cost of first sorting and then searching is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>.</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/1442.png)
    <st c="10326"><st c="10333">(for sorting) plus</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/1443.png)
    <st c="10352"><st c="10357">(for searching), which simplifies to approximately</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>.</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/1444.png)
    <st c="10408"><st c="10415">comparisons, since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/573.png)
    <st c="10434"><st c="10441">is relatively small compared</st> <st c="10470">to</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>n</mi><mo>.</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow></mrow></math>](img/1446.png)<st
    c="10473"><st c="10482">.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10483">Given this, you might wonder about the benefit of investing in
    sorting.</st> <st c="10556">The benefit of sorting becomes evident when multiple
    search operations are needed.</st> <st c="10639">If we sort the data once and
    then perform many searches, the initial sorting cost is amortized over numerous
    searches, making each individual search operation significantly faster and more
    efficient.</st> <st c="10839">Thus, the upfront investment in sorting pays off
    in scenarios where frequent searches are required, highlighting the symbiotic
    relationship where sorting optimizes the overall efficiency of</st> <st c="11029">search
    tasks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11042">However, there is a strong underlying assumption in this scenario
    that may not hold true in many real-world applications – the assumption that data
    is static and does not change.</st> <st c="11222">In reality, datasets are often
    dynamic, requiring not only search operations but also frequent insertions</st>
    <st c="11328">and deletions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11342">When dealing with unsorted data, inserting a new item is straightforward
    and incurs no comparison cost, as the new item is simply added to the end of the
    collection.</st> <st c="11509">Deleting an item, however, requires searching for
    it, which can take up to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="11584"><st c="11633">comparisons, followed by</st> <st c="11658">its removal.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11670">In contrast, with sorted data, inserting a new item necessitates
    maintaining the order, which often means re-sorting the data or finding the appropriate
    position for the new item, incurring additional comparison costs.</st> <st c="11890">Deleting
    an item from a sorted dataset involves searching for it in logarithmic time, thanks
    to the order, but it does not require re-sorting</st> <st c="12032">after removal.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12046">In conclusion, while</st> <st c="12068">sorting data upfront can
    significantly reduce the cost of search operations when searches are frequent,
    this benefit diminishes in dynamic datasets.</st> <st c="12217">Every insertion
    may require additional sorting, increasing the overall cost.</st> <st c="12294">Therefore,
    in environments where data is frequently modified, the advantage of pre-sorting
    for efficient searching must be weighed against the ongoing costs of maintaining
    the sorted order.</st> <st c="12484">This consideration challenges the impact
    of sorting on improving search efficiency in</st> <st c="12570">dynamic scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12588">In the next section, we will demonstrate how achieving a balance
    between sorting and searching can lead to the design of efficient algorithms.</st>
    <st c="12732">We will explore this balance through real-world examples, both within
    and outside of information systems, to help make more effective and</st> <st c="12870">efficient
    decisions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12890">The efficiency dilemma – to organize or not?</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="12935">We have observed</st> <st c="12952">numerous professionals and
    university professors maintaining cluttered offices with papers, books, and bills
    scattered everywhere.</st> <st c="13084">They often struggle to locate the items
    they need, spending considerable amounts of time in the process.</st> <st c="13189">Fearing
    the potential loss of something important, they tend to hold onto almost everything.</st>
    <st c="13282">In contrast, some individuals place great emphasis on organization
    (i.e., sorting).</st> <st c="13366">They invest substantial amounts of time in
    arranging and categorizing their belongings.</st> <st c="13454">However, the time
    they dedicate to organizing is rewarded when it comes to retrieving the things</st>
    <st c="13551">they need.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13561">A fundamental question is, which approach is more efficient –
    being organized or disorganized?</st> <st c="13657">In this section, I aim to
    explore the notion that the value placed on organization may be overestimated,
    drawing insights from the symbiotic relationship between sorting</st> <st c="13827">and
    searching.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13841">Professionals with cluttered offices often operate in an environment
    where immediate retrieval of specific items is challenging.</st> <st c="13971">This
    disorganized approach can lead to inefficiencies, as significant time is spent
    searching for necessary documents or tools.</st> <st c="14099">Despite the apparent
    chaos, there is often an underlying system that makes sense to the individual,
    although it may not be immediately apparent</st> <st c="14243">to others.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14253">Conversely, individuals who prioritize organization invest time
    upfront to categorize and sort their items.</st> <st c="14362">This methodical
    approach can initially seem time-consuming, but it pays off when they need to
    retrieve something quickly.</st> <st c="14484">The efficiency gained in retrieval
    often justifies the time spent organizing.</st> <st c="14562">By having a well-structured
    system, they minimize the search time, making their workflow smoother and</st>
    <st c="14664">more predictable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14681">The core question of whether organization or disorganization is
    more efficient depends on the context and the specific needs of the individual.</st>
    <st c="14826">For some, a cluttered workspace may stimulate creativity and flexibility,
    while for others, an organized environment provides clarity</st> <st c="14960">and
    efficiency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14975">Drawing parallels from sorting and search algorithms, we can see
    that the effectiveness of each approach can vary.</st> <st c="15091">In computational
    terms, an organized system (such as a sorted array) allows for faster search times
    (using algorithms such as binary search), whereas a disorganized system (such
    as an unsorted array) might require more exhaustive search methods (such as linear
    search).</st> <st c="15361">However, the initial sorting process itself has a
    cost, and the decision to sort depends on the frequency and urgency of</st> <st
    c="15482">search operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15500">In conclusion, the value of organization versus disorganization
    can be seen as analogous to the trade-offs between sorting and searching in algorithms.</st>
    <st c="15653">Both approaches have their merits and drawbacks, and the optimal
    strategy often involves finding a balance that suits the specific requirements
    and constraints of the situation.</st> <st c="15831">By understanding the symbiotic
    relationship between sorting and searching, we can make more informed decisions
    about how</st> <st c="15951">to manage our resources and</st> <st c="15980">time
    effectively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15997">Think like a computer scientist</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="16029">Let’s consider the following scenario – Janet is a professor of
    mathematics who receives a pile of scientific papers; let’s assume, on average,
    she receives</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi></mml:math>](img/1448.png)
    <st c="16187"><st c="16188">papers each day.</st> <st c="16206">She needs to retrieve
    a couple of papers daily for her research.</st> <st c="16271">The number of papers
    she picks varies, but on average, she retrieves</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>s</mml:mi></mml:math>](img/1449.png)
    <st c="16340"><st c="16341">papers per day.</st> <st c="16358">A few papers are
    her favorites, which she references more often, while the majority are</st> <st
    c="16446">rarely accessed.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16462">Applying our understanding of searching, sorting, and their computational
    costs, we aim to assist Janet in making efficient decisions.</st> <st c="16598">First,
    Janet needs to decide whether she should sort the collection of papers on her
    desk and, if so, how often.</st> <st c="16711">This decision will depend on balancing
    the cost of sorting against the efficiency gained in retrieving papers.</st> <st
    c="16822">Second, she wants to calculate the total running time of her operations
    over</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="16899"><st c="16900">days, considering both sorting and retrieving</st>
    <st c="16947">the times.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16957">The following are</st> <st c="16976">our assumptions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="16992">Average number of new papers received per</st> <st c="17035">day:
    p</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="17041">Average number of scientific papers accessed per</st> <st c="17091">day:
    s</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="17097">Total number of</st> <st c="17114">days: k</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17121">If the papers are not sorted, accessing each paper would take</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="17184"><st c="17185">time, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="17198"><st c="17247">is the total number of papers on her desk.</st> <st
    c="17290">After</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="17296"><st c="17297">days, the total number of papers is approximately</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>p</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi></mml:math>](img/1454.png)<st
    c="17348"><st c="17352">. If the papers are sorted, accessing each paper would
    take</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1152.png)
    <st c="17412"><st c="17421">time due to binary search.</st> <st c="17448">Sorting</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="17456"><st c="17505">papers takes</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1457.png)
    <st c="17518"><st c="17528">time.</st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17533">Let’s estimate the total running time without sorting.</st> <st
    c="17589">The total access time for one day is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1458.png)<st
    c="17626"><st c="17633">. Over</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="17640"><st c="17641">days, the running</st> <st c="17660">time is:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:mrow><mml:mo>.</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced><mml:mo>≈</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>s</mml:mi><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1460.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="17689">If Janet sorts her papers every day, then sorting time for one
    day is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1461.png)<st
    c="17759"><st c="17774">. Access time for one day can be</st> <st c="17807">estimated
    as:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1462.png)<st
    c="17820"><st c="17836">, and over</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/422.png)
    <st c="17847"><st c="17848">days:</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>≈</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1464.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="17907">Sorting papers frequently</st> <st c="17932">can be beneficial
    if the number of papers that Janet accesses is large compared to the number she
    receives.</st> <st c="18041">More precisely, if</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>s</mi><mo>></mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1465.png)<st
    c="18060"><st c="18071">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="18079"><st c="18128">is the total number of papers, then sorting is advantageous.</st>
    <st c="18189">For instance, if Janet has</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>10,000</mml:mn></mml:math>](img/1467.png)
    <st c="18216"><st c="18222">papers in her archive and retrieves more than 100
    papers in one day (since</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mn>10,000</mn><mo>)</mo><mo>=</mo><mn>100</mn></mrow></mrow></mrow></math>](img/1468.png)<st
    c="18297"><st c="18313">), sorting becomes beneficial.</st> <st c="18344">However,
    this number will increase daily, which is not</st> <st c="18399">very realistic.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18414">Regardless of this, we have made several implicit assumptions
    about</st> <st c="18483">Janet’s situation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="18501">Sorting capability</st>**<st c="18520">: We assumed that Janet
    could sort her papers using an efficient algorithm such as merge sort.</st> <st
    c="18616">However, humans typically sort items no better than simple algorithms
    such as bubble sort, which is much</st> <st c="18721">less efficient.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18736">Equal access probability</st>**<st c="18761">: We assumed that
    all papers have the same likelihood of being accessed.</st> <st c="18835">In reality,
    some papers are referenced frequently while others are rarely or never retrieved,
    possibly following a power</st> <st c="18956">law distribution.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18973">Returning papers to the top</st>**<st c="19001">: In the unsorted
    scenario, we assumed Janet usually returns a used paper to the top of the pile.</st>
    <st c="19100">This means she wouldn’t have to search through the entire pile to
    find</st> <st c="19170">the paper again.</st> <st c="19188">Additionally, while
    humans are poor at systematic sorting, they often have a strong ability to locate
    items among a random assortment, similar to a mental</st> <st c="19343">hashing
    mechanism.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19361">Considering these points, the initial analysis that favors frequent
    sorting may not hold.</st> <st c="19452">The natural human ability to locate frequently
    used items, and the impracticality of maintaining a sorted system in a dynamic
    environment, suggest that sorting may not always be the most efficient approach</st>
    <st c="19658">for Janet.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19668">It is important to note that the example provided is a computational
    analysis that can certainly inform decision-making, but it is not the sole factor
    to consider.</st> <st c="19833">In other words, computational efficiency does
    not necessarily translate to productivity when a human is involved or when a human
    is part of the process.</st> <st c="19986">Having a neat and organized environment
    can psychologically improve our mood, help us concentrate, and foster</st> <st
    c="20096">deep work.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20106">It is not surprising</st> <st c="20127">that, even in hypothetical
    scenarios involving robot uprisings, the robots themselves may exhibit disorder
    and lack</st> <st c="20244">of organization!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20260">While our analysis suggests that sorting may not always be the
    most efficient approach from a purely computational standpoint, human factors
    such as the need for a tidy workspace and the psychological benefits of organization
    should not be overlooked.</st> <st c="20513">These factors can significantly enhance
    overall productivity and well-being, making the decision to sort and organize
    papers more complex than simple computational efficiency</st> <st c="20688">would
    suggest.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20702">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="20710">In this chapter, we examined the symbiotic relationship between
    sorting and searching in detail.</st> <st c="20808">It was demonstrated that while
    sorting can significantly reduce the time complexity of search operations, the
    overall efficiency gained from sorting must be carefully weighed against the costs
    of maintaining a sorted dataset, especially in dynamic environments where data
    is frequently updated.</st> <st c="21103">Through various scenarios and examples,
    we highlighted the trade-offs involved in deciding whether and how often to sort
    data.</st> <st c="21230">We also pointed out that the computational benefits of
    sorting do not necessarily translate to practical efficiency when human factors
    and psychological impacts are considered.</st> <st c="21407">Our analysis revealed
    that humans’ natural ability to locate items and the psychological advantages
    of an organized workspace add layers of complexity to the</st> <st c="21565">decision-making
    process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21589">The chapter concluded with a recognition that while computational
    analysis provides valuable insights, it is not the sole determinant of productivity,
    especially when humans are involved.</st> <st c="21778">The hypothetical benefits
    of sorting must be balanced with practical considerations and the inherent strengths
    and preferences of individuals.</st> <st c="21921">As we move forward, the next
    chapter will introduce randomized algorithms, offering a new perspective on handling
    computational problems.</st> <st c="22059">These algorithms leverage randomness
    to achieve efficient solutions and provide an exciting contrast to the deterministic
    approaches discussed</st> <st c="22202">thus far.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22211">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="22242">Algorithms to Live By: The Computer Science of Human Decisions</st>*<st
    c="22305">. By Brian Christian and Tom Griffiths.</st> <st c="22345">Henry Holt
    and</st> <st c="22360">Co.</st> <st c="22364">2016</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="22368">Deep Work: Rules for Focused Success in a Distracted World</st>*<st
    c="22427">. By Cal Newport, Grand Central</st> <st c="22459">Publishing, 2016</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
