<html><head></head><body>
		<div id="_idContainer1824" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-127" class="chapter-number"><a id="_idTextAnchor149" class="pcalibre pcalibre1 calibre6"/><st c="0">10</st></h1>
			<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor150" class="pcalibre pcalibre1 calibre6"/><st c="3">Dynamic Programming</st></h1>
			<p class="calibre3"><st c="23">Dynamic programming is a</st><a id="_idIndexMarker608" class="pcalibre pcalibre1 calibre6"/><st c="48"> powerful technique that can dramatically lower the computational costs of many complex algorithms, though it comes with some trade-offs. </st><st c="186">This chapter introduces dynamic programming and includes a review of </st><span><st c="255">greedy algorithms.</st></span></p>
			<p class="calibre3"><st c="273">We will begin by revisiting the principles of divide-and-conquer strategies to contrast them with dynamic programming. </st><st c="393">Dynamic programming stands out in algorithm design due to its ability to solve problems that involve overlapping subproblems and optimal substructure. </st><st c="544">By storing the results of these subproblems, dynamic programming prevents redundant calculations, leading to significant </st><span><st c="665">efficiency gains.</st></span></p>
			<p class="calibre3"><st c="682">Through various examples, we will explore how dynamic programming can be applied to solve classical problems such as the knapsack problem, the longest common subsequence, and the Traveling Salesman Problem. </st><st c="890">Each example will illustrate the step-by-step approach to breaking down a problem, defining the state space, and formulating the recurrence relations necessary for the dynamic </st><span><st c="1066">programming solution.</st></span></p>
			<p class="calibre3"><st c="1087">It is important to note that dynamic programming is an extensive topic that cannot be fully covered in just one chapter. </st><st c="1209">In this chapter, we will focus on the key aspects of this method, including its main elements, applications, and illustrative examples. </st><st c="1345">Additionally, we will discuss how to estimate the complexities of dynamic programming solutions, and we will explore the advantages and limitations of </st><span><st c="1496">this approach.</st></span></p>
			<p class="calibre3"><st c="1510">Specifically, we’ll cover all this in the following </st><span><st c="1563">main sections:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="1577">Dynamic programming </st><span><st c="1598">versus divide-and-conquer</st></span></li>
				<li class="calibre13"><st c="1623">Exploring </st><span><st c="1634">dynamic programming</st></span></li>
				<li class="calibre13"><st c="1653">Greedy algorithms – </st><span><st c="1674">an introduction</st></span></li>
			</ul>
			<h1 id="_idParaDest-129" class="calibre5"><a id="_idTextAnchor151" class="pcalibre pcalibre1 calibre6"/><st c="1689">Dynamic programming versus divide-and-conquer</st></h1>
			<p class="calibre3"><st c="1735">In </st><em class="italic"><st c="1739">Chapters 4</st></em><st c="1749"> and </st><em class="italic"><st c="1754">5</st></em><st c="1755">, we</st><a id="_idIndexMarker609" class="pcalibre pcalibre1 calibre6"/><st c="1759"> explored recursive algorithms and the methods to analyze their complexities. </st><st c="1837">We also explored divide-and-conquer strategies. </st><st c="1885">The fundamental idea behind a divide-and-conquer approach is to break down a problem into smaller subproblems, solve these subproblems optimally, and then combine their solutions to form the final solution. </st><st c="2092">This process is typically carried out recursively, meaning that the problem is continuously divided into subproblems until we reach a point where the subproblem is so small that it can be solved intuitively or straightforwardly. </st><st c="2321">This smallest, simplest problem is referred to as the </st><span><strong class="bold"><st c="2375">base case</st></strong></span><span><st c="2384">.</st></span></p>
			<p class="calibre3"><st c="2385">Dynamic programming follows a similar strategy to divide-and-conquer. </st><st c="2456">It breaks down a problem into subproblems with the explicit assumption that the optimal solution to any subproblem will contribute to the final optimal solution. </st><st c="2618">This characteristic is known as the </st><strong class="bold"><st c="2654">optimal substructure</st></strong><st c="2674">. While</st><a id="_idIndexMarker610" class="pcalibre pcalibre1 calibre6"/><st c="2681"> this property is also present in divide-and-conquer algorithms, it is typically assumed implicitly rather than </st><span><st c="2793">explicitly stated.</st></span></p>
			<p class="calibre3"><st c="2811">However, dynamic programming extends beyond the divide-and-conquer approach in a key way that sets it apart. </st><st c="2921">In dynamic programming, subproblems often share common sub-subproblems, meaning that there is overlap between the subproblems. </st><st c="3048">This characteristic is known </st><a id="_idIndexMarker611" class="pcalibre pcalibre1 calibre6"/><st c="3077">as </st><strong class="bold"><st c="3080">overlapping subproblems</st></strong><st c="3103">. Not all problems exhibit this behavior. </st><st c="3145">When a problem does not have overlapping subproblems, using a straightforward divide-and-conquer approach is more appropriate, as dynamic programming would not provide any additional benefit in </st><span><st c="3339">such cases.</st></span></p>
			<p class="calibre3"><st c="3350">But why do overlapping subproblems matter? </st><st c="3394">One of the primary goals in algorithm design and analysis, which we have consistently focused on, is reducing the computational cost or complexity of algorithms. </st><st c="3556">The importance of overlapping subproblems lies in their potential to significantly lower this computational complexity. </st><st c="3676">In problems where subproblems overlap, divide-and-conquer algorithms may redundantly solve these overlapping sub-subproblems multiple times. </st><st c="3817">In contrast, dynamic programming stores the solutions to these sub-subproblems and reuses them whenever they are needed. </st><st c="3938">This reuse of previously computed solutions can lead to a substantial reduction in computational complexity. </st><st c="4047">However, this efficiency comes at a cost: the additional space required to store the solutions for </st><span><st c="4146">these sub-subproblems.</st></span></p>
			<p class="calibre3"><st c="4168">Now that we understand the connection between divide-and-conquer and dynamic programming, let’s discuss dynamic programming itself. </st><st c="4301">First, it’s crucial to clarify that the term dynamic programming does not pertain to writing code or computer programming. </st><st c="4424">Instead, it refers to a method of mathematical optimization. </st><st c="4485">Dynamic programming was originally proposed as a technique for solving optimization problems, which is why it is studied in both mathematical optimization and computer science. </st><st c="4662">In this chapter, our focus will be on the application of dynamic programming within the field of </st><span><st c="4759">computer science.</st></span></p>
			<p class="calibre3"><st c="4776">As we</st><a id="_idIndexMarker612" class="pcalibre pcalibre1 calibre6"/><st c="4782"> previously discussed, dynamic programming is built on two fundamental concepts: the assumption of optimal substructure and the presence of overlapping subproblems. </st><st c="4947">Optimal substructure implies that the optimal solution to a problem can be formed from the optimal solutions of its subproblems. </st><st c="5076">Overlapping subproblems occur when the same subproblems are solved multiple times during the recursive process. </st><st c="5188">In the following subsections, we will explore these concepts in greater detail, examining how they serve as the foundation of dynamic programming and how they facilitate the development of efficient algorithms for tackling </st><span><st c="5411">complex problems.</st></span></p>
			<h2 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor152" class="pcalibre pcalibre1 calibre6"/><st c="5428">Optimal substructure</st></h2>
			<p class="calibre3"><st c="5449">Optimal substructure </st><a id="_idIndexMarker613" class="pcalibre pcalibre1 calibre6"/><st c="5471">is a cornerstone concept in algorithm design, signifying that an optimal solution to a given problem can be built efficiently using the optimal solutions of its smaller subproblems. </st><st c="5653">This property suggests that the problem can be decomposed into simpler, overlapping subproblems, each of which can be solved independently. </st><st c="5793">Once the subproblems are resolved optimally, their solutions can be combined to form the solution to the original, </st><span><st c="5908">larger problem.</st></span></p>
			<p class="calibre3"><st c="5923">The presence of optimal substructure is crucial because it allows us to break down complex problems into more manageable components. </st><st c="6057">This decomposition not only simplifies the problem-solving process but also makes it possible to apply algorithmic strategies such as dynamic programming and divide-and-conquer. </st><st c="6235">In dynamic programming, the optimal substructure property ensures that once we have the optimal solutions for all subproblems, we can use them to systematically build the optimal solution for the entire problem. </st><st c="6447">This is achieved by storing the results of subproblems in a table, preventing the need to recompute them and thus enhancing the </st><span><st c="6575">algorithm’s efficiency.</st></span></p>
			<p class="calibre3"><st c="6598">In divide-and-conquer algorithms, although in a different way, the optimal substructure is also vital. </st><st c="6702">These algorithms divide the problem into non-overlapping subproblems, solve each subproblem independently, and then combine their solutions. </st><st c="6843">The success of both dynamic programming and divide-and-conquer approaches hinges on the problem exhibiting optimal substructure, as it guarantees that solving smaller parts optimally will lead to the best possible solution for the </st><span><st c="7074">overall problem.</st></span></p>
			<p class="calibre3"><st c="7090">Optimal substructure is </st><a id="_idIndexMarker614" class="pcalibre pcalibre1 calibre6"/><st c="7115">not only a theoretical concept but also a practical tool in algorithm design. </st><st c="7193">It helps us recognize when a problem can be efficiently tackled using dynamic programming or other strategies that rely on building up solutions from smaller components. </st><st c="7363">Understanding and identifying optimal substructure in various problems is a key skill in developing efficient and effective algorithms. </st><st c="7499">Next, we will explore this concept with some </st><span><st c="7544">example problems.</st></span></p>
			<p class="calibre3"><st c="7561">The first example is the shortest path problem. </st><st c="7610">In the shortest path problem on a graph, the goal is to find the shortest path from a source node (vertex) to a destination node. </st><st c="7740">This problem exhibits optimal substructure because the shortest path between two nodes can be broken down into smaller shortest paths between intermediate nodes. </st><st c="7902">Let’s assume </st><strong class="bold"><st c="7915">S</st></strong><st c="7916"> is the source node and </st><strong class="bold"><st c="7940">G</st></strong><st c="7941"> is the destination. </st><st c="7962">We aim to find the shortest path between these two nodes. </st><st c="8020">Suppose </st><strong class="bold"><st c="8028">A</st></strong><st c="8029"> is a node on the optimal (shortest) path from </st><strong class="bold"><st c="8076">S</st></strong><st c="8077"> to </st><strong class="bold"><st c="8081">G</st></strong><st c="8082">. The optimal substructure characteristic suggests that because </st><strong class="bold"><st c="8146">A</st></strong><st c="8147"> is part of the optimal path, the overall optimal path from </st><strong class="bold"><st c="8207">S</st></strong><st c="8208"> to </st><strong class="bold"><st c="8212">G</st></strong><st c="8213"> must consist of the optimal path from </st><strong class="bold"><st c="8252">S</st></strong><st c="8253"> to </st><strong class="bold"><st c="8257">A</st></strong><st c="8258">, followed by the optimal path from </st><strong class="bold"><st c="8294">A</st></strong><st c="8295"> to </st><strong class="bold"><st c="8299">G</st></strong><st c="8300">. Optimal substructure also implies that any subpath that is not optimal cannot be part of the overall optimal solution. </st><st c="8421">This means that if a subpath from S to </st><strong class="bold"><st c="8460">A</st></strong><st c="8461"> or from </st><strong class="bold"><st c="8470">A</st></strong><st c="8471"> to </st><strong class="bold"><st c="8475">G</st></strong><st c="8476"> is not the shortest, then the entire path from </st><strong class="bold"><st c="8524">S</st></strong><st c="8525"> to </st><strong class="bold"><st c="8529">G</st></strong><st c="8530"> cannot be the shortest (see </st><span><em class="italic"><st c="8559">Figure 10</st></em></span><span><em class="italic"><st c="8568">.1</st></em></span><span><st c="8570">).</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1635" class="img---figure">
					<img src="image/B22248_10_1.jpg" alt="Fig 10.1: Illustrating optimal substructure in shortest path problem." class="calibre144"/><st c="8573"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="8587">Fig 10.1: Illustrating optimal substructure in shortest path problem.</st></p>
			<p class="calibre3"><st c="8656">The second example is finding the </st><strong class="bold"><st c="8691">Longest Common Subsequence</st></strong><st c="8717"> (</st><strong class="bold"><st c="8719">LCS</st></strong><st c="8722">). </st><st c="8726">The problem involves</st><a id="_idIndexMarker615" class="pcalibre pcalibre1 calibre6"/><st c="8746"> identifying the longest subsequence that can be found in a set of sequences. </st><st c="8824">It is essential to understand that a subsequence differs from a substring. </st><st c="8899">In a subsequence, unlike in a substring, the elements do not need to be in consecutive positions within the sequence. </st><st c="9017">This distinction is crucial in many applications across computer science, such as in data compression, sequence alignment, and </st><span><st c="9144">file comparison.</st></span></p>
			<p class="calibre3"><st c="9160">Optimal substructure in</st><a id="_idIndexMarker616" class="pcalibre pcalibre1 calibre6"/><st c="9184"> the LCS problem means that the solution to finding the LCS of two sequences can be constructed from the solutions to smaller subproblems. </st><st c="9323">Specifically, the LCS of two sequences X and Y can be built by considering the LCS of prefixes of </st><span><st c="9421">these sequences.</st></span></p>
			<p class="calibre3"><st c="9437">Let’s assume we have two sequences </st><img src="image/1606.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1175"/><st c="9473"/><st c="9474"> of length </st><img src="image/1607.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1176"/><st c="9485"/><st c="9486"> and </st><img src="image/1608.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1177"/><st c="9491"/><st c="9492"> of length </st><img src="image/945.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre736"/><st c="9503"/><st c="9504">. The LCS of these two sequences denoted as LCS</st><img src="image/1610.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1178"/><st c="9551"/><st c="9553">, can be determined using the following approach: if either </st><img src="image/1606.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1179"/><st c="9613"/><st c="9614"> or </st><img src="image/1612.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1180"/><st c="9618"/><st c="9619"> is an empty sequence, then the LCS is also an empty sequence. </st><st c="9682">This is the base case for our recursion. </st><st c="9723">If the last characters of </st><img src="image/1613.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1181"/><st c="9749"/><st c="9750"> and </st><img src="image/1614.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1179"/><st c="9755"/><st c="9756"> match </st><img src="image/1615.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;y&lt;/mml:mi&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1182"/><st c="9763"/><st c="9780">, then these characters must be part of the LCS. </st><st c="9829">Therefore, the problem reduces to finding the LCS of the prefixes </st><img src="image/1616.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1183"/><st c="9895"/><st c="9896"> and </st><img src="image/1617.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1184"/><st c="9901"/><st c="9902">, and then appending the matching character to </st><span><st c="9949">this LCS.</st></span></p>
			<p class="calibre3"><st c="9958">However, if the last characters of </st><img src="image/1606.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1185"/><st c="9994"/><st c="9995"> and </st><img src="image/1608.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1186"/><st c="10000"/><st c="10001"> do not match (i.e., </st><img src="image/1620.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;≠&lt;/mml:mo&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1187"/><st c="10022"/><st c="10023">), then the LCS is the longer of the LCS obtained by either of the </st><span><st c="10090">following methods:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="10108">Excluding the last character of </st><img src="image/1606.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1188"/><st c="10141"/><st c="10142"> and considering the LCS of </st><img src="image/1622.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1189"/><st c="10170"/> <span><st c="10171">and </st></span><span><img src="image/1623.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1190"/><st c="10175"/></span></li>
				<li class="calibre13"><st c="10176">Excluding the last character of </st><img src="image/1612.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1191"/><st c="10208"/><st c="10209"> and considering the LCS of </st><img src="image/1625.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1192"/><st c="10237"/> <span><st c="10243">and </st></span><span><img src="image/1626.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1193"/><st c="10247"/></span></li>
			</ul>
			<p class="calibre3"><st c="10248">Let </st><img src="image/1627.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1194"/><st c="10252"/><st c="10260"> represent the LCS of the prefixes </st><img src="image/1628.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1195"/><st c="10294"/><st c="10300"> and </st><img src="image/1629.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mfenced open=&quot;[&quot; close=&quot;]&quot; separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mi&gt;j&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1196"/><st c="10304"/><st c="10313">. Then the optimal substructure property can be expressed </st><span><st c="10371">as follows:</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1660" class="img---figure">
					<img src="image/B22248_10_2.jpg" alt="" role="presentation" class="calibre144"/><st c="10382"/>
				</div>
			</div>
			<p class="calibre3"><span><strong class="bold"><st c="10467">Example 10.1:</st></strong></span></p>
			<p class="calibre3"><st c="10480">Consider the </st><span><st c="10494">following sequences:</st></span></p>
			<p class="calibre3"><img src="image/1630.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;abbbsbbsh&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1197"/><st c="10514"/></p>
			<p class="calibre3"><img src="image/1631.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;bbsdhjsh&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1198"/><st c="10529"/></p>
			<p class="calibre3"><st c="10542">If the last characters of both sequences are the same (here, both end in </st><img src="image/1632.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1199"/><st c="10615"/><st c="10616">), then </st><img src="image/1632.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1199"/><st c="10624"/><st c="10625"> is part of the LCS, and the problem reduces to finding the LCS of </st><img src="image/1634.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;abbbsbbs&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1200"/><st c="10692"/><st c="10705"> and </st><img src="image/1635.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;bbsdhjs&lt;/mml:mtext&gt;&lt;mml:mo&gt;.&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1201"/><st c="10709"/><st c="10722"> If the last characters are different, we must consider the LCS of the smaller sequences </st><img src="image/1630.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;abbbsbbsh&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1197"/><st c="10810"/><st c="10824"> and </st><img src="image/1637.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;bbsdhjs&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1202"/><st c="10828"/><st c="10841">, or </st><img src="image/1638.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;X&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;abbbsbbs&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1203"/><st c="10846"/><st c="10859"> and </st><img src="image/1631.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;Y&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mtext&gt;bbsdhjsh&lt;/mml:mtext&gt;&lt;/mml:math&gt;" class="calibre1198"/><st c="10863"/><st c="10876">, and take the </st><span><st c="10891">longer one.</st></span></p>
			<p class="calibre3"><st c="10902">The optimal substructure in the LCS problem ensures that the overall LCS can be constructed from the LCS of smaller subproblems. </st><st c="11032">This property is crucial for dynamic programming solutions, where we systematically solve and store the results of these subproblems to build the final </st><span><st c="11184">solution efficiently.</st></span></p>
			<p class="calibre3"><st c="11205">Not all problems </st><a id="_idIndexMarker617" class="pcalibre pcalibre1 calibre6"/><st c="11223">are optimal substructure problems. </st><st c="11258">One example is the longest path problem. </st><st c="11299">The longest path problem, particularly in a graph where cycles may exist, is not considered to have the optimal substructure property. </st><st c="11434">To understand why, let’s first recall what optimal substructure means: a problem exhibits optimal substructure if the optimal solution to the problem can be constructed from the optimal solutions of </st><span><st c="11633">its subproblems.</st></span></p>
			<p class="calibre3"><st c="11649">In the longest path problem, the goal is to find the longest simple path (a path that does not repeat nodes) between two nodes in a graph. </st><st c="11789">This problem is particularly challenging when the graph contains cycles, as the presence of cycles can complicate the identification of the longest path. </st><st c="11943">In the longest path problem, the optimal substructure property does not hold due to the </st><span><st c="12031">following reasons:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="12049">Dependency on subsequent paths</st></strong><st c="12080">: In many cases, a subpath that appears to be part of the longest path from one node to another might not lead to the overall longest path when extended to other nodes. </st><st c="12250">This is because choosing a subpath that looks long at first might force you to take shorter paths later, which would reduce the overall </st><span><st c="12386">path length.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="12398">Cycle involvement</st></strong><st c="12416">: If the graph contains cycles, the longest path might involve traversing through parts of the graph in such a way that it doesn’t neatly decompose into subproblems that independently contribute to the overall longest path. </st><st c="12641">The decision to include or exclude certain edges can dramatically change the resulting </st><span><st c="12728">path’s length.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="12742">Non-additive nature</st></strong><st c="12762">: In problems with optimal substructure, you can usually solve subproblems independently and then combine them to get the optimal solution. </st><st c="12903">However, in the longest path problem, solving a subproblem optimally (i.e., finding the longest path from one node to another) does not guarantee that this subpath will be part of the overall longest path in the entire graph. </st><st c="13129">For example, if you have found the longest path from vertex </st><img src="image/1640.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1204"/><st c="13189"/><st c="13190"> to vertex </st><img src="image/1641.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1205"/><st c="13201"/><st c="13202"> and then from vertex </st><img src="image/1642.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1206"/><st c="13224"/><st c="13225"> to vertex </st><img src="image/1643.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1207"/><st c="13236"/><st c="13237">, the combination of these paths might not yield the longest path from </st><img src="image/1644.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1208"/><st c="13308"/><st c="13309"> to </st><img src="image/1645.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1209"/><st c="13313"/><st c="13314">. The globally optimal solution might instead bypass </st><img src="image/1646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1210"/><st c="13367"/><st c="13368"> entirely if a longer alternative path </st><span><st c="13407">is available.</st></span></li>
			</ul>
			<p class="calibre3"><span><strong class="bold"><st c="13420">Example 10.2:</st></strong></span></p>
			<p class="calibre3"><st c="13434">Consider a weighted graph where the nodes are </st><img src="image/1478.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1211"/><st c="13481"/><st c="13482">, </st><img src="image/1648.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;B&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1212"/><st c="13484"/><st c="13485">, </st><img src="image/1649.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;C&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1213"/><st c="13487"/><st c="13488">, and </st><img src="image/1650.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1214"/><st c="13494"/><st c="13495">, and there are edges </st><img src="image/1651.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1215"/><st c="13517"/><st c="13518">, </st><img src="image/1652.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1216"/><st c="13520"/><st c="13521">, </st><img src="image/1653.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1217"/><st c="13523"/><st c="13524">, and </st><img src="image/1654.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1218"/><st c="13530"/><st c="13531">. The longest path from </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1219"/><st c="13555"/><st c="13556"> to </st><img src="image/1656.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1220"/><st c="13560"/><st c="13561"> could initially seem like it might go through B and C. </st><st c="13617">However, if the direct edge </st><img src="image/1657.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1221"/><st c="13645"/><st c="13646"> is longer than the sum of the paths </st><img src="image/1658.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1222"/><st c="13683"/><st c="13684">, then the optimal solution doesn’t involve the longest paths from </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre797"/><st c="13751"/><st c="13752"> to </st><img src="image/1660.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;B&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1223"/><st c="13756"/><st c="13757">, </st><img src="image/1660.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;B&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1223"/><st c="13759"/><st c="13760"> to </st><img src="image/106.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;C&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre114"/><st c="13764"/><st c="13765"> and </st><img src="image/106.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;C&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre114"/><st c="13770"/> <span><st c="13771">to </st></span><span><img src="image/1664.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1224"/><st c="13774"/></span><span><st c="13775">.</st></span></p>
			<p class="calibre3"><st c="13776">Obviously, the graph</st><a id="_idIndexMarker618" class="pcalibre pcalibre1 calibre6"/><st c="13797"> is directed and weighted. </st><st c="13824">If the graph were undirected and unweighted, this scenario would be infeasible because it would violate the triangular inequality, which states that the direct distance between two points should be less than or equal to the sum of the distances through an intermediate point. </st><st c="14100">However, even in a directed, unweighted graph like this, the result can </st><span><st c="14172">be counterintuitive.</st></span></p>
			<p class="calibre3"><st c="14192">Let’s assume that the nodes </st><img src="image/1033.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;A&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1225"/><st c="14221"/><st c="14222">, </st><img src="image/1660.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;B&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1226"/><st c="14224"/><st c="14225">, </st><img src="image/106.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;C&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1227"/><st c="14227"/><st c="14228">, and </st><img src="image/1668.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1228"/><st c="14234"/><st c="14235">represent four cities: Toronto, Chicago, Denver, and Los Angeles, respectively. </st><st c="14315">The edges represent the ticket prices of direct flights. </st><st c="14372">For example, </st><img src="image/1669.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1229"/><st c="14385"/><st c="14386"> represents the ticket price of a direct flight from Toronto </st><span><st c="14447">to Chicago.</st></span></p>
			<p class="calibre3"><st c="14458">As depicted in </st><span><em class="italic"><st c="14474">Figure 10</st></em></span><em class="italic"><st c="14483">.2</st></em><st c="14485">, the longest path from Toronto to Los Angeles is achieved through a direct flight (represented by the edge </st><img src="image/1670.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1230"/><st c="14593"/><st c="14614"> with a weight of </st><img src="image/1671.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;$&lt;/mml:mi&gt;&lt;mml:mn&gt;957&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1231"/><st c="14631"/><st c="14632">) and does not include any stops in Chicago or Denver. </st><st c="14687">This outcome might seem counterintuitive, as one might expect a longer path to involve more stops, but in this scenario, the direct flight is the most expensive and therefore forms the longest path in terms </st><span><st c="14894">of cost.</st></span></p>
			<p class="calibre3"><st c="14902">It’s also worth mentioning that in the absence of cycles in the graph, as in our simple example, one straightforward algorithm to solve the longest path problem is to negate all weights and then solve it as the shortest path problem. </st><st c="15137">This transformation works because finding the shortest path in a graph with negated weights is equivalent to finding the longest path in the </st><span><st c="15278">original graph.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1703" class="img---figure">
					<img src="image/B22248_10_3.jpg" alt="Figure 10.2: An example of the longest path problem" class="calibre144"/><st c="15293"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="15314">Figure 10.2: An example of the longest path problem</st></p>
			<p class="calibre3"><st c="15365">The lack of optimal substructure in the longest path problem means that dynamic programming and</st><a id="_idIndexMarker619" class="pcalibre pcalibre1 calibre6"/><st c="15461"> similar techniques that rely on breaking a problem down into subproblems do not work effectively. </st><st c="15560">This is because the longest path problem requires global knowledge of the graph’s structure and cannot simply be built up from smaller, independently solved subproblems. </st><st c="15730">As a result, the longest path problem is typically more challenging to solve, especially in graphs that contain cycles and is not suited to approaches such as dynamic programming that rely on an </st><span><st c="15925">optimal substructure.</st></span></p>
			<h2 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor153" class="pcalibre pcalibre1 calibre6"/><st c="15946">Overlapping subproblems</st></h2>
			<p class="calibre3"><st c="15970">The second </st><a id="_idIndexMarker620" class="pcalibre pcalibre1 calibre6"/><st c="15982">element of dynamic programming that distinguishes it from divide-and-conquer algorithms is the concept of overlapping subproblems. </st><st c="16113">In a well-designed divide-and-conquer strategy, each recursive step typically solves a new, distinct subproblem. </st><st c="16226">A good example of this is merge sort, where, during each partitioning step, the partitions do not overlap, and each subproblem is independent of </st><span><st c="16371">the others.</st></span></p>
			<p class="calibre3"><st c="16382">However, there are problems where certain subproblems overlap, meaning the same subproblems are solved multiple times in the recursive process. </st><st c="16527">This is where dynamic programming excels by avoiding redundant computations. </st><st c="16604">To illustrate this, let’s consider the Fibonacci series as </st><span><st c="16663">an example.</st></span></p>
			<p class="calibre3"><st c="16674">The Fibonacci series is defined </st><span><st c="16707">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1672.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1232"/><st c="16718"/></p>
			<p class="calibre3"><img src="image/1673.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1233"/><st c="16720"/></p>
			<p class="calibre3"><img src="image/1674.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1234"/><st c="16721"/></p>
			<p class="calibre3"><st c="16753">When calculating Fibonacci numbers using a divide-and-conquer approach, the same subproblems are solved repeatedly. </st><st c="16869">For instance, to compute </st><img src="image/1675.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;5&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1235"/><st c="16894"/><st c="16895">, the algorithm would need to calculate </st><img src="image/1676.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1235"/><st c="16935"/><st c="16936"> and </st><img src="image/1677.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1236"/><st c="16941"/><st c="16942">. But to compute </st><img src="image/1678.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1237"/><st c="16959"/><st c="16960">, the algorithm again computes </st><img src="image/1677.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1238"/><st c="16991"/><st c="16992"> and </st><img src="image/1680.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1239"/><st c="16997"/><st c="16998">, meaning </st><img src="image/1681.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1240"/><st c="17008"/><st c="17009"> is calculated multiple times. </st><st c="17040">One way to avoid this redundancy is to store the results of previously computed subproblems in data structures with near-constant access time, such as a </st><span><st c="17193">hash table.</st></span></p>
			<p class="calibre3"><st c="17204">This redundancy leads to an exponential time complexity, as the number of recursive calls grows exponentially with </st><img src="image/1054.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre815"/><st c="17320"/><st c="17321">. This is where dynamic programming provides a significant advantage. </st><st c="17391">Instead of solving the same subproblems repeatedly, dynamic programming stores the results of these subproblems and reuses them when needed, drastically reducing the number </st><span><st c="17564">of computations.</st></span></p>
			<p class="calibre3"><st c="17580">By leveraging overlapping subproblems, dynamic programming transforms the recursive solution for the Fibonacci series from an exponential time complexity </st><img src="image/1683.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1241"/><st c="17735"/><st c="17736"> to a linear time complexity </st><img src="image/1684.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre811"/><st c="17765"/><st c="17766">. This efficiency gain is why dynamic programming is preferred over divide-and-conquer approaches in problems where overlapping subproblems exist. </st><st c="17913">In the next section, we will explore dynamic programming in more detail by examining </st><span><st c="17998">several examples.</st></span></p>
			<h1 id="_idParaDest-132" class="calibre5"><a id="_idTextAnchor154" class="pcalibre pcalibre1 calibre6"/><st c="18015">Exploring dynamic programming</st></h1>
			<p class="calibre3"><st c="18045">One question </st><a id="_idIndexMarker621" class="pcalibre pcalibre1 calibre6"/><st c="18059">that arises when we identify overlapping subproblems is: how can we store these solutions to avoid redundant computations? </st><st c="18182">This is where dynamic programming introduces the concept of </st><strong class="bold"><st c="18242">memoization</st></strong><st c="18253">. It </st><a id="_idIndexMarker622" class="pcalibre pcalibre1 calibre6"/><st c="18258">involves storing the results of subproblems in a data structure, such as an array or a dictionary, so that when the same subproblem arises again, the stored result can be used immediately, eliminating the need </st><span><st c="18468">for recalculation.</st></span></p>
			<p class="calibre3"><st c="18486">Before we begin, it’s important to clarify that “memoization” is not a misspelling of “memorization.” These two terms have distinct meanings. </st><st c="18629">Memoization comes from the Latin word “memo,” which means “to be remembered.” It refers to a technique in computer science where the results of expensive function calls are stored and reused to avoid redundant calculations. </st><st c="18853">In contrast, memorization refers to the process of learning and committing information to memory, often </st><span><st c="18957">through repetition.</st></span></p>
			<p class="calibre3"><st c="18976">Memoization is a technique used in dynamic programming to optimize recursive algorithms by storing the results of expensive function calls and reusing them when the same inputs occur again. </st><st c="19167">Instead of recomputing the same result multiple times, memoization saves the result of each subproblem the first time it is solved and then returns the stored result whenever the same subproblem is encountered again. </st><st c="19384">This significantly reduces the time complexity of algorithms that have </st><span><st c="19455">overlapping subproblems.</st></span></p>
			<p class="calibre3"><st c="19479">Let’s explore how memoization works. </st><st c="19517">In a typical recursive algorithm, a function repeatedly calls itself with smaller inputs until it reaches a base case. </st><st c="19636">Without memoization, the function might be called with the same inputs multiple times, resulting in redundant calculations. </st><st c="19760">This inefficiency is common in straightforward recursive algorithms that use divide-and-conquer strategies. </st><st c="19868">By storing the results of these repeated subproblems, memoization eliminates the need for these redundant calculations, making the algorithm </st><span><st c="20009">more efficient.</st></span></p>
			<p class="calibre3"><st c="20024">With memoization, when a function is called, the algorithm first checks whether the result for the given input is already stored. </st><st c="20155">If it is, the stored result is returned immediately, avoiding redundant computation. </st><st c="20240">The results of subproblems are stored in a data structure, typically a dictionary or an array, which acts as a lookup table. </st><st c="20365">This table is often referred to as </st><span><st c="20400">a </st></span><span><strong class="bold"><st c="20402">memo</st></strong></span><span><st c="20406">.</st></span></p>
			<p class="calibre3"><span><strong class="bold"><st c="20407">Example 10.3:</st></strong></span></p>
			<p class="calibre3"><st c="20421">Let’s revisit the Fibonacci series example to illustrate memoization and compare it to the approach </st><span><st c="20522">without memoization.</st></span></p>
			<p class="calibre3"><st c="20542">The Fibonacci sequence is defined </st><span><st c="20577">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1685.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1242"/><st c="20588"/></p>
			<p class="calibre3"><img src="image/1686.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1242"/><st c="20590"/></p>
			<p class="calibre3"><img src="image/1687.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1243"/><st c="20591"/></p>
			<h3 class="calibre8"><st c="20620">Without memoization</st></h3>
			<p class="calibre3"><st c="20639">The following is </st><a id="_idIndexMarker623" class="pcalibre pcalibre1 calibre6"/><st c="20657">a simple Python implementation of the Fibonacci sequence using a naive </st><span><st c="20728">recursive approach:</st></span></p>
			<pre class="source-code"><st c="20747" class="calibre11">
def fib(n):
    if n &lt;= 1:
        return n
    return fib(n-1) + fib(n-2)
n = 10
print(f"Fibonacci number F({n}) is: {fib(n)}")</st></pre>			<p class="calibre3"><st c="20860">This approach has an exponential time complexity </st><img src="image/1688.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1244"/><st c="20910"/><st c="20911"> because it recalculates the same Fibonacci numbers </st><span><st c="20963">multiple times.</st></span></p>
			<p class="calibre3"><st c="20978">First, let’s analyze the complexity of the recursive Fibonacci series algorithm. </st><st c="21060">This algorithm divides the problem into two subproblems, where the sizes of the subproblems are reduced by one and two, respectively. </st><st c="21194">The recursive part has two components, while the driving function, which computes the sum of the two previous Fibonacci numbers, operates in constant </st><span><st c="21344">time (</st></span><span><img src="image/1689.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1245"/><st c="21350"/></span><span><st c="21366">).</st></span></p>
			<p class="calibre3"><st c="21368">The recurrence function for this algorithm can be expressed </st><span><st c="21429">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1690.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1246"/><st c="21440"/></p>
			<p class="calibre3"><st c="21478">This recurrence does not fit neatly into the standard forms for divide-and-conquer or subtracting recurrence functions. </st><st c="21598">Therefore, we simplify it </st><span><st c="21624">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1691.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;mml:mo&gt;≈&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1247"/><st c="21635"/></p>
			<p class="calibre3"><st c="21637">With this </st><a id="_idIndexMarker624" class="pcalibre pcalibre1 calibre6"/><st c="21647">simplification, the recurrence function resembles a form that can be analyzed using the Master Theorem for subtracting recurrences (see </st><a href="B22248_05_split_000.xhtml#_idTextAnchor062" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="21783">Chapter 5</st></em></span></a><st c="21792">). </st><st c="21796">According to the Master Theorem, since </st><img src="image/1692.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1248"/><st c="21835"/><st c="21836">2 and </st><img src="image/1693.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre646"/><st c="21842"/><st c="21845">, the time complexity of the recursive Fibonacci sequence algorithm </st><span><st c="21913">is this:</st></span></p>
			<p class="calibre3"><img src="image/1694.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;/&lt;/mml:mo&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;mml:mo&gt;⋅&lt;/mml:mo&gt;&lt;mml:mi&gt;f&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1249"/><st c="21921"/></p>
			<p class="calibre3"><st c="21950">This result shows that the recursive Fibonacci algorithm has exponential time complexity, specifically </st><img src="image/1695.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;Θ&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1250"/><st c="22053"/><st c="22054">, making it inefficient for large values of </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre465"/><st c="22098"/><st c="22099">. This inefficiency is why memoization or dynamic programming is often used to optimize the computation of </st><span><st c="22206">Fibonacci numbers.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1729" class="img---figure">
					<img src="image/B22248_10_4.jpg" alt="Figure 10.3: The tree demonstrating the non-memoized approach to calculating Fibonacci(5)" class="calibre144"/><st c="22224"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="22478">Figure 10.3: The tree demonstrating the non-memoized approach to calculating Fibonacci(5)</st></p>
			<p class="calibre3"><span><em class="italic"><st c="22567">Figure 10</st></em></span><em class="italic"><st c="22577">.3</st></em><st c="22579"> illustrates an example of the tree representing a divide-and-conquer (non-memoized) implementation to calculate Fibonacci(5). </st><st c="22706">As shown, the leaf nodes repeatedly consist of Fibonacci(1) and Fibonacci(0). </st><st c="22784">Additionally, many Fibonacci numbers are recalculated multiple times throughout </st><span><st c="22864">the process.</st></span></p>
			<h3 class="calibre8"><st c="22876">With memoization</st></h3>
			<p class="calibre3"><st c="22893">By applying memoization, the algorithm avoids redundant calculations. </st><st c="22964">Here is a simple Python</st><a id="_idIndexMarker625" class="pcalibre pcalibre1 calibre6"/><st c="22987"> implementation of the Fibonacci sequence using dynamic programming, which uses memoization to optimize </st><span><st c="23091">the calculation:</st></span></p>
			<pre class="source-code"><st c="23107" class="calibre11">
def dp_fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n &lt;= 1:
        return n
    memo[n] = dp_fib(n-1, memo) + dp_fib(n-2, memo)
    return memo[n]
n = 10
print(f"Fibonacci number F({n}) is: {dp_fib(n)}")</st></pre>			<p class="calibre3"><st c="23300">In this version, the time complexity is reduced to </st><img src="image/1697.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1251"/><st c="23352"/><st c="23353">, because each Fibonacci number is computed only once and then stored for </st><span><st c="23427">future reference.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1731" class="img---figure">
					<img src="image/B22248_10_5.jpg" alt="Figure 10.4: The graph demonstrating the memoized approach to calculating Fibonacci(8)" class="calibre144"/><st c="23444"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="23446">Figure 10.4: The graph demonstrating the memoized approach to calculating Fibonacci(8)</st></p>
			<p class="calibre3"><span><em class="italic"><st c="23532">Figure 10</st></em></span><em class="italic"><st c="23542">.4</st></em><st c="23544"> illustrates the graph representing the dynamic programming approach (using memoization) to calculate Fibonacci(8). </st><st c="23660">In this approach, no Fibonacci number is redundantly recalculated. </st><st c="23727">Instead, previously solved subproblems are reused, which is reflected in the edges extending from nodes. </st><st c="23832">This reuse of subproblems is why we visualize divide-and-conquer algorithms with trees (</st><span><em class="italic"><st c="23920">Figure 10</st></em></span><em class="italic"><st c="23930">.3</st></em><st c="23932">), while dynamic programming is better represented with graphs (</st><span><em class="italic"><st c="23997">Figure 10</st></em></span><span><em class="italic"><st c="24007">.4</st></em></span><span><st c="24009">).</st></span></p>
			<p class="calibre3"><st c="24012">Memoization is crucial in dynamic programming, especially for problems with overlapping subproblems. </st><st c="24114">By storing the results of these subproblems, memoization minimizes the number of calculations required to solve the overall problem, leading to significant improvements in time complexity. </st><st c="24303">However, this benefit comes at the cost of additional</st><a id="_idIndexMarker626" class="pcalibre pcalibre1 calibre6"/><st c="24356"> space for storing these results. </st><st c="24390">This tradeoff is usually favorable in scenarios where time efficiency is more critical. </st><st c="24478">It’s important to note that memoization is typically employed in a top-down dynamic programming approach, where the problem is solved recursively, and results are stored as they are computed. </st><st c="24670">In the upcoming subsection, we briefly discuss top-down and bottom-up </st><span><st c="24740">dynamic programming.</st></span></p>
			<h2 id="_idParaDest-133" class="calibre5"><a id="_idTextAnchor155" class="pcalibre pcalibre1 calibre6"/><st c="24760">Top-down versus bottom-up approaches for dynamic programming</st></h2>
			<p class="calibre3"><st c="24821">There are</st><a id="_idIndexMarker627" class="pcalibre pcalibre1 calibre6"/><st c="24831"> two main approaches to implementing dynamic programming: top-down and bottom-up. </st><st c="24913">Both approaches aim to reduce computational complexity by avoiding redundant calculations, but they do so in </st><span><st c="25022">different ways.</st></span></p>
			<p class="calibre3"><st c="25037">Top-down dynamic programming, also known as memoization, is a recursive approach. </st><st c="25120">It starts solving the problem from the top, breaking it down into smaller subproblems. </st><st c="25207">As the algorithm solves these subproblems, it stores its results in a data structure (usually a dictionary or an array) so that if the same subproblem needs to be solved again, the stored result can be used directly instead of </st><span><st c="25434">recalculating it.</st></span></p>
			<p class="calibre3"><st c="25451">The top-down process begins with the original problem and recursively breaks it down into smaller subproblems. </st><st c="25563">Each time a subproblem is solved, its result is stored (memoized). </st><st c="25630">If a subproblem is encountered again, the algorithm retrieves the stored result instead of </st><span><st c="25721">recomputing it.</st></span></p>
			<p class="calibre3"><st c="25736">The top-down approach is relatively straightforward to implement, particularly when adapting from a divide-and-conquer recursive solution. </st><st c="25876">In top-down dynamic programming, only the subproblems essential to solving the original problem are addressed, which can be advantageous if certain subproblems aren’t needed. </st><st c="26051">However, this approach does have its drawbacks. </st><st c="26099">It may require more memory due to the need to store recursive function calls on the call stack. </st><st c="26195">Additionally, deep recursion can result in a stack overflow when dealing with very large problems. </st><em class="italic"><st c="26294">Example 10.3</st></em><st c="26306"> illustrates the memoized version of the Fibonacci sequence calculation, serving as a classic example of top-down </st><span><st c="26420">dynamic programming.</st></span></p>
			<p class="calibre3"><st c="26440">The alternative to the top-down approach is the bottom-up implementation of dynamic programming. </st><st c="26538">Bottom-up dynamic programming, also known as tabulation, is an iterative method. </st><st c="26619">It begins by solving the smallest subproblems first and then uses those solutions to build up to the solution of the original problem. </st><st c="26754">In this approach, a table (usually an array) is created, with each entry representing the solution to a subproblem. </st><st c="26870">The process starts by addressing the base cases and solving the smallest subproblems first. </st><st c="26962">The solutions are stored in the table and then iteratively used to tackle larger subproblems, ultimately leading to the </st><span><st c="27082">final solution.</st></span></p>
			<p class="calibre3"><st c="27097">The</st><a id="_idIndexMarker628" class="pcalibre pcalibre1 calibre6"/><st c="27101"> bottom-up approach is generally more space-efficient than the top-down method because it avoids the overhead associated with recursive function calls. </st><st c="27253">Additionally, it eliminates the risk of stack overflow by using an iterative process instead of recursion. </st><st c="27360">This approach often provides a clearer view of how the solution is constructed, making it easier to manage and understand. </st><st c="27483">However, the bottom-up approach has two significant drawbacks. </st><st c="27546">First, it requires solving all subproblems, even those that may not be necessary for the final solution. </st><st c="27651">Additionally, it can be more complex to implement initially, particularly when transitioning from a </st><span><st c="27751">recursive approach.</st></span></p>
			<p class="calibre3"><st c="27770">The following is a Python implementation of bottom-up approach to the </st><span><st c="27841">Fibonacci sequence:</st></span></p>
			<pre class="source-code"><st c="27860" class="calibre11">
def bottom_up_fib(n):
    if n &lt;= 1:
        return n
    fib = [0] * (n+1)
    fib[1] = 1
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    return fib[n]
n = 10
print(f"Fibonacci number F({n}) is: {bottom_up_fib(n)}")</st></pre>			<p class="calibre3"><em class="italic"><st c="28062">Table 10.1</st></em><st c="28073"> provides a summary of the characteristics of both the top-down and bottom-up approaches in </st><span><st c="28165">dynamic programming.</st></span></p>
			<table id="table001-5" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="28185">Feature</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="28193">Top-down (memoization)</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="28216">Bottom-up (tabulation)</st></strong></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="28239">Approach</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28248">Recursive, solves the problem from the top (main problem) and breaks it down </st><span><st c="28326">into subproblems.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28343">Iterative, solves the problem from the bottom (base cases) and builds up to the </st><span><st c="28424">main problem.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="28437">Space complexity</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28454">May use more memory due to the call stack, and </st><span><st c="28502">memoization storage.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28522">Typically uses less memory, as it mainly relies on a table </st><span><st c="28582">or array.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="28591">Time complexity</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28607">Avoids re-computation by storing results of subproblems, </st><span><st c="28665">generally </st></span><span><img src="image/1698.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1252"/><st c="28675"/></span><span><st c="28676">.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28677">Also avoids re-computation, </st><span><st c="28706">generally </st></span><span><img src="image/450.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre364"/><st c="28716"/></span><span><st c="28717">.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="28718">Ease </st><span><st c="28724">of implementation</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28741">Easier to implement if transitioning from a naive </st><span><st c="28792">recursive solution.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28811">It might be harder to implement initially, especially if converting from a </st><span><st c="28887">recursive approach.</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="28906">Risk of </st><span><st c="28915">stack overflow</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28929">Higher risk due to </st><span><st c="28949">deep recursion.</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="28964">No risk, as it avoids </st><span><st c="28987">recursion altogether.</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="29008">Table 10.1: A comparison of top-down and bottom-up approaches</st></p>
			<p class="calibre3"><st c="29070">Both top-down </st><a id="_idIndexMarker629" class="pcalibre pcalibre1 calibre6"/><st c="29085">and bottom-up approaches to dynamic programming achieve the same goal: optimizing the computation by avoiding redundant calculations. </st><st c="29219">The choice between the two often depends on the specific problem, the programmer’s comfort with recursion or iteration, and the memory and performance constraints of the task at hand. </st><em class="italic"><st c="29403">Table 10.1</st></em><st c="29413"> presents a comparison of the top-down and bottom-up approaches in </st><span><st c="29480">dynamic programming.</st></span></p>
			<p class="calibre3"><st c="29500">Let’s take a moment to discuss how to calculate the time complexity of dynamic programming implementations. </st><st c="29609">As we’ve noted, dynamic programming algorithms are better represented by directed graphs rather than trees. </st><st c="29717">In </st><a href="B22248_05_split_000.xhtml#_idTextAnchor062" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="29720">Chapter 5</st></em></span></a><st c="29729">, we explored the use of recursion trees to estimate the time complexity of recursive algorithms. </st><st c="29827">Here, instead of using trees, we’ll utilize a graph to visualize a dynamic </st><span><st c="29902">programming algorithm.</st></span></p>
			<p class="calibre3"><st c="29924">In a dynamic programming graph, nodes represent subproblems, and the edges emerging from these nodes represent the choices we encounter within each subproblem. </st><st c="30085">We can interpret this from the perspective of the destination of the edges, given that the </st><a id="_idIndexMarker630" class="pcalibre pcalibre1 calibre6"/><st c="30176">graph is directed. </st><st c="30195">Each incoming edge to a node signifies a function call—this means the subproblem is being recalled rather than recalculated, as would happen in a typical </st><span><st c="30349">divide-and-conquer approach.</st></span></p>
			<p class="calibre3"><st c="30377">Now, let’s assume there are </st><img src="image/646.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre511"/><st c="30406"/><st c="30407"> subproblems (or functions) in total, and each subproblem is recalled </st><img src="image/1701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;r&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1253"/><st c="30477"/><st c="30478"> times, where </st><img src="image/1702.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1254"/><st c="30492"/><st c="30493">. The time complexity of this dynamic programming algorithm can be expressed </st><span><st c="30570">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1703.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:munderover&gt;&lt;mml:mo stretchy=&quot;false&quot;&gt;∑&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:munderover&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⋅&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;r&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;≤&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;≤&lt;/mml:mo&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1255"/><st c="30581"/></p>
			<p class="calibre3"><st c="30592">This approach typically results in a linear time complexity, particularly in cases where the number of subproblems </st><img src="image/1358.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;m&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1256"/><st c="30707"/><st c="30708"> is proportional to the size of the input </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1257"/><st c="30750"/><st c="30751">. In the worst-case scenario, where </st><img src="image/1706.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1258"/><st c="30787"/><st c="30788">, each subproblem corresponds directly to a unique state of the input, and the algorithm must process each state </st><span><st c="30901">exactly once.</st></span></p>
			<p class="calibre3"><st c="30914">When this occurs, the dynamic programming algorithm efficiently computes the solution in </st><img src="image/1011.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1259"/><st c="31004"/><st c="31005"> time. </st><st c="31012">This is because the algorithm leverages the overlapping subproblems by storing their results and reusing them as needed, rather than recalculating them. </st><st c="31165">As a result, the total number of operations is linearly related to the size of the input, avoiding the exponential time complexity that would occur if each subproblem were recomputed multiple times, as in naive </st><span><st c="31376">recursive approaches.</st></span></p>
			<p class="calibre3"><st c="31397">This linear time complexity is one of the key advantages of dynamic programming. </st><st c="31479">It allows the algorithm to scale effectively with the size of the input, making it practical for solving large and complex problems that would otherwise be computationally infeasible using brute-force or </st><span><st c="31683">divide-and-conquer strategies.</st></span></p>
			<p class="calibre3"><st c="31713">Let’s apply the approach discussed earlier to analyze the time complexity of the dynamic programming implementation of the Fibonacci sequence, as shown in </st><em class="italic"><st c="31869">Example 10.3</st></em><st c="31881">. By considering </st><span><em class="italic"><st c="31898">Figure 10</st></em></span><em class="italic"><st c="31907">.4</st></em><st c="31909">, which illustrates the graph representing the problem of calculating the Fibonacci of number 8 (</st><img src="image/1708.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;8&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1235"/><st c="32006"/><st c="32008">), we can derive the </st><span><st c="32029">time complexity.</st></span></p>
			<p class="calibre3"><st c="32045">In the graph, each node corresponds to a subproblem—specifically, one of the Fibonacci numbers that needs to be computed. </st><st c="32168">The graph for </st><img src="image/1709.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;8&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1260"/><st c="32182"/><st c="32183"> includes 8 nodes, each representing an overlapping subproblem. </st><st c="32247">Additionally, each node in this graph has two choices: one corresponding to the function call for the previous Fibonacci number </st><img src="image/1710.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1261"/><st c="32375"/><st c="32376"> and the other for the Fibonacci number before that </st><img src="image/1711.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1262"/><st c="32428"/><st c="32429">. These choices are depicted as outgoing edges from each node, or equivalently, two incoming edges to each node in </st><span><st c="32544">the graph.</st></span></p>
			<p class="calibre3"><st c="32554">To calculate the </st><a id="_idIndexMarker631" class="pcalibre pcalibre1 calibre6"/><st c="32572">time complexity, we observe that the graph structure results in every node (or subproblem) being processed once, with each node involving two operations: one for each of the outgoing edges. </st><st c="32762">This results in a total of </st><img src="image/1712.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1263"/><st c="32789"/><st c="32790"> operations </st><span><st c="32802">for </st></span><span><img src="image/1708.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;8&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1235"/><st c="32806"/></span><span><st c="32807">.</st></span></p>
			<p class="calibre3"><st c="32808">Generalizing this to </st><img src="image/1714.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;F&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1264"/><st c="32830"/><st c="32831">, we observe that for any Fibonacci number </st><img src="image/1715.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre723"/><st c="32874"/><st c="32875">, the total number of operations can be expressed </st><span><st c="32925">as follows:</st></span></p>
			<p class="calibre3"><img src="image/1716.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;T&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;×&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1265"/><st c="32936"/></p>
			<p class="calibre3"><st c="32938">This formula shows that the dynamic programming approach to computing Fibonacci numbers of scales linearly with the input size </st><img src="image/98.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre108"/><st c="33065"/><st c="33066">. The efficiency is achieved because dynamic programming avoids redundant calculations by storing and reusing the results of subproblems (memoization), leading to a significant reduction in time complexity compared to the naive recursive approach, which has an exponential </st><span><st c="33339">time complexity.</st></span></p>
			<p class="calibre3"><st c="33355">Let’s look at another classic example in the context of dynamic programming, which is the </st><span><strong class="bold"><st c="33446">knapsack problem</st></strong></span><span><st c="33462">.</st></span></p>
			<h2 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor156" class="pcalibre pcalibre1 calibre6"/><st c="33463">Solving the 0/1 knapsack problem using dynamic programming</st></h2>
			<p class="calibre3"><st c="33522">The </st><a id="_idIndexMarker632" class="pcalibre pcalibre1 calibre6"/><st c="33527">knapsack problem is a classic </st><a id="_idIndexMarker633" class="pcalibre pcalibre1 calibre6"/><st c="33557">optimization problem where the goal is to determine the maximum value that can be obtained</st><a id="_idIndexMarker634" class="pcalibre pcalibre1 calibre6"/><st c="33647"> by selecting items to include in a knapsack, subject to a weight capacity constraint. </st><st c="33734">Each item has a specific weight and value, and the challenge is to choose the optimal combination of items to maximize the total value without exceeding the knapsack’s weight limit. </st><st c="33916">Let’s assume we have a set of </st><img src="image/823.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre651"/><st c="33946"/><st c="33947"> items, each with a weight </st><img src="image/1719.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1266"/><st c="33974"/><st c="33975"> and a value </st><img src="image/1720.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1267"/><st c="33988"/><st c="33989"> and a knapsack with a maximum weight capacity </st><img src="image/1721.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1268"/><st c="34036"/><st c="34037">. The objective is to maximize the total value </st><img src="image/1722.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1269"/><st c="34084"/><st c="34085"> of the items in the knapsack such that the </st><span><st c="34129">following holds:</st></span></p>
			<p class="calibre3"><img src="image/1723.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;V&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;normal&quot;&gt;max&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:munderover&gt;&lt;mml:mo stretchy=&quot;false&quot;&gt;∑&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:munderover&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;×&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1270"/><st c="34145"/></p>
			<p class="calibre3"><span><st c="34147">subject to:</st></span></p>
			<p class="calibre3"><img src="image/1724.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mrow&gt;&lt;mml:munderover&gt;&lt;mml:mo stretchy=&quot;false&quot;&gt;∑&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:munderover&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;×&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;≤&lt;/mml:mo&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1271"/><st c="34158"/></p>
			<p class="calibre3"><st c="34160">Depending</st><a id="_idIndexMarker635" class="pcalibre pcalibre1 calibre6"/><st c="34169"> on how we define </st><img src="image/1725.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1272"/><st c="34187"/><st c="34188">, we encounter the following types of </st><span><st c="34226">knapsack problem:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="34243">If </st><img src="image/1726.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;∈&lt;/mml:mo&gt;&lt;mml:mo&gt;{&lt;/mml:mo&gt;&lt;mml:mn&gt;0,1&lt;/mml:mn&gt;&lt;mml:mo&gt;}&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1273"/><st c="34247"/><st c="34258">, the problem is known as the 0/1 knapsack problem. </st><st c="34310">This is the problem we will focus on solving in </st><span><st c="34358">this chapter.</st></span></li>
				<li class="calibre13"><st c="34371">If </st><img src="image/1727.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;∈&lt;/mml:mo&gt;&lt;mml:mo&gt;{&lt;/mml:mo&gt;&lt;mml:mn&gt;0,1&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mo&gt;…&lt;/mml:mo&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;mml:mo&gt;}&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1274"/><st c="34375"/><st c="34394">, where </st><img src="image/1728.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;c&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1275"/><st c="34402"/><st c="34403"> is a constant, the</st><a id="_idIndexMarker636" class="pcalibre pcalibre1 calibre6"/><st c="34422"> problem is referred to as the </st><strong class="bold"><st c="34453">Bounded Knapsack </st></strong><span><strong class="bold"><st c="34470">Problem</st></strong></span><span><st c="34477"> (</st></span><span><strong class="bold"><st c="34479">BKP</st></strong></span><span><st c="34482">).</st></span></li>
				<li class="calibre13"><st c="34485">If </st><img src="image/1729.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;x&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1276"/><st c="34489"/><st c="34490"> can be any non-negative integer, the </st><a id="_idIndexMarker637" class="pcalibre pcalibre1 calibre6"/><st c="34528">problem is called the </st><strong class="bold"><st c="34550">Unbounded Knapsack </st></strong><span><strong class="bold"><st c="34569">Problem</st></strong></span><span><st c="34576"> (</st></span><span><strong class="bold"><st c="34578">UKP</st></strong></span><span><st c="34581">).</st></span></li>
			</ul>
			<p class="calibre3"><st c="34584">First, let’s</st><a id="_idIndexMarker638" class="pcalibre pcalibre1 calibre6"/><st c="34597"> examine the complexity of the 0/1 knapsack problem using a naïve approach. </st><st c="34673">Given </st><img src="image/1730.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre356"/><st c="34679"/><st c="34680"> items, a straightforward solution would involve generating all possible subsets of these </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="34770"/><st c="34819"> items, calculating the corresponding weight and value for each subset, and then identifying the optimal solution. </st><st c="34933">This approach results in a time complexity of </st><img src="image/1732.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1277"/><st c="34979"/><st c="34980">, making the problem non-polynomial and computationally infeasible for large values </st><span><st c="35064">of </st></span><span><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="35067"/></span><span><st c="35116">.</st></span></p>
			<p class="calibre3"><st c="35117">The goal is to solve the 0/1 knapsack problem using a dynamic programming approach. </st><st c="35202">The knapsack problem exhibits both optimal substructure and overlapping subproblems, making it an ideal candidate for a dynamic </st><span><st c="35330">programming solution.</st></span></p>
			<p class="calibre3"><st c="35351">Optimal substructure means that the optimal solution to a problem can consider a knapsack problem with </st><img src="image/322.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre277"/><st c="35455"/><st c="35456"> items and capacity </st><img src="image/1735.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1278"/><st c="35476"/><st c="35477">. Let’s assume we have an optimal solution for this problem. </st><st c="35538">If we remove the last item from this optimal solution, the remaining items must form an optimal solution for a knapsack problem with </st><img src="image/485.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre362"/><st c="35671"/><st c="35672"> items and capacity </st><img src="image/1721.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1279"/><st c="35692"/><st c="35693"> minus the weight of the </st><span><st c="35718">removed item.</st></span></p>
			<p class="calibre3"><st c="35731">In other words, the optimal solution to the larger problem (</st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1280"/><st c="35792"/><st c="35842"> items, capacity </st><img src="image/1721.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1281"/><st c="35858"/><st c="35859">) is composed of an optimal solution to a smaller subproblem (</st><img src="image/1740.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1282"/><st c="35921"/><st c="35923"> items, reduced capacity) plus the decision of whether to include the </st><img src="image/1741.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre1283"/><st c="35993"/><st c="35996"> item or not. </st><st c="36009">This property allows us to break down the problem into smaller subproblems and solve them recursively, which is the foundation of the dynamic </st><span><st c="36151">programming approach.</st></span></p>
			<p class="calibre3"><st c="36172">For example, if we </st><a id="_idIndexMarker639" class="pcalibre pcalibre1 calibre6"/><st c="36192">have an optimal solution for a knapsack problem with 5 items and a capacity of 12, and we remove the fifth item, the remaining 4 items must form an optimal solution for a knapsack problem with 4 items and a capacity reduced by the weight of the </st><span><st c="36437">fifth item.</st></span></p>
			<p class="calibre3"><st c="36448">Overlapping </st><a id="_idIndexMarker640" class="pcalibre pcalibre1 calibre6"/><st c="36461">subproblems in this problem refer to the situation where the same subproblems are solved multiple times during the process of finding the optimal solution. </st><st c="36617">When solving the 0/1 knapsack problem using a recursive approach, we often find that the same subproblems are revisited. </st><st c="36738">Specifically, when deciding whether to include or exclude an item from the knapsack, we are essentially solving the same problem but with reduced capacity or </st><span><st c="36896">fewer items.</st></span></p>
			<p class="calibre3"><st c="36908">Consider a simple example with three items, and a knapsack capacity </st><img src="image/1742.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1284"/><st c="36977"/><st c="36978">. Each item has a weight </st><img src="image/1743.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;_&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1285"/><st c="37003"/><st c="37004"> and a </st><span><st c="37011">value </st></span><span><img src="image/1744.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;mml:mo&gt;_&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1286"/><st c="37017"/></span><span><st c="37018">:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="37019">Item </st><span><st c="37024">1: </st></span><span><img src="image/1745.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1287"/><st c="37027"/></span></li>
				<li class="calibre13"><st c="37028">Item </st><span><st c="37033">2: </st></span><span><img src="image/1746.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1287"/><st c="37036"/></span></li>
				<li class="calibre13"><st c="37037">Item </st><span><st c="37042">3: </st></span><span><img src="image/1747.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;5&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1288"/><st c="37045"/></span></li>
			</ul>
			<p class="calibre3"><st c="37046">When solving this problem recursively, we might face the </st><span><st c="37103">following subproblems:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="37125">Including Item 1: This leads to solving the subproblem with the remaining capacity </st><img src="image/1748.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1289"/><st c="37209"/><st c="37210"> and the remaining items (Item 2 and </st><span><st c="37247">Item 3)</st></span></li>
				<li class="calibre13"><st c="37254">Excluding Item 1: This leads to solving the subproblem with the full capacity </st><img src="image/1749.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1290"/><st c="37333"/><st c="37334"> and the remaining items (Item 2 and </st><span><st c="37371">Item 3)</st></span></li>
			</ul>
			<p class="calibre3"><st c="37378">However, when we move on to consider Item 2, you will again encounter the </st><span><st c="37453">same subproblems:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="37470">Including Item 2: Solves the problem with a capacity of </st><img src="image/1750.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1291"/><st c="37527"/><st c="37528"> (if Item 1 was included) or </st><img src="image/1751.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1292"/><st c="37557"/><st c="37558"> (if Item 1 was excluded) and the remaining item (</st><span><st c="37608">Item 3)</st></span></li>
				<li class="calibre13"><st c="37616">Excluding Item 2: Solves the problem with the current capacity and just Item </st><span><st c="37694">3 remaining</st></span></li>
			</ul>
			<p class="calibre3"><st c="37705">As we can see, some subproblems (e.g., the subproblem with </st><img src="image/1752.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1293"/><st c="37765"/><st c="37766"> and Item 3) are encountered multiple times. </st><st c="37811">Without dynamic programming, we would solve these subproblems repeatedly, leading to </st><span><st c="37896">unnecessary computations.</st></span></p>
			<p class="calibre3"><st c="37921">Now that we</st><a id="_idIndexMarker641" class="pcalibre pcalibre1 calibre6"/><st c="37933"> have a clear understanding of the two essential elements of dynamic programming in the 0/1 knapsack problem, let’s walk through the </st><span><st c="38066">step-by-step solution:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="38088">Create</st><a id="_idIndexMarker642" class="pcalibre pcalibre1 calibre6"/><st c="38095"> a two-dimensional table </st><img src="image/1172.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1037"/><st c="38120"/><st c="38121"> with </st><img src="image/1754.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1294"/><st c="38127"/><st c="38131"> rows and </st><img src="image/1755.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1295"/><st c="38140"/><st c="38142"> columns, where </st><img src="image/1055.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre816"/><st c="38157"/><st c="38158"> is the number of items and </st><img src="image/1721.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1279"/><st c="38186"/><st c="38187"> is the total capacity of the knapsack. </st><st c="38227">Let </st><img src="image/1758.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1296"/><st c="38231"/><st c="38241"> represent the maximum value that can be obtained using the first </st><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre553"/><st c="38306"/><st c="38307"> items with a knapsack capacity of </st><img src="image/1760.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1297"/><st c="38342"/><st c="38343">. For instance, </st><img src="image/1761.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1298"/><st c="38359"/><st c="38364"> would represent the maximum value achievable with the first 4 items, assuming the knapsack has a maximum capacity of 5, even though the actual capacity might </st><span><st c="38522">be greater.</st></span></li>
				<li class="calibre13"><st c="38533">Initialize the first row </st><img src="image/1762.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1299"/><st c="38559"/><st c="38560"> and first column </st><img src="image/1763.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1300"/><st c="38578"/><st c="38579">, which means </st><img src="image/1764.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1301"/><st c="38593"/><st c="38594"> for all </st><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1302"/><st c="38603"/><st c="38604"> and </st><img src="image/1766.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mn&gt;0&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1303"/><st c="38609"/><st c="38610"> for all </st><img src="image/1760.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1297"/><st c="38619"/><st c="38620">. Let’s assume we have three items with the following weights and values: </st><img src="image/1768.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mo&gt;{&lt;/mml:mo&gt;&lt;mml:mn&gt;1,3&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;mml:mo&gt;}&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1304"/><st c="38694"/><st c="38698"> and </st><img src="image/1769.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mo&gt;{&lt;/mml:mo&gt;&lt;mml:mn&gt;15,20,30&lt;/mml:mn&gt;&lt;mml:mo&gt;}&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1305"/><st c="38702"/><st c="38708"> and the knapsack capacity is 6. </st><st c="38740">(see </st><span><em class="italic"><st c="38745">Table 10.2</st></em></span><span><st c="38755">).</st></span><table id="table002-4" class="t---table"><colgroup class="calibre51"><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/></colgroup><tbody class="calibre54"><tr class="t---table1"><td class="t---table2"/><td class="t---table2" colspan="8"><p class="calibre3"><img src="image/1760.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1297"/><st c="38758"/></p></td></tr><tr class="t---table1"><td class="t---table2" rowspan="5"><p class="calibre3"><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre553"/><st c="38760"/></p></td><td class="t---table2"/><td class="t---table2"><p class="calibre3"><st c="38761">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38762">1</st></p></td><td class="t---table2"><p class="calibre3"><st c="38763">2</st></p></td><td class="t---table2"><p class="calibre3"><st c="38764">3</st></p></td><td class="t---table2"><p class="calibre3"><st c="38765">4</st></p></td><td class="t---table2"><p class="calibre3"><st c="38766">5</st></p></td><td class="t---table2"><p class="calibre3"><st c="38767">6</st></p></td></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="38768">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38769">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38770">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38771">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38772">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38773">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38774">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="38775">0</st></p></td></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="38776">1</st></p></td><td class="t---table2"><p class="calibre3"><st c="38777">0</st></p></td><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="38778">2</st></p></td><td class="t---table2"><p class="calibre3"><st c="38779">0</st></p></td><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="38780">3</st></p></td><td class="t---table2"><p class="calibre3"><st c="38781">0</st></p></td><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/><td class="t---table2"/></tr></tbody></table></li>
			</ol>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="38782">Table 10.2: Initializing table </st><img src="image/1772.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1306"/><st c="38813"/></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="38814">Populate the table by the </st><span><st c="38840">following rules:</st></span><p class="calibre3"><st c="38856">For each item </st><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre553"/><st c="38871"/><st c="38872"> and </st><span><st c="38877">weight </st></span><span><img src="image/1774.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:math&gt;" class="calibre1307"/><st c="38884"/></span><span><st c="38885">:</st></span></p><ul class="calibre50"><li class="calibre13"><st c="38886">If the weight of a new item exceeds the current weight limit, we exclude the new item: </st><img src="image/1775.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1308"/><st c="38973"/><st c="38996">) </st><span><st c="38998">if </st></span><span><img src="image/1776.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;&gt;&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1309"/><st c="39001"/></span><span><st c="39002">.</st></span></li><li class="calibre13"><st c="39003"> Otherwise, we have </st><span><st c="39023">two choices:</st></span><ul class="calibre50"><li class="calibre13"><st c="39035">Include the current </st><span><st c="39056">item: </st></span><span><img src="image/1777.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1310"/><st c="39062"/></span></li><li class="calibre13"><st c="39090">Exclude the current </st><span><st c="39110">item: </st></span><span><img src="image/1778.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1311"/><st c="39116"/></span></li></ul></li></ul><p class="calibre3"><st c="39137">Choose the maximum of these </st><span><st c="39165">two values:</st></span></p><p class="calibre3"><img src="image/1779.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;=&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi mathvariant=&quot;italic&quot;&gt;max&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mo&gt;⁡&lt;/mml:mo&gt;&lt;mml:mrow&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;v&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;d&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;mml:mo&gt;-&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;,&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:mrow&gt;&lt;/mml:mrow&gt;&lt;/mml:math&gt;" class="calibre1312"/><st c="39176"/> <span><st c="39219">if </st></span><span><img src="image/1780.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:msub&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msub&gt;&lt;mml:mo&gt;≤&lt;/mml:mo&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1313"/><st c="39222"/></span></p></li>
				<li class="calibre13"><st c="39225">Generate</st><a id="_idIndexMarker643" class="pcalibre pcalibre1 calibre6"/><st c="39233"> the solution. </st><st c="39248">The</st><a id="_idIndexMarker644" class="pcalibre pcalibre1 calibre6"/><st c="39251"> solution is located at </st><img src="image/1781.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1314"/><st c="39275"/><st c="39276">, which represents the maximum value achievable with the entire set of items and the full knapsack capacity. </st><em class="italic"><st c="39385">Table 10.3</st></em><st c="39395"> shows the completed table, </st><img src="image/1782.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1315"/><st c="39423"/><st c="39424">, with the final solution highlighted in the bottom-right corner. </st><st c="39490">The maximum value obtainable is 45, indicating that only items 1 and 3 will </st><span><st c="39566">be selected.</st></span><table id="table003-3" class="t---table"><colgroup class="calibre51"><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/><col class="calibre52"/></colgroup><tbody class="calibre54"><tr class="t---table1"><td class="t---table2"><p class="calibre3"/></td><td class="t---table2" colspan="8"><p class="calibre3"><img src="image/1760.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;w&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1297"/><st c="39578"/></p></td></tr><tr class="t---table1"><td class="t---table2" rowspan="5"><p class="calibre3"><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; display=&quot;block&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre553"/><st c="39580"/></p></td><td class="t---table2"/><td class="t---table2"><p class="calibre3"><st c="39581">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39582">1</st></p></td><td class="t---table2"><p class="calibre3"><st c="39583">2</st></p></td><td class="t---table2"><p class="calibre3"><st c="39584">3</st></p></td><td class="t---table2"><p class="calibre3"><st c="39585">4</st></p></td><td class="t---table2"><p class="calibre3"><st c="39586">5</st></p></td><td class="t---table2"><p class="calibre3"><st c="39587">6</st></p></td></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="39588">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39589">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39590">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39591">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39592">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39593">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39594">0</st></p></td><td class="t---table2"><p class="calibre3"><st c="39595">0</st></p></td></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="39596">1</st></p></td><td class="t---table2"><p class="calibre3"><st c="39597">0</st></p></td><td class="t---table2"><p class="calibre3"><span><st c="39598">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39600">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39603">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39606">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39609">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39612">15</st></span></p></td></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="39615">2</st></p></td><td class="t---table2"><p class="calibre3"><st c="39617">0</st></p></td><td class="t---table2"><p class="calibre3"><span><st c="39618">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39620">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39623">20</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39626">30</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39629">30</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39632">30</st></span></p></td></tr><tr class="t---table1"><td class="t---table2"><p class="calibre3"><st c="39635">3</st></p></td><td class="t---table2"><p class="calibre3"><st c="39637">0</st></p></td><td class="t---table2"><p class="calibre3"><span><st c="39638">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39640">15</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39643">20</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39646">30</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39649">30</st></span></p></td><td class="t---table2"><p class="calibre3"><span><st c="39652">45</st></span></p></td></tr></tbody></table></li>
			</ol>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="39655">Table 10.3: Completed table </st><img src="image/1772.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1306"/><st c="39684"/><st c="39685">. The final result is highlighted</st></p>
			<p class="calibre3"><st c="39718">The following is a Python implementation of the 0/1 knapsack problem using </st><span><st c="39794">dynamic programming:</st></span></p>
			<pre class="source-code"><st c="39814" class="calibre11">
def dp_knapsack(weights, values, W):
  n = len(weights)
  d = [[0 for _ in range(W + 1)] for _ in range(n + 1)]
  for i in range(n + 1):
    for w in range(W + 1):
      if i == 0 or w == 0:
        d[i][w] = 0
      elif weights[i - 1] &lt;= w:
        dp[i][w] = max(values[i - 1] + d[i - 1][w - weights[i - 1]], d[i - 1][w])
      else:
        d[i][w] = d[i - 1][w]
  return d[n][W]
weights = [2, 3, 4]
values = [3, 4, 5]
W = 5
result = knapsack(weights, values, W)
print("Maximum value:", result)</st></pre>			<p class="calibre3"><st c="40259">As we </st><a id="_idIndexMarker645" class="pcalibre pcalibre1 calibre6"/><st c="40266">previously showed, a naïve divide-and-conquer approach for solving the 0/1 knapsack problem leads to exponential </st><a id="_idIndexMarker646" class="pcalibre pcalibre1 calibre6"/><st c="40379">time complexity </st><img src="image/1786.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:msup&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;/mml:msup&gt;&lt;/mml:math&gt;" class="calibre1316"/><st c="40395"/><st c="40401">), as it explores every possible combination of items, making it impractical for large datasets. </st><st c="40498">The dynamic programming approach, on the other hand, solves each subproblem only once and stores the results in a table, leading to a time complexity of </st><img src="image/1787.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1317"/><st c="40651"/><st c="40652">. The space complexity is also </st><img src="image/1788.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;W&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1318"/><st c="40683"/><st c="40684"> due to the storage of the </st><img src="image/1789.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi mathvariant=&quot;bold-italic&quot;&gt;D&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1319"/><st c="40711"/> <span><st c="40712">table.</st></span></p>
			<h2 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor157" class="pcalibre pcalibre1 calibre6"/><st c="40718">Limitations of dynamic programming</st></h2>
			<p class="calibre3"><st c="40753">In the </st><a id="_idIndexMarker647" class="pcalibre pcalibre1 calibre6"/><st c="40761">previous sections, we demonstrated through two examples and a complexity analysis that dynamic programming offers numerous advantages. </st><st c="40896">Here is a summary of </st><span><st c="40917">these benefits:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="40932">Optimal solutions</st></strong><st c="40950">: Dynamic programming guarantees finding the optimal solution for problems with overlapping subproblems and optimal substructure. </st><st c="41081">By systematically solving and storing the solutions to subproblems, dynamic programming ensures that the final solution is the </st><span><st c="41208">best possible.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="41222">Efficiency</st></strong><st c="41233">: By avoiding the re-computation of overlapping subproblems, dynamic programming reduces the time complexity of many problems from exponential to polynomial, making it feasible to solve large-scale problems that would be intractable using </st><span><st c="41473">other approaches.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="41490">Versatility</st></strong><st c="41502">: Dynamic programming can be applied to a wide range of problems, including but not limited to optimization problems such as the knapsack problem, shortest path problems, and sequence alignment. </st><st c="41698">It’s a powerful tool for solving various combinatorial, probabilistic, and </st><span><st c="41773">deterministic problems.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="41796">Space-time tradeoff</st></strong><st c="41816">: Dynamic programming often allows a tradeoff between space and</st><a id="_idIndexMarker648" class="pcalibre pcalibre1 calibre6"/><st c="41880"> time complexity. </st><st c="41898">For example, by storing intermediate results, time complexity is reduced at the expense of increased space usage. </st><st c="42012">In some cases, space optimization techniques can also be applied to reduce </st><span><st c="42087">space requirements.</st></span></li>
			</ul>
			<p class="calibre3"><st c="42106">However, these benefits come with certain drawbacks </st><span><st c="42159">and limitations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="42175">High space complexity</st></strong><st c="42197">: One of the major drawbacks of dynamic programming is the potentially high space complexity. </st><st c="42292">Storing solutions to all subproblems can require significant memory, especially for problems with large input sizes or dimensions, which might be infeasible in </st><span><st c="42452">memory-constrained environments.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="42484">Complex implementation</st></strong><st c="42507">: Dynamic programming can be more complex to implement compared to simpler approaches such as greedy or divide-and-conquer. </st><st c="42632">The need to correctly define subproblems, identify the recursive structure, and manage the dynamic programming table can make implementation challenging, particularly for </st><span><st c="42803">complex problems.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="42820">Problem specific</st></strong><st c="42837">: Dynamic programming is not a universal solution and is only applicable to problems that exhibit both overlapping subproblems and optimal substructure. </st><st c="42991">For problems that do not meet these criteria, dynamic programming might not provide any advantages or might even </st><span><st c="43104">be inefficient.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="43119">Difficulty in identifying subproblems</st></strong><st c="43157">: In some cases, identifying the appropriate subproblems and constructing the recurrence relation for a dynamic programming solution can be nontrivial. </st><st c="43310">This requires a deep understanding of the problem, which can be a barrier to applying dynamic </st><span><st c="43404">programming effectively.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="43428">Overhead of table management</st></strong><st c="43457">: Managing the dynamic programming table, especially in complex problems with multiple dimensions or states, can add additional overhead and complexity to the implementation. </st><st c="43633">This can also lead to increased computational overhead if not </st><span><st c="43695">managed efficiently.</st></span></li>
			</ul>
			<p class="calibre3"><st c="43715">Dynamic programming</st><a id="_idIndexMarker649" class="pcalibre pcalibre1 calibre6"/><st c="43735"> is a powerful technique that can significantly reduce time complexity and guarantee optimal solutions for a wide range of problems. </st><st c="43868">However, it comes with tradeoffs, particularly in terms of space complexity and implementation complexity. </st><st c="43975">Understanding when and how to apply dynamic programming is key to leveraging its advantages while mitigating its limitations. </st><st c="44101">In the next and final section of this chapter, we will introduce greedy algorithms. </st><st c="44185">While they may not fully address all the limitations of dynamic programming, they provide greater flexibility in solving a broader range </st><span><st c="44322">of problems.</st></span></p>
			<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor158" class="pcalibre pcalibre1 calibre6"/><st c="44334">Greedy algorithms – an introduction</st></h1>
			<p class="calibre3"><st c="44370">At the beginning </st><a id="_idIndexMarker650" class="pcalibre pcalibre1 calibre6"/><st c="44388">of this chapter, we highlighted a</st><a id="_idIndexMarker651" class="pcalibre pcalibre1 calibre6"/><st c="44421"> key distinction between divide-and-conquer algorithms and dynamic programming: while both strategies leverage optimal substructure, divide-and-conquer algorithms do not typically involve overlapping subproblems. </st><st c="44634">Dynamic programming is particularly effective when overlapping subproblems are present because it avoids redundant calculations by storing and reusing the solutions to </st><span><st c="44802">these subproblems.</st></span></p>
			<p class="calibre3"><st c="44820">But what happens if we cannot define an optimal substructure for the problem at hand? </st><st c="44907">In such cases, we turn to a different category of algorithms known as Greedy Algorithms. </st><strong class="bold"><st c="44996">Greedy algorithms</st></strong><st c="45013"> adopt a fundamentally different approach to problem-solving. </st><st c="45075">Instead </st><a id="_idIndexMarker652" class="pcalibre pcalibre1 calibre6"/><st c="45083">of incrementally building solutions by optimally solving subproblems, as in dynamic programming, a greedy algorithm makes a series of decisions based on what appears to be the best choice at each step, with the expectation that</st><a id="_idIndexMarker653" class="pcalibre pcalibre1 calibre6"/><st c="45310"> these locally optimal decisions will collectively lead to a globally </st><span><st c="45380">optimal solution.</st></span></p>
			<p class="calibre3"><st c="45397">Key characteristics </st><a id="_idIndexMarker654" class="pcalibre pcalibre1 calibre6"/><st c="45418">of greedy algorithms are </st><span><st c="45443">as follows:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="45454">Local optimal choice</st></strong><st c="45475">: Greedy algorithms make decisions by selecting the option that seems best at each step, without considering the global consequences of </st><span><st c="45612">this choice.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="45624">No overlapping subproblems</st></strong><st c="45651">: Greedy algorithms do not require overlapping subproblems. </st><st c="45712">Instead, they work best on problems where each choice is independent </st><span><st c="45781">of others.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="45791">Simple implementation</st></strong><st c="45813">: Because greedy algorithms often involve straightforward, sequential decision-making, they tend to be easier to implement and more efficient in terms of time complexity compared to </st><span><st c="45996">dynamic programming.</st></span></li>
			</ul>
			<p class="calibre3"><st c="46016">Let’s explain the greedy algorithm in a classical </st><span><st c="46067">optimization problem.</st></span></p>
			<h2 id="_idParaDest-137" class="calibre5"><a id="_idTextAnchor159" class="pcalibre pcalibre1 calibre6"/><st c="46088">Traveling salesman problem</st></h2>
			<p class="calibre3"><st c="46115">The </st><strong class="bold"><st c="46120">Traveling Salesman Problem</st></strong><st c="46146"> (</st><strong class="bold"><st c="46148">TSP</st></strong><st c="46151">) is a </st><a id="_idIndexMarker655" class="pcalibre pcalibre1 calibre6"/><st c="46159">classic challenge in computer science and operations research. </st><st c="46222">Given a</st><a id="_idIndexMarker656" class="pcalibre pcalibre1 calibre6"/><st c="46229"> set of locations and the distances between them, the goal is to determine the shortest possible route that visits each location once and returns to the starting point. </st><st c="46398">The TSP is known for its computational complexity, as finding the exact optimal solution requires checking all possible permutations of city visits, which becomes infeasible for a large number of cities. </st><st c="46602">However, a greedy algorithm offers a simpler, though not necessarily optimal, approach to solving </st><span><st c="46700">the problem.</st></span></p>
			<p class="calibre3"><st c="46712">The core concept behind greedy algorithms is the use of heuristics. </st><st c="46781">In the next section, we will discuss the details of heuristics. </st><st c="46845">For now, let’s pause and focus on solving the TSP using the </st><span><st c="46905">greedy approach.</st></span></p>
			<p class="calibre3"><st c="46921">One of the </st><a id="_idIndexMarker657" class="pcalibre pcalibre1 calibre6"/><st c="46933">common greedy heuristics for solving TSP is the nearest neighbor algorithm. </st><st c="47009">The steps are </st><span><st c="47023">as follows:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="47034">Start at a random city</st></strong><st c="47057">: Choose an arbitrary city as the </st><span><st c="47092">starting point.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="47107">Visit the nearest unvisited city</st></strong><st c="47140">: From the current city, visit the nearest city that has not yet been visited. </st><st c="47220">This decision is made based on the shortest distance between the current city and the potential </st><span><st c="47316">next cities.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="47328">Repeat until all cities are visited</st></strong><st c="47364">: Continue the process of moving to the nearest unvisited city until all cities have </st><span><st c="47450">been visited.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="47463">Return to the starting city</st></strong><st c="47491">: Once all cities have been visited, return to the starting city to complete </st><span><st c="47569">the tour.</st></span></li>
			</ol>
			<p class="calibre3"><span><strong class="bold"><st c="47578">Example 10.4:</st></strong></span></p>
			<p class="calibre3"><st c="47592">Let’s consider a simplified example with four cities: A, B, C, and D. </st><st c="47663">These are the distances </st><span><st c="47687">between cities:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="47702">A to B = </st><span><st c="47712">10</st></span></li>
				<li class="calibre13"><st c="47714">A to C = </st><span><st c="47724">15</st></span></li>
				<li class="calibre13"><st c="47726">A to D = </st><span><st c="47736">20</st></span></li>
				<li class="calibre13"><st c="47738">B to C = </st><span><st c="47748">35</st></span></li>
				<li class="calibre13"><st c="47750">B to D = </st><span><st c="47760">25</st></span></li>
				<li class="calibre13"><st c="47762">C to D = </st><span><st c="47772">30</st></span></li>
			</ul>
			<p class="calibre3"><st c="47774">The nearest neighbor algorithm steps are </st><span><st c="47816">as follows:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><st c="47827">Start at </st><span><st c="47837">City A.</st></span></li>
				<li class="calibre13"><st c="47844">Visit the nearest city: From A, the nearest city is B (distance = </st><span><st c="47911">10).</st></span></li>
				<li class="calibre13"><st c="47915">Move to City B: From B, the nearest unvisited city is D (distance = </st><span><st c="47984">25).</st></span></li>
				<li class="calibre13"><st c="47988">Move to City D: From D, the nearest unvisited city is C (distance = </st><span><st c="48057">30).</st></span></li>
				<li class="calibre13"><st c="48061">Move to City C: Now all cities have been visited. </st><st c="48112">Finally, return to the starting city A (distance = </st><span><st c="48163">15).</st></span></li>
				<li class="calibre13"><st c="48167">The</st><a id="_idIndexMarker658" class="pcalibre pcalibre1 calibre6"/><st c="48171"> resulting tour using the greedy algorithm is A → B → D → C → A and the total distance is 10 + 25 + 30 + 15 = </st><span><st c="48281">80 units.</st></span></li>
			</ol>
			<h2 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor160" class="pcalibre pcalibre1 calibre6"/><st c="48290">Heuristics and their role in greedy algorithms</st></h2>
			<p class="calibre3"><st c="48337">The term </st><em class="italic"><st c="48347">heuristic</st></em><st c="48356"> originates </st><a id="_idIndexMarker659" class="pcalibre pcalibre1 calibre6"/><st c="48368">from the Latin word </st><em class="italic"><st c="48388">heuristicus</st></em><st c="48399">, which itself is derived from the Greek word </st><em class="italic"><st c="48445">heuriskein</st></em><st c="48455">, meaning to </st><em class="italic"><st c="48468">find</st></em><st c="48472">. Heuristics are utilized across various domains. </st><st c="48522">Here, we will focus on their application in problem-solving and </st><span><st c="48586">artificial intelligence.</st></span></p>
			<p class="calibre3"><st c="48610">Heuristics are</st><a id="_idIndexMarker660" class="pcalibre pcalibre1 calibre6"/><st c="48625"> problem-solving strategies or techniques </st><a id="_idIndexMarker661" class="pcalibre pcalibre1 calibre6"/><st c="48667">that are designed to produce a solution quickly and efficiently, though not necessarily optimally. </st><st c="48766">Heuristics are particularly useful in complex problems where finding the exact solution would require too much time or computational power. </st><st c="48906">Instead of exhaustively exploring all possible solutions, a heuristic approach uses rules of thumb, educated guesses, or intuitive strategies to generate a solution that is </st><em class="italic"><st c="49079">good enough</st></em><st c="49090"> within a reasonable amount </st><span><st c="49118">of time.</st></span></p>
			<p class="calibre3"><st c="49126">Greedy algorithms are a class of algorithms that often rely on heuristics to make decisions. </st><st c="49220">In a greedy algorithm, the strategy is to make the best possible choice at each step based on current information, with the hope that this will lead to an optimal or near-optimal solution. </st><st c="49409">The </st><em class="italic"><st c="49413">best possible choice</st></em><st c="49433"> in each step is determined by </st><span><st c="49464">a heuristic.</st></span></p>
			<p class="calibre3"><st c="49476">Let’s discuss how heuristics work in greedy algorithms. </st><st c="49533">In a greedy algorithm, a heuristic helps the algorithm decide which option to choose at each step. </st><st c="49632">This decision is based on local information, meaning the algorithm does not consider the entire problem but focuses on the current step. </st><st c="49769">In the TSP using the nearest neighbor algorithm, the heuristic is </st><em class="italic"><st c="49835">choosing the nearest unvisited city</st></em><st c="49870">. This decision is made based on the distance from the current city to other cities, without considering the </st><span><st c="49979">overall tour.</st></span></p>
			<p class="calibre3"><st c="49992">The heuristic </st><a id="_idIndexMarker662" class="pcalibre pcalibre1 calibre6"/><st c="50007">guides the algorithm by providing a simple and fast rule to follow. </st><st c="50075">This rule is based on the specific problem’s characteristics and is designed to lead to a good solution. </st><st c="50180">Let’s examine this in the coin change problem. </st><st c="50227">The coin change problem is a classic optimization problem where the goal is to determine the minimum number of coins needed to make a specific amount of money using a given set of coin denominations. </st><st c="50427">For example, if we have coins of denominations 1, 5, and 10 and need to make 12, the challenge is to find the combination of these coins that minimizes the total number of coins used. </st><st c="50611">This problem can be solved using various approaches, including greedy algorithms, dynamic programming, or recursion, depending on the specific set of denominations. </st><st c="50776">For this problem, a greedy heuristic might </st><em class="italic"><st c="50819">always take the largest denomination coin first</st></em><st c="50866">. This simple rule is easy to follow and often leads to a </st><span><st c="50924">solution quickly.</st></span></p>
			<p class="calibre3"><st c="50941">Heuristics also</st><a id="_idIndexMarker663" class="pcalibre pcalibre1 calibre6"/><st c="50957"> allow greedy algorithms to find solutions quickly, even in complex problems. </st><st c="51035">However, this speed comes at the cost of potentially missing the optimal solution. </st><st c="51118">The heuristic provides a balance between finding a solution quickly and finding the best possible solution. </st><st c="51226">Let’s discuss this behavior in the Huffman Coding Algorithm. </st><st c="51287">Huffman coding is a greedy algorithm used for lossless data compression. </st><st c="51360">It assigns variable-length codes to characters based on their frequencies in the input data, with more frequent characters receiving shorter codes. </st><st c="51508">The algorithm builds a binary tree, called the Huffman tree, where each leaf node represents a character and its frequency. </st><st c="51632">By traversing the tree, a unique binary code is generated for each character, minimizing the overall length of the encoded data. </st><st c="51761">Huffman coding is widely used in applications like file compression and encoding. </st><st c="51843">In the Huffman coding algorithm, a greedy approach uses the heuristic of always merging the two least frequent symbols first, which leads to an efficient, though not necessarily </st><span><st c="52021">optimal, encoding.</st></span></p>
			<p class="calibre3"><st c="52039">Heuristics provide significant advantages to greedy algorithms. </st><st c="52104">They make these algorithms fast by enabling decisions without the need to explore every possible option. </st><st c="52209">Moreover, heuristic-based decisions are typically easy to understand and implement, making greedy algorithms straightforward. </st><st c="52335">In many real-world scenarios, particularly in artificial intelligence, a quickly found approximate solution is often more valuable than an exact solution that requires excessive </st><span><st c="52513">computation time.</st></span></p>
			<p class="calibre3"><st c="52530">However, heuristics have their own limitations. </st><st c="52579">Because heuristics rely on local information, they can sometimes result in suboptimal solutions; what seems like the best choice in the short term may not be the best choice in the long run. </st><st c="52770">Additionally, heuristics are often </st><a id="_idIndexMarker664" class="pcalibre pcalibre1 calibre6"/><st c="52805">problem-specific, meaning a heuristic that works well for one problem may not be effective for another. </st><st c="52909">Greedy algorithms, guided by heuristics, can also become trapped in local optima – solutions that are better than nearby alternatives but not the best possible overall. </st><st c="53078">This can cause the heuristic to miss the globally </st><span><st c="53128">optimal solution.</st></span></p>
			<p class="calibre3"><st c="53145">Greedy algorithms</st><a id="_idIndexMarker665" class="pcalibre pcalibre1 calibre6"/><st c="53163"> don’t always yield the optimal solution. </st><st c="53205">In the TSP example discussed earlier, the greedy approach may overlook shorter routes that require more strategic decisions rather than just choosing the nearest neighbor at each step. </st><st c="53390">Since the greedy algorithm is heuristic, it offers a fast, approximate solution but cannot guarantee that the solution is optimal. </st><st c="53521">Additionally, the greedy approach can get trapped in local optima, where a seemingly best decision at the moment hinders achieving the </st><span><st c="53656">global optimum.</st></span></p>
			<p class="calibre3"><st c="53671">The greedy algorithm is best used in the </st><span><st c="53713">following scenarios:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="53733">Optimal substructure doesn’t exist. </st><st c="53770">If a problem lacks a clear optimal substructure, dynamic programming might not be applicable. </st><st c="53864">Greedy algorithms can provide a more straightforward solution in </st><span><st c="53929">such cases.</st></span></li>
				<li class="calibre13"><st c="53940">Greedy algorithms are tailored to specific types of problems, such as those involving scheduling, shortest paths, or resource allocation, where making the locally optimal choice at each step leads to an overall </st><span><st c="54152">optimal solution.</st></span></li>
				<li class="calibre13"><st c="54169">A quick, approximate solution is acceptable, data is small, and computational resources </st><span><st c="54258">are limited.</st></span></li>
				<li class="calibre13"><st c="54270">The problem context allows for the potential trade-off between solution quality and </st><span><st c="54355">computational efficiency.</st></span></li>
			</ul>
			<p class="calibre3"><st c="54380">While greedy algorithms offer a simpler and often more efficient alternative to dynamic programming, they are not a one-size-fits-all solution. </st><st c="54525">The absence of overlapping subproblems and the reliance on local optimization means that greedy algorithms can only be applied to certain types of problems. </st><st c="54682">Understanding when to use a greedy approach versus dynamic programming is crucial for effective problem-solving in </st><span><st c="54797">algorithm design.</st></span></p>
			<p class="calibre3"><em class="italic"><st c="54814">Table 10.4</st></em><st c="54825"> demonstrates a comparison between divide-and-conquer, dynamic programming, and </st><span><st c="54905">greedy algorithms.</st></span></p>
			<table id="table004-3" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="54923">Feature</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="54931">Divide-and-conquer</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="54950">Dynamic programming</st></strong></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><strong class="bold"><st c="54970">Greedy algorithms</st></strong></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="54988">Problem-solving </st><span><st c="55005">strategy</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55013">Breaks problem into independent subproblems, solves recursively, </st><span><st c="55079">combines solutions</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55097">Breaks problem into overlapping subproblems, solves once, </st><span><st c="55156">stores results</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55170">Builds solution piece by piece with locally </st><span><st c="55215">optimal choices</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="55230">Optimal </st><span><st c="55239">substructure</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55251">Uses optimal </st><span><st c="55265">substructure implicitly</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55288">Relies heavily on </st><span><st c="55307">optimal substructure</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55327">Assumes local optimum leads to </st><span><st c="55359">global optimum</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="55373">Overlapping </st><span><st c="55386">subproblems</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55397">Subproblems are usually independent; solving one subproblem does not affect the solution </st><span><st c="55487">of another</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55497">Handles problems with overlapping subproblems by storing and reusing results to avoid </st><span><st c="55584">redundant calculations</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55606">Typically, it does not involve overlapping subproblems. </st><st c="55663">Each decision is made based on the current state, independent of </st><span><st c="55728">previous decisions</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="55746">Use cases</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55756">Sorting, searching, </st><span><st c="55777">numerical problems</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55795">Optimization problems, </st><span><st c="55819">complex problems</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55835">Minimum spanning tree, shortest </st><span><st c="55868">path, scheduling</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="55884">Computational </st><span><st c="55899">efficiency</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55909">Depends on problem nature, </st><span><st c="55937">recursive overhead</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="55955">More space intensive, avoids </st><span><st c="55985">redundant calculations</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="56007">Generally faster, less space, may not always </st><span><st c="56053">be optimal</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><st c="56063">Example </st><span><st c="56072">problems</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="56080">Merge sort, quick sort, </st><span><st c="56105">binary search</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="56118">Knapsack, Longest Common Subsequence, </st><span><st c="56157">Floyd-Warshall</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="56171">Kruskal’s, Dijkstra’s shortest path, </st><span><st c="56209">activity selection</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="56227">Table 10.4: Comparison of divide-and-conquer, dynamic programming, and greedy algorithms</st></p>
			<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor161" class="pcalibre pcalibre1 calibre6"/><st c="56316">Summary</st></h1>
			<p class="calibre3"><st c="56324">In this chapter, we explored the key concepts and differences among these algorithmic strategies, highlighting how each approach solves problems with optimal substructure. </st><st c="56497">We discussed how divide-and-conquer algorithms break problems into smaller, non-overlapping subproblems, and how dynamic programming efficiently handles overlapping subproblems by storing and reusing their solutions. </st><st c="56714">This chapter also covered greedy algorithms, emphasizing their reliance on heuristics to make locally optimal choices at each step, even though this may not always lead to a globally </st><span><st c="56897">optimal solution.</st></span></p>
			<p class="calibre3"><st c="56914">Throughout the chapter, we provided examples such as the 0/1 knapsack problem and the TSP to illustrate the strengths and limitations of each approach. </st><st c="57067">We also examined the role of heuristics in greedy algorithms, noting how they enable quick, approximate solutions but can sometimes lead to suboptimal results. </st><st c="57227">As we concluded the discussion, we acknowledged the importance of choosing the right algorithmic strategy based on the problem </st><span><st c="57354">at hand.</st></span></p>
			<p class="calibre3"><st c="57362">In the next chapter, we will transition into an introduction to data structures, the foundational elements that support efficient algorithm design </st><span><st c="57510">and implementation.</st></span></p>
			<h1 id="_idParaDest-140" class="calibre5"><a id="_idTextAnchor162" class="pcalibre pcalibre1 calibre6"/><st c="57529">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><st c="57560">Introduction to Algorithms. </st><st c="57589">By Thomas H. </st><st c="57602">Cormen, Charles E. </st><st c="57621">Leiserson, Ronald L. </st><st c="57642">Rivest, and Clifford Stein. </st><st c="57670">Fourth Edition. </st><st c="57686">MIT </st><span><st c="57690">Press. </st><st c="57697">2022.</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="57702">Chapter 15, </st></em><span><em class="italic"><st c="57715">Dynamic Programming</st></em></span></li><li class="calibre13"><em class="italic"><st c="57734">Chapter 16, </st></em><span><em class="italic"><st c="57747">Greedy Algorithms</st></em></span></li><li class="calibre13"><em class="italic"><st c="57764">Chapter 34, NP-Completeness (for a comparison of </st></em><span><em class="italic"><st c="57814">algorithm complexities)</st></em></span></li></ul></li>
				<li class="calibre13"><st c="57837">Algorithm Design. </st><st c="57856">By J. </st><st c="57862">Kleinberg and É. </st><st c="57879">Tardos. </st><span><st c="57887">Pearson. </st><st c="57896">2006.</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="57901">Chapter 4, </st></em><span><em class="italic"><st c="57913">Greedy Algorithms</st></em></span></li><li class="calibre13"><em class="italic"><st c="57930">Chapter </st></em><span><em class="italic"><st c="57939">5, Divide-and-Conquer</st></em></span></li><li class="calibre13"><em class="italic"><st c="57960">Chapter 6, </st></em><span><em class="italic"><st c="57972">Dynamic Programming</st></em></span></li></ul></li>
				<li class="calibre13"><st c="57991">Algorithms. </st><st c="58004">By S. </st><st c="58010">Dasgupta, C. </st><st c="58023">H. </st><st c="58026">Papadimitriou, and U. </st><st c="58048">V. </st><st c="58051">Vazirani. </st><span><st c="58061">McGraw-Hill. </st><st c="58074">2008</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="58078">Chapter </st></em><span><em class="italic"><st c="58087">2, Divide-and-Conquer</st></em></span></li><li class="calibre13"><em class="italic"><st c="58108">Chapter 5, </st></em><span><em class="italic"><st c="58120">Greedy Algorithms</st></em></span></li><li class="calibre13"><em class="italic"><st c="58137">Chapter 6, </st></em><span><em class="italic"><st c="58149">Dynamic Programming</st></em></span></li></ul></li>
			</ul>
		</div>
	<div id="charCountTotal" value="58168" class="calibre2"/></body></html>