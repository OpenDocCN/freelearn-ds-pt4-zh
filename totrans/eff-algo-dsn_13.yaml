- en: <st c="0">10</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Dynamic Programming</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="23">Dynamic programming is a</st> <st c="48">powerful technique that
    can dramatically lower the computational costs of many complex algorithms, though
    it comes with some trade-offs.</st> <st c="186">This chapter introduces dynamic
    programming and includes a review of</st> <st c="255">greedy algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="273">We will begin by revisiting the principles of divide-and-conquer
    strategies to contrast them with dynamic programming.</st> <st c="393">Dynamic
    programming stands out in algorithm design due to its ability to solve problems
    that involve overlapping subproblems and optimal substructure.</st> <st c="544">By
    storing the results of these subproblems, dynamic programming prevents redundant
    calculations, leading to significant</st> <st c="665">efficiency gains.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="682">Through various examples, we will explore how dynamic programming
    can be applied to solve classical problems such as the knapsack problem, the longest
    common subsequence, and the Traveling Salesman Problem.</st> <st c="890">Each
    example will illustrate the step-by-step approach to breaking down a problem,
    defining the state space, and formulating the recurrence relations necessary for
    the dynamic</st> <st c="1066">programming solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1087">It is important to note that dynamic programming is an extensive
    topic that cannot be fully covered in just one chapter.</st> <st c="1209">In this
    chapter, we will focus on the key aspects of this method, including its main elements,
    applications, and illustrative examples.</st> <st c="1345">Additionally, we will
    discuss how to estimate the complexities of dynamic programming solutions, and
    we will explore the advantages and limitations of</st> <st c="1496">this approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1510">Specifically, we’ll cover all this in the following</st> <st c="1563">main
    sections:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1577">Dynamic programming</st> <st c="1598">versus divide-and-conquer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1623">Exploring</st> <st c="1634">dynamic programming</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1653">Greedy algorithms –</st> <st c="1674">an introduction</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1689">Dynamic programming versus divide-and-conquer</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1735">In</st> *<st c="1739">Chapters 4</st>* <st c="1749">and</st> *<st
    c="1754">5</st>*<st c="1755">, we</st> <st c="1759">explored recursive algorithms
    and the methods to analyze their complexities.</st> <st c="1837">We also explored
    divide-and-conquer strategies.</st> <st c="1885">The fundamental idea behind a
    divide-and-conquer approach is to break down a problem into smaller subproblems,
    solve these subproblems optimally, and then combine their solutions to form the
    final solution.</st> <st c="2092">This process is typically carried out recursively,
    meaning that the problem is continuously divided into subproblems until we reach
    a point where the subproblem is so small that it can be solved intuitively or
    straightforwardly.</st> <st c="2321">This smallest, simplest problem is referred
    to as the</st> **<st c="2375">base case</st>**<st c="2384">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2385">Dynamic programming follows a similar strategy to divide-and-conquer.</st>
    <st c="2456">It breaks down a problem into subproblems with the explicit assumption
    that the optimal solution to any subproblem will contribute to the final optimal
    solution.</st> <st c="2618">This characteristic is known as the</st> **<st c="2654">optimal
    substructure</st>**<st c="2674">. While</st> <st c="2681">this property is also
    present in divide-and-conquer algorithms, it is typically assumed implicitly rather
    than</st> <st c="2793">explicitly stated.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2811">However, dynamic programming extends beyond the divide-and-conquer
    approach in a key way that sets it apart.</st> <st c="2921">In dynamic programming,
    subproblems often share common sub-subproblems, meaning that there is overlap
    between the subproblems.</st> <st c="3048">This characteristic is known</st> <st
    c="3077">as</st> **<st c="3080">overlapping subproblems</st>**<st c="3103">. Not
    all problems exhibit this behavior.</st> <st c="3145">When a problem does not
    have overlapping subproblems, using a straightforward divide-and-conquer approach
    is more appropriate, as dynamic programming would not provide any additional benefit
    in</st> <st c="3339">such cases.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="3350">But why do overlapping subproblems matter?</st> <st c="3394">One
    of the primary goals in algorithm design and analysis, which we have consistently
    focused on, is reducing the computational cost or complexity of algorithms.</st>
    <st c="3556">The importance of overlapping subproblems lies in their potential
    to significantly lower this computational complexity.</st> <st c="3676">In problems
    where subproblems overlap, divide-and-conquer algorithms may redundantly solve
    these overlapping sub-subproblems multiple times.</st> <st c="3817">In contrast,
    dynamic programming stores the solutions to these sub-subproblems and reuses them
    whenever they are needed.</st> <st c="3938">This reuse of previously computed
    solutions can lead to a substantial reduction in computational complexity.</st>
    <st c="4047">However, this efficiency comes at a cost: the additional space required
    to store the solutions for</st> <st c="4146">these sub-subproblems.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4168">Now that we understand the connection between divide-and-conquer
    and dynamic programming, let’s discuss dynamic programming itself.</st> <st c="4301">First,
    it’s crucial to clarify that the term dynamic programming does not pertain to
    writing code or computer programming.</st> <st c="4424">Instead, it refers to
    a method of mathematical optimization.</st> <st c="4485">Dynamic programming was
    originally proposed as a technique for solving optimization problems, which is
    why it is studied in both mathematical optimization and computer science.</st>
    <st c="4662">In this chapter, our focus will be on the application of dynamic
    programming within the field of</st> <st c="4759">computer science.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="4776">As we</st> <st c="4782">previously discussed, dynamic programming
    is built on two fundamental concepts: the assumption of optimal substructure and
    the presence of overlapping subproblems.</st> <st c="4947">Optimal substructure
    implies that the optimal solution to a problem can be formed from the optimal
    solutions of its subproblems.</st> <st c="5076">Overlapping subproblems occur
    when the same subproblems are solved multiple times during the recursive process.</st>
    <st c="5188">In the following subsections, we will explore these concepts in greater
    detail, examining how they serve as the foundation of dynamic programming and
    how they facilitate the development of efficient algorithms for tackling</st>
    <st c="5411">complex problems.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5428">Optimal substructure</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5449">Optimal substructure</st> <st c="5471">is a cornerstone concept
    in algorithm design, signifying that an optimal solution to a given problem can
    be built efficiently using the optimal solutions of its smaller subproblems.</st>
    <st c="5653">This property suggests that the problem can be decomposed into simpler,
    overlapping subproblems, each of which can be solved independently.</st> <st c="5793">Once
    the subproblems are resolved optimally, their solutions can be combined to form
    the solution to the original,</st> <st c="5908">larger problem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5923">The presence of optimal substructure is crucial because it allows
    us to break down complex problems into more manageable components.</st> <st c="6057">This
    decomposition not only simplifies the problem-solving process but also makes it
    possible to apply algorithmic strategies such as dynamic programming and divide-and-conquer.</st>
    <st c="6235">In dynamic programming, the optimal substructure property ensures
    that once we have the optimal solutions for all subproblems, we can use them to
    systematically build the optimal solution for the entire problem.</st> <st c="6447">This
    is achieved by storing the results of subproblems in a table, preventing the need
    to recompute them and thus enhancing the</st> <st c="6575">algorithm’s efficiency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6598">In divide-and-conquer algorithms, although in a different way,
    the optimal substructure is also vital.</st> <st c="6702">These algorithms divide
    the problem into non-overlapping subproblems, solve each subproblem independently,
    and then combine their solutions.</st> <st c="6843">The success of both dynamic
    programming and divide-and-conquer approaches hinges on the problem exhibiting
    optimal substructure, as it guarantees that solving smaller parts optimally will
    lead to the best possible solution for the</st> <st c="7074">overall problem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7090">Optimal substructure is</st> <st c="7115">not only a theoretical
    concept but also a practical tool in algorithm design.</st> <st c="7193">It helps
    us recognize when a problem can be efficiently tackled using dynamic programming
    or other strategies that rely on building up solutions from smaller components.</st>
    <st c="7363">Understanding and identifying optimal substructure in various problems
    is a key skill in developing efficient and effective algorithms.</st> <st c="7499">Next,
    we will explore this concept with some</st> <st c="7544">example problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7561">The first example is the shortest path problem.</st> <st c="7610">In
    the shortest path problem on a graph, the goal is to find the shortest path from
    a source node (vertex) to a destination node.</st> <st c="7740">This problem exhibits
    optimal substructure because the shortest path between two nodes can be broken
    down into smaller shortest paths between intermediate nodes.</st> <st c="7902">Let’s
    assume</st> **<st c="7915">S</st>** <st c="7916">is the source node and</st> **<st
    c="7940">G</st>** <st c="7941">is the destination.</st> <st c="7962">We aim to
    find the shortest path between these two nodes.</st> <st c="8020">Suppose</st>
    **<st c="8028">A</st>** <st c="8029">is a node on the optimal (shortest) path
    from</st> **<st c="8076">S</st>** <st c="8077">to</st> **<st c="8081">G</st>**<st
    c="8082">. The optimal substructure characteristic suggests that because</st>
    **<st c="8146">A</st>** <st c="8147">is part of the optimal path, the overall
    optimal path from</st> **<st c="8207">S</st>** <st c="8208">to</st> **<st c="8212">G</st>**
    <st c="8213">must consist of the optimal path from</st> **<st c="8252">S</st>**
    <st c="8253">to</st> **<st c="8257">A</st>**<st c="8258">, followed by the optimal
    path from</st> **<st c="8294">A</st>** <st c="8295">to</st> **<st c="8299">G</st>**<st
    c="8300">. Optimal substructure also implies that any subpath that is not optimal
    cannot be part of the overall optimal solution.</st> <st c="8421">This means that
    if a subpath from S to</st> **<st c="8460">A</st>** <st c="8461">or from</st>
    **<st c="8470">A</st>** <st c="8471">to</st> **<st c="8475">G</st>** <st c="8476">is
    not the shortest, then the entire path from</st> **<st c="8524">S</st>** <st c="8525">to</st>
    **<st c="8529">G</st>** <st c="8530">cannot be the shortest (see</st> *<st c="8559">Figure
    10</st>**<st c="8568">.1</st>*<st c="8570">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Fig 10.1: Illustrating optimal substructure in shortest path problem.](img/B22248_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="8587">Fig 10.1: Illustrating optimal substructure in shortest path problem.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8656">The second example is finding the</st> **<st c="8691">Longest Common
    Subsequence</st>** <st c="8717">(</st>**<st c="8719">LCS</st>**<st c="8722">).</st>
    <st c="8726">The problem involves</st> <st c="8746">identifying the longest subsequence
    that can be found in a set of sequences.</st> <st c="8824">It is essential to
    understand that a subsequence differs from a substring.</st> <st c="8899">In a
    subsequence, unlike in a substring, the elements do not need to be in consecutive
    positions within the sequence.</st> <st c="9017">This distinction is crucial in
    many applications across computer science, such as in data compression, sequence
    alignment, and</st> <st c="9144">file comparison.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9160">Optimal substructure in</st> <st c="9184">the LCS problem means
    that the solution to finding the LCS of two sequences can be constructed from
    the solutions to smaller subproblems.</st> <st c="9323">Specifically, the LCS
    of two sequences X and Y can be built by considering the LCS of prefixes of</st>
    <st c="9421">these sequences.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="9437">Let’s assume we have two sequences</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9473"><st c="9474">of length</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1607.png)
    <st c="9485"><st c="9486">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1608.png)
    <st c="9491"><st c="9492">of length</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/945.png)<st
    c="9503"><st c="9504">. The LCS of these two sequences denoted as LCS</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1610.png)<st
    c="9551"><st c="9553">, can be determined using the following approach: if either</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9613"><st c="9614">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1612.png)
    <st c="9618"><st c="9619">is an empty sequence, then the LCS is also an empty
    sequence.</st> <st c="9682">This is the base case for our recursion.</st> <st
    c="9723">If the last characters of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1613.png)
    <st c="9749"><st c="9750">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1614.png)
    <st c="9755"><st c="9756">match</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:mi>s</mml:mi><mml:mi>a</mml:mi><mml:mi>y</mml:mi><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/1615.png)<st
    c="9763"><st c="9780">, then these characters must be part of the LCS.</st> <st
    c="9829">Therefore, the problem reduces to finding the LCS of the prefixes</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1616.png)
    <st c="9895"><st c="9896">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1617.png)<st
    c="9901"><st c="9902">, and then appending the matching character to</st> <st
    c="9949">this LCS.</st></st></st></st></st></st></st></st></st></st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9958">However, if the last characters of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="9994"><st c="9995">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1608.png)
    <st c="10000"><st c="10001">do not match (i.e.,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1620.png)<st
    c="10022"><st c="10023">), then the LCS is the longer of the LCS obtained by either
    of the</st> <st c="10090">following methods:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10108">Excluding the last character of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi></mml:math>](img/1606.png)
    <st c="10141"><st c="10142">and considering the LCS of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1622.png)
    <st c="10170"><st c="10171">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1623.png)</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10176">Excluding the last character of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi></mml:math>](img/1612.png)
    <st c="10208"><st c="10209">and considering the LCS of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1625.png)
    <st c="10237"><st c="10243">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1626.png)</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10248">Let</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>L</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1627.png)
    <st c="10252"><st c="10260">represent the LCS of the prefixes</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1628.png)
    <st c="10294"><st c="10300">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1629.png)<st
    c="10304"><st c="10313">. Then the optimal substructure property can be expressed</st>
    <st c="10371">as follows:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22248_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**<st c="10467">Example 10.1:</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10480">Consider the</st> <st c="10494">following sequences:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbsh</mml:mtext></mml:math>](img/1630.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjsh</mml:mtext></mml:math>](img/1631.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="10542">If the last characters of both sequences are the same (here, both
    end in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1632.png)<st
    c="10615"><st c="10616">), then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>h</mml:mi></mml:math>](img/1632.png)
    <st c="10624"><st c="10625">is part of the LCS, and the problem reduces to finding
    the LCS of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbs</mml:mtext></mml:math>](img/1634.png)
    <st c="10692"><st c="10705">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjs</mml:mtext><mml:mo>.</mml:mo></mml:math>](img/1635.png)
    <st c="10709"><st c="10722">If the last characters are different, we must consider
    the LCS of the smaller sequences</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbsh</mml:mtext></mml:math>](img/1630.png)
    <st c="10810"><st c="10824">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjs</mml:mtext></mml:math>](img/1637.png)<st
    c="10828"><st c="10841">, or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mtext>abbbsbbs</mml:mtext></mml:math>](img/1638.png)
    <st c="10846"><st c="10859">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>bbsdhjsh</mml:mtext></mml:math>](img/1631.png)<st
    c="10863"><st c="10876">, and take the</st> <st c="10891">longer one.</st></st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10902">The optimal substructure in the LCS problem ensures that the overall
    LCS can be constructed from the LCS of smaller subproblems.</st> <st c="11032">This
    property is crucial for dynamic programming solutions, where we systematically
    solve and store the results of these subproblems to build the final</st> <st c="11184">solution
    efficiently.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="11205">Not all problems</st> <st c="11223">are optimal substructure
    problems.</st> <st c="11258">One example is the longest path problem.</st> <st
    c="11299">The longest path problem, particularly in a graph where cycles may exist,
    is not considered to have the optimal substructure property.</st> <st c="11434">To
    understand why, let’s first recall what optimal substructure means: a problem
    exhibits optimal substructure if the optimal solution to the problem can be constructed
    from the optimal solutions of</st> <st c="11633">its subproblems.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11649">In the longest path problem, the goal is to find the longest simple
    path (a path that does not repeat nodes) between two nodes in a graph.</st> <st
    c="11789">This problem is particularly challenging when the graph contains cycles,
    as the presence of cycles can complicate the identification of the longest path.</st>
    <st c="11943">In the longest path problem, the optimal substructure property does
    not hold due to the</st> <st c="12031">following reasons:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="12049">Dependency on subsequent paths</st>**<st c="12080">: In many
    cases, a subpath that appears to be part of the longest path from one node to
    another might not lead to the overall longest path when extended to other nodes.</st>
    <st c="12250">This is because choosing a subpath that looks long at first might
    force you to take shorter paths later, which would reduce the overall</st> <st
    c="12386">path length.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12398">Cycle involvement</st>**<st c="12416">: If the graph contains
    cycles, the longest path might involve traversing through parts of the graph in
    such a way that it doesn’t neatly decompose into subproblems that independently
    contribute to the overall longest path.</st> <st c="12641">The decision to include
    or exclude certain edges can dramatically change the resulting</st> <st c="12728">path’s
    length.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12742">Non-additive nature</st>**<st c="12762">: In problems with
    optimal substructure, you can usually solve subproblems independently and then
    combine them to get the optimal solution.</st> <st c="12903">However, in the longest
    path problem, solving a subproblem optimally (i.e., finding the longest path from
    one node to another) does not guarantee that this subpath will be part of the
    overall longest path in the entire graph.</st> <st c="13129">For example, if you
    have found the longest path from vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math>](img/1640.png)
    <st c="13189"><st c="13190">to vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1641.png)
    <st c="13201"><st c="13202">and then from vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1642.png)
    <st c="13224"><st c="13225">to vertex</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math>](img/1643.png)<st
    c="13236"><st c="13237">, the combination of these paths might not yield the longest
    path from</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math>](img/1644.png)
    <st c="13308"><st c="13309">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math>](img/1645.png)<st
    c="13313"><st c="13314">. The globally optimal solution might instead bypass</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math>](img/1646.png)
    <st c="13367"><st c="13368">entirely if a longer alternative path</st> <st c="13407">is
    available.</st></st></st></st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="13420">Example 10.2:</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13434">Consider a weighted graph where the nodes are</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1478.png)<st
    c="13481"><st c="13482">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1648.png)<st
    c="13484"><st c="13485">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/1649.png)<st
    c="13487"><st c="13488">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1650.png)<st
    c="13494"><st c="13495">, and there are edges</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mrow></math>](img/1651.png)<st
    c="13517"><st c="13518">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow></mrow></math>](img/1652.png)<st
    c="13520"><st c="13521">,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1653.png)<st
    c="13523"><st c="13524">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1654.png)<st
    c="13530"><st c="13531">. The longest path from</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="13555"><st c="13556">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)
    <st c="13560"><st c="13561">could initially seem like it might go through B and
    C.</st> <st c="13617">However, if the direct edge</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1657.png)
    <st c="13645"><st c="13646">is longer than the sum of the paths</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow></mrow></math>](img/1658.png)<st
    c="13683"><st c="13684">, then the optimal solution doesn’t involve the longest
    paths from</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="13751"><st c="13752">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)<st
    c="13756"><st c="13757">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)
    <st c="13759"><st c="13760">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)
    <st c="13764"><st c="13765">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)
    <st c="13770"><st c="13771">to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1664.png)<st
    c="13774"><st c="13775">.</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13776">Obviously, the graph</st> <st c="13797">is directed and weighted.</st>
    <st c="13824">If the graph were undirected and unweighted, this scenario would
    be infeasible because it would violate the triangular inequality, which states
    that the direct distance between two points should be less than or equal to the
    sum of the distances through an intermediate point.</st> <st c="14100">However,
    even in a directed, unweighted graph like this, the result can</st> <st c="14172">be
    counterintuitive.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="14192">Let’s assume that the nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)<st
    c="14221"><st c="14222">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>B</mml:mi></mml:math>](img/1660.png)<st
    c="14224"><st c="14225">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>C</mml:mi></mml:math>](img/106.png)<st
    c="14227"><st c="14228">, and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math>](img/1668.png)<st
    c="14234"><st c="14235">represent four cities: Toronto, Chicago, Denver, and Los
    Angeles, respectively.</st> <st c="14315">The edges represent the ticket prices
    of direct flights.</st> <st c="14372">For example,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow></mrow></math>](img/1669.png)
    <st c="14385"><st c="14386">represents the ticket price of a direct flight from
    Toronto</st> <st c="14447">to Chicago.</st></st></st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14458">As depicted in</st> *<st c="14474">Figure 10</st>**<st c="14483">.2</st>*<st
    c="14485">, the longest path from Toronto to Los Angeles is achieved through a
    direct flight (represented by the edge</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>T</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>o</mi><mo>→</mo><mi>L</mi><mi>o</mi><mi>s</mi><mi>A</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>s</mi></mrow></mrow></math>](img/1670.png)
    <st c="14593"><st c="14614">with a weight of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>$</mml:mi><mml:mn>957</mml:mn></mml:math>](img/1671.png)<st
    c="14631"><st c="14632">) and does not include any stops in Chicago or Denver.</st>
    <st c="14687">This outcome might seem counterintuitive, as one might expect a
    longer path to involve more stops, but in this scenario, the direct flight is
    the most expensive and therefore forms the longest path in terms</st> <st c="14894">of
    cost.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14902">It’s also worth mentioning that in the absence of cycles in the
    graph, as in our simple example, one straightforward algorithm to solve the longest
    path problem is to negate all weights and then solve it as the shortest path problem.</st>
    <st c="15137">This transformation works because finding the shortest path in a
    graph with negated weights is equivalent to finding the longest path in the</st>
    <st c="15278">original graph.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: An example of the longest path problem](img/B22248_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="15314">Figure 10.2: An example of the longest path problem</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15365">The lack of optimal substructure in the longest path problem means
    that dynamic programming and</st> <st c="15461">similar techniques that rely on
    breaking a problem down into subproblems do not work effectively.</st> <st c="15560">This
    is because the longest path problem requires global knowledge of the graph’s structure
    and cannot simply be built up from smaller, independently solved subproblems.</st>
    <st c="15730">As a result, the longest path problem is typically more challenging
    to solve, especially in graphs that contain cycles and is not suited to approaches
    such as dynamic programming that rely on an</st> <st c="15925">optimal substructure.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15946">Overlapping subproblems</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="15970">The second</st> <st c="15982">element of dynamic programming that
    distinguishes it from divide-and-conquer algorithms is the concept of overlapping
    subproblems.</st> <st c="16113">In a well-designed divide-and-conquer strategy,
    each recursive step typically solves a new, distinct subproblem.</st> <st c="16226">A
    good example of this is merge sort, where, during each partitioning step, the
    partitions do not overlap, and each subproblem is independent of</st> <st c="16371">the
    others.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16382">However, there are problems where certain subproblems overlap,
    meaning the same subproblems are solved multiple times in the recursive process.</st>
    <st c="16527">This is where dynamic programming excels by avoiding redundant computations.</st>
    <st c="16604">To illustrate this, let’s consider the Fibonacci series as</st>
    <st c="16663">an example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16674">The Fibonacci series is defined</st> <st c="16707">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1672.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1673.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mi>f</mi><mi>o</mi><mi>r</mi><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></mrow></math>](img/1674.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="16753">When calculating Fibonacci numbers using a divide-and-conquer
    approach, the same subproblems are solved repeatedly.</st> <st c="16869">For instance,
    to compute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>5</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1675.png)<st
    c="16894"><st c="16895">, the algorithm would need to calculate</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1676.png)
    <st c="16935"><st c="16936">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1677.png)<st
    c="16941"><st c="16942">. But to compute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1678.png)<st
    c="16959"><st c="16960">, the algorithm again computes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1677.png)
    <st c="16991"><st c="16992">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1680.png)<st
    c="16997"><st c="16998">, meaning</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>3</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1681.png)
    <st c="17008"><st c="17009">is calculated multiple times.</st> <st c="17040">One
    way to avoid this redundancy is to store the results of previously computed subproblems
    in data structures with near-constant access time, such as a</st> <st c="17193">hash
    table.</st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17204">This redundancy leads to an exponential time complexity, as the
    number of recursive calls grows exponentially with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1054.png)<st
    c="17320"><st c="17321">. This is where dynamic programming provides a significant
    advantage.</st> <st c="17391">Instead of solving the same subproblems repeatedly,
    dynamic programming stores the results of these subproblems and reuses them when
    needed, drastically reducing the number</st> <st c="17564">of computations.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17580">By leveraging overlapping subproblems, dynamic programming transforms
    the recursive solution for the Fibonacci series from an exponential time complexity</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1683.png)
    <st c="17735"><st c="17736">to a linear time complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1684.png)<st
    c="17765"><st c="17766">. This efficiency gain is why dynamic programming is preferred
    over divide-and-conquer approaches in problems where overlapping subproblems exist.</st>
    <st c="17913">In the next section, we will explore dynamic programming in more
    detail by examining</st> <st c="17998">several examples.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18015">Exploring dynamic programming</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="18045">One question</st> <st c="18059">that arises when we identify
    overlapping subproblems is: how can we store these solutions to avoid redundant
    computations?</st> <st c="18182">This is where dynamic programming introduces
    the concept of</st> **<st c="18242">memoization</st>**<st c="18253">. It</st>
    <st c="18258">involves storing the results of subproblems in a data structure,
    such as an array or a dictionary, so that when the same subproblem arises again,
    the stored result can be used immediately, eliminating the need</st> <st c="18468">for
    recalculation.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18486">Before we begin, it’s important to clarify that “memoization”
    is not a misspelling of “memorization.” These two terms have distinct meanings.</st>
    <st c="18629">Memoization comes from the Latin word “memo,” which means “to be
    remembered.” It refers to a technique in computer science where the results of
    expensive function calls are stored and reused to avoid redundant calculations.</st>
    <st c="18853">In contrast, memorization refers to the process of learning and
    committing information to memory, often</st> <st c="18957">through repetition.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18976">Memoization is a technique used in dynamic programming to optimize
    recursive algorithms by storing the results of expensive function calls and reusing
    them when the same inputs occur again.</st> <st c="19167">Instead of recomputing
    the same result multiple times, memoization saves the result of each subproblem
    the first time it is solved and then returns the stored result whenever the same
    subproblem is encountered again.</st> <st c="19384">This significantly reduces
    the time complexity of algorithms that have</st> <st c="19455">overlapping subproblems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19479">Let’s explore how memoization works.</st> <st c="19517">In a typical
    recursive algorithm, a function repeatedly calls itself with smaller inputs until
    it reaches a base case.</st> <st c="19636">Without memoization, the function might
    be called with the same inputs multiple times, resulting in redundant calculations.</st>
    <st c="19760">This inefficiency is common in straightforward recursive algorithms
    that use divide-and-conquer strategies.</st> <st c="19868">By storing the results
    of these repeated subproblems, memoization eliminates the need for these redundant
    calculations, making the algorithm</st> <st c="20009">more efficient.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20024">With memoization, when a function is called, the algorithm first
    checks whether the result for the given input is already stored.</st> <st c="20155">If
    it is, the stored result is returned immediately, avoiding redundant computation.</st>
    <st c="20240">The results of subproblems are stored in a data structure, typically
    a dictionary or an array, which acts as a lookup table.</st> <st c="20365">This
    table is often referred to as</st> <st c="20400">a</st> **<st c="20402">memo</st>**<st
    c="20406">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="20407">Example 10.3:</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20421">Let’s revisit the Fibonacci series example to illustrate memoization
    and compare it to the approach</st> <st c="20522">without memoization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20542">The Fibonacci sequence is defined</st> <st c="20577">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow></mrow></mrow></math>](img/1685.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow></mrow></mrow></math>](img/1686.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mi>f</mi><mi>o</mi><mi>r</mi><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></mrow></math>](img/1687.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="20620">Without memoization</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="20639">The following is</st> <st c="20657">a simple Python implementation
    of the Fibonacci sequence using a naive</st> <st c="20728">recursive approach:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20860">This approach has an exponential time complexity</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1688.png)
    <st c="20910"><st c="20911">because it recalculates the same Fibonacci numbers</st>
    <st c="20963">multiple times.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20978">First, let’s analyze the complexity of the recursive Fibonacci
    series algorithm.</st> <st c="21060">This algorithm divides the problem into two
    subproblems, where the sizes of the subproblems are reduced by one and two, respectively.</st>
    <st c="21194">The recursive part has two components, while the driving function,
    which computes the sum of the two previous Fibonacci numbers, operates in constant</st>
    <st c="21344">time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>c</mml:mi></mml:math>](img/1689.png)<st
    c="21350"><st c="21366">).</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21368">The recurrence function for this algorithm can be expressed</st>
    <st c="21429">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1690.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21478">This recurrence does not fit neatly into the standard forms for
    divide-and-conquer or subtracting recurrence functions.</st> <st c="21598">Therefore,
    we simplify it</st> <st c="21624">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>≈</mml:mo><mml:mn>2</mml:mn><mml:mfenced
    separators="|"><mml:mrow><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1691.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21637">With this</st> <st c="21647">simplification, the recurrence function
    resembles a form that can be analyzed using the Master Theorem for subtracting
    recurrences (see</st> [*<st c="21783">Chapter 5</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="21792">).</st> <st c="21796">According to the Master Theorem, since</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>a</mi><mo>=</mo></mrow></mrow></math>](img/1692.png)<st
    c="21835"><st c="21836">2 and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/1693.png)<st
    c="21842"><st c="21845">, the time complexity of the recursive Fibonacci sequence
    algorithm</st> <st c="21913">is this:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo>⋅</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1694.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21950">This result shows that the recursive Fibonacci algorithm has exponential
    time complexity, specifically</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1695.png)<st
    c="22053"><st c="22054">, making it inefficient for large values of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="22098"><st c="22099">. This inefficiency is why memoization or dynamic programming
    is often used to optimize the computation of</st> <st c="22206">Fibonacci numbers.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The tree demonstrating the non-memoized approach to calculating
    Fibonacci(5)](img/B22248_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="22478">Figure 10.3: The tree demonstrating the non-memoized approach
    to calculating Fibonacci(5)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="22567">Figure 10</st>**<st c="22577">.3</st>* <st c="22579">illustrates
    an example of the tree representing a divide-and-conquer (non-memoized) implementation
    to calculate Fibonacci(5).</st> <st c="22706">As shown, the leaf nodes repeatedly
    consist of Fibonacci(1) and Fibonacci(0).</st> <st c="22784">Additionally, many
    Fibonacci numbers are recalculated multiple times throughout</st> <st c="22864">the
    process.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22876">With memoization</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="22893">By applying memoization, the algorithm avoids redundant calculations.</st>
    <st c="22964">Here is a simple Python</st> <st c="22987">implementation of the
    Fibonacci sequence using dynamic programming, which uses memoization to optimize</st>
    <st c="23091">the calculation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23300">In this version, the time complexity is reduced to</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1697.png)<st
    c="23352"><st c="23353">, because each Fibonacci number is computed only once
    and then stored for</st> <st c="23427">future reference.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: The graph demonstrating the memoized approach to calculating
    Fibonacci(8)](img/B22248_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="23446">Figure 10.4: The graph demonstrating the memoized approach to
    calculating Fibonacci(8)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="23532">Figure 10</st>**<st c="23542">.4</st>* <st c="23544">illustrates
    the graph representing the dynamic programming approach (using memoization) to
    calculate Fibonacci(8).</st> <st c="23660">In this approach, no Fibonacci number
    is redundantly recalculated.</st> <st c="23727">Instead, previously solved subproblems
    are reused, which is reflected in the edges extending from nodes.</st> <st c="23832">This
    reuse of subproblems is why we visualize divide-and-conquer algorithms with trees
    (</st>*<st c="23920">Figure 10</st>**<st c="23930">.3</st>*<st c="23932">), while
    dynamic programming is better represented with graphs (</st>*<st c="23997">Figure
    10</st>**<st c="24007">.4</st>*<st c="24009">).</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24012">Memoization is crucial in dynamic programming, especially for
    problems with overlapping subproblems.</st> <st c="24114">By storing the results
    of these subproblems, memoization minimizes the number of calculations required
    to solve the overall problem, leading to significant improvements in time complexity.</st>
    <st c="24303">However, this benefit comes at the cost of additional</st> <st c="24356">space
    for storing these results.</st> <st c="24390">This tradeoff is usually favorable
    in scenarios where time efficiency is more critical.</st> <st c="24478">It’s important
    to note that memoization is typically employed in a top-down dynamic programming
    approach, where the problem is solved recursively, and results are stored as they
    are computed.</st> <st c="24670">In the upcoming subsection, we briefly discuss
    top-down and bottom-up</st> <st c="24740">dynamic programming.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24760">Top-down versus bottom-up approaches for dynamic programming</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="24821">There are</st> <st c="24831">two main approaches to implementing
    dynamic programming: top-down and bottom-up.</st> <st c="24913">Both approaches
    aim to reduce computational complexity by avoiding redundant calculations, but
    they do so in</st> <st c="25022">different ways.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25037">Top-down dynamic programming, also known as memoization, is a
    recursive approach.</st> <st c="25120">It starts solving the problem from the
    top, breaking it down into smaller subproblems.</st> <st c="25207">As the algorithm
    solves these subproblems, it stores its results in a data structure (usually a
    dictionary or an array) so that if the same subproblem needs to be solved again,
    the stored result can be used directly instead of</st> <st c="25434">recalculating
    it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25451">The top-down process begins with the original problem and recursively
    breaks it down into smaller subproblems.</st> <st c="25563">Each time a subproblem
    is solved, its result is stored (memoized).</st> <st c="25630">If a subproblem
    is encountered again, the algorithm retrieves the stored result instead of</st>
    <st c="25721">recomputing it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25736">The top-down approach is relatively straightforward to implement,
    particularly when adapting from a divide-and-conquer recursive solution.</st>
    <st c="25876">In top-down dynamic programming, only the subproblems essential
    to solving the original problem are addressed, which can be advantageous if certain
    subproblems aren’t needed.</st> <st c="26051">However, this approach does have
    its drawbacks.</st> <st c="26099">It may require more memory due to the need to
    store recursive function calls on the call stack.</st> <st c="26195">Additionally,
    deep recursion can result in a stack overflow when dealing with very large problems.</st>
    *<st c="26294">Example 10.3</st>* <st c="26306">illustrates the memoized version
    of the Fibonacci sequence calculation, serving as a classic example of top-down</st>
    <st c="26420">dynamic programming.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26440">The alternative to the top-down approach is the bottom-up implementation
    of dynamic programming.</st> <st c="26538">Bottom-up dynamic programming, also
    known as tabulation, is an iterative method.</st> <st c="26619">It begins by solving
    the smallest subproblems first and then uses those solutions to build up to the
    solution of the original problem.</st> <st c="26754">In this approach, a table
    (usually an array) is created, with each entry representing the solution to a
    subproblem.</st> <st c="26870">The process starts by addressing the base cases
    and solving the smallest subproblems first.</st> <st c="26962">The solutions are
    stored in the table and then iteratively used to tackle larger subproblems, ultimately
    leading to the</st> <st c="27082">final solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27097">The</st> <st c="27101">bottom-up approach is generally more space-efficient
    than the top-down method because it avoids the overhead associated with recursive
    function calls.</st> <st c="27253">Additionally, it eliminates the risk of stack
    overflow by using an iterative process instead of recursion.</st> <st c="27360">This
    approach often provides a clearer view of how the solution is constructed, making
    it easier to manage and understand.</st> <st c="27483">However, the bottom-up
    approach has two significant drawbacks.</st> <st c="27546">First, it requires
    solving all subproblems, even those that may not be necessary for the final solution.</st>
    <st c="27651">Additionally, it can be more complex to implement initially, particularly
    when transitioning from a</st> <st c="27751">recursive approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27770">The following is a Python implementation of bottom-up approach
    to the</st> <st c="27841">Fibonacci sequence:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*<st c="28062">Table 10.1</st>* <st c="28073">provides a summary of the characteristics
    of both the top-down and bottom-up approaches in</st> <st c="28165">dynamic programming.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="28185">Feature</st>** | **<st c="28193">Top-down (memoization)</st>**
    | **<st c="28216">Bottom-up (tabulation)</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="28239">Approach</st> | <st c="28248">Recursive, solves the problem
    from the top (main problem) and breaks it down</st> <st c="28326">into subproblems.</st>
    | <st c="28343">Iterative, solves the problem from the bottom (base cases) and
    builds up to the</st> <st c="28424">main problem.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="28437">Space complexity</st> | <st c="28454">May use more memory due
    to the call stack, and</st> <st c="28502">memoization storage.</st> | <st c="28522">Typically
    uses less memory, as it mainly relies on a table</st> <st c="28582">or array.</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="28591">Time complexity</st> | <st c="28607">Avoids re-computation
    by storing results of subproblems,</st> <st c="28665">generally</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1698.png)<st
    c="28675"><st c="28676">.</st></st> | <st c="28677">Also avoids re-computation,</st>
    <st c="28706">generally</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)<st
    c="28716"><st c="28717">.</st></st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="28718">Ease</st> <st c="28724">of implementation</st> | <st c="28741">Easier
    to implement if transitioning from a naive</st> <st c="28792">recursive solution.</st>
    | <st c="28811">It might be harder to implement initially, especially if converting
    from a</st> <st c="28887">recursive approach.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="28906">Risk of</st> <st c="28915">stack overflow</st> | <st c="28929">Higher
    risk due to</st> <st c="28949">deep recursion.</st> | <st c="28964">No risk, as
    it avoids</st> <st c="28987">recursion altogether.</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="29008">Table 10.1: A comparison of top-down and bottom-up approaches</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="29070">Both top-down</st> <st c="29085">and bottom-up approaches to
    dynamic programming achieve the same goal: optimizing the computation by avoiding
    redundant calculations.</st> <st c="29219">The choice between the two often depends
    on the specific problem, the programmer’s comfort with recursion or iteration,
    and the memory and performance constraints of the task at hand.</st> *<st c="29403">Table
    10.1</st>* <st c="29413">presents a comparison of the top-down and bottom-up approaches
    in</st> <st c="29480">dynamic programming.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29500">Let’s take a moment to discuss how to calculate the time complexity
    of dynamic programming implementations.</st> <st c="29609">As we’ve noted, dynamic
    programming algorithms are better represented by directed graphs rather than trees.</st>
    <st c="29717">In</st> [*<st c="29720">Chapter 5</st>*](B22248_05_split_000.xhtml#_idTextAnchor062)<st
    c="29729">, we explored the use of recursion trees to estimate the time complexity
    of recursive algorithms.</st> <st c="29827">Here, instead of using trees, we’ll
    utilize a graph to visualize a dynamic</st> <st c="29902">programming algorithm.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29924">In a dynamic programming graph, nodes represent subproblems, and
    the edges emerging from these nodes represent the choices we encounter within
    each subproblem.</st> <st c="30085">We can interpret this from the perspective
    of the destination of the edges, given that the</st> <st c="30176">graph is directed.</st>
    <st c="30195">Each incoming edge to a node signifies a function call—this means
    the subproblem is being recalled rather than recalculated, as would happen in
    a typical</st> <st c="30349">divide-and-conquer approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30377">Now, let’s assume there are</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/646.png)
    <st c="30406"><st c="30407">subproblems (or functions) in total, and each subproblem
    is recalled</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1701.png)
    <st c="30477"><st c="30478">times, where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow></mrow></math>](img/1702.png)<st
    c="30492"><st c="30493">. The time complexity of this dynamic programming algorithm
    can be expressed</st> <st c="30570">as follows:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mrow><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>m</mml:mi></mml:math>](img/1703.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="30592">This approach typically results in a linear time complexity, particularly
    in cases where the number of subproblems</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>m</mml:mi></mml:math>](img/1358.png)
    <st c="30707"><st c="30708">is proportional to the size of the input</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)<st
    c="30750"><st c="30751">. In the worst-case scenario, where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow></mrow></math>](img/1706.png)<st
    c="30787"><st c="30788">, each subproblem corresponds directly to a unique state
    of the input, and the algorithm must process each state</st> <st c="30901">exactly
    once.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30914">When this occurs, the dynamic programming algorithm efficiently
    computes the solution in</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="31004"><st c="31005">time.</st> <st c="31012">This is because the algorithm
    leverages the overlapping subproblems by storing their results and reusing them
    as needed, rather than recalculating them.</st> <st c="31165">As a result, the
    total number of operations is linearly related to the size of the input, avoiding
    the exponential time complexity that would occur if each subproblem were recomputed
    multiple times, as in naive</st> <st c="31376">recursive approaches.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31397">This linear time complexity is one of the key advantages of dynamic
    programming.</st> <st c="31479">It allows the algorithm to scale effectively with
    the size of the input, making it practical for solving large and complex problems
    that would otherwise be computationally infeasible using brute-force or</st> <st
    c="31683">divide-and-conquer strategies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31713">Let’s apply the approach discussed earlier to analyze the time
    complexity of the dynamic programming implementation of the Fibonacci sequence,
    as shown in</st> *<st c="31869">Example 10.3</st>*<st c="31881">. By considering</st>
    *<st c="31898">Figure 10</st>**<st c="31907">.4</st>*<st c="31909">, which illustrates
    the graph representing the problem of calculating the Fibonacci of number 8 (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1708.png)<st
    c="32006"><st c="32008">), we can derive the</st> <st c="32029">time complexity.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="32045">In the graph, each node corresponds to a subproblem—specifically,
    one of the Fibonacci numbers that needs to be computed.</st> <st c="32168">The
    graph for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1709.png)
    <st c="32182"><st c="32183">includes 8 nodes, each representing an overlapping
    subproblem.</st> <st c="32247">Additionally, each node in this graph has two choices:
    one corresponding to the function call for the previous Fibonacci number</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1710.png)
    <st c="32375"><st c="32376">and the other for the Fibonacci number before that</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/1711.png)<st
    c="32428"><st c="32429">. These choices are depicted as outgoing edges from each
    node, or equivalently, two incoming edges to each node in</st> <st c="32544">the
    graph.</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="32554">To calculate the</st> <st c="32572">time complexity, we observe
    that the graph structure results in every node (or subproblem) being processed
    once, with each node involving two operations: one for each of the outgoing edges.</st>
    <st c="32762">This results in a total of</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>8</mn><mo>×</mo><mn>2</mn></mrow></mrow></math>](img/1712.png)
    <st c="32789"><st c="32790">operations</st> <st c="32802">for</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mn>8</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1708.png)<st
    c="32806"><st c="32807">.</st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32808">Generalizing this to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1714.png)<st
    c="32830"><st c="32831">, we observe that for any Fibonacci number</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1715.png)<st
    c="32874"><st c="32875">, the total number of operations can be expressed</st>
    <st c="32925">as follows:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>T</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1716.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="32938">This formula shows that the dynamic programming approach to computing
    Fibonacci numbers of scales linearly with the input size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/98.png)<st
    c="33065"><st c="33066">. The efficiency is achieved because dynamic programming
    avoids redundant calculations by storing and reusing the results of subproblems
    (memoization), leading to a significant reduction in time complexity compared
    to the naive recursive approach, which has an exponential</st> <st c="33339">time
    complexity.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33355">Let’s look at another classic example in the context of dynamic
    programming, which is the</st> **<st c="33446">knapsack problem</st>**<st c="33462">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33463">Solving the 0/1 knapsack problem using dynamic programming</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="33522">The</st> <st c="33527">knapsack problem is a classic</st> <st
    c="33557">optimization problem where the goal is to determine the maximum value
    that can be obtained</st> <st c="33647">by selecting items to include in a knapsack,
    subject to a weight capacity constraint.</st> <st c="33734">Each item has a specific
    weight and value, and the challenge is to choose the optimal combination of items
    to maximize the total value without exceeding the knapsack’s weight limit.</st>
    <st c="33916">Let’s assume we have a set of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/823.png)
    <st c="33946"><st c="33947">items, each with a weight</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1719.png)
    <st c="33974"><st c="33975">and a value</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1720.png)
    <st c="33988"><st c="33989">and a knapsack with a maximum weight capacity</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)<st
    c="34036"><st c="34037">. The objective is to maximize the total value</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1722.png)
    <st c="34084"><st c="34085">of the items in the knapsack such that the</st> <st
    c="34129">following holds:</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">max</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1723.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="34147">subject to:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>W</mml:mi></mml:math>](img/1724.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="34160">Depending</st> <st c="34169">on how we define</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1725.png)<st
    c="34187"><st c="34188">, we encounter the following types of</st> <st c="34226">knapsack
    problem:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34243">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1726.png)<st
    c="34247"><st c="34258">, the problem is known as the 0/1 knapsack problem.</st>
    <st c="34310">This is the problem we will focus on solving in</st> <st c="34358">this
    chapter.</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34371">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo></mml:math>](img/1727.png)<st
    c="34375"><st c="34394">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi></mml:math>](img/1728.png)
    <st c="34402"><st c="34403">is a constant, the</st> <st c="34422">problem is referred
    to as the</st> **<st c="34453">Bounded Knapsack</st>** **<st c="34470">Problem</st>**
    <st c="34477">(</st>**<st c="34479">BKP</st>**<st c="34482">).</st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34485">If</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1729.png)
    <st c="34489"><st c="34490">can be any non-negative integer, the</st> <st c="34528">problem
    is called the</st> **<st c="34550">Unbounded Knapsack</st>** **<st c="34569">Problem</st>**
    <st c="34576">(</st>**<st c="34578">UKP</st>**<st c="34581">).</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34584">First, let’s</st> <st c="34597">examine the complexity of the
    0/1 knapsack problem using a naïve approach.</st> <st c="34673">Given</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1730.png)
    <st c="34679"><st c="34680">items, a straightforward solution would involve generating
    all possible subsets of these</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="34770"><st c="34819">items, calculating the corresponding weight and value
    for each subset, and then identifying the optimal solution.</st> <st c="34933">This
    approach results in a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1732.png)<st
    c="34979"><st c="34980">, making the problem non-polynomial and computationally
    infeasible for large values</st> <st c="35064">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)<st
    c="35067"><st c="35116">.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35117">The goal is to solve the 0/1 knapsack problem using a dynamic
    programming approach.</st> <st c="35202">The knapsack problem exhibits both optimal
    substructure and overlapping subproblems, making it an ideal candidate for a dynamic</st>
    <st c="35330">programming solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35351">Optimal substructure means that the optimal solution to a problem
    can consider a knapsack problem with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="35455"><st c="35456">items and capacity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1735.png)<st
    c="35476"><st c="35477">. Let’s assume we have an optimal solution for this problem.</st>
    <st c="35538">If we remove the last item from this optimal solution, the remaining
    items must form an optimal solution for a knapsack problem with</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/485.png)
    <st c="35671"><st c="35672">items and capacity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)
    <st c="35692"><st c="35693">minus the weight of the</st> <st c="35718">removed
    item.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35731">In other words, the optimal solution to the larger problem (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="35792"><st c="35842">items, capacity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)<st
    c="35858"><st c="35859">) is composed of an optimal solution to a smaller subproblem
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1740.png)
    <st c="35921"><st c="35923">items, reduced capacity) plus the decision of whether
    to include the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1741.png)
    <st c="35993"><st c="35996">item or not.</st> <st c="36009">This property allows
    us to break down the problem into smaller subproblems and solve them recursively,
    which is the foundation of the dynamic</st> <st c="36151">programming approach.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36172">For example, if we</st> <st c="36192">have an optimal solution
    for a knapsack problem with 5 items and a capacity of 12, and we remove the fifth
    item, the remaining 4 items must form an optimal solution for a knapsack problem
    with 4 items and a capacity reduced by the weight of the</st> <st c="36437">fifth
    item.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36448">Overlapping</st> <st c="36461">subproblems in this problem refer
    to the situation where the same subproblems are solved multiple times during the
    process of finding the optimal solution.</st> <st c="36617">When solving the 0/1
    knapsack problem using a recursive approach, we often find that the same subproblems
    are revisited.</st> <st c="36738">Specifically, when deciding whether to include
    or exclude an item from the knapsack, we are essentially solving the same problem
    but with reduced capacity or</st> <st c="36896">fewer items.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36908">Consider a simple example with three items, and a knapsack capacity</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1742.png)<st
    c="36977"><st c="36978">. Each item has a weight</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi></mml:math>](img/1743.png)
    <st c="37003"><st c="37004">and a</st> <st c="37011">value</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi></mml:math>](img/1744.png)<st
    c="37017"><st c="37018">:</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37019">Item</st> <st c="37024">1:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math>](img/1745.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37028">Item</st> <st c="37033">2:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:math>](img/1746.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37037">Item</st> <st c="37042">3:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math>](img/1747.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37046">When solving this problem recursively, we might face the</st>
    <st c="37103">following subproblems:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="37125">Including Item 1: This leads to solving the subproblem with the
    remaining capacity</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1748.png)
    <st c="37209"><st c="37210">and the remaining items (Item 2 and</st> <st c="37247">Item
    3)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="37254">Excluding Item 1: This leads to solving the subproblem with the
    full capacity</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>5</mn></mrow></mrow></math>](img/1749.png)
    <st c="37333"><st c="37334">and the remaining items (Item 2 and</st> <st c="37371">Item
    3)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37378">However, when we move on to consider Item 2, you will again encounter
    the</st> <st c="37453">same subproblems:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="37470">Including Item 2: Solves the problem with a capacity of</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>2</mn></mrow></mrow></math>](img/1750.png)
    <st c="37527"><st c="37528">(if Item 1 was included) or</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1751.png)
    <st c="37557"><st c="37558">(if Item 1 was excluded) and the remaining item (</st><st
    c="37608">Item 3)</st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="37616">Excluding Item 2: Solves the problem with the current capacity
    and just Item</st> <st c="37694">3 remaining</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37705">As we can see, some subproblems (e.g., the subproblem with</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>W</mi><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/1752.png)
    <st c="37765"><st c="37766">and Item 3) are encountered multiple times.</st> <st
    c="37811">Without dynamic programming, we would solve these subproblems repeatedly,
    leading to</st> <st c="37896">unnecessary computations.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37921">Now that we</st> <st c="37933">have a clear understanding of the
    two essential elements of dynamic programming in the 0/1 knapsack problem, let’s
    walk through the</st> <st c="38066">step-by-step solution:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38088">Create</st> <st c="38095">a two-dimensional table</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi></mml:math>](img/1172.png)
    <st c="38120"><st c="38121">with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1754.png)
    <st c="38127"><st c="38131">rows and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1755.png)
    <st c="38140"><st c="38142">columns, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1055.png)
    <st c="38157"><st c="38158">is the number of items and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>W</mml:mi></mml:math>](img/1721.png)
    <st c="38186"><st c="38187">is the total capacity of the knapsack.</st> <st c="38227">Let</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1758.png)
    <st c="38231"><st c="38241">represent the maximum value that can be obtained using
    the first</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38306"><st c="38307">items with a knapsack capacity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/1760.png)<st
    c="38342"><st c="38343">. For instance,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mn>4</mn><mo>,</mo><mn>5</mn><mo>)</mo></mrow></mrow></mrow></math>](img/1761.png)
    <st c="38359"><st c="38364">would represent the maximum value achievable with
    the first 4 items, assuming the knapsack has a maximum capacity of 5, even though
    the actual capacity might</st> <st c="38522">be greater.</st></st></st></st></st></st></st></st></st></st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="38533">Initialize the first row</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1762.png)
    <st c="38559"><st c="38560">and first column</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>(</mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1763.png)<st
    c="38578"><st c="38579">, which means</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1764.png)
    <st c="38593"><st c="38594">for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38603"><st c="38604">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/1766.png)
    <st c="38609"><st c="38610">for all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi></mml:math>](img/1760.png)<st
    c="38619"><st c="38620">. Let’s assume we have three items with the following
    weights and values:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1,3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1768.png)
    <st c="38694"><st c="38698">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>15,20,30</mml:mn><mml:mo>}</mml:mo></mml:math>](img/1769.png)
    <st c="38702"><st c="38708">and the knapsack capacity is 6\.</st> <st c="38740">(see</st>
    *<st c="38745">Table 10.2</st>*<st c="38755">).</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>w</mml:mi></mml:math>](img/1760.png) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>i</mml:mi></mml:math>](img/701.png) |  | <st c="38761">0</st>
    | <st c="38762">1</st> | <st c="38763">2</st> | <st c="38764">3</st> | <st c="38765">4</st>
    | <st c="38766">5</st> | <st c="38767">6</st> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="38768">0</st> | <st c="38769">0</st> | <st c="38770">0</st> | <st
    c="38771">0</st> | <st c="38772">0</st> | <st c="38773">0</st> | <st c="38774">0</st>
    | <st c="38775">0</st> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="38776">1</st> | <st c="38777">0</st> |  |  |  |  |  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="38778">2</st> | <st c="38779">0</st> |  |  |  |  |  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="38780">3</st> | <st c="38781">0</st> |  |  |  |  |  |  |</st></st></st></st></st></st></st></st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="38782">Table 10.2: Initializing table</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1772.png)'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38814">Populate the table by the</st> <st c="38840">following rules:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="38856">For each item</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="38871"><st c="38872">and</st> <st c="38877">weight</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1774.png)<st
    c="38884"><st c="38885">:</st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38886">If the weight of a new item exceeds the current weight limit,
    we exclude the new item:</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:math>](img/1775.png)<st
    c="38973"><st c="38996">)</st> <st c="38998">if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>></mml:mo><mml:mi>w</mml:mi></mml:math>](img/1776.png)<st
    c="39001"><st c="39002">.</st></st></st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39003">Otherwise, we have</st> <st c="39023">two choices:</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39035">Include the current</st> <st c="39056">item:</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/1777.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39090">Exclude the current</st> <st c="39110">item:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>i</mi><mo>,</mo><mi>w</mi><mo>)</mo><mo>=</mo><mi>d</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1778.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39137">Choose the maximum of these</st> <st c="39165">two values:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi
    mathvariant="italic">max</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/1779.png)
    <st c="39176"><st c="39219">if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>w</mml:mi></mml:math>](img/1780.png)</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39225">Generate</st> <st c="39233">the solution.</st> <st c="39248">The</st>
    <st c="39251">solution is located at</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>,</mo><mi>W</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1781.png)<st
    c="39275"><st c="39276">, which represents the maximum value achievable with the
    entire set of items and the full knapsack capacity.</st> *<st c="39385">Table
    10.3</st>* <st c="39395">shows the completed table,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1782.png)<st
    c="39423"><st c="39424">, with the final solution highlighted in the bottom-right
    corner.</st> <st c="39490">The maximum value obtainable is 45, indicating that
    only items 1 and 3 will</st> <st c="39566">be selected.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  | ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>w</mml:mi></mml:math>](img/1760.png) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>i</mml:mi></mml:math>](img/701.png) |  | <st c="39581">0</st>
    | <st c="39582">1</st> | <st c="39583">2</st> | <st c="39584">3</st> | <st c="39585">4</st>
    | <st c="39586">5</st> | <st c="39587">6</st> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="39588">0</st> | <st c="39589">0</st> | <st c="39590">0</st> | <st
    c="39591">0</st> | <st c="39592">0</st> | <st c="39593">0</st> | <st c="39594">0</st>
    | <st c="39595">0</st> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="39596">1</st> | <st c="39597">0</st> | <st c="39598">15</st> | <st
    c="39600">15</st> | <st c="39603">15</st> | <st c="39606">15</st> | <st c="39609">15</st>
    | <st c="39612">15</st> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="39615">2</st> | <st c="39617">0</st> | <st c="39618">15</st> | <st
    c="39620">15</st> | <st c="39623">20</st> | <st c="39626">30</st> | <st c="39629">30</st>
    | <st c="39632">30</st> |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| <st c="39635">3</st> | <st c="39637">0</st> | <st c="39638">15</st> | <st
    c="39640">15</st> | <st c="39643">20</st> | <st c="39646">30</st> | <st c="39649">30</st>
    | <st c="39652">45</st> |</st></st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="39655">Table 10.3: Completed table</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1772.png)<st
    c="39684"><st c="39685">. The final result is highlighted</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39718">The following is a Python implementation of the 0/1 knapsack problem
    using</st> <st c="39794">dynamic programming:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40259">As we</st> <st c="40266">previously showed, a naïve divide-and-conquer
    approach for solving the 0/1 knapsack problem leads to exponential</st> <st c="40379">time
    complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/1786.png)<st
    c="40395"><st c="40401">), as it explores every possible combination of items,
    making it impractical for large datasets.</st> <st c="40498">The dynamic programming
    approach, on the other hand, solves each subproblem only once and stores the results
    in a table, leading to a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>W</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1787.png)<st
    c="40651"><st c="40652">. The space complexity is also</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mi>W</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1788.png)
    <st c="40683"><st c="40684">due to the storage of the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold-italic">D</mml:mi></mml:math>](img/1789.png)
    <st c="40711"><st c="40712">table.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40718">Limitations of dynamic programming</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="40753">In the</st> <st c="40761">previous sections, we demonstrated through
    two examples and a complexity analysis that dynamic programming offers numerous
    advantages.</st> <st c="40896">Here is a summary of</st> <st c="40917">these benefits:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="40932">Optimal solutions</st>**<st c="40950">: Dynamic programming
    guarantees finding the optimal solution for problems with overlapping subproblems
    and optimal substructure.</st> <st c="41081">By systematically solving and storing
    the solutions to subproblems, dynamic programming ensures that the final solution
    is the</st> <st c="41208">best possible.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41222">Efficiency</st>**<st c="41233">: By avoiding the re-computation
    of overlapping subproblems, dynamic programming reduces the time complexity of
    many problems from exponential to polynomial, making it feasible to solve large-scale
    problems that would be intractable using</st> <st c="41473">other approaches.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41490">Versatility</st>**<st c="41502">: Dynamic programming can be
    applied to a wide range of problems, including but not limited to optimization
    problems such as the knapsack problem, shortest path problems, and sequence alignment.</st>
    <st c="41698">It’s a powerful tool for solving various combinatorial, probabilistic,
    and</st> <st c="41773">deterministic problems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="41796">Space-time tradeoff</st>**<st c="41816">: Dynamic programming
    often allows a tradeoff between space and</st> <st c="41880">time complexity.</st>
    <st c="41898">For example, by storing intermediate results, time complexity is
    reduced at the expense of increased space usage.</st> <st c="42012">In some cases,
    space optimization techniques can also be applied to reduce</st> <st c="42087">space
    requirements.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42106">However, these benefits come with certain drawbacks</st> <st c="42159">and
    limitations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="42175">High space complexity</st>**<st c="42197">: One of the major
    drawbacks of dynamic programming is the potentially high space complexity.</st>
    <st c="42292">Storing solutions to all subproblems can require significant memory,
    especially for problems with large input sizes or dimensions, which might be infeasible
    in</st> <st c="42452">memory-constrained environments.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42484">Complex implementation</st>**<st c="42507">: Dynamic programming
    can be more complex to implement compared to simpler approaches such as greedy
    or divide-and-conquer.</st> <st c="42632">The need to correctly define subproblems,
    identify the recursive structure, and manage the dynamic programming table can
    make implementation challenging, particularly for</st> <st c="42803">complex problems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42820">Problem specific</st>**<st c="42837">: Dynamic programming
    is not a universal solution and is only applicable to problems that exhibit both
    overlapping subproblems and optimal substructure.</st> <st c="42991">For problems
    that do not meet these criteria, dynamic programming might not provide any advantages
    or might even</st> <st c="43104">be inefficient.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="43119">Difficulty in identifying subproblems</st>**<st c="43157">:
    In some cases, identifying the appropriate subproblems and constructing the recurrence
    relation for a dynamic programming solution can be nontrivial.</st> <st c="43310">This
    requires a deep understanding of the problem, which can be a barrier to applying
    dynamic</st> <st c="43404">programming effectively.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="43428">Overhead of table management</st>**<st c="43457">: Managing
    the dynamic programming table, especially in complex problems with multiple dimensions
    or states, can add additional overhead and complexity to the implementation.</st>
    <st c="43633">This can also lead to increased computational overhead if not</st>
    <st c="43695">managed efficiently.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43715">Dynamic programming</st> <st c="43735">is a powerful technique
    that can significantly reduce time complexity and guarantee optimal solutions
    for a wide range of problems.</st> <st c="43868">However, it comes with tradeoffs,
    particularly in terms of space complexity and implementation complexity.</st>
    <st c="43975">Understanding when and how to apply dynamic programming is key to
    leveraging its advantages while mitigating its limitations.</st> <st c="44101">In
    the next and final section of this chapter, we will introduce greedy algorithms.</st>
    <st c="44185">While they may not fully address all the limitations of dynamic
    programming, they provide greater flexibility in solving a broader range</st>
    <st c="44322">of problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44334">Greedy algorithms – an introduction</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="44370">At the beginning</st> <st c="44388">of this chapter, we highlighted
    a</st> <st c="44421">key distinction between divide-and-conquer algorithms and
    dynamic programming: while both strategies leverage optimal substructure, divide-and-conquer
    algorithms do not typically involve overlapping subproblems.</st> <st c="44634">Dynamic
    programming is particularly effective when overlapping subproblems are present
    because it avoids redundant calculations by storing and reusing the solutions
    to</st> <st c="44802">these subproblems.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44820">But what happens if we cannot define an optimal substructure for
    the problem at hand?</st> <st c="44907">In such cases, we turn to a different
    category of algorithms known as Greedy Algorithms.</st> **<st c="44996">Greedy
    algorithms</st>** <st c="45013">adopt a fundamentally different approach to problem-solving.</st>
    <st c="45075">Instead</st> <st c="45083">of incrementally building solutions by
    optimally solving subproblems, as in dynamic programming, a greedy algorithm makes
    a series of decisions based on what appears to be the best choice at each step,
    with the expectation that</st> <st c="45310">these locally optimal decisions will
    collectively lead to a globally</st> <st c="45380">optimal solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45397">Key characteristics</st> <st c="45418">of greedy algorithms are</st>
    <st c="45443">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="45454">Local optimal choice</st>**<st c="45475">: Greedy algorithms
    make decisions by selecting the option that seems best at each step, without considering
    the global consequences of</st> <st c="45612">this choice.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="45624">No overlapping subproblems</st>**<st c="45651">: Greedy algorithms
    do not require overlapping subproblems.</st> <st c="45712">Instead, they work
    best on problems where each choice is independent</st> <st c="45781">of others.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="45791">Simple implementation</st>**<st c="45813">: Because greedy
    algorithms often involve straightforward, sequential decision-making, they tend
    to be easier to implement and more efficient in terms of time complexity compared
    to</st> <st c="45996">dynamic programming.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="46016">Let’s explain the greedy algorithm in a classical</st> <st c="46067">optimization
    problem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46088">Traveling salesman problem</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="46115">The</st> **<st c="46120">Traveling Salesman Problem</st>** <st
    c="46146">(</st>**<st c="46148">TSP</st>**<st c="46151">) is a</st> <st c="46159">classic
    challenge in computer science and operations research.</st> <st c="46222">Given
    a</st> <st c="46229">set of locations and the distances between them, the goal
    is to determine the shortest possible route that visits each location once and
    returns to the starting point.</st> <st c="46398">The TSP is known for its computational
    complexity, as finding the exact optimal solution requires checking all possible
    permutations of city visits, which becomes infeasible for a large number of cities.</st>
    <st c="46602">However, a greedy algorithm offers a simpler, though not necessarily
    optimal, approach to solving</st> <st c="46700">the problem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46712">The core concept behind greedy algorithms is the use of heuristics.</st>
    <st c="46781">In the next section, we will discuss the details of heuristics.</st>
    <st c="46845">For now, let’s pause and focus on solving the TSP using the</st>
    <st c="46905">greedy approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46921">One of the</st> <st c="46933">common greedy heuristics for solving
    TSP is the nearest neighbor algorithm.</st> <st c="47009">The steps are</st> <st
    c="47023">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="47034">Start at a random city</st>**<st c="47057">: Choose an arbitrary
    city as the</st> <st c="47092">starting point.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="47107">Visit the nearest unvisited city</st>**<st c="47140">: From
    the current city, visit the nearest city that has not yet been visited.</st> <st
    c="47220">This decision is made based on the shortest distance between the current
    city and the potential</st> <st c="47316">next cities.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="47328">Repeat until all cities are visited</st>**<st c="47364">: Continue
    the process of moving to the nearest unvisited city until all cities have</st>
    <st c="47450">been visited.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="47463">Return to the starting city</st>**<st c="47491">: Once all
    cities have been visited, return to the starting city to complete</st> <st c="47569">the
    tour.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="47578">Example 10.4:</st>**'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="47592">Let’s consider a simplified example with four cities: A, B, C,
    and D.</st> <st c="47663">These are the distances</st> <st c="47687">between cities:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47702">A to B =</st> <st c="47712">10</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47714">A to C =</st> <st c="47724">15</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47726">A to D =</st> <st c="47736">20</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47738">B to C =</st> <st c="47748">35</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47750">B to D =</st> <st c="47760">25</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47762">C to D =</st> <st c="47772">30</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47774">The nearest neighbor algorithm steps are</st> <st c="47816">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47827">Start at</st> <st c="47837">City A.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="47844">Visit the nearest city: From A, the nearest city is B (distance
    =</st> <st c="47911">10).</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="47915">Move to City B: From B, the nearest unvisited city is D (distance
    =</st> <st c="47984">25).</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="47988">Move to City D: From D, the nearest unvisited city is C (distance
    =</st> <st c="48057">30).</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="48061">Move to City C: Now all cities have been visited.</st> <st c="48112">Finally,
    return to the starting city A (distance =</st> <st c="48163">15).</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="48167">The</st> <st c="48171">resulting tour using the greedy algorithm
    is A → B → D → C → A and the total distance is 10 + 25 + 30 + 15 =</st> <st c="48281">80
    units.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="48290">Heuristics and their role in greedy algorithms</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="48337">The term</st> *<st c="48347">heuristic</st>* <st c="48356">originates</st>
    <st c="48368">from the Latin word</st> *<st c="48388">heuristicus</st>*<st c="48399">,
    which itself is derived from the Greek word</st> *<st c="48445">heuriskein</st>*<st
    c="48455">, meaning to</st> *<st c="48468">find</st>*<st c="48472">. Heuristics
    are utilized across various domains.</st> <st c="48522">Here, we will focus on
    their application in problem-solving and</st> <st c="48586">artificial intelligence.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48610">Heuristics are</st> <st c="48625">problem-solving strategies or
    techniques</st> <st c="48667">that are designed to produce a solution quickly
    and efficiently, though not necessarily optimally.</st> <st c="48766">Heuristics
    are particularly useful in complex problems where finding the exact solution would
    require too much time or computational power.</st> <st c="48906">Instead of exhaustively
    exploring all possible solutions, a heuristic approach uses rules of thumb, educated
    guesses, or intuitive strategies to generate a solution that is</st> *<st c="49079">good
    enough</st>* <st c="49090">within a reasonable amount</st> <st c="49118">of time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49126">Greedy algorithms are a class of algorithms that often rely on
    heuristics to make decisions.</st> <st c="49220">In a greedy algorithm, the strategy
    is to make the best possible choice at each step based on current information,
    with the hope that this will lead to an optimal or near-optimal solution.</st>
    <st c="49409">The</st> *<st c="49413">best possible choice</st>* <st c="49433">in
    each step is determined by</st> <st c="49464">a heuristic.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49476">Let’s discuss how heuristics work in greedy algorithms.</st> <st
    c="49533">In a greedy algorithm, a heuristic helps the algorithm decide which
    option to choose at each step.</st> <st c="49632">This decision is based on local
    information, meaning the algorithm does not consider the entire problem but focuses
    on the current step.</st> <st c="49769">In the TSP using the nearest neighbor
    algorithm, the heuristic is</st> *<st c="49835">choosing the nearest unvisited
    city</st>*<st c="49870">. This decision is made based on the distance from the
    current city to other cities, without considering the</st> <st c="49979">overall
    tour.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49992">The heuristic</st> <st c="50007">guides the algorithm by providing
    a simple and fast rule to follow.</st> <st c="50075">This rule is based on the
    specific problem’s characteristics and is designed to lead to a good solution.</st>
    <st c="50180">Let’s examine this in the coin change problem.</st> <st c="50227">The
    coin change problem is a classic optimization problem where the goal is to determine
    the minimum number of coins needed to make a specific amount of money using a
    given set of coin denominations.</st> <st c="50427">For example, if we have coins
    of denominations 1, 5, and 10 and need to make 12, the challenge is to find the
    combination of these coins that minimizes the total number of coins used.</st>
    <st c="50611">This problem can be solved using various approaches, including greedy
    algorithms, dynamic programming, or recursion, depending on the specific set of
    denominations.</st> <st c="50776">For this problem, a greedy heuristic might</st>
    *<st c="50819">always take the largest denomination coin first</st>*<st c="50866">.
    This simple rule is easy to follow and often leads to a</st> <st c="50924">solution
    quickly.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50941">Heuristics also</st> <st c="50957">allow greedy algorithms to
    find solutions quickly, even in complex problems.</st> <st c="51035">However,
    this speed comes at the cost of potentially missing the optimal solution.</st>
    <st c="51118">The heuristic provides a balance between finding a solution quickly
    and finding the best possible solution.</st> <st c="51226">Let’s discuss this
    behavior in the Huffman Coding Algorithm.</st> <st c="51287">Huffman coding is
    a greedy algorithm used for lossless data compression.</st> <st c="51360">It assigns
    variable-length codes to characters based on their frequencies in the input data,
    with more frequent characters receiving shorter codes.</st> <st c="51508">The
    algorithm builds a binary tree, called the Huffman tree, where each leaf node
    represents a character and its frequency.</st> <st c="51632">By traversing the
    tree, a unique binary code is generated for each character, minimizing the overall
    length of the encoded data.</st> <st c="51761">Huffman coding is widely used in
    applications like file compression and encoding.</st> <st c="51843">In the Huffman
    coding algorithm, a greedy approach uses the heuristic of always merging the two
    least frequent symbols first, which leads to an efficient, though not necessarily</st>
    <st c="52021">optimal, encoding.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52039">Heuristics provide significant advantages to greedy algorithms.</st>
    <st c="52104">They make these algorithms fast by enabling decisions without the
    need to explore every possible option.</st> <st c="52209">Moreover, heuristic-based
    decisions are typically easy to understand and implement, making greedy algorithms
    straightforward.</st> <st c="52335">In many real-world scenarios, particularly
    in artificial intelligence, a quickly found approximate solution is often more
    valuable than an exact solution that requires excessive</st> <st c="52513">computation
    time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52530">However, heuristics have their own limitations.</st> <st c="52579">Because
    heuristics rely on local information, they can sometimes result in suboptimal
    solutions; what seems like the best choice in the short term may not be the best
    choice in the long run.</st> <st c="52770">Additionally, heuristics are often</st>
    <st c="52805">problem-specific, meaning a heuristic that works well for one problem
    may not be effective for another.</st> <st c="52909">Greedy algorithms, guided
    by heuristics, can also become trapped in local optima – solutions that are better
    than nearby alternatives but not the best possible overall.</st> <st c="53078">This
    can cause the heuristic to miss the globally</st> <st c="53128">optimal solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53145">Greedy algorithms</st> <st c="53163">don’t always yield the optimal
    solution.</st> <st c="53205">In the TSP example discussed earlier, the greedy
    approach may overlook shorter routes that require more strategic decisions rather
    than just choosing the nearest neighbor at each step.</st> <st c="53390">Since
    the greedy algorithm is heuristic, it offers a fast, approximate solution but
    cannot guarantee that the solution is optimal.</st> <st c="53521">Additionally,
    the greedy approach can get trapped in local optima, where a seemingly best decision
    at the moment hinders achieving the</st> <st c="53656">global optimum.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53671">The greedy algorithm is best used in the</st> <st c="53713">following
    scenarios:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53733">Optimal substructure doesn’t exist.</st> <st c="53770">If a problem
    lacks a clear optimal substructure, dynamic programming might not be applicable.</st>
    <st c="53864">Greedy algorithms can provide a more straightforward solution in</st>
    <st c="53929">such cases.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53940">Greedy algorithms are tailored to specific types of problems,
    such as those involving scheduling, shortest paths, or resource allocation, where
    making the locally optimal choice at each step leads to an overall</st> <st c="54152">optimal
    solution.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54169">A quick, approximate solution is acceptable, data is small, and
    computational resources</st> <st c="54258">are limited.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54270">The problem context allows for the potential trade-off between
    solution quality and</st> <st c="54355">computational efficiency.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="54380">While greedy algorithms offer a simpler and often more efficient
    alternative to dynamic programming, they are not a one-size-fits-all solution.</st>
    <st c="54525">The absence of overlapping subproblems and the reliance on local
    optimization means that greedy algorithms can only be applied to certain types
    of problems.</st> <st c="54682">Understanding when to use a greedy approach versus
    dynamic programming is crucial for effective problem-solving in</st> <st c="54797">algorithm
    design.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="54814">Table 10.4</st>* <st c="54825">demonstrates a comparison between
    divide-and-conquer, dynamic programming, and</st> <st c="54905">greedy algorithms.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="54923">Feature</st>** | **<st c="54931">Divide-and-conquer</st>**
    | **<st c="54950">Dynamic programming</st>** | **<st c="54970">Greedy algorithms</st>**
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="54988">Problem-solving</st> <st c="55005">strategy</st> | <st c="55013">Breaks
    problem into independent subproblems, solves recursively,</st> <st c="55079">combines
    solutions</st> | <st c="55097">Breaks problem into overlapping subproblems, solves
    once,</st> <st c="55156">stores results</st> | <st c="55170">Builds solution piece
    by piece with locally</st> <st c="55215">optimal choices</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="55230">Optimal</st> <st c="55239">substructure</st> | <st c="55251">Uses
    optimal</st> <st c="55265">substructure implicitly</st> | <st c="55288">Relies
    heavily on</st> <st c="55307">optimal substructure</st> | <st c="55327">Assumes
    local optimum leads to</st> <st c="55359">global optimum</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="55373">Overlapping</st> <st c="55386">subproblems</st> | <st c="55397">Subproblems
    are usually independent; solving one subproblem does not affect the solution</st>
    <st c="55487">of another</st> | <st c="55497">Handles problems with overlapping
    subproblems by storing and reusing results to avoid</st> <st c="55584">redundant
    calculations</st> | <st c="55606">Typically, it does not involve overlapping subproblems.</st>
    <st c="55663">Each decision is made based on the current state, independent of</st>
    <st c="55728">previous decisions</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="55746">Use cases</st> | <st c="55756">Sorting, searching,</st> <st
    c="55777">numerical problems</st> | <st c="55795">Optimization problems,</st>
    <st c="55819">complex problems</st> | <st c="55835">Minimum spanning tree, shortest</st>
    <st c="55868">path, scheduling</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="55884">Computational</st> <st c="55899">efficiency</st> | <st c="55909">Depends
    on problem nature,</st> <st c="55937">recursive overhead</st> | <st c="55955">More
    space intensive, avoids</st> <st c="55985">redundant calculations</st> | <st c="56007">Generally
    faster, less space, may not always</st> <st c="56053">be optimal</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="56063">Example</st> <st c="56072">problems</st> | <st c="56080">Merge
    sort, quick sort,</st> <st c="56105">binary search</st> | <st c="56118">Knapsack,
    Longest Common Subsequence,</st> <st c="56157">Floyd-Warshall</st> | <st c="56171">Kruskal’s,
    Dijkstra’s shortest path,</st> <st c="56209">activity selection</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="56227">Table 10.4: Comparison of divide-and-conquer, dynamic programming,
    and greedy algorithms</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56316">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="56324">In this chapter, we explored the key concepts and differences
    among these algorithmic strategies, highlighting how each approach solves problems
    with optimal substructure.</st> <st c="56497">We discussed how divide-and-conquer
    algorithms break problems into smaller, non-overlapping subproblems, and how dynamic
    programming efficiently handles overlapping subproblems by storing and reusing
    their solutions.</st> <st c="56714">This chapter also covered greedy algorithms,
    emphasizing their reliance on heuristics to make locally optimal choices at each
    step, even though this may not always lead to a globally</st> <st c="56897">optimal
    solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56914">Throughout the chapter, we provided examples such as the 0/1 knapsack
    problem and the TSP to illustrate the strengths and limitations of each approach.</st>
    <st c="57067">We also examined the role of heuristics in greedy algorithms, noting
    how they enable quick, approximate solutions but can sometimes lead to suboptimal
    results.</st> <st c="57227">As we concluded the discussion, we acknowledged the
    importance of choosing the right algorithmic strategy based on the problem</st>
    <st c="57354">at hand.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57362">In the next chapter, we will transition into an introduction to
    data structures, the foundational elements that support efficient algorithm design</st>
    <st c="57510">and implementation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57529">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="57560">Introduction to Algorithms.</st> <st c="57589">By Thomas H.</st>
    <st c="57602">Cormen, Charles E.</st> <st c="57621">Leiserson, Ronald L.</st>
    <st c="57642">Rivest, and Clifford Stein.</st> <st c="57670">Fourth Edition.</st>
    <st c="57686">MIT</st> <st c="57690">Press.</st> <st c="57697">2022.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="57702">Chapter 15,</st>* *<st c="57715">Dynamic Programming</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="57734">Chapter 16,</st>* *<st c="57747">Greedy Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="57764">Chapter 34, NP-Completeness (for a comparison of</st>* *<st
    c="57814">algorithm complexities)</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57837">Algorithm Design.</st> <st c="57856">By J.</st> <st c="57862">Kleinberg
    and É.</st> <st c="57879">Tardos.</st> <st c="57887">Pearson.</st> <st c="57896">2006.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="57901">Chapter 4,</st>* *<st c="57913">Greedy Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="57930">Chapter</st>* *<st c="57939">5, Divide-and-Conquer</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="57960">Chapter 6,</st>* *<st c="57972">Dynamic Programming</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57991">Algorithms.</st> <st c="58004">By S.</st> <st c="58010">Dasgupta,
    C.</st> <st c="58023">H.</st> <st c="58026">Papadimitriou, and U.</st> <st c="58048">V.</st>
    <st c="58051">Vazirani.</st> <st c="58061">McGraw-Hill.</st> <st c="58074">2008</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="58078">Chapter</st>* *<st c="58087">2, Divide-and-Conquer</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="58108">Chapter 5,</st>* *<st c="58120">Greedy Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="58137">Chapter 6,</st>* *<st c="58149">Dynamic Programming</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
