- en: <st c="0">11</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Landscape of Data Structures</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="32">The relationship between algorithms and data is fundamental to designing
    efficient software programs.</st> <st c="135">The choice of data structures directly
    impacts the performance of algorithms, as basic data structures might require
    resource-intensive operations such as search, insertion, and deletion, potentially
    leading to inefficiencies in software execution.</st> <st c="384">In contrast,
    more advanced data structures can simplify these operations, reducing complexity
    and significantly enhancing overall algorithm performance.</st> <st c="537">Understanding
    this relationship is key to optimizing both the speed and resource usage of</st>
    <st c="627">software programs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="645">In this chapter, we will explore various aspects of data structures,
    including their classifications as linear and non-linear types, as well as the
    distinctions between static and dynamic data allocations.</st> <st c="852">We
    also discuss the fundamental operations supported by data structures, such as
    searching, insertion, and deletion, and discuss how the efficiency of these operations
    varies with different data structures.</st> <st c="1059">By examining these characteristics,
    this chapter aims to provide a comprehensive understanding of how to select and
    implement data structures that best meet the needs of specific algorithms, ultimately
    leading to more efficient and effective</st> <st c="1301">software design.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1317">We’ll cover the following main topics in</st> <st c="1359">this
    chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1372">Taxonomy of</st> <st c="1385">data structures</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1400">Abstract</st> <st c="1410">data types</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1420">Dictionaries</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1433">Taxonomy of data structures</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1461">Understanding</st> <st c="1476">and designing algorithms without
    considering the data they operate on is an incomplete endeavor.</st> <st c="1573">In</st>
    [*<st c="1576">Chapter 1</st>*](B22248_01.xhtml#_idTextAnchor014)<st c="1585">,
    we explored the unique relationship between computing hardware and algorithms.</st>
    <st c="1666">Similarly, there is a significant connection between algorithms and
    data.</st> <st c="1740">An efficient algorithm relies heavily on the use of an
    appropriate and efficient data structure.</st> <st c="1837">For this reason, in
    this chapter and the next two, we will focus on data structures from the perspective
    of algorithm design.</st> <st c="1963">While data structures are a broad and complex
    field that warrants detailed study, our focus here and in the next two chapters
    will be on their critical role in</st> <st c="2123">algorithm efficiency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2144">First, it is crucial</st> <st c="2166">to grasp the key aspects
    used to evaluate and assess the efficiency and characteristics of data structures.</st>
    <st c="2274">Understanding these aspects is important, as the choice of an appropriate
    data structure directly impacts the performance and effectiveness of an algorithm.</st>
    <st c="2431">When designing an algorithm, selecting the right data structure is
    not merely a matter of preference but also a necessity dictated by the algorithm’s</st>
    <st c="2581">specific requirements.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2603">Let’s begin by defining what a data structure is within the context
    of algorithms.</st> <st c="2687">A data structure is a systematic way of organizing,
    managing, and storing data in a computer so that it can be accessed and modified
    efficiently.</st> <st c="2833">The organization of data is not arbitrary; it is
    intentionally designed to support specific types of operations that are critical
    for the performance of algorithms and</st> <st c="3001">computer programs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3019">In the domain of algorithms, a data structure serves as the foundation
    upon which algorithms operate.</st> <st c="3122">It determines how data is stored,
    how it is retrieved, and how it can be manipulated during the execution of a program.</st>
    <st c="3242">The efficiency of an algorithm often hinges on the effectiveness
    of the underlying data structure.</st> <st c="3341">Whether the task involves
    searching, sorting, inserting, or deleting data, the choice of data structure
    can dramatically impact the speed and resource usage of</st> <st c="3501">the
    algorithm.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3515">In essence, a data structure is more than just a method of data
    organization; it is a vital component that influences the efficiency, scalability,
    and overall performance of algorithms in</st> <st c="3704">computer science.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3721">The key question now is, which data structure is best suited for
    specific computational tasks and algorithms?</st> <st c="3832">This section is
    dedicated to addressing that question.</st> <st c="3887">In this section, we will
    introduce the criteria that define the efficiency of data structures.</st> <st
    c="3982">These criteria will guide our exploration of various data structures
    and their suitability for different types of algorithms.</st> <st c="4108">Following
    this, the discussion will shift to a comprehensive examination of how data structures
    can be categorized.</st> <st c="4224">This categorization, or taxonomy, of data
    structures will help us understand the different types and their appropriate use
    cases, providing a structured approach to selecting the most suitable data structure
    for a given</st> <st c="4444">algorithmic challenge.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4466">Physical versus logical data structures</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4506">In data</st> <st c="4515">structures, it’s important to distinguish
    between physical and logical data structures.</st> <st c="4603">A</st> **<st c="4605">physical
    data structure</st>** <st c="4628">refers</st> <st c="4635">to the actual organization
    and arrangement of data in the memory of a computer.</st> <st c="4716">In this
    context, the data items are physically related to each other, based on their location
    in memory.</st> <st c="4821">When an algorithm is executed, the data it processes
    is stored in a computer’s memory in a manner that reflects its</st> <st c="4937">physical
    structure.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4956">Physical data structures are directly concerned with how data is
    laid out in memory, including aspects such as memory allocation, pointers, and
    how data is retrieved or modified at the hardware lev</st><st c="5154">el.</st>
    <st c="5159">The way data is physically organized can significantly affect the
    performance of an algorithm, particularly in terms of speed and</st> <st c="5289">memory
    efficiency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5307">Conversely, a</st> **<st c="5322">logical data structure</st>**
    <st c="5344">refers</st> <st c="5351">to the abstract organization of data as
    perceived by the algorithm or the programmer.</st> <st c="5438">This is a conceptual
    model that defines how data is related to each other, regardless of how it is
    physically stored.</st> <st c="5556">Examples of logical data structures include
    arrays, linked lists, trees, and graphs.</st> <st c="5641">These structures are
    defined by the operations that can be performed on them and the relationships
    between data items, rather than their physical location</st> <st c="5796">in memory.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5806">When an algorithm is executed, it operates on these logical data
    structu</st><st c="5879">res.</st> <st c="5885">However, in order for the algorithm
    to function, there must be a mapping between the logical structure and the physical
    memory where the data resides.</st> <st c="6036">This mapping is managed by a
    combination of system programs and the memory management subsystem, which are
    integral components of the operating system.</st> <st c="6188">These systems ensure
    that the logical data structures used by the algorithm are efficiently translated
    into the appropriate physical data structures</st> <st c="6337">in memory.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6347">As we move to higher levels of abstraction in computer algorithms
    and models, the dependence on the physical representation of data diminishes.</st>
    <st c="6492">At these advanced levels, the focus shifts from how data is physically
    stored in memory to how it is logically structured and manipulated to achieve
    the</st> <st c="6645">desired outcomes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6662">In essence, higher-level algorithms are designed to operate on
    data without needing to concern themselves with the underlying physical data representation.</st>
    <st c="6819">This abstraction allows for greater flexibility and generality in
    algorithm design, as the same logical structure can be implemented on various
    physical systems without altering the</st> <st c="7001">algorithm itself.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7018">In this book, we concentrate on studying data structures at the
    logical level.</st> <st c="7098">This approach allows us to focus on the abstract
    organization of data and the operations that can be performed on it, independent
    of the specifics of physical storage.</st> <st c="7266">By understanding</st>
    <st c="7282">data structures in this way, we can develop more versatile and robust
    algorithms that are applicable across different computing environments, regardless
    of the underlying hardware or</st> <st c="7466">memory architecture.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7486">In summary, physical data structures are concerned with the actual
    storage of data in memory, while logical data structures provide an abstract way
    to organize and manipulate data.</st> <st c="7668">The efficiency of an algorithm
    can depend heavily on how well these two aspects are managed</st> <st c="7760">and
    aligned.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7772">Primitive versus composite data structures</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7815">When</st> <st c="7820">discussing data structures, it is essential
    to differentiate between primitive and composite data structures.</st> *<st c="7931">Primitive
    data structures</st>* <st c="7956">are</st> <st c="7960">the most basic forms
    of data representation.</st> <st c="8006">They include fundamental types, such
    as integers, floats, characters, and pointers.</st> <st c="8090">These structures
    are typically directly supported by computer hardware or the programming language,
    and they form the building blocks for more complex data structures.</st> <st c="8258">Primitive
    data structures are straightforward in terms of both their implementation and
    their operations, such as assigning values, performing arithmetic, and basic</st>
    <st c="8423">input/output operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8447">Conversely,</st> *<st c="8460">composite data structures</st>*
    <st c="8485">are</st> <st c="8490">more complex and are composed of multiple primitive
    data elements.</st> <st c="8557">They are designed to handle more sophisticated
    data organization and operations.</st> <st c="8638">Examples of composite data
    structures include arrays, linked lists, trees, and graphs.</st> <st c="8725">These
    structures allow you to group multiple primitive data types into a single, more
    powerful entity, enabling more complex operations such as searching, sorting,
    and</st> <st c="8893">hierarchical organization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8919">Composite data structures are essential for implementing algorithms
    that require the handling of more complex data relationships.</st> <st c="9050">For
    instance, a tree structure can represent hierarchical relationships between data
    items, while a graph structure can represent more complex networks of relationships.</st>
    <st c="9220">Unlike primitive data structures, composite data structures require
    careful design and management to ensure efficient data processing.</st> <st c="9355">In
    this book (</st>[*<st c="9369">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)
    <st c="9380">and</st> [*<st c="9385">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="9395">), our focus is on understanding and utilizing composite data structures
    from a</st> <st c="9476">logical perspective.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9496">Linear versus non-linear data structures</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="9537">One important</st> <st c="9552">way to classify logical data structures
    is by their linearity.</st> <st c="9615">Logical data structures can be categorized
    as either linear or non-linear, with each type serving distinct purposes and enabling
    different types</st> <st c="9760">of operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="9774">Linear data structures</st>* <st c="9797">are those in which
    data elements are arranged in a sequential order, where</st> <st c="9872">each
    element is connected to its previous and next elements, forming a straight line.</st>
    <st c="9959">Examples of linear data structures include arrays, linked lists,
    stacks, and queues.</st> <st c="10044">In a linear data structure, operations
    such as traversal, insertion, and deletion typically follow a straightforward,
    sequential pattern.</st> <st c="10182">This ordered nature makes linear data structures
    ideal for tasks where data needs to be processed in a specific order, such as
    in managing queues or performing</st> <st c="10342">simple searches.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10358">In terms of memory, linear data structure has the</st> <st c="10408">following
    advantages:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="10430">Contiguous memory allocation</st>**<st c="10459">: Linear data
    structures, such as arrays, use contiguous blocks of memory, making memory access
    faster and more predictable due to the locality of reference.</st> <st c="10618">This
    results in efficient utilization of cache memory and reduces the overhead of</st>
    <st c="10700">accessing elements.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10719">Memory management simplicity</st>**<st c="10748">: Because
    linear data structures often involve fixed sizes (e.g., arrays) or sequential
    pointers (e.g., linked lists), managing memory is straightforward.</st> <st c="10904">Memory
    allocation and deallocation are easier to implement compared to more</st> <st
    c="10980">complex structures.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10999">Low memory overhead</st>**<st c="11019">: For structures such
    as arrays, there is minimal memory overhead because no additional pointers or
    links are required to connect the elements, leading to lower memory usage compared
    to non-linear structures such as trees</st> <st c="11242">or graphs.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11252">Conversely, linear data structures come</st> <st c="11292">with
    limitations in terms</st> <st c="11319">of memory:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11329">Wasted memory (a fixed-size limitation)</st>**<st c="11369">:
    In structures such as arrays, memory is allocated for a fixed number of elements
    at the time of creation.</st> <st c="11478">If the number of elements is fewer
    than the allocated size, there will be unused memory space, leading to</st> <st
    c="11584">inefficient utilization.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11608">Memory reallocation</st>**<st c="11628">: Expanding a linear
    data structure such as an array requires reallocation of memory and copying of
    elements to a new, larger memory block, which is costly in terms of time and space.</st>
    <st c="11813">This reallocation can lead to memory fragmentation</st> <st c="11864">and
    inefficiency.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11881">Pointer overhead in linked lists</st>**<st c="11914">: In linked
    lists, each element stores an additional pointer to the next element, which increases
    the overall memory usage, especially when dealing with a large number of elements.</st>
    <st c="12096">This overhead can negate some of the memory advantages gained by</st>
    <st c="12161">dynamic sizing.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12176">Sequential memory allocation for contiguous structures</st>**<st
    c="12231">: Linear structures such as arrays require contiguous blocks of memory.</st>
    <st c="12304">If sufficient contiguous space is not available, memory allocation
    may fail or become inefficient, leading to potential</st> <st c="12424">performance
    bottlenecks.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="12448">The</st> <st c="12453">simplicity of linear data structures often
    leads to ease of implementation and predictability in performance.</st> <st c="12563">However,
    they may not always be the most efficient choice to represent more complex relationships
    between data elements, as their sequential nature can limit flexibility in</st>
    <st c="12736">certain scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="12754">Non-linear data structures</st>*<st c="12781">, conversely,
    do</st> <st c="12797">not organize data in a linear sequence.</st> <st c="12838">Instead,
    the data elements are connected in a more complex way, forming structures such
    as trees, graphs, and heaps.</st> <st c="12955">In non-linear data structures,
    each element may be connected to multiple elements, allowing for the representation
    of hierarchical or networked relationships between</st> <st c="13121">data points.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13133">Non-linear data structures are particularly powerful for representing
    data that has an inherent hierarchical organization, such as a family tree or
    a file directory, or for modeling networks, such as social connections or transportation
    routes.</st> <st c="13379">They offer greater flexibility and efficiency for tasks
    that require managing and querying complex relationships between data items.</st>
    <st c="13512">However, their complexity also requires more sophisticated</st>
    <st c="13570">algorithms for traversal, searching,</st> <st c="13608">and manipulation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13625">In this book, we will examine both linear (</st>[*<st c="13669">Chapter
    12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="13680">) and non-linear data
    structures (</st>[*<st c="13715">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="13726">) from a logical standpoint, focusing on how they can be utilized to
    support different types</st> <st c="13820">of algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13834">Static versus dynamic memory allocation</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="13874">Another</st> <st c="13883">important classification is based on
    how memory is allocated to store data.</st> <st c="13959">This classification
    divides data structures into those with static data allocation and those with
    dynamic</st> <st c="14065">data allocation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="14081">Static data structures</st>* <st c="14104">are</st> <st c="14109">those
    where the size of the data structure is fixed at the time of its creation.</st>
    <st c="14190">This means that the amount of memory allocated for the data structure
    remains constant throughout its lifetime.</st> <st c="14302">An example of a static
    data structure is an array.</st> <st c="14353">When we declare an array, we specify
    the number of elements it can hold, and this size cannot be changed during runtime.</st>
    <st c="14474">Static data structures are generally simpler to implement and access
    because their memory layout is predetermined, which can lead to efficient memory
    usage when the data size is known</st> <st c="14658">in advance.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14669">However, the main drawback of static data structures is their
    inflexibility.</st> <st c="14747">If the actual data size exceeds the predefined
    capacity, there is no way to expand the structure without reallocating memory
    and potentially moving data, which can be inefficient</st> <st c="14926">and cumbersome.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="14941">Dynamic data structures</st>*<st c="14965">, conversely, allow
    memory allocation to be adjusted at runtime.</st> <st c="15030">This</st> <st
    c="15034">means that the size of the data structure can grow or shrink as needed,
    depending on the operations being performed.</st> <st c="15152">Examples of dynamic
    data structures include linked lists, trees, and graphs.</st> <st c="15229">In
    a dynamic data structure, memory is allocated as elements are added and deallocated
    as they are removed, providing greater flexibility and efficient use of memory
    when dealing with data of unpredictable size or varying</st> <st c="15451">over
    time.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15461">Dynamic data structures are especially useful in scenarios where
    the amount of data cannot be determined beforehand, or when the data structure
    needs to accommodate varying amounts of data efficiently.</st> <st c="15664">However,
    this flexibility comes at the cost of additional overhead in managing memory allocation
    and pointers, which can lead to more complex implementations and potentially slower
    access times compared to static data structures.</st> <st c="15894">In</st> *<st
    c="15897">Chapters 12</st>* <st c="15908">and</st> *<st c="15913">13</st>*<st
    c="15915">, we will explore both static and dynamic data structures, focusing
    on their characteristics, advantages,</st> <st c="16021">and trade-offs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16036">Sequential versus random access</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="16068">The</st> <st c="16072">final classification of data structures
    is based on how data elements are accessed and retrieved.</st> <st c="16171">This
    classification divides data structures into those with sequential access and those
    with</st> <st c="16264">random access.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="16278">Sequential access data structures</st>* <st c="16312">are</st>
    <st c="16317">those where data elements are accessed in a specific, linear order.</st>
    <st c="16385">To retrieve a particular element, you must first traverse through
    the preceding elements.</st> <st c="16475">Examples of sequential access data
    structures include linked lists and queues.</st> <st c="16554">In these structures,
    accessing a specific element often requires iterating through a sequence of nodes
    or elements, which can make retrieval times longer, especially if the desired
    element is deep within</st> <st c="16758">a structure.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16770">Sequential access is often used in scenarios where the order of
    data elements is important or where data is processed in a linear fashion, such
    as in streaming applications or when data needs to be processed one element at
    a time.</st> <st c="17002">However, the primary limitation is that direct access
    to a specific element is not possible without traversing the sequence, which can
    be inefficient for</st> <st c="17156">large datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="17171">Random access data structures</st>*<st c="17201">, conversely,
    allow</st> <st c="17220">direct access to any data element without needing to
    traverse through others.</st> <st c="17299">This means that you can instantly
    retrieve or modify any element if you know its index or key.</st> <st c="17394">Examples
    of random-access data structures include arrays and hash tables.</st> <st c="17468">In
    an array, for instance, you can access any element directly by its index, making
    operations such as retrieval and updating</st> <st c="17594">very fast.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17604">Random access is highly beneficial when you need quick access
    to individual elements, especially in applications where speed is critical, such
    as in databases or real-time systems.</st> <st c="17786">However, this convenience
    comes with trade-offs, such as the need for continuous memory allocation in the
    case of arrays, which can lead to inefficient memory usage if the data structure
    is</st> <st c="17976">sparsely populated.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17995">In</st> [*<st c="17999">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="18009">, we will examine both sequential and random-access data structures,
    focusing on their use cases, advantages, and limitations.</st> <st c="18136">Understanding
    the access patterns of different data structures is crucial for designing algorithms
    that are both efficient and appropriate for the specific type of data they handle.</st>
    <st c="18318">The choice between sequential and random access can significantly
    impact the performance of an algorithm, particularly in terms of speed and</st>
    <st c="18459">resource utilization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18480">Abstract data types</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="18500">An</st> **<st c="18504">Abstract Data Type</st>** <st c="18522">(</st>**<st
    c="18524">ADT</st>**<st c="18527">) is</st> <st c="18533">a mathematical model
    for data types where the data type is defined by its behavior (operations), rather
    than its implementation.</st> <st c="18662">An ADT encapsulates data and the operations
    that can be performed on that data, abstracting away the implementation details.</st>
    <st c="18787">In other words, an ADT specifies what operations are possible and
    what their behavior is, but not how these operations</st> <st c="18906">are implemented.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18922">ADTs are fundamental in computer science because they allow developers
    to work with data in a more flexible and modular way.</st> <st c="19048">By defining
    operations without specifying implementation details, ADTs enable code to be more
    maintainable and adaptable to</st> <st c="19172">different contexts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19191">ADTs can be broadly categorized into several types, based on the
    operations they support and the use cases they address.</st> <st c="19313">Here
    are some</st> <st c="19327">common types:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="19340">List</st>**<st c="19345">: A</st> <st c="19350">list is an
    ADT that represents an ordered collection of elements, where each element has
    a specific position within the sequence.</st> <st c="19480">The primary operations
    for lists include insertion, deletion, access, and traversal of elements.</st>
    <st c="19577">Common examples of list implementations are arrays and linked lists.</st>
    <st c="19646">An array is a straightforward implementation in which elements are
    stored in contiguous memory locations, providing fast access by index.</st> <st
    c="19784">In contrast, a linked list is a more flexible implementation where each
    element (or node) points to the next, allowing dynamic resizing and easier insertion
    or deletion of elements.</st> <st c="19966">Lists are often used to manage ordered
    collections of items, such as a list of students, tasks in a to-do list, or a
    playlist of songs.</st> <st c="20102">Both arrays and linked lists will be discussed
    in</st> [*<st c="20152">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="20162">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20163">Stack</st>**<st c="20169">: A stack is</st> <st c="20183">an
    ADT that operates on the</st> **<st c="20211">Last-In-First-Out</st>** <st c="20228">(</st>**<st
    c="20230">LIFO</st>**<st c="20234">) principle, where</st> <st c="20254">the most
    recently added element is the first to be removed.</st> <st c="20314">The primary
    operations associated with a stack are</st> **<st c="20365">push</st>** <st c="20369">(adding
    an element to the top of the stack) and</st> **<st c="20418">pop</st>** <st c="20421">(removing
    the top element).</st> <st c="20450">One common example of a stack is the call
    stack, used by programming languages to track function calls and returns.</st>
    <st c="20566">Another prevalent use case is the undo mechanism in text editors,
    where a stack is used to revert to previous states.</st> <st c="20684">Stacks
    are also essential in parsing expressions in compilers, implementing backtracking
    algorithms such as solving mazes or puzzles, and managing nested function calls
    in recursion.</st> <st c="20867">Stacks will be reviewed in</st> [*<st c="20894">Chapter
    12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="20904">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="20905">Queue</st>**<st c="20911">: A</st> <st c="20916">queue is an
    ADT that operates on</st> <st c="20949">the</st> **<st c="20953">First-In-First-Out</st>**
    <st c="20971">(</st>**<st c="20973">FIFO</st>**<st c="20977">) principle, meaning
    the first element added is the first one to be removed.</st> <st c="21055">The
    primary operations associated with queues are</st> **<st c="21105">enqueue</st>**
    <st c="21112">(adding an element to the queue) and</st> **<st c="21150">dequeue</st>**
    <st c="21157">(removing an element from the queue).</st> <st c="21196">Queues
    have numerous applications in software programming and computer systems, such
    as managing print jobs in a print queue, where documents are processed in the
    order they are received, and in task scheduling within operating systems, where
    processes are handled in the order they are queued for execution.</st> <st c="21505">In</st>
    [*<st c="21508">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st c="21518">,
    we will review the major characteristics</st> <st c="21561">of Queues.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="21571">Deque (Double-Ended Queue</st>**<st c="21597">): A</st> <st
    c="21603">deque is an ADT that allows elements to be inserted and deleted from
    both ends of the sequence, effectively generalizing both stacks and queues.</st>
    <st c="21748">For example, the deque implementation in the</st> **<st c="21793">Standard
    Template Library</st>** <st c="21818">(</st>**<st c="21820">STL</st>**<st c="21823">)
    of</st> <st c="21829">C++ provides a flexible sequence container that can dynamically
    grow and shrink at either end.</st> <st c="21924">Another example is the circular
    buffer, a deque implementation commonly used in scenarios where data is cyclically
    added and removed.</st> <st c="22058">Deques are particularly useful in implementing
    features such as undo/redo in software applications such as text editors.</st>
    <st c="22179">They also play a crucial role in more advanced applications, such
    as managing sliding window problems in algorithms.</st> <st c="22296">Deque will
    be reviewed in detail in</st> [*<st c="22332">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="22342">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22343">Set</st>**<st c="22347">: A set</st> <st c="22355">is an ADT
    that represents a collection of unique elements, where the order of elements is
    not important.</st> <st c="22461">The key operations associated with sets include
    insertion, deletion, membership checks, and set operations such as union, intersection,
    and difference.</st> <st c="22613">Examples of set implementations include</st>
    **<st c="22653">HashSet</st>** <st c="22660">in Java, which ensures that a collection
    contains no duplicate elements, and</st> **<st c="22738">Set</st>** <st c="22741">in
    Python, which supports various mathematical operations such as union and intersection.</st>
    <st c="22832">Sets are widely used in scenarios such as managing collections of
    unique items (e.g., a list of students enrolled in a course), implementing operations
    that require uniqueness (e.g., removing duplicates from a list), and performing
    mathematical</st> <st c="23077">set operations.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="23092">Dictionary</st>**<st c="23103">: A dictionary, also</st> <st
    c="23125">referred to as a map or associative array, is an ADT that stores data
    as key-value pairs, with each key being unique and associated with a specific
    value.</st> <st c="23280">The primary operations include inserting new key-value
    pairs, deleting pairs, looking up values based on keys, and sometimes iterating
    over keys or values.</st> <st c="23436">Examples of dictionary implementations
    include</st> **<st c="23483">HashMap</st>** <st c="23490">in Java, which enables
    fast retrieval of values using unique keys, and</st> **<st c="23562">Dictionary</st>**
    <st c="23572">in Python, which offers a versatile way to map keys to values.</st>
    <st c="23636">Dictionaries are widely used in various applications, such as implementing
    lookup tables, managing configuration settings where each one is identified by
    a unique key, and storing and retrieving data by key, such as user profiles indexed
    by user ID.</st> <st c="23886">Detailed discussions on dictionaries are found
    in the</st> <st c="23940">next section.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="23953">Graph</st>**<st c="23959">: A graph is</st> <st c="23973">an
    ADT that represents a collection of nodes, known as vertices, which are connected
    by edges.</st> <st c="24068">Graphs can be either directed, where edges have a
    specific direction, or undirected, where edges have no direction.</st> <st c="24184">They
    can also contain cycles.</st> <st c="24214">Common operations on graphs include
    adding vertices, adding edges, and traversing the structure.</st> <st c="24311">Graphs
    are typically implemented using an adjacency list, where each node has a list
    of its neighboring nodes, or an adjacency matrix, a 2D array that indicates the
    presence or absence of edges between nodes.</st> <st c="24520">Graphs are</st>
    <st c="24531">widely used in various fields of science and engineering, including
    modeling networks such as social networks, communication networks, and transportation
    systems.</st> <st c="24694">Graphs are discussed further in</st> [*<st c="24726">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="24736">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24737">Tree</st>**<st c="24742">: A tree</st> <st c="24751">is a hierarchical
    ADT where elements are arranged in nodes, starting with a single root node that
    branches out into child nodes, forming subtrees.</st> <st c="24899">Trees can
    be of various types, such as binary trees, where each node has at most two children,
    or more complex structures such as B-trees.</st> <st c="25038">Examples include</st>
    <st c="25054">the</st> **<st c="25059">Binary Search Tree</st>** <st c="25077">(</st>**<st
    c="25079">BST</st>**<st c="25082">) and the Heap.</st> <st c="25099">In a BST,
    each node can have up to two children, with the left child being smaller than
    the parent and the right child being larger.</st> <st c="25232">The Heap is a
    specialized tree structure that adheres to the</st> **<st c="25293">heap</st>**
    <st c="25297">property, commonly used to implement priority queues.</st> <st c="25352">We
    will discuss trees in</st> [*<st c="25377">Chapter 13</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="25387">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25388">ADTs allow programmers to focus on what operations can be performed
    on data, rather than how these operations are implemented.</st> <st c="25516">This
    abstraction leads to more flexible, maintainable, and reusable code.</st> <st
    c="25590">ADTs such as lists, stacks, queues, sets, maps, graphs, and trees are
    foundational to computer science, each serving specific use cases based on the
    nature o</st><st c="25747">f the data and</st> <st c="25763">operations required.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25783">Now that we have an understanding of data structure classifications
    and abstract data types, the next section will focus on the major operations that
    can be performed on data structures.</st> <st c="25971">We will begin by introducing
    an abstract data structure known as</st> <st c="26036">a</st> *<st c="26038">dictionary</st>*<st
    c="26048">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26049">Dictionaries</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="26062">Dictionaries</st> <st c="26076">are abstract data structures designed
    to store data in a key-value format.</st> <st c="26151">In a dictionary, each
    element consists of a key that is unique and used to access the associated value.</st>
    <st c="26255">The key-value pairing allows for rapid lookups, which is one of
    the prima</st><st c="26328">ry advantages of using dictionaries.</st> <st c="26366">Dictionaries
    are also commonly referred to as maps, associative arrays, or</st> <st c="26441">symbol
    tables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26455">While our focus</st> <st c="26471">has been on logical data structures,
    it’s worth noting that dictionaries can also be implemented directly in hardware
    through what is known as associative</st> <st c="26627">memory, or</st> **<st
    c="26638">Content-Addressable</st>** **<st c="26658">Memory</st>** <st c="26664">(</st>**<st
    c="26666">CAM</st>**<st c="26669">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26672">Associative memories are used for ultra-high-speed search operations.</st>
    <st c="26743">As you might expect, with associative memory, any search operation
    can be executed in constant time,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1790.png)<st
    c="26844"><st c="26845">. Although employing associative memories may seem costly
    and impractical for general algorithmic use, a more feasible approach in software
    is the use of hashing.</st> <st c="27008">Hashing, which was discussed in</st>
    [*<st c="27040">Chapter 7</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="27049">, provides an algorithmic method to implement a content-addressable
    data structure, allowing for efficient lookups and</st> <st c="27168">other operations.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27185">The key</st> <st c="27194">properties of dictionaries include</st>
    <st c="27229">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27243">In most implementa</st><st c="27262">tions, dictionaries do not
    maintain any particular order of the key-value pairs.</st> <st c="27344">The elements
    are stored in an arbitrary order based on the</st> **<st c="27403">hash</st>**
    <st c="27407">function</st> <st c="27417">used internally.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27433">Each key in a dictionary is unique.</st> <st c="27470">If you
    attempt to insert a new key-value pair with a key that already exists in the dictionary,
    the existing value is typically overwritten with the</st> <st c="27619">new value.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27629">The primary operations on a dictionary – such as inserting, deleting,
    and accessing elements – are typically performed in average-case</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1791.png)
    <st c="27765"><st c="27766">time due to the underlying hash table implementation.</st>
    <st c="27821">This makes dictionaries extremely efficient for large datasets where
    fast lookups</st> <st c="27903">are required.</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27916">The question is how</st> <st c="27937">to implement and maintain
    dictionaries.</st> <st c="27977">Fortunately, many programming languages provide
    built-in support for dictionaries.</st> <st c="28060">Here’s a simple example
    of how dictionaries can be used</st> <st c="28116">in Python:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28976">This example</st> <st c="28990">demonstrates the basic operations
    of a dictionary in Python, showcasing how easy it is to create, manipulate, and
    access data using this powerful data structure.</st> <st c="29152">Let’s briefly
    explain</st> <st c="29174">the code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="29183">Creating a dictionary</st>**<st c="29205">: We define a dictionary,</st>
    **<st c="29232">student_info</st>**<st c="29244">, with key-value pairs representing
    various attributes of</st> <st c="29302">a student.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="29312">Accessing values</st>**<st c="29329">: We access the values
    associated with the</st> **<st c="29373">name</st>** <st c="29377">and</st> **<st
    c="29382">age</st>** <st c="29385">keys using</st> <st c="29397">square brackets.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="29413">Adding a key-value pair</st>**<st c="29437">: We add a new
    key,</st> **<st c="29458">graduation_year</st>**<st c="29473">, with its</st>
    <st c="29484">corresponding value.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="29504">Updating a value</st>**<st c="29521">: We update the value
    associated with the</st> **<st c="29564">GPA</st>** <st c="29567">key.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="29572">Deleting a key-value pair</st>**<st c="29598">: We remove the</st>
    **<st c="29615">major</st>** <st c="29620">key and its value using the</st> **<st
    c="29649">del</st>** <st c="29652">statement.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="29663">Iterating over the dictionary</st>**<st c="29693">: We iterate
    over the dictionary using a</st> **<st c="29735">for</st>** <st c="29738">loop,
    printing each</st> <st c="29759">key-value pair.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29774">As we</st> <st c="29781">illustrated in the previous example,
    dictionaries are more than just collections of key-value pairs; they also support
    a range of fundamental operations that allow for efficient data management.</st>
    <st c="29976">These basic operations include insertion, search, update (or edit),
    and deletion.</st> <st c="30058">Let’s explore each of these functions in detail
    with examples</st> <st c="30120">in Python.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30130">Insertion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="30140">Insertion</st>* <st c="30150">involves</st> <st c="30159">adding
    a new key-value pair to the dictionary.</st> <st c="30207">If the key already
    exists, the value associated with that key is updated; otherwise, a new entry
    is created.</st> <st c="30316">The following is an insertion function for a simple
    dictionary</st> <st c="30379">in Python:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="30601">In this example, we create an empty dictionary called</st> `<st
    c="30656">student_grades</st>` <st c="30670">and insert two key-value pairs –</st>
    `<st c="30704">Alice: 85</st>` <st c="30713">and</st> `<st c="30718">Bob: 90</st>`<st
    c="30725">. The dictionary now holds these values, and new</st> <st c="30773">entries
    can be</st> <st c="30789">added similarly.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30805">Search</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="30812">Search</st>* <st c="30819">is the</st> <st c="30827">operation
    of retrieving a value associated with a specific key.</st> <st c="30891">This
    is one of the most common and efficient operations on a dictionary, typically
    performed in constant time.</st> <st c="31002">Let’s look at a simple search function
    in</st> <st c="31044">a dictionary:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31371">Here, the</st> `<st c="31382">get</st>` <st c="31385">method is
    used to search for the value associated with the</st> `<st c="31445">Alice</st>`
    <st c="31450">key.</st> <st c="31456">If the key exists, the corresponding value
    is returned.</st> <st c="31512">If the key is not found, as in the case of</st>
    `<st c="31555">Charlie</st>`<st c="31562">, a default value (</st>`<st c="31581">"Not
    Found"</st>`<st c="31593">) can be</st> <st c="31603">returned instead.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31620">Update</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="31627">Update</st>* <st c="31634">involves</st> <st c="31644">changing
    the value associated with an existing key in the dictionary.</st> <st c="31714">If
    the key exists, its value is modified; if the key does not exist, a new key-value
    pair is added.</st> <st c="31814">The following is one example</st> <st c="31843">of
    updating:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="32127">In this example, the</st> <st c="32148">value associated with
    the</st> `<st c="32175">Alice</st>` <st c="32181">key is updated from 85 to 88\.</st>
    <st c="32211">Additionally, a new key-value pair,</st> `<st c="32247">Charlie:
    92</st>`<st c="32258">, is added to</st> <st c="32272">the dictionary.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32287">Deletion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="32296">Deletion</st>* <st c="32305">removes</st> <st c="32314">a key-value
    pair from the dictionary.</st> <st c="32352">Once removed, the key and its associated
    value no longer exist in the dictionary.</st> <st c="32434">Take a look at the</st>
    <st c="32453">following example:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32761">In this example, the</st> `<st c="32783">del</st>` <st c="32786">statement
    is used to remove the</st> `<st c="32819">"Bob"</st>` <st c="32824">key and its
    associated value from the dictionary.</st> <st c="32875">Additionally, the</st>
    `<st c="32893">pop</st>` <st c="32896">method is used to attempt to remove the</st>
    `<st c="32937">David</st>` <st c="32942">key, which does not exist in the dictionary,
    returning a default message,</st> `<st c="33017">Key</st>` `<st c="33021">not
    found</st>`<st c="33030">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33031">These basic operations – insertion, search, update, and deletion
    – are essential for working with dictionaries in any programming language.</st>
    <st c="33172">They allow efficient management of data and enable you to create
    dynamic and adaptable programs.</st> <st c="33269">Whether we are adding new data,
    retrieving existing information, modifying values, or removing entries, these
    functions make dictionaries a versatile and powerful tool in algorithm design
    and everyday</st> <st c="33470">programming tasks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33488">In</st> *<st c="33492">Chapters 12</st>* <st c="33503">and</st>
    *<st c="33508">13</st>*<st c="33510">, as we introduce various data structures,
    we will evaluate their performance as they relate to these fundamental operations.</st>
    <st c="33636">Additionally, some data structures include extended functions and
    specific operations, such as finding successor and predecessor</st> <st c="33765">in
    BSTs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33773">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="33781">In this chapter, the foundational concepts of data structures
    were explored, with a focus on their classification and the ess</st><st c="33907">ential
    operations that can be performed on them.</st> <st c="33957">The chapter discussed
    the distinctions between physical and logical data structures, as well as between
    primitive and composite structures.</st> <st c="34097">It also covered the differences
    between linear and non-linear data structures, along with the implications of
    static versus dynamic data allocation, and sequential versus random access.</st>
    <st c="34283">Through these discussions, the importance of selecting the appropriate
    data structure for specific algorithmic tasks</st> <st c="34400">was emphasized.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34415">The chapter also provided insights into the workings of dictionaries,
    highlighting their key operations, such as insertion, search, update, and deletion,
    with examples to demonstrate their practical usage.</st> <st c="34622">The discussion
    underscored the role of dictionaries as a versatile and efficient tool in</st>
    <st c="34711">algorithm design.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34728">As we move forward, the next chapter will delve into linear data
    structures, including arrays and linked lists, and we will examine their properties
    and use cases in</st> <st c="34895">greater detail.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34910">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="34941">Introduction to Algorithms</st>* <st c="34968">by Thomas H.</st>
    <st c="34982">Cormen, Charles E.</st> <st c="35001">Leiserson, Ronald L.</st>
    <st c="35022">Rivest, and Clifford Stein.</st> <st c="35050">Fourth Edition.</st>
    <st c="35066">MIT</st> <st c="35070">Press.</st> <st c="35077">2022:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="35082">Chapter 10</st>*<st c="35093">,</st> *<st c="35095">Elementary</st>*
    *<st c="35106">Data Structures</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="35121">Algorithms</st>* <st c="35132">by R.</st> <st c="35139">Sedgewick,
    K.</st> <st c="35153">Wayne.</st> <st c="35160">Fourth Edition.</st> <st c="35176">Addison-Wesley.</st>
    <st c="35192">2011:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="35197">Chapter</st>* *<st c="35206">1</st>*<st c="35207">,</st> *<st
    c="35209">Fundamentals</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="35221">Data Structures and Algorithm Analysis in C++</st>* <st c="35267">by
    Mark A.</st> <st c="35279">Weiss.</st> <st c="35286">Fourth Edition.</st> <st
    c="35302">Pearson.</st> <st c="35311">2012:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="35316">Chapter 3</st>*<st c="35326">,</st> *<st c="35328">Lists, Stacks,</st>*
    *<st c="35343">and Queues</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
