<html><head></head><body>
		<div id="_idContainer1879" epub:type="chapter" class="calibre2">
			<h1 id="_idParaDest-158" class="chapter-number"><a id="_idTextAnchor187" class="pcalibre pcalibre1 calibre6"/><st c="0">12</st></h1>
			<h1 id="_idParaDest-159" class="calibre5"><a id="_idTextAnchor188" class="pcalibre pcalibre1 calibre6"/><st c="3">Linear Data Structures</st></h1>
			<p class="calibre3"><st c="26">In this chapter, we will explore the foundational concepts of </st><strong class="bold"><st c="89">linear data structures</st></strong><st c="111">, which play a</st><a id="_idIndexMarker715" class="pcalibre pcalibre1 calibre6"/><st c="125"> critical role in computer science and algorithm design. </st><st c="182">We will start by understanding the basics of arrays and linked lists and learning how these structures store and manage data. </st><st c="308">The chapter will guide you through the key operations performed on these structures, such as insertion, deletion, and searching, and you will examine their time complexities to understand their efficiency. </st><st c="514">By comparing arrays and linked lists, you will gain insight into the trade-offs involved in choosing the right data structure for </st><span><st c="644">specific applications.</st></span></p>
			<p class="calibre3"><st c="666">As we progress, we will discover more advanced linear data structures such as stacks, queues, and </st><strong class="bold"><st c="765">double-ended queues</st></strong><st c="784"> (</st><strong class="bold"><st c="786">deques</st></strong><st c="792">). </st><st c="796">We </st><a id="_idIndexMarker716" class="pcalibre pcalibre1 calibre6"/><st c="799">will learn how these structures extend the functionality of basic lists and how they are applied in real-world scenarios, such as task scheduling and resource management. </st><st c="970">Additionally, the chapter will introduce you to </st><strong class="bold"><st c="1018">skip lists</st></strong><st c="1028">, a </st><a id="_idIndexMarker717" class="pcalibre pcalibre1 calibre6"/><st c="1032">probabilistic data structure that offers a balance between the efficiency of arrays and the flexibility of linked lists. </st><st c="1153">By the end of this chapter, you will be well-equipped with the knowledge needed to implement and utilize these linear data </st><span><st c="1276">structures effectively.</st></span></p>
			<p class="calibre3"><st c="1299">Essentially, this chapter will cover the </st><span><st c="1341">following topics:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><span><st c="1358">Lists</st></span></li>
				<li class="calibre13"><span><st c="1364">Skip lists</st></span></li>
				<li class="calibre13"><span><st c="1375">Stacks</st></span></li>
				<li class="calibre13"><span><st c="1382">Queue</st></span></li>
				<li class="calibre13"><span><st c="1388">Deque</st></span></li>
			</ul>
			<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor189" class="pcalibre pcalibre1 calibre6"/><st c="1394">Lists</st></h1>
			<p class="calibre3"><st c="1400">A </st><strong class="bold"><st c="1403">list</st></strong><st c="1407"> is </st><a id="_idIndexMarker718" class="pcalibre pcalibre1 calibre6"/><st c="1411">an ordered collection of items that can hold elements of the same or different types, where each element is indexed and has a specific position within the list. </st><st c="1572">Lists are commonly used to store sequences of data that can be easily accessed, inserted, or removed. </st><st c="1674">They can hold elements of different types, though in some programming languages, lists are more often homogeneous, meaning all elements are of the </st><span><st c="1821">same type.</st></span></p>
			<p class="calibre3"><st c="1831">Lists are generally implemented using either arrays or linked structures, and these two approaches result in distinct characteristics regarding performance and memory usage. </st><st c="2006">When elements in a list are stored in contiguous memory locations, the list is known as an </st><strong class="bold"><st c="2097">array</st></strong><st c="2102">. In</st><a id="_idIndexMarker719" class="pcalibre pcalibre1 calibre6"/><st c="2106"> this case, accessing elements by index is very efficient, typically taking constant time (</st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="2197"/><st c="2199">), since the memory location of any element can be directly computed. </st><st c="2269">However, arrays have a fixed size once they are created, which can lead to inefficiencies if the number of elements changes frequently, requiring the creation of new arrays and copying </st><span><st c="2454">of data.</st></span></p>
			<p class="calibre3"><st c="2462">On the other hand, if the list is implemented using linked structures, it is referred to as a </st><strong class="bold"><st c="2557">linked list</st></strong><st c="2568">. In a</st><a id="_idIndexMarker720" class="pcalibre pcalibre1 calibre6"/><st c="2574"> linked list, each element, known as</st><a id="_idIndexMarker721" class="pcalibre pcalibre1 calibre6"/><st c="2610"> a </st><strong class="bold"><st c="2613">node</st></strong><st c="2617">, contains a reference (or link) to the next node in the sequence. </st><st c="2684">This structure allows the list to grow and shrink dynamically as elements are added or removed, without the need for large blocks of contiguous memory. </st><st c="2836">However, because the nodes are scattered throughout memory, accessing an element by index requires traversing the list from the beginning, which can be time-consuming (</st><img src="image/450.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre364"/><st c="3004"/><st c="3006"> in the </st><span><st c="3014">worst case).</st></span></p>
			<p class="calibre3"><st c="3026">The choice between using an array or a linked list depends on the specific needs of the application, such as the frequency of insertions and deletions versus the need for quick access to elements. </st><st c="3224">Arrays are generally preferred when fast access and predictable memory usage are crucial, while linked lists are more suitable for scenarios where dynamic resizing and frequent modifications are needed. </st><st c="3427">In the following subsections, we will explore the key characteristics of arrays, particularly in relation to algorithm efficiency and the various operations that can be performed </st><span><st c="3606">on them.</st></span></p>
			<h2 id="_idParaDest-161" class="calibre5"><a id="_idTextAnchor190" class="pcalibre pcalibre1 calibre6"/><st c="3614">Arrays</st></h2>
			<p class="calibre3"><st c="3621">An </st><strong class="bold"><st c="3625">array</st></strong><st c="3630"> is </st><a id="_idIndexMarker722" class="pcalibre pcalibre1 calibre6"/><st c="3634">a fundamental data structure that consists of a collection of elements, each identified by </st><a id="_idIndexMarker723" class="pcalibre pcalibre1 calibre6"/><st c="3725">at least one array index or key. </st><st c="3758">Arrays are one of the simplest and most widely used data structures in computer science. </st><st c="3847">They are typically used to store a fixed-size sequence of elements of the same type. </st><st c="3932">The position of each element is defined by its index, which usually starts </st><span><st c="4007">from zero.</st></span></p>
			<p class="calibre3"><st c="4017">Arrays possess the</st><a id="_idIndexMarker724" class="pcalibre pcalibre1 calibre6"/><st c="4036"> following </st><a id="_idIndexMarker725" class="pcalibre pcalibre1 calibre6"/><st c="4047">defining characteristics that influence their behavior </st><span><st c="4102">and performance:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="4118">Fixed size</st></strong><st c="4129">: Once an array is created, its size is set and cannot be altered. </st><st c="4197">This means that the number of elements that an array can hold is predetermined at the time of its creation. </st><st c="4305">For example, in most programming languages, we must specify the size of an array when it is declared, such as </st><strong class="source-inline1"><st c="4415">int[] a = new int[10];</st></strong><st c="4437"> in Java, which creates an array that can hold 10 integers. </st><st c="4497">The following is a simple array declaration </st><span><st c="4541">in Python:</st></span><pre class="source-code"><st c="4551" class="calibre11">
# Define an array (list) of integers
a = [10, 20, 30, 40, 50]
# Print the array
print(a)  # Outputs: [10, 20, 30, 40, 50]</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="4672">Contiguous memory allocation</st></strong><st c="4701">: The elements of an array are stored in contiguous memory locations. </st><st c="4772">This enables efficient access to any element by calculating its memory address using a simple mathematical formula. </st><st c="4888">For instance, in a one-dimensional array </st><em class="italic"><st c="4929">a</st></em><st c="4930"> of size </st><img src="image/477.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre386"/><st c="4939"/><st c="4940">, the address of the element </st><em class="italic"><st c="4969">a[i]</st></em><st c="4973"> can be calculated as </st><img src="image/1795.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;*&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1322"/><st c="4995"/><st c="5013">, where </st><img src="image/1796.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;b&lt;/mml:mi&gt;&lt;mml:mi&gt;a&lt;/mml:mi&gt;&lt;mml:mi&gt;s&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1323"/><st c="5021"/><st c="5026"> is the base memory address, </st><img src="image/701.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;i&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1324"/><st c="5054"/><st c="5055"> is the index of the element in the array </st><em class="italic"><st c="5097">a</st></em><st c="5098">, and </st><img src="image/1798.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;l&lt;/mml:mi&gt;&lt;mml:mi&gt;e&lt;/mml:mi&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mi&gt;g&lt;/mml:mi&gt;&lt;mml:mi&gt;t&lt;/mml:mi&gt;&lt;mml:mi&gt;h&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1325"/><st c="5104"/><st c="5111"> is the size of each element in the array. </st><st c="5153">For example, it is 1 for 1 byte, 2 for 16 bits or words, and so on. </st><em class="italic"><st c="5221">Table 12.1</st></em><st c="5231"> illustrates a simple example of </st><span><st c="5264">an array.</st></span></li>
			</ul>
			<table id="table001-6" class="t---table">
				<colgroup class="calibre51">
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
					<col class="calibre52"/>
				</colgroup>
				<tbody class="calibre54">
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="5273">Memory address</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5288">FF01</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5293">FF02</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5298">FF03</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5303">FF04</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5308">FF05</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5313">FF06</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="5318">Content</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5326">23</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5329">123</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5333">54</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5336">67</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5339">34</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><span><st c="5342">87</st></span></p>
						</td>
					</tr>
					<tr class="t---table1">
						<td class="t---table2">
							<p class="calibre3"><span><st c="5345">Index</st></span></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="5351">0</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="5353">1</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="5354">2</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="5355">3</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="5356">4</st></p>
						</td>
						<td class="t---table2">
							<p class="calibre3"><st c="5357">5</st></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="5358">Table 12.1: An example array</st></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="5386">Homogeneous elements</st></strong><st c="5407">: All elements in an array must be of the same data type, ensuring that the array is a uniform collection. </st><st c="5515">For example, an array of integers </st><strong class="source-inline1"><st c="5549">int[]</st></strong><st c="5554"> can only store integer values, and an array of strings </st><strong class="source-inline1"><st c="5610">String[]</st></strong><st c="5618"> can only store </st><span><st c="5634">string values.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="5648">Indexed access</st></strong><st c="5663">: Arrays</st><a id="_idIndexMarker726" class="pcalibre pcalibre1 calibre6"/><st c="5672"> allow direct access to any element using its index, providing constant-time access, which is one of the key advantages of this data structure. </st><st c="5816">Accessing the third element in an array </st><em class="italic"><st c="5856">a</st></em><st c="5857"> is as simple as </st><span><em class="italic"><st c="5874">a</st></em></span><span><st c="5875"> [2].</st></span></li>
			</ul>
			<p class="calibre3"><st c="5880">Arrays </st><a id="_idIndexMarker727" class="pcalibre pcalibre1 calibre6"/><st c="5888">support a variety of operations, each with its own performance implications. </st><st c="5965">Here are the</st><a id="_idIndexMarker728" class="pcalibre pcalibre1 calibre6"/><st c="5977"> major operations commonly performed on arrays, along with their </st><span><st c="6042">time complexities:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="6060">Insertion</st></strong><st c="6070">: This </st><a id="_idIndexMarker729" class="pcalibre pcalibre1 calibre6"/><st c="6078">refers to adding a new element to the array. </st><st c="6123">For example, consider </st><strong class="source-inline1"><st c="6145">a = [1, 2, 3, 4]</st></strong><st c="6161">. Inserting </st><strong class="source-inline1"><st c="6173">5</st></strong><st c="6174"> at the end of the array is straightforward if there is space. </st><st c="6237">However, inserting </st><strong class="source-inline1"><st c="6256">5</st></strong><st c="6257"> at index </st><strong class="source-inline1"><st c="6267">1</st></strong><st c="6268"> requires shifting all elements from index </st><strong class="source-inline1"><st c="6311">1</st></strong><st c="6312"> to the right. </st><st c="6327">The time complexity of insertion in arrays is </st><img src="image/1799.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1326"/><st c="6373"/><st c="6374"> in the best case and </st><img src="image/1294.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre979"/><st c="6396"/><st c="6397"> in the worst case. </st><st c="6417">The best case is inserting at the end in a partially filled array. </st><st c="6484">If inserting at the beginning or middle, requires shifting of elements, it is the worst case. </st><st c="6578">The following is a </st><span><st c="6597">Python example:</st></span><pre class="source-code"><st c="6612" class="calibre11">
a = [1, 2, 3, 4]
a.insert(1, 5)  # a becomes [1, 5, 2, 3, 4]
print(a)</st></pre><p class="calibre3"><st c="6681">Since Python uses zero-based indexing, the </st><strong class="source-inline"><st c="6725">a.insert(1, 5)</st></strong><st c="6739"> operation inserts the value into the second position of </st><span><st c="6796">the array.</st></span></p></li>				<li class="calibre13"><strong class="bold"><st c="6806">Deletion</st></strong><st c="6815">: This </st><a id="_idIndexMarker730" class="pcalibre pcalibre1 calibre6"/><st c="6823">involves removing an element from the array. </st><st c="6868">Given </st><strong class="source-inline1"><st c="6874">a = [1, 2, 3, 4]</st></strong><st c="6890">, deleting element </st><strong class="source-inline1"><st c="6909">2</st></strong><st c="6910"> at index </st><strong class="source-inline1"><st c="6920">1</st></strong><st c="6921"> requires shifting all elements after index </st><strong class="source-inline1"><st c="6965">1</st></strong><st c="6966"> to the left to fill the gap. </st><st c="6996">In the best case, deleting the last element has a time complexity of </st><img src="image/1425.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1067"/><st c="7065"/><st c="7066">. However, if we delete an element from the beginning or middle of the array, it requires shifting the subsequent elements, resulting </st><a id="_idIndexMarker731" class="pcalibre pcalibre1 calibre6"/><st c="7200">in a worst-case time complexity </st><span><st c="7232">of </st></span><span><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="7235"/></span><span><st c="7236">:</st></span><pre class="source-code"><st c="7237" class="calibre11">
a = [1, 2, 3, 4]
a.pop(1)  # a becomes [1, 3, 4]</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="7285">Edit or update</st></strong><st c="7300">: Editing is </st><a id="_idIndexMarker732" class="pcalibre pcalibre1 calibre6"/><st c="7314">modifying an existing element in the array. </st><st c="7358">Given </st><strong class="source-inline1"><st c="7364">a = [1, 2, 3, 4]</st></strong><st c="7380">, changing the element at index </st><strong class="source-inline1"><st c="7412">2</st></strong><st c="7413"> from </st><strong class="source-inline1"><st c="7419">3</st></strong><st c="7420"> to </st><strong class="source-inline1"><st c="7424">5</st></strong><st c="7425"> is a direct </st><a id="_idIndexMarker733" class="pcalibre pcalibre1 calibre6"/><st c="7438">operation. </st><st c="7449">We can directly access the element by its index and update it, which makes its time </st><span><st c="7533">complexity </st></span><span><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="7544"/></span><span><st c="7545">:</st></span><pre class="source-code"><st c="7546" class="calibre11">
a = [1, 2, 3, 4]
a[2] = 5  # a becomes [1, 2, 5, 4]</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="7597">Search</st></strong><st c="7604">: Searching</st><a id="_idIndexMarker734" class="pcalibre pcalibre1 calibre6"/><st c="7616"> involves finding a specific element within an array. </st><st c="7670">This topic was covered extensively in </st><a href="B22248_07_split_000.xhtml#_idTextAnchor103" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="7708">Chapter 7</st></em></span></a><st c="7717">, where most of the search algorithms discussed were based on arrays as the underlying data structure. </st><st c="7820">In </st><a href="B22248_13.xhtml#_idTextAnchor200" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="7823">Chapter 13</st></em></span></a><st c="7833">, we will explore how searching can be performed on non-linear data structures, such </st><span><st c="7918">as trees.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="7927">Access</st></strong><st c="7934">: Access </st><a id="_idIndexMarker735" class="pcalibre pcalibre1 calibre6"/><st c="7944">refers to retrieving the value of an element at a specific index </st><a id="_idIndexMarker736" class="pcalibre pcalibre1 calibre6"/><st c="8009">in an array. </st><st c="8022">One of the key advantages of arrays is that their access time is constant (</st><img src="image/1804.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1327"/><st c="8097"/><st c="8099">), allowing any element to be directly retrieved by its index without the need </st><span><st c="8178">for traversal.</st></span></li>
			</ul>
			<p class="calibre3"><st c="8192">Arrays can be implemented in more sophisticated structures. </st><st c="8253">One example is </st><strong class="bold"><st c="8268">dynamic arrays</st></strong><st c="8282"> (such as </st><strong class="source-inline"><st c="8292">list</st></strong><st c="8296"> in Python). </st><st c="8309">These</st><a id="_idIndexMarker737" class="pcalibre pcalibre1 calibre6"/><st c="8314"> arrays can resize themselves when elements are added beyond the initial capacity. </st><st c="8397">However, the underlying principle remains the same, with arrays providing efficient access and traversal. </st><st c="8503">Another</st><a id="_idIndexMarker738" class="pcalibre pcalibre1 calibre6"/><st c="8510"> example is </st><strong class="bold"><st c="8522">multidimensional arrays</st></strong><st c="8545">. These arrays can be extended into multiple dimensions, such as 2D arrays (matrices) or 3D arrays, which are particularly useful in applications such as image processing, scientific simulations, and game development. </st><st c="8763">The following is an example 2D array </st><span><st c="8800">in Python:</st></span></p>
			<pre class="source-code"><st c="8810" class="calibre11">
matrix = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9]
]
print(matrix[1][2])  # Outputs: 6 (element at second row, third column)</st></pre>			<p class="calibre3"><strong class="bold"><st c="8926">Arrays</st></strong><st c="8933"> are a</st><a id="_idIndexMarker739" class="pcalibre pcalibre1 calibre6"/><st c="8939"> fundamental </st><a id="_idIndexMarker740" class="pcalibre pcalibre1 calibre6"/><st c="8952">and highly efficient data structure for storing and managing collections of elements, especially when the size of the collection is known and remains constant. </st><st c="9112">Their contiguous memory allocation allows for fast access and straightforward implementation of various operations. </st><st c="9228">However, their fixed size and potential inefficiencies in insertion and deletion make them less flexible compared to other data structures such as linked lists. </st><st c="9389">Understanding the trade-offs and appropriate use cases for arrays is essential for effective algorithm design </st><span><st c="9499">and implementation.</st></span></p>
			<h2 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor191" class="pcalibre pcalibre1 calibre6"/><st c="9518">Linked lists</st></h2>
			<p class="calibre3"><st c="9531">A </st><strong class="bold"><st c="9534">linked list</st></strong><st c="9545"> is a</st><a id="_idIndexMarker741" class="pcalibre pcalibre1 calibre6"/><st c="9550"> linear</st><a id="_idIndexMarker742" class="pcalibre pcalibre1 calibre6"/><st c="9557"> data structure in which elements, called nodes, are arranged sequentially. </st><st c="9633">Unlike arrays, linked lists do not store their elements in contiguous memory locations. </st><st c="9721">Instead, each node in a linked list contains at least two parts: the data and a reference (or pointer) to the next node in the sequence. </st><st c="9858">This structure allows linked lists to be dynamic in size, easily growing or shrinking as elements are added </st><span><st c="9966">or removed.</st></span></p>
			<p class="calibre3"><st c="9977">Linked lists have several</st><a id="_idIndexMarker743" class="pcalibre pcalibre1 calibre6"/><st c="10003"> key characteristics that distinguish them from other data structures such </st><span><st c="10078">as arrays:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="10088">Dynamic size</st></strong><st c="10101">: Linked lists can dynamically increase or decrease in size, as nodes can be added or removed as needed without reallocating or reorganizing the entire data structure. </st><st c="10270">For example, we can continue adding nodes to a linked list without worrying about a </st><span><st c="10354">predefined size.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="10370">Non-contiguous memory allocation</st></strong><st c="10403">: Unlike arrays, linked lists do not require contiguous memory locations. </st><st c="10478">Each node is stored independently in memory and linked together using pointers. </st><st c="10558">For instance, in a singly linked list, each node contains a pointer to the next node, allowing elements to be scattered </st><span><st c="10678">throughout memory.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="10696">Sequential access</st></strong><st c="10714">: Linked lists must be accessed sequentially from the beginning, as there is no direct way to access a specific element by index. </st><st c="10845">For example, to access the third element in a linked list, we must traverse the first </st><span><st c="10931">two nodes.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="10941">Variants</st></strong><st c="10950">: Linked lists</st><a id="_idIndexMarker744" class="pcalibre pcalibre1 calibre6"/><st c="10965"> come in different forms, including singly linked lists (where each node points to the next), doubly linked lists (where each node points to both the next and previous nodes), and circular linked lists (where the last node points back to the first). </st><st c="11215">For example, in a doubly linked list, traversal can happen in both directions due to the pointers to both the previous and </st><span><st c="11338">next nodes.</st></span></li>
			</ul>
			<p class="calibre3"><st c="11349">Linked lists support various operations, each with specific performance characteristics. </st><st c="11439">Let’s review the major operations, along with their time complexities </st><span><st c="11509">and examples.</st></span></p>
			<h3 class="calibre8"><st c="11522">Insertion in a linked list</st></h3>
			<p class="calibre3"><st c="11549">Consider</st><a id="_idIndexMarker745" class="pcalibre pcalibre1 calibre6"/><st c="11558"> this linked list: </st><strong class="source-inline"><st c="11577">24</st></strong><st c="11579"> → </st><strong class="source-inline"><st c="11582">3</st></strong><st c="11583"> → </st><strong class="source-inline"><st c="11586">12</st></strong><st c="11588"> → </st><strong class="source-inline"><st c="11591">17</st></strong><st c="11593">. If we want to insert the value </st><strong class="source-inline"><st c="11626">8</st></strong><st c="11627"> between </st><strong class="source-inline"><st c="11636">3</st></strong><st c="11637"> and </st><strong class="source-inline"><st c="11642">12</st></strong><st c="11644">, the process involves creating a new node with the value </st><strong class="source-inline"><st c="11702">3</st></strong><st c="11703"> and updating the pointers accordingly. </st><st c="11743">Here’s how we can do it step </st><span><st c="11772">by step:</st></span></p>
			<ol class="calibre12">
				<li class="calibre13"><strong class="bold"><st c="11780">Create the new node</st></strong><st c="11800">: First, we create a new node that contains the value </st><strong class="source-inline1"><st c="11855">8</st></strong><st c="11856">. Initially, the pointer of this new node is set to </st><strong class="source-inline1"><st c="11908">null</st></strong><st c="11912">, as it does not point to </st><span><st c="11938">anything yet.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="11951">Update the pointer of the new node</st></strong><st c="11986">: Next, set the pointer of the new node to point to the node that comes after </st><strong class="source-inline1"><st c="12065">3</st></strong><st c="12066">, which is the node containing </st><strong class="source-inline1"><st c="12097">12</st></strong><st c="12099">. Now, the new node </st><strong class="source-inline1"><st c="12119">3</st></strong><st c="12120"> is connected to </st><span><st c="12137">node </st></span><span><strong class="source-inline1"><st c="12142">4</st></strong></span><span><st c="12143">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="12144">Update the pointer of the previous node</st></strong><st c="12184">: Finally, update the pointer of the node containing </st><strong class="source-inline1"><st c="12238">3</st></strong><st c="12239"> to point to the new node </st><strong class="source-inline1"><st c="12265">8</st></strong><st c="12266">. This completes the insertion, resulting in the linked </st><strong class="source-inline1"><st c="12322">list 24</st></strong><st c="12329"> → </st><strong class="source-inline1"><st c="12332">3</st></strong><st c="12333"> → </st><strong class="source-inline1"><st c="12336">8</st></strong><st c="12337"> → </st><strong class="source-inline1"><st c="12340">12</st></strong><st c="12342"> → </st><span><strong class="source-inline1"><st c="12345">17</st></strong></span><span><st c="12347">.</st></span></li>
			</ol>
			<p class="calibre3"><span><em class="italic"><st c="12348">Figure 12</st></em></span><em class="italic"><st c="12358">.1 </st></em><st c="12361">illustrates the process of inserting a new node in </st><span><st c="12412">linked lists.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1843" class="img---figure">
					<img src="image/B22248_12_1.jpg" alt="Figure 12.1: The process of adding a new node to a linked list in three steps" class="calibre144"/><st c="12425"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="12540">Figure 12.1: The process of adding a new node to a linked list in three steps</st></p>
			<p class="calibre3"><st c="12617">In </st><span><em class="italic"><st c="12621">Figure 12</st></em></span><em class="italic"><st c="12630">.1</st></em><st c="12632">, </st><em class="italic"><st c="12634">Link</st></em><st c="12638"> represents</st><a id="_idIndexMarker746" class="pcalibre pcalibre1 calibre6"/><st c="12649"> the pointer to the </st><strong class="bold"><st c="12669">head</st></strong><st c="12673"> of the linked list (node with value </st><strong class="source-inline"><st c="12710">24</st></strong><st c="12712">). </st><st c="12716">The last node, referred to as the </st><strong class="bold"><st c="12750">tail</st></strong><st c="12754"> (the node with value </st><strong class="source-inline"><st c="12776">17</st></strong><st c="12778">), points to </st><strong class="source-inline"><st c="12792">null</st></strong><st c="12796">, indicating the end of the list. </st><st c="12830">We represent a pointer to </st><strong class="source-inline"><st c="12856">null</st></strong><st c="12860"> with the </st><strong class="source-inline"><st c="12870">/</st></strong><st c="12871"> symbol. </st><st c="12880">The address of the newly created node is labeled as </st><strong class="source-inline"><st c="12932">New</st></strong><st c="12935">, and initially, it points </st><span><st c="12962">to </st></span><span><strong class="source-inline"><st c="12965">null</st></strong></span><span><st c="12969">.</st></span></p>
			<p class="calibre3"><st c="12970">Here is a simple Python implementation of the </st><span><st c="13017">preceding process:</st></span></p>
			<pre class="source-code"><st c="13035" class="calibre11">
class Node:
    def __init__(self, data):
        self.data = data  # Store data
        self.next = None  # Initialize next as null (None in Python)
class LinkedList:
    def __init__(self):
        self.head = None  # Initialize the head of the list as None
    def insert_after(self, prev_node, new_data):
        if prev_node is None:
            print("The given previous node must be in the LinkedList.")
            return
        new_node = Node(new_data)  # Create a new node with the provided data
        new_node.next = prev_node.next  # Point the new node to the next node (e.g., 4)
        prev_node.next = new_node  # Point the previous node (e.g., 2) to the new node (e.g., 3)
    def print_list(self):
        temp = self.head
        while temp:
            print(temp.data, end=" -&gt; ")
            temp = temp.next
        print("None")</st></pre>			<p class="calibre3"><st c="13741">To test the</st><a id="_idIndexMarker747" class="pcalibre pcalibre1 calibre6"/><st c="13753"> functionality of both the </st><strong class="source-inline"><st c="13780">Node</st></strong><st c="13784"> class and the </st><strong class="source-inline"><st c="13799">LinkedList</st></strong><st c="13809"> class, we can use the </st><span><st c="13832">following example:</st></span></p>
			<pre class="source-code"><st c="13850" class="calibre11">
if __name__ == "__main__":
    llist = LinkedList()
    # Creating the initial linked list 1 -&gt; 2 -&gt; 4
    llist.head = Node(1)
    second = Node(2)
    third = Node(4)
    llist.head.next = second
    second.next = third
    # Insert 3 between 2 and 4
    llist.insert_after(second, 3)
    # Print the updated linked list
    llist.print_list()</st></pre>			<p class="calibre3"><st c="14152">Let’s briefly explain </st><span><st c="14175">the code:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="source-inline1"><st c="14184">Node</st></strong><st c="14189">: Each </st><strong class="source-inline1"><st c="14197">Node</st></strong><st c="14201"> object stores a </st><strong class="source-inline1"><st c="14218">data</st></strong><st c="14222"> value and a </st><strong class="source-inline1"><st c="14235">next</st></strong><st c="14239"> pointer in the next node in the </st><span><st c="14272">linked list.</st></span></li>
				<li class="calibre13"><strong class="source-inline1"><st c="14284">LinkedList</st></strong><st c="14295">: The </st><strong class="source-inline1"><st c="14302">LinkedList</st></strong><st c="14312"> class manages the linked list, including the </st><span><st c="14358">insertion operation.</st></span></li>
				<li class="calibre13"><strong class="source-inline1"><st c="14378">insert_after</st></strong><st c="14391">: This method inserts a new node after a given node (</st><strong class="source-inline1"><st c="14445">prev_node</st></strong><st c="14455">). </st><st c="14459">The new node is created with the </st><strong class="source-inline1"><st c="14492">new_data</st></strong><st c="14500"> value, and pointers are updated to insert it correctly into </st><span><st c="14561">the list.</st></span></li>
				<li class="calibre13"><strong class="source-inline1"><st c="14570">print_list</st></strong><st c="14581">: This method traverses the linked list and prints the data of </st><span><st c="14645">each node.</st></span></li>
			</ul>
			<p class="calibre3"><st c="14655">The time </st><a id="_idIndexMarker748" class="pcalibre pcalibre1 calibre6"/><st c="14665">complexity of insertion in a linked list is </st><img src="image/1805.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1328"/><st c="14709"/><st c="14710"> in the best case, such as when inserting at the beginning or end of the list if the position is already known. </st><st c="14822">In the worst case, when inserting at a specific position requires traversal through the list, the time complexity </st><span><st c="14936">is </st></span><span><img src="image/995.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="14939"/></span><span><st c="14940">.</st></span></p>
			<h3 class="calibre8"><st c="14941">Deletion in linked lists</st></h3>
			<p class="calibre3"><st c="14966">Deletion from a linked</st><a id="_idIndexMarker749" class="pcalibre pcalibre1 calibre6"/><st c="14989"> list involves removing a specific node. </st><st c="15030">For instance, given the </st><strong class="source-inline"><st c="15054">24</st></strong><st c="15056"> → </st><strong class="source-inline"><st c="15059">3</st></strong><st c="15060"> → </st><strong class="source-inline"><st c="15063">12</st></strong><st c="15065"> → </st><strong class="source-inline"><st c="15068">17</st></strong><st c="15070"> linked list, deleting the node with the value </st><strong class="source-inline"><st c="15117">3</st></strong><st c="15118"> requires bypassing it by updating the pointer of the previous node (</st><strong class="source-inline"><st c="15187">2</st></strong><st c="15189">) to point to the next node (</st><strong class="source-inline"><st c="15218">4</st></strong><st c="15220">). </st><st c="15223">Like insertion, the time complexity of the deletion operation in linked lists depends on the location of the node to be deleted. </st><st c="15352">In the worst case, when traversal is needed to find the node, the time complexity is </st><img src="image/1071.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1329"/><st c="15437"/><st c="15438">. </st><span><em class="italic"><st c="15440">Figure 12</st></em></span><em class="italic"><st c="15449">.2</st></em><st c="15451"> illustrates the deleting process in the example </st><span><st c="15500">link list.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1847" class="img---figure">
					<img src="image/B22248_12_2.jpg" alt="Figure 12.2: The process of deleting a node in a linked list" class="calibre144"/><st c="15510"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="15545">Figure 12.2: The process of deleting a node in a linked list</st></p>
			<p class="calibre3"><st c="15605">In </st><span><em class="italic"><st c="15609">Figure 12</st></em></span><em class="italic"><st c="15618">.3</st></em><st c="15620">, the top part displays the linked list before the deletion of the node with the value </st><strong class="source-inline"><st c="15707">12</st></strong><st c="15709">, while the bottom part shows the linked list after the deletion. </st><st c="15775">The following is an</st><a id="_idIndexMarker750" class="pcalibre pcalibre1 calibre6"/><st c="15794"> example Python code for deleting a node in a </st><span><st c="15840">linked list:</st></span></p>
			<pre class="source-code"><st c="15852" class="calibre11">
def delete_node(self, key):
    temp = self.head
    if (temp is not None):
        if (temp.data == key):
            self.head = temp.next
            temp = None
            return
    while(temp is not None):
        if temp.data == key:
            break
        prev = temp
        temp = temp.next
    if(temp == None):
        return
    prev.next = temp.next
    temp = None
# Example usage:
llist.delete_node(3)  # Deletes the node with value 3
llist.print_list()</st></pre>			<p class="calibre3"><st c="16213">The </st><strong class="source-inline"><st c="16218">delete_node</st></strong><st c="16229"> function should be added to the </st><strong class="source-inline"><st c="16262">LinkedList</st></strong><st c="16272"> class in the </st><span><st c="16286">previous section.</st></span></p>
			<h3 class="calibre8"><st c="16303">Edit in link lists</st></h3>
			<p class="calibre3"><st c="16322">Editing involves</st><a id="_idIndexMarker751" class="pcalibre pcalibre1 calibre6"/><st c="16339"> modifying the data within an existing node in the linked list. </st><st c="16403">For instance, if we want to change the value of the second node from </st><strong class="source-inline"><st c="16472">2</st></strong><st c="16473"> to </st><strong class="source-inline"><st c="16477">5</st></strong><st c="16478"> in the </st><strong class="source-inline"><st c="16486">1</st></strong><st c="16487"> → </st><strong class="source-inline"><st c="16490">2</st></strong><st c="16491"> → </st><strong class="source-inline"><st c="16494">3</st></strong><st c="16495"> → </st><strong class="source-inline"><st c="16498">4</st></strong><st c="16499"> linked list, we would update the node’s data accordingly. </st><st c="16558">The time complexity for this operation is </st><img src="image/1011.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1330"/><st c="16600"/><st c="16601"> because we may need to traverse the list to locate the node to be updated. </st><st c="16677">Here is a piece of sample Python code for the </st><span><st c="16723">edit/update operation:</st></span></p>
			<pre class="source-code"><st c="16745" class="calibre11">
def update_node(self, old_data, new_data):
    temp = self.head
    while temp is not None:
        if temp.data == old_data:
            temp.data = new_data
            return
        temp = temp.next
# Example usage:
llist.update_node(2, 5)  # Updates node with value 2 to 5</st></pre>			<p class="calibre3"><st c="16974">The </st><strong class="source-inline"><st c="16979">update_node</st></strong><st c="16990"> function should be added to the </st><strong class="source-inline"><st c="17023">LinkedList</st></strong><st c="17033"> class in the </st><span><st c="17047">previous section.</st></span></p>
			<h3 class="calibre8"><st c="17064">Searching in linked lists</st></h3>
			<p class="calibre3"><st c="17090">In </st><a href="B22248_07_split_000.xhtml#_idTextAnchor103" class="pcalibre pcalibre1 calibre6"><span><em class="italic"><st c="17094">Chapter 7</st></em></span></a><st c="17103">, we</st><a id="_idIndexMarker752" class="pcalibre pcalibre1 calibre6"/><st c="17107"> explored a variety of search algorithms in detail, all of which are based on arrays as the underlying data structure. </st><st c="17226">For instance, in binary search, we can directly access an element at a specific index, such as the middle of the array. </st><st c="17346">However, when using a linked list, finding a node with a specific value becomes more challenging due to the sequential nature of the data structure. </st><st c="17495">This means that regardless of the search algorithm used, when applied to a singly linked list, the search essentially becomes a sequential, linear search. </st><st c="17650">As a result, searching in a linked list has a time complexity </st><span><st c="17712">of </st></span><span><img src="image/1809.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1331"/><st c="17715"/></span><span><st c="17716">.</st></span></p>
			<p class="calibre3"><st c="17717">Here is the Python code example using a singly </st><span><st c="17765">linked list:</st></span></p>
			<pre class="source-code"><st c="17777" class="calibre11">
def search_node(self, key):
    temp = self.head
    while temp is not None:
        if temp.data == key:
            return True
        temp = temp.next
    return False
# Example usage:
found = llist.search(3)  # Returns True if 3 is found</st></pre>			<p class="calibre3"><st c="17979">The </st><strong class="source-inline"><st c="17984">search_node</st></strong><st c="17995"> function </st><a id="_idIndexMarker753" class="pcalibre pcalibre1 calibre6"/><st c="18005">should be added to the </st><strong class="source-inline"><st c="18028">LinkedList</st></strong><st c="18038"> class in the </st><span><st c="18052">previous section.</st></span></p>
			<h3 class="calibre8"><st c="18069">Access in link lists</st></h3>
			<p class="calibre3"><st c="18090">This </st><a id="_idIndexMarker754" class="pcalibre pcalibre1 calibre6"/><st c="18096">operation involves retrieving the value of a node at a specific position in the linked list. </st><st c="18189">For example, accessing the fourth node in the </st><strong class="source-inline"><st c="18235">17</st></strong><st c="18237"> → </st><strong class="source-inline"><st c="18240">12</st></strong><st c="18242"> → </st><strong class="source-inline"><st c="18245">3</st></strong><st c="18246"> → </st><strong class="source-inline"><st c="18249">24</st></strong><st c="18251"> → </st><strong class="source-inline"><st c="18254">6</st></strong><st c="18255"> linked list requires sequential traversal to reach the desired node. </st><st c="18325">The time complexity for this operation is </st><img src="image/1071.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1332"/><st c="18367"/><st c="18368">. The following is a simple Python code implementing access in a </st><span><st c="18433">linked list:</st></span></p>
			<pre class="source-code"><st c="18445" class="calibre11">
def get_nth(self, index):
    temp = self.head
    count = 0
    while (temp):
        if (count == index):
            return temp.data
    count += 1
    temp = temp.next
    return None
# Example usage:
value = llist.get_nth(2)  # Returns the value of the third node</st></pre>			<p class="calibre3"><st c="18670">The </st><strong class="source-inline"><st c="18675">get_nth</st></strong><st c="18682"> function should be added to the </st><strong class="source-inline"><st c="18715">LinkedList</st></strong><st c="18725"> class in the </st><span><st c="18739">previous section.</st></span></p>
			<p class="calibre3"><st c="18756">In practice, linked lists </st><a id="_idIndexMarker755" class="pcalibre pcalibre1 calibre6"/><st c="18783">are commonly used as the underlying data structure for implementing stacks and queues due to their ability to dynamically resize. </st><st c="18913">They are also employed in operating systems for managing memory allocation, where free memory blocks are linked together in a list. </st><st c="19045">Another significant application of linked lists is in representing adjacency lists in graphs or trees, where each vertex points to a linked list of </st><span><st c="19193">adjacent vertices.</st></span></p>
			<p class="calibre3"><st c="19211">Linked lists offer a flexible and dynamic alternative to arrays, especially in scenarios where the size of the data structure needs to change frequently. </st><st c="19366">Their non-contiguous memory allocation allows for efficient insertions and deletions without the need to shift elements, unlike arrays. </st><st c="19502">However, this flexibility comes with the drawback of sequential access times, making linked lists less suitable for applications that require frequent random access. </st><st c="19668">Understanding the trade-offs between linked lists and other data structures, such as arrays, is essential for selecting the most appropriate structure for a given problem. </st><st c="19840">In the next section, we will briefly explore other variants of </st><span><st c="19903">linked lists.</st></span></p>
			<h3 class="calibre8"><st c="19916">Doubly and circular linked lists</st></h3>
			<p class="calibre3"><st c="19949">A </st><strong class="bold"><st c="19952">doubly linked list</st></strong><st c="19970"> is a</st><a id="_idIndexMarker756" class="pcalibre pcalibre1 calibre6"/><st c="19975"> type of linked list in which each node </st><a id="_idIndexMarker757" class="pcalibre pcalibre1 calibre6"/><st c="20015">contains two pointers: one pointing to the next node and another pointing to the previous node (see </st><span><em class="italic"><st c="20115">Figure 12</st></em></span><em class="italic"><st c="20124">.3</st></em><st c="20126">). </st><st c="20130">This bidirectional structure allows traversal of the list in both forward and backward directions, making certain operations more efficient. </st><st c="20271">Although doubly linked lists allow bidirectional access, their sequential nature means that the time complexity for major operations remains similar to that of singly </st><span><st c="20438">linked lists.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1851" class="img---figure">
					<img src="image/B22248_12_3.jpg" alt="Figure 12.3: An example doubly linked list" class="calibre144"/><st c="20451"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="20478">Figure 12.3: An example doubly linked list</st></p>
			<p class="calibre3"><st c="20520">Another variation of </st><a id="_idIndexMarker758" class="pcalibre pcalibre1 calibre6"/><st c="20542">the linked</st><a id="_idIndexMarker759" class="pcalibre pcalibre1 calibre6"/><st c="20552"> list is the </st><strong class="bold"><st c="20565">circular linked list</st></strong><st c="20585"> where the last node points back to the first node, forming a circular structure (see </st><span><em class="italic"><st c="20671">Figure 12</st></em></span><em class="italic"><st c="20680">.4</st></em><st c="20682">). </st><st c="20686">This can be applied to both singly and doubly linked lists. </st><st c="20746">Since the last node connects back to the first, we can traverse the list in a loop without encountering a null reference. </st><st c="20868">This characteristic is ideal for applications where data needs to be looped through continuously, such as in round-robin scheduling or buffer management. </st><st c="21022">Like </st><a id="_idIndexMarker760" class="pcalibre pcalibre1 calibre6"/><st c="21027">doubly linked lists, circular linked lists do not provide any improvement in </st><a id="_idIndexMarker761" class="pcalibre pcalibre1 calibre6"/><st c="21104">time complexity compared to non-circular </st><span><st c="21145">linked lists.</st></span></p>
			<div class="calibre2">
				<div id="_idContainer1852" class="img---figure">
					<img src="image/B22248_12_4.jpg" alt="Figure 12.4: A circular linked list" class="calibre144"/><st c="21158"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="21184">Figure 12.4: A circular linked list</st></p>
			<p class="calibre3"><st c="21219">Both doubly linked lists and circular linked lists offer distinct advantages depending on the use case. </st><st c="21324">Doubly linked lists provide more flexibility in navigation and easier node removal, while circular linked lists enable efficient cyclic traversal of data. </st><st c="21479">In terms of performance, both structures exhibit similar time complexities to singly linked lists but with added benefits in specific operations. </st><st c="21625">In the next section, we will explore a data structure that combines the advantages of both linked lists </st><span><st c="21729">and arrays.</st></span></p>
			<h1 id="_idParaDest-163" class="calibre5"><a id="_idTextAnchor192" class="pcalibre pcalibre1 calibre6"/><st c="21740">Skip lists</st></h1>
			<p class="calibre3"><st c="21751">As </st><a id="_idIndexMarker762" class="pcalibre pcalibre1 calibre6"/><st c="21755">we discussed in the previous chapter, when studying data structures, it’s important to evaluate their performance in three key operations: insertion, deletion, and search. </st><st c="21927">Arrays excel in searching, particularly when the data is already sorted, thanks to their direct (or random) access capabilities, which allow for sublinear time complexity. </st><st c="22099">However, due to their static nature, arrays can present challenges when it comes to inserting new data or deleting existing data. </st><st c="22229">On the other hand, linked lists exhibit the opposite behavior. </st><st c="22292">Their dynamic allocation allows for easy insertion and deletion, but the lack of direct access means that searching, even in sorted data, becomes a sequential process with linear </st><span><st c="22471">time complexity.</st></span></p>
			<p class="calibre3"><st c="22487">This question then arises: Is it possible to combine the benefits of both arrays and linked lists? </st><st c="22587">In other words, can we achieve faster-than-sequential access, similar to arrays, while also enjoying the dynamic memory allocation of linked lists? </st><st c="22735">The answer lies in the </st><strong class="bold"><st c="22758">skip list</st></strong><st c="22767">. A </st><strong class="bold"><st c="22771">skip list</st></strong><st c="22780"> is a probabilistic data structure that extends the basic linked list by adding multiple levels of linked lists, allowing for faster search, insertion, and deletion operations. </st><st c="22957">Each level of a skip list contains a subset of the elements from the level below, with the bottommost level containing all elements in a simple linked list. </st><st c="23114">Higher levels act as “express lanes” to skip over multiple elements at once, hence the name </st><em class="italic"><st c="23206">skip list</st></em><st c="23215">. </st><span><em class="italic"><st c="23217">Figure 12</st></em></span><em class="italic"><st c="23226">.6</st></em><st c="23228"> illustrates an example of a skip list. </st><st c="23268">Level 1 functions as a standard linked list, while all the upper levels serve as </st><span><st c="23349">express lanes.</st></span></p>
			<p class="calibre3"><st c="23363">Let’s explain the </st><a id="_idIndexMarker763" class="pcalibre pcalibre1 calibre6"/><st c="23382">concept of a skip list using an analogy. </st><st c="23423">Imagine we are traveling to meet a friend at a specific station in a bus system. </st><st c="23504">The bus stops at every station, and each stop takes a considerable amount of time, so we want to minimize the number of stops on our way to our friend’s station. </st><st c="23666">There are </st><img src="image/23.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre465"/><st c="23676"/><st c="23677"> stations in total, and we know the exact station number where our friend is waiting. </st><st c="23763">The bus system has two types </st><span><st c="23792">of lines:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="23801">The regular bus stops at every </st><span><st c="23833">single station</st></span></li>
				<li class="calibre13"><st c="23847">The express line stops only at four stations, specifically at </st><img src="image/1812.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre1333"/><st c="23910"/><st c="23911">, </st><img src="image/547.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre437"/><st c="23913"/><st c="23914">, </st><img src="image/1814.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mn&gt;3&lt;/mml:mn&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre1334"/><st c="23916"/><st c="23917">, </st><span><st c="23919">and </st></span><span><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="23923"/></span></li>
			</ul>
			<p class="calibre3"><st c="23972">Taking the regular bus is the safest option because it ensures we will reach our destination, but it requires stopping at every station, which can be inefficient, taking </st><img src="image/48.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre1335"/><st c="24142"/><st c="24191"> stops in total. </st><st c="24207">Alternatively, we could take the express bus, which only makes four stops. </st><st c="24282">If our friend’s station falls within one of the intervals between these express stops (for example, between 1 and </st><img src="image/1812.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre1333"/><st c="24396"/><st c="24397">, or between </st><img src="image/1818.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1336"/><st c="24410"/><st c="24411"> and </st><img src="image/547.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;2&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;/mml:math&gt;" class="calibre437"/><st c="24416"/><st c="24417">), we can get off the bus at the nearest express stop and switch to the regular bus to reach our friend’s exact station. </st><st c="24538">By doing this, we reduce the number of stops from a maximum of </st><img src="image/1820.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:math&gt;" class="calibre64"/><st c="24601"/><st c="24602"> to around </st><img src="image/1818.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mfrac&gt;&lt;mml:mrow&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;/mml:mrow&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;4&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfrac&gt;&lt;mml:mo&gt;+&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:math&gt;" class="calibre1337"/><st c="24613"/><st c="24614">, making our journey much more efficient. </st><st c="24656">The skip list is similar to this </st><span><st c="24689">bus system.</st></span></p>
			<p class="calibre3"><st c="24700">Skip lists have several defining</st><a id="_idIndexMarker764" class="pcalibre pcalibre1 calibre6"/><st c="24733"> characteristics that influence their behavior </st><span><st c="24780">and performance:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="24796">Multiple levels</st></strong><st c="24812">: Skip lists consist of multiple levels, where each level above the base level contains a subset of elements from the previous level. </st><st c="24947">The bottommost level is a standard linked list containing all elements. </st><st c="25019">In a skip list, the first level might contain all elements, the second level might contain half, the third level might contain a quarter, and </st><span><st c="25161">so on.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="25167">Probabilistic balancing</st></strong><st c="25191">: Skip lists use randomization to determine the level at which each element will appear. </st><st c="25281">This leads to an average-case time complexity similar to balanced binary search trees without the need for complex balancing algorithms. </st><st c="25418">For example, when inserting an element, a random number of levels (up to a maximum) is chosen for the element to be </st><span><st c="25534">included in.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="25546">Efficient searching</st></strong><st c="25566">: Skip lists allow for faster searching by skipping over large portions of the list using the higher levels, reducing the number of comparisons needed. </st><st c="25719">For </st><a id="_idIndexMarker765" class="pcalibre pcalibre1 calibre6"/><st c="25723">instance, searching for an element in a skip list can quickly bypass multiple nodes by moving through the </st><span><st c="25829">upper levels.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="25842">Dynamic resizing</st></strong><st c="25859">: Skip lists can dynamically adjust their structure as elements are added or removed, maintaining efficient operations without needing to rebuild the entire structure. </st><st c="26028">For example, as new elements are inserted, they may be added to multiple levels depending on the </st><span><st c="26125">randomization process.</st></span></li>
			</ul>
			<p class="calibre3"><st c="26147">Skip lists support various operations, each with specific performance characteristics. </st><st c="26235">The following section outlines the major operations, along with their time complexities </st><span><st c="26323">and examples.</st></span></p>
			<h2 id="_idParaDest-164" class="calibre5"><a id="_idTextAnchor193" class="pcalibre pcalibre1 calibre6"/><st c="26336">Insertion in skip lists</st></h2>
			<p class="calibre3"><st c="26360">Inserting </st><a id="_idIndexMarker766" class="pcalibre pcalibre1 calibre6"/><st c="26371">numbers into a skip list involves a few steps. </st><st c="26418">For this example, we will insert the numbers </st><strong class="source-inline"><st c="26463">3</st></strong><st c="26464">, </st><strong class="source-inline"><st c="26466">4</st></strong><st c="26467">, </st><strong class="source-inline"><st c="26469">5</st></strong><st c="26470">, </st><strong class="source-inline"><st c="26472">7</st></strong><st c="26473">, </st><strong class="source-inline"><st c="26475">8</st></strong><st c="26476">, </st><strong class="source-inline"><st c="26478">9</st></strong><st c="26479">, and </st><strong class="source-inline"><st c="26485">10</st></strong><st c="26487"> into a skip list with 4 levels. </st><st c="26520">Each number will be inserted one by one, and the levels will be assigned based on randomization. </st><st c="26617">Here’s a detailed step-by-step description of how this </st><span><st c="26672">process works:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="26686">Step 1: Initialize the skip list</st></strong><st c="26719">: Start with an empty skip list that has four levels: </st><em class="italic"><st c="26774">Level 4</st></em><st c="26781"> (topmost), </st><em class="italic"><st c="26793">Level 3</st></em><st c="26800">, </st><em class="italic"><st c="26802">Level 2</st></em><st c="26809">, and </st><em class="italic"><st c="26815">Level 1</st></em><st c="26822"> (bottommost). </st><st c="26837">Initially, the list has only a head node at each level pointing </st><span><st c="26901">to </st></span><span><strong class="source-inline1"><st c="26904">null</st></strong></span><span><st c="26908">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="26909">Step 2: </st></strong><span><strong class="bold"><st c="26918">Insert 3</st></strong></span><span><st c="26926">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="26928">Determine levels for 3</st></strong><st c="26950">: Randomly determine the levels at which </st><strong class="source-inline1"><st c="26992">3</st></strong><st c="26993"> should appear. </st><st c="27009">Let’s assume it appears at </st><span><st c="27036">all levels.</st></span></li><li class="calibre13"><strong class="bold"><st c="27047">Insertion</st></strong><st c="27057">: At </st><em class="italic"><st c="27063">Levels 1</st></em><st c="27071"> to </st><em class="italic"><st c="27075">4</st></em><st c="27076">, there are no other nodes; so, </st><strong class="source-inline1"><st c="27108">3</st></strong><st c="27109"> is simply inserted, and the head node at </st><em class="italic"><st c="27151">Levels 1</st></em><st c="27159"> to </st><em class="italic"><st c="27163">4</st></em><st c="27164"> now points </st><span><st c="27176">to </st></span><span><strong class="source-inline1"><st c="27179">3</st></strong></span><span><st c="27180">.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="27181">Here is the </st><span><st c="27194">skip list:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="27204">Level 4: 3 --&gt; </st><span><st c="27220">null</st></span></li>
				<li class="calibre13"><st c="27224">Level 3: 3 --&gt; </st><span><st c="27240">null</st></span></li>
				<li class="calibre13"><st c="27244">Level 2: 3 --&gt; </st><span><st c="27260">null</st></span></li>
				<li class="calibre13"><st c="27264">Level 1: 3 --&gt; </st><span><st c="27280">null</st></span></li>
			</ul>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="27284">Step 3: </st></strong><span><strong class="bold"><st c="27293">Insert 4</st></strong></span><span><st c="27301">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="27303">Determine levels for 4</st></strong><st c="27325">: Randomly determine the levels at which </st><strong class="source-inline1"><st c="27367">4</st></strong><st c="27368"> should appear. </st><st c="27384">Suppose it appears only at </st><em class="italic"><st c="27411">Level 1</st></em><st c="27418">. The higher levels remain unchanged as </st><strong class="source-inline1"><st c="27458">3</st></strong><st c="27459"> does not </st><span><st c="27469">appear there.</st></span></li><li class="calibre13"><strong class="bold"><st c="27482">Insertion</st></strong><st c="27492">: Traverse </st><em class="italic"><st c="27504">Level 1</st></em><st c="27511"> from the head to the appropriate position. </st><strong class="source-inline1"><st c="27555">4</st></strong><st c="27556"> should be inserted after </st><strong class="source-inline1"><st c="27582">3</st></strong><st c="27583">. Update the pointers so that </st><strong class="source-inline1"><st c="27613">3</st></strong><st c="27614"> now points to </st><strong class="source-inline1"><st c="27629">4</st></strong><st c="27630"> at </st><span><em class="italic"><st c="27634">Level 1</st></em></span><span><st c="27641">.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="27642">Here is the</st><a id="_idIndexMarker767" class="pcalibre pcalibre1 calibre6"/> <span><st c="27654">skip list:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="27665">Level 4: 3 --&gt; </st><span><st c="27681">null</st></span></li>
				<li class="calibre13"><st c="27685">Level 3: 3 --&gt; </st><span><st c="27701">null</st></span></li>
				<li class="calibre13"><st c="27705">Level 2: 3 --&gt; </st><span><st c="27721">null</st></span></li>
				<li class="calibre13"><st c="27725">Level 1: 3 --&gt; 4 --&gt; </st><span><st c="27747">null</st></span></li>
			</ul>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="27751">Step 4: </st></strong><span><strong class="bold"><st c="27760">Insert 5</st></strong></span><span><st c="27768">:</st></span><p class="calibre3"><strong class="bold"><st c="27770">Determine levels for 5</st></strong><st c="27792">: Let’s assume </st><strong class="source-inline"><st c="27808">5</st></strong><st c="27809"> is assigned randomly to </st><em class="italic"><st c="27834">Levels 1</st></em><st c="27842">, </st><em class="italic"><st c="27844">2</st></em><st c="27845">, </st><span><st c="27847">and </st></span><span><em class="italic"><st c="27851">3</st></em></span><span><st c="27852">.</st></span></p><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="27853">Insertion</st></strong><st c="27863">: In </st><em class="italic"><st c="27869">Levels 2</st></em><st c="27877"> and </st><em class="italic"><st c="27882">3</st></em><st c="27883">, element </st><strong class="source-inline1"><st c="27893">5</st></strong><st c="27894"> is the next element to </st><strong class="source-inline1"><st c="27918">3</st></strong><st c="27919">. Then, pointers of </st><strong class="source-inline1"><st c="27939">3</st></strong><st c="27940"> at these levels are updated to point to </st><strong class="source-inline1"><st c="27981">5</st></strong><st c="27982">. In </st><em class="italic"><st c="27987">Level 1</st></em><st c="27994">, insert </st><strong class="source-inline1"><st c="28003">5</st></strong><st c="28004"> after </st><strong class="source-inline1"><st c="28011">4</st></strong><st c="28012"> by updating the </st><span><st c="28029">pointers accordingly.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="28050">Here is the </st><span><st c="28063">skip list:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="28073">Level 4: 3 --&gt; </st><span><st c="28089">null</st></span></li>
				<li class="calibre13"><st c="28093">Level 3: 3 --&gt; 5 --&gt; </st><span><st c="28115">null</st></span></li>
				<li class="calibre13"><st c="28119">Level 2: 3 --&gt; 5 --&gt; </st><span><st c="28141">null</st></span></li>
				<li class="calibre13"><st c="28145">Level 1: 3 --&gt; 4 --&gt;5 --&gt; </st><span><st c="28172">null</st></span></li>
			</ul>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="28176">Step 5: </st></strong><span><strong class="bold"><st c="28185">Insert 7</st></strong></span><span><st c="28193">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="28195">Determine levels for 7</st></strong><st c="28217">: Suppose </st><strong class="source-inline1"><st c="28228">7</st></strong><st c="28229"> is assigned randomly to </st><em class="italic"><st c="28254">Level 1</st></em><st c="28261">. All upper levels </st><span><st c="28280">remain unchanged.</st></span></li><li class="calibre13"><strong class="bold"><st c="28297">Insertion</st></strong><st c="28307">: In </st><em class="italic"><st c="28313">Level 1 </st></em><st c="28321">insert </st><strong class="source-inline1"><st c="28328">7</st></strong> <span><st c="28329">after </st></span><span><strong class="source-inline1"><st c="28335">5</st></strong></span><span><st c="28336">.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="28337">Here is the</st><a id="_idIndexMarker768" class="pcalibre pcalibre1 calibre6"/> <span><st c="28349">skip list:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="28360">Level 4: 3 --&gt; </st><span><st c="28376">null</st></span></li>
				<li class="calibre13"><st c="28380">Level 3: 3 --&gt; </st><span><st c="28396">5 --&gt;null</st></span></li>
				<li class="calibre13"><st c="28405">Level 2: 3 --&gt; </st><span><st c="28421">5 --&gt;null</st></span></li>
				<li class="calibre13"><st c="28430">Level 1: 3 --&gt; 4 --&gt; 5 --&gt;7 --&gt; </st><span><st c="28463">null</st></span></li>
			</ul>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="28467">Step 6: </st></strong><span><strong class="bold"><st c="28476">Insert 8</st></strong></span><span><st c="28484">:</st></span><ul class="calibre50"><li class="calibre13"><strong class="bold"><st c="28486">Determine levels for 8</st></strong><st c="28508">: Let’s assume </st><strong class="source-inline1"><st c="28524">8</st></strong><st c="28525"> is assigned randomly to </st><em class="italic"><st c="28550">Levels 1</st></em> <span><st c="28558">and </st></span><span><em class="italic"><st c="28563">2</st></em></span><span><st c="28564">.</st></span></li><li class="calibre13"><strong class="bold"><st c="28565">Insertion</st></strong><st c="28575">: In </st><em class="italic"><st c="28581">Level 2</st></em><st c="28588">, insert </st><strong class="source-inline1"><st c="28597">8</st></strong><st c="28598"> after </st><strong class="source-inline1"><st c="28605">5</st></strong><st c="28606"> by updating the pointers. </st><st c="28633">In </st><em class="italic"><st c="28636">Level 1</st></em><st c="28643">, insert </st><strong class="source-inline1"><st c="28652">8</st></strong> <span><st c="28653">after </st></span><span><strong class="source-inline1"><st c="28659">7</st></strong></span><span><st c="28660">.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="28661">Here is the </st><span><st c="28674">skip list:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="28684">Level 4: 3 --&gt; </st><span><st c="28700">null</st></span></li>
				<li class="calibre13"><st c="28704">Level 3: 3 --&gt; 5 --&gt; </st><span><st c="28726">null</st></span></li>
				<li class="calibre13"><st c="28730">Level 2: 3 --&gt; 5 --&gt; 8 --&gt; </st><span><st c="28758">null</st></span></li>
				<li class="calibre13"><st c="28762">Level 1: 3 --&gt; 4 --&gt; 5 --&gt; 7 --&gt; 8 --&gt; </st><span><st c="28802">null</st></span></li>
			</ul>
			<ul class="calibre14">
				<li class="calibre13"><st c="28806">For </st><em class="italic"><st c="28811">Steps 9</st></em><st c="28818"> and </st><em class="italic"><st c="28823">10</st></em><st c="28825">, we do similar to what we did with element </st><strong class="source-inline1"><st c="28869">7</st></strong><st c="28870">. The final skip list after inserting all elements is illustrated in </st><span><em class="italic"><st c="28939">Figure 12</st></em></span><span><em class="italic"><st c="28948">.5</st></em></span><span><st c="28950">.</st></span></li>
			</ul>
			<div class="calibre2">
				<div id="_idContainer1864" class="img---figure">
					<img src="image/B22248_12_5.jpg" alt="Figure 12.5: An example skip list with four levels" class="calibre144"/><st c="28951"/>
				</div>
			</div>
			<p class="img---caption1" lang="en-US" xml:lang="en-US"><st c="29049">Figure 12.5: An example skip list with four levels</st></p>
			<p class="calibre3"><st c="29099">The insertion </st><a id="_idIndexMarker769" class="pcalibre pcalibre1 calibre6"/><st c="29114">process in a skip list involves determining the levels at which a new element will appear and updating the pointers at each relevant level to maintain the order. </st><st c="29276">The random assignment of levels ensures that the skip list remains balanced, providing efficient search, insertion, and deletion operations. </st><st c="29417">The preceding steps illustrate how each number was inserted into the skip list, taking advantage of the express lanes created by the </st><span><st c="29550">higher levels.</st></span></p>
			<p class="calibre3"><st c="29564">The following Python code is an implementation of insertion into a </st><span><st c="29632">skip list:</st></span></p>
			<pre class="source-code"><st c="29642" class="calibre11">
import random
class Node:
    def __init__(self, value, level):
        self.value = value
        self.forward = [None] * (level + 1)
class SkipList:
    def __init__(self, max_level):
        self.max_level = max_level
        self.head = Node(-1, max_level)  # Head node with value -1 (acts as a sentinel)
        self.level = 0
    def random_level(self):
        level = 0
        while random.random() &lt; 0.5 and level &lt; self.max_level:
            level += 1
        return level
    def insert(self, value):
        update = [None] * (self.max_level + 1)
        current = self.head
        for i in range(self.level, -1, -1):
            while current.forward[i] and current.forward[i].value &lt; value:
                current = current.forward[i]
            update[i] = current
        level = self.random_level()
        if level &gt; self.level:
            for i in range(self.level + 1, level + 1):
                update[i] = self.head
            self.level = level
        new_node = Node(value, level)
        for i in range(level + 1):
            new_node.forward[i] = update[i].forward[i]
            update[i].forward[i] = new_node
    def print_skiplist(self):
        print("Skip List:")
        for i in range(self.level, -1, -1):
            print(f"Level {i}: ", end="")
            node = self.head.forward[i]
            while node:
                print(node.value, end=" -&gt; ")
                node = node.forward[i]
            print("None")
# Example usage
if __name__ == "__main__":
    skiplist = SkipList(3)
    # Insert elements into the skip list
    skiplist.insert(3)
    skiplist.insert(4)
    skiplist.insert(5)
    skiplist.insert(7)
    skiplist.insert(8)
    skiplist.insert(9)
    skiplist.insert(10)
    # Print the skip list
    skiplist.print_skiplist()</st></pre>			<p class="calibre3"><st c="31042">Let’s look inside </st><a id="_idIndexMarker770" class="pcalibre pcalibre1 calibre6"/><st c="31061">the code and explain the main classes of </st><span><st c="31102">the algorithm:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="source-inline1"><st c="31116">Node</st></strong><st c="31121">: Each </st><strong class="source-inline1"><st c="31129">Node</st></strong><st c="31133"> object stores a </st><strong class="source-inline1"><st c="31150">value</st></strong><st c="31155"> and a list of </st><strong class="source-inline1"><st c="31170">forward</st></strong><st c="31177"> pointers that are 4 in level 1, 5 in level 2, 5 in level 3 and null in </st><span><st c="31249">level 4</st></span></li>
				<li class="calibre13"><strong class="source-inline1"><st c="31256">SkipList</st></strong><st c="31265">: This contains the </st><span><st c="31286">following functions:</st></span><ul class="calibre50"><li class="calibre13"><strong class="source-inline1"><st c="31306">random_level()</st></strong><st c="31321">: This generates a random level for each new node based on a </st><span><st c="31383">probabilistic model</st></span></li><li class="calibre13"><strong class="source-inline1"><st c="31402">insert()</st></strong><st c="31411">: This inserts a new value into the skip list at the </st><span><st c="31465">appropriate levels</st></span></li><li class="calibre13"><strong class="source-inline1"><st c="31483">print_skiplist()</st></strong><st c="31500">: This prints the skip list, displaying the nodes at each level from the topmost level down to the </st><span><st c="31600">bottommost level</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="31616">As an example, we </st><a id="_idIndexMarker771" class="pcalibre pcalibre1 calibre6"/><st c="31635">create a skip list with up to three levels. </st><st c="31679">The values </st><strong class="source-inline"><st c="31690">3</st></strong><st c="31691">, </st><strong class="source-inline"><st c="31693">4</st></strong><st c="31694">, </st><strong class="source-inline"><st c="31696">5</st></strong><st c="31697">, </st><strong class="source-inline"><st c="31699">7</st></strong><st c="31700">, </st><strong class="source-inline"><st c="31702">8</st></strong><st c="31703">, </st><strong class="source-inline"><st c="31705">9</st></strong><st c="31706">, and </st><strong class="source-inline"><st c="31712">10</st></strong><st c="31714"> are inserted into the skip list. </st><st c="31748">Finally, we print the skip list, displaying how the nodes are organized across the various levels, which looks something </st><span><st c="31869">like this:</st></span></p>
			<pre class="source-code"><st c="31879" class="calibre11">
Skip List:
Level 2: 7 --&gt; 10 --&gt; None
Level 1: 5 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; None
Level 0: 3 --&gt; 4 --&gt; 5 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; None</st></pre>			<p class="calibre3"><st c="32019">After insertion, let’s discuss the behavior of a skip list during </st><span><st c="32086">search operations.</st></span></p>
			<h2 id="_idParaDest-165" class="calibre5"><a id="_idTextAnchor194" class="pcalibre pcalibre1 calibre6"/><st c="32104">Search in skip lists</st></h2>
			<p class="calibre3"><st c="32125">Searching</st><a id="_idIndexMarker772" class="pcalibre pcalibre1 calibre6"/><st c="32135"> for an item in a skip list involves starting at the highest level and moving forward through the list until the target is found or the search needs to move down a level. </st><st c="32306">Here’s a step-by-step explanation of how to search for the number </st><em class="italic"><st c="32372">8</st></em><st c="32373"> in the skip list we </st><span><st c="32394">previously constructed.</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="32417">Step 1</st></strong><st c="32424">: Start at the highest level (</st><span><em class="italic"><st c="32455">Level 4</st></em></span><span><st c="32463">):</st></span><ul class="calibre50"><li class="calibre13"><st c="32466">Start at the head node at </st><span><em class="italic"><st c="32493">Level 3</st></em></span><span><st c="32500">.</st></span></li><li class="calibre13"><st c="32501">Is </st><strong class="source-inline1"><st c="32505">3</st></strong><st c="32506"> (the first value at </st><em class="italic"><st c="32527">Level 3</st></em><st c="32534">) less than </st><strong class="source-inline1"><st c="32547">7</st></strong><st c="32548">? Yes; the next node </st><span><st c="32569">is </st></span><span><strong class="source-inline1"><st c="32572">null</st></strong></span><span><st c="32576">.</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="32577">Step 2</st></strong><st c="32584">: Move down to </st><span><em class="italic"><st c="32600">Level 3</st></em></span><span><st c="32607">:</st></span><ul class="calibre50"><li class="calibre13"><st c="32609">Now, drop down to node </st><strong class="source-inline1"><st c="32632">3</st></strong><st c="32633"> at </st><em class="italic"><st c="32637">Level 3</st></em><st c="32644"> and the next node </st><span><st c="32663">is </st></span><span><strong class="source-inline1"><st c="32666">5</st></strong></span><span><st c="32667">.</st></span></li><li class="calibre13"><st c="32668">Is </st><strong class="source-inline1"><st c="32672">5</st></strong><st c="32673"> less than </st><strong class="source-inline1"><st c="32684">9</st></strong><st c="32685">? Yes. </st><st c="32692">Move to node </st><strong class="source-inline1"><st c="32705">5</st></strong><st c="32706">. The next node which </st><span><st c="32728">in null.</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="32736">Step 3</st></strong><st c="32743">: Move down to </st><span><em class="italic"><st c="32759">Level 2</st></em></span><span><st c="32766">:</st></span><ul class="calibre50"><li class="calibre13"><st c="32768">Now, drop down to node </st><strong class="source-inline1"><st c="32791">5</st></strong><st c="32792"> at </st><em class="italic"><st c="32796">Level 3</st></em><st c="32803"> and the next node </st><span><st c="32822">is </st></span><span><strong class="source-inline1"><st c="32825">8</st></strong></span><span><st c="32826">.</st></span></li><li class="calibre13"><st c="32827">Is </st><strong class="source-inline1"><st c="32831">8</st></strong><st c="32832"> less than </st><span><strong class="source-inline1"><st c="32843">9</st></strong></span><span><st c="32844">? No.</st></span></li></ul></li>
				<li class="calibre13"><strong class="bold"><st c="32849">Step 4</st></strong><st c="32856">: Move down to </st><span><em class="italic"><st c="32872">Level 1</st></em></span><span><st c="32879">:</st></span><ul class="calibre50"><li class="calibre13"><st c="32881">The next node is </st><strong class="source-inline1"><st c="32898">7</st></strong><st c="32899">. The target </st><span><st c="32912">is found.</st></span></li></ul></li>
			</ul>
			<p class="calibre3"><st c="32921">The total number of comparisons is three, demonstrating a clear improvement over the sequential search in </st><em class="italic"><st c="33028">Level 1</st></em><st c="33035"> that would be required in a standard linked list. </st><st c="33086">Skip lists are significantly</st><a id="_idIndexMarker773" class="pcalibre pcalibre1 calibre6"/><st c="33114"> more efficient than linked lists, especially when dealing with </st><span><st c="33178">large datasets.</st></span></p>
			<p class="calibre3"><st c="33193">The following is a </st><strong class="source-inline"><st c="33213">search</st></strong><st c="33219"> method that must be added to the previously described </st><span><strong class="source-inline"><st c="33274">SkipList</st></strong></span><span><st c="33282"> class:</st></span></p>
			<pre class="source-code"><st c="33289" class="calibre11">
    def search(self, value):
        current = self.head
        for i in range(self.level, -1, -1):
            while current.forward[i] and current.forward[i].value &lt; value:
                current = current.forward[i]
        current = current.forward[0]
        if current and current.value == value:
            return True
        return False</st></pre>			<p class="calibre3"><st c="33555">The following is an example usage of </st><strong class="source-inline"><st c="33593">search</st></strong><st c="33599"> in a </st><span><strong class="source-inline"><st c="33605">SkipList</st></strong></span><span><st c="33613"> class:</st></span></p>
			<pre class="source-code"><st c="33620" class="calibre11">
if __name__ == "__main__":
    skiplist = SkipList(3)
    skiplist.insert(3)
    skiplist.insert(4)
    skiplist.insert(5)
    skiplist.insert(7)
    skiplist.insert(8)
    skiplist.insert(9)
    skiplist.insert(10)
    skiplist.print_skiplist()
    value_to_search = 7
    found = skiplist.search(value_to_search)
    print(f"\nSearch for {value_to_search}: {'Found' if found else 'Not Found'}")
    value_to_search = 6
    found = skiplist.search(value_to_search)
    print(f"Search for {value_to_search}: {'Found' if found else 'Not Found'}")</st></pre>			<p class="calibre3"><st c="34106">By inserting</st><a id="_idIndexMarker774" class="pcalibre pcalibre1 calibre6"/><st c="34119"> the example data, it produces the </st><span><st c="34154">following results:</st></span></p>
			<pre class="source-code"><st c="34172" class="calibre11">
Skip List:
Level 1: 3 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; None
Level 0: 3 --&gt; 4 --&gt; 5 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; None
Search for 7: Found
Search for 6: Not Found</st></pre>			<p class="calibre3"><st c="34323">To conclude our discussion on skip lists, we will skip the detailed explanation of deletion. </st><st c="34417">Deletion in a skip list involves first performing a search, followed by updating the </st><span><st c="34502">necessary pointers.</st></span></p>
			<p class="calibre3"><st c="34521">Skip lists offer efficient average-case time complexities for search, delete, and insert operations, typically performing at </st><img src="image/1436.png" alt="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" class="calibre1338"/><st c="34647"/><st c="34656">. This efficiency is achieved through the use of multiple levels of linked lists, allowing operations to skip over large portions of data, similar to a binary search tree. </st><st c="34828">In the best case, operations can approach </st><img src="image/1823.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1339"/><st c="34870"/><st c="34871"> when the target element is close to the starting point. </st><st c="34928">However, due to the probabilistic nature of skip lists, there is a small chance that the structure could degenerate, leading to a worst-case time complexity of </st><img src="image/1071.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1340"/><st c="35088"/><st c="35089"> for these operations. </st><st c="35112">Despite this, the average-case performance remains robust, making skip lists a practical choice for dynamic data structures where balanced search, insertion, and deletion times </st><span><st c="35289">are crucial.</st></span></p>
			<h1 id="_idParaDest-166" class="calibre5"><a id="_idTextAnchor195" class="pcalibre pcalibre1 calibre6"/><st c="35301">Stacks</st></h1>
			<p class="calibre3"><st c="35308">A </st><strong class="bold"><st c="35311">stack</st></strong><st c="35316"> is a</st><a id="_idIndexMarker775" class="pcalibre pcalibre1 calibre6"/><st c="35321"> linear data structure that follows the LIFO principle, meaning that the last element added to the stack is the first one to be removed. </st><st c="35458">Think of it as a stack of plates: we add new plates on top, and when we need a plate, we take the top one off first. </st><st c="35575">Stacks are used in various applications, including expression evaluation, function call management, and undo mechanisms </st><span><st c="35695">in software.</st></span></p>
			<p class="calibre3"><st c="35707">Stacks have several</st><a id="_idIndexMarker776" class="pcalibre pcalibre1 calibre6"/><st c="35727"> defining characteristics that influence their behavior </st><span><st c="35783">and performance:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="35799">LIFO order</st></strong><st c="35810">: The last element inserted into the stack is the first one to be removed. </st><st c="35886">For example, if we push the numbers </st><strong class="source-inline1"><st c="35922">1</st></strong><st c="35923">, </st><strong class="source-inline1"><st c="35925">2</st></strong><st c="35926">, and </st><strong class="source-inline1"><st c="35932">3</st></strong><st c="35933"> onto a stack, we will pop them off in the reverse order: </st><strong class="source-inline1"><st c="35991">3</st></strong><st c="35992">, </st><span><strong class="source-inline1"><st c="35994">2</st></strong></span><span><st c="35995">, </st></span><span><strong class="source-inline1"><st c="35997">1</st></strong></span><span><st c="35998">.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="35999">Operations performed at one end</st></strong><st c="36031">: All insertions (push) and deletions (pop) are performed at the top of the stack. </st><st c="36115">There is no direct access to elements in the middle or bottom of the stack. </st><st c="36191">If we push several elements onto a stack, we can only access the most recently added element directly. </st><st c="36294">It also means there is no random access to the stack. </st><st c="36348">Unlike arrays, we cannot directly access elements at a specific index in a stack. </st><st c="36430">Access is restricted to the top </st><span><st c="36462">element only.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="36475">Dynamic size</st></strong><st c="36488">: Stacks can dynamically grow or shrink as elements are pushed or popped. </st><st c="36563">As we push more elements onto a stack, its size increases, and as we pop elements off, its </st><span><st c="36654">size decreases.</st></span></li>
			</ul>
			<p class="calibre3"><st c="36669">Stacks support a few fundamental operations, each with specific performance characteristics. </st><st c="36763">The following are these major operations, along with their time complexities </st><span><st c="36840">and examples:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="source-inline1"><st c="36853">push</st></strong><st c="36858">: It adds a new element to the top of the stack. </st><st c="36908">Its time complexity is </st><img src="image/1266.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre964"/><st c="36931"/><st c="36932">, as the operation involves simply adding an element to the top of the stack. </st><st c="37010">The following is a simple </st><span><st c="37036">Python example:</st></span><pre class="source-code"><st c="37051" class="calibre11">
stack = []
stack.append(3)  # Stack is now [3]
stack.append(5)  # Stack is now [3, 5]
print(stack)</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="37148">pop</st></strong><st c="37152">: This removes the top element from the stack. </st><st c="37200">It performs the removal in constant time (</st><img src="image/1046.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre809"/><st c="37242"/><st c="37244">).  </st><st c="37247">The following is a </st><span><st c="37266">Python example:</st></span><pre class="source-code"><st c="37281" class="calibre11">
top_element = stack.pop()
print(stack)</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="37320">peek</st></strong><st c="37325">: It is</st><a id="_idIndexMarker777" class="pcalibre pcalibre1 calibre6"/><st c="37333"> for retrieving the value of the top element without removing it from the stack. </st><st c="37414">For the stack </st><strong class="source-inline1"><st c="37428">[1, 2, 3]</st></strong><st c="37437">, peeking would return </st><strong class="source-inline1"><st c="37460">3</st></strong><st c="37461"> without altering the stack. </st><st c="37490">The time complexity is </st><img src="image/1827.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1341"/><st c="37513"/><st c="37514">, as it only involves accessing the top element. </st><st c="37563">A simple Python instruction is </st><span><st c="37594">as follows:</st></span><pre class="source-code"><st c="37605" class="calibre11">
top_element = stack[-1]</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="37629">search</st></strong><st c="37636">: As usual, this is for finding an element in the stack. </st><st c="37694">For example, if we search for element </st><strong class="source-inline1"><st c="37732">2</st></strong><st c="37733"> in the stack </st><strong class="source-inline1"><st c="37747">[1, 2, 3]</st></strong><st c="37756">, we would find it at position 1 from the top. </st><st c="37803">Obviously, the time complexity of </st><strong class="source-inline1"><st c="37837">search</st></strong><st c="37843"> in stacks is </st><img src="image/1828.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mi&gt;n&lt;/mml:mi&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1342"/><st c="37857"/><st c="37858">, as it may require scanning through the entire stack from top to bottom. </st><st c="37932">Let’s see a simple </st><span><st c="37951">Python example:</st></span><pre class="source-code"><st c="37966" class="calibre11">
element_to_find = 2
position = stack.index(element_to_find)  # Finds the position of 2 in the stack</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="38065">edit</st></strong><st c="38070">: This modifies the value of the top element in the stack. </st><st c="38130">If the top element of the stack </st><strong class="source-inline1"><st c="38162">[1, 2, 3]</st></strong><st c="38171"> is </st><strong class="source-inline1"><st c="38175">3</st></strong><st c="38176"> and we want to change it to </st><strong class="source-inline1"><st c="38205">5</st></strong><st c="38206">, the stack would become </st><strong class="source-inline1"><st c="38231">[1, 2, 5]</st></strong><st c="38240">. It does this operation in constant time (</st><img src="image/1829.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1343"/><st c="38283"/><st c="38285">) since the operation only affects the top element. </st><st c="38337">A Python code example is </st><span><st c="38362">as follows:</st></span><pre class="source-code"><st c="38373" class="calibre11">
stack[-1] = 5  # Changes the top element to 5; Stack becomes [3, 5]</st></pre></li>			</ul>
			<p class="calibre3"><st c="38440">Some programming languages also support additional operations such as </st><strong class="source-inline"><st c="38511">isFull</st></strong><st c="38517">, which checks whether the stack is full, and </st><strong class="source-inline"><st c="38563">isEmpty</st></strong><st c="38570">, which determines whether the stack </st><span><st c="38607">is empty.</st></span></p>
			<p class="calibre3"><st c="38616">Stacks are extensively</st><a id="_idIndexMarker778" class="pcalibre pcalibre1 calibre6"/><st c="38639"> used in computer programming for several key applications. </st><st c="38699">Here are a few important </st><span><st c="38724">use cases:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><st c="38734">Stacks store function calls, pushing each invocation onto the stack and popping it when the </st><span><st c="38827">function completes</st></span></li>
				<li class="calibre13"><st c="38845">They are used for converting and evaluating expressions, particularly for changing infix expressions to postfix or </st><span><st c="38961">prefix notation</st></span></li>
				<li class="calibre13"><st c="38976">Stacks implement undo features in software, where each action is pushed onto the stack and can be undone by popping </st><span><st c="39093">it off</st></span></li>
			</ul>
			<p class="calibre3"><st c="39099">Stacks are a fundamental and versatile data structure used in many algorithms and applications. </st><st c="39196">They provide efficient </st><strong class="source-inline"><st c="39219">push</st></strong><st c="39223"> and </st><strong class="source-inline"><st c="39228">pop</st></strong><st c="39231"> operations with a time complexity of </st><img src="image/1830.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1344"/><st c="39269"/><st c="39270"> and are particularly useful in scenarios where the last element added needs to be the first one removed. </st><st c="39376">However, their lack of random access and LIFO nature can make them less suitable for situations where elements need to be accessed in a different order. </st><st c="39529">Understanding the trade-offs and appropriate use cases for stacks is essential for effective algorithm design and implementation. </st><st c="39659">In the next section, we will explore queues, which operate in a manner opposite </st><span><st c="39739">to stacks.</st></span></p>
			<h1 id="_idParaDest-167" class="calibre5"><a id="_idTextAnchor196" class="pcalibre pcalibre1 calibre6"/><st c="39749">Queue</st></h1>
			<p class="calibre3"><st c="39755">A </st><strong class="bold"><st c="39758">queue</st></strong><st c="39763"> operates</st><a id="_idIndexMarker779" class="pcalibre pcalibre1 calibre6"/><st c="39772"> on the FIFO principle, meaning it has a behavior opposite to stacks: The first element added is the first to be removed. </st><st c="39894">This structure is analogous to a line of people waiting for service: The first person in line is the first to be served. </st><st c="40015">Queues are used in various scenarios, including task scheduling, buffering, and managing resources in </st><span><st c="40117">computer systems.</st></span></p>
			<p class="calibre3"><st c="40134">Queues have several </st><a id="_idIndexMarker780" class="pcalibre pcalibre1 calibre6"/><st c="40155">characteristics that influence their behavior </st><span><st c="40201">and performance:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="40217">FIFO order</st></strong><st c="40228">: The first element inserted into the queue is the first one to </st><span><st c="40293">be removed.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="40304">Operations at opposite ends</st></strong><st c="40332">: Elements are added at the rear (end) of the queue and removed from the front (beginning) of </st><span><st c="40427">the queue.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="40437">Dynamic size</st></strong><st c="40450">: Queues </st><a id="_idIndexMarker781" class="pcalibre pcalibre1 calibre6"/><st c="40460">can dynamically grow or shrink as elements are enqueued or dequeued. </st><st c="40529">As we enqueue more elements, the size of the queue increases, and as we dequeue elements, the </st><span><st c="40623">size decreases.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="40638">No random access</st></strong><st c="40655">: Like stacks and unlike arrays, we cannot directly access elements at a specific index in a queue. </st><st c="40756">Access is restricted to the front </st><span><st c="40790">element only.</st></span></li>
			</ul>
			<p class="calibre3"><st c="40803">Queues support some fundamental operations, each with specific performance characteristics. </st><st c="40896">The following are the </st><span><st c="40918">major operations:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="source-inline1"><st c="40935">enqueue</st></strong><st c="40943">: This</st><a id="_idIndexMarker782" class="pcalibre pcalibre1 calibre6"/><st c="40950"> involves adding a new element to the rear of the queue. </st><st c="41007">Consider a queue that currently holds the elements </st><strong class="source-inline1"><st c="41058">1</st></strong><st c="41059"> and </st><strong class="source-inline1"><st c="41064">2</st></strong><st c="41065">. Enqueuing </st><strong class="source-inline1"><st c="41077">3</st></strong><st c="41078"> into the queue would place it at the rear, resulting in the queue </st><strong class="source-inline1"><st c="41145">[1, 2, 3]</st></strong><st c="41154">. This operation is performed in constant time or </st><img src="image/1189.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre773"/><st c="41204"/><st c="41205">, as the operation involves simply adding an element to the end of the queue. </st><st c="41283">A simple Python example is </st><span><st c="41310">as follows:</st></span><pre class="source-code"><st c="41321" class="calibre11">
queue = []
queue.append(1)  # Queue is now [1]
queue.append(2)  # Queue is now [1, 2]
queue.append(3)  # Queue is now [1, 2, 3]
print(queue)</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="41459">dequeue</st></strong><st c="41467">: It </st><a id="_idIndexMarker783" class="pcalibre pcalibre1 calibre6"/><st c="41473">removes the front element from the queue. </st><st c="41515">If we dequeue the queue </st><strong class="source-inline1"><st c="41539">[1, 2, 3]</st></strong><st c="41548">, the front element </st><strong class="source-inline1"><st c="41568">1</st></strong><st c="41569"> is removed, leaving us with the queue </st><strong class="source-inline1"><st c="41608">[2, 3]</st></strong><st c="41614">. Similar to </st><strong class="source-inline1"><st c="41627">enqueue</st></strong><st c="41634">, the time complexity here is </st><img src="image/1832.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mfenced separators=&quot;|&quot;&gt;&lt;mml:mrow&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;/mml:mrow&gt;&lt;/mml:mfenced&gt;&lt;/mml:math&gt;" class="calibre1345"/><st c="41664"/><st c="41665">, as it involves removing the front element. </st><st c="41710">Here is a simple </st><span><st c="41727">Python instruction:</st></span><pre class="source-code"><st c="41746" class="calibre11">
front_element = queue.pop(0)</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="41775">peek</st></strong><st c="41780">: This is</st><a id="_idIndexMarker784" class="pcalibre pcalibre1 calibre6"/><st c="41790"> for retrieving the value of the front element without removing it from the queue and it performs in constant time. </st><st c="41906">For the queue </st><strong class="source-inline1"><st c="41920">[1, 2, 3]</st></strong><st c="41929">, peeking would return </st><strong class="source-inline1"><st c="41952">1</st></strong><st c="41953"> without altering the queue. </st><st c="41982">The Python instruction for peeking can be like </st><span><st c="42029">the following:</st></span><pre class="source-code"><st c="42043" class="calibre11">
front_element = queue[0]</st></pre></li>				<li class="calibre13"><strong class="source-inline1"><st c="42068">search</st></strong><st c="42075">: A </st><a id="_idIndexMarker785" class="pcalibre pcalibre1 calibre6"/><st c="42080">queue conducts a search in linear time, as it may require scanning through the entire queue from front to rear. </st><st c="42192">The following is a Python code implementing a search in </st><span><st c="42248">a queue:</st></span><pre class="source-code"><st c="42256" class="calibre11">
target = 2
position = queue.index(target)</st></pre></li>			</ul>
			<p class="calibre3"><st c="42298">Some programming languages also support additional operations such as </st><strong class="source-inline"><st c="42369">isFull</st></strong><st c="42375">, which checks whether the queue is full, and </st><strong class="source-inline"><st c="42421">isNull</st></strong><st c="42427">, which determines whether the queue </st><span><st c="42464">is empty.</st></span></p>
			<p class="calibre3"><st c="42473">Similar to stacks, queues</st><a id="_idIndexMarker786" class="pcalibre pcalibre1 calibre6"/><st c="42499"> have numerous applications in computer programming. </st><st c="42552">A well-known example is </st><strong class="bold"><st c="42576">task scheduling</st></strong><st c="42591">, where queues are used in operating systems to manage processes. </st><st c="42657">Processes are enqueued when they are ready to run and dequeued once they are executed. </st><st c="42744">Another example is buffering, where queues temporarily store data before it is processed, such as in print queues or streaming services. </st><st c="42881">Lastly, queues play a crucial role in resource management, ensuring that access to shared resources is handled in the order requests </st><span><st c="43014">are received.</st></span></p>
			<p class="calibre3"><st c="43027">Queues are a fundamental data structure used in many algorithms and applications, particularly in scenarios that require managing tasks or resources in a FIFO manner. </st><st c="43195">They provide efficient enqueue and dequeue operations with a time complexity of </st><img src="image/1833.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1346"/><st c="43275"/><st c="43276"> but do not allow random access to elements. </st><st c="43321">Understanding the appropriate use cases for queues is essential for effective algorithm design and implementation. </st><st c="43436">In the final section of this chapter, we expand on the concept of a queue by introducing a structure that has two ends, effectively combining the functionalities of both a stack and </st><span><st c="43618">a queue.</st></span></p>
			<h1 id="_idParaDest-168" class="calibre5"><a id="_idTextAnchor197" class="pcalibre pcalibre1 calibre6"/><st c="43626">Deque</st></h1>
			<p class="calibre3"><st c="43632">A </st><strong class="bold"><st c="43635">deque</st></strong><st c="43640"> is a </st><a id="_idIndexMarker787" class="pcalibre pcalibre1 calibre6"/><st c="43646">versatile data structure that allows the insertion and deletion of elements from both ends of the sequence, making it a generalization of both stacks and queues. </st><st c="43808">Deques can operate as both a stack and a queue, providing greater flexibility in how elements are added </st><span><st c="43912">or removed.</st></span></p>
			<p class="calibre3"><st c="43923">Let’s highlight the</st><a id="_idIndexMarker788" class="pcalibre pcalibre1 calibre6"/><st c="43943"> properties </st><span><st c="43955">of deques:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="43965">Insertions and deletions at both ends</st></strong><st c="44003">: Elements can be added or removed from either the front or the rear of the deque. </st><st c="44087">For example, we can push elements onto the front or rear of the deque and pop them off from either end </st><span><st c="44190">as well.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="44198">No fixed direction</st></strong><st c="44217">: Deques do not enforce a strict LIFO or FIFO order; instead, they allow operations at both ends. </st><st c="44316">For instance, we can treat a deque as a stack by only using one end or as a queue by using </st><span><st c="44407">both ends.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="44417">Dynamic size</st></strong><st c="44430">: Deques can dynamically grow or shrink as elements are added or removed from </st><span><st c="44509">either end.</st></span></li>
				<li class="calibre13"><strong class="bold"><st c="44520">No random access</st></strong><st c="44537">: Like stacks and queues, deques do not allow direct access to elements at a </st><span><st c="44615">specific index.</st></span></li>
			</ul>
			<p class="calibre3"><st c="44630">Deques support a wide range of operations, each with specific performance characteristics. </st><st c="44722">The following </st><a id="_idIndexMarker789" class="pcalibre pcalibre1 calibre6"/><st c="44736">are the major operations, along with their time complexities </st><span><st c="44797">and examples:</st></span></p>
			<ul class="calibre14">
				<li class="calibre13"><strong class="bold"><st c="44810">Add to front (insert at the front)</st></strong><st c="44845">: This involves adding a new element to the front of the deque. </st><st c="44910">For example, if the deque currently holds </st><strong class="source-inline1"><st c="44952">[2, 3]</st></strong><st c="44958">, adding </st><strong class="source-inline1"><st c="44967">1</st></strong><st c="44968"> to the front would result in </st><strong class="source-inline1"><st c="44998">[1, 2, 3]</st></strong><st c="45007">. This is done in constant time, as the operation involves simply adding an element to the front. </st><st c="45105">Here is a simple piece of </st><span><st c="45131">Python code:</st></span><pre class="source-code"><st c="45143" class="calibre11">
from collections import deque
d = deque([2, 3])
d.appendleft(1)  # Deque is now [1, 2, 3]
print(d)</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="45241">Add to rear (insert at the rear)</st></strong><st c="45274">: This adds a new element to the rear of the deque. </st><st c="45327">If the deque currently holds </st><strong class="source-inline1"><st c="45356">[1, 2]</st></strong><st c="45362">, adding </st><strong class="source-inline1"><st c="45371">3</st></strong><st c="45372"> to the rear would result in </st><strong class="source-inline1"><st c="45401">[1, 2, 3]</st></strong><st c="45410">. Similar to </st><em class="italic"><st c="45423">add to front</st></em><st c="45435">, the time complexity is </st><img src="image/1425.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1347"/><st c="45460"/><st c="45461">. The following is a simple Python instruction to do </st><span><st c="45514">this operation:</st></span><pre class="source-code"><st c="45529" class="calibre11">
d.append(3)  # Deque is now [1, 2, 3]</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="45566">Remove from front (delete from the front)</st></strong><st c="45608">: This operation removes the front </st><a id="_idIndexMarker790" class="pcalibre pcalibre1 calibre6"/><st c="45644">element from the deque in constant time. </st><st c="45685">If we remove the front element from the deque </st><strong class="source-inline1"><st c="45731">[1, 2, 3]</st></strong><st c="45740">, it becomes </st><strong class="source-inline1"><st c="45753">[2, 3]</st></strong><st c="45759">. A simple Python instruction to execute the </st><em class="italic"><st c="45804">remove from front</st></em><st c="45821"> operation is </st><span><st c="45835">as follows:</st></span><pre class="source-code"><st c="45846" class="calibre11">
front_element = d.popleft</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="45872">Remove from rear (delete from the rear)</st></strong><st c="45912">: Similar to the previous operation, only from the rear of the deque. </st><st c="45983">The Python code for this operation is </st><span><st c="46021">as follows:</st></span><pre class="source-code"><st c="46032" class="calibre11">
rear_element = d.pop()</st></pre></li>				<li class="calibre13"><strong class="bold"><st c="46055">Peek (access the front or rear element)</st></strong><st c="46095">: Retrieve the value of the front or rear element without removing it from the deque in constant time. </st><st c="46199">For the deque </st><strong class="source-inline1"><st c="46213">[1, 2, 3]</st></strong><st c="46222">, peeking the front would return </st><strong class="source-inline1"><st c="46255">1</st></strong><st c="46256">, and peeking the rear would </st><span><st c="46285">return </st></span><span><strong class="source-inline1"><st c="46292">3</st></strong></span><span><st c="46293">:</st></span><pre class="source-code"><st c="46294" class="calibre11">
front_element = d[0]  #Returns the front element w/o removing it; Deque remains [1, 2]
rear_element = d[-1]  #Returns the rear element w/o removing it; Deque remains [1, 2]</st></pre></li>			</ul>
			<p class="calibre3"><st c="46465">It’s important to note that many of the functions used for a deque may or may not be supported by different programming languages. </st><st c="46597">Fortunately, Python provides built-in support for </st><span><st c="46647">these functions.</st></span></p>
			<p class="calibre3"><st c="46663">Deques have several important use cases in computer programming. </st><st c="46729">One key example is task scheduling, where deques are used in scheduling algorithms to add or remove tasks from either end of the queue as needed. </st><st c="46875">Another use case is in sliding window algorithms, where deques are employed to efficiently manage elements as they are added or removed from the window while it moves across a dataset. </st><st c="47060">Lastly, deques are also used in implementing undo/redo functionality in applications, allowing actions to be added or removed from either end of </st><span><st c="47205">the deque.</st></span></p>
			<p class="calibre3"><st c="47215">Deques are a flexible </st><a id="_idIndexMarker791" class="pcalibre pcalibre1 calibre6"/><st c="47238">data structure that generalizes both stacks and queues, allowing insertion and deletion at both ends. </st><st c="47340">They provide efficient operations with a time complexity of </st><img src="image/1189.png" alt="&lt;mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:m=&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot;&gt;&lt;mml:mi&gt;O&lt;/mml:mi&gt;&lt;mml:mo&gt;(&lt;/mml:mo&gt;&lt;mml:mn&gt;1&lt;/mml:mn&gt;&lt;mml:mo&gt;)&lt;/mml:mo&gt;&lt;/mml:math&gt;" class="calibre1348"/><st c="47400"/><st c="47401"> for adding or removing elements at either end. </st><st c="47449">Deques are particularly useful in scenarios where elements need to be managed from both ends, such as task scheduling, sliding window algorithms, and undo/redo functionality. </st><st c="47624">Understanding the appropriate use cases for deques is essential for effective algorithm design </st><span><st c="47719">and implementation.</st></span></p>
			<h1 id="_idParaDest-169" class="calibre5"><a id="_idTextAnchor198" class="pcalibre pcalibre1 calibre6"/><st c="47738">Summary</st></h1>
			<p class="calibre3"><st c="47746">In this chapter, we explored various linear data structures, focusing on their definitions, characteristics, and operations. </st><st c="47872">We began with an in-depth look at arrays and linked lists, examining how they handle fundamental operations such as insertion, deletion, and searching. </st><st c="48024">We discussed the trade-offs between these structures, noting the efficiency of arrays in accessing elements and the flexibility of linked lists in dynamic memory allocation. </st><st c="48198">The chapter also covered more advanced linear structures such as stacks, queues, and deques, illustrating their practical applications in computer programming, from task scheduling to expression evaluation and </st><span><st c="48408">resource management.</st></span></p>
			<p class="calibre3"><st c="48428">We then introduced the skip list, a probabilistic data structure that combines the advantages of both arrays and linked lists, offering efficient search, insertion, and deletion operations. </st><st c="48619">Through detailed examples, we demonstrated how skip lists improve upon the limitations of traditional linked lists. </st><st c="48735">As we concluded the chapter, we emphasized the importance of understanding the appropriate use cases for each data structure to optimize algorithm design. </st><st c="48890">You now have a thorough understanding of linear data structures, which play a crucial role in algorithm design. </st><st c="49002">In the next chapter, we will shift our focus to non-linear data structures, exploring their unique properties </st><span><st c="49112">and applications.</st></span></p>
			<h1 id="_idParaDest-170" class="calibre5"><a id="_idTextAnchor199" class="pcalibre pcalibre1 calibre6"/><st c="49129">References and further reading</st></h1>
			<ul class="calibre14">
				<li class="calibre13"><em class="italic"><st c="49160">Introduction to Algorithms</st></em><st c="49187">. By Thomas H. </st><st c="49202">Cormen, Charles E. </st><st c="49221">Leiserson, Ronald L. </st><st c="49242">Rivest, and Clifford Stein. </st><st c="49270">Fourth Edition. </st><st c="49286">MIT </st><span><st c="49290">Press. </st><st c="49297">2022:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="49302">Chapter 10</st></em><st c="49313">, </st><em class="italic"><st c="49315">Elementary </st></em><span><em class="italic"><st c="49326">Data Structures</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="49341">Algorithms</st></em><st c="49352">. By R. </st><st c="49360">Sedgewick, K. </st><st c="49374">Wayne. </st><st c="49381">Fourth Edition. </st><span><st c="49397">Addison-Wesley. </st><st c="49413">2011:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="49418">Chapter </st></em><span><em class="italic"><st c="49427">1</st></em></span><span><st c="49428">, </st></span><span><em class="italic"><st c="49430">Fundamentals</st></em></span></li></ul></li>
				<li class="calibre13"><em class="italic"><st c="49442">Data Structures and Algorithm Analysis in C++</st></em><st c="49488">. By Mark A. </st><st c="49501">Weiss. </st><st c="49508">Fourth Edition. </st><span><st c="49524">Pearson. </st><st c="49533">2012:</st></span><ul class="calibre50"><li class="calibre13"><em class="italic"><st c="49538">Chapter 3</st></em><st c="49548">, </st><em class="italic"><st c="49550">Lists, Stacks, </st></em><span><em class="italic"><st c="49565">and Queues</st></em></span></li></ul></li>
			</ul>
		</div>
	<div id="charCountTotal" value="49575" class="calibre2"/></body></html>