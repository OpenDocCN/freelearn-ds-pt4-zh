["```py\n     # Define an array (list) of integers\n    a = [10, 20, 30, 40, 50]\n    # Print the array\n    print(a)  # Outputs: [10, 20, 30, 40, 50]\n    ```", "```py\n     a = [1, 2, 3, 4]\n    a.insert(1, 5)  # a becomes [1, 5, 2, 3, 4]\n    print(a)\n    ```", "```py\n     a = [1, 2, 3, 4]\n    a.pop(1)  # a becomes [1, 3, 4]\n    ```", "```py\n     a = [1, 2, 3, 4]\n    a[2] = 5  # a becomes [1, 2, 5, 4]\n    ```", "```py\n matrix = [\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9]\n]\nprint(matrix[1][2])  # Outputs: 6 (element at second row, third column)\n```", "```py\n class Node:\n    def __init__(self, data):\n        self.data = data  # Store data\n        self.next = None  # Initialize next as null (None in Python)\nclass LinkedList:\n    def __init__(self):\n        self.head = None  # Initialize the head of the list as None\n    def insert_after(self, prev_node, new_data):\n        if prev_node is None:\n            print(\"The given previous node must be in the LinkedList.\")\n            return\n        new_node = Node(new_data)  # Create a new node with the provided data\n        new_node.next = prev_node.next  # Point the new node to the next node (e.g., 4)\n        prev_node.next = new_node  # Point the previous node (e.g., 2) to the new node (e.g., 3)\n    def print_list(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=\" -> \")\n            temp = temp.next\n        print(\"None\")\n```", "```py\n if __name__ == \"__main__\":\n    llist = LinkedList()\n    # Creating the initial linked list 1 -> 2 -> 4\n    llist.head = Node(1)\n    second = Node(2)\n    third = Node(4)\n    llist.head.next = second\n    second.next = third\n    # Insert 3 between 2 and 4\n    llist.insert_after(second, 3)\n    # Print the updated linked list\n    llist.print_list()\n```", "```py\n def delete_node(self, key):\n    temp = self.head\n    if (temp is not None):\n        if (temp.data == key):\n            self.head = temp.next\n            temp = None\n            return\n    while(temp is not None):\n        if temp.data == key:\n            break\n        prev = temp\n        temp = temp.next\n    if(temp == None):\n        return\n    prev.next = temp.next\n    temp = None\n# Example usage:\nllist.delete_node(3)  # Deletes the node with value 3\nllist.print_list()\n```", "```py\n def update_node(self, old_data, new_data):\n    temp = self.head\n    while temp is not None:\n        if temp.data == old_data:\n            temp.data = new_data\n            return\n        temp = temp.next\n# Example usage:\nllist.update_node(2, 5)  # Updates node with value 2 to 5\n```", "```py\n def search_node(self, key):\n    temp = self.head\n    while temp is not None:\n        if temp.data == key:\n            return True\n        temp = temp.next\n    return False\n# Example usage:\nfound = llist.search(3)  # Returns True if 3 is found\n```", "```py\n def get_nth(self, index):\n    temp = self.head\n    count = 0\n    while (temp):\n        if (count == index):\n            return temp.data\n    count += 1\n    temp = temp.next\n    return None\n# Example usage:\nvalue = llist.get_nth(2)  # Returns the value of the third node\n```", "```py\n import random\nclass Node:\n    def __init__(self, value, level):\n        self.value = value\n        self.forward = [None] * (level + 1)\nclass SkipList:\n    def __init__(self, max_level):\n        self.max_level = max_level\n        self.head = Node(-1, max_level)  # Head node with value -1 (acts as a sentinel)\n        self.level = 0\n    def random_level(self):\n        level = 0\n        while random.random() < 0.5 and level < self.max_level:\n            level += 1\n        return level\n    def insert(self, value):\n        update = [None] * (self.max_level + 1)\n        current = self.head\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n            update[i] = current\n        level = self.random_level()\n        if level > self.level:\n            for i in range(self.level + 1, level + 1):\n                update[i] = self.head\n            self.level = level\n        new_node = Node(value, level)\n        for i in range(level + 1):\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n    def print_skiplist(self):\n        print(\"Skip List:\")\n        for i in range(self.level, -1, -1):\n            print(f\"Level {i}: \", end=\"\")\n            node = self.head.forward[i]\n            while node:\n                print(node.value, end=\" -> \")\n                node = node.forward[i]\n            print(\"None\")\n# Example usage\nif __name__ == \"__main__\":\n    skiplist = SkipList(3)\n    # Insert elements into the skip list\n    skiplist.insert(3)\n    skiplist.insert(4)\n    skiplist.insert(5)\n    skiplist.insert(7)\n    skiplist.insert(8)\n    skiplist.insert(9)\n    skiplist.insert(10)\n    # Print the skip list\n    skiplist.print_skiplist()\n```", "```py\n Skip List:\nLevel 2: 7 --> 10 --> None\nLevel 1: 5 --> 7 --> 8 --> 9 --> 10 --> None\nLevel 0: 3 --> 4 --> 5 --> 7 --> 8 --> 9 --> 10 --> None\n```", "```py\n def search(self, value):\n        current = self.head\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n        current = current.forward[0]\n        if current and current.value == value:\n            return True\n        return False\n```", "```py\n if __name__ == \"__main__\":\n    skiplist = SkipList(3)\n    skiplist.insert(3)\n    skiplist.insert(4)\n    skiplist.insert(5)\n    skiplist.insert(7)\n    skiplist.insert(8)\n    skiplist.insert(9)\n    skiplist.insert(10)\n    skiplist.print_skiplist()\n    value_to_search = 7\n    found = skiplist.search(value_to_search)\n    print(f\"\\nSearch for {value_to_search}: {'Found' if found else 'Not Found'}\")\n    value_to_search = 6\n    found = skiplist.search(value_to_search)\n    print(f\"Search for {value_to_search}: {'Found' if found else 'Not Found'}\")\n```", "```py\n Skip List:\nLevel 1: 3 --> 8 --> 9 --> 10 --> None\nLevel 0: 3 --> 4 --> 5 --> 7 --> 8 --> 9 --> 10 --> None\nSearch for 7: Found\nSearch for 6: Not Found\n```", "```py\n     stack = []\n    stack.append(3)  # Stack is now [3]\n    stack.append(5)  # Stack is now [3, 5]\n    print(stack)\n    ```", "```py\n     top_element = stack.pop()\n    print(stack)\n    ```", "```py\n     top_element = stack[-1]\n    ```", "```py\n     element_to_find = 2\n    position = stack.index(element_to_find)  # Finds the position of 2 in the stack\n    ```", "```py\n     stack[-1] = 5  # Changes the top element to 5; Stack becomes [3, 5]\n    ```", "```py\n     queue = []\n    queue.append(1)  # Queue is now [1]\n    queue.append(2)  # Queue is now [1, 2]\n    queue.append(3)  # Queue is now [1, 2, 3]\n    print(queue)\n    ```", "```py\n     front_element = queue.pop(0)\n    ```", "```py\n     front_element = queue[0]\n    ```", "```py\n     target = 2\n    position = queue.index(target)\n    ```", "```py\n     from collections import deque\n    d = deque([2, 3])\n    d.appendleft(1)  # Deque is now [1, 2, 3]\n    print(d)\n    ```", "```py\n     d.append(3)  # Deque is now [1, 2, 3]\n    ```", "```py\n     front_element = d.popleft\n    ```", "```py\n     rear_element = d.pop()\n    ```", "```py\n     front_element = d[0]  #Returns the front element w/o removing it; Deque remains [1, 2]\n    rear_element = d[-1]  #Returns the rear element w/o removing it; Deque remains [1, 2]\n    ```"]