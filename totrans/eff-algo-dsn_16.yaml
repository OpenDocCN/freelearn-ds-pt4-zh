- en: <st c="0">12</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Linear Data Structures</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="26">In this chapter, we will explore the foundational concepts of</st>
    **<st c="89">linear data structures</st>**<st c="111">, which play a</st> <st
    c="125">critical role in computer science and algorithm design.</st> <st c="182">We
    will start by understanding the basics of arrays and linked lists and learning
    how these structures store and manage data.</st> <st c="308">The chapter will
    guide you through the key operations performed on these structures, such as insertion,
    deletion, and searching, and you will examine their time complexities to understand
    their efficiency.</st> <st c="514">By comparing arrays and linked lists, you will
    gain insight into the trade-offs involved in choosing the right data structure
    for</st> <st c="644">specific applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="666">As we progress, we will discover more advanced linear data structures
    such as stacks, queues, and</st> **<st c="765">double-ended queues</st>** <st
    c="784">(</st>**<st c="786">deques</st>**<st c="792">).</st> <st c="796">We</st>
    <st c="799">will learn how these structures extend the functionality of basic
    lists and how they are applied in real-world scenarios, such as task scheduling
    and resource management.</st> <st c="970">Additionally, the chapter will introduce
    you to</st> **<st c="1018">skip lists</st>**<st c="1028">, a</st> <st c="1032">probabilistic
    data structure that offers a balance between the efficiency of arrays and the
    flexibility of linked lists.</st> <st c="1153">By the end of this chapter, you
    will be well-equipped with the knowledge needed to implement and utilize these
    linear data</st> <st c="1276">structures effectively.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1299">Essentially, this chapter will cover the</st> <st c="1341">following
    topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1358">Lists</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1364">Skip lists</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1375">Stacks</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1382">Queue</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1388">Deque</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1394">Lists</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1400">A</st> **<st c="1403">list</st>** <st c="1407">is</st> <st c="1411">an
    ordered collection of items that can hold elements of the same or different types,
    where each element is indexed and has a specific position within the list.</st>
    <st c="1572">Lists are commonly used to store sequences of data that can be easily
    accessed, inserted, or removed.</st> <st c="1674">They can hold elements of different
    types, though in some programming languages, lists are more often homogeneous,
    meaning all elements are of the</st> <st c="1821">same type.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1831">Lists are generally implemented using either arrays or linked structures,
    and these two approaches result in distinct characteristics regarding performance
    and memory usage.</st> <st c="2006">When elements in a list are stored in contiguous
    memory locations, the list is known as an</st> **<st c="2097">array</st>**<st
    c="2102">. In</st> <st c="2106">this case, accessing elements by index is very
    efficient, typically taking constant time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="2197"><st c="2199">), since the memory location of any element can be directly
    computed.</st> <st c="2269">However, arrays have a fixed size once they are created,
    which can lead to inefficiencies if the number of elements changes frequently,
    requiring the creation of new arrays and copying</st> <st c="2454">of data.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2462">On the other hand, if the list is implemented using linked structures,
    it is referred to as a</st> **<st c="2557">linked list</st>**<st c="2568">. In
    a</st> <st c="2574">linked list, each element, known as</st> <st c="2610">a</st>
    **<st c="2613">node</st>**<st c="2617">, contains a reference (or link) to the
    next node in the sequence.</st> <st c="2684">This structure allows the list to
    grow and shrink dynamically as elements are added or removed, without the need
    for large blocks of contiguous memory.</st> <st c="2836">However, because the
    nodes are scattered throughout memory, accessing an element by index requires
    traversing the list from the beginning, which can be time-consuming (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)
    <st c="3004"><st c="3006">in the</st> <st c="3014">worst case).</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3026">The choice between using an array or a linked list depends on the
    specific needs of the application, such as the frequency of insertions and deletions
    versus the need for quick access to elements.</st> <st c="3224">Arrays are generally
    preferred when fast access and predictable memory usage are crucial, while linked
    lists are more suitable for scenarios where dynamic resizing and frequent modifications
    are needed.</st> <st c="3427">In the following subsections, we will explore the
    key characteristics of arrays, particularly in relation to algorithm efficiency
    and the various operations that can be performed</st> <st c="3606">on them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3614">Arrays</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3621">An</st> **<st c="3625">array</st>** <st c="3630">is</st> <st c="3634">a
    fundamental data structure that consists of a collection of elements, each identified
    by</st> <st c="3725">at least one array index or key.</st> <st c="3758">Arrays
    are one of the simplest and most widely used data structures in computer science.</st>
    <st c="3847">They are typically used to store a fixed-size sequence of elements
    of the same type.</st> <st c="3932">The position of each element is defined by
    its index, which usually starts</st> <st c="4007">from zero.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4017">Arrays possess the</st> <st c="4036">following</st> <st c="4047">defining
    characteristics that influence their behavior</st> <st c="4102">and performance:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="4118">Fixed size</st>**<st c="4129">: Once an array is created, its
    size is set and cannot be altered.</st> <st c="4197">This means that the number
    of elements that an array can hold is predetermined at the time of its creation.</st>
    <st c="4305">For example, in most programming languages, we must specify the size
    of an array when it is declared, such as</st> **<st c="4415">int[] a = new int[10];</st>**
    <st c="4437">in Java, which creates an array that can hold 10 integers.</st> <st
    c="4497">The following is a simple array declaration</st> <st c="4541">in Python:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="4672">Contiguous memory allocation</st>**<st c="4701">: The elements
    of an array are stored in contiguous memory locations.</st> <st c="4772">This
    enables efficient access to any element by calculating its memory address using
    a simple mathematical formula.</st> <st c="4888">For instance, in a one-dimensional
    array</st> *<st c="4929">a</st>* <st c="4930">of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/477.png)<st
    c="4939"><st c="4940">, the address of the element</st> *<st c="4969">a[i]</st>*
    <st c="4973">can be calculated as</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>i</mi><mi
    mathvariant="normal">*</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow></mrow></math>](img/1795.png)<st
    c="4995"><st c="5013">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:math>](img/1796.png)
    <st c="5021"><st c="5026">is the base memory address,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="5054"><st c="5055">is the index of the element in the array</st> *<st c="5097">a</st>*<st
    c="5098">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:math>](img/1798.png)
    <st c="5104"><st c="5111">is the size of each element in the array.</st> <st c="5153">For
    example, it is 1 for 1 byte, 2 for 16 bits or words, and so on.</st> *<st c="5221">Table
    12.1</st>* <st c="5231">illustrates a simple example of</st> <st c="5264">an array.</st></st></st></st></st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| <st c="5273">Memory address</st> | <st c="5288">FF01</st> | <st c="5293">FF02</st>
    | <st c="5298">FF03</st> | <st c="5303">FF04</st> | <st c="5308">FF05</st> | <st
    c="5313">FF06</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="5318">Content</st> | <st c="5326">23</st> | <st c="5329">123</st>
    | <st c="5333">54</st> | <st c="5336">67</st> | <st c="5339">34</st> | <st c="5342">87</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="5345">Index</st> | <st c="5351">0</st> | <st c="5353">1</st> | <st
    c="5354">2</st> | <st c="5355">3</st> | <st c="5356">4</st> | <st c="5357">5</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '<st c="5358">Table 12.1: An example array</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5386">Homogeneous elements</st>**<st c="5407">: All elements in an
    array must be of the same data type, ensuring that the array is a uniform collection.</st>
    <st c="5515">For example, an array of integers</st> **<st c="5549">int[]</st>**
    <st c="5554">can only store integer values, and an array of strings</st> **<st
    c="5610">String[]</st>** <st c="5618">can only store</st> <st c="5634">string
    values.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5648">Indexed access</st>**<st c="5663">: Arrays</st> <st c="5672">allow
    direct access to any element using its index, providing constant-time access,
    which is one of the key advantages of this data structure.</st> <st c="5816">Accessing
    the third element in an array</st> *<st c="5856">a</st>* <st c="5857">is as simple
    as</st> *<st c="5874">a</st>* <st c="5875">[2].</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5880">Arrays</st> <st c="5888">support a variety of operations, each
    with its own performance implications.</st> <st c="5965">Here are the</st> <st
    c="5977">major operations commonly performed on arrays, along with their</st>
    <st c="6042">time complexities:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="6060">Insertion</st>**<st c="6070">: This</st> <st c="6078">refers
    to adding a new element to the array.</st> <st c="6123">For example, consider</st>
    **<st c="6145">a = [1, 2, 3, 4]</st>**<st c="6161">. Inserting</st> **<st c="6173">5</st>**
    <st c="6174">at the end of the array is straightforward if there is space.</st>
    <st c="6237">However, inserting</st> **<st c="6256">5</st>** <st c="6257">at index</st>
    **<st c="6267">1</st>** <st c="6268">requires shifting all elements from index</st>
    **<st c="6311">1</st>** <st c="6312">to the right.</st> <st c="6327">The time
    complexity of insertion in arrays is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1799.png)
    <st c="6373"><st c="6374">in the best case and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1294.png)
    <st c="6396"><st c="6397">in the worst case.</st> <st c="6417">The best case is
    inserting at the end in a partially filled array.</st> <st c="6484">If inserting
    at the beginning or middle, requires shifting of elements, it is the worst case.</st>
    <st c="6578">The following is a</st> <st c="6597">Python example:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="6681">Since Python uses zero-based indexing, the</st> `<st c="6725">a.insert(1,
    5)</st>` <st c="6739">operation inserts the value into the second position of</st>
    <st c="6796">the array.</st></st></st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="6806">Deletion</st>**<st c="6815">: This</st> <st c="6823">involves
    removing an element from the array.</st> <st c="6868">Given</st> **<st c="6874">a
    = [1, 2, 3, 4]</st>**<st c="6890">, deleting element</st> **<st c="6909">2</st>**
    <st c="6910">at index</st> **<st c="6920">1</st>** <st c="6921">requires shifting
    all elements after index</st> **<st c="6965">1</st>** <st c="6966">to the left
    to fill the gap.</st> <st c="6996">In the best case, deleting the last element
    has a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)<st
    c="7065"><st c="7066">. However, if we delete an element from the beginning or
    middle of the array, it requires shifting the subsequent elements, resulting</st>
    <st c="7200">in a worst-case time complexity</st> <st c="7232">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="7235"><st c="7236">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]</st></st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="7285">Edit or update</st>**<st c="7300">: Editing is</st> <st c="7314">modifying
    an existing element in the array.</st> <st c="7358">Given</st> **<st c="7364">a
    = [1, 2, 3, 4]</st>**<st c="7380">, changing the element at index</st> **<st c="7412">2</st>**
    <st c="7413">from</st> **<st c="7419">3</st>** <st c="7420">to</st> **<st c="7424">5</st>**
    <st c="7425">is a direct</st> <st c="7438">operation.</st> <st c="7449">We can
    directly access the element by its index and update it, which makes its time</st>
    <st c="7533">complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="7544"><st c="7545">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="7597">Search</st>**<st c="7604">: Searching</st> <st c="7616">involves
    finding a specific element within an array.</st> <st c="7670">This topic was covered
    extensively in</st> [*<st c="7708">Chapter 7</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="7717">, where most of the search algorithms discussed were based on arrays
    as the underlying data structure.</st> <st c="7820">In</st> [*<st c="7823">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="7833">, we will explore how
    searching can be performed on non-linear data structures, such</st> <st c="7918">as
    trees.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7927">Access</st>**<st c="7934">: Access</st> <st c="7944">refers
    to retrieving the value of an element at a specific index</st> <st c="8009">in
    an array.</st> <st c="8022">One of the key advantages of arrays is that their
    access time is constant (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1804.png)<st
    c="8097"><st c="8099">), allowing any element to be directly retrieved by its
    index without the need</st> <st c="8178">for traversal.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8192">Arrays can be implemented in more sophisticated structures.</st>
    <st c="8253">One example is</st> `<st c="8292">list</st>` <st c="8296">in Python).</st>
    <st c="8309">These</st> <st c="8314">arrays can resize themselves when elements
    are added beyond the initial capacity.</st> <st c="8397">However, the underlying
    principle remains the same, with arrays providing efficient access and traversal.</st>
    <st c="8503">Another</st> <st c="8510">example is</st> **<st c="8522">multidimensional
    arrays</st>**<st c="8545">. These arrays can be extended into multiple dimensions,
    such as 2D arrays (matrices) or 3D arrays, which are particularly useful in applications
    such as image processing, scientific simulations, and game development.</st> <st
    c="8763">The following is an example 2D array</st> <st c="8800">in Python:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**<st c="8926">Arrays</st>** <st c="8933">are a</st> <st c="8939">fundamental</st>
    <st c="8952">and highly efficient data structure for storing and managing collections
    of elements, especially when the size of the collection is known and remains constant.</st>
    <st c="9112">Their contiguous memory allocation allows for fast access and straightforward
    implementation of various operations.</st> <st c="9228">However, their fixed size
    and potential inefficiencies in insertion and deletion make them less flexible
    compared to other data structures such as linked lists.</st> <st c="9389">Understanding
    the trade-offs and appropriate use cases for arrays is essential for effective
    algorithm design</st> <st c="9499">and implementation.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9518">Linked lists</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="9531">A</st> **<st c="9534">linked list</st>** <st c="9545">is a</st>
    <st c="9550">linear</st> <st c="9557">data structure in which elements, called
    nodes, are arranged sequentially.</st> <st c="9633">Unlike arrays, linked lists
    do not store their elements in contiguous memory locations.</st> <st c="9721">Instead,
    each node in a linked list contains at least two parts: the data and a reference
    (or pointer) to the next node in the sequence.</st> <st c="9858">This structure
    allows linked lists to be dynamic in size, easily growing or shrinking as elements
    are added</st> <st c="9966">or removed.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9977">Linked lists have several</st> <st c="10003">key characteristics
    that distinguish them from other data structures such</st> <st c="10078">as arrays:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="10088">Dynamic size</st>**<st c="10101">: Linked lists can dynamically
    increase or decrease in size, as nodes can be added or removed as needed without
    reallocating or reorganizing the entire data structure.</st> <st c="10270">For
    example, we can continue adding nodes to a linked list without worrying about
    a</st> <st c="10354">predefined size.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10370">Non-contiguous memory allocation</st>**<st c="10403">: Unlike
    arrays, linked lists do not require contiguous memory locations.</st> <st c="10478">Each
    node is stored independently in memory and linked together using pointers.</st>
    <st c="10558">For instance, in a singly linked list, each node contains a pointer
    to the next node, allowing elements to be scattered</st> <st c="10678">throughout
    memory.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10696">Sequential access</st>**<st c="10714">: Linked lists must be
    accessed sequentially from the beginning, as there is no direct way to access
    a specific element by index.</st> <st c="10845">For example, to access the third
    element in a linked list, we must traverse the first</st> <st c="10931">two nodes.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10941">Variants</st>**<st c="10950">: Linked lists</st> <st c="10965">come
    in different forms, including singly linked lists (where each node points to the
    next), doubly linked lists (where each node points to both the next and previous
    nodes), and circular linked lists (where the last node points back to the first).</st>
    <st c="11215">For example, in a doubly linked list, traversal can happen in both
    directions due to the pointers to both the previous and</st> <st c="11338">next
    nodes.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11349">Linked lists support various operations, each with specific performance
    characteristics.</st> <st c="11439">Let’s review the major operations, along with
    their time complexities</st> <st c="11509">and examples.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11522">Insertion in a linked list</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="11549">Consider</st> <st c="11558">this linked list:</st> `<st c="11577">24</st>`
    <st c="11579">→</st> `<st c="11582">3</st>` <st c="11583">→</st> `<st c="11586">12</st>`
    <st c="11588">→</st> `<st c="11591">17</st>`<st c="11593">. If we want to insert
    the value</st> `<st c="11626">8</st>` <st c="11627">between</st> `<st c="11636">3</st>`
    <st c="11637">and</st> `<st c="11642">12</st>`<st c="11644">, the process involves
    creating a new node with the value</st> `<st c="11702">3</st>` <st c="11703">and
    updating the pointers accordingly.</st> <st c="11743">Here’s how we can do it
    step</st> <st c="11772">by step:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11780">Create the new node</st>**<st c="11800">: First, we create
    a new node that contains the value</st> **<st c="11855">8</st>**<st c="11856">.
    Initially, the pointer of this new node is set to</st> **<st c="11908">null</st>**<st
    c="11912">, as it does not point to</st> <st c="11938">anything yet.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="11951">Update the pointer of the new node</st>**<st c="11986">: Next,
    set the pointer of the new node to point to the node that comes after</st> **<st
    c="12065">3</st>**<st c="12066">, which is the node containing</st> **<st c="12097">12</st>**<st
    c="12099">. Now, the new node</st> **<st c="12119">3</st>** <st c="12120">is connected
    to</st> <st c="12137">node</st> **<st c="12142">4</st>**<st c="12143">.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="12144">Update the pointer of the previous node</st>**<st c="12184">:
    Finally, update the pointer of the node containing</st> **<st c="12238">3</st>**
    <st c="12239">to point to the new node</st> **<st c="12265">8</st>**<st c="12266">.
    This completes the insertion, resulting in the linked</st> **<st c="12322">list
    24</st>** <st c="12329">→</st> **<st c="12332">3</st>** <st c="12333">→</st> **<st
    c="12336">8</st>** <st c="12337">→</st> **<st c="12340">12</st>** <st c="12342">→</st>
    **<st c="12345">17</st>**<st c="12347">.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*<st c="12348">Figure 12</st>**<st c="12358">.1</st>* <st c="12361">illustrates
    the process of inserting a new node in</st> <st c="12412">linked lists.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: The process of adding a new node to a linked list in three steps](img/B22248_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="12540">Figure 12.1: The process of adding a new node to a linked list
    in three steps</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12617">In</st> *<st c="12621">Figure 12</st>**<st c="12630">.1</st>*<st
    c="12632">,</st> *<st c="12634">Link</st>* <st c="12638">represents</st> <st c="12649">the
    pointer to the</st> `<st c="12710">24</st>`<st c="12712">).</st> <st c="12716">The
    last node, referred to as the</st> `<st c="12776">17</st>`<st c="12778">), points
    to</st> `<st c="12792">null</st>`<st c="12796">, indicating the end of the list.</st>
    <st c="12830">We represent a pointer to</st> `<st c="12856">null</st>` <st c="12860">with
    the</st> `<st c="12870">/</st>` <st c="12871">symbol.</st> <st c="12880">The address
    of the newly created node is labeled as</st> `<st c="12932">New</st>`<st c="12935">,
    and initially, it points</st> <st c="12962">to</st> `<st c="12965">null</st>`<st
    c="12969">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12970">Here is a simple Python implementation of the</st> <st c="13017">preceding
    process:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13741">To test the</st> <st c="13753">functionality of both the</st>
    `<st c="13780">Node</st>` <st c="13784">class and the</st> `<st c="13799">LinkedList</st>`
    <st c="13809">class, we can use the</st> <st c="13832">following example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14152">Let’s briefly explain</st> <st c="14175">the code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="14184">Node</st>**<st c="14189">: Each</st> **<st c="14197">Node</st>**
    <st c="14201">object stores a</st> **<st c="14218">data</st>** <st c="14222">value
    and a</st> **<st c="14235">next</st>** <st c="14239">pointer in the next node
    in the</st> <st c="14272">linked list.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14284">LinkedList</st>**<st c="14295">: The</st> **<st c="14302">LinkedList</st>**
    <st c="14312">class manages the linked list, including the</st> <st c="14358">insertion
    operation.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14378">insert_after</st>**<st c="14391">: This method inserts a new
    node after a given node (</st>**<st c="14445">prev_node</st>**<st c="14455">).</st>
    <st c="14459">The new node is created with the</st> **<st c="14492">new_data</st>**
    <st c="14500">value, and pointers are updated to insert it correctly into</st>
    <st c="14561">the list.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14570">print_list</st>**<st c="14581">: This method traverses the
    linked list and prints the data of</st> <st c="14645">each node.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="14655">The time</st> <st c="14665">complexity of insertion in a linked
    list is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1805.png)
    <st c="14709"><st c="14710">in the best case, such as when inserting at the beginning
    or end of the list if the position is already known.</st> <st c="14822">In the
    worst case, when inserting at a specific position requires traversal through the
    list, the time complexity</st> <st c="14936">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="14939"><st c="14940">.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14941">Deletion in linked lists</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="14966">Deletion from a linked</st> <st c="14989">list involves removing
    a specific node.</st> <st c="15030">For instance, given the</st> `<st c="15054">24</st>`
    <st c="15056">→</st> `<st c="15059">3</st>` <st c="15060">→</st> `<st c="15063">12</st>`
    <st c="15065">→</st> `<st c="15068">17</st>` <st c="15070">linked list, deleting
    the node with the value</st> `<st c="15117">3</st>` <st c="15118">requires bypassing
    it by updating the pointer of the previous node (</st>`<st c="15187">2</st>`<st
    c="15189">) to point to the next node (</st>`<st c="15218">4</st>`<st c="15220">).</st>
    <st c="15223">Like insertion, the time complexity of the deletion operation in
    linked lists depends on the location of the node to be deleted.</st> <st c="15352">In
    the worst case, when traversal is needed to find the node, the time complexity
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="15437"><st c="15438">.</st> *<st c="15440">Figure 12</st>**<st c="15449">.2</st>*
    <st c="15451">illustrates the deleting process in the example</st> <st c="15500">link
    list.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: The process of deleting a node in a linked list](img/B22248_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="15545">Figure 12.2: The process of deleting a node in a linked list</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15605">In</st> *<st c="15609">Figure 12</st>**<st c="15618">.3</st>*<st
    c="15620">, the top part displays the linked list before the deletion of the node
    with the value</st> `<st c="15707">12</st>`<st c="15709">, while the bottom part
    shows the linked list after the deletion.</st> <st c="15775">The following is
    an</st> <st c="15794">example Python code for deleting a node in a</st> <st c="15840">linked
    list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="16213">The</st> `<st c="16218">delete_node</st>` <st c="16229">function
    should be added to the</st> `<st c="16262">LinkedList</st>` <st c="16272">class
    in the</st> <st c="16286">previous section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16303">Edit in link lists</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="16322">Editing involves</st> <st c="16339">modifying the data within
    an existing node in the linked list.</st> <st c="16403">For instance, if we want
    to change the value of the second node from</st> `<st c="16472">2</st>` <st c="16473">to</st>
    `<st c="16477">5</st>` <st c="16478">in the</st> `<st c="16486">1</st>` <st c="16487">→</st>
    `<st c="16490">2</st>` <st c="16491">→</st> `<st c="16494">3</st>` <st c="16495">→</st>
    `<st c="16498">4</st>` <st c="16499">linked list, we would update the node’s data
    accordingly.</st> <st c="16558">The time complexity for this operation is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="16600"><st c="16601">because we may need to traverse the list to locate
    the node to be updated.</st> <st c="16677">Here is a piece of sample Python code
    for the</st> <st c="16723">edit/update operation:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="16974">The</st> `<st c="16979">update_node</st>` <st c="16990">function
    should be added to the</st> `<st c="17023">LinkedList</st>` <st c="17033">class
    in the</st> <st c="17047">previous section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17064">Searching in linked lists</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="17090">In</st> [*<st c="17094">Chapter 7</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="17103">, we</st> <st c="17107">explored a variety of search algorithms in detail,
    all of which are based on arrays as the underlying data structure.</st> <st c="17226">For
    instance, in binary search, we can directly access an element at a specific index,
    such as the middle of the array.</st> <st c="17346">However, when using a linked
    list, finding a node with a specific value becomes more challenging due to the
    sequential nature of the data structure.</st> <st c="17495">This means that regardless
    of the search algorithm used, when applied to a singly linked list, the search
    essentially becomes a sequential, linear search.</st> <st c="17650">As a result,
    searching in a linked list has a time complexity</st> <st c="17712">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1809.png)<st
    c="17715"><st c="17716">.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17717">Here is the Python code example using a singly</st> <st c="17765">linked
    list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17979">The</st> `<st c="17984">search_node</st>` <st c="17995">function</st>
    <st c="18005">should be added to the</st> `<st c="18028">LinkedList</st>` <st
    c="18038">class in the</st> <st c="18052">previous section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18069">Access in link lists</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="18090">This</st> <st c="18096">operation involves retrieving the value
    of a node at a specific position in the linked list.</st> <st c="18189">For example,
    accessing the fourth node in the</st> `<st c="18235">17</st>` <st c="18237">→</st>
    `<st c="18240">12</st>` <st c="18242">→</st> `<st c="18245">3</st>` <st c="18246">→</st>
    `<st c="18249">24</st>` <st c="18251">→</st> `<st c="18254">6</st>` <st c="18255">linked
    list requires sequential traversal to reach the desired node.</st> <st c="18325">The
    time complexity for this operation is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="18367"><st c="18368">. The following is a simple Python code implementing access
    in a</st> <st c="18433">linked list:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18670">The</st> `<st c="18675">get_nth</st>` <st c="18682">function should
    be added to the</st> `<st c="18715">LinkedList</st>` <st c="18725">class in the</st>
    <st c="18739">previous section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18756">In practice, linked lists</st> <st c="18783">are commonly used
    as the underlying data structure for implementing stacks and queues due to their
    ability to dynamically resize.</st> <st c="18913">They are also employed in operating
    systems for managing memory allocation, where free memory blocks are linked together
    in a list.</st> <st c="19045">Another significant application of linked lists
    is in representing adjacency lists in graphs or trees, where each vertex points
    to a linked list of</st> <st c="19193">adjacent vertices.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19211">Linked lists offer a flexible and dynamic alternative to arrays,
    especially in scenarios where the size of the data structure needs to change frequently.</st>
    <st c="19366">Their non-contiguous memory allocation allows for efficient insertions
    and deletions without the need to shift elements, unlike arrays.</st> <st c="19502">However,
    this flexibility comes with the drawback of sequential access times, making linked
    lists less suitable for applications that require frequent random access.</st>
    <st c="19668">Understanding the trade-offs between linked lists and other data
    structures, such as arrays, is essential for selecting the most appropriate structure
    for a given problem.</st> <st c="19840">In the next section, we will briefly explore
    other variants of</st> <st c="19903">linked lists.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19916">Doubly and circular linked lists</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '<st c="19949">A</st> **<st c="19952">doubly linked list</st>** <st c="19970">is
    a</st> <st c="19975">type of linked list in which each node</st> <st c="20015">contains
    two pointers: one pointing to the next node and another pointing to the previous
    node (see</st> *<st c="20115">Figure 12</st>**<st c="20124">.3</st>*<st c="20126">).</st>
    <st c="20130">This bidirectional structure allows traversal of the list in both
    forward and backward directions, making certain operations more efficient.</st>
    <st c="20271">Although doubly linked lists allow bidirectional access, their sequential
    nature means that the time complexity for major operations remains similar to
    that of singly</st> <st c="20438">linked lists.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: An example doubly linked list](img/B22248_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="20478">Figure 12.3: An example doubly linked list</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20520">Another variation of</st> <st c="20542">the linked</st> <st c="20552">list
    is the</st> **<st c="20565">circular linked list</st>** <st c="20585">where the
    last node points back to the first node, forming a circular structure (see</st>
    *<st c="20671">Figure 12</st>**<st c="20680">.4</st>*<st c="20682">).</st> <st
    c="20686">This can be applied to both singly and doubly linked lists.</st> <st
    c="20746">Since the last node connects back to the first, we can traverse the
    list in a loop without encountering a null reference.</st> <st c="20868">This
    characteristic is ideal for applications where data needs to be looped through
    continuously, such as in round-robin scheduling or buffer management.</st> <st
    c="21022">Like</st> <st c="21027">doubly linked lists, circular linked lists do
    not provide any improvement in</st> <st c="21104">time complexity compared to
    non-circular</st> <st c="21145">linked lists.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: A circular linked list](img/B22248_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="21184">Figure 12.4: A circular linked list</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21219">Both doubly linked lists and circular linked lists offer distinct
    advantages depending on the use case.</st> <st c="21324">Doubly linked lists provide
    more flexibility in navigation and easier node removal, while circular linked
    lists enable efficient cyclic traversal of data.</st> <st c="21479">In terms of
    performance, both structures exhibit similar time complexities to singly linked
    lists but with added benefits in specific operations.</st> <st c="21625">In the
    next section, we will explore a data structure that combines the advantages of
    both linked lists</st> <st c="21729">and arrays.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21740">Skip lists</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="21751">As</st> <st c="21755">we discussed in the previous chapter, when
    studying data structures, it’s important to evaluate their performance in three
    key operations: insertion, deletion, and search.</st> <st c="21927">Arrays excel
    in searching, particularly when the data is already sorted, thanks to their direct
    (or random) access capabilities, which allow for sublinear time complexity.</st>
    <st c="22099">However, due to their static nature, arrays can present challenges
    when it comes to inserting new data or deleting existing data.</st> <st c="22229">On
    the other hand, linked lists exhibit the opposite behavior.</st> <st c="22292">Their
    dynamic allocation allows for easy insertion and deletion, but the lack of direct
    access means that searching, even in sorted data, becomes a sequential process
    with linear</st> <st c="22471">time complexity.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="22487">This question then arises: Is it possible to combine the benefits
    of both arrays and linked lists?</st> <st c="22587">In other words, can we achieve
    faster-than-sequential access, similar to arrays, while also enjoying the dynamic
    memory allocation of linked lists?</st> <st c="22735">The answer lies in the</st>
    **<st c="22758">skip list</st>**<st c="22767">. A</st> **<st c="22771">skip list</st>**
    <st c="22780">is a probabilistic data structure that extends the basic linked
    list by adding multiple levels of linked lists, allowing for faster search, insertion,
    and deletion operations.</st> <st c="22957">Each level of a skip list contains
    a subset of the elements from the level below, with the bottommost level containing
    all elements in a simple linked list.</st> <st c="23114">Higher levels act as
    “express lanes” to skip over multiple elements at once, hence the name</st> *<st
    c="23206">skip list</st>*<st c="23215">.</st> *<st c="23217">Figure 12</st>**<st
    c="23226">.6</st>* <st c="23228">illustrates an example of a skip list.</st> <st
    c="23268">Level 1 functions as a standard linked list, while all the upper levels
    serve as</st> <st c="23349">express lanes.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23363">Let’s explain the</st> <st c="23382">concept of a skip list using
    an analogy.</st> <st c="23423">Imagine we are traveling to meet a friend at a
    specific station in a bus system.</st> <st c="23504">The bus stops at every station,
    and each stop takes a considerable amount of time, so we want to minimize the
    number of stops on our way to our friend’s station.</st> <st c="23666">There are</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="23676"><st c="23677">stations in total, and we know the exact station number
    where our friend is waiting.</st> <st c="23763">The bus system has two types</st>
    <st c="23792">of lines:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23801">The regular bus stops at every</st> <st c="23833">single station</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="23847">The express line stops only at four stations, specifically at</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1812.png)<st
    c="23910"><st c="23911">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="23913"><st c="23914">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1814.png)<st
    c="23916"><st c="23917">,</st> <st c="23919">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)</st></st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="23972">Taking the regular bus is the safest option because it ensures
    we will reach our destination, but it requires stopping at every station, which
    can be inefficient, taking</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="24142"><st c="24191">stops in total.</st> <st c="24207">Alternatively,
    we could take the express bus, which only makes four stops.</st> <st c="24282">If
    our friend’s station falls within one of the intervals between these express stops
    (for example, between 1 and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1812.png)<st
    c="24396"><st c="24397">, or between</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1818.png)
    <st c="24410"><st c="24411">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="24416"><st c="24417">), we can get off the bus at the nearest express stop
    and switch to the regular bus to reach our friend’s exact station.</st> <st c="24538">By
    doing this, we reduce the number of stops from a maximum of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1820.png)
    <st c="24601"><st c="24602">to around</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1818.png)<st
    c="24613"><st c="24614">, making our journey much more efficient.</st> <st c="24656">The
    skip list is similar to this</st> <st c="24689">bus system.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24700">Skip lists have several defining</st> <st c="24733">characteristics
    that influence their behavior</st> <st c="24780">and performance:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24796">Multiple levels</st>**<st c="24812">: Skip lists consist of
    multiple levels, where each level above the base level contains a subset of elements
    from the previous level.</st> <st c="24947">The bottommost level is a standard
    linked list containing all elements.</st> <st c="25019">In a skip list, the first
    level might contain all elements, the second level might contain half, the third
    level might contain a quarter, and</st> <st c="25161">so on.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="25167">Probabilistic balancing</st>**<st c="25191">: Skip lists use
    randomization to determine the level at which each element will appear.</st> <st
    c="25281">This leads to an average-case time complexity similar to balanced binary
    search trees without the need for complex balancing algorithms.</st> <st c="25418">For
    example, when inserting an element, a random number of levels (up to a maximum)
    is chosen for the element to be</st> <st c="25534">included in.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="25546">Efficient searching</st>**<st c="25566">: Skip lists allow
    for faster searching by skipping over large portions of the list using the higher
    levels, reducing the number of comparisons needed.</st> <st c="25719">For</st>
    <st c="25723">instance, searching for an element in a skip list can quickly bypass
    multiple nodes by moving through the</st> <st c="25829">upper levels.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="25842">Dynamic resizing</st>**<st c="25859">: Skip lists can dynamically
    adjust their structure as elements are added or removed, maintaining efficient
    operations without needing to rebuild the entire structure.</st> <st c="26028">For
    example, as new elements are inserted, they may be added to multiple levels depending
    on the</st> <st c="26125">randomization process.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26147">Skip lists support various operations, each with specific performance
    characteristics.</st> <st c="26235">The following section outlines the major operations,
    along with their time complexities</st> <st c="26323">and examples.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26336">Insertion in skip lists</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="26360">Inserting</st> <st c="26371">numbers into a skip list involves
    a few steps.</st> <st c="26418">For this example, we will insert the numbers</st>
    `<st c="26463">3</st>`<st c="26464">,</st> `<st c="26466">4</st>`<st c="26467">,</st>
    `<st c="26469">5</st>`<st c="26470">,</st> `<st c="26472">7</st>`<st c="26473">,</st>
    `<st c="26475">8</st>`<st c="26476">,</st> `<st c="26478">9</st>`<st c="26479">,
    and</st> `<st c="26485">10</st>` <st c="26487">into a skip list with 4 levels.</st>
    <st c="26520">Each number will be inserted one by one, and the levels will be
    assigned based on randomization.</st> <st c="26617">Here’s a detailed step-by-step
    description of how this</st> <st c="26672">process works:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="26686">Step 1: Initialize the skip list</st>**<st c="26719">: Start
    with an empty skip list that has four levels:</st> *<st c="26774">Level 4</st>*
    <st c="26781">(topmost),</st> *<st c="26793">Level 3</st>*<st c="26800">,</st>
    *<st c="26802">Level 2</st>*<st c="26809">, and</st> *<st c="26815">Level 1</st>*
    <st c="26822">(bottommost).</st> <st c="26837">Initially, the list has only a
    head node at each level pointing</st> <st c="26901">to</st> **<st c="26904">null</st>**<st
    c="26908">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26909">Step 2:</st>** **<st c="26918">Insert 3</st>**<st c="26926">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26928">Determine levels for 3</st>**<st c="26950">: Randomly determine
    the levels at which</st> **<st c="26992">3</st>** <st c="26993">should appear.</st>
    <st c="27009">Let’s assume it appears at</st> <st c="27036">all levels.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27047">Insertion</st>**<st c="27057">: At</st> *<st c="27063">Levels
    1</st>* <st c="27071">to</st> *<st c="27075">4</st>*<st c="27076">, there are
    no other nodes; so,</st> **<st c="27108">3</st>** <st c="27109">is simply inserted,
    and the head node at</st> *<st c="27151">Levels 1</st>* <st c="27159">to</st>
    *<st c="27163">4</st>* <st c="27164">now points</st> <st c="27176">to</st> **<st
    c="27179">3</st>**<st c="27180">.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27181">Here is the</st> <st c="27194">skip list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="27204">Level 4: 3 --></st> <st c="27220">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="27224">Level 3: 3 --></st> <st c="27240">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="27244">Level 2: 3 --></st> <st c="27260">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="27264">Level 1: 3 --></st> <st c="27280">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27284">Step 3:</st>** **<st c="27293">Insert 4</st>**<st c="27301">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27303">Determine levels for 4</st>**<st c="27325">: Randomly determine
    the levels at which</st> **<st c="27367">4</st>** <st c="27368">should appear.</st>
    <st c="27384">Suppose it appears only at</st> *<st c="27411">Level 1</st>*<st
    c="27418">. The higher levels remain unchanged as</st> **<st c="27458">3</st>**
    <st c="27459">does not</st> <st c="27469">appear there.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27482">Insertion</st>**<st c="27492">: Traverse</st> *<st c="27504">Level
    1</st>* <st c="27511">from the head to the appropriate position.</st> **<st c="27555">4</st>**
    <st c="27556">should be inserted after</st> **<st c="27582">3</st>**<st c="27583">.
    Update the pointers so that</st> **<st c="27613">3</st>** <st c="27614">now points
    to</st> **<st c="27629">4</st>** <st c="27630">at</st> *<st c="27634">Level 1</st>*<st
    c="27641">.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27642">Here is the</st> <st c="27654">skip list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="27665">Level 4: 3 --></st> <st c="27681">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="27685">Level 3: 3 --></st> <st c="27701">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="27705">Level 2: 3 --></st> <st c="27721">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="27725">Level 1: 3 --> 4 --></st> <st c="27747">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="27808">5</st>` <st c="27809">is assigned randomly to</st> *<st c="27834">Levels
    1</st>*<st c="27842">,</st> *<st c="27844">2</st>*<st c="27845">,</st> <st c="27847">and</st>
    *<st c="27851">3</st>*<st c="27852">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27853">Insertion</st>**<st c="27863">: In</st> *<st c="27869">Levels
    2</st>* <st c="27877">and</st> *<st c="27882">3</st>*<st c="27883">, element</st>
    **<st c="27893">5</st>** <st c="27894">is the next element to</st> **<st c="27918">3</st>**<st
    c="27919">. Then, pointers of</st> **<st c="27939">3</st>** <st c="27940">at these
    levels are updated to point to</st> **<st c="27981">5</st>**<st c="27982">. In</st>
    *<st c="27987">Level 1</st>*<st c="27994">, insert</st> **<st c="28003">5</st>**
    <st c="28004">after</st> **<st c="28011">4</st>** <st c="28012">by updating the</st>
    <st c="28029">pointers accordingly.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28050">Here is the</st> <st c="28063">skip list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="28073">Level 4: 3 --></st> <st c="28089">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28093">Level 3: 3 --> 5 --></st> <st c="28115">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28119">Level 2: 3 --> 5 --></st> <st c="28141">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28145">Level 1: 3 --> 4 -->5 --></st> <st c="28172">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="28176">Step 5:</st>** **<st c="28185">Insert 7</st>**<st c="28193">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="28195">Determine levels for 7</st>**<st c="28217">: Suppose</st> **<st
    c="28228">7</st>** <st c="28229">is assigned randomly to</st> *<st c="28254">Level
    1</st>*<st c="28261">. All upper levels</st> <st c="28280">remain unchanged.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="28297">Insertion</st>**<st c="28307">: In</st> *<st c="28313">Level
    1</st>* <st c="28321">insert</st> **<st c="28328">7</st>** <st c="28329">after</st>
    **<st c="28335">5</st>**<st c="28336">.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28337">Here is the</st> <st c="28349">skip list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="28360">Level 4: 3 --></st> <st c="28376">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28380">Level 3: 3 --></st> <st c="28396">5 -->null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28405">Level 2: 3 --></st> <st c="28421">5 -->null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28430">Level 1: 3 --> 4 --> 5 -->7 --></st> <st c="28463">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="28467">Step 6:</st>** **<st c="28476">Insert 8</st>**<st c="28484">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="28486">Determine levels for 8</st>**<st c="28508">: Let’s assume</st>
    **<st c="28524">8</st>** <st c="28525">is assigned randomly to</st> *<st c="28550">Levels
    1</st>* <st c="28558">and</st> *<st c="28563">2</st>*<st c="28564">.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="28565">Insertion</st>**<st c="28575">: In</st> *<st c="28581">Level
    2</st>*<st c="28588">, insert</st> **<st c="28597">8</st>** <st c="28598">after</st>
    **<st c="28605">5</st>** <st c="28606">by updating the pointers.</st> <st c="28633">In</st>
    *<st c="28636">Level 1</st>*<st c="28643">, insert</st> **<st c="28652">8</st>**
    <st c="28653">after</st> **<st c="28659">7</st>**<st c="28660">.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28661">Here is the</st> <st c="28674">skip list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="28684">Level 4: 3 --></st> <st c="28700">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28704">Level 3: 3 --> 5 --></st> <st c="28726">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28730">Level 2: 3 --> 5 --> 8 --></st> <st c="28758">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="28762">Level 1: 3 --> 4 --> 5 --> 7 --> 8 --></st> <st c="28802">null</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28806">For</st> *<st c="28811">Steps 9</st>* <st c="28818">and</st> *<st
    c="28823">10</st>*<st c="28825">, we do similar to what we did with element</st>
    **<st c="28869">7</st>**<st c="28870">. The final skip list after inserting all
    elements is illustrated in</st> *<st c="28939">Figure 12</st>**<st c="28948">.5</st>*<st
    c="28950">.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.5: An example skip list with four levels](img/B22248_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="29049">Figure 12.5: An example skip list with four levels</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29099">The insertion</st> <st c="29114">process in a skip list involves
    determining the levels at which a new element will appear and updating the pointers
    at each relevant level to maintain the order.</st> <st c="29276">The random assignment
    of levels ensures that the skip list remains balanced, providing efficient search,
    insertion, and deletion operations.</st> <st c="29417">The preceding steps illustrate
    how each number was inserted into the skip list, taking advantage of the express
    lanes created by the</st> <st c="29550">higher levels.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29564">The following Python code is an implementation of insertion into
    a</st> <st c="29632">skip list:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31042">Let’s look inside</st> <st c="31061">the code and explain the
    main classes of</st> <st c="31102">the algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31116">Node</st>**<st c="31121">: Each</st> **<st c="31129">Node</st>**
    <st c="31133">object stores a</st> **<st c="31150">value</st>** <st c="31155">and
    a list of</st> **<st c="31170">forward</st>** <st c="31177">pointers that are
    4 in level 1, 5 in level 2, 5 in level 3 and null in</st> <st c="31249">level
    4</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31256">SkipList</st>**<st c="31265">: This contains the</st> <st c="31286">following
    functions:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31306">random_level()</st>**<st c="31321">: This generates a random
    level for each new node based on a</st> <st c="31383">probabilistic model</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31402">insert()</st>**<st c="31411">: This inserts a new value into
    the skip list at the</st> <st c="31465">appropriate levels</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31483">print_skiplist()</st>**<st c="31500">: This prints the skip
    list, displaying the nodes at each level from the topmost level down to the</st>
    <st c="31600">bottommost level</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="31616">As an example, we</st> <st c="31635">create a skip list with up
    to three levels.</st> <st c="31679">The values</st> `<st c="31690">3</st>`<st
    c="31691">,</st> `<st c="31693">4</st>`<st c="31694">,</st> `<st c="31696">5</st>`<st
    c="31697">,</st> `<st c="31699">7</st>`<st c="31700">,</st> `<st c="31702">8</st>`<st
    c="31703">,</st> `<st c="31705">9</st>`<st c="31706">, and</st> `<st c="31712">10</st>`
    <st c="31714">are inserted into the skip list.</st> <st c="31748">Finally, we
    print the skip list, displaying how the nodes are organized across the various
    levels, which looks something</st> <st c="31869">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32019">After insertion, let’s discuss the behavior of a skip list during</st>
    <st c="32086">search operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32104">Search in skip lists</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="32125">Searching</st> <st c="32135">for an item in a skip list involves
    starting at the highest level and moving forward through the list until the target
    is found or the search needs to move down a level.</st> <st c="32306">Here’s a
    step-by-step explanation of how to search for the number</st> *<st c="32372">8</st>*
    <st c="32373">in the skip list we</st> <st c="32394">previously constructed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="32417">Step 1</st>**<st c="32424">: Start at the highest level (</st>*<st
    c="32455">Level 4</st>*<st c="32463">):</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32466">Start at the head node at</st> *<st c="32493">Level 3</st>*<st
    c="32500">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32501">Is</st> **<st c="32505">3</st>** <st c="32506">(the first value
    at</st> *<st c="32527">Level 3</st>*<st c="32534">) less than</st> **<st c="32547">7</st>**<st
    c="32548">? Yes; the next node</st> <st c="32569">is</st> **<st c="32572">null</st>**<st
    c="32576">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32577">Step 2</st>**<st c="32584">: Move down to</st> *<st c="32600">Level
    3</st>*<st c="32607">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32609">Now, drop down to node</st> **<st c="32632">3</st>** <st c="32633">at</st>
    *<st c="32637">Level 3</st>* <st c="32644">and the next node</st> <st c="32663">is</st>
    **<st c="32666">5</st>**<st c="32667">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32668">Is</st> **<st c="32672">5</st>** <st c="32673">less than</st>
    **<st c="32684">9</st>**<st c="32685">? Yes.</st> <st c="32692">Move to node</st>
    **<st c="32705">5</st>**<st c="32706">. The next node which</st> <st c="32728">in
    null.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32736">Step 3</st>**<st c="32743">: Move down to</st> *<st c="32759">Level
    2</st>*<st c="32766">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32768">Now, drop down to node</st> **<st c="32791">5</st>** <st c="32792">at</st>
    *<st c="32796">Level 3</st>* <st c="32803">and the next node</st> <st c="32822">is</st>
    **<st c="32825">8</st>**<st c="32826">.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32827">Is</st> **<st c="32831">8</st>** <st c="32832">less than</st>
    **<st c="32843">9</st>**<st c="32844">? No.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="32849">Step 4</st>**<st c="32856">: Move down to</st> *<st c="32872">Level
    1</st>*<st c="32879">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32881">The next node is</st> **<st c="32898">7</st>**<st c="32899">.
    The target</st> <st c="32912">is found.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32921">The total number of comparisons is three, demonstrating a clear
    improvement over the sequential search in</st> *<st c="33028">Level 1</st>* <st
    c="33035">that would be required in a standard linked list.</st> <st c="33086">Skip
    lists are significantly</st> <st c="33114">more efficient than linked lists, especially
    when dealing with</st> <st c="33178">large datasets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33193">The following is a</st> `<st c="33213">search</st>` <st c="33219">method
    that must be added to the previously described</st> `<st c="33274">SkipList</st>`
    <st c="33282">class:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="33555">The following is an example usage of</st> `<st c="33593">search</st>`
    <st c="33599">in a</st> `<st c="33605">SkipList</st>` <st c="33613">class:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34106">By inserting</st> <st c="34119">the example data, it produces
    the</st> <st c="34154">following results:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34323">To conclude our discussion on skip lists, we will skip the detailed
    explanation of deletion.</st> <st c="34417">Deletion in a skip list involves first
    performing a search, followed by updating the</st> <st c="34502">necessary pointers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34521">Skip lists offer efficient average-case time complexities for
    search, delete, and insert operations, typically performing at</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1436.png)<st
    c="34647"><st c="34656">. This efficiency is achieved through the use of multiple
    levels of linked lists, allowing operations to skip over large portions of data,
    similar to a binary search tree.</st> <st c="34828">In the best case, operations
    can approach</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1823.png)
    <st c="34870"><st c="34871">when the target element is close to the starting point.</st>
    <st c="34928">However, due to the probabilistic nature of skip lists, there is
    a small chance that the structure could degenerate, leading to a worst-case time
    complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)
    <st c="35088"><st c="35089">for these operations.</st> <st c="35112">Despite this,
    the average-case performance remains robust, making skip lists a practical choice
    for dynamic data structures where balanced search, insertion, and deletion times</st>
    <st c="35289">are crucial.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35301">Stacks</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="35308">A</st> **<st c="35311">stack</st>** <st c="35316">is a</st> <st
    c="35321">linear data structure that follows the LIFO principle, meaning that
    the last element added to the stack is the first one to be removed.</st> <st c="35458">Think
    of it as a stack of plates: we add new plates on top, and when we need a plate,
    we take the top one off first.</st> <st c="35575">Stacks are used in various applications,
    including expression evaluation, function call management, and undo mechanisms</st>
    <st c="35695">in software.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35707">Stacks have several</st> <st c="35727">defining characteristics
    that influence their behavior</st> <st c="35783">and performance:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35799">LIFO order</st>**<st c="35810">: The last element inserted
    into the stack is the first one to be removed.</st> <st c="35886">For example,
    if we push the numbers</st> **<st c="35922">1</st>**<st c="35923">,</st> **<st
    c="35925">2</st>**<st c="35926">, and</st> **<st c="35932">3</st>** <st c="35933">onto
    a stack, we will pop them off in the reverse order:</st> **<st c="35991">3</st>**<st
    c="35992">,</st> **<st c="35994">2</st>**<st c="35995">,</st> **<st c="35997">1</st>**<st
    c="35998">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35999">Operations performed at one end</st>**<st c="36031">: All insertions
    (push) and deletions (pop) are performed at the top of the stack.</st> <st c="36115">There
    is no direct access to elements in the middle or bottom of the stack.</st> <st
    c="36191">If we push several elements onto a stack, we can only access the most
    recently added element directly.</st> <st c="36294">It also means there is no
    random access to the stack.</st> <st c="36348">Unlike arrays, we cannot directly
    access elements at a specific index in a stack.</st> <st c="36430">Access is restricted
    to the top</st> <st c="36462">element only.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="36475">Dynamic size</st>**<st c="36488">: Stacks can dynamically grow
    or shrink as elements are pushed or popped.</st> <st c="36563">As we push more
    elements onto a stack, its size increases, and as we pop elements off, its</st>
    <st c="36654">size decreases.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36669">Stacks support a few fundamental operations, each with specific
    performance characteristics.</st> <st c="36763">The following are these major
    operations, along with their time complexities</st> <st c="36840">and examples:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="36853">push</st>**<st c="36858">: It adds a new element to the top
    of the stack.</st> <st c="36908">Its time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1266.png)<st
    c="36931"><st c="36932">, as the operation involves simply adding an element to
    the top of the stack.</st> <st c="37010">The following is a simple</st> <st c="37036">Python
    example:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="37148">pop</st>**<st c="37152">: This removes the top element from
    the stack.</st> <st c="37200">It performs the removal in constant time (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="37242"><st c="37244">).</st> <st c="37247">The following is a</st> <st c="37266">Python
    example:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="37320">peek</st>**<st c="37325">: It is</st> <st c="37333">for retrieving
    the value of the top element without removing it from the stack.</st> <st c="37414">For
    the stack</st> **<st c="37428">[1, 2, 3]</st>**<st c="37437">, peeking would return</st>
    **<st c="37460">3</st>** <st c="37461">without altering the stack.</st> <st c="37490">The
    time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1827.png)<st
    c="37513"><st c="37514">, as it only involves accessing the top element.</st>
    <st c="37563">A simple Python instruction is</st> <st c="37594">as follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="37629">search</st>**<st c="37636">: As usual, this is for finding
    an element in the stack.</st> <st c="37694">For example, if we search for element</st>
    **<st c="37732">2</st>** <st c="37733">in the stack</st> **<st c="37747">[1, 2,
    3]</st>**<st c="37756">, we would find it at position 1 from the top.</st> <st
    c="37803">Obviously, the time complexity of</st> **<st c="37837">search</st>**
    <st c="37843">in stacks is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1828.png)<st
    c="37857"><st c="37858">, as it may require scanning through the entire stack
    from top to bottom.</st> <st c="37932">Let’s see a simple</st> <st c="37951">Python
    example:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="38065">edit</st>**<st c="38070">: This modifies the value of the top
    element in the stack.</st> <st c="38130">If the top element of the stack</st>
    **<st c="38162">[1, 2, 3]</st>** <st c="38171">is</st> **<st c="38175">3</st>**
    <st c="38176">and we want to change it to</st> **<st c="38205">5</st>**<st c="38206">,
    the stack would become</st> **<st c="38231">[1, 2, 5]</st>**<st c="38240">. It
    does this operation in constant time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1829.png)<st
    c="38283"><st c="38285">) since the operation only affects the top element.</st>
    <st c="38337">A Python code example is</st> <st c="38362">as follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38440">Some programming languages also support additional operations
    such as</st> `<st c="38511">isFull</st>`<st c="38517">, which checks whether the
    stack is full, and</st> `<st c="38563">isEmpty</st>`<st c="38570">, which determines
    whether the stack</st> <st c="38607">is empty.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38616">Stacks are extensively</st> <st c="38639">used in computer programming
    for several key applications.</st> <st c="38699">Here are a few important</st>
    <st c="38724">use cases:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38734">Stacks store function calls, pushing each invocation onto the
    stack and popping it when the</st> <st c="38827">function completes</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="38845">They are used for converting and evaluating expressions, particularly
    for changing infix expressions to postfix or</st> <st c="38961">prefix notation</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="38976">Stacks implement undo features in software, where each action
    is pushed onto the stack and can be undone by popping</st> <st c="39093">it off</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39099">Stacks are a fundamental and versatile data structure used in
    many algorithms and applications.</st> <st c="39196">They provide efficient</st>
    `<st c="39219">push</st>` <st c="39223">and</st> `<st c="39228">pop</st>` <st
    c="39231">operations with a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1830.png)
    <st c="39269"><st c="39270">and are particularly useful in scenarios where the
    last element added needs to be the first one removed.</st> <st c="39376">However,
    their lack of random access and LIFO nature can make them less suitable for situations
    where elements need to be accessed in a different order.</st> <st c="39529">Understanding
    the trade-offs and appropriate use cases for stacks is essential for effective
    algorithm design and implementation.</st> <st c="39659">In the next section, we
    will explore queues, which operate in a manner opposite</st> <st c="39739">to
    stacks.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39749">Queue</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="39755">A</st> **<st c="39758">queue</st>** <st c="39763">operates</st>
    <st c="39772">on the FIFO principle, meaning it has a behavior opposite to stacks:
    The first element added is the first to be removed.</st> <st c="39894">This structure
    is analogous to a line of people waiting for service: The first person in line
    is the first to be served.</st> <st c="40015">Queues are used in various scenarios,
    including task scheduling, buffering, and managing resources in</st> <st c="40117">computer
    systems.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40134">Queues have several</st> <st c="40155">characteristics that influence
    their behavior</st> <st c="40201">and performance:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="40217">FIFO order</st>**<st c="40228">: The first element inserted
    into the queue is the first one to</st> <st c="40293">be removed.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40304">Operations at opposite ends</st>**<st c="40332">: Elements
    are added at the rear (end) of the queue and removed from the front (beginning)
    of</st> <st c="40427">the queue.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40437">Dynamic size</st>**<st c="40450">: Queues</st> <st c="40460">can
    dynamically grow or shrink as elements are enqueued or dequeued.</st> <st c="40529">As
    we enqueue more elements, the size of the queue increases, and as we dequeue elements,
    the</st> <st c="40623">size decreases.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40638">No random access</st>**<st c="40655">: Like stacks and unlike
    arrays, we cannot directly access elements at a specific index in a queue.</st>
    <st c="40756">Access is restricted to the front</st> <st c="40790">element only.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40803">Queues support some fundamental operations, each with specific
    performance characteristics.</st> <st c="40896">The following are the</st> <st
    c="40918">major operations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="40935">enqueue</st>**<st c="40943">: This</st> <st c="40950">involves
    adding a new element to the rear of the queue.</st> <st c="41007">Consider a queue
    that currently holds the elements</st> **<st c="41058">1</st>** <st c="41059">and</st>
    **<st c="41064">2</st>**<st c="41065">. Enqueuing</st> **<st c="41077">3</st>**
    <st c="41078">into the queue would place it at the rear, resulting in the queue</st>
    **<st c="41145">[1, 2, 3]</st>**<st c="41154">. This operation is performed in
    constant time or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)<st
    c="41204"><st c="41205">, as the operation involves simply adding an element to
    the end of the queue.</st> <st c="41283">A simple Python example is</st> <st c="41310">as
    follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="41459">dequeue</st>**<st c="41467">: It</st> <st c="41473">removes
    the front element from the queue.</st> <st c="41515">If we dequeue the queue</st>
    **<st c="41539">[1, 2, 3]</st>**<st c="41548">, the front element</st> **<st c="41568">1</st>**
    <st c="41569">is removed, leaving us with the queue</st> **<st c="41608">[2, 3]</st>**<st
    c="41614">. Similar to</st> **<st c="41627">enqueue</st>**<st c="41634">, the
    time complexity here is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1832.png)<st
    c="41664"><st c="41665">, as it involves removing the front element.</st> <st
    c="41710">Here is a simple</st> <st c="41727">Python instruction:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="41775">peek</st>**<st c="41780">: This is</st> <st c="41790">for retrieving
    the value of the front element without removing it from the queue and it performs
    in constant time.</st> <st c="41906">For the queue</st> **<st c="41920">[1, 2,
    3]</st>**<st c="41929">, peeking would return</st> **<st c="41952">1</st>** <st
    c="41953">without altering the queue.</st> <st c="41982">The Python instruction
    for peeking can be like</st> <st c="42029">the following:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="42068">search</st>**<st c="42075">: A</st> <st c="42080">queue conducts
    a search in linear time, as it may require scanning through the entire queue from
    front to rear.</st> <st c="42192">The following is a Python code implementing
    a search in</st> <st c="42248">a queue:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="42298">Some programming languages also support additional operations
    such as</st> `<st c="42369">isFull</st>`<st c="42375">, which checks whether the
    queue is full, and</st> `<st c="42421">isNull</st>`<st c="42427">, which determines
    whether the queue</st> <st c="42464">is empty.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42473">Similar to stacks, queues</st> <st c="42499">have numerous applications
    in computer programming.</st> <st c="42552">A well-known example is</st> **<st
    c="42576">task scheduling</st>**<st c="42591">, where queues are used in operating
    systems to manage processes.</st> <st c="42657">Processes are enqueued when they
    are ready to run and dequeued once they are executed.</st> <st c="42744">Another
    example is buffering, where queues temporarily store data before it is processed,
    such as in print queues or streaming services.</st> <st c="42881">Lastly, queues
    play a crucial role in resource management, ensuring that access to shared resources
    is handled in the order requests</st> <st c="43014">are received.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43027">Queues are a fundamental data structure used in many algorithms
    and applications, particularly in scenarios that require managing tasks or resources
    in a FIFO manner.</st> <st c="43195">They provide efficient enqueue and dequeue
    operations with a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1833.png)
    <st c="43275"><st c="43276">but do not allow random access to elements.</st> <st
    c="43321">Understanding the appropriate use cases for queues is essential for
    effective algorithm design and implementation.</st> <st c="43436">In the final
    section of this chapter, we expand on the concept of a queue by introducing a
    structure that has two ends, effectively combining the functionalities of both
    a stack and</st> <st c="43618">a queue.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43626">Deque</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="43632">A</st> **<st c="43635">deque</st>** <st c="43640">is a</st> <st
    c="43646">versatile data structure that allows the insertion and deletion of elements
    from both ends of the sequence, making it a generalization of both stacks and
    queues.</st> <st c="43808">Deques can operate as both a stack and a queue, providing
    greater flexibility in how elements are added</st> <st c="43912">or removed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43923">Let’s highlight the</st> <st c="43943">properties</st> <st c="43955">of
    deques:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="43965">Insertions and deletions at both ends</st>**<st c="44003">:
    Elements can be added or removed from either the front or the rear of the deque.</st>
    <st c="44087">For example, we can push elements onto the front or rear of the
    deque and pop them off from either end</st> <st c="44190">as well.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="44198">No fixed direction</st>**<st c="44217">: Deques do not enforce
    a strict LIFO or FIFO order; instead, they allow operations at both ends.</st>
    <st c="44316">For instance, we can treat a deque as a stack by only using one
    end or as a queue by using</st> <st c="44407">both ends.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="44417">Dynamic size</st>**<st c="44430">: Deques can dynamically grow
    or shrink as elements are added or removed from</st> <st c="44509">either end.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="44520">No random access</st>**<st c="44537">: Like stacks and queues,
    deques do not allow direct access to elements at a</st> <st c="44615">specific
    index.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44630">Deques support a wide range of operations, each with specific
    performance characteristics.</st> <st c="44722">The following</st> <st c="44736">are
    the major operations, along with their time complexities</st> <st c="44797">and
    examples:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44810">Add to front (insert at the front)</st>**<st c="44845">: This
    involves adding a new element to the front of the deque.</st> <st c="44910">For
    example, if the deque currently holds</st> **<st c="44952">[2, 3]</st>**<st c="44958">,
    adding</st> **<st c="44967">1</st>** <st c="44968">to the front would result in</st>
    **<st c="44998">[1, 2, 3]</st>**<st c="45007">. This is done in constant time,
    as the operation involves simply adding an element to the front.</st> <st c="45105">Here
    is a simple piece of</st> <st c="45131">Python code:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="45241">Add to rear (insert at the rear)</st>**<st c="45274">: This
    adds a new element to the rear of the deque.</st> <st c="45327">If the deque currently
    holds</st> **<st c="45356">[1, 2]</st>**<st c="45362">, adding</st> **<st c="45371">3</st>**
    <st c="45372">to the rear would result in</st> **<st c="45401">[1, 2, 3]</st>**<st
    c="45410">. Similar to</st> *<st c="45423">add to front</st>*<st c="45435">, the
    time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)<st
    c="45460"><st c="45461">. The following is a simple Python instruction to do</st>
    <st c="45514">this operation:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="45566">Remove from front (delete from the front)</st>**<st c="45608">:
    This operation removes the front</st> <st c="45644">element from the deque in
    constant time.</st> <st c="45685">If we remove the front element from the deque</st>
    **<st c="45731">[1, 2, 3]</st>**<st c="45740">, it becomes</st> **<st c="45753">[2,
    3]</st>**<st c="45759">. A simple Python instruction to execute the</st> *<st
    c="45804">remove from front</st>* <st c="45821">operation is</st> <st c="45835">as
    follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="45872">Remove from rear (delete from the rear)</st>**<st c="45912">:
    Similar to the previous operation, only from the rear of the deque.</st> <st c="45983">The
    Python code for this operation is</st> <st c="46021">as follows:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="46055">Peek (access the front or rear element)</st>**<st c="46095">:
    Retrieve the value of the front or rear element without removing it from the deque
    in constant time.</st> <st c="46199">For the deque</st> **<st c="46213">[1, 2,
    3]</st>**<st c="46222">, peeking the front would return</st> **<st c="46255">1</st>**<st
    c="46256">, and peeking the rear would</st> <st c="46285">return</st> **<st c="46292">3</st>**<st
    c="46293">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="46465">It’s important to note that many of the functions used for a deque
    may or may not be supported by different programming languages.</st> <st c="46597">Fortunately,
    Python provides built-in support for</st> <st c="46647">these functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46663">Deques have several important use cases in computer programming.</st>
    <st c="46729">One key example is task scheduling, where deques are used in scheduling
    algorithms to add or remove tasks from either end of the queue as needed.</st>
    <st c="46875">Another use case is in sliding window algorithms, where deques are
    employed to efficiently manage elements as they are added or removed from the
    window while it moves across a dataset.</st> <st c="47060">Lastly, deques are
    also used in implementing undo/redo functionality in applications, allowing actions
    to be added or removed from either end of</st> <st c="47205">the deque.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47215">Deques are a flexible</st> <st c="47238">data structure that generalizes
    both stacks and queues, allowing insertion and deletion at both ends.</st> <st
    c="47340">They provide efficient operations with a time complexity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)
    <st c="47400"><st c="47401">for adding or removing elements at either end.</st>
    <st c="47449">Deques are particularly useful in scenarios where elements need
    to be managed from both ends, such as task scheduling, sliding window algorithms,
    and undo/redo functionality.</st> <st c="47624">Understanding the appropriate
    use cases for deques is essential for effective algorithm design</st> <st c="47719">and
    implementation.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47738">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="47746">In this chapter, we explored various linear data structures, focusing
    on their definitions, characteristics, and operations.</st> <st c="47872">We began
    with an in-depth look at arrays and linked lists, examining how they handle fundamental
    operations such as insertion, deletion, and searching.</st> <st c="48024">We discussed
    the trade-offs between these structures, noting the efficiency of arrays in accessing
    elements and the flexibility of linked lists in dynamic memory allocation.</st>
    <st c="48198">The chapter also covered more advanced linear structures such as
    stacks, queues, and deques, illustrating their practical applications in computer
    programming, from task scheduling to expression evaluation and</st> <st c="48408">resource
    management.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48428">We then introduced the skip list, a probabilistic data structure
    that combines the advantages of both arrays and linked lists, offering efficient
    search, insertion, and deletion operations.</st> <st c="48619">Through detailed
    examples, we demonstrated how skip lists improve upon the limitations of traditional
    linked lists.</st> <st c="48735">As we concluded the chapter, we emphasized the
    importance of understanding the appropriate use cases for each data structure
    to optimize algorithm design.</st> <st c="48890">You now have a thorough understanding
    of linear data structures, which play a crucial role in algorithm design.</st>
    <st c="49002">In the next chapter, we will shift our focus to non-linear data
    structures, exploring their unique properties</st> <st c="49112">and applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49129">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="49160">Introduction to Algorithms</st>*<st c="49187">. By Thomas H.</st>
    <st c="49202">Cormen, Charles E.</st> <st c="49221">Leiserson, Ronald L.</st>
    <st c="49242">Rivest, and Clifford Stein.</st> <st c="49270">Fourth Edition.</st>
    <st c="49286">MIT</st> <st c="49290">Press.</st> <st c="49297">2022:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="49302">Chapter 10</st>*<st c="49313">,</st> *<st c="49315">Elementary</st>*
    *<st c="49326">Data Structures</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="49341">Algorithms</st>*<st c="49352">. By R.</st> <st c="49360">Sedgewick,
    K.</st> <st c="49374">Wayne.</st> <st c="49381">Fourth Edition.</st> <st c="49397">Addison-Wesley.</st>
    <st c="49413">2011:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="49418">Chapter</st>* *<st c="49427">1</st>*<st c="49428">,</st> *<st
    c="49430">Fundamentals</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="49442">Data Structures and Algorithm Analysis in C++</st>*<st c="49488">.
    By Mark A.</st> <st c="49501">Weiss.</st> <st c="49508">Fourth Edition.</st> <st
    c="49524">Pearson.</st> <st c="49533">2012:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="49538">Chapter 3</st>*<st c="49548">,</st> *<st c="49550">Lists, Stacks,</st>*
    *<st c="49565">and Queues</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
