["```py\n # You will need first: pip install networkx matplotlib\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# Define the graph as an adjacency list\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['B' , 'F'],\n    'D': ['E'],\n    'E': ['F'],\n    'F': ['A']\n}\n```", "```py\n # Visualize the graph\nvisualize_graph(G)\n# Create a directed graph using NetworkX\nG = nx.DiGraph()\n# Add edges to the graph\nfor node, neighbors in graph.items():\n    for neighbor in neighbors:\n        G.add_edge(node, neighbor)\n# Visualize the graph using NetworkX and Matplotlib\ndef visualize_graph(G):\n    pos = nx.spring_layout(G)  # Positions for all nodes\n    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=10, font_weight='bold')\n    plt.title(\"Graph Visualization\")\n    plt.show()\n```", "```py\n # DFS function (optional, same as before)\nvisited = set()\ndef dfs(node):\n    if node not in visited:\n        print(node)\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n# Start DFS at node 'A'\ndfs('A')\n```", "```py\n<st c=\"20564\" class=\"calibre11\">A, B, D, E, F, C</st>\n```", "```py\n from collections import deque\n# Graph represented as an adjacency list\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F'],\n    'D': ['A'],\n    'E': ['B','D'],\n    'F': ['E','D']\n}\n# BFS function\ndef bfs(start_node):\n    visited = set()           # Set to track visited nodes\n    queue = deque([start_node])  # Initialize the queue with the starting node\n    while queue:\n        node = queue.popleft()  # Dequeue a node\n        if node not in visited:\n            print(node)\n            visited.add(node)  # Mark it as visited\n            queue.extend(graph[node])  # Enqueue all unvisited neighbors\n# Start BFS at node 'A'\nbfs('A')\n```", "```py\n A, B, C, D, E, F\n```", "```py\n def bfs_shortest_path(start_node, target_node):\n    visited = set()\n    queue = deque([[start_node]])  # Queue stores paths\n    while queue:\n        path = queue.popleft()  # Dequeue the first path\n        node = path[-1]  # Get the last node from the path\n        if node == target_node:\n            return path  # Return the path when target is reached\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)  # Enqueue the new path\n    return None  # Return None if there is no path\n# Find the shortest path between 'A' and 'F'\nprint(bfs_shortest_path('A', 'F'))\n```", "```py\n ['A', 'C', 'F']\n```", "```py\n # Definition of a TreeNode class in Python\nclass TreeNode:\n    def __init__(self, key):\n        self.key = key       # Node value\n        self.left = None     # Pointer to left child\n        self.right = None    # Pointer to right child\n# Creating nodes and linking them to form a binary tree\nroot = TreeNode(10)          # Root node\nroot.left = TreeNode(5)      # Left child of root\nroot.right = TreeNode(20)    # Right child of root\n# Adding more nodes to the tree\nroot.left.left = TreeNode(3) # Left child of node with value 5\nroot.left.right = TreeNode(7) # Right child of node with value 5\nroot.right.left = TreeNode(15) # Left child of node with value 20\nroot.right.right = TreeNode(25) # Right child of node with value 20\n# Function to perform an in-order traversal of the tree\ndef inorder_traversal(node):\n    if node:\n        inorder_traversal(node.left)\n        print(node.key, end=' ')\n        inorder_traversal(node.right)\n# In-order traversal of the tree\nprint(\"In-order Traversal:\")\ninorder_traversal(root)\n```", "```py\n # Array representation of a complete binary tree\nbinary_tree = [10, 5, 20, 3, 7, 15, 25]\n# Accessing elements\nroot = binary_tree[0]\nleft_child_of_root = binary_tree[2 * 0 + 1]  # index 1\nright_child_of_root = binary_tree[2 * 0 + 2]  # index 2\n# Display the values\nprint(f\"Root: {root}\")\nprint(f\"Left Child of Root: {left_child_of_root}\")\nprint(f\"Right Child of Root: {right_child_of_root}\")\n```", "```py\n def build_tree(parent_array):\n    n = len(parent_array)\n    nodes = [None] * n\n    root = None\n    # Create tree nodes for each index\n    for i in range(n):\n        nodes[i] = TreeNode(i)\n    # Assign parents to each node\n    for i in range(n):\n        if parent_array[i] == -1:\n            root = nodes[i]  # This is the root node\n        else:\n            parent_node = nodes[parent_array[i]]\n            if parent_node.left is None:\n                parent_node.left = nodes[i]\n            else:\n                parent_node.right = nodes[i]\n    return root\n```", "```py\n class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n```", "```py\n parent_array = [-1, 0, 0, 1, 1, 2, 2]\n# Build the tree from the parent array\nroot = build_tree(parent_array)\n# Function to perform an in-order traversal of the tree\ndef inorder_traversal(node):\n    if node:\n        inorder_traversal(node.left)\n        print(node.key, end=' ')\n        inorder_traversal(node.right)\n# In-order traversal of the tree\nprint(\"In-order Traversal:\")\ninorder_traversal(root)\n```", "```py\n # Definition of TreeNode class\nclass TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n# Function for in-order traversal\ndef inorder_traversal(node):\n    if node:\n        inorder_traversal(node.left)\n        print(node.key, end=' ')\n        inorder_traversal(node.right)\n```", "```py\n # Example: Build the BST\nroot = TreeNode(22)\nroot.left = TreeNode(35)\nroot.right = TreeNode(30)\nroot.left.left = TreeNode(5)\nroot.left.right = TreeNode(15)\nroot.right.left = TreeNode(25)\nroot.right.right = TreeNode(35)\n```", "```py\n # Perform in-order traversal\nprint(\"In-Order Traversal:\")\ninorder_traversal(root)\n```", "```py\n<st c=\"46866\" class=\"calibre11\">5 10 15 20 25 30 35</st>\n```", "```py\n # Function for pre-order traversal\ndef preorder_traversal(node):\n    if node:\n        print(node.key, end=' ')\n        preorder_traversal(node.left)\n        preorder_traversal(node.right)\n# Perform pre-order traversal\nprint(\"Pre-Order Traversal:\")\npreorder_traversal(root)\n```", "```py\n # Function for post-order traversal\ndef postorder_traversal(node):\n    if node:\n        postorder_traversal(node.left)\n        postorder_traversal(node.right)\n        print(node.key, end=' ')\n# Perform post-order traversal\nprint(\"Post-Order Traversal:\")\npostorder_traversal(root)\n```", "```py\n class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n```", "```py\n Function to insert a node in the BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return TreeNode(key)\n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    else:\n        node.right = insert(node.right, key)\n    return node\n```", "```py\n # Function to search a key in the BST\ndef search(node, key):\n    # Base case: the node is None (key not found) or the key matches the current node's key\n    if node is None or node.key == key:\n        return node\n    # If the key is smaller than the node's key, search the left subtree\n    if key < node.key:\n        return search(node.left, key)\n    # Otherwise, search the right subtree\n    return search(node.right, key)\n```", "```py\n root = None\nkeys = [20, 10, 30, 5, 15, 25, 35]\nfor key in keys:\n    root = insert(root, key)\n```", "```py\n search_key = 25\nfound_node = search(root, search_key)\n# Output the result\nif found_node:\n    print(f\"Key {search_key} found in the BST.\")\nelse:\n    print(f\"Key {search_key} not found in the BST.\")\n```", "```py\n # Function to insert a node in the BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return TreeNode(key)\n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    else:\n        node.right = insert(node.right, key)\n    return node\n```", "```py\n # Function to find the minimum value node in the right subtree (in-order successor)\ndef min_value_node(node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current\n```", "```py\n # Function to delete a node from the BST\ndef delete_node(root, key):\n    # Base case: the tree is empty\n    if root is None:\n        return root\n    # If the key to be deleted is smaller than the root's key, go to the left subtree\n    if key < root.key:\n        root.left = delete_node(root.left, key)\n    # If the key to be deleted is greater than the root's key, go to the right subtree\n    elif key > root.key:\n        root.right = delete_node(root.right, key)\n    # If key is equal to the root's key, this is the node to be deleted\n    else:\n        # Case 1: Node with only one child or no child\n        if root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        # Case 2: Node with two children\n        # Get the in-order successor (smallest in the right subtree)\n        temp = min_value_node(root.right)\n        # Replace the current node's key with the in-order successor's key\n        root.key = temp.key\n        # Delete the in-order successor\n        root.right = delete_node(root.right, temp.key)\n    return root\n```", "```py\n # Create a BST and insert values into it\nroot = None\nkeys = [20, 10, 30, 5, 15, 25, 35]\nfor key in keys:\n    root = insert(root, key)\n# Delete a node from the BST\ndelete_key = 30\nroot = delete_node(root, delete_key)\n# Function to perform in-order traversal\ndef inorder_traversal(node):\n    if node:\n        inorder_traversal(node.left)\n        print(node.key, end=' ')\n        inorder_traversal(node.right)\n# Perform in-order traversal after deletion\nprint(\"In-order Traversal after Deletion:\")\ninorder_traversal(root)\n```", "```py\n def heapify_up(heap, index):\n    parent = (index - 1) // 2\n    if index > 0 and heap[parent] < heap[index]:\n        # Swap the parent and current node\n        heap[parent], heap[index] = heap[index], heap[parent]\n        # Recursively heapify the parent node\n        heapify_up(heap, parent)\ndef insert_max_heap(heap, element):\n    heap.append(element)\n    heapify_up(heap, len(heap) - 1)\n```", "```py\n # Example usage\nheap = []\ninsert_max_heap(heap, 20)\ninsert_max_heap(heap, 15)\ninsert_max_heap(heap, 30)\ninsert_max_heap(heap, 5)\ninsert_max_heap(heap, 40)\nprint(\"Heap after insertions:\", heap)\n```", "```py\n def heapify_down(heap, index):\n    largest = index\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < len(heap) and heap[left] > heap[largest]:\n        largest = left\n    if right < len(heap) and heap[right] > heap[largest]:\n        largest = right\n    if largest != index:\n        heap[index], heap[largest] = heap[largest], heap[index]\n        heapify_down(heap, largest)\ndef delete_max_heap(heap):\n    if len(heap) == 0:\n        return None\n    if len(heap) == 1:\n        return heap.pop()\n    root = heap[0]\n    heap[0] = heap.pop()  # Move last element to the root\n    heapify_down(heap, 0)  # Restore heap property\n    return root\n```", "```py\n heap = [40, 30, 20, 5, 15]\ndeleted = delete_max_heap(heap)\nprint(\"Heap after deletion of max element:\", heap)\n```", "```py\n def heapify(heap, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != i:\n        heap[i], heap[largest] = heap[largest], heap[i]\n        heapify(heap, n, largest)\n```", "```py\n def build_max_heap(a):\n    n = len(a)\n    # Start from the first non-leaf node and heapify each node\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(a, n, i)\n```", "```py\n arr = [5, 15, 20, 30, 40]\nbuild_max_heap(a)\nprint(\"Array after building max-heap:\", a)\n```", "```py\n def heapsort(arr):\n    n = len(arr)\n    build_max_heap(arr)  # Step 1: Build a max-heap\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Step 2: Swap root with last element\n        heapify(arr, i, 0)  # Step 3: Heapify the reduced heap\n```", "```py\n a = [5, 15, 20, 30, 40]\nheapsort(arr)\nprint(\"Sorted array:\", arr)\n```", "```py\n<st c=\"67187\" class=\"calibre11\">Sorted array: [5, 15, 20, 30, 40]</st>\n```"]