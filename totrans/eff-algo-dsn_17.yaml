- en: <st c="0">13</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Non-Linear Data Structures</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="30">Non-linear data structures</st>** <st c="57">form</st> <st c="63">a
    crucial class of data structures with extensive applications in designing efficient
    algorithms.</st> <st c="161">Unlike linear data structures, such as arrays and
    linked lists, non-linear structures allow data elements to be stored and accessed
    in a more complex, hierarchical manner.</st> <st c="333">These structures enable
    the efficient handling of relationships, dependencies, and hierarchical data,
    making them vital for solving a wide range of</st> <st c="481">computational problems.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="504">In this chapter, we begin by exploring the general properties and
    characteristics that define non-linear data structures.</st> <st c="627">Following
    this, we discuss two major groups: graphs and trees.</st> **<st c="690">Graphs</st>**
    <st c="696">are</st> <st c="701">versatile structures used to model relationships
    between objects, while</st> **<st c="773">trees</st>** <st c="778">represent</st>
    <st c="788">hierarchical relationships in a more structured form.</st> <st c="843">Finally,
    we</st> <st c="854">examine a special case of binary trees, known as</st> **<st
    c="904">heaps</st>**<st c="909">, which are essential for implementing efficient
    algorithms such as heapsort.</st> <st c="987">Learning about non-linear data structures
    is essential for algorithm design, as they play a key role in many algorithms,
    including those for sorting and searching.</st> <st c="1151">Additionally, graphs,
    trees, and other forms of non-linear data structures are extensively used in advanced
    fields such as AI, machine learning, and optimization, where efficient data management
    and processing</st> <st c="1361">are critical.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1374">This chapter covers the</st> <st c="1399">following topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1416">Introduction to non-linear</st> <st c="1444">data structures</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1459">Graphs</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1466">Trees</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1472">Heaps</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1478">Introduction to non-linear data structures</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="1521">In</st> [*<st c="1525">Chapter 11</st>*](B22248_11.xhtml#_idTextAnchor164)<st
    c="1535">, we</st> <st c="1539">introduced the concept of</st> **<st c="1566">abstract
    data types</st>** <st c="1585">(</st>**<st c="1587">ADTs</st>**<st c="1591">),
    classifying</st> <st c="1606">them into two main categories: linear and non-linear.</st>
    <st c="1661">We followed this with an in-depth discussion of linear data structures
    in</st> [*<st c="1735">Chapter 12</st>*](B22248_12.xhtml#_idTextAnchor187)<st
    c="1745">, where we examined their relevance to our core focus – designing and
    analyzing efficient algorithms.</st> <st c="1847">While we touched on many essential
    aspects of linear data structures, it is worth noting that this area of study
    is vast and could easily warrant its own in-depth exploration.</st> <st c="2023">For
    those interested in deeper exploration of data structures, we have included references
    at the end of both</st> *<st c="2133">Chapters 11</st>* <st c="2144">and</st>
    *<st c="2149">12</st>*<st c="2151">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2152">In this chapter, our focus shifts to non-linear data structures.</st>
    <st c="2218">Like the previous chapter, we will approach this topic with an eye
    on its relationship with efficient algorithm design.</st> <st c="2338">Our goal
    is not merely to present the various types of non-linear data structures but to
    highlight their roles and applications in improving the performance</st> <st c="2495">of
    algorithms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2509">Let’s begin by briefly discussing what defines non-linear data
    structures, their key characteristics, and some of the most commonly</st> <st
    c="2642">used types.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2653">Unlike linear data structures, where elements are arranged in a
    sequential manner (e.g., arrays, linked lists), non-linear data structures organize
    data in a hierarchical or interconnected way.</st> <st c="2848">In non-linear
    structures, each element may be connected to multiple other elements, forming
    complex relationships that enable more efficient data processing for</st> <st
    c="3009">certain operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3028">The following are the</st> <st c="3051">key features of non-linear</st>
    <st c="3078">data structures:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="3094">Hierarchical relationships</st>**<st c="3121">: Elements are
    structured in a way that reflects a hierarchy, meaning</st> <st c="3192">some
    elements may act as</st> **<st c="3217">parents</st>** <st c="3224">while others
    are</st> **<st c="3242">children</st>**<st c="3250">. This is particularly true
    for structures such as</st> **<st c="3301">trees</st>** <st c="3306">and</st>
    **<st c="3311">graphs</st>**<st c="3317">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="3318">Complex traversal patterns</st>**<st c="3345">: Unlike linear
    structures, where traversal is relatively</st> <st c="3403">straightforward, moving
    through non-linear data structures requires more sophisticated techniques, often
    specific to the structure</st> <st c="3535">being used.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="3546">Variable access time</st>**<st c="3567">: The time</st> <st
    c="3579">it takes to search, insert, or delete elements can vary greatly depending
    on the structure and the way it is implemented.</st> <st c="3701">In many cases,
    non-linear data structures allow for more efficient operations compared</st> <st
    c="3788">to their</st> <st c="3797">linear counterparts.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3817">Non-linear data structures are</st> <st c="3848">composed of several
    key elements that define their structure and functionality.</st> <st c="3929">The
    most important components include nodes, edges, parents, children, roots, leaves,
    and subtrees.</st> <st c="4029">Let’s understand these components</st> <st c="4063">in
    detail:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="4073">Nodes</st>**<st c="4079">: A</st> <st c="4084">node or vertex
    is the fundamental building block of most non-linear data structures.</st> <st
    c="4169">Each node typically contains data and may also have connections to other
    vertices, depending on the type of structure.</st> <st c="4288">In trees, for
    example, vertices represent individual elements within the hierarchy.</st> <st
    c="4372">For example, in a social network graph, each node represents a user,
    and the data stored in the node might be the user’s</st> <st c="4493">profile
    information.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="4513">Edges</st>**<st c="4519">: An</st> <st c="4525">edge or arrow
    is a link or connection between two nodes.</st> <st c="4582">In non-linear structures,
    edges play a critical role in defining the relationships between nodes.</st> <st
    c="4680">In a binary tree, edges define the relationship between a parent and
    its children.</st> <st c="4763">For example, if a parent node represents a manager,
    the edges would connect to child nodes that represent their employees.</st> <st
    c="4886">In a graph, an edge represents a relationship between two entities.</st>
    <st c="4954">In a transportation network, for instance, an edge might represent
    a direct flight between</st> <st c="5045">two cities.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5056">Parents and children</st>**<st c="5077">: In hierarchical non-linear
    data structures such as trees, nodes are organized in levels, where parent nodes
    are directly connected to the child nodes below them.</st> <st c="5242">The parent-child
    relationship is a fundamental concept</st> <st c="5297">in trees:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5306">Parent</st>**<st c="5313">: A</st> <st c="5318">node that has
    one or more child nodes directly</st> <st c="5365">beneath it</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5375">Child</st>**<st c="5381">: A node</st> <st c="5390">that is
    directly connected to another node above it (</st><st c="5444">its parent)</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5456">For example, in a corporate hierarchy tree, a manager is a parent
    node, and their subordinates are the</st> <st c="5560">child nodes.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="5572">Root</st>**<st c="5577">: The root is</st> <st c="5591">the
    topmost node in a tree structure and acts as the starting point for traversing
    the tree.</st> <st c="5685">A tree can only have one root, and all other nodes
    are descendants of this root.</st> <st c="5766">If a node has no parent, it is
    considered the root.</st> <st c="5818">In a filesystem, the root directory is
    the topmost folder, and all other directories or files branch out</st> <st c="5923">from
    it.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="5931">Leaf</st>**<st c="5936">: A</st> <st c="5941">leaf is a node
    that has no children.</st> <st c="5978">Leaves represent the endpoints of a tree
    structure, where no further branching occurs.</st> <st c="6065">These are crucial
    in many algorithms, as they often signal completion points in traversals</st>
    <st c="6156">or searches.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6168">Subtree</st>**<st c="6176">: A</st> <st c="6180">subtree is
    a smaller portion of a tree that includes a node and all its descendants.</st>
    <st c="6266">Subtrees allow trees to be treated recursively, where each node,
    along with its children, can be considered a tree on its own.</st> <st c="6393">In
    a decision tree, each node and its branches form a subtree, representing a subset
    of</st> <st c="6481">possible decisions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="6500">There are several types of non-linear data structures, each suited
    to different kinds of algorithmic problems.</st> <st c="6612">The most common
    non-linear data structures include graphs, trees, and heaps.</st> <st c="6689">In
    the following sections, we will examine these three fundamental non-linear data
    structures in detail.</st> <st c="6794">Each of the structures has unique characteristics
    and applications, and understanding them is crucial for designing efficient algorithms.</st>
    <st c="6932">We will explore their properties, how they are implemented, and the
    roles they play in solving various</st> <st c="7035">computational problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7058">Graphs</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="7065">Graphs</st>** <st c="7072">are</st> <st c="7076">one of the
    most versatile and widely used non-linear data structures.</st> <st c="7147">They
    are used to represent relationships between entities, where entities are represented
    as nodes (also called</st> **<st c="7259">vertices</st>**<st c="7267">) and</st>
    <st c="7273">relationships as edges.</st> <st c="7298">Graphs can model a wide
    range of real-world problems, from social networks to transportation systems and</st>
    <st c="7403">communication protocols.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7427">Graphs come in various types, each with specific properties that
    make them suitable for different tasks.</st> <st c="7533">Here are the most common
    types</st> <st c="7564">of graphs:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7574">Undirected graphs</st>**<st c="7592">: In</st> <st c="7598">undirected
    graphs, edges have no direction.</st> <st c="7642">The</st> <st c="7646">relationship
    between two nodes is bidirectional (see</st> *<st c="7699">Figure 13</st>**<st
    c="7708">.1</st>*<st c="7710">).</st> <st c="7714">If there is an edge between
    node A and node B, you can traverse from A to B or from B to A without any restrictions.</st>
    <st c="7831">An example of an undirected graph is the social network of Facebook
    friends, where connections are mutual.</st> <st c="7938">This means if A is friends
    with B, then B is also friends with A, reflecting the bidirectional nature of</st>
    <st c="8043">the relationship.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.1: An undirected graph](img/B22248_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="8062">Figure 13.1: An undirected graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="8094">Directed graphs (digraphs)</st>**<st c="8121">: In digraphs,
    edges have a direction.</st> <st c="8161">The relationship</st> <st c="8178">between
    nodes is one-way, meaning</st> <st c="8211">that if there is a directed edge from
    node A to node B, you can only traverse from A to B, not the other way around,
    for example, a website where pages have links pointing to other pages, forming
    a digraph.</st> *<st c="8419">Figure 13</st>**<st c="8428">.2</st>* <st c="8430">shows
    an example of digraphs.</st> <st c="8461">As illustrated, graphs do not have to
    be</st> <st c="8502">fully connected.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.2: A digraph](img/B22248_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="8522">Figure 13.2: A digraph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="8544">Weighted graphs</st>**<st c="8560">: In a</st> <st c="8568">weighted
    graph, each edge is</st> <st c="8597">assigned a numerical value or</st> **<st
    c="8627">weight</st>**<st c="8633">. This weight often represents a cost, distance,
    or time associated with the connection between nodes.</st> <st c="8736">An example
    of a weighted graph is a road network where the weight of an edge represents the</st>
    <st c="8828">distance or travel time</st> <st c="8852">between cities.</st> *<st
    c="8868">Figure 13</st>**<st c="8877">.3</st>* <st c="8879">depicts a weighted
    graph, where the weights are assigned to</st> <st c="8940">the edges.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.3: A weighted graph](img/B22248_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="8952">Figure 13.3: A weighted graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="8981">Unweighted graphs</st>**<st c="8999">: In unweighted graphs,
    all edges have equal significance, meaning</st> <st c="9067">that there is no
    particular cost or distance</st> <st c="9112">associated with traveling between
    nodes.</st> <st c="9153">In</st> *<st c="9156">Figure 13</st>**<st c="9165">.1</st>*<st
    c="9167">, the graph</st> <st c="9179">is unweighted.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9193">Cyclic and acyclic graphs</st>**<st c="9219">: A cyclic graph
    contains at least one cycle, meaning</st> <st c="9273">you</st> <st c="9277">can
    start from a node, traverse</st> <st c="9310">edges, and return to the</st> <st
    c="9335">same node.</st> <st c="9346">An acyclic graph has no such cycles, making
    them essential for applications such as task scheduling.</st> <st c="9447">The
    graph in</st> *<st c="9460">Figure 13</st>**<st c="9469">.1</st>* <st c="9471">has
    cycles.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9483">Signed graphs</st>**<st c="9497">: In</st> <st c="9503">signed
    graphs, edges are labeled with</st> <st c="9540">either positive or negative signs,
    typically representing favorable or unfavorable relationships.</st> <st c="9639">These
    graphs are useful in scenarios where relationships can have polarities, such as
    in social networks, where edges</st> <st c="9757">could represent</st> <st c="9772">friendship
    (positive) or conflict (negative).</st> <st c="9819">Social networks in which
    positive edges represent friendships and negative edges represent rivalries is
    an example of a</st> <st c="9939">signed graph.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9952">Hypergraphs</st>**<st c="9964">: A</st> <st c="9969">hypergraph</st>
    <st c="9980">generalizes the</st> <st c="9995">concept of a graph by allowing
    edges (called</st> **<st c="10041">hyperedges</st>**<st c="10051">) to connect
    more than two nodes at a time.</st> <st c="10096">This type of graph is particularly
    useful in representing complex relationships where a single connection might involve
    multiple entities.</st> <st c="10235">For example, in a research collaboration
    network, a hyperedge might represent a publication authored by three or more researchers,
    connecting all of</st> <st c="10384">them simultaneously.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.4: A hypergraph](img/B22248_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="10406">Figure 13.4: A hypergraph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="10431">Figure 13</st>**<st c="10441">.4</st>* <st c="10443">illustrates
    an example of a hypergraph with the following components: The set of vertices
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1836.png)<st
    c="10537"><st c="10562">, and the set of hyperedges is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/1837.png)<st
    c="10593"><st c="10605">. Each hyperedge connects multiple vertices as follows:</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1838.png)<st
    c="10661"><st c="10677">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1839.png)<st
    c="10679"><st c="10693">,</st> <st c="10695">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1840.png)<st
    c="10699"><st c="10714">.</st></st></st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10715">In the following</st> <st c="10733">section, we will explore how
    to represent some of the most commonly used graphs in algorithms and discuss the
    complexities associated with each</st> <st c="10877">representation method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10899">Graphs representation</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10921">Graphs can be</st> <st c="10936">represented in several ways,
    each method being well suited to particular use cases depending on the graph structure
    and the type of operations needed.</st> <st c="11087">In the following subsections,
    we will examine three common methods for graph representation and their key properties.</st>
    <st c="11205">While evaluating each method, we will focus on three critical aspects
    of</st> <st c="11278">their performance:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11296">Space complexity</st>**<st c="11313">: How much memory is required
    to store the graph using the</st> <st c="11373">chosen representation</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11394">The time complexity for accessing all neighbors of a node</st>**<st
    c="11452">: The efficiency of retrieving all nodes that are directly connected
    (adjacent) to a</st> <st c="11538">given node</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11548">The time complexity for checking edge existence</st>**<st c="11596">:
    The time required to determine whether an edge exists between two</st> <st c="11665">specific
    nodes</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11679">By analyzing these complexities, we can better understand the
    strengths and limitations of each graph representation and how they apply to different</st>
    <st c="11829">algorithmic tasks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11847">Adjacency matrix</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="11864">An</st> **<st c="11868">adjacency matrix</st>** <st c="11884">represents</st>
    <st c="11895">a graph</st> <st c="11904">using a</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow></mrow></math>](img/1841.png)
    <st c="11912"><st c="11914">matrix, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1842.png)
    <st c="11928"><st c="11929">is the number of nodes or vertices in the graph.</st>
    <st c="11979">Each cell in the matrix at position</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1843.png)
    <st c="12015"><st c="12016">indicates the presence (and possibly the weight) of
    an edge between node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/1844.png)
    <st c="12090"><st c="12091">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1845.png)<st
    c="12101"><st c="12102">. In an undirected graph, the adjacency matrix</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1650.png)
    <st c="12149"><st c="12150">is symmetric, meaning that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mi>D</mml:mi></mml:math>](img/1847.png)<st
    c="12178"><st c="12179">’, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)<st
    c="12188">*<st c="12189">’</st>* <st c="12190">represents the transpose of matrix</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi></mml:math>](img/1656.png)<st
    c="12226"><st c="12227">. This symmetry arises because the edges in an undirected
    graph have no direction, so</st> <st c="12313">if there is an edge between node</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="12346"><st c="12347">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="12357"><st c="12358">, the relationship is mutual.</st> <st c="12388">Therefore,
    both</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1852.png)
    <st c="12404"><st c="12406">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1853.png)
    <st c="12410"><st c="12411">will have the</st> <st c="12426">same value.</st></st></st></st></st></st></st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12437">For</st> <st c="12442">unweighted, unsigned graphs, the adjacency
    matrix is a binary matrix, where each entry is either 0 or 1\.</st> <st c="12547">A
    value of 1 at</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1854.png)
    <st c="12563"><st c="12570">indicates that there is an edge between vertices</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="12619"><st c="12620">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)<st
    c="12625"><st c="12626">, and a 0 means no edge exists</st> <st c="12657">between
    them.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="12670">Example 13.1</st>**<st c="12683">:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12685">Here is a matrix representing a digraph</st> <st c="12725">with
    weights:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12738">A --></st> <st c="12745">B (2)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12750">B --></st> <st c="12757">C (3)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12762">A --></st> <st c="12769">C (4)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12774">The adjacency matrix representing this simple graph is a</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:math>](img/1857.png)
    <st c="12832"><st c="12838">matrix</st> <st c="12845">as follows:</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mtable
    columnspacing="0.8000em 0.8000em" columnwidth="auto auto auto" columnalign="center
    center center" rowalign="baseline"><mtr><mtd><mi>A</mi></mtd><mtd><mi>B</mi></mtd><mtd><mi>C</mi></mtd></mtr></mtable></mrow></math>](img/1858.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtable><mml:mtr><mml:mtd><mml:mi>A</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>B</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>C</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/1859.png)'
  prefs: []
  type: TYPE_IMG
- en: <st c="12859">It is obvious that the space complexity of this representation
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1860.png)<st
    c="12925"><st c="12926">. Regardless of the number of edges, the adjacency matrix
    requires space proportional to the square of the number of vertices because it
    must account for every possible edge between all pairs of vertices.</st> <st c="13131">This
    can be inefficient for large graphs, especially if the graph is sparse (i.e.,
    has relatively few edges compared to the number of</st> <st c="13265">possible
    edges).</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13281">In graphs, one of the operations is accessing all neighbors of
    a node in the graph.</st> <st c="13366">Using adjacency matrix representation,
    the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1861.png)<st
    c="13428"><st c="13429">. To find all neighbors of a given node, we need to inspect
    all entries in the corresponding row (or column) of the matrix.</st> <st c="13553">For
    a node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="13564"><st c="13565">, you scan the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/1863.png)
    <st c="13580"><st c="13584">row to check which vertices have a direct edge from</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="13636"><st c="13637">, which reminds us of a linear search algorithm in which
    we want to report all non-zero entries.</st> <st c="13734">This operation requires
    examining</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1865.png)
    <st c="13768"><st c="13769">entries, resulting in a time complexity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1866.png)<st
    c="13813"><st c="13814">, regardless of the number of actual neighbors the node
    has.</st> <st c="13875">In contrast, checking whether an edge exists in the adjacency
    matrix representation has a time complexity of</st> <st c="13984">O</st><st c="13985">(</st><st
    c="13986">1</st><st c="13987">)</st><st c="13988">, as we can directly access
    any edge in constant time.</st> <st c="14043">Since the adjacency matrix</st>
    <st c="14069">is a two-dimensional array, checking whether an edge exists between
    node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="14143"><st c="14144">and</st> <st c="14149">node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/1035.png)
    <st c="14154"><st c="14155">is a direct access operation to the cell at position</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1869.png)<st
    c="14209"><st c="14210">. Simply check whether the value at</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo>(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1869.png)
    <st c="14246"><st c="14247">is non-zero (for weighted graphs) or</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi></mml:math>](img/1871.png)
    <st c="14285"><st c="14286">or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>1</mml:mn></mml:math>](img/1872.png)
    <st c="14290"><st c="14291">(for</st> <st c="14297">unweighted graphs).</st></st></st></st></st></st></st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14316">When should we use an adjacency matrix?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14356">It is particularly useful when the graph is dense (i.e., the number
    of edges is close to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1873.png)<st
    c="14446"><st c="14447">), as the high space requirement becomes less significant
    in such cases.</st> <st c="14520">Additionally, if our algorithm needs constant-time
    edge existence checks, the adjacency matrix offers a clear advantage.</st> <st
    c="14641">Lastly, the adjacency matrix is simple to implement, making it a practical
    choice for certain algorithms where ease of use is</st> <st c="14767">a priority.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14778">Adjacency list</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="14793">In</st> <st c="14797">an</st> **<st c="14800">adjacency list</st>**<st
    c="14814">, each node stores a list of its neighboring</st> <st c="14859">nodes
    (or nodes it is connected to).</st> <st c="14896">This is a more space-efficient
    representation, especially for sparse graphs.</st> <st c="14973">The adjacency
    list for</st> *<st c="14996">Example 13.1</st>* <st c="15008">is</st> <st c="15012">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15023">A:</st> <st c="15027">B(2), C(4)</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="15037">B: C(3)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="15045">C: -</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15050">The adjacency list representation uses</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1874.png)
    <st c="15090"><st c="15099">space, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/1875.png)
    <st c="15112"><st c="15113">is the number of edges.</st> <st c="15138">This is
    generally more efficient for</st> <st c="15175">sparse graphs.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15189">Accessing the neighbors of a node (i.e., adjacent vertices) takes</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1876.png)<st
    c="15256"><st c="15257">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/1184.png)
    <st c="15265"><st c="15266">is the degree of the node (the number of edges connected
    to the node).</st> <st c="15338">In the worst case, this could be</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1878.png)<st
    c="15371"><st c="15374">, but for most practical applications, it’s much smaller.</st>
    <st c="15432">In the preceding adjacency list, the nodes listed after the colon
    represent the neighbors, or adjacent nodes, of the node on the</st> <st c="15561">left
    side.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15571">To check</st> <st c="15581">whether there is an edge between two
    specific vertices, you need to traverse the list of adjacent vertices.</st> <st
    c="15689">This takes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1879.png)
    <st c="15700"><st c="15701">time, since we may need to scan through all neighbors
    of</st> <st c="15759">the source node.</st> <st c="15776">In the worst case, this
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1880.png)<st
    c="15803"><st c="15806">, but typically it is smaller for</st> <st c="15840">sparse
    graphs.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15854">When to use an adjacency list</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15884">An adjacency list is most effective when the graph is sparse –
    that is when the number of edges is much smaller than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1881.png)<st
    c="16002"><st c="16003">. Since the space complexity is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1882.png)<st
    c="16035"><st c="16045">, it is more memory-efficient for graphs with fewer edges.</st>
    <st c="16104">Additionally, if our algorithm frequently needs to access all neighbors
    of a node, the adjacency list provides efficient</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1883.png)
    <st c="16225"><st c="16226">access.</st> <st c="16235">It is also beneficial for
    dynamic graphs where nodes and edges are frequently added or removed, as updating
    an adjacency list is straightforward and less costly in terms</st> <st c="16405">of
    memory.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16415">Edge list</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="16425">An</st> **<st c="16429">edge list</st>** <st c="16438">explicitly</st>
    <st c="16449">stores all the edges in a graph</st> <st c="16482">along with their
    weights (if any).</st> <st c="16517">This is useful when the graph is sparse and
    you need to work primarily with the edges.</st> <st c="16604">The edge list in
    the</st> *<st c="16625">Example 13.1</st>* <st c="16637">graph is</st> <st c="16647">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16658">(A,</st> <st c="16663">B, 2)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16668">(A,</st> <st c="16673">C, 4)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16678">(B,</st> <st c="16683">C, 3)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16688">The edge list representation uses</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1884.png)
    <st c="16723"><st c="16724">space.</st> <st c="16732">This is efficient for very
    sparse graphs.</st> <st c="16774">To access all neighbors of a node, the edge
    list does not directly store them, so finding all neighbors requires scanning
    the entire edge list, which has a worst-case time complexity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1885.png)<st
    c="16960"><st c="16961">. Likewise, checking whether an edge exists between two
    vertices also involves scanning the entire edge list, resulting in a time complexity</st>
    <st c="17102">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1886.png)<st
    c="17105"><st c="17106">.</st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17107">When to use an edge list</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17132">An edge list is</st> <st c="17149">ideal for very sparse graphs
    where we primarily need to work with the edges themselves rather than frequently
    accessing neighbors or checking edge existence.</st> <st c="17307">It uses</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1887.png)
    <st c="17315"><st c="17320">space, making it highly memory-efficient for graphs
    with few edges.</st> <st c="17388">However, its primary limitation is that it
    is not efficient for operations such as finding all neighbors of a node or checking
    whether a specific edge exists, both of which require scanning through the entire
    list.</st> <st c="17603">Therefore, edge lists are best suited for algorithms
    where working directly with the edges is the focus, such as in certain edge-centric
    algorithms such as Kruskal’s minimum spanning</st> <st c="17786">tree algorithm.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17801">Traversing graphs</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**<st c="17819">Traversal</st>** <st c="17829">is a</st> <st c="17834">fundamental
    operation in graph algorithms, where the goal is to visit all nodes in a specific
    sequence.</st> <st c="17939">The two most widely used graph traversal techniques
    are</st> **<st c="17995">depth-first search</st>** <st c="18013">(</st>**<st c="18015">DFS</st>**<st
    c="18018">) and</st> **<st c="18025">breadth-first search</st>** <st c="18045">(</st>**<st
    c="18047">BFS</st>**<st c="18050">).</st> <st c="18054">In the sections that</st>
    <st c="18074">follow, we will explore both of these methods</st> <st c="18120">in
    detail, highlighting their processes, use cases,</st> <st c="18173">and complexities.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18190">DFS graph traversal</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="18210">DFS is a</st> <st c="18220">graph traversal technique that explores
    as far along each</st> <st c="18277">branch or path as possible before backtracking.</st>
    <st c="18326">It is typically implemented using recursion or a stack, and it works
    well in exploring deep structures or discovering specific paths in</st> <st c="18462">a
    graph.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18470">The idea behind DFS is to start at an arbitrary node (usually
    called the</st> *<st c="18544">root</st>*<st c="18548">) and explore each branch
    of the graph as deeply as possible before moving on to the next branch.</st> <st
    c="18647">DFS follows these</st> <st c="18665">basic steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18677">Visit the</st> <st c="18688">starting node.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="18702">For each unvisited neighbor of the current node, perform a DFS
    on</st> <st c="18769">that neighbor.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="18783">Repeat this process until all nodes reachable from the starting
    node</st> <st c="18853">are visited.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="18865">Let’s</st> <st c="18872">consider</st> <st c="18880">the graph
    in</st> *<st c="18894">Figure 13</st>**<st c="18903">.5</st>* <st c="18905">with</st>
    <st c="18911">six nodes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: An example graph](img/B22248_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="18923">Figure 13.5: An example graph</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="18952">Starting the DFS at</st> *<st c="18973">node A</st>*<st c="18979">,
    the traversal order would be this: A --> B --> D --> E --> F --> C.</st> <st c="19049">This
    traversal explores one path (branch) completely before moving on to</st> <st c="19122">the
    next.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19131">Here is a Python implementation of DFS using recursion.</st> <st
    c="19188">First, we define a</st> <st c="19207">simple graph:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="19468">The</st> <st c="19473">following</st> <st c="19483">code visualizes
    the</st> <st c="19503">example graph:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20013">Now, we</st> <st c="20022">implement the DFS</st> <st c="20040">traversal
    algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20263">Let’s examine</st> <st c="20277">the code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20287">The graph is represented as an</st> <st c="20319">adjacency list</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20333">We use a</st> **<st c="20343">visited</st>** <st c="20350">set
    to ensure that nodes are</st> <st c="20380">not revisited</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20393">The</st> **<st c="20398">dfs</st>** <st c="20401">function prints
    the current node, marks it as visited, and recursively calls itself on all</st>
    <st c="20493">unvisited neighbors</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20512">For the given graph, the output will be</st> <st c="20553">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20581">DFS is more memory efficient compared to BFS, particularly in
    deep graphs.</st> <st c="20657">This is because DFS only needs to keep track of
    the current path and backtracking information, while BFS must store all nodes
    at each level of the graph.</st> <st c="20811">DFS is also beneficial for pathfinding,
    especially in scenarios where all possible paths need to be explored, such as
    maze-solving algorithms.</st> <st c="20954">Additionally, DFS is</st> <st c="20975">frequently
    used for topological sorting in</st> **<st c="21018">directed acyclic graphs</st>**
    <st c="21041">(</st>**<st c="21043">DAGs</st>**<st c="21047">), a technique useful
    in scheduling tasks and</st> <st c="21094">resolving dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21117">However, DFS has some</st> <st c="21140">limitations.</st> <st
    c="21153">One major drawback is that DFS may not find the shortest path in an
    unweighted graph, as it could explore a deep path before reaching the solution,
    which might not be optimal.</st> <st c="21329">Additionally, in very large or
    infinite graphs, DFS can get</st> <st c="21389">stuck exploring long paths or
    cycles unless precautions, such as cycle detection, are in place.</st> <st c="21485">In
    languages such as Python, which have a limit on recursion depth, using a recursive
    DFS can lead to stack overflow errors if the graph is particularly deep.</st>
    <st c="21644">To avoid this, DFS can be implemented iteratively using an explicit
    stack instead of relying</st> <st c="21737">on recursion.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21750">The</st> <st c="21754">time complexity of DFS is</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1888.png)<st
    c="21781"><st c="21791">, where V.</st> <st c="21802">This is because DFS visits
    every node and every edge in the graph once.</st> <st c="21874">In a sparse graph
    where</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>E</mi><mo>≈</mo><mi>V</mi></mrow></mrow></math>](img/1889.png)<st
    c="21898"><st c="21900">, the time complexity is close to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1890.png)<st
    c="21934"><st c="21935">. On the other side, in a dense graph where</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi><mml:mo>≈</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/1891.png)<st
    c="21979"><st c="21980">, the time complexity</st> <st c="22002">approaches</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/1860.png)<st
    c="22013"><st c="22014">.</st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22015">The space complexity</st> <st c="22037">of DFS is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1880.png)
    <st c="22047"><st c="22050">in the worst case due to the depth of the recursion
    stack or the explicit stack used in the iterative version.</st> <st c="22161">In
    a worst-case scenario, where the graph is a long linear chain, the stack could
    hold all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/1722.png)
    <st c="22252"><st c="22253">nodes.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="22259">There are two</st> <st c="22274">common variants of DFS:</st>
    **<st c="22298">pre-order DFS</st>**<st c="22311">, which visits a node before
    exploring its neighbors (as seen in the earlier example), and</st> **<st c="22402">post-order
    DFS</st>**<st c="22416">, which visits a node only after visiting all its neighbors.</st>
    <st c="22477">In the</st> <st c="22484">same graph (</st>*<st c="22496">Figure
    13</st>**<st c="22506">.5</st>*<st c="22508">), if we perform a post-order DFS,
    the traversal will result in the following order: D --> F --> E --> B --> C -->
    A.</st> <st c="22627">These variants are useful in different scenarios, such as
    tree traversal and algorithms that require specific orderings of</st> <st c="22750">node
    processing.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22766">DFS has numerous applications in algorithm design, including its
    use in AI search algorithms.</st> <st c="22861">For instance, DFS is employed
    in problems that require exploring all possible paths between nodes, such as solving
    puzzles or finding paths through mazes.</st> <st c="23016">It is also highly effective
    for cycle detection in both directed and undirected graphs, helping to identify
    loops within</st> <st c="23136">the graph structure.</st> <st c="23158">Additionally,
    DFS can be used to find all connected components in a graph, particularly in undirected
    graphs.</st> <st c="23268">In DAGs, DFS plays a crucial role in topological sorting,
    which is essential for tasks such as scheduling and dependency resolution.</st>
    <st c="23401">These diverse applications highlight the importance of DFS in various</st>
    <st c="23471">computational problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23494">In summary, DFS is a powerful and efficient graph traversal technique,
    especially useful for pathfinding and solving problems that require exploring
    all possibilities.</st> <st c="23663">Although it doesn’t guarantee</st> <st c="23693">the
    shortest path, it excels in scenarios where memory efficiency is critical or when
    dealing with deep structures.</st> <st c="23809">The key trade-offs include potentially
    long search times for large graphs and the risk of stack overflow in deep recursion.</st>
    <st c="23933">In the next section, we will explore the BFS</st> <st c="23978">traversal
    approach.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23997">BFS graph traversal</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="24017">BFS</st>** <st c="24021">is another</st> <st c="24032">graph
    traversal algorithm that explores nodes</st> <st c="24079">level by level, starting
    from a given source node.</st> <st c="24130">Unlike DFS, which goes as deep as
    possible into one branch before backtracking, BFS explores all neighbors of a
    node before moving on to the next level of neighbors.</st> <st c="24296">This
    makes BFS particularly effective for finding the shortest path in</st> <st c="24367">unweighted
    graphs.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24385">The BFS algorithm starts at the root (or any arbitrary starting
    node) and explores all its neighbors first.</st> <st c="24494">After visiting
    all neighbors at the current level, it proceeds to the next level, visiting the
    neighbors of those neighbors, and so on.</st> <st c="24630">The traversal continues
    until all nodes reachable from the starting node have</st> <st c="24708">been
    visited.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24721">The core of BFS relies on using a queue data structure, which
    ensures that nodes are explored in the correct order (</st>**<st c="24838">first-in
    first-out</st>** <st c="24857">(</st>**<st c="24859">FIFO</st>**<st c="24863">)).</st>
    <st c="24868">Let’s consider the graph in</st> *<st c="24896">Figure 13</st>**<st
    c="24905">.6</st>* <st c="24907">with six nodes.</st> <st c="24924">Starting the
    BFS at</st> *<st c="24944">node A</st>*<st c="24950">, the traversal order would
    be A --> B --> C -->D --> E --> F --> C.</st> <st c="25019">This traversal explores
    one path (branch) completely before moving on to</st> <st c="25092">the next.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: An example graph for BFS traversal](img/B22248_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="25103">Figure 13.6: An example graph for BFS traversal</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25150">Here is a</st> <st c="25161">Python</st> <st c="25167">implementation
    of BFS using</st> <st c="25196">a queue:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25752">This is</st> <st c="25761">how</st> <st c="25764">the code works.</st>
    <st c="25781">First, we represent the graph using an adjacency list.</st> <st
    c="25836">Next, we implement the queue data structure, which is essential for
    the BFS algorithm.</st> <st c="25923">Finally, we implement the BFS traversal</st>
    <st c="25963">algorithm itself:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="25980">Graph representation</st>**<st c="26001">: The graph is represented
    as an</st> <st c="26035">adjacency list</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26049">Queue</st>**<st c="26055">:</st> **<st c="26058">deque</st>**
    <st c="26063">is used to efficiently handle queue operations (enqueueing and</st>
    <st c="26127">dequeueing nodes)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26144">bfs</st>**<st c="26148">: Nodes are processed in the order
    they are dequeued, and their neighbors are added to the queue for</st> <st c="26250">further
    exploration</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26269">For the given graph, the output will be</st> <st c="26310">as
    follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26338">BFS offers several advantages</st> <st c="26368">over DFS.</st>
    <st c="26379">In an unweighted graph, BFS guarantees that the first time a node
    is reached, it is via the shortest path from the source node, making it ideal
    for pathfinding problems.</st> <st c="26549">Additionally, BFS explores all nodes
    at the same level before moving on to the next level, which is particularly useful
    when all immediate neighbors need to be visited first, such as in finding the
    shortest route in transportation systems.</st> <st c="26789">Furthermore, BFS
    is highly effective in identifying all connected components in an undirected graph,
    as it systematically explores all</st> <st c="26924">reachable nodes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26940">However, BFS</st> <st c="26953">has its drawbacks.</st> <st c="26973">It
    requires storing all nodes at the current level in memory, which can lead to significant
    memory consumption, particularly in graphs with large branching factors.</st>
    <st c="27138">Additionally, BFS can be inefficient for graphs with deep structures,
    as it explores level by level.</st> <st c="27239">In cases where the graph is
    deep but not very broad, DFS may be a more efficient alternative since it focuses
    on depth rather than breadth in</st> <st c="27381">its exploration.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27397">The time complexity of BFS is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1895.png)<st
    c="27428"><st c="27437">, as each vertex and edge is processed exactly once during
    the traversal.</st> <st c="27511">In contrast, the space complexity of BFS is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1896.png)<st
    c="27555"><st c="27560">, since in the worst case, all nodes at a particular level
    could be stored in the queue simultaneously.</st> <st c="27664">This becomes particularly
    significant in graphs with large branching factors or wide levels, where the memory
    requirements can</st> <st c="27791">grow substantially.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27810">BFS has two notable variants:</st> **<st c="27841">bidirectional
    BFS</st>** <st c="27858">and</st> **<st c="27863">multi-source BFS</st>**<st c="27879">.
    Bidirectional BFS is</st> <st c="27902">used to find the shortest path between
    two nodes.</st> <st c="27952">It runs two BFS traversals simultaneously – one
    from the source node and</st> <st c="28025">one from the destination node – until
    the two searches meet in the middle.</st> <st c="28100">This approach reduces
    the search space significantly, making it faster than a traditional BFS in scenarios
    where the source and destination are far apart.</st> <st c="28255">Multi-source
    BFS involves multiple starting points.</st> <st c="28307">BFS is initiated from
    all the source nodes at the same time, allowing exploration from multiple origins
    simultaneously.</st> <st c="28427">This variant is useful in scenarios where you
    need to explore paths from several locations, such as finding the shortest distance
    from multiple sources to a destination in</st> <st c="28599">a graph.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28607">BFS has a wide</st> <st c="28623">range of applications, including
    its use in AI search strategies.</st> <st c="28689">One of its key strengths is
    its ability to find the shortest path in unweighted graphs.</st> <st c="28777">Since
    BFS explores all nodes at the same level before moving deeper, it guarantees that
    the first time a node is reached, it is via the shortest possible path.</st> <st
    c="28937">This makes BFS ideal for pathfinding algorithms, such</st> <st c="28991">as
    navigation systems or solving puzzles where all moves have</st> <st c="29053">equal
    cost.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29064">Let’s modify the BFS algorithm to find the shortest path between</st>
    <st c="29130">two nodes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29734">For the given graph, the</st> <st c="29760">shortest path between</st>
    `<st c="29782">A</st>` <st c="29783">and</st> `<st c="29788">F</st>` <st c="29789">is</st>
    <st c="29793">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29820">Another</st> <st c="29829">notable application of BFS is in undirected
    graphs.</st> <st c="29881">BFS is particularly useful for identifying all nodes
    that are reachable from a given starting point.</st> <st c="29982">By doing this,
    BFS can efficiently detect and label connected components, which is essential
    in network analysis and social</st> <st c="30106">network mapping.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30122">Additionally, BFS is widely used for level-order traversal in
    trees.</st> <st c="30192">In this scenario, BFS visits all nodes at each depth
    level before progressing to the next, making it an ideal approach when the hierarchy
    or levels of the nodes matter, such as in organization charts, filesystem structures,
    or</st> <st c="30419">hierarchical clustering.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30443">Beyond these core applications, BFS is widely used in AI search
    algorithms, alongside DFS, as two major search techniques.</st> <st c="30567">Additionally,
    BFS is employed in finding the minimum spanning tree and the shortest path in
    various</st> <st c="30667">graph-related problems:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="30690">BFS in AI</st>**<st c="30700">: BFS serves as the foundation
    for many AI search strategies, particularly those that require exploration of
    all possible states level by level, such as in game trees or</st> <st c="30871">puzzle
    solving</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="30885">Finding the minimum spanning tree</st>**<st c="30919">: In
    unweighted graphs, BFS can be used as a building block to find the minimum spanning
    tree by ensuring all nodes are visited in the shortest path order from</st> <st
    c="31080">the source</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31090">Network broadcast</st>**<st c="31108">: In computer networks,
    BFS is used to simulate broadcast routing, where information must be sent to all
    nodes in the shortest possible time, making it crucial for network discovery protocols
    such as</st> **<st c="31309">Open Shortest Path</st>** **<st c="31328">First</st>**
    <st c="31333">(</st>**<st c="31335">OSPF</st>**<st c="31339">)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="31341">These diverse</st> <st c="31355">applications highlight the versatility
    of BFS, making it a fundamental tool in algorithm design and practical implementations
    across</st> <st c="31488">various fields.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31503">In summary, BFS is an essential graph traversal technique, particularly
    useful when the goal is to explore all nodes level by level or to find the shortest
    path in unweighted graphs.</st> <st c="31687">While it is efficient in terms of
    time complexity, its higher memory requirements can be a drawback for graphs with
    large branching factors.</st> <st c="31828">BFS’s guaranteed shortest-path property
    and its versatility in various algorithmic tasks make it a powerful tool in many</st>
    <st c="31949">real-world applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31973">Before moving</st> <st c="31988">on to the next non-linear data
    structure, let’s conclude our discussion on graphs by summarizing their significance
    and applications in algorithm design.</st> <st c="32142">Graphs are incredibly
    versatile structures that allow us to model and solve a wide range of problems
    in areas such as networking, social analysis, and AI.</st> <st c="32297">They
    can represent complex relationships between entities, and through various algorithms
    such as BFS and DFS, we can efficiently traverse, search, and process graph data.</st>
    <st c="32469">Graphs play a central role in critical applications such as pathfinding,
    network routing, cycle detection, and even</st> <st c="32585">hierarchical problem-solving.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32614">Their importance in algorithm design cannot be overstated, as
    they form the foundation for solving problems that involve connectivity, optimization,
    and search strategies in both theoretical and</st> <st c="32810">practical fields.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32827">Trees</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="32833">A</st> **<st c="32836">tree</st>** <st c="32840">is a</st> <st
    c="32845">hierarchical, non-linear data structure that consists of nodes connected
    by edges.</st> <st c="32929">Trees are widely used in various applications, such
    as organizing data, databases, network structures, and more.</st> <st c="33042">A
    tree has a single root node and all other nodes are connected in a parent-child
    relationship.</st> <st c="33138">The tree structure ensures that there are no
    cycles, and each child has exactly</st> <st c="33218">one parent.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33229">In this section, we will explore different types of trees, their
    properties, and how to represent trees and</st> <st c="33338">discuss</st> <st
    c="33346">two important types:</st> **<st c="33367">binary search trees</st>**
    <st c="33386">(</st>**<st c="33388">BSTs</st>**<st c="33392">) and</st> **<st
    c="33399">red-black trees</st>**<st c="33414">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33415">Different types of trees and their properties</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="33461">Trees come in many types, each with unique characteristics suited
    for different applications.</st> <st c="33556">Here are some of the most</st>
    <st c="33582">common types:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="33595">General tree</st>**<st c="33608">: A</st> <st c="33613">general
    tree is a type of tree where any node can</st> <st c="33662">have an arbitrary
    number of children.</st> <st c="33701">This type of tree can be used to represent
    hierarchical data, such as filesystems or organization charts.</st> *<st c="33807">Figure
    13</st>**<st c="33816">.7</st>* <st c="33818">illustrates an example of a</st>
    <st c="33847">general tree.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.7: An example general tree](img/B22248_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="33862">Figure 13.7: An example general tree</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="33898">Binary tree</st>**<st c="33910">: A</st> <st c="33915">binary
    tree is a type of tree where each node has a</st> <st c="33966">maximum of</st>
    <st c="33978">two children, known as the</st> **<st c="34005">left child</st>**
    <st c="34015">and</st> <st c="34020">the</st> **<st c="34024">right child</st>**<st
    c="34035">. It is one of the most commonly used tree structures in computer science.</st>
    <st c="34110">In</st> *<st c="34113">Figure 13</st>**<st c="34122">.7</st>*<st
    c="34124">, all subtrees rooted at</st> *<st c="34149">nodes 1</st>*<st c="34156">,</st>
    *<st c="34158">5</st>*<st c="34159">, and</st> *<st c="34165">6</st>* <st c="34166">are
    examples of</st> <st c="34183">binary trees.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34196">Full binary tree</st>**<st c="34213">: A</st> <st c="34218">binary
    tree is considered full if every node has either</st> <st c="34273">zero or two
    children.</st> <st c="34296">No nodes have only one child.</st> <st c="34326">In</st>
    *<st c="34329">Figure 13</st>**<st c="34338">.7</st>*<st c="34340">, the subtree
    rooted at</st> *<st c="34364">node 5</st>* <st c="34370">is a full</st> <st c="34381">binary
    tree.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34393">Complete binary tree</st>**<st c="34414">: A</st> <st c="34418">complete
    binary tree is a</st> <st c="34445">binary tree where all levels are fully filled
    except possibly the last, which must be filled from left to right.</st> <st c="34558">A
    well-known complete binary tree is a heap structure, which will be discussed at
    the end of</st> <st c="34651">this chapter.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="34664">Balanced binary tree</st>**<st c="34685">: A</st> <st c="34689">tree
    is considered balanced if the</st> <st c="34725">heights of the left and right
    subtrees of any node differ by no more than one.</st> <st c="34804">Balanced trees
    are preferred because they ensure optimal performance for search, insertion, and
    deletion operations.</st> <st c="34921">In</st> *<st c="34924">Figure 13</st>**<st
    c="34933">.8</st>*<st c="34935">, the binary tree is</st> <st c="34956">fully
    balanced.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.8: A perfectly balanced binary tree](img/B22248_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="34973">Figure 13.8: A perfectly balanced binary tree</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="35018">Figure 13</st>**<st c="35028">.9</st>* <st c="35030">illustrates
    a counterexample of a non-balanced binary tree.</st> <st c="35091">In this tree,
    the height of the subtrees differs significantly, violating the balanced binary
    tree property, where the heights of the left and right subtrees of any node should
    differ by no more than one.</st> <st c="35296">This imbalance can lead to inefficient
    operations such as searching, insertion, and deletion, as the tree structure begins
    to resemble a</st> <st c="35433">linear chain.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: A counterexample of a non-balanced binary tree](img/B22248_13_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="35448">Figure 13.9: A counterexample of a non-balanced binary tree</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35507">AVL tree</st>**<st c="35516">: An</st> <st c="35521">AVL tree
    (named after inventors Adelson-Velsky and Landis) is a self-balancing binary search
    tree (BST).</st> <st c="35627">It</st> <st c="35630">maintains a balance factor
    (the difference between the heights of the left and right subtrees) for every
    node, ensuring that the tree remains balanced after insertions</st> <st c="35798">and
    deletions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35812">B-tree</st>**<st c="35819">: A B-tree</st> <st c="35830">is
    a self-balancing tree data structure that maintains</st> <st c="35885">sorted
    data and allows searches, sequential access, insertions, and deletions in logarithmic
    time.</st> <st c="35985">B-trees are commonly used in databases</st> <st c="36024">and
    filesystems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="36040">Red-black tree</st>**<st c="36055">: A</st> <st c="36060">red-black
    tree is another type of self-balancing BST.</st> <st c="36114">Each</st> <st c="36119">node
    in the tree is assigned a color (red or black) to ensure that the tree remains
    balanced, which guarantees better worst-case time complexity for insertions</st>
    <st c="36279">and deletions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36293">Next, we will discuss two common tree representation methods:</st>
    **<st c="36356">linked representation</st>** <st c="36377">and</st> **<st c="36382">array
    representation</st>**<st c="36402">. Each method offers different advantages and
    is suited for specific types of operations and tree structures.</st> <st c="36512">By
    understanding both, we can choose the most efficient representation for a</st>
    <st c="36589">given application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36607">Tree representation</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="36627">Trees can be</st> <st c="36640">represented in several ways, each
    depending on the use case and complexity of the operations.</st> <st c="36735">Let’s
    explore this</st> <st c="36754">in detail.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36764">Linked representation</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="36786">In the</st> <st c="36794">linked representation of a binary tree,
    each node contains data and pointers (or references) to its left and right children.</st>
    <st c="36919">This is a more flexible representation than the array representation,
    as it doesn’t require the tree to be a complete binary tree.</st> <st c="37050">Instead,
    each node directly references its children, allowing for</st> <st c="37116">irregular
    structures.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37137">This</st> <st c="37143">representation is commonly used for binary
    trees and BST, where the nodes can have arbitrary arrangements.</st> <st c="37250">Each
    node in the tree is defined as a class or structure that holds a value and two
    pointers to its left and right</st> <st c="37365">child nodes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37377">The following code is an implementation of a node in Python using
    the</st> <st c="37448">linked representation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="38405">Let’s</st> <st c="38411">explain</st> <st c="38420">the many components
    of</st> <st c="38443">the code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="38452">TreeNode</st>**<st c="38461">: Each node contains a value (</st>**<st
    c="38492">key</st>**<st c="38496">) and two pointers (</st>**<st c="38517">left</st>**
    <st c="38522">and</st> **<st c="38527">right</st>**<st c="38532">), which reference
    the left and right</st> <st c="38571">children, respectively</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="38593">Creating nodes</st>**<st c="38608">: We create nodes and link
    them to form the structure of a</st> <st c="38668">binary tree</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="38679">In-order traversal</st>**<st c="38698">: The</st> **<st c="38705">inorder_traversal</st>**
    <st c="38722">function recursively visits the left subtree, the root, and then
    the right subtree, printing the nodes in a sorted order for</st> <st c="38848">a
    BST</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="38853">The linked representation works for any type of binary tree, whether
    it is complete, balanced, or irregular.</st> <st c="38963">This approach is especially
    memory efficient for sparse trees, as memory is only</st> <st c="39044">allocated
    for the nodes that are actually present.</st> <st c="39095">This eliminates the
    need for continuous memory allocation for non-existent nodes, unlike</st> <st
    c="39184">array representation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39205">Additionally, the</st> <st c="39223">linked representation is
    more flexible for dynamic operations such as insertion, deletion, and traversal.</st>
    <st c="39330">Since each node directly references its children, modifying the
    tree structure is straightforward and doesn’t require reordering or shifting elements,
    as would be needed in an array-based representation.</st> <st c="39534">This makes
    it ideal for trees that grow or change frequently, such as</st> <st c="39604">in
    BSTs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39612">Array representation</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="39633">This</st> <st c="39639">method is commonly used for representing</st>
    <st c="39680">complete binary trees, such as heap structures.</st> <st c="39728">In
    this approach, a binary tree is stored as an array or list, where the root node
    is located at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>0</mml:mn></mml:math>](img/1897.png)<st
    c="39831"><st c="39832">. For any node at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="39856"><st c="39857">, its children are positioned</st> <st c="39887">as follows:</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39898">The left child is located at</st> <st c="39928">index</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>](img/1899.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39935">The right child is located at</st> <st c="39965">index</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mrow></math>](img/1900.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39972">This array-based representation is highly efficient for complete
    binary trees because it avoids the need for pointers to track the parent-child
    relationships.</st> <st c="40131">It also allows for fast access to children or
    parents directly by calculating their indices.</st> <st c="40224">Here’s a simple
    Python example demonstrating the array representation of a small complete</st>
    <st c="40314">binary tree:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40715">This</st> <st c="40720">array-based structure is ideal for heaps,
    where</st> <st c="40768">insertion and deletion operations require efficient reordering
    to maintain the heap property.</st> <st c="40863">The simplicity of the index-based
    parent-child relationships makes this representation fast and memory-efficient
    for complete</st> <st c="40989">binary trees.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41002">Parent array representation</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="41030">Another</st> <st c="41039">way</st> <st c="41043">to represent
    a tree is by storing the parent of each node in an array.</st> <st c="41114">In
    this approach, each index of the array corresponds to a node, and the value at
    that index represents the parent of that node.</st> <st c="41243">The root node
    is assigned a special value (commonly</st> `<st c="41295">-1</st>`<st c="41297">)
    to indicate that it has</st> <st c="41324">no parent.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41334">This representation is particularly useful when we need to reconstruct
    the tree from parent-child relationships or when the tree is stored in such a
    way that direct access to child nodes is</st> <st c="41525">not necessary.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41539">Here is a simple Python implementation for representing a tree
    using a parent array.</st> <st c="41625">The first part is a function to build
    the tree from a</st> <st c="41679">parent array:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="42114">Next, we</st> <st c="42123">define</st> <st c="42130">the</st>
    `<st c="42135">TreeNode</st>` <st c="42143">class:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="42241">Finally, we build an example parent array, where</st> `<st c="42291">-1</st>`
    <st c="42293">represents</st> <st c="42305">the root:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="42687">Let’s</st> <st c="42694">explain the many components</st> <st
    c="42721">of</st> <st c="42725">the code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="42734">Parent array</st>**<st c="42747">: The array represents the
    parent of each node.</st> <st c="42796">For example, if</st> **<st c="42812">parent_array[3]
    = 1</st>**<st c="42831">, it means</st> *<st c="42842">node 3</st>* <st c="42848">has</st>
    *<st c="42853">node 1</st>* <st c="42859">as its parent.</st> <st c="42875">The
    root node has the value</st> **<st c="42903">-1</st>**<st c="42905">, indicating
    it has</st> <st c="42925">no parent.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42935">build_tree</st>**<st c="42946">: We first create an array of
    nodes and then link each node to its parent using the parent array.</st> <st c="43045">The
    nodes are connected either as the left or right child, depending</st> <st c="43114">on
    availability.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="43130">inorder_traversal</st>**<st c="43148">: We perform an in-order
    traversal of the tree to visit the nodes in their</st> <st c="43224">sorted order.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43237">The parent array representation offers several advantages.</st>
    <st c="43297">One significant benefit is its space efficiency.</st> <st c="43346">Since
    this method only stores the parent-child relationships, it eliminates the need
    for additional pointers to left and right children, making it a compact structure.</st>
    <st c="43514">This feature makes it particularly suitable for environments where
    memory</st> <st c="43588">is limited.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43599">Another advantage is its usefulness in reconstructing a tree from
    given parent-child relationships, such as those found in filesystems, organization
    charts, or other hierarchical structures.</st> <st c="43791">This method allows
    for easy and efficient</st> <st c="43833">tree reconstruction.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43853">Additionally, it is</st> <st c="43873">efficient in applications
    where direct access to parent nodes is required.</st> <st c="43949">Since each
    index in the array corresponds to a specific node and stores its parent, retrieving
    the parent of any node can be done in</st> <st c="44082">constant time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44096">Lastly, the</st> <st c="44109">parent array representation is
    well suited for cases where trees are stored in external memory.</st> <st c="44205">It
    requires minimal data storage, which makes it particularly useful in databases
    or large-scale systems where the tree structure needs to be reconstructed on demand
    with</st><st c="44375">out taking up</st> <st c="44390">excessive space.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44406">This representation is helpful when working with static tree structures,
    especially in cases where storing the parent relationships alone suffices for
    the</st> <st c="44562">intended operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44582">BSTs</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="44587">A</st> **<st c="44590">BST</st>** <st c="44593">is a</st> <st
    c="44599">type of binary tree where the nodes are organized in a way that for
    every node, the left subtree contains only nodes with values less than the node,
    and the right subtree contains only nodes with values greater than the node.</st>
    <st c="44825">This property makes BSTs efficient for search operations.</st> *<st
    c="44883">Figure 13</st>**<st c="44892">.10</st>* <st c="44895">illustrates a
    simple BST.</st> <st c="44922">The following are</st> <st c="44939">the properties
    of</st> <st c="44958">a BST:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44964">The left child contains values less than the</st> <st c="45010">parent
    node</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="45021">The right child contains values greater than the</st> <st c="45071">parent
    node</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="45082">In-order traversal of a BST produces a</st> <st c="45122">sorted
    sequence</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figur\uFEFFe 13.10: An example BST](img/B22248_13_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: '<st c="45139">Figur</st><st c="45144">e 13.10: An example BST</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45168">Before exploring</st> <st c="45185">the operations of a BST,
    it is important to first understand how to traverse a BST.</st> <st c="45270">In
    a BST, similar to graphs, traversal refers to the process of visiting and processing
    each node in the tree.</st> <st c="45381">There are three common methods of traversal
    (or tree-walk): in-order, pre-order, and post-order.</st> <st c="45478">Each traversal
    method follows a specific order to visit the nodes, and all of them have the same
    time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)
    <st c="45594"><st c="45595">since each node is visited</st> <st c="45623">exactly
    once.</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45636">In-order traversal</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="45655">In-order traversal</st>** <st c="45674">visits</st> <st c="45681">the
    nodes in the following order: left subtree, root, right subtree.</st> <st c="45751">In
    a BST, an in-order traversal will visit the nodes in sorted order (ascending).</st>
    <st c="45833">The in-order traversal steps are</st> <st c="45866">as follows:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45877">Traverse the</st> <st c="45891">left subtree.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45904">Visit the</st> <st c="45915">root node.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45925">Traverse the</st> <st c="45939">right subtree.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45953">For the BST shown in</st> *<st c="45975">Figure 13</st>**<st c="45984">.11</st>*<st
    c="45987">, we aim to perform an in-order traversal of</st> <st c="46032">the
    tree.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: An example BST](img/B22248_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="46043">Figure 13.11: An example BST</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46071">Here is the Python code for</st> <st c="46100">in-order traversal:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46397">First, we build</st> <st c="46413">the BST using the following</st>
    <st c="46442">Python code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46673">Then, we call</st> `<st c="46688">inorder_traversal</st>` <st
    c="46705">to perform in-order</st> <st c="46726">BST traversal:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46822">In-order traversal</st> <st c="46842">generates</st> <st c="46852">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46886">Pre-order traversal</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="46906">Pre-order traversal</st>** <st c="46926">visits</st> <st c="46934">the
    nodes in the following order: root, left subtree, right subtree.</st> <st c="47003">This
    method is useful for creating a copy of the tree or for printing the tree structure.</st>
    <st c="47093">The pre-order traversal steps are</st> <st c="47127">as follows:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47138">Visit the</st> <st c="47149">root node.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47159">Traverse the</st> <st c="47173">left subtree.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47186">Traverse the</st> <st c="47200">right subtree.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47214">The pre-order traversal will visit the nodes in BST of</st> *<st
    c="47270">Figure 13</st>**<st c="47279">.11</st>* <st c="47282">in the following
    order:</st> `<st c="47307">20, 10, 5, 15, 30,</st>` `<st c="47326">25, 35</st>`<st
    c="47332">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47333">The following is the Python code for</st> <st c="47371">pre-order
    traversal:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="47636">Post-order traversal</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="47657">Post-order traversal</st>** <st c="47678">visits</st> <st c="47685">the
    nodes in the following order: left subtree, right subtree, root.</st> <st c="47755">This
    traversal is often used in applications such as tree deletion, where you must
    delete the children before deleting the parent node.</st> <st c="47891">The post-order
    traversal steps are</st> <st c="47926">as follows:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47937">Traverse the</st> <st c="47951">left subtree.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47964">Traverse the</st> <st c="47978">right subtree.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47992">Visit the</st> <st c="48003">root node.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="48013">For the example in</st> *<st c="48033">Figure 13</st>**<st c="48042">.11</st>*<st
    c="48045">, the post-order traversal will visit the nodes in the following order:</st>
    `<st c="48117">5, 15, 10, 25, 35,</st>` `<st c="48136">30, 20</st>`<st c="48142">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48143">Here is the Python code for</st> <st c="48172">post-order traversal:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="48445">In summary, in-order traversal visits nodes in the sorted order
    (left, root, right) and is commonly used for</st> <st c="48554">extracting sorted
    data from BSTs.</st> <st c="48589">Pre-order traversal visits nodes in the order
    (root, left, right), making it useful for copying the tree structure or printing
    it.</st> <st c="48720">Post-order traversal visits nodes in the order (left, right,
    root) and is helpful for tasks such as tree deletion, where processing the child
    before the parent</st> <st c="48880">is necessary.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48893">In a BST, the main operations – insertion, deletion, and searching
    – rely on the tree structure and properties.</st> <st c="49006">The efficiency
    of these operations depends heavily on whether the tree is balanced or not.</st>
    <st c="49097">Let’s explore these operations</st> <st c="49128">in detail.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49138">The search operation in a BST</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="49168">Searching</st> <st c="49178">in a BST leverages the property that
    the left subtree contains values smaller than the current node and the right subtree
    contains values larger than the current node.</st> <st c="49347">This allows us
    to effectively halve the search space with each step, similar to</st> <st c="49427">binary
    search:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="49441">Average case (balanced tree)</st>**<st c="49470">: In a balanced
    BST (such as the one shown in</st> *<st c="49517">Figure 13</st>**<st c="49526">.6</st>*<st
    c="49528">), the search</st> <st c="49542">operation takes</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1246.png)
    <st c="49559"><st c="49568">time.</st> <st c="49574">This is because the tree
    height is logarithmic relative to the number of nodes, and we reduce the search
    space at</st> <st c="49688">each level.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="49699">Worst case (unbalanced tree)</st>**<st c="49728">: If the BST
    is unbalanced, the search time complexity</st> <st c="49784">can approach</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1201.png)<st
    c="49797"><st c="49798">, where the tree starts resembling a linked list.</st>
    <st c="49848">In such cases, the tree height grows linearly with the number of
    nodes, making</st> <st c="49927">searches inefficient.</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="49948">For extreme cases, such as the skewed tree in</st> *<st c="49995">Figure
    13</st>**<st c="50004">.12</st>*<st c="50007">, the search complexity reaches</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1904.png)<st
    c="50039"><st c="50040">, where every node has only one child, and the tree degenerates
    into a</st> <st c="50111">linear structure.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: An example of extreme unbalanced BST](img/B22248_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="50130">Figure 13.12: An example of extreme unbalanced BST</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50180">The following</st> <st c="50194">is a Python implementation of
    searching in a BST.</st> <st c="50245">The first part is the definition of a</st>
    `<st c="50283">TreeNode</st>` <st c="50291">class for</st> <st c="50302">the BST:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50401">To build the BST, we implement the insertion operation using the</st>
    `<st c="50467">insert</st>` <st c="50473">function</st> <st c="50483">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50776">The</st> `<st c="50781">search</st>` <st c="50787">operation</st>
    <st c="50797">is implemented</st> <st c="50813">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51208">Let’s create the root node and insert elements into</st> <st c="51261">the
    BST:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51358">The following shows how to search a key</st> <st c="51399">in
    BST:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="51595">Let’s explain the</st> <st c="51613">important parts of</st> <st
    c="51633">the algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="51647">TreeNode</st>**<st c="51656">: Each node in the BST contains
    a key (the value of the node), and references (</st>**<st c="51736">left</st>**
    <st c="51741">and</st> **<st c="51746">right</st>**<st c="51751">) to its left
    and</st> <st c="51770">right children.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51785">insert</st>**<st c="51792">: The insert function inserts values
    into the BST.</st> <st c="51844">It recursively traverses the tree and inserts
    the new node in the correct position based on the</st> <st c="51940">BST property.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51953">search</st>**<st c="51960">: The search function recursively
    looks for a given key.</st> <st c="52018">If the current node’s key matches the
    key being searched, it returns that node.</st> <st c="52098">Otherwise, it continues
    searching in the left or right subtree based on whether the key is smaller or
    larger than the current</st> <st c="52224">node’s key.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52235">The time complexity of searching in a BST depends on how balanced
    the tree is.</st> <st c="52315">In the worst case, the complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1905.png)<st
    c="52352"><st c="52353">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>L</mml:mi></mml:math>](img/1906.png)
    <st c="52361"><st c="52362">is the depth of the BST.</st> <st c="52388">In an
    extremely unbalanced case, where the BST essentially forms a linear structure,
    the time complexity becomes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1907.png)<st
    c="52501"><st c="52502">. However, in a fully balanced BST, the time complexity
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1908.png)<st
    c="52561"><st c="52569">, ensuring more</st> <st c="52585">efficient searches.</st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52604">The insertion operation in a BST</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="52637">The</st> `<st c="52886">null</st>`<st c="52891">), the new node
    is</st> <st c="52911">inserted there.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="52926">Let’s briefly discuss the complexity of insertion in a BST: Similar
    to searching, the time complexity of insertion in a BST depends on its balance.</st>
    <st c="53075">In the worst case, when the tree is highly unbalanced and resembles
    a linear structure, the time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/1909.png)<st
    c="53186"><st c="53187">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/322.png)
    <st c="53195"><st c="53196">is the</st> <st c="53203">number of nodes.</st> <st
    c="53221">In contrast, in a balanced BST, the time complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/1908.png)<st
    c="53276"><st c="53284">, as the insertion operation involves traversing the</st>
    <st c="53337">tree’s height:</st></st></st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="53351">Average case (balanced tree)</st>**<st c="53380">: In a balanced
    BST, insertion takes</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1912.png)
    <st c="53418"><st c="53427">time on</st> <st c="53434">average, as we are essentially
    performing a search to find the appropriate location to insert the</st> <st c="53533">new
    node</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="53541">Worst case (unbalanced tree)</st>**<st c="53570">: Similar
    to searching, if the BST is unbalanced, insertion time can degrade to</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/49.png)<st
    c="53651"><st c="53668">, particularly if the values being inserted cause the
    tree to</st> <st c="53730">become skewed</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53743">In the Python code provided for the search algorithm, the</st>
    `<st c="53802">insert</st>` <st c="53808">function is responsible for inserting
    nodes into the BST while maintaining the BST property.</st> <st c="53902">It works
    recursively to find the correct position for the</st> <st c="53960">new node.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53969">Let’s see how the</st> `<st c="53988">insert</st>` <st c="53994">function
    works.</st> <st c="54011">If the tree is empty (i.e., the current node is</st>
    `<st c="54059">None</st>`<st c="54063">), the function creates a new node with
    the given key and returns it, effectively making it the root or a leaf.</st> <st
    c="54176">If the key to be inserted is smaller than the current node’s key, the
    function recursively moves to the left subtree to find the appropriate position.</st>
    <st c="54327">If the key to be inserted is larger than the current node’s key,
    it recursively moves to the right subtree.</st> <st c="54435">Once the appropriate
    position is found, the new node is added as either the left or</st> <st c="54519">right
    child.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54531">Here is a simple Python code implementing insertion in</st> <st
    c="54587">a BST:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="54877">For example, if we insert the values</st> `<st c="54915">20</st>`<st
    c="54917">,</st> `<st c="54919">10</st>`<st c="54921">,</st> `<st c="54923">30</st>`<st
    c="54925">,</st> `<st c="54927">5</st>`<st c="54928">,</st> `<st c="54930">15</st>`<st
    c="54932">,</st> `<st c="54934">25</st>`<st c="54936">, and</st> `<st c="54942">35</st>`
    <st c="54944">using this</st> `<st c="54956">insert</st>` <st c="54962">function,
    it will create the BST depicted in</st> *<st c="55008">Figure 13</st>**<st c="55017">.13</st>*<st
    c="55020">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: The final BST representing [20, 10, 30, 5, 15, 25, 35]](img/B22248_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="55023">Figure 13.13: The final BST representing [20, 10, 30, 5, 15,
    25, 35]</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55091">The</st> <st c="55096">insertion of the value</st> `<st c="55119">35</st>`
    <st c="55121">is highlighted in the tree.</st> <st c="55150">When inserting</st>
    `<st c="55165">35</st>`<st c="55167">, first, it is compared with the root node,</st>
    `<st c="55211">20</st>`<st c="55213">. Since</st> `<st c="55221">35</st>` <st
    c="55223">is greater than</st> `<st c="55240">20</st>`<st c="55242">, we move
    to the right subtree.</st> <st c="55274">Next,</st> `<st c="55280">35</st>` <st
    c="55282">is compared with the node</st> `<st c="55309">30</st>`<st c="55311">.
    Since</st> `<st c="55319">35</st>` <st c="55321">is greater than</st> `<st c="55338">30</st>`<st
    c="55340">, it will be inserted as the right child of node</st> `<st c="55389">30</st>`<st
    c="55391">. The key comparison process ensures that</st> `<st c="55433">35</st>`
    <st c="55435">is placed correctly in the BST according to the BST property, where
    values in the right subtree are greater than the</st> <st c="55553">parent node.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55565">As a summary, the</st> `<st c="55584">insert</st>` <st c="55590">function
    ensures that each new value is placed in the correct position in the tree by comparing
    it to the existing node values.</st> <st c="55719">It maintains in the BST property
    that all values in the left subtree are smaller than the parent node, and all
    values in the right subtree</st> <st c="55858">are larger.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55869">The deletion operation in a BST</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="55901">In a BST, the</st> <st c="55916">deletion operation is more complex
    than the insertion operation because we need to maintain the BST property after
    removing a node.</st> <st c="56048">There are three possible cases to consider
    when deleting</st> <st c="56105">a node:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="56112">Deleting a leaf node</st>**<st c="56133">: A node with no children
    can be</st> <st c="56167">directly removed.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="56184">Deleting a node with one child</st>**<st c="56215">: The node
    is replaced by</st> <st c="56242">its child.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="56252">Deleting a node with two children</st>**<st c="56286">: The
    node is replaced by either its in-order predecessor (the largest node in the left
    subtree) or its in-order successor (the smallest node in the right subtree).</st>
    <st c="56452">After replacement, the node from which the replacement came must
    also</st> <st c="56522">be removed.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56533">The</st> <st c="56537">following is the Python code that implements
    the deletion operation in a BST.</st> <st c="56616">First, we must define the</st>
    `<st c="56642">TreeNode</st>` <st c="56650">class (refer to previous examples).</st>
    <st c="56687">Next, we need to construct the tree using the</st> `<st c="56733">insert</st>`
    <st c="56739">function that was discussed earlier.</st> <st c="56777">Next, we
    implement the</st> `<st c="56800">min_value_node</st>` <st c="56814">function
    to find the successor when a node</st> <st c="56858">is deleted:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="57064">Lastly, we have</st> `<st c="57081">delete_node</st>` <st c="57092">to
    implement the three cases of the deletion operation</st> <st c="57148">in BSTs:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="58081">The</st> <st c="58086">following is an example of constructing
    a BST using the</st> `<st c="58142">insert</st>` <st c="58148">function and then
    deleting the node with the</st> <st c="58194">value</st> `<st c="58200">30</st>`<st
    c="58202">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="58691">Let’s explain</st> <st c="58705">the example.</st> <st c="58719">We
    first compare</st> *<st c="58736">node 30</st>* <st c="58743">with the root</st>
    *<st c="58758">node 20</st>*<st c="58765">. Since 30 is greater than 20, we move
    to the right subtree.</st> <st c="58826">We find</st> *<st c="58834">node 30</st>*
    <st c="58841">and notice that it has two children (</st>*<st c="58879">nodes 25</st>*
    <st c="58888">and</st> *<st c="58893">35</st>*<st c="58895">).</st> <st c="58899">We
    replace</st> *<st c="58910">node 30</st>* <st c="58917">with its in-order successor,</st>
    *<st c="58947">node 35</st>*<st c="58954">, and then remove</st> *<st c="58972">node
    35</st>* <st c="58979">from its original position.</st> *<st c="59008">Figure
    13</st>**<st c="59017">.14</st>* <st c="59020">demonstrates the BST after removing</st>
    *<st c="59057">node 35</st>*<st c="59064">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14: The BST in Figure 13.9 after removing 35](img/B22248_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="59067">Figure 13.14: The BST in Figure 13.9 after removing 35</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59121">The time complexity of deletion in BSTs is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1914.png)
    <st c="59165"><st c="59174">on average, which occurs when the tree is balanced
    since we only need to traverse the tree’s height to locate and delete the node.</st>
    <st c="59305">However, in the worst case, the time complexity is</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)<st
    c="59356"><st c="59357">, particularly when the tree is unbalanced and takes the
    form of a</st> <st c="59424">linked list.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59436">In the next section, we will explore heap structures, which play
    a crucial role in sorting algorithms and other applications requiring efficient</st>
    <st c="59582">data management.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59598">Heaps</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="59604">A</st> **<st c="59607">heap</st>** <st c="59611">is a</st> <st
    c="59616">special type of binary tree that satisfies the heap property.</st> <st
    c="59679">In a heap, the parent node always follows a specific order relation
    with respect to its children.</st> <st c="59777">Heaps are commonly used in various
    algorithms, especially in sorting and priority queues, due to their e</st><st
    c="59881">fficient access to the minimum or</st> <st c="59916">maximum element.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59932">There are two main types of heaps, based on the order property</st>
    <st c="59996">they follow:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="60008">Max-heap</st>**<st c="60017">: In a</st> <st c="60025">max-heap,
    each node’s value is greater than or equal to the values of its children, with
    the largest element positioned at the root.</st> <st c="60158">Max-heaps are commonly
    used in algorithms that need efficient access to the maximum element, such as
    heapsort and priority queue implementations.</st> <st c="60304">In max-heap, the
    heap property is as</st> <st c="60341">follows:</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi
    mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mo>.</mo></mrow></mrow></math>](img/1916.png) <st
    c="60350">*   ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>A</mi><mfenced
    open="[" close="]"><mi>i</mi></mfenced><mo>≥</mo><mi>A</mi><mfenced open="[" close="]"><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mfenced></mrow></mrow></math>](img/1917.png)<st
    c="60370"><st c="60390">(</st><st c="60391">left child)</st></st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≥</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1918.png)
    <st c="60402"><st c="60419">(right child), where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi></mml:math>](img/1033.png)
    <st c="60440"><st c="60441">is the array representation of</st> <st c="60473">the
    heap</st></st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="60481">Min-heap</st>**<st c="60490">: In a min-heap, the</st> <st
    c="60512">value of each node is less than or equal to the values of its children.</st>
    <st c="60584">The smallest element is always at the root.</st> <st c="60628">Min-heaps
    are commonly used in algorithms such as Dijkstra’s shortest path and Prim’s minimum
    spanning tree.</st> <st c="60737">In this case, the heap property is as follows:
    For each node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="60798"><st c="60799">, this is</st> <st c="60809">the case:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1921.png)
    <st c="60818"><st c="60839">(</st><st c="60840">left child)</st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≤</mml:mo><mml:mi>A</mml:mi><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1922.png)
    <st c="60851"><st c="60869">(</st><st c="60870">right child)</st></st></st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60882">Heaps are typically represented as complete binary trees stored
    in an array.</st> <st c="60960">In a complete binary tree, this is</st> <st c="60995">the
    case:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61004">The root node is at</st> <st c="61025">index 0</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61032">For a node at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)<st
    c="61053"><st c="61054">, the left child is at index</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></math>](img/1899.png)<st
    c="61083"><st c="61084">, and the right child is at</st> <st c="61112">index</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow></mrow></math>](img/1900.png)</st></st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61119">The parent of a node at index</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="61149"><st c="61150">is located</st> <st c="61162">at</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mtext>floor</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1927.png)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61182">This array representation allows heaps to be efficiently stored
    in memory without using pointers for the child nodes (see</st> *<st c="61304">Figure
    13</st>**<st c="61313">.15</st>*<st c="61316">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15: An example max-heap](img/B22248_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="61321">Figure 13.15: An example max-heap</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="61354">Index</st>** | <st c="61360">1</st> | <st c="61362">2</st>
    | <st c="61363">3</st> | <st c="61364">4</st> | <st c="61365">5</st> | <st c="61366">6</st>
    | <st c="61367">7</st> | <st c="61368">8</st> | <st c="61369">9</st> | <st c="61370">10</st>
    | <st c="61372">11</st> | <st c="61375">12</st> | <st c="61378">13</st> |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="61381">node</st>** | <st c="61386">98</st> | <st c="61389">81</st>
    | <st c="61392">86</st> | <st c="61395">63</st> | <st c="61398">21</st> | <st
    c="61401">68</st> | <st c="61404">18</st> | <st c="61407">10</st> | <st c="61410">51</st>
    | <st c="61413">4</st> | <st c="61415">14</st> | <st c="61417">1</st> | <st c="61419">50</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '<st c="61421">Figure 13.16: The array representation of the max-heap in Figure
    13.15</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61492">Now that we have</st> <st c="61509">learned about the heap property
    and heap representation, let’s explore the operation</st> <st c="61595">on heaps.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61604">Heap operations</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="61620">The</st> <st c="61625">primary operations on heaps are</st> *<st
    c="61657">insertion</st>*<st c="61666">,</st> *<st c="61668">deletion</st>*<st
    c="61676">, and</st> *<st c="61682">heapify</st>* <st c="61689">(used for maintaining
    the heap property).</st> <st c="61732">Each of these operations relies on the
    heap property to ensure that the structure remains a</st> <st c="61824">valid
    heap.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61835">Insertion in a heap</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="61855">To insert an element</st> <st c="61876">into a heap, we first
    add the element at the last position in the array (the end of the heap).</st>
    <st c="61972">Then, we perform a</st> `<st c="61991">heapify-up</st>` <st c="62001">operation,
    which involves comparing the inserted element with its parent.</st> <st c="62076">If
    the heap property is violated, we swap the two.</st> <st c="62127">This process
    is repeated until the heap property</st> <st c="62176">is restored.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62188">Here is the Python code for insertion in</st> <st c="62230">a
    max-heap:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <st c="62582">The</st> <st c="62586">following is an example of building</st>
    <st c="62623">a max-heap:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="62827">The time complexity for insertion is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1928.png)<st
    c="62865"><st c="62874">, as we may need to swap elements up the tree to restore
    the</st> <st c="62935">heap property.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62949">Deletion in a heap</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="62968">In a heap, deletion</st> <st c="62988">typically involves removing
    the root element (the maximum in a max-heap or the minimum in a min-heap).</st>
    <st c="63092">The deletion process is performed in</st> <st c="63129">three steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63141">Replace the root element with the last element in</st> <st c="63192">the
    array.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="63202">Remove the last element from</st> <st c="63232">the array.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="63242">The process of heapifying down the root element involves comparing
    it with its children.</st> <st c="63332">In cases where the heap property is violated,
    a swap occurs between the root and the largest child for a max-heap or the smallest
    child for a min-heap.</st> <st c="63484">This continues until the heap property</st>
    <st c="63523">is restored.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="63535">Here is a</st> <st c="63545">simple Python code for deletion in</st>
    <st c="63581">a max-heap:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="64145">Let’s have an</st> <st c="64160">example max-heap and delete the
    root</st> <st c="64197">using</st> `<st c="64203">delete_max_heap</st>`<st c="64218">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="64330">The heap after the deletion of a max element is</st> `<st c="64379">[30,
    15,</st>` `<st c="64388">20, 5]</st>`<st c="64394">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64395">The time complexity for deletion is</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1929.png)<st
    c="64432"><st c="64441">, as we may need to swap elements down the tree to restore
    the</st> <st c="64504">heap property.</st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64518">Heapify (building a heap)</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="64544">To build a</st> <st c="64556">heap from an arbitrary array, we
    use the heapify process.</st> <st c="64614">Starting from the first non-leaf node,
    we move up to the root, ensuring the heap property is maintained.</st> <st c="64719">Consider
    the following Python implementation</st> <st c="64764">of</st> `<st c="64767">heapify</st>`<st
    c="64774">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <st c="65060">As we</st> <st c="65066">can see, the</st> `<st c="65080">heapify</st>`
    <st c="65087">function recursively calls itself to ensure that the heap property
    is maintained throughout the tree.</st> <st c="65190">If a violation of the heap
    property is detected at any node,</st> `<st c="65251">heapify</st>` <st c="65258">continues
    down the tree, correcting the structure by comparing and swapping nodes as needed,
    until the property is</st> <st c="65374">fully restored.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65389">The following is a Python code to build a max-heap using the</st>
    `<st c="65451">heapify</st>` <st c="65458">recursive algorithm:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <st c="65625">The following is a simple example of a</st> `<st c="65665">build_max_heap</st>`
    <st c="65679">usage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <st c="65773">The</st> `<st c="65778">a</st>` <st c="65779">array representing
    the max-heap after building the max-heap is</st> `<st c="65843">[40, 30, 20,</st>`
    `<st c="65856">5, 15]</st>`<st c="65862">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65863">The time complexity for building a heap is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1930.png)
    <st c="65907"><st c="65908">since each node requires at most</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1931.png)
    <st c="65942"><st c="65951">swaps, but most nodes are near the bottom of the tree
    and need</st> <st c="66014">fewer swaps.</st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="66026">Let’s explore a major application of heap</st> <st c="66069">structures:
    heapsort.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66090">Heapsort</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**<st c="66099">Heapsort</st>** <st c="66108">is an</st> <st c="66115">efficient
    comparison-based sorting algorithm that leverages the heap data structure, particularly
    the max-heap, to sort elements in</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1010.png)
    <st c="66247"><st c="66258">time.</st> <st c="66264">It works by first converting
    the input array into a max-heap and then repeatedly extracting the largest element
    (the root of the heap) to build the sorted output.</st> <st c="66427">This process
    ensures that the elements are sorted in ascending order.</st> <st c="66497">The
    following outlines</st> <st c="66520">the steps involved in</st> <st c="66542">performing
    heapsort:</st></st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66562">Build a max-heap from the</st> <st c="66589">input array.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="66601">Swap the root (maximum element) with the</st> <st c="66643">last
    element.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="66656">Reduce the heap size by one and</st> **<st c="66689">heapify</st>**
    <st c="66696">the</st> <st c="66701">root element.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="66714">Repeat the process until the heap</st> <st c="66749">is empty.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="66758">Here is the Python implementation</st> <st c="66793">of heapsort:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <st c="67038">Let’s examine the heapsort algorithm in</st> <st c="67079">an
    example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <st c="67156">The output will be</st> <st c="67176">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <st c="67221">The time</st> <st c="67230">complexity of heapsort is</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1084.png)<st
    c="67257"><st c="67268">, as building the heap takes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="67297"><st c="67298">, and each extraction of the maximum (in a max-heap) or
    minimum (in a min-heap) requires</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1047.png)
    <st c="67387"><st c="67396">over</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1271.png)
    <st c="67401"><st c="67402">elements.</st> <st c="67413">As discussed and demonstrated
    in</st> [*<st c="67446">Chapter 6</st>*](B22248_06.xhtml#_idTextAnchor081)<st
    c="67455">, the time complexity of heapsort cannot be better than</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1937.png)
    <st c="67511"><st c="67522">because it is a comparison-based sorting algorithm,
    which imposes a lower bound on the time complexity for such algorithms.</st> <st
    c="67646">Heapsort is an in-place sorting algorithm and its space complexity</st>
    <st c="67713">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="67716"><st c="67717">.</st></st></st></st></st></st></st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67718">With the heap structure, we conclude our discussion on non-linear
    data structures.</st> <st c="67802">This chapter has provided key highlights of
    this important class of data structures, but it is not meant to serve as a comprehensive
    replacement for a dedicated book on data structures.</st> <st c="67988">It offers
    an overview, emphasizing their role in algorithm design, while more detailed exploration
    can be found in</st> <st c="68103">specialized texts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68121">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="68129">In this chapter, we explored the key concepts and applications
    of non-linear data structures, which are essential for designing efficient algorithms.</st>
    <st c="68280">We began by discussing the general properties of non-linear structures,
    highlighting how they differ from linear data structures in terms of organization
    and access patterns.</st> <st c="68455">Two major categories were covered in detail:
    graphs and trees.</st> <st c="68518">Graphs were presented as versatile structures
    for modeling relationships, while trees provided a more hierarchical organization
    of data.</st> <st c="68655">We examined different types of trees, such as BSTs,
    discussing their properties, operations, and use cases in</st> <st c="68765">algorithm
    design.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68782">The chapter concluded by focusing on heaps, a special form of
    binary tree that is commonly used in priority queues and sorting algorithms such
    as heapsort.</st> <st c="68939">We covered how heaps are constructed, how the
    heap property is maintained through insertion, deletion, and heapify operations,
    and the role heaps play in sorting.</st> <st c="69102">Overall, this chapter provided
    a foundational understanding of non-linear data structures and emphasized their
    significance in the efficient processing and manipulation of complex data relationships.</st>
    <st c="69302">By the end of this chapter, our discussion of algorithms comes to
    a close.</st> <st c="69377">However, in the next chapter, we will explore emerging
    trends and future directions in</st> <st c="69464">algorithm development.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69486">References and further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*<st c="69517">Introduction to Algorithms</st>*<st c="69544">. By Thomas H.</st>
    <st c="69559">Cormen, Charles E.</st> <st c="69578">Leiserson, Ronald L.</st>
    <st c="69599">Rivest, and Clifford Stein.</st> <st c="69627">Fourth Edition.</st>
    <st c="69643">MIT</st> <st c="69647">Press.</st> <st c="69654">2022:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69659">Chapter</st>* *<st c="69668">6</st>*<st c="69669">,</st> *<st
    c="69671">Heapsort</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69679">Chapter 12</st>*<st c="69690">,</st> *<st c="69692">Binary</st>*
    *<st c="69699">Search Trees</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69711">Chapter 22</st>*<st c="69722">,</st> *<st c="69724">Elementary</st>*
    *<st c="69735">Graph Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69751">Data Structures and Algorithm Analysis in C++.</st>* <st c="69798">By
    Mark A.</st> <st c="69810">Weiss.</st> <st c="69817">Fourth Edition.</st> <st
    c="69833">Pearson.</st> <st c="69842">2012:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69847">Chapter</st>* *<st c="69856">4</st>*<st c="69857">,</st> *<st
    c="69859">Trees</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69864">Chapter 5</st>*<st c="69874">,</st> *<st c="69876">Binary</st>*
    *<st c="69883">Search Trees</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69895">Chapter</st>* *<st c="69904">6</st>*<st c="69905">,</st> *<st
    c="69907">Heaps</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69912">Chapter 9</st>*<st c="69922">,</st> *<st c="69924">Graph Algorithms</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="69940">Algorithms</st>*<st c="69951">. By R.</st> <st c="69959">Sedgewick,
    K.</st> <st c="69973">Wayne.</st> <st c="69980">Fourth Edition.</st> <st c="69996">Addison-Wesley.</st>
    <st c="70012">2011.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="70017">Chapter 3</st>*<st c="70027">,</st> *<st c="70029">Searching
    (Binary</st>* *<st c="70047">Search Trees)</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="70060">Chapter 4</st>*<st c="70070">,</st> *<st c="70072">Sorting (Heapsort)</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="70090">Chapter</st>* *<st c="70099">5</st>*<st c="70100">,</st> *<st
    c="70102">Graphs</st>*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
