<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer124">
<h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor070"/>6</h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Graph Theory</h1>
<p>Graphs are mathematical structures that are used to model pairwise relationships. Graph theory provides a tool to quantify these relationships in a dynamic system. In other words, graphs are ways to represent a network or a collection of interconnected objects. Graph theory is mostly applied in operations research and social sciences. Its history dates back to the 18th century when the Swiss mathematician Leonhard Euler solved the Königsberg bridge problem (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em>), which served as a precursor to graph theory. The city of Königsberg in Russia was set on both sides of the Pregel river and included two large islands, namely, Kneiphof and Lomse, which were connected by seven bridges. The problem was to devise a walk through the city that would cross each of these bridges only once. Euler drew out the first known visual representation of a modern graph for the city. It is represented (abstractly) by a set of points known as vertices or nodes, connected by a set of lines known as edges. Edges represent the relationships <span class="No-Break">between nodes.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<img alt="Figure 6.1: Seven bridges of Königsberg" height="254" src="image/Figure_06_01_B18943.jpg" width="1043"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Seven bridges of Königsberg</p>
<p>A graph theory problem typically uses the framework of mathematical optimization, which has three components, namely, the objective function, decision variables, and constraints. The objective function is minimized to obtain the optimal path between nodes in a graph because there can be multiple paths connecting two nodes (multigraphs). The objective of using a graph to solve a problem is multifold. One could be to visualize the edges, figure out closely connected nodes, and identify the nodes that directly influence the objective function. A possible decision variable among others could be whether or not to add an edge between two nodes. A typical constraint could be the degree each node can attain, that is, the maximum number of connections each node can <a id="_idIndexMarker179"/>have to other nodes in the network. A well-known problem solved using graph theory is the <strong class="bold">traveling salesman problem</strong> (<strong class="bold">TSP</strong>), in which the shortest path starts and ends at the same vertex/node and visits each edge exactly once. Such examples (routing) are related to the field of <span class="No-Break">linear programming.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<img alt="Figure 6.2a: Simple graph (L) and multigraph (R)" height="172" src="image/Figure_06_02_B18943.jpg" width="421"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2a: Simple graph (L) and multigraph (R)</p>
<p>Graphs come in a variety of sorts, the most common of which are simple graphs and multigraphs. These are shown in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2a</em> and there is also a graph or directed graph (edges have directions) together with a function that assigns a positive real number to each edge, known as a network. A network is <a id="_idIndexMarker180"/>in fact an oriented edge-labeled graph, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.2b</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<img alt="Figure 6.2b: Graph as network (model)" height="165" src="image/Figure_06_03_B18943.jpg" width="165"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2b: Graph as network (model)</p>
<p>There is a restricted type of graph <a id="_idIndexMarker181"/>known as trees. Tree data structures are different from graph data structures (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.3</em>). A tree, which is a hierarchical model, can <a id="_idIndexMarker182"/>never have cyclical links (edges) like some graphs have. Trees are <strong class="bold">directed acyclic graphs</strong> (<strong class="bold">DAGs</strong>) and are unidirectional. A graph has no root (source) node, whereas a tree does have this node, along with child nodes, and every child has one <span class="No-Break">parent node.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<img alt="Figure 6.3: Tree (L) with n-1 edges (n = number of nodes) and graph (R) with no rule about the number of edges it can have" height="217" src="image/Figure_06_04_B18943.jpg" width="505"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Tree (L) with n-1 edges (n = number of nodes) and graph (R) with no rule about the number of edges it can have</p>
<p>Graphs can also have loops, circuits, and self-loops. There are databases that use graph structures for semantic queries with nodes and edges. Querying relationships (edges labeled, directed) is fast in general, as they are perpetually stored in the database. Graph databases are <a id="_idIndexMarker183"/>commonly called NoSQL. Graphs are utilized in analyzing social networks <span class="No-Break">as well.</span></p>
<p>This chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Types <span class="No-Break">of graphs</span></li>
<li>Optimization <span class="No-Break">use case</span></li>
<li>Graph <span class="No-Break">neural networks</span></li>
</ul>
<p>The next section discusses the types of graphs depending on labels, directions, and the weights of edges in <span class="No-Break">the graphs.</span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Types of graphs</h1>
<p>The primary graph types are <a id="_idIndexMarker184"/>undirected, directed, and weighted graphs, as illustrated in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.4</em>. Social networks can be undirected as well as directed graphs. In the former, edges end up being unordered pairs, for example, Facebook. In the latter, edges are ordered pairs, for example, Twitter, in which one node is an origin and the other <span class="No-Break">a destination.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<img alt="Figure 6.4: Three standard graph types" height="360" src="image/Figure_06_05_B18943.jpg" width="781"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Three standard graph types</p>
<p>We will explore <a id="_idIndexMarker185"/>each of these graphs in the <span class="No-Break">following subsections.</span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Undirected graphs</h2>
<p>While solving a problem using graph theory, the first step is to determine the type of graph we <a id="_idIndexMarker186"/>are dealing with. In undirected graphs, there is no particular <a id="_idIndexMarker187"/>direction of the edges between nodes, in other words, the edge is bidirectional. An edge connecting node 1 to node 2 (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.5</em>) would be identical to the edge connecting node 2 to <span class="No-Break">node 1.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<img alt="Figure 6.5: Directed and undirected graphs" height="646" src="image/Figure_06_06_B18943.jpg" width="874"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Directed and undirected graphs</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Directed graphs</h2>
<p>In directed <a id="_idIndexMarker188"/>graphs, or digraphs, there is a specified direction <a id="_idIndexMarker189"/>between the nodes. The edge between nodes 1 and 2 is directed from 1 toward 2 (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.5</em>) and a link directed toward 1 from 2 would not be permitted. In other words, the edges between nodes <span class="No-Break">are unidirectional.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Weighted graphs</h2>
<p>If the edge between two nodes or vertices has an associated weight to represent implications <a id="_idIndexMarker190"/>such as distance or cost, the corresponding graph <a id="_idIndexMarker191"/>is said to be weighted. Weighted graphs can be either directed or undirected (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.6</em>). Weighted graphs are applicable to many real-world scenarios, for example, search engines comparing flight times and cost or <span class="No-Break">route planning.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<img alt="Figure 6.6: Undirected weighted graph (L) and directed weighted graph (R)" height="464" src="image/Figure_06_07_B18943.jpg" width="1001"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: Undirected weighted graph (L) and directed weighted graph (R)</p>
<p>Any graph can be represented mathematically through an adjacency matrix, which describes all permitted routes or paths between nodes in the graph. An adjacency matrix for a directed graph is shown in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.7a</em>, and that of an undirected graph is illustrated in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.7b</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 6.7a: Adjacency matrix of a directed graph" height="307" src="image/Figure_06_08_B18943.jpg" width="643"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7a: Adjacency matrix of a directed graph</p>
<p>We know by now that graphs make networks more interpretable and easier to visualize. More computer memory is consumed by an adjacency matrix for a bigger graph (more nodes) like the one of the weighted graph shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.7c</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 6.7b: Adjacency matrix of an undirected graph" height="465" src="image/Figure_06_09_B18943.jpg" width="1091"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7b: Adjacency matrix of an undirected graph</p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 6.7c: Adjacency matrix of a weighted (directed) graph" height="388" src="image/Figure_06_10_B18943.jpg" width="834"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7c: Adjacency matrix of a weighted (directed) graph</p>
<p>Most adjacency <a id="_idIndexMarker192"/>matrices are sparse; that is, the graphs are <a id="_idIndexMarker193"/>not densely connected, making <span class="No-Break">computations harder.</span></p>
<p>Now that we have explored the different graphs, we will investigate a use case of an optimization problem solved using <span class="No-Break">graph theory.</span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Optimization use case</h1>
<p>Graphs can be <a id="_idIndexMarker194"/>used to model relations and processes in physical, biological, and information systems. They have a wide range of applications, such as ranking hyperlinks in search engines, the study of biomolecules, computer network security, GPS in maps to find the shortest route, and social network analysis. There are knowledge graphs for information mining as well. In the following subsection, we pick a dataset and formulate the problem in a way that is solved using <span class="No-Break">graph theory.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Optimization problem</h2>
<p>There can be multiple paths between origin and destination airports. An airline seeks the shortest <a id="_idIndexMarker195"/>possible path between airports, wherein the shortest path can be defined in terms of either distance or airtime. If the city airports are represented as nodes and the flight routes between them as edges, we convert the problem into a graph (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.8a</em>). The dataset can be found in the GitHub <span class="No-Break">repository: </span><a href="http://ebay.co.uk"><span class="No-Break">https://github.com/ranja-sarkar/graphs</span></a><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 6.8a: Network (flight routes) between origin (city) airport and destination (city) airport" height="622" src="image/Figure_06_11_B18943.jpg" width="939"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8a: Network (flight routes) between origin (city) airport and destination (city) airport</p>
<p>We can identify the shortest (minimum airtime or minimum distance) possible path between any two city airports from the graph. Example code in Python to arrive at the solution is explained in the <span class="No-Break">following subsection.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Optimized solution</h2>
<p>The dataset, a sample <a id="_idIndexMarker196"/>of which is displayed in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.8b</em>, has records of flights in January 2017 from the USA out of the origin (source) city, which is given by <strong class="source-inline">Origin</strong>, to the destination city, which is given by <strong class="source-inline">Dest</strong>. The distance between the origin and destination and the airtime of the flight are the most relevant variables required to find the <span class="No-Break">optimized solution.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<img alt="Figure 6.8b: Dataset for the case study" height="280" src="image/Figure_06_12_B18943.jpg" width="1548"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8b: Dataset for the case study</p>
<p>You can have <a id="_idIndexMarker197"/>a look at the nodes and edges of the corresponding graph resulting from executing the code. The graph (network) of flights is shown in <span class="No-Break">Figure 6</span><span class="No-Break">.8a:</span></p>
<pre class="source-code">
import pandas as pd, numpy as np
import networkx as nx
import matplotlib.pyplot as plt
#dataset
data = pd.read_csv('FlightsUSA.csv')
df = nx.from_pandas_edgelist(data, source = 'Origin', target = 'Dest', edge_attr = True)
#df.nodes()
#df.edges()
plt.figure(figsize = (18,12))
nx.draw_networkx(df, with_labels = True)</pre>
<p>A passenger wishing to take the shortest route from <strong class="source-inline">LAS</strong> (Las Vegas) to <strong class="source-inline">PBI</strong> (Palm Beach in Florida) with respect to the distance and airtime metrics can run the piece of code (consuming Dijkstra’s shortest-path algorithm contained in the NetworkX Python library) and self-serve or decide on the <span class="No-Break">best route:</span></p>
<pre class="source-code">
shortest_airtime = nx.dijkstra_path(df, source = 'LAS', target = 'PBI', weight = 'AirTime')
shortest_dist = nx.dijkstra_path(df, source = 'LAS', target = 'PBI', weight = 'Distance')
print(shortest_dist,shortest_airtime)</pre>
<p>The shortest path between <strong class="source-inline">LAS</strong> and <strong class="source-inline">PBI</strong> based on distance is shown in the output in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.9a</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<img alt="Figure 6.9a: Output when the model parameter is distance" height="43" src="image/Figure_06_13_B18943.jpg" width="240"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9a: Output when the model parameter is distance</p>
<p>The shortest path based on airtime is shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.9b</em></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 6.9b: Output when the model parameter is airtime" height="40" src="image/Figure_06_14_B18943.jpg" width="243"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9b: Output when the model parameter is airtime</p>
<p>The algorithm <a id="_idIndexMarker198"/>creates the shortest path set first by picking the vertex closest to the source vertex, then a vertex from the remaining ones closest to the source. This continues until the set includes all vertices/nodes. Graph theory can therefore be applied to travel planning and finding the best route to deliver post, among other usages. The mathematical formulation of graphs is intuitive <a id="_idIndexMarker199"/>and comprehensive. In the next section, we will <a id="_idIndexMarker200"/>introduce <strong class="bold">graph neural networks</strong> (<strong class="bold">GNNs</strong>), which will involve diving into <strong class="bold">deep </strong><span class="No-Break"><strong class="bold">learning</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DL</strong></span><span class="No-Break">).</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Graph neural networks</h1>
<p>DL algorithms make use of graphs to predict at the level of nodes, edges, or entire graphs. In node <a id="_idIndexMarker201"/>classification, the label of samples (nodes) is determined by looking at the labels of neighbors. In graph classification, the entire graph is classified into different categories, an example being categorizing documents using natural language processing. The relationships (edges) between nodes or entities are utilized in recommendation systems. Image and text are types of structured data that can be described as grids of pixels and sequences of words, respectively. These are shown in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.10a</em>. Graphs, in contrast, are unstructured data. Graphs can contain any kind of data, including images <span class="No-Break">and text.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer121">
<img alt="" height="320" src="image/Figure_06_15_B18943.jpg" width="888"/>
</div>
</div>
<p class="IMG---Figure"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10a: Structured data (L) as opposed to graphs/networks (R)</p>
<p>GNNs organize <a id="_idIndexMarker202"/>graphs using a process called message passing so that DL algorithms can use the embedded information about the neighbors of each node to find patterns and make predictions. Typically, the input to a GNN pipeline (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.10b</em>) is a defined graph structure with its type <span class="No-Break">and scale.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<img alt="Figure 6.10b: GNN has a graph as an input" height="469" src="image/Figure_06_16_B18943.jpg" width="1103"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10b: GNN has a graph as an input</p>
<p>In graph theory, the concept of node embedding is implemented, meaning mapping nodes to a lower dimensional (than the actual dimension) space so that similar nodes in the graph are close to each other. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.11</em> illustrates how information from the input graph will propagate to the outside of the neural networks (gray boxes). Therefore, the aggregation of information takes multiple (three here) layers. A model can be trained by supervised and unsupervised means. In the latter, only the graph structure is used and similar nodes have similar embeddings. The former is used for a supervised task such as <span class="No-Break">node classification.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<img alt="Figure 6.11: Propagation of information" height="376" src="image/Figure_06_17_B18943.jpg" width="811"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: Propagation of information</p>
<p>GNN architectures <a id="_idIndexMarker203"/>are used in image and text classification problems. They are also used in relation (semantic) extraction. They have become powerful tools in recent years for any problem that can be modeled <span class="No-Break">by graphs.</span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>
<p>In this chapter, we learned about a theory that is helpful in simplifying and quantifying complex connected systems called networks. Graph theory is the study of relationships (represented as edges in graphs) between dynamic entities and helps better interpret network models. We further elaborated (with Python code) on how an optimization problem can be mathematically formulated and solved using this concept. A lot of problems can be approached using a graph framework that involves the components of mathematical optimization, as discussed in a section of <span class="No-Break">this chapter.</span></p>
<p>This chapter also introduced GNNs, which operate on the structure and property of a graph. A single property is predicted for an entire graph for a graph-level task, a property of each node is predicted for a node-level task, and the property of each existing edge in a graph is predicted abstractly an edge-level task. GNNs are applied when graphs are complex <span class="No-Break">and deep.</span></p>
<p>In the next chapter, we will study the Kalman filter, which is one of the most efficient estimation algorithms. It provides a recursive computation method to estimate the (unknown) state of a discrete data-controlled process by using a series of measurements that are typically noisy, as well as calculating the uncertainty in measurement. Kalman filtering is a concept applied to topics such as signal processing, wherein the variables of interest which cannot be directly measured are <span class="No-Break">indirectly measured.</span></p>
</div>
</div></body></html>