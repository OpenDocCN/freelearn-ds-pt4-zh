- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are mathematical structures that are used to model pairwise relationships.
    Graph theory provides a tool to quantify these relationships in a dynamic system.
    In other words, graphs are ways to represent a network or a collection of interconnected
    objects. Graph theory is mostly applied in operations research and social sciences.
    Its history dates back to the 18th century when the Swiss mathematician Leonhard
    Euler solved the Königsberg bridge problem (*Figure 6**.1*), which served as a
    precursor to graph theory. The city of Königsberg in Russia was set on both sides
    of the Pregel river and included two large islands, namely, Kneiphof and Lomse,
    which were connected by seven bridges. The problem was to devise a walk through
    the city that would cross each of these bridges only once. Euler drew out the
    first known visual representation of a modern graph for the city. It is represented
    (abstractly) by a set of points known as vertices or nodes, connected by a set
    of lines known as edges. Edges represent the relationships between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Seven bridges of Königsberg](img/Figure_06_01_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Seven bridges of Königsberg'
  prefs: []
  type: TYPE_NORMAL
- en: A graph theory problem typically uses the framework of mathematical optimization,
    which has three components, namely, the objective function, decision variables,
    and constraints. The objective function is minimized to obtain the optimal path
    between nodes in a graph because there can be multiple paths connecting two nodes
    (multigraphs). The objective of using a graph to solve a problem is multifold.
    One could be to visualize the edges, figure out closely connected nodes, and identify
    the nodes that directly influence the objective function. A possible decision
    variable among others could be whether or not to add an edge between two nodes.
    A typical constraint could be the degree each node can attain, that is, the maximum
    number of connections each node can have to other nodes in the network. A well-known
    problem solved using graph theory is the **traveling salesman problem** (**TSP**),
    in which the shortest path starts and ends at the same vertex/node and visits
    each edge exactly once. Such examples (routing) are related to the field of linear
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2a: Simple graph (L) and multigraph (R)](img/Figure_06_02_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2a: Simple graph (L) and multigraph (R)'
  prefs: []
  type: TYPE_NORMAL
- en: Graphs come in a variety of sorts, the most common of which are simple graphs
    and multigraphs. These are shown in *Figure 6**.2a* and there is also a graph
    or directed graph (edges have directions) together with a function that assigns
    a positive real number to each edge, known as a network. A network is in fact
    an oriented edge-labeled graph, as shown in *Figure 6**.2b*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2b: Graph as network (model)](img/Figure_06_03_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2b: Graph as network (model)'
  prefs: []
  type: TYPE_NORMAL
- en: There is a restricted type of graph known as trees. Tree data structures are
    different from graph data structures (*Figure 6**.3*). A tree, which is a hierarchical
    model, can never have cyclical links (edges) like some graphs have. Trees are
    **directed acyclic graphs** (**DAGs**) and are unidirectional. A graph has no
    root (source) node, whereas a tree does have this node, along with child nodes,
    and every child has one parent node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Tree (L) with n-1 edges (n = number of nodes) and graph (R) with
    no rule about the number of edges it can have](img/Figure_06_04_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Tree (L) with n-1 edges (n = number of nodes) and graph (R) with
    no rule about the number of edges it can have'
  prefs: []
  type: TYPE_NORMAL
- en: Graphs can also have loops, circuits, and self-loops. There are databases that
    use graph structures for semantic queries with nodes and edges. Querying relationships
    (edges labeled, directed) is fast in general, as they are perpetually stored in
    the database. Graph databases are commonly called NoSQL. Graphs are utilized in
    analyzing social networks as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph neural networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section discusses the types of graphs depending on labels, directions,
    and the weights of edges in the graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary graph types are undirected, directed, and weighted graphs, as illustrated
    in *Figure 6**.4*. Social networks can be undirected as well as directed graphs.
    In the former, edges end up being unordered pairs, for example, Facebook. In the
    latter, edges are ordered pairs, for example, Twitter, in which one node is an
    origin and the other a destination.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Three standard graph types](img/Figure_06_05_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Three standard graph types'
  prefs: []
  type: TYPE_NORMAL
- en: We will explore each of these graphs in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Undirected graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While solving a problem using graph theory, the first step is to determine the
    type of graph we are dealing with. In undirected graphs, there is no particular
    direction of the edges between nodes, in other words, the edge is bidirectional.
    An edge connecting node 1 to node 2 (*Figure 6**.5*) would be identical to the
    edge connecting node 2 to node 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Directed and undirected graphs](img/Figure_06_06_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Directed and undirected graphs'
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In directed graphs, or digraphs, there is a specified direction between the
    nodes. The edge between nodes 1 and 2 is directed from 1 toward 2 (*Figure 6**.5*)
    and a link directed toward 1 from 2 would not be permitted. In other words, the
    edges between nodes are unidirectional.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the edge between two nodes or vertices has an associated weight to represent
    implications such as distance or cost, the corresponding graph is said to be weighted.
    Weighted graphs can be either directed or undirected (*Figure 6**.6*). Weighted
    graphs are applicable to many real-world scenarios, for example, search engines
    comparing flight times and cost or route planning.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Undirected weighted graph (L) and directed weighted graph (R)](img/Figure_06_07_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Undirected weighted graph (L) and directed weighted graph (R)'
  prefs: []
  type: TYPE_NORMAL
- en: Any graph can be represented mathematically through an adjacency matrix, which
    describes all permitted routes or paths between nodes in the graph. An adjacency
    matrix for a directed graph is shown in *Figure 6**.7a*, and that of an undirected
    graph is illustrated in *Figure 6**.7b*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7a: Adjacency matrix of a directed graph](img/Figure_06_08_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7a: Adjacency matrix of a directed graph'
  prefs: []
  type: TYPE_NORMAL
- en: We know by now that graphs make networks more interpretable and easier to visualize.
    More computer memory is consumed by an adjacency matrix for a bigger graph (more
    nodes) like the one of the weighted graph shown in *Figure 6**.7c*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7b: Adjacency matrix of an undirected graph](img/Figure_06_09_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7b: Adjacency matrix of an undirected graph'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7c: Adjacency matrix of a weighted (directed) graph](img/Figure_06_10_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7c: Adjacency matrix of a weighted (directed) graph'
  prefs: []
  type: TYPE_NORMAL
- en: Most adjacency matrices are sparse; that is, the graphs are not densely connected,
    making computations harder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the different graphs, we will investigate a use case
    of an optimization problem solved using graph theory.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs can be used to model relations and processes in physical, biological,
    and information systems. They have a wide range of applications, such as ranking
    hyperlinks in search engines, the study of biomolecules, computer network security,
    GPS in maps to find the shortest route, and social network analysis. There are
    knowledge graphs for information mining as well. In the following subsection,
    we pick a dataset and formulate the problem in a way that is solved using graph
    theory.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be multiple paths between origin and destination airports. An airline
    seeks the shortest possible path between airports, wherein the shortest path can
    be defined in terms of either distance or airtime. If the city airports are represented
    as nodes and the flight routes between them as edges, we convert the problem into
    a graph (*Figure 6**.8a*). The dataset can be found in the GitHub repository:
    [https://github.com/ranja-sarkar/graphs](http://ebay.co.uk).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8a: Network (flight routes) between origin (city) airport and destination
    (city) airport](img/Figure_06_11_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8a: Network (flight routes) between origin (city) airport and destination
    (city) airport'
  prefs: []
  type: TYPE_NORMAL
- en: We can identify the shortest (minimum airtime or minimum distance) possible
    path between any two city airports from the graph. Example code in Python to arrive
    at the solution is explained in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Optimized solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dataset, a sample of which is displayed in *Figure 6**.8b*, has records
    of flights in January 2017 from the USA out of the origin (source) city, which
    is given by `Origin`, to the destination city, which is given by `Dest`. The distance
    between the origin and destination and the airtime of the flight are the most
    relevant variables required to find the optimized solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8b: Dataset for the case study](img/Figure_06_12_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8b: Dataset for the case study'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have a look at the nodes and edges of the corresponding graph resulting
    from executing the code. The graph (network) of flights is shown in Figure 6.8a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A passenger wishing to take the shortest route from `LAS` (Las Vegas) to `PBI`
    (Palm Beach in Florida) with respect to the distance and airtime metrics can run
    the piece of code (consuming Dijkstra’s shortest-path algorithm contained in the
    NetworkX Python library) and self-serve or decide on the best route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The shortest path between `LAS` and `PBI` based on distance is shown in the
    output in *Figure 6**.9a*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9a: Output when the model parameter is distance](img/Figure_06_13_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9a: Output when the model parameter is distance'
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path based on airtime is shown in *Figure 6**.9b*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9b: Output when the model parameter is airtime](img/Figure_06_14_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9b: Output when the model parameter is airtime'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm creates the shortest path set first by picking the vertex closest
    to the source vertex, then a vertex from the remaining ones closest to the source.
    This continues until the set includes all vertices/nodes. Graph theory can therefore
    be applied to travel planning and finding the best route to deliver post, among
    other usages. The mathematical formulation of graphs is intuitive and comprehensive.
    In the next section, we will introduce **graph neural networks** (**GNNs**), which
    will involve diving into **deep** **learning** (**DL**).
  prefs: []
  type: TYPE_NORMAL
- en: Graph neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DL algorithms make use of graphs to predict at the level of nodes, edges, or
    entire graphs. In node classification, the label of samples (nodes) is determined
    by looking at the labels of neighbors. In graph classification, the entire graph
    is classified into different categories, an example being categorizing documents
    using natural language processing. The relationships (edges) between nodes or
    entities are utilized in recommendation systems. Image and text are types of structured
    data that can be described as grids of pixels and sequences of words, respectively.
    These are shown in *Figure 6**.10a*. Graphs, in contrast, are unstructured data.
    Graphs can contain any kind of data, including images and text.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_06_15_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10a: Structured data (L) as opposed to graphs/networks (R)'
  prefs: []
  type: TYPE_NORMAL
- en: GNNs organize graphs using a process called message passing so that DL algorithms
    can use the embedded information about the neighbors of each node to find patterns
    and make predictions. Typically, the input to a GNN pipeline (*Figure 6**.10b*)
    is a defined graph structure with its type and scale.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10b: GNN has a graph as an input](img/Figure_06_16_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10b: GNN has a graph as an input'
  prefs: []
  type: TYPE_NORMAL
- en: In graph theory, the concept of node embedding is implemented, meaning mapping
    nodes to a lower dimensional (than the actual dimension) space so that similar
    nodes in the graph are close to each other. *Figure 6**.11* illustrates how information
    from the input graph will propagate to the outside of the neural networks (gray
    boxes). Therefore, the aggregation of information takes multiple (three here)
    layers. A model can be trained by supervised and unsupervised means. In the latter,
    only the graph structure is used and similar nodes have similar embeddings. The
    former is used for a supervised task such as node classification.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Propagation of information](img/Figure_06_17_B18943.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Propagation of information'
  prefs: []
  type: TYPE_NORMAL
- en: GNN architectures are used in image and text classification problems. They are
    also used in relation (semantic) extraction. They have become powerful tools in
    recent years for any problem that can be modeled by graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a theory that is helpful in simplifying and
    quantifying complex connected systems called networks. Graph theory is the study
    of relationships (represented as edges in graphs) between dynamic entities and
    helps better interpret network models. We further elaborated (with Python code)
    on how an optimization problem can be mathematically formulated and solved using
    this concept. A lot of problems can be approached using a graph framework that
    involves the components of mathematical optimization, as discussed in a section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced GNNs, which operate on the structure and property
    of a graph. A single property is predicted for an entire graph for a graph-level
    task, a property of each node is predicted for a node-level task, and the property
    of each existing edge in a graph is predicted abstractly an edge-level task. GNNs
    are applied when graphs are complex and deep.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study the Kalman filter, which is one of the most
    efficient estimation algorithms. It provides a recursive computation method to
    estimate the (unknown) state of a discrete data-controlled process by using a
    series of measurements that are typically noisy, as well as calculating the uncertainty
    in measurement. Kalman filtering is a concept applied to topics such as signal
    processing, wherein the variables of interest which cannot be directly measured
    are indirectly measured.
  prefs: []
  type: TYPE_NORMAL
