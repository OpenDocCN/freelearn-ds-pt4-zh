["```py\nimport numpy as np\nstates = [\"increase\", \"decrease\", \"stable\"] #Markov states\ntransition_probs = np.array([[0.6, 0.3, 0.1], [0.4, 0.4, 0.2], [0.5, 0.3, 0.2]])\nnum_steps = 10                 #time-steps for simulation\ndef MC_states(current_state):\n     future_states = []\nfor i in range(num_steps):\n           probs = transition_probs[states.index(current_state)]\n           new_state = np.random.choice(states, p = probs)\n           future_states.append(new_state)\n           current_state = new_state #Update current state\n     return future_states\n#output\nMC_states(\"increase\")\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nnp.random.seed(42)\ndef gibbs_sampler(mus, sigmas, n_iter = 10000):\n    samples = []\n    y = mus[1]\n    for _ in range(n_iter):\n        x = p_x_y(y, mus, sigmas)\n        y = p_y_x(x, mus, sigmas)\n        samples.append([x, y])\n    return samples\ndef p_x_y(y, mus, sigmas):\n    mu = mus[0] + sigmas[1, 0]/sigmas[0, 0] * (y - mus[1])\n    sigma = sigmas[0, 0]-sigmas[1, 0]/sigmas[1, 1]*sigmas[1, 0]\n    return np.random.normal(mu, sigma)\ndef p_y_x(x, mus, sigmas):\n    mu = mus[1] + sigmas[0, 1] / sigmas[1, 1]*(x - mus[0])\n    sigma = sigmas[1, 1] - sigmas[0, 1]/sigmas[0, 0]*sigmas[0, 1]\n    return np.random.normal(mu, sigma)\nmus = np.asarray([5, 5])\nsigmas = np.asarray([[1, 0.9], [0.9, 1]])\nsamples = gibbs_sampler(mus, sigmas)\nburnin = 200\nx = list(zip(*samples[burnin:]))[0]\ny = list(zip(*samples[burnin:]))[1]\nsns.jointplot(samples[burnin:], x = x, y = y, kind = 'kde')\nsns.jointplot(samples[burnin:], x = x, y = y, kind = 'reg')\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm as tqdm\ndef density(z):\n    z = np.reshape(z, [z.shape[0], 2])\n    z1, z2 = z[:, 0], z[:, 1]\n    norm = np.sqrt(z1 ** 2 + z2 ** 2)\n    exp1 = np.exp(-0.5 * ((z1 - 2) / 0.6) ** 2)\n    exp2 = np.exp(-0.5 * ((z1 + 2) / 0.6) ** 2)\n    v = 0.5 * ((norm - 2) / 0.4) ** 2 – np.log(exp1 + exp2)\n    return np.exp(-v)\nr = np.linspace(-5, 5, 1000)\nz = np.array(np.meshgrid(r, r)).transpose(1, 2, 0)\nz = np.reshape(z, [z.shape[0] * z.shape[1], -1])\ndef metropolis_sampler(target_density, size = 100000):\n    burnin = 5000\n    size += burnin\n    x0 = np.array([[0, 0]])\n    xt = x0\n    samples = []\n    for i in tqdm(range(size)):\n        xt_candidate = np.array([np.random.multivariate_normal(xt[0], np.eye(2))])\n      accept_prob = (target_density(xt_candidate))/(target_density(xt))\n      if np.random.uniform(0, 1) < accept_prob:\n         xt = xt_candidate\n      samples.append(xt)\n    samples = np.array(samples[burnin:])\n     samples = np.reshape(samples, [samples.shape[0], 2])\n    return samples\nq = density(z) #true density\nplt.hexbin(z[:,0], z[:,1], C = q.squeeze())\nplt.gca().set_aspect('equal', adjustable ='box')\nplt.xlim([-3, 3])\nplt.ylim([-3, 3])\nplt.show()\nsamples = metropolis_sampler(density)\nplt.hexbin(samples[:,0], samples[:,1])\nplt.gca().set_aspect('equal', adjustable = 'box')\nplt.xlim([-3, 3])\nplt.ylim([-3, 3])\nplt.show()\n```"]