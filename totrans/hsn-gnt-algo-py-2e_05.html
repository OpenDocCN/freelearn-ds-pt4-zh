<html><head></head><body>
<div id="_idContainer059" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-77"><a id="_idTextAnchor091" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-78" class="calibre5"><a id="_idTextAnchor092" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Using the DEAP Framework</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter – as promised – the real fun begins! </span><span class="kobospan" id="kobo.3.2">You will be introduced to </span><strong class="bold"><span class="kobospan" id="kobo.4.1">Distributed Evolutionary Algorithms in Python</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">DEAP</span></strong><span class="kobospan" id="kobo.7.1">) – a powerful and flexible evolutionary </span><a id="_idIndexMarker143" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.8.1">computation framework capable of solving real-life problems using genetic algorithms. </span><span class="kobospan" id="kobo.8.2">After a brief introduction, you will get acquainted with two of its main modules – the creator and the toolbox – and learn how to create the various components needed for the genetic algorithm flow. </span><span class="kobospan" id="kobo.8.3">We will then write a Python program that solves the OneMax problem – the Hello World of genetic algorithms – using the DEAP framework. </span><span class="kobospan" id="kobo.8.4">This will be followed by a more concise version of the same program, where we’ll take advantage of the built-in algorithms of the framework. </span><span class="kobospan" id="kobo.8.5">We’ve saved the best for the last part of this chapter, where we will be experimenting with various settings of the genetic algorithm we created and discover the effects of </span><span><span class="kobospan" id="kobo.9.1">our modifications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.10.1">By the end of this chapter, you will be able to do </span><span><span class="kobospan" id="kobo.11.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.12.1">Express your familiarity with the DEAP framework and its genetic </span><span><span class="kobospan" id="kobo.13.1">algorithm modules</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Understand the concepts of the creator and toolbox modules in the </span><span><span class="kobospan" id="kobo.15.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.16.1">Translate a simple problem into a genetic </span><span><span class="kobospan" id="kobo.17.1">algorithm representation</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.18.1">Create a genetic algorithm solution using the </span><span><span class="kobospan" id="kobo.19.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.20.1">Understand how to use the DEAP framework’s built-in algorithms to produce </span><span><span class="kobospan" id="kobo.21.1">concise code</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.22.1">Solve the OneMax problem using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.23.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.24.1">Experiment with various settings of the genetic algorithm and interpret the differences in </span><span><span class="kobospan" id="kobo.25.1">the results</span></span></li>
</ul>
<h1 id="_idParaDest-79" class="calibre5"><a id="_idTextAnchor093" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.26.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">Here are the technical requirements for </span><span><span class="kobospan" id="kobo.28.1">this chapter.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.29.1">Important note: </span></p>
<p class="callout"><span class="kobospan" id="kobo.30.1">For the latest information regarding the technical requirements, please refer to the README file </span><span><span class="kobospan" id="kobo.31.1">at: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.32.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md</span></span></a></p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor094" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.33.1">Python version</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">In this book, we will be using Python 3, version 3.11 or newer. </span><span class="kobospan" id="kobo.34.2">Python can be downloaded from the Python Software Foundation at </span><a href="https://www.python.org/downloads/" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.35.1">https://www.python.org/downloads/</span></a><span class="kobospan" id="kobo.36.1">. </span><span class="kobospan" id="kobo.36.2">Additional useful instructions can be found </span><span><span class="kobospan" id="kobo.37.1">here: </span></span><a href="https://realpython.com/installing-python/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.38.1">https://realpython.com/installing-python/</span></span></a><span><span class="kobospan" id="kobo.39.1">.</span></span></p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor095" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.40.1">Using a virtual environment</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">It is generally good practice to use a virtual environment when working on a Python-based project as it enables you to keep the dependencies of your project isolated from other Python projects, as well as the system’s existing settings </span><span><span class="kobospan" id="kobo.42.1">and dependencies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">One common way to create a virtual environment is by using </span><strong class="bold"><span class="kobospan" id="kobo.44.1">venv</span></strong><span class="kobospan" id="kobo.45.1">, as described </span><span><span class="kobospan" id="kobo.46.1">here: </span></span><a href="https://docs.python.org/3/library/venv.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.47.1">https://docs.python.org/3/library/venv.html</span></span></a><span><span class="kobospan" id="kobo.48.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.49.1">Another popular way to manage Python environments and packages is using </span><strong class="bold"><span class="kobospan" id="kobo.50.1">conda</span></strong><span class="kobospan" id="kobo.51.1">, as described </span><span><span class="kobospan" id="kobo.52.1">here: </span></span><a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.53.1">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html</span></span></a><span><span class="kobospan" id="kobo.54.1">.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.55.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.56.1">When using a virtual environment, make sure you </span><strong class="bold"><span class="kobospan" id="kobo.57.1">activate</span></strong><span class="kobospan" id="kobo.58.1"> it before installing the required libraries, as described in the </span><span><span class="kobospan" id="kobo.59.1">following section.</span></span></p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor096" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.60.1">Installing the necessary libraries</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">Throughout this book, we will be using the DEAP library, as well as various other Python packages. </span><span class="kobospan" id="kobo.61.2">There are a couple of options to install these dependencies, as outlined in the </span><span><span class="kobospan" id="kobo.62.1">following subsections.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.63.1">Using requirements.txt</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.64.1">Whether you choose to use a virtual environment or not, you can utilize the </span><strong class="source-inline"><span class="kobospan" id="kobo.65.1">requirements.txt</span></strong><span class="kobospan" id="kobo.66.1"> file we provide to install all the required dependencies at once. </span><span class="kobospan" id="kobo.66.2">This file contains all the packages that will be used throughout this book and can be found in this book’s GitHub repository </span><span><span class="kobospan" id="kobo.67.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.68.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt</span></span></a><span><span class="kobospan" id="kobo.69.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">Typically, the </span><strong class="source-inline"><span class="kobospan" id="kobo.71.1">requirements.txt</span></strong><span class="kobospan" id="kobo.72.1"> file is used in conjunction with the </span><strong class="source-inline"><span class="kobospan" id="kobo.73.1">pip</span></strong><span class="kobospan" id="kobo.74.1"> utility and can be installed by applying the </span><span><span class="kobospan" id="kobo.75.1">following command:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.76.1">
pip install -r /path/to/requirements.txt</span></pre> <h3 class="calibre9"><span class="kobospan" id="kobo.77.1">Installing individual packages</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.78.1">If you prefer to install the required packages individually as you go through this book, the Technical requirements section of each chapter will mention the particular packages that will be used within </span><span><span class="kobospan" id="kobo.79.1">that chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.80.1">To start with, we will need to install the DEAP library. </span><span class="kobospan" id="kobo.80.2">The recommended ways to install DEAP are using </span><strong class="source-inline"><span class="kobospan" id="kobo.81.1">easy_install</span></strong><span class="kobospan" id="kobo.82.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.83.1">pip</span></strong><span class="kobospan" id="kobo.84.1">, </span><span><span class="kobospan" id="kobo.85.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.86.1">
pip install deap</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.87.1">For more information, check out the DEAP </span><span><span class="kobospan" id="kobo.88.1">documentation: </span></span><a href="https://deap.readthedocs.io/en/master/installation.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.89.1">https://deap.readthedocs.io/en/master/installation.html</span></span></a><span><span class="kobospan" id="kobo.90.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.91.1">If you prefer to install DEAP via Conda, consult the following </span><span><span class="kobospan" id="kobo.92.1">link: </span></span><a href="https://anaconda.org/conda-forge/deap" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.93.1">https://anaconda.org/conda-forge/deap</span></span></a><span><span class="kobospan" id="kobo.94.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">In addition, for this chapter, you will need the </span><span><span class="kobospan" id="kobo.96.1">following packages:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.97.1">NumPy</span></strong></span><span><span class="kobospan" id="kobo.98.1">: </span></span><a href="https://www.numpy.org/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.99.1">https://www.numpy.org/</span></span></a></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.100.1">Matplotlib</span></strong></span><span><span class="kobospan" id="kobo.101.1">: </span></span><a href="https://matplotlib.org/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.102.1">https://matplotlib.org/</span></span></a></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.103.1">Seaborn</span></strong></span><span><span class="kobospan" id="kobo.104.1">: </span></span><a href="https://seaborn.pydata.org/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.105.1">https://seaborn.pydata.org/</span></span></a></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.106.1">We are now ready to use DEAP. </span><span class="kobospan" id="kobo.106.2">The framework’s most useful tools and utilities will be covered in the next two sections. </span><span class="kobospan" id="kobo.106.3">But first, we will get acquainted with DEAP and understand why we chose this framework for working with </span><span><span class="kobospan" id="kobo.107.1">genetic algorithms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.108.1">The programs that will be used in this chapter can be found in this book’s GitHub repository </span><span><span class="kobospan" id="kobo.109.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.110.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03</span></span></a><span><span class="kobospan" id="kobo.111.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.112.1">Check out the following video to see the Code in </span><span><span class="kobospan" id="kobo.113.1">Action: </span></span><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.114.1">https://packt.link/OEBOd</span></span></a><span><span class="kobospan" id="kobo.115.1">.</span></span></p>
<h1 id="_idParaDest-83" class="calibre5"><a id="_idTextAnchor097" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.116.1">Introduction to DEAP</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">As we have</span><a id="_idIndexMarker144" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.118.1"> seen in the previous chapters, the basic ideas behind genetic algorithms and the genetic flow are relatively simple, and so are many of the genetic operators. </span><span class="kobospan" id="kobo.118.2">Therefore, developing a program from scratch that implements a genetic algorithm to solve a particular problem is </span><span><span class="kobospan" id="kobo.119.1">entirely feasible.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">However, as is often the case when developing software, using a tried-and-true dedicated library or framework can make our lives easier. </span><span class="kobospan" id="kobo.120.2">It helps us create solutions faster and with fewer bugs and gives us many options to choose from (and experiment with) right out of the box, without the need to reinvent </span><span><span class="kobospan" id="kobo.121.1">the wheel.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.122.1">Numerous Python frameworks have been created for working with genetic algorithms – PyGAD, GAFT, Pyevolve, and PyGMO, to mention a few. </span><span class="kobospan" id="kobo.122.2">After looking into several options, we chose to use the DEAP framework for this book thanks to its ease of use and a large selection of features, as well as its extensibility and </span><span><span class="kobospan" id="kobo.123.1">ample documentation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.124.1">DEAP is a Python framework that supports the rapid development of solutions using genetic algorithms, as well as other evolutionary computation techniques. </span><span class="kobospan" id="kobo.124.2">DEAP offers various data structures and tools that prove essential when implementing a wide range of </span><span><span class="kobospan" id="kobo.125.1">genetic-algorithm-based solutions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.126.1">DEAP has been developed at the Canadian Laval University since 2009 and is available under the</span><a id="_idIndexMarker145" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.127.1"> GNU </span><strong class="bold"><span class="kobospan" id="kobo.128.1">Lesser General Public </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.129.1">License</span></strong></span><span><span class="kobospan" id="kobo.130.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.131.1">LGPL</span></strong></span><span><span class="kobospan" id="kobo.132.1">).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.133.1">The source code</span><a id="_idIndexMarker146" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.134.1"> for DEAP is available at </span><a href="https://github.com/DEAP/deap" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.135.1">https://github.com/DEAP/deap</span></a><span class="kobospan" id="kobo.136.1"> and the documentation can be found </span><span><span class="kobospan" id="kobo.137.1">at </span></span><a href="https://deap.readthedocs.io/en/master/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.138.1">https://deap.readthedocs.io/en/master/</span></span></a><span><span class="kobospan" id="kobo.139.1">.</span></span></p>
<h1 id="_idParaDest-84" class="calibre5"><a id="_idTextAnchor098" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.140.1">Using the creator module</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.141.1">The first powerful</span><a id="_idIndexMarker147" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.142.1"> tool </span><a id="_idIndexMarker148" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.143.1">provided by the DEAP framework is the </span><strong class="source-inline"><span class="kobospan" id="kobo.144.1">creator</span></strong><span class="kobospan" id="kobo.145.1"> module. </span><span class="kobospan" id="kobo.145.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">creator</span></strong><span class="kobospan" id="kobo.147.1"> module is used as a meta-factory, and it enables us to extend existing classes by augmenting them with </span><span><span class="kobospan" id="kobo.148.1">new attributes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.149.1">For example, suppose we have a class called </span><strong class="source-inline"><span class="kobospan" id="kobo.150.1">Employee</span></strong><span class="kobospan" id="kobo.151.1">. </span><span class="kobospan" id="kobo.151.2">Using the </span><strong class="source-inline"><span class="kobospan" id="kobo.152.1">creator</span></strong><span class="kobospan" id="kobo.153.1"> tool, we can extend the </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">Employee</span></strong><span class="kobospan" id="kobo.155.1"> class by creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">Developer</span></strong><span class="kobospan" id="kobo.157.1"> class, </span><span><span class="kobospan" id="kobo.158.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.159.1">
from deap import creator
</span><strong class="bold1"><span class="kobospan1" id="kobo.160.1">creator.create</span></strong><span class="kobospan1" id="kobo.161.1">("Developer", Employee,\
                position="Developer", \
                programmingLanguages=set)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.162.1">The</span><a id="_idIndexMarker149" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.163.1"> first argument</span><a id="_idIndexMarker150" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.164.1"> that’s passed to the </span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">create()</span></strong><span class="kobospan" id="kobo.166.1"> function is the desired name for the new class. </span><span class="kobospan" id="kobo.166.2">The second argument is the existing base class to be extended. </span><span class="kobospan" id="kobo.166.3">Then, each additional argument defines an attribute for the new class. </span><span class="kobospan" id="kobo.166.4">If the argument is assigned a data structure (such as </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">dict</span></strong><span class="kobospan" id="kobo.168.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">set</span></strong><span class="kobospan" id="kobo.170.1">), it is added to the new class as an instance attribute that’s initialized in the constructor. </span><span class="kobospan" id="kobo.170.2">If the argument is a simple type, such as a literal, it’s added as a class attribute that’s shared among all instances of </span><span><span class="kobospan" id="kobo.171.1">the class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.172.1">Consequently, the created </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">Developer</span></strong><span class="kobospan" id="kobo.174.1"> class will extend the </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">Employee</span></strong><span class="kobospan" id="kobo.176.1"> class and will have a class attribute, </span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">position</span></strong><span class="kobospan" id="kobo.178.1">, set to </span><strong class="source-inline"><span class="kobospan" id="kobo.179.1">Developer</span></strong><span class="kobospan" id="kobo.180.1">, and an instance attribute, </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">programmingLanguages</span></strong><span class="kobospan" id="kobo.182.1"> of the </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">set</span></strong><span class="kobospan" id="kobo.184.1"> type, which is initialized in the constructor. </span><span class="kobospan" id="kobo.184.2">So, effectively, the new class is equivalent to </span><span><span class="kobospan" id="kobo.185.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.186.1">
class Developer(Employee):
    </span><strong class="bold1"><span class="kobospan1" id="kobo.187.1">position</span></strong><span class="kobospan1" id="kobo.188.1"> = "Developer"
    def __init__(self):
        </span><strong class="bold1"><span class="kobospan1" id="kobo.189.1">self.programmingLanguages</span></strong><span class="kobospan1" id="kobo.190.1"> = set()</span></pre> <p class="callout-heading"><span class="kobospan" id="kobo.191.1">Important notes</span></p>
<p class="callout"><span class="kobospan" id="kobo.192.1">1. </span><span class="kobospan" id="kobo.192.2">This new class exists within the </span><strong class="source-inline1"><span class="kobospan" id="kobo.193.1">creator</span></strong><span class="kobospan" id="kobo.194.1"> module and therefore needs to be referenced </span><span><span class="kobospan" id="kobo.195.1">as </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.196.1">creator.Developer</span></strong></span><span><span class="kobospan" id="kobo.197.1">.</span></span></p>
<p class="callout"><span class="kobospan" id="kobo.198.1">2. </span><span class="kobospan" id="kobo.198.2">Extending the </span><strong class="source-inline1"><span class="kobospan" id="kobo.199.1">numpy.ndarray</span></strong><span class="kobospan" id="kobo.200.1"> class is a special case that will be discussed later in </span><span><span class="kobospan" id="kobo.201.1">this book.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.202.1">When using</span><a id="_idIndexMarker151" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.203.1"> DEAP, the </span><strong class="source-inline"><span class="kobospan" id="kobo.204.1">creator</span></strong><span class="kobospan" id="kobo.205.1"> module usually serves to create the </span><strong class="source-inline"><span class="kobospan" id="kobo.206.1">Fitness</span></strong><span class="kobospan" id="kobo.207.1"> class, as well as the </span><strong class="source-inline"><span class="kobospan" id="kobo.208.1">Individual</span></strong><span class="kobospan" id="kobo.209.1"> class, to be used by the genetic algorithm, as we will </span><span><span class="kobospan" id="kobo.210.1">see next.</span></span></p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor099" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.211.1">Creating the Fitness class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.212.1">When </span><a id="_idIndexMarker152" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.213.1">using DEAP, fitness values are encapsulated within a </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">Fitness</span></strong><span class="kobospan" id="kobo.215.1"> class. </span><span class="kobospan" id="kobo.215.2">DEAP enables fitness to be combined into several components (also called objectives), each having its own weight. </span><span class="kobospan" id="kobo.215.3">The combination of these weights defines the behavior or strategy of the fitness for the </span><span><span class="kobospan" id="kobo.216.1">given problem.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.217.1">Defining the fitness strategy</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">To help</span><a id="_idIndexMarker153" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.219.1"> define this strategy, DEAP comes with the abstract </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">base.Fitness</span></strong><span class="kobospan" id="kobo.221.1"> class, which contains a </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">weights</span></strong><span class="kobospan" id="kobo.223.1"> tuple. </span><span class="kobospan" id="kobo.223.2">This tuple needs to be assigned values to define the strategy and make the class usable. </span><span class="kobospan" id="kobo.223.3">This can be done by extending the base </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">Fitness</span></strong><span class="kobospan" id="kobo.225.1"> class using </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">creator</span></strong><span class="kobospan" id="kobo.227.1">, in a similar manner to what we did with the preceding </span><span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">Developer</span></strong></span><span><span class="kobospan" id="kobo.229.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.230.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.231.1">FitnessMax</span></strong><span class="kobospan1" id="kobo.232.1">", base.Fitness, </span><strong class="bold1"><span class="kobospan1" id="kobo.233.1">weights=(1.0,)</span></strong><span class="kobospan1" id="kobo.234.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.235.1">This will yield a </span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">creator.FitnessMax</span></strong><span class="kobospan" id="kobo.237.1"> class that extends the </span><strong class="source-inline"><span class="kobospan" id="kobo.238.1">base.Fitness</span></strong><span class="kobospan" id="kobo.239.1"> class, with the </span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">weights</span></strong><span class="kobospan" id="kobo.241.1"> class attribute initialized to a value </span><span><span class="kobospan" id="kobo.242.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.243.1">(1.0,)</span></strong></span><span><span class="kobospan" id="kobo.244.1">.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.245.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.246.1">Note the trailing comma in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.247.1">weights</span></strong><span class="kobospan" id="kobo.248.1"> definition when a single weight is defined. </span><span class="kobospan" id="kobo.248.2">The comma is required </span><a id="_idIndexMarker154" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.249.1">because </span><strong class="source-inline1"><span class="kobospan" id="kobo.250.1">weights</span></strong><span class="kobospan" id="kobo.251.1"> is </span><span><span class="kobospan" id="kobo.252.1">a </span></span><span><strong class="bold"><span class="kobospan" id="kobo.253.1">tuple</span></strong></span><span><span class="kobospan" id="kobo.254.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.255.1">The strategy of this </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">FitnessMax</span></strong><span class="kobospan" id="kobo.257.1"> class is to </span><em class="italic"><span class="kobospan" id="kobo.258.1">maximize </span></em><span class="kobospan" id="kobo.259.1">the fitness values of the single-objective solutions throughout the genetic algorithm. </span><span class="kobospan" id="kobo.259.2">Conversely, if we have a single-objective problem where we need to find a solution that </span><em class="italic"><span class="kobospan" id="kobo.260.1">minimizes</span></em><span class="kobospan" id="kobo.261.1"> the fitness value, we can use the following definition to create the appropriate </span><span><span class="kobospan" id="kobo.262.1">minimizing strategy:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.263.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.264.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.265.1">", base.Fitness, </span><strong class="bold1"><span class="kobospan1" id="kobo.266.1">weights=(-1.0,)</span></strong><span class="kobospan1" id="kobo.267.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.268.1">We can also define a class with a strategy for optimizing more than one objective, and with varying degrees </span><span><span class="kobospan" id="kobo.269.1">of importance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.270.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.271.1">FitnessCompound</span></strong><span class="kobospan1" id="kobo.272.1">", base.Fitness, 
    </span><strong class="bold1"><span class="kobospan1" id="kobo.273.1">weights=(1.0, 0.2, -0.5)</span></strong><span class="kobospan1" id="kobo.274.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.275.1">This will </span><a id="_idIndexMarker155" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.276.1">create the </span><strong class="source-inline"><span class="kobospan" id="kobo.277.1">creator.FitnessCompound</span></strong><span class="kobospan" id="kobo.278.1"> class, which will utilize three different fitness components. </span><span class="kobospan" id="kobo.278.2">The first will be given a weight of </span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">1.0</span></strong><span class="kobospan" id="kobo.280.1">, the second </span><strong class="source-inline"><span class="kobospan" id="kobo.281.1">0.2</span></strong><span class="kobospan" id="kobo.282.1">, and the third </span><strong class="source-inline"><span class="kobospan" id="kobo.283.1">-0.5</span></strong><span class="kobospan" id="kobo.284.1">. </span><span class="kobospan" id="kobo.284.2">This fitness strategy will tend to maximize the first and the second components (or objectives) and minimize the third. </span><span class="kobospan" id="kobo.284.3">In terms of importance, the first component has the most importance, followed by the third component and then the </span><span><span class="kobospan" id="kobo.285.1">second one.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.286.1">Storing the fitness values</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.287.1">While the </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">weights</span></strong><span class="kobospan" id="kobo.289.1"> tuple</span><a id="_idIndexMarker156" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.290.1"> defines the fitness strategy, a matching tuple, called </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">values</span></strong><span class="kobospan" id="kobo.292.1">, is used to contain the actual fitness values within the </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">base.Fitness</span></strong><span class="kobospan" id="kobo.294.1"> class. </span><span class="kobospan" id="kobo.294.2">These values are obtained from a separately defined function, typ</span><a id="_idTextAnchor100" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.295.1">ically called </span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">evaluate()</span></strong><span class="kobospan" id="kobo.297.1">, as will be described later in this chapter. </span><span class="kobospan" id="kobo.297.2">Just like the </span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">weights</span></strong><span class="kobospan" id="kobo.299.1"> tuple, the </span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">values</span></strong><span class="kobospan" id="kobo.301.1"> tuple contains one value for each fitness </span><span><span class="kobospan" id="kobo.302.1">component (objective).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.303.1">A third tuple, </span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">wvalues</span></strong><span class="kobospan" id="kobo.305.1">, contains the weighted values that are obtained by multiplying each component of the values tuple with its matching com</span><a id="_idTextAnchor101" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.306.1">ponent of the </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">weights</span></strong><span class="kobospan" id="kobo.308.1"> tuple. </span><span class="kobospan" id="kobo.308.2">Whenever the fitness values of an instance are set, the weighted values are calculated and inserted into </span><strong class="source-inline"><span class="kobospan" id="kobo.309.1">wvalues</span></strong><span class="kobospan" id="kobo.310.1">. </span><span class="kobospan" id="kobo.310.2">These are used internally for comparison operations </span><span><span class="kobospan" id="kobo.311.1">between individuals.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.312.1">The weighted fitness values may be lexicographically compared using the </span><span><span class="kobospan" id="kobo.313.1">following operators:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.314.1">
&gt;, &lt;, &gt;=, &lt;=, ==, !=</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.315.1">Once the </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">Fitness</span></strong><span class="kobospan" id="kobo.317.1"> class is created, we can use it in the definition of the </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">Individual</span></strong><span class="kobospan" id="kobo.319.1"> class, as shown in the </span><span><span class="kobospan" id="kobo.320.1">next subsection.</span></span></p>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.321.1">Creating the Individual class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">The</span><a id="_idIndexMarker157" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.323.1"> second common use of the </span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">creator</span></strong><span class="kobospan" id="kobo.325.1"> tool in DEAP is defining the individuals that form the population for the genetic algorithm. </span><span class="kobospan" id="kobo.325.2">As we saw in the previous chapters, the individuals in genetic algorithms are represented using a chromosome that can be manipulated by genetic operators. </span><span class="kobospan" id="kobo.325.3">In DEAP, the </span><strong class="source-inline"><span class="kobospan" id="kobo.326.1">Individual</span></strong><span class="kobospan" id="kobo.327.1"> class is created by extending a base class that represents the chromosome. </span><span class="kobospan" id="kobo.327.2">In addition, each instance in DEAP needs to contain its fitness function as </span><span><span class="kobospan" id="kobo.328.1">an attribute.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.329.1">To fulfill these two requirements, we can utilize </span><strong class="source-inline"><span class="kobospan" id="kobo.330.1">creator</span></strong><span class="kobospan" id="kobo.331.1"> to create the </span><strong class="source-inline"><span class="kobospan" id="kobo.332.1">creator.Individual</span></strong><span class="kobospan" id="kobo.333.1"> class, as shown in </span><span><span class="kobospan" id="kobo.334.1">this example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.335.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.336.1">Individual</span></strong><span class="kobospan1" id="kobo.337.1">", list, \
                fitness=creator.FitnessMax)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.338.1">This line provides the following </span><span><span class="kobospan" id="kobo.339.1">two effects:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.340.1">The created </span><strong class="source-inline1"><span class="kobospan" id="kobo.341.1">Individual</span></strong><span class="kobospan" id="kobo.342.1"> class extends the Python </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">list</span></strong><span class="kobospan" id="kobo.344.1"> class. </span><span class="kobospan" id="kobo.344.2">This means that the chromosome that’s used is of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.345.1">list</span></strong></span><span><span class="kobospan" id="kobo.346.1"> type.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.347.1">Each instance of this </span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">Individual</span></strong><span class="kobospan" id="kobo.349.1"> class will have an attribute called </span><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">f</span><a id="_idTextAnchor103" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.351.1">itness</span></strong><span class="kobospan" id="kobo.352.1">, of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">FitnessMax</span></strong><span class="kobospan" id="kobo.354.1"> class, which we </span><span><span class="kobospan" id="kobo.355.1">created previously.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.356.1">We will learn to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">Toolbox</span></strong><span class="kobospan" id="kobo.358.1"> class in the </span><span><span class="kobospan" id="kobo.359.1">next section.</span></span></p>
<h1 id="_idParaDest-87" class="calibre5"><a id="_idTextAnchor104" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.360.1">Using the Toolbox class</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.361.1">The second </span><a id="_idIndexMarker158" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.362.1">mechanism offered by the DEAP framework is the </span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">base.Toolbox</span></strong><span class="kobospan" id="kobo.364.1"> class. </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">Toolbox</span></strong><span class="kobospan" id="kobo.366.1"> is used as a container for functions (or operators) and enables us to create new operators by aliasing and customizing </span><span><span class="kobospan" id="kobo.367.1">existing functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.368.1">For example, suppose we have a function, </span><strong class="source-inline"><span class="kobospan" id="kobo.369.1">sumOfTwo()</span></strong><span class="kobospan" id="kobo.370.1">, defined </span><span><span class="kobospan" id="kobo.371.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.372.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.373.1">sumOfTwo</span></strong><span class="kobospan1" id="kobo.374.1">(a, b):
    return a + b</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.375.1">Using </span><strong class="source-inline"><span class="kobospan" id="kobo.376.1">toolbox</span></strong><span class="kobospan" id="kobo.377.1">, we can now create a new operator, </span><span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">incrementByFive()</span></strong></span><span><span class="kobospan" id="kobo.379.1">, which</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.380.1">customizes the </span><strong class="source-inline"><span class="kobospan" id="kobo.381.1">sumOfTwo()</span></strong><span class="kobospan" id="kobo.382.1"> function, </span><span><span class="kobospan" id="kobo.383.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.384.1">
from deap import base
toolbox= base.Toolbox()
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.385.1">incrementByFive</span></strong><span class="kobospan1" id="kobo.386.1">", sumOfTwo, b=5)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.387.1">The </span><a id="_idIndexMarker159" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.388.1">first argument that</span><a id="_idTextAnchor105" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.389.1">’s passed to the </span><strong class="source-inline"><span class="kobospan" id="kobo.390.1">register()</span></strong><span class="kobospan" id="kobo.391.1"> toolbox function is the desired name (or alias) for the new operator. </span><span class="kobospan" id="kobo.391.2">The second argument is the existing function to be customized. </span><span class="kobospan" id="kobo.391.3">Then, each additional (optional) argument is automatically passed to the customized function whenever we call the new operator. </span><span class="kobospan" id="kobo.391.4">For example, look at </span><span><span class="kobospan" id="kobo.392.1">this definition:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.393.1">
toolbox.incrementByFive(10)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.394.1">Calling the preceding function is equivalent to </span><span><span class="kobospan" id="kobo.395.1">calling this:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.396.1">
sumOfTwo(10, 5)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.397.1">This is </span><a id="_idIndexMarker160" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.398.1">because the </span><strong class="source-inline"><span class="kobospan" id="kobo.399.1">b</span></strong><span class="kobospan" id="kobo.400.1"> argument has been fixed to a value of </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">5</span></strong><span class="kobospan" id="kobo.402.1"> by the definition of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.403.1">incrementByFive</span></strong></span><span><span class="kobospan" id="kobo.404.1"> operator.</span></span></p>
<h2 id="_idParaDest-88" class="calibre7"><a id="_idTextAnchor106" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.405.1">Creating genetic operators</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.406.1">In many </span><a id="_idIndexMarker161" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.407.1">cases, the </span><strong class="source-inline"><span class="kobospan" id="kobo.408.1">Toolbox</span></strong><span class="kobospan" id="kobo.409.1"> class is used to customize existing </span><a id="_idTextAnchor107" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.410.1">functions from the </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">tools</span></strong><span class="kobospan" id="kobo.412.1"> module. </span><span class="kobospan" id="kobo.412.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">tools</span></strong><span class="kobospan" id="kobo.414.1"> module contains numerous handy functions related to the genetic operations of </span><em class="italic"><span class="kobospan" id="kobo.415.1">selection</span></em><span class="kobospan" id="kobo.416.1">, </span><em class="italic"><span class="kobospan" id="kobo.417.1">crossover</span></em><span class="kobospan" id="kobo.418.1">, and </span><em class="italic"><span class="kobospan" id="kobo.419.1">mutation</span></em><span class="kobospan" id="kobo.420.1">, as well as </span><span><span class="kobospan" id="kobo.421.1">initialization utilities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.422.1">For example, the following code defines three aliases that will be later used as </span><span><span class="kobospan" id="kobo.423.1">genetic operators:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.424.1">
from deap import tools
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.425.1">select</span></strong><span class="kobospan1" id="kobo.426.1">",tools.selTournament,tournsize=3)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.427.1">mate</span></strong><span class="kobospan1" id="kobo.428.1">", tools.cxTwoPoint)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.429.1">mutate</span></strong><span class="kobospan1" id="kobo.430.1">", tools.mutFlipBit, indpb=0.02)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.431.1">The three aliases are defined </span><span><span class="kobospan" id="kobo.432.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.433.1">select</span></strong><span class="kobospan" id="kobo.434.1"> is registered as an ali</span><a id="_idTextAnchor108" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.435.1">as to the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.436.1">tools</span></strong><span class="kobospan" id="kobo.437.1"> function, </span><strong class="source-inline1"><span class="kobospan" id="kobo.438.1">selTournament()</span></strong><span class="kobospan" id="kobo.439.1">, with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.440.1">tournsize</span></strong><span class="kobospan" id="kobo.441.1"> argument set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.442.1">3</span></strong><span class="kobospan" id="kobo.443.1">. </span><span class="kobospan" id="kobo.443.2">This creates a </span><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">toolbox.select</span></strong><span class="kobospan" id="kobo.445.1"> operator that performs </span><em class="italic"><span class="kobospan" id="kobo.446.1">tournament selection</span></em><span class="kobospan" id="kobo.447.1"> with a tournament size </span><span><span class="kobospan" id="kobo.448.1">of 3.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">mate</span></strong><span class="kobospan" id="kobo.450.1"> is registered as an ali</span><a id="_idTextAnchor109" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.451.1">as to the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.452.1">tools</span></strong><span class="kobospan" id="kobo.453.1"> function, </span><strong class="source-inline1"><span class="kobospan" id="kobo.454.1">cxTwoPoint()</span></strong><span class="kobospan" id="kobo.455.1">. </span><span class="kobospan" id="kobo.455.2">This results in a </span><strong class="source-inline1"><span class="kobospan" id="kobo.456.1">toolbox.mate</span></strong><span class="kobospan" id="kobo.457.1"> operator that performs </span><span><em class="italic"><span class="kobospan" id="kobo.458.1">two-point crossover</span></em></span><span><span class="kobospan" id="kobo.459.1">.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.460.1">mutate</span></strong><span class="kobospan" id="kobo.461.1"> is registered as an ali</span><a id="_idTextAnchor110" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.462.1">as to the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">tools</span></strong><span class="kobospan" id="kobo.464.1"> function, </span><strong class="source-inline1"><span class="kobospan" id="kobo.465.1">mutFlipBit</span></strong><span class="kobospan" id="kobo.466.1">, with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.467.1">indpb</span></strong><span class="kobospan" id="kobo.468.1"> argument set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.469.1">0.02</span></strong><span class="kobospan" id="kobo.470.1">, providing a </span><strong class="source-inline1"><span class="kobospan" id="kobo.471.1">toolbox.mutate</span></strong><span class="kobospan" id="kobo.472.1"> operator that performs </span><em class="italic"><span class="kobospan" id="kobo.473.1">flip-bit mutation</span></em><span class="kobospan" id="kobo.474.1"> with 0.02 as the probability for each attribute to </span><span><span class="kobospan" id="kobo.475.1">be flipped.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.476.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">tools</span></strong><span class="kobospan" id="kobo.478.1"> module </span><a id="_idIndexMarker162" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.479.1">provides implementations of various genetic operators, including several of the ones we mentioned in the </span><span><span class="kobospan" id="kobo.480.1">previous chapter.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.481.1">Selection</span></strong><span class="kobospan" id="kobo.482.1"> functions</span><a id="_idIndexMarker163" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.483.1"> can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.484.1">selection.py</span></strong><span class="kobospan" id="kobo.485.1"> file. </span><span class="kobospan" id="kobo.485.2">Some of them are </span><span><span class="kobospan" id="kobo.486.1">as </span></span><span><a id="_idIndexMarker164" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.487.1">follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.488.1">selRoulette()</span></strong><span class="kobospan" id="kobo.489.1"> implements </span><strong class="bold"><span class="kobospan" id="kobo.490.1">roulette </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.491.1">wheel selection</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.492.1">selStochasticUniversalSampling()</span></strong><span class="kobospan" id="kobo.493.1"> implements </span><strong class="bold"><span class="kobospan" id="kobo.494.1">Stochastic Universal </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.495.1">Sampling</span></strong></span><span><span class="kobospan" id="kobo.496.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.497.1">SUS</span></strong></span><span><span class="kobospan" id="kobo.498.1">)</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.499.1">selTournament()</span></strong><span class="kobospan" id="kobo.500.1"> implements </span><span><strong class="bold"><span class="kobospan" id="kobo.501.1">tournament selection</span></strong></span></li>
</ul>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.502.1">Crossover</span></strong><span class="kobospan" id="kobo.503.1"> functions can </span><a id="_idIndexMarker165" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.504.1">be found in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">crossover.py</span></strong></span><span><span class="kobospan" id="kobo.506.1"> file:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.507.1">cxOnePoint()</span></strong><span class="kobospan" id="kobo.508.1"> implements </span><span><strong class="bold"><span class="kobospan" id="kobo.509.1">single-point crossover</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.510.1">cxUniform()</span></strong><span class="kobospan" id="kobo.511.1"> implements </span><span><strong class="bold"><span class="kobospan" id="kobo.512.1">uniform crossover</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">cxOrdered()</span></strong><span class="kobospan" id="kobo.514.1"> implements </span><strong class="bold"><span class="kobospan" id="kobo.515.1">ordered </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.516.1">crossover</span></strong></span><span><span class="kobospan" id="kobo.517.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.518.1">OX1</span></strong></span><span><span class="kobospan" id="kobo.519.1">)</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.520.1">cxPartialyMatched()</span></strong><span class="kobospan" id="kobo.521.1"> implements </span><strong class="bold"><span class="kobospan" id="kobo.522.1">partially matched </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.523.1">crossover</span></strong></span><span><span class="kobospan" id="kobo.524.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.525.1">PMX</span></strong></span><span><span class="kobospan" id="kobo.526.1">)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.527.1">A couple of</span><a id="_idIndexMarker166" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.528.1"> the </span><strong class="bold"><span class="kobospan" id="kobo.529.1">Mutation</span></strong><span class="kobospan" id="kobo.530.1"> functions that can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">mutation.py</span></strong><span class="kobospan" id="kobo.532.1"> file are </span><span><span class="kobospan" id="kobo.533.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.534.1">mutFlipBit()</span></strong><span class="kobospan" id="kobo.535.1"> implements </span><span><strong class="bold"><span class="kobospan" id="kobo.536.1">flip-bit mutation</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.537.1">mutGaussian()</span></strong><span class="kobospan" id="kobo.538.1"> implements </span><strong class="bold"><span class="kobospan" id="kobo.539.1">normally </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.540.1">distributed mutation</span></strong></span></li>
</ul>
<h2 id="_idParaDest-89" class="calibre7"><a id="_idTextAnchor111" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.541.1">Creating the population</span></h2>
<p class="calibre3"><a id="_idTextAnchor112" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.542.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">init.py</span></strong><span class="kobospan" id="kobo.544.1"> file of the </span><strong class="source-inline"><span class="kobospan" id="kobo.545.1">tools</span></strong><span class="kobospan" id="kobo.546.1"> module contains several functions that can be useful for creating </span><a id="_idIndexMarker167" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.547.1">and initializing the population for the genetic algorithm. </span><span class="kobospan" id="kobo.547.2">One particularly useful function is </span><strong class="source-inline"><span class="kobospan" id="kobo.548.1">initRepeat()</span></strong><span class="kobospan" id="kobo.549.1">, which accepts </span><span><span class="kobospan" id="kobo.550.1">three arguments:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.551.1">The container type in which we would like to put the </span><span><span class="kobospan" id="kobo.552.1">resulting objects</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.553.1">The function that’s used to generate objects that will be put into </span><span><span class="kobospan" id="kobo.554.1">the container</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.555.1">The number of objects we want </span><span><span class="kobospan" id="kobo.556.1">to generate</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.557.1">For example, the following line of code will produce a list of 30 random numbers between 0 </span><span><span class="kobospan" id="kobo.558.1">and 1:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.559.1">
randomList = tools.initRepeat(</span><strong class="bold1"><span class="kobospan1" id="kobo.560.1">list</span></strong><span class="kobospan1" id="kobo.561.1">, </span><strong class="bold1"><span class="kobospan1" id="kobo.562.1">random.random</span></strong><span class="kobospan1" id="kobo.563.1">, </span><strong class="bold1"><span class="kobospan1" id="kobo.564.1">30</span></strong><span class="kobospan1" id="kobo.565.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.566.1">In this example, </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">list</span></strong><span class="kobospan" id="kobo.568.1"> is the type serving as the container to be filled, </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">random.random</span></strong><span class="kobospan" id="kobo.570.1"> is the generator function, and </span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">30</span></strong><span class="kobospan" id="kobo.572.1"> is the number of times we will call the function to generate values that fill </span><span><span class="kobospan" id="kobo.573.1">the container.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">What if we wanted to fill the list with integer random numbers that are </span><em class="italic"><span class="kobospan" id="kobo.575.1">either</span></em><span class="kobospan" id="kobo.576.1"> 0 or 1? </span><span class="kobospan" id="kobo.576.2">We could, for example, create a function that utilizes </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">random.radint()</span></strong><span class="kobospan" id="kobo.578.1"> to generate a single random value of 0 or 1, and then use it as the generator function of </span><strong class="source-inline"><span class="kobospan" id="kobo.579.1">initRepeat()</span></strong><span class="kobospan" id="kobo.580.1">, as shown in the following </span><span><span class="kobospan" id="kobo.581.1">code snippet:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.582.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.583.1">zeroOrOne</span></strong><span class="kobospan1" id="kobo.584.1">():
    return random.randint(0, 1)
randomList = tools.initRepeat(list, </span><strong class="bold1"><span class="kobospan1" id="kobo.585.1">zeroOrOne</span></strong><span class="kobospan1" id="kobo.586.1">, 30)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.587.1">Alternatively, we can take advantage of </span><strong class="source-inline"><span class="kobospan" id="kobo.588.1">toolbox</span></strong><span class="kobospan" id="kobo.589.1">, </span><span><span class="kobospan" id="kobo.590.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.591.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.592.1">zeroOrOne</span></strong><span class="kobospan1" id="kobo.593.1">", random.randint, 0, 1)
randomList = tools.initRepeat(list, </span><strong class="bold1"><span class="kobospan1" id="kobo.594.1">toolbox.zeroOrOne</span></strong><span class="kobospan1" id="kobo.595.1">, 30)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.596.1">Here, instead of </span><a id="_idIndexMarker168" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.597.1">explicitly defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.598.1">zeroOrOne()</span></strong><span class="kobospan" id="kobo.599.1"> function, we created the </span><strong class="source-inline"><span class="kobospan" id="kobo.600.1">zeroOrOne</span></strong><span class="kobospan" id="kobo.601.1"> operator (or alias), which calls </span><strong class="source-inline"><span class="kobospan" id="kobo.602.1">random.radint()</span></strong><span class="kobospan" id="kobo.603.1"> with the fixed parameters of </span><strong class="source-inline"><span class="kobospan" id="kobo.604.1">0</span></strong> <span><span class="kobospan" id="kobo.605.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.606.1">1</span></strong></span><span><span class="kobospan" id="kobo.607.1">.</span></span></p>
<h2 id="_idParaDest-90" class="calibre7"><a id="_idTextAnchor113" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.608.1">Calculating the fitness</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.609.1">As mentioned </span><a id="_idIndexMarker169" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.610.1">previously, while the </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">Fitness</span></strong><span class="kobospan" id="kobo.612.1"> class defines the fitness </span><em class="italic"><span class="kobospan" id="kobo.613.1">weights</span></em><span class="kobospan" id="kobo.614.1"> that determine its strategy (such as </span><em class="italic"><span class="kobospan" id="kobo.615.1">maximization</span></em><span class="kobospan" id="kobo.616.1"> or </span><em class="italic"><span class="kobospan" id="kobo.617.1">minimization</span></em><span class="kobospan" id="kobo.618.1">), the actual fitness values are obtained from a separately defined function. </span><span class="kobospan" id="kobo.618.2">This fitness calculation function is typically registered with the </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">toolbox</span></strong><span class="kobospan" id="kobo.620.1"> module using an alias of </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">evaluate</span></strong><span class="kobospan" id="kobo.622.1">, as shown in the following </span><span><span class="kobospan" id="kobo.623.1">code snippet:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.624.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.625.1">someFitnessCalculationFunction</span></strong><span class="kobospan1" id="kobo.626.1">(individual):
    return _some_calculation_of_the_fitness
toolbox.register("evaluate",</span><strong class="bold1"><span class="kobospan1" id="kobo.627.1">someFitnessCalculationFunction</span></strong><span class="kobospan1" id="kobo.628.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.629.1">In this example, </span><strong class="source-inline"><span class="kobospan" id="kobo.630.1">someFitnessCalculationFunction()</span></strong><span class="kobospan" id="kobo.631.1"> calculates the fitness for any given individual, while </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">evaluate</span></strong><span class="kobospan" id="kobo.633.1"> is registered as </span><span><span class="kobospan" id="kobo.634.1">its alias.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.635.1">We are finally ready to put our knowledge to use and solve our first problem using a genetic algorithm written with DEAP. </span><span class="kobospan" id="kobo.635.2">We’ll do this in the </span><span><span class="kobospan" id="kobo.636.1">next section.</span></span></p>
<h1 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor114" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.637.1">The OneMax problem</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.638.1">The OneMax (or One-Max) problem</span><a id="_idIndexMarker170" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.639.1"> is a simple optimization task that is often used as the </span><em class="italic"><span class="kobospan" id="kobo.640.1">Hello World</span></em><span class="kobospan" id="kobo.641.1"> of genetic algorithm</span><a id="_idIndexMarker171" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.642.1"> frameworks. </span><span class="kobospan" id="kobo.642.2">We will use this problem for the rest of this chapter to demonstrate how DEAP can be used to implement a </span><span><span class="kobospan" id="kobo.643.1">genetic algorithm.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.644.1">The OneMax task is to find the binary string of a given length that maximizes the sum of its digits. </span><span class="kobospan" id="kobo.644.2">For example, the OneMax problem of length 5 will consider candidates such as </span><span><span class="kobospan" id="kobo.645.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.646.1">10010 (sum of digits = </span><span><span class="kobospan" id="kobo.647.1">2)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.648.1">01110 (sum of digits = </span><span><span class="kobospan" id="kobo.649.1">3)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.650.1">11111 (sum of digits = </span><span><span class="kobospan" id="kobo.651.1">5)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.652.1">Obviously (to us), the </span><a id="_idIndexMarker172" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.653.1">solution to this problem is always the string that comprises all 1s. </span><span class="kobospan" id="kobo.653.2">However, the genetic algorithm does not have this knowledge and needs to blindly look for the solution using its genetic operators. </span><span class="kobospan" id="kobo.653.3">If the algorithm does its job, it will find this solution, or at least one close to it, within a reasonable amount </span><span><span class="kobospan" id="kobo.654.1">of time.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.655.1">The DEAP framework’s documentation uses the OneMax problem as its introductory example (</span><a href="https://github.com/DEAP/deap/blob/master/examples/ga/onemax.py" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.656.1">https://github.com/DEAP/deap/blob/master/examples/ga/onemax.py</span></a><span class="kobospan" id="kobo.657.1">). </span><span class="kobospan" id="kobo.657.2">In the following sections, we will describe our version of DEAP’s </span><span><span class="kobospan" id="kobo.658.1">OneMax example.</span></span></p>
<h1 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor115" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.659.1">Solving the OneMax problem with DEAP</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.660.1">In the previous chapter, we </span><a id="_idIndexMarker173" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.661.1">mentioned several choices that need to be made when solving </span><a id="_idIndexMarker174" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.662.1">a problem using the genetic algorithm approach. </span><span class="kobospan" id="kobo.662.2">As we tackle the OneMax problem, we will make these choices in a series of steps. </span><span class="kobospan" id="kobo.662.3">In the chapters to follow, we will keep using the same series of steps as we apply the genetic algorithms approach to various types </span><span><span class="kobospan" id="kobo.663.1">of problems.</span></span></p>
<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor116" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.664.1">Choosing the chromosome</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.665.1">Since the </span><a id="_idIndexMarker175" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.666.1">OneMax problem deals with binary strings, th</span><a id="_idTextAnchor117" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.667.1">e choice of chromosome is easy – each individual will be represented with a binary string that directly represents a candidate solution. </span><span class="kobospan" id="kobo.667.2">In the actual Python implementation, this will be implemented as a list containing integer values of either 0 or 1. </span><span class="kobospan" id="kobo.667.3">The length of the chromosome matches the size of the OneMax problem. </span><span class="kobospan" id="kobo.667.4">For example, for a One</span><a id="_idTextAnchor118" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.668.1">Max problem of size 5, the 10010 individual will be represented by </span><strong class="source-inline"><span class="kobospan" id="kobo.669.1">[1, 0, 0, </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.670.1">1, 0]</span></strong></span><span><span class="kobospan" id="kobo.671.1">.</span></span></p>
<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor119" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.672.1">Calculating the fitness</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.673.1">Since we want</span><a id="_idIndexMarker176" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.674.1"> to find the individual with the largest sum of digits, we are going t</span><a id="_idTextAnchor120" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.675.1">o use the </span><strong class="source-inline"><span class="kobospan" id="kobo.676.1">FitnessMax</span></strong><span class="kobospan" id="kobo.677.1"> strategy. </span><span class="kobospan" id="kobo.677.2">As each individual is represented by a list of integer values of either 0 or 1, the fitness value will be directly calculated as the sum of the el</span><a id="_idTextAnchor121" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.678.1">ements in the list – for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.679.1">sum([1, 0, 0, 1, 0]) = </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.680.1">2</span></strong></span><span><span class="kobospan" id="kobo.681.1">.</span></span></p>
<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor122" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.682.1">Choosing the genetic operators</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.683.1">Now, we</span><a id="_idIndexMarker177" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.684.1"> need to decide on the genetic operators to be used – </span><em class="italic"><span class="kobospan" id="kobo.685.1">selection</span></em><span class="kobospan" id="kobo.686.1">, </span><em class="italic"><span class="kobospan" id="kobo.687.1">crossover</span></em><span class="kobospan" id="kobo.688.1">, and </span><em class="italic"><span class="kobospan" id="kobo.689.1">mutation</span></em><span class="kobospan" id="kobo.690.1">. </span><span class="kobospan" id="kobo.690.2">In the previous chapter, we examined several different types of each of these operators. </span><span class="kobospan" id="kobo.690.3">Choosing these genetic operators is not an exact science, and we can usually experiment with several choices. </span><span class="kobospan" id="kobo.690.4">But while selection operators can typically work with any chromosome type, the crossover and mutation operators we choose need to match the chromosome type we use; otherwise, they could produce </span><span><span class="kobospan" id="kobo.691.1">invalid chromosomes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.692.1">For the selection operator, we can start with </span><em class="italic"><span class="kobospan" id="kobo.693.1">tournament</span></em><span class="kobospan" id="kobo.694.1"> selection because it is simple and efficient. </span><span class="kobospan" id="kobo.694.2">Later, we can experiment with other selection strategies, such as </span><em class="italic"><span class="kobospan" id="kobo.695.1">roulette wheel</span></em><span class="kobospan" id="kobo.696.1"> selection </span><span><span class="kobospan" id="kobo.697.1">and </span></span><span><em class="italic"><span class="kobospan" id="kobo.698.1">SUS</span></em></span><span><span class="kobospan" id="kobo.699.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.700.1">For the </span><em class="italic"><span class="kobospan" id="kobo.701.1">crossover</span></em><span class="kobospan" id="kobo.702.1"> operator, either the </span><em class="italic"><span class="kobospan" id="kobo.703.1">single-point</span></em><span class="kobospan" id="kobo.704.1"> or </span><em class="italic"><span class="kobospan" id="kobo.705.1">two-point</span></em><span class="kobospan" id="kobo.706.1"> crossover operator will be suitable as the result of crossing over two binary strings using these methods will produce a valid </span><span><span class="kobospan" id="kobo.707.1">binary string.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.708.1">The </span><em class="italic"><span class="kobospan" id="kobo.709.1">mutation</span></em><span class="kobospan" id="kobo.710.1"> operator can be the simple </span><em class="italic"><span class="kobospan" id="kobo.711.1">flip-bit</span></em><span class="kobospan" id="kobo.712.1"> mutation, which works well for </span><span><span class="kobospan" id="kobo.713.1">binary strings.</span></span></p>
<h2 id="_idParaDest-96" class="calibre7"><a id="_idTextAnchor123" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.714.1">Setting the stopping condition</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.715.1">It is always </span><a id="_idIndexMarker178" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.716.1">a good idea to put a limit on the number of generations to guarantee that the algorithm doesn’t run forever. </span><span class="kobospan" id="kobo.716.2">This gives us one </span><span><span class="kobospan" id="kobo.717.1">stopping condition.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.718.1">In addition, since we happen to know the best solution for the OneMax problem – a binary string with all 1s, and a fitness value equal to the length of the individual – we can use that as a second </span><span><span class="kobospan" id="kobo.719.1">stopping condition.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.720.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.721.1">For a real-world problem, we typically don’t have this kind of knowledge </span><span><span class="kobospan" id="kobo.722.1">in advance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.723.1">If either of these </span><a id="_idIndexMarker179" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.724.1">conditions is met – that is, the number of generations reaches the limit </span><em class="italic"><span class="kobospan" id="kobo.725.1">or</span></em><span class="kobospan" id="kobo.726.1"> the best solution is found – the genetic algorithm </span><span><span class="kobospan" id="kobo.727.1">will stop.</span></span></p>
<h2 id="_idParaDest-97" class="calibre7"><a id="_idTextAnchor124" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.728.1">Implementing with DEAP</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.729.1">Putting it</span><a id="_idIndexMarker180" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.730.1"> all together, we can finally start coding our solution to the OneMax problem using the </span><span><span class="kobospan" id="kobo.731.1">DEAP framework.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.732.1">The complete program containing the code snippets shown in this section can be found </span><span><span class="kobospan" id="kobo.733.1">here: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_03/01_OneMax_long.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.734.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_03/01_OneMax_long.py</span></span></a><span><span class="kobospan" id="kobo.735.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.736.1">Setting up</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.737.1">Before </span><a id="_idIndexMarker181" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.738.1">we start the actual genetic algorithm flow, we need to set things up. </span><span class="kobospan" id="kobo.738.2">The DEAP framework has quite a distinct way of doing this, as shown in the rest of </span><span><span class="kobospan" id="kobo.739.1">this section:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.740.1">We start by importing the essential modules of the DEAP framework, followed by a couple of </span><span><span class="kobospan" id="kobo.741.1">useful utilities:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.742.1">
from deap import base
from deap import creator
from deap import tools
import random
import matplotlib.pyplot as plt</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.743.1">Next, we must declare a few constants that set the parameters for the problem and control the behavior of the </span><span><span class="kobospan" id="kobo.744.1">genetic algorithm:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.745.1">
# problem constants:
ONE_MAX_LENGTH = 100   # length of bit string to be
                       # optimized
# Genetic Algorithm constants:
POPULATION_SIZE = 200 # number of individuals in
                      # population
P_CROSSOVER = 0.9     # probability for crossover
P_MUTATION = 0.1      # probability for mutating
                      # an individual
MAX_GENERATIONS = 50  # max number of generations for
                      # stopping condition</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.746.1">One</span><a id="_idIndexMarker182" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.747.1"> important aspect of the genetic algorithm is the use of probability, which introduces a random element to the behavior of the algorithm. </span><span class="kobospan" id="kobo.747.2">However, when experimenting with the code, we may want to be able to run the same experiment several times and get repeatable results. </span><span class="kobospan" id="kobo.747.3">To accomplish this, we must set the random </span><strong class="source-inline1"><span class="kobospan" id="kobo.748.1">seed</span></strong><span class="kobospan" id="kobo.749.1"> function to a constant number of some value, as shown in the following </span><span><span class="kobospan" id="kobo.750.1">code snippet:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.751.1">RANDOM_SEED</span></strong><span class="kobospan1" id="kobo.752.1"> = 42
random.seed(RANDOM_SEED)</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.753.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.754.1">At some point, you may decide to remove these lines of code, so separate runs could produce somewhat </span><span><span class="kobospan" id="kobo.755.1">different results.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.756.1">As we saw earlier in this chapter, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.757.1">Toolbox</span></strong><span class="kobospan" id="kobo.758.1"> class is one of the main utilities provided by the DEAP framework, enabling us to register new functions (or operators) that customize existing functions using pre-set arguments. </span><span class="kobospan" id="kobo.758.2">Here, we’ll use it to create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.759.1">zeroOrOne</span></strong><span class="kobospan" id="kobo.760.1"> operator, which customizes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.761.1">random.randomint(a, b)</span></strong><span class="kobospan" id="kobo.762.1"> function. </span><span class="kobospan" id="kobo.762.2">This function normally returns a random integer, </span><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">N</span></strong><span class="kobospan" id="kobo.764.1">, such that </span><strong class="source-inline1"><span class="kobospan" id="kobo.765.1">a ≤ N ≤ b</span></strong><span class="kobospan" id="kobo.766.1">. </span><span class="kobospan" id="kobo.766.2">By fixing the two arguments, </span><strong class="source-inline1"><span class="kobospan" id="kobo.767.1">a</span></strong><span class="kobospan" id="kobo.768.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.769.1">b</span></strong><span class="kobospan" id="kobo.770.1">, to the values </span><strong class="source-inline1"><span class="kobospan" id="kobo.771.1">0</span></strong><span class="kobospan" id="kobo.772.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.773.1">1</span></strong><span class="kobospan" id="kobo.774.1">, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.775.1">zeroOrOne</span></strong><span class="kobospan" id="kobo.776.1"> operator will randomly return either </span><strong class="source-inline1"><span class="kobospan" id="kobo.777.1">0</span></strong><span class="kobospan" id="kobo.778.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.779.1">1</span></strong><span class="kobospan" id="kobo.780.1"> when it’s called later in the code. </span><span class="kobospan" id="kobo.780.2">The following code snippet defines the </span><strong class="source-inline1"><span class="kobospan" id="kobo.781.1">toolbox</span></strong><span class="kobospan" id="kobo.782.1"> variable, and then uses it to register the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.783.1">zeroOrOne</span></strong></span><span><span class="kobospan" id="kobo.784.1"> operator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.785.1">
toolbox = base.Toolbox()
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.786.1">zeroOrOne</span></strong><span class="kobospan1" id="kobo.787.1">", random.randint, 0, 1)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.788.1">Next, we </span><a id="_idIndexMarker183" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.789.1">need to create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.790.1">Fitness</span></strong><span class="kobospan" id="kobo.791.1"> class. </span><span class="kobospan" id="kobo.791.2">Since we only have one objective here – the sum of digits – and our goal is to maximize it, we’ll choose the </span><strong class="source-inline1"><span class="kobospan" id="kobo.792.1">FitnessMax</span></strong><span class="kobospan" id="kobo.793.1"> strategy and use a </span><strong class="source-inline1"><span class="kobospan" id="kobo.794.1">weights</span></strong><span class="kobospan" id="kobo.795.1"> tuple with a single positive weight, as shown in the following </span><span><span class="kobospan" id="kobo.796.1">code snippet:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.797.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.798.1">FitnessMax</span></strong><span class="kobospan1" id="kobo.799.1">", base.Fitness, \
                weights=</span><strong class="bold1"><span class="kobospan1" id="kobo.800.1">1.0</span></strong><span class="kobospan1" id="kobo.801.1">,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.802.1">in DEAP, the convention is to use a class called </span><strong class="source-inline1"><span class="kobospan" id="kobo.803.1">Individual</span></strong><span class="kobospan" id="kobo.804.1"> to represent each of the population’s individuals. </span><span class="kobospan" id="kobo.804.2">This class is created with the help of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.805.1">creator</span></strong><span class="kobospan" id="kobo.806.1"> tool. </span><span class="kobospan" id="kobo.806.2">In our case, </span><strong class="source-inline1"><span class="kobospan" id="kobo.807.1">list</span></strong><span class="kobospan" id="kobo.808.1"> serves as the base class, which is used as the individual’s chromosome. </span><span class="kobospan" id="kobo.808.2">The class is augmented with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.809.1">fitness</span></strong><span class="kobospan" id="kobo.810.1"> attribute, initialized to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.811.1">FitnessMax</span></strong><span class="kobospan" id="kobo.812.1"> class that we </span><span><span class="kobospan" id="kobo.813.1">defined earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.814.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.815.1">Individual</span></strong><span class="kobospan1" id="kobo.816.1">", list, \
                fitness=creator.FitnessMax)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.817.1">Next, we must register the </span><strong class="source-inline1"><span class="kobospan" id="kobo.818.1">individualCreator</span></strong><span class="kobospan" id="kobo.819.1"> operator, which creates an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.820.1">Individual</span></strong><span class="kobospan" id="kobo.821.1"> class that’s filled with random values of </span><strong class="source-inline1"><span class="kobospan" id="kobo.822.1">0</span></strong><span class="kobospan" id="kobo.823.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.824.1">1</span></strong><span class="kobospan" id="kobo.825.1">. </span><span class="kobospan" id="kobo.825.2">This is done by utilizing the previously defined </span><strong class="source-inline1"><span class="kobospan" id="kobo.826.1">zeroOrOne</span></strong><span class="kobospan" id="kobo.827.1"> operator. </span><span class="kobospan" id="kobo.827.2">This definition makes use of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.828.1">initRepeat</span></strong><span class="kobospan" id="kobo.829.1"> operator that was mentioned earlier as the base class. </span><span class="kobospan" id="kobo.829.2">It can be customized using the </span><span><span class="kobospan" id="kobo.830.1">following arguments:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.831.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.832.1">Individual</span></strong><span class="kobospan" id="kobo.833.1"> class can be used as the container type in which the resulting objects will </span><span><span class="kobospan" id="kobo.834.1">be placed</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.835.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.836.1">zeroOrOne</span></strong><span class="kobospan" id="kobo.837.1"> operator can be used as the function to </span><span><span class="kobospan" id="kobo.838.1">generate objects</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.839.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.840.1">ONE_MAX_LENGTH</span></strong><span class="kobospan" id="kobo.841.1"> constant can be used as the number of objects we want to generate (currently set </span><span><span class="kobospan" id="kobo.842.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.843.1">100</span></strong></span><span><span class="kobospan" id="kobo.844.1">)</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.845.1">Since the </span><a id="_idIndexMarker184" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.846.1">objects that are generated by the </span><strong class="source-inline"><span class="kobospan" id="kobo.847.1">zeroOrOne</span></strong><span class="kobospan" id="kobo.848.1"> operator are integers with random values of </span><strong class="source-inline"><span class="kobospan" id="kobo.849.1">0</span></strong><span class="kobospan" id="kobo.850.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.851.1">1</span></strong><span class="kobospan" id="kobo.852.1">, the resulting </span><strong class="source-inline"><span class="kobospan" id="kobo.853.1">individualCreator</span></strong><span class="kobospan" id="kobo.854.1"> operator will fill an </span><strong class="source-inline"><span class="kobospan" id="kobo.855.1">Individual</span></strong><span class="kobospan" id="kobo.856.1"> instance with 100 randomly generated values of </span><strong class="source-inline"><span class="kobospan" id="kobo.857.1">0</span></strong> <span><span class="kobospan" id="kobo.858.1">or </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.859.1">1</span></strong></span><span><span class="kobospan" id="kobo.860.1">:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.861.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.862.1">individualCreator</span></strong><span class="kobospan1" id="kobo.863.1">",\
                  tools.initRepeat,\
                  creator.Individual,\
                  toolbox.zeroOrOne, ONE_MAX_LENGTH)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.864.1">Lastly, we must register the </span><strong class="source-inline1"><span class="kobospan" id="kobo.865.1">populationCreator</span></strong><span class="kobospan" id="kobo.866.1"> operator, which creates a list of individuals. </span><span class="kobospan" id="kobo.866.2">This definition also uses the </span><strong class="source-inline1"><span class="kobospan" id="kobo.867.1">initRepeat</span></strong><span class="kobospan" id="kobo.868.1"> operator, with the </span><span><span class="kobospan" id="kobo.869.1">following arguments:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.870.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.871.1">list</span></strong><span class="kobospan" id="kobo.872.1"> class as the </span><span><span class="kobospan" id="kobo.873.1">container type</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.874.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.875.1">individualCreator</span></strong><span class="kobospan" id="kobo.876.1"> operator defined earlier as the function that’s used to generate the objects in </span><span><span class="kobospan" id="kobo.877.1">the list</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.878.1">The last argument for </span><strong class="source-inline"><span class="kobospan" id="kobo.879.1">initRepeat</span></strong><span class="kobospan" id="kobo.880.1"> – the number of objects we want to generate – is not given here. </span><span class="kobospan" id="kobo.880.2">This means that when using the </span><strong class="source-inline"><span class="kobospan" id="kobo.881.1">populationCreator</span></strong><span class="kobospan" id="kobo.882.1"> operator, this argument will be expected and used to determine the number of individuals that are created – in other words, the </span><span><span class="kobospan" id="kobo.883.1">population size:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.884.1">
toolbox.register("populationCreator", \
                  tools.initRepeat, \
                  list, toolbox.individualCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.885.1">To </span><a id="_idIndexMarker185" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.886.1">facilitate the fitness calculation (or </span><strong class="source-inline1"><span class="kobospan" id="kobo.887.1">evaluation</span></strong><span class="kobospan" id="kobo.888.1">, in DEAP terminology), we must define a standalone function that accepts an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.889.1">Individual</span></strong><span class="kobospan" id="kobo.890.1"> class and returns the fitness for it. </span><span class="kobospan" id="kobo.890.2">Here, we defined a function named </span><strong class="source-inline1"><span class="kobospan" id="kobo.891.1">oneMaxFitness</span></strong><span class="kobospan" id="kobo.892.1"> that computes the number of 1s in the individual. </span><span class="kobospan" id="kobo.892.2">Since the individual is essentially a list with values of either </span><strong class="source-inline1"><span class="kobospan" id="kobo.893.1">1</span></strong><span class="kobospan" id="kobo.894.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.895.1">0</span></strong><span class="kobospan" id="kobo.896.1">, the Python </span><strong class="source-inline1"><span class="kobospan" id="kobo.897.1">sum()</span></strong><span class="kobospan" id="kobo.898.1"> function can be used for </span><span><span class="kobospan" id="kobo.899.1">this purpose:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.900.1">
def oneMaxFitness(individual):
    return </span><strong class="bold1"><span class="kobospan1" id="kobo.901.1">sum(individual),</span></strong><span class="kobospan1" id="kobo.902.1"> # return a tuple</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.903.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.904.1">As mentioned previously, fitness values in DEAP are represented as tuples, and therefore a comma needs to follow when a single value </span><span><span class="kobospan" id="kobo.905.1">is returned.</span></span></p>
<ol class="calibre15">
<li value="10" class="calibre11"><span class="kobospan" id="kobo.906.1">Next, we must define the evaluate operator as an alias to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.907.1">oneMaxfitness()</span></strong><span class="kobospan" id="kobo.908.1"> function we defined earlier. </span><span class="kobospan" id="kobo.908.2">As you will see later, using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.909.1">evaluate</span></strong><span class="kobospan" id="kobo.910.1"> alias to calculate the fitness is a </span><span><span class="kobospan" id="kobo.911.1">DEAP convention:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.912.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.913.1">evaluate</span></strong><span class="kobospan1" id="kobo.914.1">", oneMaxFitness)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.915.1">As we mentioned in the previous section, the genetic operators are typically created by aliasing existing functions from the </span><strong class="source-inline"><span class="kobospan" id="kobo.916.1">tools</span></strong><span class="kobospan" id="kobo.917.1"> module and setting the argument values as needed. </span><span class="kobospan" id="kobo.917.2">Here, we chose </span><span><span class="kobospan" id="kobo.918.1">the following:</span></span></p><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.919.1">Tournament selection with a tournament size </span><span><span class="kobospan" id="kobo.920.1">of 3</span></span></li><li class="calibre11"><span><span class="kobospan" id="kobo.921.1">Single-point crossover</span></span></li><li class="calibre11"><span><span class="kobospan" id="kobo.922.1">Flip-bit mutation</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.923.1">Note the </span><strong class="source-inline"><span class="kobospan" id="kobo.924.1">indpb</span></strong><span class="kobospan" id="kobo.925.1"> parameter of the </span><strong class="source-inline"><span class="kobospan" id="kobo.926.1">mutFlipBit</span></strong><span class="kobospan" id="kobo.927.1"> function. </span><span class="kobospan" id="kobo.927.2">This function iterates over all the attributes of the individual – a list containing values of 1s and 0s in our case – where each attribute will use this argument value as the probability of flipping (applying the </span><strong class="source-inline"><span class="kobospan" id="kobo.928.1">not</span></strong><span class="kobospan" id="kobo.929.1"> operator to) the attribute value. </span><span class="kobospan" id="kobo.929.2">This value is independent of the mutation probability, which is set by the </span><strong class="source-inline"><span class="kobospan" id="kobo.930.1">P_MUTATION</span></strong><span class="kobospan" id="kobo.931.1"> constant that we defined earlier and has not been used yet. </span><span class="kobospan" id="kobo.931.2">The mutation</span><a id="_idIndexMarker186" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.932.1"> probability serves to decide whether the </span><strong class="source-inline"><span class="kobospan" id="kobo.933.1">mutFlipBit</span></strong><span class="kobospan" id="kobo.934.1"> function is called for a given individual in </span><span><span class="kobospan" id="kobo.935.1">the population:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.936.1">toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.937.1">select</span></strong><span class="kobospan1" id="kobo.938.1">",tools.selTournament,\
                  tournsize=3)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.939.1">mate</span></strong><span class="kobospan1" id="kobo.940.1">", tools.cxOnePoint)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.941.1">mutate</span></strong><span class="kobospan1" id="kobo.942.1">", tools.mutFlipBit,\
                  indpb=1.0/ONE_MAX_LENGTH)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.943.1">We are finally done with our settings and definitions. </span><span class="kobospan" id="kobo.943.2">Now, we’re ready to start the genetic flow, as described in the </span><span><span class="kobospan" id="kobo.944.1">next section.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.945.1">Evolving the solu</span><a id="_idTextAnchor125" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.946.1">tion</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.947.1">The</span><a id="_idIndexMarker187" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.948.1"> genetic flow is implemented in the </span><strong class="source-inline"><span class="kobospan" id="kobo.949.1">main()</span></strong><span class="kobospan" id="kobo.950.1"> function, as described in the </span><span><span class="kobospan" id="kobo.951.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.952.1">We start the flow by creating the initial population using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.953.1">populationCreator</span></strong><span class="kobospan" id="kobo.954.1"> operator we defined earlier, and then using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.955.1">POPULATION_SIZE</span></strong><span class="kobospan" id="kobo.956.1"> constant as the argument for this operator. </span><span class="kobospan" id="kobo.956.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.957.1">generationCounter</span></strong><span class="kobospan" id="kobo.958.1"> variable, which will be used later, is initialized here </span><span><span class="kobospan" id="kobo.959.1">as well:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.960.1">
population = toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.961.1">populationCreator</span></strong><span class="kobospan1" id="kobo.962.1">(n=POPULATION_SIZE)
genera</span><a id="_idTextAnchor126" class="calibre17 pcalibre pcalibre1"/><span class="kobospan1" id="kobo.963.1">tionCounter = 0</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.964.1">To calculate the fitness for each individual in t</span><a id="_idTextAnchor127" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.965.1">he initial population, we can use the Python </span><strong class="source-inline1"><span class="kobospan" id="kobo.966.1">map()</span></strong><span class="kobospan" id="kobo.967.1"> function to apply the </span><strong class="source-inline1"><span class="kobospan" id="kobo.968.1">evaluate</span></strong><span class="kobospan" id="kobo.969.1"> operator to each item in the population. </span><span class="kobospan" id="kobo.969.2">As the </span><strong class="source-inline1"><span class="kobospan" id="kobo.970.1">evaluate</span></strong><span class="kobospan" id="kobo.971.1"> operator is an alias for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.972.1">oneMaxFitness()</span></strong><span class="kobospan" id="kobo.973.1"> function, the resulting </span><strong class="source-inline1"><span class="kobospan" id="kobo.974.1">iterable</span></strong><span class="kobospan" id="kobo.975.1"> consists of the calculated fitness tuple of each individual. </span><span class="kobospan" id="kobo.975.2">It is then converted</span><a id="_idTextAnchor128" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.976.1"> into</span><a id="_idTextAnchor129" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.977.1"> a </span><strong class="source-inline1"><span class="kobospan" id="kobo.978.1">list</span></strong><span class="kobospan" id="kobo.979.1"> type </span><span><span class="kobospan" id="kobo.980.1">of tuples:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.981.1">
fitnessValues = list(map(toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.982.1">evaluate</span></strong><span class="kobospan1" id="kobo.983.1">,\
                     population))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.984.1">Since </span><a id="_idIndexMarker188" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.985.1">the items of </span><strong class="source-inline1"><span class="kobospan" id="kobo.986.1">fitnessValues</span></strong><span class="kobospan" id="kobo.987.1"> match those in the population (which is a list of individuals), we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.988.1">zip()</span></strong><span class="kobospan" id="kobo.989.1"> function to combine them and assign the matching fitness tuple to </span><span><span class="kobospan" id="kobo.990.1">eac</span><a id="_idTextAnchor130" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.991.1">h individual:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.992.1">
for individual, fitnessValue in zip(population, fitnessValues):
    individual.fitness.values = fitnessValue</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.993.1">Next, since we have single-objective fitness, we must extract the first value out of each fitness to </span><span><span class="kobospan" id="kobo.994.1">gather statistics:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.995.1">
fitnessValues = [
    individual.fitness.values[0] for individual in population
]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.996.1">The statistics that are collected will be the max fitness value and the mean (average) fitness value for each generation. </span><span class="kobospan" id="kobo.996.2">Two lists will be used for this purpose. </span><span class="kobospan" id="kobo.996.3">Let’s </span><span><span class="kobospan" id="kobo.997.1">create them:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.998.1">
maxFitnessValues = []
meanFitnessValues = []</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.999.1">We are finally ready for the main loop of the genetic flow. </span><span class="kobospan" id="kobo.999.2">At the top of the loop, we have the stopping conditions. </span><span class="kobospan" id="kobo.999.3">As we decided earlier, one stopping condition will be set by putting a limit on the number of generations, and the other will be set by detecting that we have reached the best solution (a binary string containing </span><span><span class="kobospan" id="kobo.1000.1">all 1s):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1001.1">while</span></strong><span class="kobospan1" id="kobo.1002.1"> max(fitnessValues) &lt; ONE_MAX_LENGTH and \
    generationCounter &lt; MAX_GENERATIONS:</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1003.1">The generation counter is updated next. </span><span class="kobospan" id="kobo.1003.2">It is used by the stopping condition, as well as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1004.1">print</span></strong><span class="kobospan" id="kobo.1005.1"> statements we will </span><span><span class="kobospan" id="kobo.1006.1">see soon:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1007.1">
generationCounter = generationCounter + 1</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1008.1">At the heart of the genetic algorithm are the </span><em class="italic"><span class="kobospan" id="kobo.1009.1">genetic operators</span></em><span class="kobospan" id="kobo.1010.1">, which are applied next. </span><span class="kobospan" id="kobo.1010.2">The first is the </span><em class="italic"><span class="kobospan" id="kobo.1011.1">selection</span></em><span class="kobospan" id="kobo.1012.1"> operator, which can be applied using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1013.1">toolbox.select</span></strong><span class="kobospan" id="kobo.1014.1"> operator we defined as the </span><em class="italic"><span class="kobospan" id="kobo.1015.1">tournament selection</span></em><span class="kobospan" id="kobo.1016.1"> earlier. </span><span class="kobospan" id="kobo.1016.2">Since we already set the tournament size when the operator was defined, we only need to send the population and its length as </span><span><span class="kobospan" id="kobo.1017.1">arguments now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1018.1">
offspring = toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1019.1">select</span></strong><span class="kobospan1" id="kobo.1020.1">(population, len(population))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1021.1">The </span><a id="_idIndexMarker189" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1022.1">selected individuals, now residing in a list called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1023.1">offspring</span></strong><span class="kobospan" id="kobo.1024.1">, must be cloned so that we can apply the next genetic operators without </span><a id="_idTextAnchor131" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1025.1">affec</span><a id="_idTextAnchor132" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1026.1">ting the </span><span><span class="kobospan" id="kobo.1027.1">original population:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1028.1">
offspring = list(map(toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1029.1">clone</span></strong><span class="kobospan1" id="kobo.1030.1">, offspring))</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1031.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1032.1">Despite the name </span><strong class="source-inline1"><span class="kobospan" id="kobo.1033.1">offspring</span></strong><span class="kobospan" id="kobo.1034.1">, these are still clones of individuals from the previous generation, and we still need to mate them using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1035.1">crossover</span></strong><span class="kobospan" id="kobo.1036.1"> operator to create the </span><span><span class="kobospan" id="kobo.1037.1">actual offspring.</span></span></p>
<ol class="calibre15">
<li value="10" class="calibre11"><span class="kobospan" id="kobo.1038.1">The next genetic operator is </span><strong class="source-inline1"><span class="kobospan" id="kobo.1039.1">crossover</span></strong><span class="kobospan" id="kobo.1040.1">. </span><span class="kobospan" id="kobo.1040.2">It was defined as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1041.1">toolbox.mate</span></strong><span class="kobospan" id="kobo.1042.1"> operator earlier, and is aliasing a single-point crossover. </span><span class="kobospan" id="kobo.1042.2">We use Python extended slices to pair every even-indexed item of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1043.1">offspring</span></strong><span class="kobospan" id="kobo.1044.1"> list w</span><a id="_idTextAnchor133" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1045.1">ith the one following it. </span><span class="kobospan" id="kobo.1045.2">Then, we utilize the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1046.1">random()</span></strong><span class="kobospan" id="kobo.1047.1"> function to flip a coin using the </span><em class="italic"><span class="kobospan" id="kobo.1048.1">crossover probability</span></em><span class="kobospan" id="kobo.1049.1"> set by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1050.1">P_CROSSOVER</span></strong><span class="kobospan" id="kobo.1051.1"> constant. </span><span class="kobospan" id="kobo.1051.2">This will decide if the pair of individuals will be crossed over or remain intact. </span><span class="kobospan" id="kobo.1051.3">Lastly, we delete the fitness values of the children since they have been modified and their</span><a id="_idIndexMarker190" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1052.1"> existing fitness values are no </span><span><span class="kobospan" id="kobo.1053.1">l</span><a id="_idTextAnchor134" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1054.1">onger v</span><a id="_idTextAnchor135" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1055.1">alid:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1056.1">
for child1, child2 in zip(offspring[::2], offspring[1::2]):
    if random.random() &lt; </span><strong class="bold1"><span class="kobospan1" id="kobo.1057.1">P_CROSSOVER</span></strong><span class="kobospan1" id="kobo.1058.1">:
        toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1059.1">mate</span></strong><span class="kobospan1" id="kobo.1060.1">(child1, child2)
        del child1.fitness.values
        del child2.fitness.values</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1061.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1062.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1063.1">mate</span></strong><span class="kobospan" id="kobo.1064.1"> function takes two individuals as arguments and modifies them in place, meaning they don’t need to </span><span><span class="kobospan" id="kobo.1065.1">be reassigned.</span></span></p>
<ol class="calibre15">
<li value="11" class="calibre11"><span class="kobospan" id="kobo.1066.1">The final genetic operator to be applied is the </span><em class="italic"><span class="kobospan" id="kobo.1067.1">mutation</span></em><span class="kobospan" id="kobo.1068.1">, wh</span><a id="_idTextAnchor136" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1069.1">ich we registered earlier as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1070.1">toolbox.mutate</span></strong><span class="kobospan" id="kobo.1071.1"> operator, and was set to be a </span><em class="italic"><span class="kobospan" id="kobo.1072.1">flip-bit</span></em><span class="kobospan" id="kobo.1073.1"> mutation operation. </span><span class="kobospan" id="kobo.1073.2">Iterating over all </span><strong class="source-inline1"><span class="kobospan" id="kobo.1074.1">offspring</span></strong><span class="kobospan" id="kobo.1075.1"> items, the mutation operator will be applied at the probability set by the mutation probability constant, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1076.1">P_MUTATION</span></strong><span class="kobospan" id="kobo.1077.1">. </span><span class="kobospan" id="kobo.1077.2">If the individual gets mutated, we must delete its fitness value (if it exists). </span><span class="kobospan" id="kobo.1077.3">This value could have carried over with the individual from the previous generation, and after mutation, it is no longer correct and needs to </span><span><span class="kobospan" id="kobo.1078.1">be recalculated:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1079.1">
for mutant in offspring:
    if random.random() &lt; </span><strong class="bold1"><span class="kobospan1" id="kobo.1080.1">P_MUTATION</span></strong><span class="kobospan1" id="kobo.1081.1">:
        toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1082.1">mutate</span></strong><span class="kobospan1" id="kobo.1083.1">(mutant)
        del mutant.fitness.values</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1084.1">Individuals that were not crossed over or mutated remained intact, and therefore their existing fitness values, which were already calculated in a previous generation, don’t need to be calculated again. </span><span class="kobospan" id="kobo.1084.2">The rest of the individuals will have this value empty. </span><span class="kobospan" id="kobo.1084.3">Now, we must find those fresh individuals using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1085.1">Fitness</span></strong><span class="kobospan" id="kobo.1086.1"> class’ </span><strong class="source-inline1"><span class="kobospan" id="kobo.1087.1">valid</span></strong><span class="kobospan" id="kobo.1088.1"> property, then calculate the new fitness for them</span><a id="_idIndexMarker191" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1089.1"> similarly to how to did the original calculation for </span><span><span class="kobospan" id="kobo.1090.1">fitness values:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1091.1">
freshIndividuals = [
    ind for ind in offspring if not ind.fitness.</span><strong class="bold1"><span class="kobospan1" id="kobo.1092.1">valid</span></strong><span class="kobospan1" id="kobo.1093.1">]
freshFitnessValues = list(map(toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1094.1">evaluate</span></strong><span class="kobospan1" id="kobo.1095.1">, 
    freshIndividuals))
for individual, fitnessValue in zip(freshIndividuals, 
    freshFitnessValues
):
    individual.</span><strong class="bold1"><span class="kobospan1" id="kobo.1096.1">fitness</span></strong><span class="kobospan1" id="kobo.1097.1">.values = fitnessValue</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1098.1">Now that the genetic operators are done, it is time</span><a id="_idTextAnchor137" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1099.1"> to replace the old population with the </span><span><span class="kobospan" id="kobo.1100.1">new one:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1101.1">
population[:] = offspring</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1102.1">Before we continue to the next round, the current fitness values are collected to allow for statistical gathering. </span><span class="kobospan" id="kobo.1102.2">Since the fitness value is a (single element) tuple, we need to select the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1103.1">[</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.1104.1">0]</span></strong></span><span><span class="kobospan" id="kobo.1105.1"> index:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1106.1">
fitnessValues = [ind.fitness.</span><strong class="bold1"><span class="kobospan1" id="kobo.1107.1">values[0]</span></strong><span class="kobospan1" id="kobo.1108.1"> for ind in population]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1109.1">The max and mean fitness values are then found, at which point their values get appended to the statistics accumulators and a summary line is </span><span><span class="kobospan" id="kobo.1110.1">printed out:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1111.1">maxFitness</span></strong><span class="kobospan1" id="kobo.1112.1"> = max(fitnessValues)
</span><strong class="bold1"><span class="kobospan1" id="kobo.1113.1">meanFitness</span></strong><span class="kobospan1" id="kobo.1114.1"> = sum(fitnessValues) / len(population)
maxFitnessValues.append(maxFitness)
meanFitnessValues.append(meanFitness)
print(f"- Generation {</span><strong class="bold1"><span class="kobospan1" id="kobo.1115.1">generationCounter</span></strong><span class="kobospan1" id="kobo.1116.1">}:
Max Fitness = {</span><strong class="bold1"><span class="kobospan1" id="kobo.1117.1">maxFitness</span></strong><span class="kobospan1" id="kobo.1118.1">}, \
    Avg Fitness = {</span><strong class="bold1"><span class="kobospan1" id="kobo.1119.1">meanFitness</span></strong><span class="kobospan1" id="kobo.1120.1">}")</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1121.1">In </span><a id="_idIndexMarker192" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1122.1">addition, we must locate the index of the (first) best individual using the max fitness value we just found and print this </span><span><span class="kobospan" id="kobo.1123.1">individual out:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1124.1">
best_index = fitnessValues.</span><strong class="bold1"><span class="kobospan1" id="kobo.1125.1">index</span></strong><span class="kobospan1" id="kobo.1126.1">(</span><strong class="bold1"><span class="kobospan1" id="kobo.1127.1">max</span></strong><span class="kobospan1" id="kobo.1128.1">(fitnessValues))
print("Best Individual = ", *population[best_index], "\n")</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1129.1">Once a stopping condition is activated and the genetic algorithm flow concludes, we can use the statistics accumulators to plot a couple of graphs using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1130.1">matplotlib</span></strong><span class="kobospan" id="kobo.1131.1"> library. </span><span class="kobospan" id="kobo.1131.2">We can use the following code snippet to draw a graph illustrating the progress of the best and average fitness values throughout </span><span><span class="kobospan" id="kobo.1132.1">the generations:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1133.1">
plt.plot(</span><strong class="bold1"><span class="kobospan1" id="kobo.1134.1">maxFitnessValues</span></strong><span class="kobospan1" id="kobo.1135.1">, color='red')
plt.plot(</span><strong class="bold1"><span class="kobospan1" id="kobo.1136.1">meanFitnessValues</span></strong><span class="kobospan1" id="kobo.1137.1">, color='green')
plt.xlabel('Generation')
plt.ylabel('Max / Average Fitness')
plt.title('Max and Average fitness over Generations')
plt.show()</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1138.1">We are finally ready to test our first genetic algorithm – let’s run it to find out if it finds the </span><span><span class="kobospan" id="kobo.1139.1">OneMax solution.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1140.1">Running the program</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1141.1">When</span><a id="_idIndexMarker193" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1142.1"> running the program described in the previous sections, we get the </span><span><span class="kobospan" id="kobo.1143.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1144.1">
- Generation 1: Max Fitness = 65.0, Avg Fitness = 53.575
Best Individual = 1 1 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 0 0 1 0 1 0 0 0 1 1 1 1 1 0 1 1 1 1 0 1 0 1 1 1 1 0 0 1 1 111101111101111111000 0 1 0 1 0 1 1 1 0 1 1 0 0 0 1 1 1 0011111111111100
...
</span><span class="kobospan1" id="kobo.1144.2">- Generation 40: Max Fitness = 100.0, Avg Fitness = 98.29
Best Individual = 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 111111111111111111111 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1111111111111111</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1145.1">As you </span><a id="_idIndexMarker194" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1146.1">can see, after 40 generations, an </span><em class="italic"><span class="kobospan" id="kobo.1147.1">all-1</span></em><span class="kobospan" id="kobo.1148.1"> solution was found, which yielded a fitness of 100 and stopped the genetic flow. </span><span class="kobospan" id="kobo.1148.2">The </span><em class="italic"><span class="kobospan" id="kobo.1149.1">average fitness</span></em><span class="kobospan" id="kobo.1150.1">, which started at a value of around 53, ended at a value close </span><span><span class="kobospan" id="kobo.1151.1">to 100.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1152.1">The graph that’s plotted by </span><strong class="source-inline"><span class="kobospan" id="kobo.1153.1">matplotlib</span></strong><span class="kobospan" id="kobo.1154.1"> is </span><span><span class="kobospan" id="kobo.1155.1">shown here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer043">
<span class="kobospan" id="kobo.1156.1"><img alt="Figure 3.1: Stats of the program solving the OneMax problem" src="image/B20851_03_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1157.1">Figure 3.1: Stats of the program solving the OneMax problem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1158.1">This plot</span><a id="_idIndexMarker195" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1159.1"> illustrates how max fitness (the red line) increases over generations with incremental leaps, while the average fitness (the green line) keeps </span><span><span class="kobospan" id="kobo.1160.1">progressing smoothly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1161.1">Now that we’ve solved the OneMax problem using the DEAP framework, let’s move on to the next section and find out how we can make our code </span><span><span class="kobospan" id="kobo.1162.1">more concise.</span></span></p>
<h1 id="_idParaDest-98" class="calibre5"><a id="_idTextAnchor138" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1163.1">Using built-in algorithms</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1164.1">The</span><a id="_idIndexMarker196" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1165.1"> DEAP framework</span><a id="_idIndexMarker197" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1166.1"> comes with sev</span><a id="_idTextAnchor139" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1167.1">eral built-in evolutionary algorithms provided by the </span><strong class="source-inline"><span class="kobospan" id="kobo.1168.1">algorithms</span></strong><span class="kobospan" id="kobo.1169.1"> module. </span><span class="kobospan" id="kobo.1169.2">One of them, </span><strong class="source-inline"><span class="kobospan" id="kobo.1170.1">eaSimple</span></strong><span class="kobospan" id="kobo.1171.1">, implements the genetic algorithm flow we have been using, and can replace most of the code we had in the main method. </span><span class="kobospan" id="kobo.1171.2">Other useful DEAP objects, </span><strong class="source-inline"><span class="kobospan" id="kobo.1172.1">Statistics</span></strong><span class="kobospan" id="kobo.1173.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.1174.1">Logbook</span></strong><span class="kobospan" id="kobo.1175.1">, can be used for statistics gathering and printing, as we will </span><span><span class="kobospan" id="kobo.1176.1">soon see.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1177.1">The program</span><a id="_idIndexMarker198" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1178.1"> described in this section implements the same solution to the OneMax problem as the program discussed in the previous section but with less code. </span><span class="kobospan" id="kobo.1178.2">The only differences </span><a id="_idIndexMarker199" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1179.1">can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1180.1">main</span></strong><span class="kobospan" id="kobo.1181.1"> method. </span><span class="kobospan" id="kobo.1181.2">We will describe these differences in the following </span><span><span class="kobospan" id="kobo.1182.1">code snippets.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1183.1">The complete program can be found </span><span><span class="kobospan" id="kobo.1184.1">here: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_03/02_OneMax_short.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1185.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_03/02_OneMax_short.py</span></span></a><span><span class="kobospan" id="kobo.1186.1">.</span></span></p>
<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor140" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1187.1">The Statistics object</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1188.1">The first </span><a id="_idIndexMarker200" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1189.1">change we will make is in the way statistics are being gathered. </span><span class="kobospan" id="kobo.1189.2">To this end, we will now take advantage of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1190.1">tools.Statistics</span></strong><span class="kobospan" id="kobo.1191.1"> class provided by DEAP. </span><span class="kobospan" id="kobo.1191.2">This utility enables us to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.1192.1">statistics</span></strong><span class="kobospan" id="kobo.1193.1"> object using a key argument, which is a function that will be applied to the data on which the statistics </span><span><span class="kobospan" id="kobo.1194.1">are computed:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1195.1">Since the data we plan to provide is the population of each generation, we’ll set the key</span><a id="_idTextAnchor141" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1196.1"> function to one that extracts the fitness value(s) from </span><span><span class="kobospan" id="kobo.1197.1">each individual:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1198.1">
stats = tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.1199.1">Statistics</span></strong><span class="kobospan1" id="kobo.1200.1">(lambda ind: ind.fitness.</span><strong class="bold1"><span class="kobospan1" id="kobo.1201.1">values</span></strong><span class="kobospan1" id="kobo.1202.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1203.1">We can now register various functions that can be applied to these values at each step. </span><span class="kobospan" id="kobo.1203.2">In our example, we only use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1204.1">max</span></strong><span class="kobospan" id="kobo.1205.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1206.1">mean</span></strong><span class="kobospan" id="kobo.1207.1"> NumPy functions, but others (such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.1208.1">min</span></strong><span class="kobospan" id="kobo.1209.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1210.1">std</span></strong><span class="kobospan" id="kobo.1211.1">) can be registered </span><span><span class="kobospan" id="kobo.1212.1">as well:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1213.1">
stats.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1214.1">max</span></strong><span class="kobospan1" id="kobo.1215.1">", numpy.max)
stats.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1216.1">avg</span></strong><span class="kobospan1" id="kobo.1217.1">", numpy.mean)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1218.1">As we will see soon, the collected statistics will be returned in an object called </span><strong class="source-inline"><span class="kobospan" id="kobo.1219.1">logbook</span></strong><span class="kobospan" id="kobo.1220.1"> at the end of </span><span><span class="kobospan" id="kobo.1221.1">the run.</span></span></p>
<h2 id="_idParaDest-100" class="calibre7"><a id="_idTextAnchor142" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1222.1">The algorithm</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1223.1">Now, it’s time for the actual flow. </span><span class="kobospan" id="kobo.1223.2">This</span><a id="_idIndexMarker201" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1224.1"> is done with a single call to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1225.1">algorithms.eaSimple</span></strong><span class="kobospan" id="kobo.1226.1"> method, one of the built-in evolutionary algorithms provided by the </span><strong class="source-inline"><span class="kobospan" id="kobo.1227.1">algorithms</span></strong><span class="kobospan" id="kobo.1228.1"> module of DEAP. </span><span class="kobospan" id="kobo.1228.2">When we call the method, we provide it with </span><strong class="source-inline"><span class="kobospan" id="kobo.1229.1">population</span></strong><span class="kobospan" id="kobo.1230.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1231.1">toolbox</span></strong><span class="kobospan" id="kobo.1232.1">, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.1233.1">statistics</span></strong><span class="kobospan" id="kobo.1234.1"> object, among </span><span><span class="kobospan" id="kobo.1235.1">other parameters:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1236.1">
population, logbook = algorithms.</span><strong class="bold1"><span class="kobospan1" id="kobo.1237.1">eaSimple</span></strong><span class="kobospan1" id="kobo.1238.1">(population, toolbox,
    cxpb=P_CROSSOVER,
    mutpb=P_MUTATION,
    ngen=MAX_GENERATIONS,
    stats=stats,
    verbose=True)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1239.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1240.1">algorithms.eaSimple</span></strong><span class="kobospan" id="kobo.1241.1"> method assumes that we previously used </span><strong class="source-inline"><span class="kobospan" id="kobo.1242.1">toolbox</span></strong><span class="kobospan" id="kobo.1243.1"> to register the following operators – </span><strong class="source-inline"><span class="kobospan" id="kobo.1244.1">evaluate</span></strong><span class="kobospan" id="kobo.1245.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1246.1">select</span></strong><span class="kobospan" id="kobo.1247.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1248.1">mate</span></strong><span class="kobospan" id="kobo.1249.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.1250.1">mutate</span></strong><span class="kobospan" id="kobo.1251.1"> – something we did when we created the original program. </span><span class="kobospan" id="kobo.1251.2">The stopping condition here is set by the value of </span><strong class="source-inline"><span class="kobospan" id="kobo.1252.1">ngen</span></strong><span class="kobospan" id="kobo.1253.1">, which specifies the number of generations to run the </span><span><span class="kobospan" id="kobo.1254.1">algorithm for.</span></span></p>
<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor143" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1255.1">The logbook</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1256.1">When the flow is done, the</span><a id="_idIndexMarker202" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1257.1"> algorithm returns two objects – the final population and a </span><strong class="source-inline"><span class="kobospan" id="kobo.1258.1">logbook</span></strong><span class="kobospan" id="kobo.1259.1"> object containing the statistics that were collected. </span><span class="kobospan" id="kobo.1259.2">We can now extract the desired statistics from the logbook using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1260.1">select()</span></strong><span class="kobospan" id="kobo.1261.1"> method so that we can use them for plotting, as we </span><span><span class="kobospan" id="kobo.1262.1">did previously:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1263.1">
maxFitnessValues, meanFitnessValues = logbook.</span><strong class="bold1"><span class="kobospan1" id="kobo.1264.1">select</span></strong><span class="kobospan1" id="kobo.1265.1">("max", "avg")</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1266.1">We are now ready to run this slimmer version of </span><span><span class="kobospan" id="kobo.1267.1">the program.</span></span></p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor144" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1268.1">Running the program</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1269.1">When running</span><a id="_idIndexMarker203" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1270.1"> the program with the same parameter values and settings that we used previously, the printouts will be </span><span><span class="kobospan" id="kobo.1271.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1272.1">
gen   nevals  max    avg
0     200     61     49.695
1     193     65     53.575
...
</span><span class="kobospan1" id="kobo.1272.2">39    192     99     98.04
40    173     100    98.29
...
</span><span class="kobospan1" id="kobo.1272.3">49    187     100    99.83
50    184     100    99.89</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1273.1">These printouts are automatically generated by the </span><strong class="source-inline"><span class="kobospan" id="kobo.1274.1">algorithms.eaSimple</span></strong><span class="kobospan" id="kobo.1275.1"> method, according to the way we defined the </span><strong class="source-inline"><span class="kobospan" id="kobo.1276.1">statistics</span></strong><span class="kobospan" id="kobo.1277.1"> object sent to it, as the </span><strong class="source-inline"><span class="kobospan" id="kobo.1278.1">ve</span><a id="_idTextAnchor145" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1279.1">rbose</span></strong><span class="kobospan" id="kobo.1280.1"> argument was set </span><span><span class="kobospan" id="kobo.1281.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1282.1">True</span></strong></span><span><span class="kobospan" id="kobo.1283.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1284.1">The results are numerically similar to what we saw in the previous program, with </span><span><span class="kobospan" id="kobo.1285.1">two differences:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1286.1">There is a printout for generation 0; this was not included in the </span><span><span class="kobospan" id="kobo.1287.1">previous program.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1288.1">The genetic flow here continues to the 50th generation as this was the only stopping condition. </span><span class="kobospan" id="kobo.1288.2">In the previous program, there was an additional stopping condition that stopped the flow at the 40th generation since the best solution (that we happened to know beforehand) </span><span><span class="kobospan" id="kobo.1289.1">was reached.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1290.1">We can obs</span><a id="_idTextAnchor146" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1291.1">erve the same behavior in the new graph plot. </span><span class="kobospan" id="kobo.1291.2">This graph is similar to the one we saw before but it continues to the 50th generation, even though the best result was already reached at the </span><span><span class="kobospan" id="kobo.1292.1">40th generation:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer044">
<span class="kobospan" id="kobo.1293.1"><img alt="Figure 3.2: Stats of the program solving the OneMax problem using the built-in algorithm" src="image/B20851_03_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1294.1">Figure 3.2: Stats of the program solving the OneMax problem using the built-in algorithm</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1295.1">Consequently, starting</span><a id="_idIndexMarker204" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1296.1"> at the 40th generation, the value of the best fitness (the red line) no longer changes, while the average fitness (the green line) keeps climbing until it almost reaches the same max value. </span><span class="kobospan" id="kobo.1296.2">This means that by the end of this run, nearly all individuals are identical to the </span><span><span class="kobospan" id="kobo.1297.1">best one.</span></span></p>
<h2 id="_idParaDest-103" class="calibre7"><a id="_idTextAnchor147" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1298.1">Adding the hall of fame feature</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1299.1">One</span><a id="_idIndexMarker205" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1300.1"> additional feature of the built-in </span><strong class="source-inline"><span class="kobospan" id="kobo.1301.1">algorithms.eaSimple</span></strong><span class="kobospan" id="kobo.1302.1"> method</span><a id="_idIndexMarker206" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1303.1"> is the </span><strong class="bold"><span class="kobospan" id="kobo.1304.1">hall of fame</span></strong><span class="kobospan" id="kobo.1305.1"> (or </span><strong class="bold"><span class="kobospan" id="kobo.1306.1">HOF</span></strong><span class="kobospan" id="kobo.1307.1"> for short). </span><span class="kobospan" id="kobo.1307.2">Implemented in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1308.1">tools</span></strong><span class="kobospan" id="kobo.1309.1"> module, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1310.1">HallOfFame</span></strong><span class="kobospan" id="kobo.1311.1"> class can be used to retain the best individuals that ever existed in the population during the evolution, even if they have been lost at some point due to selection, crossover, or mutation. </span><span class="kobospan" id="kobo.1311.2">The hall of fame is continuously sorted so that the first element is the first individual that has the best fitness value </span><span><span class="kobospan" id="kobo.1312.1">ever seen.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1313.1">The complete program containing the code snippets shown in this section can be found </span><span><span class="kobospan" id="kobo.1314.1">here: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_03/03_OneMax_short_hof.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1315.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_03/03_OneMax_short_hof.py</span></span></a><span><span class="kobospan" id="kobo.1316.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1317.1">To add the </span><a id="_idIndexMarker207" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1318.1">hall of fame functionality, let’s make a few modifications to the </span><span><span class="kobospan" id="kobo.1319.1">previous program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1320.1">We start by defining a constant for the number of individuals we want to keep in the hall of fame. </span><span class="kobospan" id="kobo.1320.2">We will add this line to the constant </span><span><span class="kobospan" id="kobo.1321.1">definition section:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1322.1">HALL_OF_FAME_SIZE</span></strong><span class="kobospan1" id="kobo.1323.1"> = 10</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1324.1">Just before calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1325.1">eaSimple</span></strong><span class="kobospan" id="kobo.1326.1"> algorithm, we’ll create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1327.1">HallOfFame</span></strong><span class="kobospan" id="kobo.1328.1"> object with </span><span><span class="kobospan" id="kobo.1329.1">that size:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1330.1">
hof = tools.HallOfFame(</span><strong class="bold1"><span class="kobospan1" id="kobo.1331.1">HALL_OF_FAME_SIZE</span></strong><span class="kobospan1" id="kobo.1332.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1333.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1334.1">HallOfFame</span></strong><span class="kobospan" id="kobo.1335.1"> object is sent as an argument to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1336.1">eaSimple</span></strong><span class="kobospan" id="kobo.1337.1"> algorithm, which internally updates it during the run of the genetic </span><span><span class="kobospan" id="kobo.1338.1">algorithm flow:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1339.1">
population, logbook = algorithms.eaSimple(\
    population, toolbox, cxpb=P_CROSSOVER, \
    mutpb=P_MUTATION, ngen=MAX_GENERATIONS, \
    stats=stats, </span><strong class="bold1"><span class="kobospan1" id="kobo.1340.1">halloffame</span></strong><span class="kobospan1" id="kobo.1341.1">=hof, verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1342.1">When the algorithm is done, we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1343.1">HallOfFame</span></strong><span class="kobospan" id="kobo.1344.1"> object’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.1345.1">items</span></strong><span class="kobospan" id="kobo.1346.1"> attribute to access the list of individuals who were inducted into the hall </span><span><span class="kobospan" id="kobo.1347.1">of fame:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1348.1">
print("Hall of Fame Individuals = ", </span><strong class="bold1"><span class="kobospan1" id="kobo.1349.1">*hof.items</span></strong><span class="kobospan1" id="kobo.1350.1">, sep="\n")
print("Best Ever Individual = ", </span><strong class="bold1"><span class="kobospan1" id="kobo.1351.1">hof.items[0]</span></strong><span class="kobospan1" id="kobo.1352.1">)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1353.1">The printed results look as follows – the best individual consists of all 1s, followed by various individuals that have a 0 value in </span><span><span class="kobospan" id="kobo.1354.1">various locations:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.1355.1">Hall of Fame Individuals =
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, </span><strong class="bold1"><span class="kobospan1" id="kobo.1356.1">0</span></strong><span class="kobospan1" id="kobo.1357.1">, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
...</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1358.1">The</span><a id="_idIndexMarker208" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1359.1"> best individual is the same one that was printed </span><span><span class="kobospan" id="kobo.1360.1">first previously:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1361.1">
Best Ever Individual = [1, 1, 1, 1, ..., 0, ..., 1]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1362.1">From now on, we will use these features – the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1363.1">statistics</span></strong><span class="kobospan" id="kobo.1364.1"> object and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1365.1">logbook</span></strong><span class="kobospan" id="kobo.1366.1">, the built-in </span><strong class="source-inline1"><span class="kobospan" id="kobo.1367.1">eaSimple</span></strong><span class="kobospan" id="kobo.1368.1"> algorithm, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1369.1">HallOfFame</span></strong><span class="kobospan" id="kobo.1370.1"> – in all the programs </span><span><span class="kobospan" id="kobo.1371.1">we create.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1372.1">Now that we’ve learned how to use the inbuilt algorithms, we’ll experiment with them to find their differences and find the best algorithm for </span><span><span class="kobospan" id="kobo.1373.1">various uses.</span></span></p>
<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor148" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1374.1">Experimenting with the algorithm’s settings</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1375.1">We can now</span><a id="_idIndexMarker209" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1376.1"> experiment with the various settings and definitions we placed into the</span><a id="_idIndexMarker210" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1377.1"> program and observe any changes in their behavior </span><span><span class="kobospan" id="kobo.1378.1">and results.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1379.1">In each of the following subsections, we’ll start from the original program settings and make one or more changes. </span><span class="kobospan" id="kobo.1379.2">You are encouraged to experiment with making your own modifications, as well as combining several modifications to be made to the </span><span><span class="kobospan" id="kobo.1380.1">same program.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1381.1">Bear in mind that the effects of changes we make may be specific to the problem at hand – a simple </span><em class="italic"><span class="kobospan" id="kobo.1382.1">OneMax</span></em><span class="kobospan" id="kobo.1383.1">, in our case – and may be different for other types </span><span><span class="kobospan" id="kobo.1384.1">of problems.</span></span></p>
<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor149" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1385.1">Population size and number of generations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1386.1">We will </span><a id="_idIndexMarker211" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1387.1">start our experimentation by making modifications to the </span><strong class="bold"><span class="kobospan" id="kobo.1388.1">population size</span></strong><span class="kobospan" id="kobo.1389.1"> and the number of generations used by the </span><span><span class="kobospan" id="kobo.1390.1">genetic algorithm:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1391.1">The size of the population is determined by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1392.1">POPULATION_SIZE</span></strong><span class="kobospan" id="kobo.1393.1"> constant. </span><span class="kobospan" id="kobo.1393.2">We will start by increasing the value of this constant from 200 </span><span><span class="kobospan" id="kobo.1394.1">to 400:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1395.1">
POPULATION_SIZE = </span><strong class="bold1"><span class="kobospan1" id="kobo.1396.1">400</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.1397.1">This modification accelerates the genetic flow. </span><span class="kobospan" id="kobo.1397.2">The best solution is now found after 22 generations, as shown in the </span><span><span class="kobospan" id="kobo.1398.1">following figure:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer045">
<span class="kobospan" id="kobo.1399.1"><img alt="Figure 3.3: Stats of the program solving the OneMax problem after increasing the population size to 400" src="image/B20851_03_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1400.1">Figure 3.3: Stats of the program solving the OneMax problem after increasing the population size to 400</span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.1401.1">Next, we</span><a id="_idIndexMarker212" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1402.1"> will try reducing the population size </span><span><span class="kobospan" id="kobo.1403.1">to 100:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1404.1">
POPULATION_SIZE = </span><strong class="bold1"><span class="kobospan1" id="kobo.1405.1">100</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1406.1">This modification slows down the convergence of the algorithm, which will no longer reach the best possible value after </span><span><span class="kobospan" id="kobo.1407.1">50 generations:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer046">
<span class="kobospan" id="kobo.1408.1"><img alt="Figure 3.4: Stats of the program solving the OneMax problem after decreasing the population size to 100" src="image/B20851_03_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1409.1">Figure 3.4: Stats of the program solving the OneMax problem after decreasing the population size to 100</span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.1410.1">To </span><a id="_idIndexMarker213" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1411.1">compensate, let’s try increasing the value of </span><strong class="source-inline1"><span class="kobospan" id="kobo.1412.1">MAX_GENERATIONS</span></strong> <span><span class="kobospan" id="kobo.1413.1">to 80:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1414.1">
MAX_GENERATIONS = 80</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1415.1">We find that the best solution is now reached after </span><span><span class="kobospan" id="kobo.1416.1">68 generations:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer047">
<span class="kobospan" id="kobo.1417.1"><img alt="Figure 3.5: Stats of the program solving the OneMax problem after increasing the number of generations to 80" src="image/B20851_03_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1418.1">Figure 3.5: Stats of the program solving the OneMax problem after increasing the number of generations to 80</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1419.1">This </span><a id="_idIndexMarker214" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1420.1">behavior is typical of genetic-algorithm-based solutions – increasing the population will require fewer generations to reach a solution. </span><span class="kobospan" id="kobo.1420.2">However, the computational and memory requirements increase with the population size, and we typically aspire to find a moderate population size that will provide a solution within a reasonable amount </span><span><span class="kobospan" id="kobo.1421.1">of time.</span></span></p>
<h2 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1422.1">Crossover operator</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1423.1">Let’s reset </span><a id="_idIndexMarker215" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1424.1">our changes and go back to the original settings (50 generations, population size 200). </span><span class="kobospan" id="kobo.1424.2">We are now ready to experiment with the </span><strong class="bold"><span class="kobospan" id="kobo.1425.1">crossover</span></strong><span class="kobospan" id="kobo.1426.1"> operator, which</span><a id="_idIndexMarker216" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1427.1"> is responsible for creating offspring from </span><span><span class="kobospan" id="kobo.1428.1">parent individuals.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1429.1">Changing the crossover type</span><a id="_idIndexMarker217" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1430.1"> from a </span><strong class="bold"><span class="kobospan" id="kobo.1431.1">single-point</span></strong><span class="kobospan" id="kobo.1432.1"> to a </span><strong class="bold"><span class="kobospan" id="kobo.1433.1">two-point</span></strong><span class="kobospan" id="kobo.1434.1"> crossover is simple as we now </span><a id="_idIndexMarker218" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1435.1">define the </span><strong class="source-inline"><span class="kobospan" id="kobo.1436.1">mate</span></strong><span class="kobospan" id="kobo.1437.1"> operator </span><span><span class="kobospan" id="kobo.1438.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1439.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1440.1">mate</span></strong><span class="kobospan1" id="kobo.1441.1">", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.1442.1">cxTwoPoint</span></strong><span class="kobospan1" id="kobo.1443.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1444.1">The algorithm </span><a id="_idIndexMarker219" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1445.1">now </span><a id="_idIndexMarker220" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1446.1">finds the best solution after only </span><span><span class="kobospan" id="kobo.1447.1">27 generations:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer048">
<span class="kobospan" id="kobo.1448.1"><img alt="Figure 3.6: Stats of the program solving the OneMax problem after switching to a two-point crossover" src="image/B20851_03_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1449.1">Figure 3.6: Stats of the program solving the OneMax problem after switching to a two-point crossover</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1450.1">This behavior is typical of genetic algorithms that utilize binary string representation as two-point crossover provides a more versatile way to combine two parents and mix their genes in comparison to the </span><span><span class="kobospan" id="kobo.1451.1">single-point crossover.</span></span></p>
<h2 id="_idParaDest-107" class="calibre7"><a id="_idTextAnchor151" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1452.1">Mutation operator</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1453.1">We will </span><a id="_idIndexMarker221" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1454.1">now reset our changes again as we get ready to experiment</span><a id="_idIndexMarker222" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1455.1"> with the </span><strong class="bold"><span class="kobospan" id="kobo.1456.1">mutation</span></strong><span class="kobospan" id="kobo.1457.1"> operator, which is responsible for introducing random modifications </span><span><span class="kobospan" id="kobo.1458.1">to offspring:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1459.1">We will start by increasing the value of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1460.1">P_MUTATION</span></strong><span class="kobospan" id="kobo.1461.1"> constant to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1462.1">0.9</span></strong><span class="kobospan" id="kobo.1463.1">. </span><span class="kobospan" id="kobo.1463.2">This results in the </span><span><span class="kobospan" id="kobo.1464.1">following plot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer049">
<span class="kobospan" id="kobo.1465.1"><img alt="Figure 3.7: Stats of the program solving the OneMax problem after increasing the mutation probability to 0.9" src="image/B20851_03_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1466.1">Figure 3.7: Stats of the program solving the OneMax problem after increasing the mutation probability to 0.9</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1467.1">The results may seem surprising at first as increasing the mutation rate typically causes the algorithm to behave erratically, while here, the effect is seemingly unnoticeable. </span><span class="kobospan" id="kobo.1467.2">However, recall that there is another mutation-related parameter in our algorithm, </span><strong class="source-inline"><span class="kobospan" id="kobo.1468.1">indpb</span></strong><span class="kobospan" id="kobo.1469.1">, which is an argument of the specific mutation operator we used here – </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1470.1">mutFlipBit</span></strong></span><span><span class="kobospan" id="kobo.1471.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1472.1">
toolbox.register("mutate", tools.mutFlipBit, \
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1473.1">indpb</span></strong><span class="kobospan1" id="kobo.1474.1">=1.0/ONE_MAX_LENGTH)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1475.1">While</span><a id="_idIndexMarker223" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1476.1"> the value of </span><strong class="source-inline"><span class="kobospan" id="kobo.1477.1">P_MUTATION</span></strong><span class="kobospan" id="kobo.1478.1"> determines</span><a id="_idIndexMarker224" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1479.1"> the probability of an individual being mutated, </span><strong class="source-inline"><span class="kobospan" id="kobo.1480.1">indpb</span></strong><span class="kobospan" id="kobo.1481.1"> determines the probability of each bit in a given individual being flipped. </span><span class="kobospan" id="kobo.1481.2">In our program, we set the value of </span><strong class="source-inline"><span class="kobospan" id="kobo.1482.1">indpb</span></strong><span class="kobospan" id="kobo.1483.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.1484.1">1.0/ONE_MAX_LENGTH</span></strong><span class="kobospan" id="kobo.1485.1">, which means that, on average, a single bit will be flipped in a mutated solution. </span><span class="kobospan" id="kobo.1485.2">For our 100-bit-long OneMax problem, this seems to limit the effect of the mutation, regardless of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1486.1">P_MUTATION</span></strong> <span><span class="kobospan" id="kobo.1487.1">constant value.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.1488.1">Now, let’s increase the value of </span><strong class="source-inline1"><span class="kobospan" id="kobo.1489.1">indpb</span></strong><span class="kobospan" id="kobo.1490.1"> tenfold, </span><span><span class="kobospan" id="kobo.1491.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1492.1">
toolbox.register("mutate", tools.mutFlipBit, \
    indpb=</span><strong class="bold1"><span class="kobospan1" id="kobo.1493.1">10.0</span></strong><span class="kobospan1" id="kobo.1494.1">/ONE_MAX_LENGTH)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1495.1">The result of running the algorithm with this value is somewhat erratic, as shown in the </span><span><span class="kobospan" id="kobo.1496.1">following figure:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer050">
<span class="kobospan" id="kobo.1497.1"><img alt="Figure 3.8: Stats of the program after a tenfold increase in the per-bit mutation probability" src="image/B20851_03_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1498.1">Figure 3.8: Stats of the program after a tenfold increase in the per-bit mutation probability</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1499.1">The figure</span><a id="_idIndexMarker225" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1500.1"> indicates that while at first, the</span><a id="_idIndexMarker226" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1501.1"> algorithm can improve the results, it quickly gets stuck in a state of oscillations without being able to make </span><span><span class="kobospan" id="kobo.1502.1">significant improvements.</span></span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.1503.1">Increasing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1504.1">indpb</span></strong><span class="kobospan" id="kobo.1505.1"> value further, to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1506.1">50.0/ONE_MAX_LENGTH</span></strong><span class="kobospan" id="kobo.1507.1">, results in the following, </span><span><span class="kobospan" id="kobo.1508.1">unstable-looking, graph:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer051">
<span class="kobospan" id="kobo.1509.1"><img alt="Figure 3.9: Stats of the program after a fifty-fold increase in the per-bit mutation probability" src="image/B20851_03_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1510.1">Figure 3.9: Stats of the program after a fifty-fold increase in the per-bit mutation probability</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1511.1">As evident</span><a id="_idIndexMarker227" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1512.1"> from</span><a id="_idIndexMarker228" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1513.1"> this plot, the genetic algorithm has turned into the equivalent of a random search – it may stumble upon the best solution by chance, but it doesn’t make any progress toward </span><span><span class="kobospan" id="kobo.1514.1">better solutions.</span></span></p>
<h2 id="_idParaDest-108" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1515.1">Selection operator</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1516.1">Next, we’ll</span><a id="_idIndexMarker229" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1517.1"> look at the </span><strong class="bold"><span class="kobospan" id="kobo.1518.1">selection</span></strong><span class="kobospan" id="kobo.1519.1"> operator. </span><span class="kobospan" id="kobo.1519.2">First, we’ll change</span><a id="_idIndexMarker230" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1520.1"> the tournament size to see the combined effect of this parameter with the mutation probability. </span><span class="kobospan" id="kobo.1520.2">Then, we’ll look at using </span><em class="italic"><span class="kobospan" id="kobo.1521.1">roulette</span></em><span class="kobospan" id="kobo.1522.1"> selection instead of </span><span><em class="italic"><span class="kobospan" id="kobo.1523.1">tournament</span></em></span><span><span class="kobospan" id="kobo.1524.1"> selection.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1525.1">Tournament size and relation to mutation probability</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1526.1">Once again, we’ll </span><a id="_idIndexMarker231" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1527.1">start by changing back to the original settings of the program before we make new modifications and run </span><span><span class="kobospan" id="kobo.1528.1">some experiments:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1529.1">First, we’ll modify the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1530.1">tournamentSize</span></strong><span class="kobospan" id="kobo.1531.1"> parameter of the tournament selection algorithm and change it to </span><strong class="bold"><span class="kobospan" id="kobo.1532.1">2</span></strong><span class="kobospan" id="kobo.1533.1"> (instead of the original value </span><span><span class="kobospan" id="kobo.1534.1">of </span></span><span><strong class="bold"><span class="kobospan" id="kobo.1535.1">3</span></strong></span><span><span class="kobospan" id="kobo.1536.1">):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1537.1">
toolbox.register("select", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.1538.1">selTournament</span></strong><span class="kobospan1" id="kobo.1539.1">, tournsize=</span><strong class="bold1"><span class="kobospan1" id="kobo.1540.1">2</span></strong><span class="kobospan1" id="kobo.1541.1">)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1542.1">This doesn’t seem to have a noticeable effect on the </span><span><span class="kobospan" id="kobo.1543.1">algorithm’s behavior:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer052">
<span class="kobospan" id="kobo.1544.1"><img alt="Figure 3.10: Stats of the program solving the OneMax problem after decreasing the tournament size to 2" src="image/B20851_03_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1545.1">Figure 3.10: Stats of the program solving the OneMax problem after decreasing the tournament size to 2</span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.1546.1">What if we increase the tournament size to a very large value, </span><span><span class="kobospan" id="kobo.1547.1">say </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1548.1">100</span></strong></span><span><span class="kobospan" id="kobo.1549.1">?</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.1550.1">Let’s see:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1551.1">
toolbox.register("select", tools.selTournament, </span><strong class="bold1"><span class="kobospan1" id="kobo.1552.1">tournsize=100</span></strong><span class="kobospan1" id="kobo.1553.1">)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1554.1">The </span><a id="_idIndexMarker232" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1555.1">algorithm still behaves well and finds the best solution in less than 40 generations. </span><span class="kobospan" id="kobo.1555.2">One noticeable effect is that the max fitness now closely resembles the average fitness, as shown in the </span><span><span class="kobospan" id="kobo.1556.1">following graph:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer053">
<span class="kobospan" id="kobo.1557.1"><img alt="Figure 3.11: Stats of the program after increasing the tournament size to 100" src="image/B20851_03_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1558.1">Figure 3.11: Stats of the program after increasing the tournament size to 100</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1559.1">This behavior occurs because when the tournament size increases, the chance of weak individuals being selected diminishes, and better solutions tend to take over the population. </span><span class="kobospan" id="kobo.1559.2">In real-life problems, this takeover might cause suboptimal solutions to saturate the population and prevent the best solution from being found (a phenomenon known as </span><strong class="bold"><span class="kobospan" id="kobo.1560.1">premature convergence</span></strong><span class="kobospan" id="kobo.1561.1">). </span><span class="kobospan" id="kobo.1561.2">However, in the case of the</span><a id="_idIndexMarker233" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1562.1"> simple OneMax problem, this doesn’t seem to be an issue. </span><span class="kobospan" id="kobo.1562.2">A possible explanation is that the mutation operator provides enough diversity to keep the solutions moving in the </span><span><span class="kobospan" id="kobo.1563.1">right direction.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.1564.1">To put this explanation to the test, let’s reduce the mutation probability tenfold, </span><span><span class="kobospan" id="kobo.1565.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1566.1">0.01</span></strong></span><span><span class="kobospan" id="kobo.1567.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1568.1">
P_MUTATION = 0.01</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1569.1">If we </span><a id="_idIndexMarker234" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1570.1">run the algorithm again, we’ll see that the results stop improving soon after the start of the algorithms, and then improve at a much slower pace, with an occasional improvement here and there. </span><span class="kobospan" id="kobo.1570.2">The overall results are far worse than the previous run as the best fitness is around 80 rather </span><span><span class="kobospan" id="kobo.1571.1">than 100:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer054">
<span class="kobospan" id="kobo.1572.1"><img alt="Figure 3.12: Stats of the program with a tournament size of 100 and a mutation probability of 0.01" src="image/B20851_03_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1573.1">Figure 3.12: Stats of the program with a tournament size of 100 and a mutation probability of 0.01</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1574.1">This </span><a id="_idIndexMarker235" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1575.1">interpretation is that due to the large tournament size, the best individuals from the initial population take over within a small number of generations, which shows in the initial quick increase of both graphs in the plot. </span><span class="kobospan" id="kobo.1575.2">After that, only an occasional mutation in the right direction – one that flips a 0 to 1 –creates a better individual; this is indicated in the plot by a jump of the red line. </span><span class="kobospan" id="kobo.1575.3">Soon after, this individual takes over the entire population again, where the green line catches up with the </span><span><span class="kobospan" id="kobo.1576.1">red one.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.1577.1">To make this situation even more extreme, we can further reduce the </span><span><span class="kobospan" id="kobo.1578.1">mutation rate:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1579.1">
P_MUTATION = 0.001</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1580.1">We can</span><a id="_idIndexMarker236" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1581.1"> now see the same general behavior, but since mutations are very rare, the improvements are few and </span><span><span class="kobospan" id="kobo.1582.1">far between:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer055">
<span class="kobospan" id="kobo.1583.1"><img alt="Figure 3.13: Stats of the program with a tournament size of 100 and a mutation probability of 0.001" src="image/B20851_03_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1584.1">Figure 3.13: Stats of the program with a tournament size of 100 and a mutation probability of 0.001</span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.1585.1">Now, if we increase the number of generations to 500, we can see this behavior </span><span><span class="kobospan" id="kobo.1586.1">more clearly:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer056">
<span class="kobospan" id="kobo.1587.1"><img alt="Figure 3.14: Stats of the program with a tournament size of 100 and a mutation probability of 0.001, over 500 generations" src="image/B20851_03_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1588.1">Figure 3.14: Stats of the program with a tournament size of 100 and a mutation probability of 0.001, over 500 generations</span></p>
<ol class="calibre15">
<li value="7" class="calibre11"><span class="kobospan" id="kobo.1589.1">Just out</span><a id="_idIndexMarker237" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1590.1"> of curiosity, let’s dial back the tournament size to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1591.1">3</span></strong><span class="kobospan" id="kobo.1592.1"> again and restore the number of generations to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1593.1">50</span></strong><span class="kobospan" id="kobo.1594.1">, leaving the small mutation rate </span><span><span class="kobospan" id="kobo.1595.1">in place:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1596.1">
MAX_GENERATIONS = </span><strong class="bold1"><span class="kobospan1" id="kobo.1597.1">50</span></strong><span class="kobospan1" id="kobo.1598.1">
toolbox.register("select", tools.selTournament, tournsize=</span><strong class="bold1"><span class="kobospan1" id="kobo.1599.1">3</span></strong><span class="kobospan1" id="kobo.1600.1">)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1601.1">The resulting plot is a lot closer to the </span><span><span class="kobospan" id="kobo.1602.1">original one:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer057">
<span class="kobospan" id="kobo.1603.1"><img alt="Figure 3.15: Stats of the program with a tournament size of 3 and a mutation probability of 0.001, over 50 generations" src="image/B20851_03_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1604.1">Figure 3.15: Stats of the program with a tournament size of 3 and a mutation probability of 0.001, over 50 generations</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1605.1">Here, it </span><a id="_idIndexMarker238" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1606.1">seems that a takeover occurred as well, but far later, around generation 30, when the best fitness was already close to the maximum value of 100. </span><span class="kobospan" id="kobo.1606.2">Here, a more reasonable mutation rate would help us find the best solution, as happened with the </span><span><span class="kobospan" id="kobo.1607.1">original settings.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1608.1">Roulette wheel selection</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1609.1">Let’s go back to the</span><a id="_idIndexMarker239" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1610.1"> original settings once more, in preparation for our last experiment, as we will now try replacing the tournament selection</span><a id="_idIndexMarker240" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1611.1"> algorithm with </span><strong class="bold"><span class="kobospan" id="kobo.1612.1">roulette wheel selection</span></strong><span class="kobospan" id="kobo.1613.1">, which was described in </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.1614.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.1615.1">, </span><em class="italic"><span class="kobospan" id="kobo.1616.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.1617.1">. </span><span class="kobospan" id="kobo.1617.2">This is done </span><span><span class="kobospan" id="kobo.1618.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1619.1">
toolbox.register("select", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.1620.1">selRoulette</span></strong><span class="kobospan1" id="kobo.1621.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1622.1">This change seems to harm the algorithm’s results. </span><span class="kobospan" id="kobo.1622.2">As the following plot shows, there are numerous points in</span><a id="_idIndexMarker241" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1623.1"> time where the best solution is forgotten as a result of the selection, and the max fitness value decreases, at least temporarily, although the average fitness value keeps increasing. </span><span class="kobospan" id="kobo.1623.2">This is because the roulette selection algorithm selects individuals with a probability proportionate to their fitness; when the differences between</span><a id="_idIndexMarker242" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1624.1"> the individuals are relatively small, there is a better chance for weaker individuals to be selected, in comparison to the tournament selection we </span><span><span class="kobospan" id="kobo.1625.1">had before:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer058">
<span class="kobospan" id="kobo.1626.1"><img alt="Figure 3.16: Stats of the program when using roulette wheel selection" src="image/B20851_03_16.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1627.1">Figure 3.16: Stats of the program when using roulette wheel selection</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1628.1">To compensate for this behavior, we</span><a id="_idIndexMarker243" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1629.1"> can use the </span><strong class="bold"><span class="kobospan" id="kobo.1630.1">elitist approach</span></strong><span class="kobospan" id="kobo.1631.1"> mentioned in </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.1632.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.1633.1">, </span><em class="italic"><span class="kobospan" id="kobo.1634.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.1635.1">. </span><span class="kobospan" id="kobo.1635.2">This approach allows a certain number of the best individuals from the current generation to carry over to the next generation unaltered and prevents them from being lost. </span><span class="kobospan" id="kobo.1635.3">In the next chapter, we will explore applying the elitist approach when using the </span><span><span class="kobospan" id="kobo.1636.1">DEAP library.</span></span></p>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor153" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1637.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1638.1">In this chapter, you were introduced to </span><strong class="bold"><span class="kobospan" id="kobo.1639.1">DEAP</span></strong><span class="kobospan" id="kobo.1640.1"> – a versatile evolutionary computation framework that will be used in the rest of this book to solve real-life problems using genetic algorithms. </span><span class="kobospan" id="kobo.1640.2">You learned about DEAP’s </span><strong class="source-inline"><span class="kobospan" id="kobo.1641.1">creator</span></strong><span class="kobospan" id="kobo.1642.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.1643.1">toolbox</span></strong><span class="kobospan" id="kobo.1644.1"> modules, and how to use them to create the various components needed for the genetic algorithm’s flow. </span><span class="kobospan" id="kobo.1644.2">DEAP was then used to write two versions of a Python program that solves the </span><em class="italic"><span class="kobospan" id="kobo.1645.1">OneMax</span></em><span class="kobospan" id="kobo.1646.1"> problem, the first with full implementation of the genetic algorithm flow, and the other – more concise – taking advantage of the built-in algorithms of the framework. </span><span class="kobospan" id="kobo.1646.2">A third version of the program introduced the HOF feature offered by DEAP. </span><span class="kobospan" id="kobo.1646.3">We then experimented with various settings of the genetic algorithm and discovered the effects of changing the population size, as well as modifying the </span><em class="italic"><span class="kobospan" id="kobo.1647.1">selection</span></em><span class="kobospan" id="kobo.1648.1">, </span><em class="italic"><span class="kobospan" id="kobo.1649.1">crossover</span></em><span class="kobospan" id="kobo.1650.1">, and </span><span><em class="italic"><span class="kobospan" id="kobo.1651.1">mutation</span></em></span><span><span class="kobospan" id="kobo.1652.1"> operators.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1653.1">In the next chapter, expanding on what we learned in this chapter, we will start solving real-life combinatorial problems, including the </span><em class="italic"><span class="kobospan" id="kobo.1654.1">traveling salesman problem</span></em><span class="kobospan" id="kobo.1655.1"> and the </span><em class="italic"><span class="kobospan" id="kobo.1656.1">vehicle routing problem</span></em><span class="kobospan" id="kobo.1657.1">, using DEAP-based </span><span><span class="kobospan" id="kobo.1658.1">Python programs.</span></span></p>
<h1 id="_idParaDest-110" class="calibre5"><a id="_idTextAnchor154" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1659.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1660.1">For more information, please refer to the </span><span><span class="kobospan" id="kobo.1661.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1662.1">DEAP </span><span><span class="kobospan" id="kobo.1663.1">documentation: </span></span><a href="https://deap.readthedocs.io/en/master/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1664.1">https://deap.readthedocs.io/en/master/</span></span></a></li>
<li class="calibre11"><span class="kobospan" id="kobo.1665.1">DEAP source code on </span><span><span class="kobospan" id="kobo.1666.1">GitHub: </span></span><a href="https://github.com/DEAP/deap" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1667.1">https://github.com/DEAP/deap</span></span></a></li>
</ul>
</div>
</body></html>