- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the DEAP Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter – as promised – the real fun begins! You will be introduced
    to **Distributed Evolutionary Algorithms in Python** (**DEAP**) – a powerful and
    flexible evolutionary computation framework capable of solving real-life problems
    using genetic algorithms. After a brief introduction, you will get acquainted
    with two of its main modules – the creator and the toolbox – and learn how to
    create the various components needed for the genetic algorithm flow. We will then
    write a Python program that solves the OneMax problem – the Hello World of genetic
    algorithms – using the DEAP framework. This will be followed by a more concise
    version of the same program, where we’ll take advantage of the built-in algorithms
    of the framework. We’ve saved the best for the last part of this chapter, where
    we will be experimenting with various settings of the genetic algorithm we created
    and discover the effects of our modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Express your familiarity with the DEAP framework and its genetic algorithm modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the concepts of the creator and toolbox modules in the DEAP framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate a simple problem into a genetic algorithm representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a genetic algorithm solution using the DEAP framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to use the DEAP framework’s built-in algorithms to produce concise
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve the OneMax problem using a genetic algorithm coded with the DEAP framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with various settings of the genetic algorithm and interpret the
    differences in the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the latest information regarding the technical requirements, please refer
    to the README file at: [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/README.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Python version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book, we will be using Python 3, version 3.11 or newer. Python can
    be downloaded from the Python Software Foundation at [https://www.python.org/downloads/](https://www.python.org/downloads/).
    Additional useful instructions can be found here: [https://realpython.com/installing-python/](https://realpython.com/installing-python/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using a virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is generally good practice to use a virtual environment when working on a
    Python-based project as it enables you to keep the dependencies of your project
    isolated from other Python projects, as well as the system’s existing settings
    and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common way to create a virtual environment is by using **venv**, as described
    here: [https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another popular way to manage Python environments and packages is using **conda**,
    as described here: [https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When using a virtual environment, make sure you **activate** it before installing
    the required libraries, as described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the necessary libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we will be using the DEAP library, as well as various
    other Python packages. There are a couple of options to install these dependencies,
    as outlined in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using requirements.txt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether you choose to use a virtual environment or not, you can utilize the
    `requirements.txt` file we provide to install all the required dependencies at
    once. This file contains all the packages that will be used throughout this book
    and can be found in this book’s GitHub repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/requirements.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the `requirements.txt` file is used in conjunction with the `pip`
    utility and can be installed by applying the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing individual packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer to install the required packages individually as you go through
    this book, the Technical requirements section of each chapter will mention the
    particular packages that will be used within that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will need to install the DEAP library. The recommended ways
    to install DEAP are using `easy_install` or `pip`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information, check out the DEAP documentation: [https://deap.readthedocs.io/en/master/installation.html](https://deap.readthedocs.io/en/master/installation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to install DEAP via Conda, consult the following link: [https://anaconda.org/conda-forge/deap](https://anaconda.org/conda-forge/deap).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, for this chapter, you will need the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NumPy**: [https://www.numpy.org/](https://www.numpy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matplotlib**: [https://matplotlib.org/](https://matplotlib.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seaborn**: [https://seaborn.pydata.org/](https://seaborn.pydata.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now ready to use DEAP. The framework’s most useful tools and utilities
    will be covered in the next two sections. But first, we will get acquainted with
    DEAP and understand why we chose this framework for working with genetic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The programs that will be used in this chapter can be found in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_03).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/OEBOd](https://packt.link/OEBOd).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to DEAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous chapters, the basic ideas behind genetic algorithms
    and the genetic flow are relatively simple, and so are many of the genetic operators.
    Therefore, developing a program from scratch that implements a genetic algorithm
    to solve a particular problem is entirely feasible.
  prefs: []
  type: TYPE_NORMAL
- en: However, as is often the case when developing software, using a tried-and-true
    dedicated library or framework can make our lives easier. It helps us create solutions
    faster and with fewer bugs and gives us many options to choose from (and experiment
    with) right out of the box, without the need to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Numerous Python frameworks have been created for working with genetic algorithms
    – PyGAD, GAFT, Pyevolve, and PyGMO, to mention a few. After looking into several
    options, we chose to use the DEAP framework for this book thanks to its ease of
    use and a large selection of features, as well as its extensibility and ample
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: DEAP is a Python framework that supports the rapid development of solutions
    using genetic algorithms, as well as other evolutionary computation techniques.
    DEAP offers various data structures and tools that prove essential when implementing
    a wide range of genetic-algorithm-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: DEAP has been developed at the Canadian Laval University since 2009 and is available
    under the GNU **Lesser General Public** **License** (**LGPL**).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for DEAP is available at [https://github.com/DEAP/deap](https://github.com/DEAP/deap)
    and the documentation can be found at [https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/).
  prefs: []
  type: TYPE_NORMAL
- en: Using the creator module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first powerful tool provided by the DEAP framework is the `creator` module.
    The `creator` module is used as a meta-factory, and it enables us to extend existing
    classes by augmenting them with new attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have a class called `Employee`. Using the `creator`
    tool, we can extend the `Employee` class by creating a `Developer` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first argument that’s passed to the `create()` function is the desired name
    for the new class. The second argument is the existing base class to be extended.
    Then, each additional argument defines an attribute for the new class. If the
    argument is assigned a data structure (such as `dict` or `set`), it is added to
    the new class as an instance attribute that’s initialized in the constructor.
    If the argument is a simple type, such as a literal, it’s added as a class attribute
    that’s shared among all instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the created `Developer` class will extend the `Employee` class
    and will have a class attribute, `position`, set to `Developer`, and an instance
    attribute, `programmingLanguages` of the `set` type, which is initialized in the
    constructor. So, effectively, the new class is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: 1\. This new class exists within the **creator** module and therefore needs
    to be referenced as **creator.Developer**.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Extending the **numpy.ndarray** class is a special case that will be discussed
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: When using DEAP, the `creator` module usually serves to create the `Fitness`
    class, as well as the `Individual` class, to be used by the genetic algorithm,
    as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Fitness class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using DEAP, fitness values are encapsulated within a `Fitness` class. DEAP
    enables fitness to be combined into several components (also called objectives),
    each having its own weight. The combination of these weights defines the behavior
    or strategy of the fitness for the given problem.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the fitness strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help define this strategy, DEAP comes with the abstract `base.Fitness` class,
    which contains a `weights` tuple. This tuple needs to be assigned values to define
    the strategy and make the class usable. This can be done by extending the base
    `Fitness` class using `creator`, in a similar manner to what we did with the preceding
    `Developer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: creator.create("FitnessCompound", base.Fitness,
  prefs: []
  type: TYPE_NORMAL
- en: creator.FitnessCompound class, which will utilize three different fitness components.
    The first will be given a weight of 1.0, the second 0.2, and the third -0.5. This
    fitness strategy will tend to maximize the first and the second components (or
    objectives) and minimize the third. In terms of importance, the first component
    has the most importance, followed by the third component and then the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the fitness values
  prefs: []
  type: TYPE_NORMAL
- en: While the `weights` tuple defines the fitness strategy, a matching tuple, called
    `values`, is used to contain the actual fitness values within the `base.Fitness`
    class. These values are obtained from a separately defined function, typically
    called `evaluate()`, as will be described later in this chapter. Just like the
    `weights` tuple, the `values` tuple contains one value for each fitness component
    (objective).
  prefs: []
  type: TYPE_NORMAL
- en: A third tuple, `wvalues`, contains the weighted values that are obtained by
    multiplying each component of the values tuple with its matching component of
    the `weights` tuple. Whenever the fitness values of an instance are set, the weighted
    values are calculated and inserted into `wvalues`. These are used internally for
    comparison operations between individuals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The weighted fitness values may be lexicographically compared using the following
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once the `Fitness` class is created, we can use it in the definition of the
    `Individual` class, as shown in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Individual class
  prefs: []
  type: TYPE_NORMAL
- en: The second common use of the `creator` tool in DEAP is defining the individuals
    that form the population for the genetic algorithm. As we saw in the previous
    chapters, the individuals in genetic algorithms are represented using a chromosome
    that can be manipulated by genetic operators. In DEAP, the `Individual` class
    is created by extending a base class that represents the chromosome. In addition,
    each instance in DEAP needs to contain its fitness function as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fulfill these two requirements, we can utilize `creator` to create the `creator.Individual`
    class, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This line provides the following two effects:'
  prefs: []
  type: TYPE_NORMAL
- en: The created **Individual** class extends the Python **list** class. This means
    that the chromosome that’s used is of the **list** type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance of this **Individual** class will have an attribute called **fitness**,
    of the **FitnessMax** class, which we created previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn to use the `Toolbox` class in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Toolbox class
  prefs: []
  type: TYPE_NORMAL
- en: The second mechanism offered by the DEAP framework is the `base.Toolbox` class.
    `Toolbox` is used as a container for functions (or operators) and enables us to
    create new operators by aliasing and customizing existing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have a function, `sumOfTwo()`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using `toolbox`, we can now create a new operator, `incrementByFive()`, which
  prefs: []
  type: TYPE_NORMAL
- en: 'customizes the `sumOfTwo()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: toolbox.incrementByFive(10)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: sumOfTwo(10, 5)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: from deap import tools
  prefs: []
  type: TYPE_NORMAL
- en: toolbox.register("select",tools.selTournament,tournsize=3)
  prefs: []
  type: TYPE_NORMAL
- en: toolbox.register("mate", tools.cxTwoPoint)
  prefs: []
  type: TYPE_NORMAL
- en: toolbox.register("mutate", tools.mutFlipBit, indpb=0.02)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: randomList = tools.initRepeat(list is the type serving as the container to be
    filled, random.random is the generator function, and 30 is the number of times
    we will call the function to generate values that fill the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to fill the list with integer random numbers that are *either*
    0 or 1? We could, for example, create a function that utilizes `random.radint()`
    to generate a single random value of 0 or 1, and then use it as the generator
    function of `initRepeat()`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: toolbox.register("zeroOrOne", random.randint, 0, 1)
  prefs: []
  type: TYPE_NORMAL
- en: randomList = tools.initRepeat(list, zeroOrOne() function, we created the zeroOrOne
    operator (or alias), which calls random.radint() with the fixed parameters of
    0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the fitness
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, while the `Fitness` class defines the fitness *weights*
    that determine its strategy (such as *maximization* or *minimization*), the actual
    fitness values are obtained from a separately defined function. This fitness calculation
    function is typically registered with the `toolbox` module using an alias of `evaluate`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: from deap import base
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from deap import creator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from deap import tools
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import random
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import matplotlib.pyplot as plt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'problem constants:'
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: ONE_MAX_LENGTH = 100   # length of bit string to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# optimized'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Genetic Algorithm constants:'
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POPULATION_SIZE = 200 # number of individuals in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# population'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P_CROSSOVER = 0.9     # probability for crossover
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P_MUTATION = 0.1      # probability for mutating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# an individual'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MAX_GENERATIONS = 50  # max number of generations for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# stopping condition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: RANDOM_SEED = 42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: random.seed(RANDOM_SEED)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: toolbox = base.Toolbox()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: toolbox.register("zeroOrOne", random.randint, 0, 1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: creator.create("FitnessMax", base.Fitness, \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: weights=1.0,))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: creator.create("Individual", list, \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fitness=creator.FitnessMax)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: toolbox.register("individualCreator",\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tools.initRepeat,\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: creator.Individual,\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: toolbox.zeroOrOne, ONE_MAX_LENGTH)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: toolbox.register("populationCreator", \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tools.initRepeat, \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list, toolbox.individualCreator)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'def oneMaxFitness(individual):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return sum(individual), # return a tuple'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'toolbox.register("tools module and setting the argument values as needed. Here,
    we chose the following:*   Tournament selection with a tournament size of 3*   Single-point
    crossover*   Flip-bit mutationNote the `indpb` parameter of the `mutFlipBit` function.
    This function iterates over all the attributes of the individual – a list containing
    values of 1s and 0s in our case – where each attribute will use this argument
    value as the probability of flipping (applying the `not` operator to) the attribute
    value. This value is independent of the mutation probability, which is set by
    the `P_MUTATION` constant that we defined earlier and has not been used yet. The
    mutation probability serves to decide whether the `mutFlipBit` function is called
    for a given individual in the population:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: population = toolbox.populationCreator(n=POPULATION_SIZE)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generationCounter = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: fitnessValues = list(map(toolbox.evaluate,\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: population))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'for individual, fitnessValue in zip(population, fitnessValues):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: individual.fitness.values = fitnessValue
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: fitnessValues = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: individual.fitness.values[0] for individual in population
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: maxFitnessValues = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: meanFitnessValues = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: while max(fitnessValues) < ONE_MAX_LENGTH and \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'generationCounter < MAX_GENERATIONS:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: generationCounter = generationCounter + 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: offspring = toolbox.select(population, len(population))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: offspring = list(map(toolbox.clone, offspring))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'for child1, child2 in zip(offspring[::2], offspring[1::2]):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if random.random() < P_CROSSOVER:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: toolbox.mate(child1, child2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: del child1.fitness.values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: del child2.fitness.values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'for mutant in offspring:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if random.random() < P_MUTATION:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: toolbox.mutate(mutant)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: del mutant.fitness.values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: freshIndividuals = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ind for ind in offspring if not ind.fitness.valid]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: freshFitnessValues = list(map(toolbox.evaluate,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: freshIndividuals))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for individual, fitnessValue in zip(freshIndividuals,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: freshFitnessValues
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: individual.fitness.values = fitnessValue
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: population[:] = offspring
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: fitnessValues = [ind.fitness.values[0] for ind in population]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: maxFitness = max(fitnessValues)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: meanFitness = sum(fitnessValues) / len(population)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: maxFitnessValues.append(maxFitness)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: meanFitnessValues.append(meanFitness)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(f"- Generation {generationCounter}:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Max Fitness = {maxFitness}, \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Avg Fitness = {meanFitness}")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: best_index = fitnessValues.index(max(fitnessValues))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print("Best Individual = ", *population[best_index], "\n")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: plt.plot(maxFitnessValues, color='red')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plt.plot(meanFitnessValues, color='green')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plt.xlabel('Generation')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plt.ylabel('Max / Average Fitness')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plt.title('Max and Average fitness over Generations')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plt.show()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '- Generation 1: Max Fitness = 65.0, Avg Fitness = 53.575'
  prefs: []
  type: TYPE_NORMAL
- en: Best Individual = 1 1 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 0 0 1 0 1 0 0 0 1 1 1 1
    1 0 1 1 1 1 0 1 0 1 1 1 1 0 0 1 1 111101111101111111000 0 1 0 1 0 1 1 1 0 1 1
    0 0 0 1 1 1 0011111111111100
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '- Generation 40: Max Fitness = 100.0, Avg Fitness = 98.29'
  prefs: []
  type: TYPE_NORMAL
- en: Best Individual = 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 111111111111111111111 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1111111111111111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'stats = tools.Statistics(lambda ind: ind.fitness.values)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: stats.register("max", numpy.max)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stats.register("avg", numpy.mean)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: population, logbook = algorithms.eaSimple(population, toolbox,
  prefs: []
  type: TYPE_NORMAL
- en: cxpb=P_CROSSOVER,
  prefs: []
  type: TYPE_NORMAL
- en: mutpb=P_MUTATION,
  prefs: []
  type: TYPE_NORMAL
- en: ngen=MAX_GENERATIONS,
  prefs: []
  type: TYPE_NORMAL
- en: stats=stats,
  prefs: []
  type: TYPE_NORMAL
- en: verbose=True)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: maxFitnessValues, meanFitnessValues = logbook.select("max", "avg")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: gen   nevals  max    avg
  prefs: []
  type: TYPE_NORMAL
- en: 0     200     61     49.695
  prefs: []
  type: TYPE_NORMAL
- en: 1     193     65     53.575
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 39    192     99     98.04
  prefs: []
  type: TYPE_NORMAL
- en: 40    173     100    98.29
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 49    187     100    99.83
  prefs: []
  type: TYPE_NORMAL
- en: 50    184     100    99.89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: HALL_OF_FAME_SIZE = 10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: population, logbook = algorithms.eaSimple(\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: population, toolbox, cxpb=P_CROSSOVER, \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mutpb=P_MUTATION, ngen=MAX_GENERATIONS, \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stats=stats, halloffame=hof, verbose=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: print("Hall of Fame Individuals = ", *hof.items, sep="\n")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print("Best Ever Individual = ", hof.items[0])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hall of Fame Individuals =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  [1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Best Ever Individual = [1, 1, 1, 1, ..., 0, ..., 1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: POPULATION_SIZE = 400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: POPULATION_SIZE = 100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: MAX_GENERATIONS = 80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: toolbox.register("mate", tools.cxTwoPoint)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: toolbox.register("mutate", tools.mutFlipBit, \
  prefs: []
  type: TYPE_NORMAL
- en: P_MUTATION determines the probability of an individual being mutated, indpb
    determines the probability of each bit in a given individual being flipped. In
    our program, we set the value of indpb to 1.0/ONE_MAX_LENGTH, which means that,
    on average, a single bit will be flipped in a mutated solution. For our 100-bit-long
    OneMax problem, this seems to limit the effect of the mutation, regardless of
    the P_MUTATION constant value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s increase the value of **indpb** tenfold, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of running the algorithm with this value is somewhat erratic, as
    shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.8: Stats of the program after a tenfold increase in the per-bit
    mutation probability](img/B20851_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Stats of the program after a tenfold increase in the per-bit mutation
    probability'
  prefs: []
  type: TYPE_NORMAL
- en: The figure indicates that while at first, the algorithm can improve the results,
    it quickly gets stuck in a state of oscillations without being able to make significant
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Increasing the **indpb** value further, to **50.0/ONE_MAX_LENGTH**, results
    in the following, unstable-looking, graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9: Stats of the program after a fifty-fold increase in the per-bit
    mutation probability](img/B20851_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Stats of the program after a fifty-fold increase in the per-bit
    mutation probability'
  prefs: []
  type: TYPE_NORMAL
- en: As evident from this plot, the genetic algorithm has turned into the equivalent
    of a random search – it may stumble upon the best solution by chance, but it doesn’t
    make any progress toward better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Selection operator
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the **selection** operator. First, we’ll change the tournament
    size to see the combined effect of this parameter with the mutation probability.
    Then, we’ll look at using *roulette* selection instead of *tournament* selection.
  prefs: []
  type: TYPE_NORMAL
- en: Tournament size and relation to mutation probability
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we’ll start by changing back to the original settings of the program
    before we make new modifications and run some experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll modify the **tournamentSize** parameter of the tournament selection
    algorithm and change it to **2** (instead of the original value of **3**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This doesn’t seem to have a noticeable effect on the algorithm’s behavior:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.10: Stats of the program solving the OneMax problem after decreasing
    the tournament size to 2](img/B20851_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Stats of the program solving the OneMax problem after decreasing
    the tournament size to 2'
  prefs: []
  type: TYPE_NORMAL
- en: What if we increase the tournament size to a very large value, say **100**?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The algorithm still behaves well and finds the best solution in less than 40
    generations. One noticeable effect is that the max fitness now closely resembles
    the average fitness, as shown in the following graph:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.11: Stats of the program after increasing the tournament size to
    100](img/B20851_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Stats of the program after increasing the tournament size to 100'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior occurs because when the tournament size increases, the chance
    of weak individuals being selected diminishes, and better solutions tend to take
    over the population. In real-life problems, this takeover might cause suboptimal
    solutions to saturate the population and prevent the best solution from being
    found (a phenomenon known as **premature convergence**). However, in the case
    of the simple OneMax problem, this doesn’t seem to be an issue. A possible explanation
    is that the mutation operator provides enough diversity to keep the solutions
    moving in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this explanation to the test, let’s reduce the mutation probability
    tenfold, to **0.01**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the algorithm again, we’ll see that the results stop improving soon
    after the start of the algorithms, and then improve at a much slower pace, with
    an occasional improvement here and there. The overall results are far worse than
    the previous run as the best fitness is around 80 rather than 100:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.12: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.01](img/B20851_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.01'
  prefs: []
  type: TYPE_NORMAL
- en: This interpretation is that due to the large tournament size, the best individuals
    from the initial population take over within a small number of generations, which
    shows in the initial quick increase of both graphs in the plot. After that, only
    an occasional mutation in the right direction – one that flips a 0 to 1 –creates
    a better individual; this is indicated in the plot by a jump of the red line.
    Soon after, this individual takes over the entire population again, where the
    green line catches up with the red one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this situation even more extreme, we can further reduce the mutation
    rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now see the same general behavior, but since mutations are very rare,
    the improvements are few and far between:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.13: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001](img/B20851_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we increase the number of generations to 500, we can see this behavior
    more clearly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001, over 500 generations](img/B20851_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Stats of the program with a tournament size of 100 and a mutation
    probability of 0.001, over 500 generations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just out of curiosity, let’s dial back the tournament size to **3** again and
    restore the number of generations to **50**, leaving the small mutation rate in
    place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot is a lot closer to the original one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.15: Stats of the program with a tournament size of 3 and a mutation
    probability of 0.001, over 50 generations](img/B20851_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Stats of the program with a tournament size of 3 and a mutation
    probability of 0.001, over 50 generations'
  prefs: []
  type: TYPE_NORMAL
- en: Here, it seems that a takeover occurred as well, but far later, around generation
    30, when the best fitness was already close to the maximum value of 100\. Here,
    a more reasonable mutation rate would help us find the best solution, as happened
    with the original settings.
  prefs: []
  type: TYPE_NORMAL
- en: Roulette wheel selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the original settings once more, in preparation for our last
    experiment, as we will now try replacing the tournament selection algorithm with
    **roulette wheel selection**, which was described in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053),
    *Understanding the Key Components of Genetic Algorithms*. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This change seems to harm the algorithm’s results. As the following plot shows,
    there are numerous points in time where the best solution is forgotten as a result
    of the selection, and the max fitness value decreases, at least temporarily, although
    the average fitness value keeps increasing. This is because the roulette selection
    algorithm selects individuals with a probability proportionate to their fitness;
    when the differences between the individuals are relatively small, there is a
    better chance for weaker individuals to be selected, in comparison to the tournament
    selection we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: Stats of the program when using roulette wheel selection](img/B20851_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Stats of the program when using roulette wheel selection'
  prefs: []
  type: TYPE_NORMAL
- en: To compensate for this behavior, we can use the **elitist approach** mentioned
    in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding the Key Components
    of Genetic Algorithms*. This approach allows a certain number of the best individuals
    from the current generation to carry over to the next generation unaltered and
    prevents them from being lost. In the next chapter, we will explore applying the
    elitist approach when using the DEAP library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to `creator` and `toolbox` modules, and
    how to use them to create the various components needed for the genetic algorithm’s
    flow. DEAP was then used to write two versions of a Python program that solves
    the *OneMax* problem, the first with full implementation of the genetic algorithm
    flow, and the other – more concise – taking advantage of the built-in algorithms
    of the framework. A third version of the program introduced the HOF feature offered
    by DEAP. We then experimented with various settings of the genetic algorithm and
    discovered the effects of changing the population size, as well as modifying the
    *selection*, *crossover*, and *mutation* operators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, expanding on what we learned in this chapter, we will start
    solving real-life combinatorial problems, including the *traveling salesman problem*
    and the *vehicle routing problem*, using DEAP-based Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, please refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DEAP documentation: [https://deap.readthedocs.io/en/master/](https://deap.readthedocs.io/en/master/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DEAP source code on GitHub: [https://github.com/DEAP/deap](https://github.com/DEAP/deap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
