<html><head></head><body>
<div id="_idContainer079" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-111"><a id="_idTextAnchor155" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-112" class="calibre5"><a id="_idTextAnchor156" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Combinatorial Optimization</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, you will learn how genetic algorithms can be utilized in combinatorial optimization applications. </span><span class="kobospan" id="kobo.3.2">We will start by describing search problems and combinatorial optimization, and outline several hands-on examples of combinatorial optimization problems. </span><span class="kobospan" id="kobo.3.3">We will then analyze each of these problems and match them with Python-based solutions using the DEAP framework. </span><span class="kobospan" id="kobo.3.4">The optimization problems we’ll cover are the well-known knapsack problem, the </span><strong class="bold"><span class="kobospan" id="kobo.4.1">traveling salesman problem</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">TSP</span></strong><span class="kobospan" id="kobo.7.1">), and the </span><strong class="bold"><span class="kobospan" id="kobo.8.1">vehicle routing problem</span></strong><span class="kobospan" id="kobo.9.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.10.1">VRP</span></strong><span class="kobospan" id="kobo.11.1">). </span><span class="kobospan" id="kobo.11.2">As a bonus, we will cover the topics of genotype-to-phenotype mapping and exploration </span><span><span class="kobospan" id="kobo.12.1">versus exploitation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.13.1">By the end of this chapter, you will be able to do </span><span><span class="kobospan" id="kobo.14.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Understand the nature of search problems and </span><span><span class="kobospan" id="kobo.16.1">combinatorial optimization</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">Solve the knapsack problem using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.18.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.19.1">Solve the TSP using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.20.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.21.1">Solve the VRP using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.22.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.23.1">Understand </span><span><span class="kobospan" id="kobo.24.1">genotype-to-phenotype mapping</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.25.1">Gain familiarity with the concept of exploration versus exploitation and its relation </span><span><span class="kobospan" id="kobo.26.1">to elitism</span></span></li>
</ul>
<h1 id="_idParaDest-113" class="calibre5"><a id="_idTextAnchor157" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.27.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">In this chapter, we will be using Python 3 with the following </span><span><span class="kobospan" id="kobo.29.1">supporting libraries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.30.1">deap</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.31.1">numpy</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.32.1">matplotlib</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.33.1">seaborn</span></strong></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.34.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.35.1">If you use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.36.1">requirements.txt</span></strong><span class="kobospan" id="kobo.37.1"> file provided (see </span><a href="B20851_03.xhtml#_idTextAnchor091" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.38.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.39.1">), these libraries will already be in </span><span><span class="kobospan" id="kobo.40.1">your environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">In addition, we will be using the benchmark data from the </span><em class="italic"><span class="kobospan" id="kobo.42.1">Rosetta Code</span></em><span class="kobospan" id="kobo.43.1">  (</span><a href="https://rosettacode.org/wiki/Rosetta_Code" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.44.1">https://rosettacode.org/wiki/Rosetta_Code</span></a><span class="kobospan" id="kobo.45.1">) and </span><em class="italic"><span class="kobospan" id="kobo.46.1">TSPLIB</span></em><span class="kobospan" id="kobo.47.1"> (</span><a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.48.1">http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/</span></a><span class="kobospan" id="kobo.49.1">) </span><span><span class="kobospan" id="kobo.50.1">web pages.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.51.1">The programs that will be used in this chapter can be found in this book’s GitHub repository: </span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_04" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.52.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_04</span></a><span class="kobospan" id="kobo.53.1">. </span><span class="kobospan" id="kobo.53.2">Check out the following video to see the Code in </span><span><span class="kobospan" id="kobo.54.1">Action: </span></span><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.55.1">https://packt.link/OEBOd</span></span></a></p>
<h1 id="_idParaDest-114" class="calibre5"><a id="_idTextAnchor158" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.56.1">Search problems and combinatorial optimization</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.57.1">One common</span><a id="_idIndexMarker244" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.58.1"> area of applying genetic algorithms is </span><em class="italic"><span class="kobospan" id="kobo.59.1">search problems</span></em><span class="kobospan" id="kobo.60.1">, which have </span><a id="_idIndexMarker245" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.61.1">important applications in fields such as logistics, operations, artificial intelligence, and machine learning. </span><span class="kobospan" id="kobo.61.2">Examples include determining the optimal routes for package delivery, designing hub-based airline networks, managing investment portfolios, and assigning passengers to available drivers in a fleet </span><span><span class="kobospan" id="kobo.62.1">of taxis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">Search algorithms focus on solving a problem through methodic evaluation of </span><strong class="bold"><span class="kobospan" id="kobo.64.1">states</span></strong><span class="kobospan" id="kobo.65.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.66.1">state transitions</span></strong><span class="kobospan" id="kobo.67.1">, aiming to find a path from the initial state to a desirable final (or “goal”) state. </span><span class="kobospan" id="kobo.67.2">Typically, there is a </span><strong class="bold"><span class="kobospan" id="kobo.68.1">cost</span></strong><span class="kobospan" id="kobo.69.1"> or a </span><strong class="bold"><span class="kobospan" id="kobo.70.1">gain</span></strong><span class="kobospan" id="kobo.71.1"> involved in every state transition, and the objective of the corresponding search algorithm is to find a path that minimizes the cost or maximizes the gain. </span><span class="kobospan" id="kobo.71.2">Since the optimal path is one of many possible ones, this kind of search is related to </span><em class="italic"><span class="kobospan" id="kobo.72.1">combinatorial optimization</span></em><span class="kobospan" id="kobo.73.1">, a topic that involves finding an optimal object from a finite, yet often extremely large, set of </span><span><span class="kobospan" id="kobo.74.1">possible objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.75.1">These concepts will be illustrated as we get acquainted with the </span><em class="italic"><span class="kobospan" id="kobo.76.1">knapsack problem</span></em><span class="kobospan" id="kobo.77.1">, which is the main focus of the </span><span><span class="kobospan" id="kobo.78.1">next section.</span></span></p>
<h1 id="_idParaDest-115" class="calibre5"><a id="_idTextAnchor159" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.79.1">Solving the knapsack problem</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.80.1">Think of the</span><a id="_idIndexMarker246" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.81.1"> familiar situation of packing for a long trip. </span><span class="kobospan" id="kobo.81.2">There are many items that you would like to take with you, but you are limited by the capacity of your suitcase. </span><span class="kobospan" id="kobo.81.3">In your mind, each item has a certain value it will add to your trip; at the same time, it has a size (and weight) associated with it, and it will compete with other items over the available space in your suitcase. </span><span class="kobospan" id="kobo.81.4">This situation is just one of many real-life examples of the </span><em class="italic"><span class="kobospan" id="kobo.82.1">knapsack problem</span></em><span class="kobospan" id="kobo.83.1">, which is considered one of the oldest and most investigated combinatorial </span><span><span class="kobospan" id="kobo.84.1">search problems.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">More formally, the knapsack problem consists of the </span><span><span class="kobospan" id="kobo.86.1">following components:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.87.1">A set of </span><strong class="bold"><span class="kobospan" id="kobo.88.1">items</span></strong><span class="kobospan" id="kobo.89.1">, each of them associated a certain </span><strong class="bold"><span class="kobospan" id="kobo.90.1">value</span></strong><span class="kobospan" id="kobo.91.1"> and a </span><span><span class="kobospan" id="kobo.92.1">certain </span></span><span><strong class="bold"><span class="kobospan" id="kobo.93.1">weight</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.94.1">A </span><strong class="bold"><span class="kobospan" id="kobo.95.1">bag/sack/container</span></strong><span class="kobospan" id="kobo.96.1"> (the “knapsack”) of a certain </span><span><strong class="bold"><span class="kobospan" id="kobo.97.1">weight capacity</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.98.1">Our goal is to come up with a group of selected items that will provide the maximum total value, without exceeding the total weight capacity of </span><span><span class="kobospan" id="kobo.99.1">the bag.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.100.1">In the context of search algorithms, each subset of the items represents a state, and the set of all possible item subsets is considered the state space. </span><span class="kobospan" id="kobo.100.2">For an instance of the knapsack 0-1 problem with </span><em class="italic"><span class="kobospan" id="kobo.101.1">n</span></em><span class="kobospan" id="kobo.102.1"> items, the size of the state space is </span><span><span class="kobospan" id="kobo.103.1">2</span></span><span><span class="kobospan" id="kobo.104.1"> </span></span><span><span class="kobospan" id="kobo.105.1">n</span></span><span class="kobospan" id="kobo.106.1">, which can quickly grow very large, even for a modest value </span><span><span class="kobospan" id="kobo.107.1">of </span></span><span><em class="italic"><span class="kobospan" id="kobo.108.1">n</span></em></span><span><span class="kobospan" id="kobo.109.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">In this (original) version of the problem, each item can only be included once or not at all, and therefore it is sometimes referred to as the </span><strong class="bold"><span class="kobospan" id="kobo.111.1">knapsack 0-1</span></strong><span class="kobospan" id="kobo.112.1"> problem. </span><span class="kobospan" id="kobo.112.2">However, it can be expanded into other variants – for example, where items can be included multiple times (limited or unlimited) or where multiple knapsacks with varying capacities </span><span><span class="kobospan" id="kobo.113.1">are present.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.114.1">Applications of knapsack problems appear in many real-world processes that involve resource allocation and decision-making, such as selecting investments when building an investment portfolio, minimizing the waste when cutting raw materials, and getting the “most bang for your buck” when selecting which questions to answer in a </span><span><span class="kobospan" id="kobo.115.1">timed test.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.116.1">To get our hands dirty with a knapsack problem, we will look at a widely </span><span><span class="kobospan" id="kobo.117.1">known example.</span></span></p>
<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor160" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.118.1">The Rosetta Code knapsack 0-1 problem</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.119.1">The </span><em class="italic"><span class="kobospan" id="kobo.120.1">Rosetta Code</span></em><span class="kobospan" id="kobo.121.1"> website (</span><a href="http://rosettacode.org" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.122.1">rosettacode.org</span></a><span class="kobospan" id="kobo.123.1">) provides a collection of programming tasks, each with</span><a id="_idIndexMarker247" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.124.1"> solutions in numerous languages. </span><span class="kobospan" id="kobo.124.2">One of these tasks, described at </span><a href="http://rosettacode.org/wiki/Knapsack_problem/0-1" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.125.1">rosettacode.org/wiki/Knapsack_problem/0-1</span></a><span class="kobospan" id="kobo.126.1">, is a knapsack 0-1 problem where a tourist needs to decide which items to pack for their weekend trip. </span><span class="kobospan" id="kobo.126.2">The tourist has 22 items they can choose from; each item is assigned by the tourist with some value that represents its relative importance for the </span><span><span class="kobospan" id="kobo.127.1">upcoming journey.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.128.1">The weight capacity of the tourist’s bag in this problem is </span><strong class="bold"><span class="kobospan" id="kobo.129.1">400</span></strong><span class="kobospan" id="kobo.130.1">. </span><span class="kobospan" id="kobo.130.2">The list of items, along with their associated values and weights, is provided in the </span><span><span class="kobospan" id="kobo.131.1">following table:</span></span></p>
<table class="no-table-style" id="table001-3">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.132.1">Item</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.133.1">Weight</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.134.1">Value</span></strong></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">map</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.136.1">9</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.137.1">150</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.138.1">compass</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.139.1">13</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.140.1">35</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">water</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.142.1">153</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.143.1">200</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.144.1">sandwich</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.145.1">50</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.146.1">160</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">glucose</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.148.1">15</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.149.1">60</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.150.1">tin</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.151.1">68</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.152.1">45</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">banana</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.154.1">27</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.155.1">60</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">apple</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.157.1">39</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.158.1">40</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.159.1">cheese</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.160.1">23</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.161.1">30</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.162.1">beer</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.163.1">52</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.164.1">10</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">suntan cream</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.166.1">11</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.167.1">70</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.168.1">camera</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.169.1">32</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.170.1">30</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">T-shirt</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.172.1">24</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.173.1">15</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.174.1">trousers</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.175.1">48</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.176.1">10</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">umbrella</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.178.1">73</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.179.1">40</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.180.1">waterproof trousers</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.181.1">42</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.182.1">70</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">waterproof overclothes</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.184.1">43</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.185.1">75</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">note-case</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.187.1">22</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.188.1">80</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">sunglasses</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.190.1">7</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.191.1">20</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">towel</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.193.1">18</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.194.1">12</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.195.1">socks</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.196.1">4</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.197.1">50</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.198.1">book</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.199.1">30</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.200.1">10</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.201.1">Table 4.1: A list of Rosetta Code knapsack 0-1 items</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.202.1">Before we start</span><a id="_idIndexMarker248" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.203.1"> solving this problem, we need to discuss one important matter – what’s a </span><span><span class="kobospan" id="kobo.204.1">potential solution?</span></span></p>
<h2 id="_idParaDest-117" class="calibre7"><a id="_idTextAnchor161" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.205.1">Solution representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">When solving the</span><a id="_idIndexMarker249" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.207.1"> knapsack 0-1 problem, a straightforward way to represent a solution is using a list of binary values. </span><span class="kobospan" id="kobo.207.2">Every entry in that list corresponds to one of the items in the problem. </span><span class="kobospan" id="kobo.207.3">For the Rosetta Code problem, a solution can be represented using a list of 22 integers of the values </span><strong class="source-inline"><span class="kobospan" id="kobo.208.1">0</span></strong><span class="kobospan" id="kobo.209.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.210.1">1</span></strong><span class="kobospan" id="kobo.211.1">. </span><span class="kobospan" id="kobo.211.2">A value of </span><strong class="source-inline"><span class="kobospan" id="kobo.212.1">1</span></strong><span class="kobospan" id="kobo.213.1"> represents picking the corresponding item, while a value of </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">0</span></strong><span class="kobospan" id="kobo.215.1"> means that the item hasn’t been picked. </span><span class="kobospan" id="kobo.215.2">When applying the genetic algorithms approach, this list of binary values is going to be used as </span><span><span class="kobospan" id="kobo.216.1">the chromosome.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.217.1">However, we have to remember that the total weight of the chosen items cannot exceed the capacity of the knapsack. </span><span class="kobospan" id="kobo.217.2">One way to incorporate this restriction into the solution is to wait until it gets evaluated. </span><span class="kobospan" id="kobo.217.3">We then evaluate by adding the weights of the chosen items one by one, while ignoring any chosen item that will cause the accumulated weight to exceed the maximum allowed value. </span><span class="kobospan" id="kobo.217.4">From the genetic algorithm’s point of view, this means that the chromosome representation of an individual (</span><em class="italic"><span class="kobospan" id="kobo.218.1">genotype</span></em><span class="kobospan" id="kobo.219.1">) may not entirely express itself when it gets translated into the actual solution (</span><em class="italic"><span class="kobospan" id="kobo.220.1">phenotype</span></em><span class="kobospan" id="kobo.221.1">) as some of the 1 values in the chromosome may be ignored. </span><span class="kobospan" id="kobo.221.2">This situation is sometimes referred </span><a id="_idIndexMarker250" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.222.1">to as </span><span><strong class="bold"><span class="kobospan" id="kobo.223.1">genotype-to-phenotype mapping</span></strong></span><span><span class="kobospan" id="kobo.224.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">The solution </span><a id="_idIndexMarker251" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.226.1">representation we just discussed is implemented in the Python class described in the </span><span><span class="kobospan" id="kobo.227.1">next subsection.</span></span></p>
<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor162" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.228.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.229.1">To encapsulate the</span><a id="_idIndexMarker252" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.230.1"> Rosetta Code knapsack 0-1 problem, we created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">Knapsack01Problem</span></strong><span class="kobospan" id="kobo.232.1">. </span><span class="kobospan" id="kobo.232.2">This class is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.233.1">knapsack.py</span></strong><span class="kobospan" id="kobo.234.1"> file, which can be found </span><span><span class="kobospan" id="kobo.235.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/knapsack.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.236.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/knapsack.py</span></span></a><span><span class="kobospan" id="kobo.237.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.238.1">The class provides the </span><span><span class="kobospan" id="kobo.239.1">following methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.240.1">__init_data()</span></strong><span class="kobospan" id="kobo.241.1">: This initializes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.242.1">RosettaCode.org</span></strong><span class="kobospan" id="kobo.243.1"> knapsack 0-1 problem data by creating a list of tuples. </span><span class="kobospan" id="kobo.243.2">Each tuple contains the name of an item, followed by its weight and </span><span><span class="kobospan" id="kobo.244.1">its value.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.245.1">getValue(zeroOneList)</span></strong><span class="kobospan" id="kobo.246.1">: This calculates the value of the chosen items in the list while ignoring items that will cause the accumulating weight to exceed the </span><span><span class="kobospan" id="kobo.247.1">maximum weight.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.248.1">printItems(zeroOneList)</span></strong><span class="kobospan" id="kobo.249.1">: This prints the chosen items in the list while ignoring items that will cause the accumulating weight to exceed the </span><span><span class="kobospan" id="kobo.250.1">maximum weight.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.251.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">main()</span></strong><span class="kobospan" id="kobo.253.1"> method of the class creates an instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">Knapsack01Problem</span></strong><span class="kobospan" id="kobo.255.1"> class. </span><span class="kobospan" id="kobo.255.2">It then creates a random solution and prints out its relevant information. </span><span class="kobospan" id="kobo.255.3">If we run this class as a standalone Python program, a sample output may look </span><span><span class="kobospan" id="kobo.256.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.257.1">
Random Solution =
[1 1 1 1 1 0 0 0 0 1 1 1 0 1 0 0 0 1 0 0 0 0]
- Adding map: weight = 9, value = 150, accumulated weight = 9, accumulated value = 150
- Adding compass: weight = 13, value = 35, accumulated weight = 22, accumulated value = 185
- Adding water: weight = 153, value = 200, accumulated weight = 175, accumulated value = 385
- Adding sandwich: weight = 50, value = 160, accumulated weight = 225, accumulated value = 545
- Adding glucose: weight = 15, value = 60, accumulated weight = 240, accumulated value = 605
- Adding beer: weight = 52, value = 10, accumulated weight = 292, accumulated value = 615
- Adding suntan cream: weight = 11, value = 70, accumulated weight = 303, accumulated value = 685
- Adding camera: weight = 32, value = 30, accumulated weight = 335, accumulated value = 715
- Adding trousers: weight = 48, value = 10, accumulated weight = 383, accumulated value = 725
- Total weight = 383, Total value = 725</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.258.1">Note that the last occurrence of </span><strong class="source-inline"><span class="kobospan" id="kobo.259.1">1</span></strong><span class="kobospan" id="kobo.260.1"> in the random solution, representing the </span><strong class="source-inline"><span class="kobospan" id="kobo.261.1">note-case</span></strong><span class="kobospan" id="kobo.262.1"> item, fell victim to the </span><em class="italic"><span class="kobospan" id="kobo.263.1">genotype-to-phenotype mapping</span></em><span class="kobospan" id="kobo.264.1"> discussed in the previous subsection. </span><span class="kobospan" id="kobo.264.2">As this item’s weight is 22, it would cause the total weight to exceed 400. </span><span class="kobospan" id="kobo.264.3">As a result, this item was not included in </span><span><span class="kobospan" id="kobo.265.1">the solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.266.1">This random solution, as you may expect, is far from being optimal. </span><span class="kobospan" id="kobo.266.2">Let’s try and find the optimal solution </span><a id="_idIndexMarker253" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.267.1">for this problem using a </span><span><span class="kobospan" id="kobo.268.1">genetic algorithm.</span></span></p>
<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor163" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.269.1">Genetic algorithm solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.270.1">To solve our </span><a id="_idIndexMarker254" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.271.1">knapsack 0-1 problem using a genetic algorithm, we created the </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">01-solve-knapsack.py</span></strong><span class="kobospan" id="kobo.273.1"> Python program located </span><span><span class="kobospan" id="kobo.274.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.275.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py</span></span></a><span><span class="kobospan" id="kobo.276.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.277.1">As a reminder, the chromosome representation we decided to use here is a list of integers with the values of 0 or 1. </span><span class="kobospan" id="kobo.277.2">This makes our problem, from the point of view of the genetic algorithm, similar to the OneMax problem we solved in the previous chapter. </span><span class="kobospan" id="kobo.277.3">The genetic algorithm doesn’t care what the chromosome represents (also known as the </span><em class="italic"><span class="kobospan" id="kobo.278.1">phenotype</span></em><span class="kobospan" id="kobo.279.1">) – a list of items to pack, a sequence of Boolean equation coefficients, or perhaps an actual binary number; it is only concerned with the chromosome itself (the </span><em class="italic"><span class="kobospan" id="kobo.280.1">genotype</span></em><span class="kobospan" id="kobo.281.1">) and the fitness value of that chromosome. </span><span class="kobospan" id="kobo.281.2">Mapping the chromosome to the solution it represents is carried out by the fitness evaluation function, which is implemented outside the genetic algorithm. </span><span class="kobospan" id="kobo.281.3">In our case, this chromosome mapping and fitness calculation is implemented by the </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">getValue()</span></strong><span class="kobospan" id="kobo.283.1"> method, which is encapsulated within the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">Knapsack01Problem</span></strong></span><span><span class="kobospan" id="kobo.285.1"> class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.286.1">The outcome of all this is that we can use the same genetic algorithm implementation that we used for the On-Max problem, with a </span><span><span class="kobospan" id="kobo.287.1">few adaptations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.288.1">The following steps describe the main points of </span><span><span class="kobospan" id="kobo.289.1">our solution:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.290.1">First, we need to create an instance of the knapsack problem we would like </span><span><span class="kobospan" id="kobo.291.1">to solve:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.292.1">
knapsack = knapsack.Knapsack01Problem()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.293.1">Then, we must instruct the genetic algorithm to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">getValue()</span></strong><span class="kobospan" id="kobo.295.1"> method of that instance for </span><span><span class="kobospan" id="kobo.296.1">fitness evaluation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.297.1">
def knapsackValue(individual):
    return knapsack.getValue(individual),
toolbox.register("evaluate", knapsackValue)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.298.1">The genetic operators that are used are compatible with the </span><span><span class="kobospan" id="kobo.299.1">binary-list chromosome:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.300.1">
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, 
    indpb=1.0/len(knapsack))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.301.1">Once the genetic algorithm stops, we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">printItems()</span></strong><span class="kobospan" id="kobo.303.1"> method to pretty-print the</span><a id="_idIndexMarker255" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.304.1"> best solution that </span><span><span class="kobospan" id="kobo.305.1">was found:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.306.1">
best = hof.items[0]
print("-- Knapsack Items = ")
knapsack.printItems(best)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.307.1">We can also tweak some of the parameters of the genetic algorithm. </span><span class="kobospan" id="kobo.307.2">As this particular problem uses a binary string of length 22, it seems easier than the 100-length OneMax problem we previously solved, so we can probably reduce the population size and maximum number </span><span><span class="kobospan" id="kobo.308.1">of generations.</span></span><p class="calibre3"><span class="kobospan" id="kobo.309.1">Upon running the algorithm for 50 generations, with a population size of 50, we get the </span><span><span class="kobospan" id="kobo.310.1">following outcome:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.311.1">
-- Best Ever Individual = [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1]
-- Best Ever Fitness = 1030.0
-- Knapsack Items =
- Adding map: weight = 9, value = 150, accumulated weight = 9, accumulated value = 150
- Adding compass: weight = 13, value = 35, accumulated weight = 22, accumulated value = 185
- Adding water: weight = 153, value = 200, accumulated weight = 175, accumulated value = 385
- Adding sandwich: weight = 50, value = 160, accumulated weight = 225, accumulated value = 545
- Adding glucose: weight = 15, value = 60, accumulated weight = 240, accumulated value = 605
- Adding banana: weight = 27, value = 60, accumulated weight = 267, accumulated value = 665
- Adding suntan cream: weight = 11, value = 70, accumulated weight = 278, accumulated value = 735
- Adding waterproof trousers: weight = 42, value = 70, accumulated weight = 320, accumulated value = 805
- Adding waterproof overclothes: weight = 43, value = 75, accumulated weight = 363, accumulated value = 880
- Adding note-case: weight = 22, value = 80, accumulated weight = 385, accumulated value = 960
- Adding sunglasses: weight = 7, value = 20, accumulated weight = 392, accumulated value = 980
- Adding socks: weight = 4, value = 50, accumulated weight = 396, accumulated value = 1030
- Total weight = 396, Total value = 1030</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.312.1">The total value </span><a id="_idIndexMarker256" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.313.1">of </span><strong class="source-inline"><span class="kobospan" id="kobo.314.1">1030</span></strong><span class="kobospan" id="kobo.315.1"> is the known optimal solution for </span><span><span class="kobospan" id="kobo.316.1">this problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.317.1">Here, too, we can see that the last occurrence of 1 in the chromosome of the best individual, representing the </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">book</span></strong><span class="kobospan" id="kobo.319.1"> item, was sacrificed to the actual solution in the mapping to keep the accumulated weight from exceeding the limit </span><span><span class="kobospan" id="kobo.320.1">of 400.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.321.1">The following figure, which depicts the max and average fitness over the generations, indicates that the best solution was found in less than </span><span><span class="kobospan" id="kobo.322.1">10 generations:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer060">
<span class="kobospan" id="kobo.323.1"><img alt="Figure 4.1: Stats of the program solving the knapsack 0-1 problem" src="image/B20851_04_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.324.1">Figure 4.1: Stats of the program solving the knapsack 0-1 problem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">In the next </span><a id="_idIndexMarker257" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.326.1">section, we will shift gears and tackle a more involved, yet still classic, combinatorial search task known as </span><span><span class="kobospan" id="kobo.327.1">the TSP.</span></span></p>
<h1 id="_idParaDest-120" class="calibre5"><a id="_idTextAnchor164" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.328.1">Solving the TSP</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.329.1">Imagine that you</span><a id="_idIndexMarker258" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.330.1"> manage a small fulfillment center and need to deliver packages to a list of customers using a single vehicle. </span><span class="kobospan" id="kobo.330.2">What’s the best route for the vehicle to take so that you can visit all your customers and then return to the starting point? </span><span class="kobospan" id="kobo.330.3">This is an example of the </span><span><span class="kobospan" id="kobo.331.1">classic </span></span><span><strong class="bold"><span class="kobospan" id="kobo.332.1">TSP</span></strong></span><span><span class="kobospan" id="kobo.333.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.334.1">The TSP dates back to 1930, and since then has been one of the most thoroughly studied problems in optimization. </span><span class="kobospan" id="kobo.334.2">It is often used to benchmark optimization algorithms. </span><span class="kobospan" id="kobo.334.3">The problem has many variants, but it was originally formulated after a traveling salesman who needs to take a trip that covers </span><span><span class="kobospan" id="kobo.335.1">several cities:</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.336.1">“Given a list of cities and the distances between each pair of the cities, find the shortest possible path that goes through all the cities and then returns to the starting city.”</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.337.1">Using combinatorics, you could find that when given </span><em class="italic"><span class="kobospan" id="kobo.338.1">n</span></em><span class="kobospan" id="kobo.339.1"> cities, the number of possible paths that go through all cities is </span><span><span class="kobospan" id="kobo.340.1">(</span></span><span><span class="kobospan" id="kobo.341.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.342.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.343.1">1)</span></span><span> </span><span><span class="kobospan" id="kobo.344.1">!/</span></span><span> </span><span><span><span class="kobospan" id="kobo.345.1">2</span></span></span><span><span class="kobospan" id="kobo.346.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.347.1">The following figure shows the shortest path for the traveling salesperson problem that covers the 15 largest cities </span><span><span class="kobospan" id="kobo.348.1">in Germany:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer061">
<span class="kobospan" id="kobo.349.1"><img alt="Figure 4.2: The shortest TSP path for the 15 largest cities in Germany. " src="image/B20851_04_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.350.1">Figure 4.2: The shortest TSP path for the 15 largest cities in Germany. </span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.351.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:TSP_Deutschland_3.png" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.352.1">https://commons.wikimedia.org/wiki/File:TSP_Deutschland_3.png</span></a><span class="kobospan" id="kobo.353.1">. </span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.354.1">Image by Kapitän Nemo.</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.355.1">In this case, </span><em class="italic"><span class="kobospan" id="kobo.356.1">n=15</span></em><span class="kobospan" id="kobo.357.1">, so the</span><a id="_idIndexMarker259" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.358.1"> number of possible routes is </span><em class="italic"><span class="kobospan" id="kobo.359.1">14!/2</span></em><span class="kobospan" id="kobo.360.1">, which amounts to the staggering number </span><span><span class="kobospan" id="kobo.361.1">of 43,589,145,600.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.362.1">In the context of search algorithms, each path (or partial path) through the cities represents a state, and the set of all possible paths is considered the state space. </span><span class="kobospan" id="kobo.362.2">Each of the paths has a corresponding “cost” – the length (distance) of the path – and we are looking for the path that will minimize </span><span><span class="kobospan" id="kobo.363.1">this distance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.364.1">As we pointed out, the state space is very large, even for a moderate number of cities, which can make it prohibitively expensive to evaluate every possible path. </span><span class="kobospan" id="kobo.364.2">As a result, even though it is relatively easy to find a path that goes through all the cities, finding the </span><em class="italic"><span class="kobospan" id="kobo.365.1">optimal</span></em><span class="kobospan" id="kobo.366.1"> path can</span><a id="_idIndexMarker260" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.367.1"> be </span><span><span class="kobospan" id="kobo.368.1">very hard.</span></span></p>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor165" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.369.1">TSPLIB benchmark files</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.370.1">The </span><strong class="bold"><span class="kobospan" id="kobo.371.1">TSPLIB</span></strong><span class="kobospan" id="kobo.372.1"> is a</span><a id="_idIndexMarker261" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.373.1"> library containing </span><a id="_idIndexMarker262" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.374.1">sample problems for the TSP based on the actual geographic locations of cities. </span><span class="kobospan" id="kobo.374.2">The library is maintained by Heidelberg University, and relevant examples can be found </span><span><span class="kobospan" id="kobo.375.1">here: </span></span><a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.376.1">http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/</span></span></a><span><span class="kobospan" id="kobo.377.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.378.1">Two types of files can be found on this web page: files with the</span><strong class="source-inline"><span class="kobospan" id="kobo.379.1">.tsp.gz</span></strong><span class="kobospan" id="kobo.380.1"> suffix, each of them containing the description of a particular TSP problem, and the corresponding  </span><strong class="source-inline"><span class="kobospan" id="kobo.381.1">.opt.tour.gz</span></strong><span class="kobospan" id="kobo.382.1"> files, containing the optimal solution for </span><span><span class="kobospan" id="kobo.383.1">each problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.384.1">The problem description files are text-based and white-space delimited. </span><span class="kobospan" id="kobo.384.2">A typical file contains several informational lines, followed by city data. </span><span class="kobospan" id="kobo.384.3">We are interested in files that include the x, y coordinates of the participating cities so that we can plot the cities and visualize their locations. </span><span class="kobospan" id="kobo.384.4">For example, the contents of the </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">burma14.tsp.gz</span></strong><span class="kobospan" id="kobo.386.1"> file, once unzipped, look as follows (with some of the lines omitted here </span><span><span class="kobospan" id="kobo.387.1">for brevity):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.388.1">
NAME: burma14
TYPE: TSP
...
</span><span class="kobospan1" id="kobo.388.2">NODE_COORD_SECTION
   1  16.47       96.10
   2  16.47       94.44
   3  20.09       92.54
   ...
</span><span class="kobospan1" id="kobo.388.3">  12  21.52       95.59
  13  19.41       97.13
  14  20.09       94.55
EOF</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.389.1">The interesting section for us is the lines between </span><strong class="source-inline"><span class="kobospan" id="kobo.390.1">NODE_COORD_SECTION</span></strong><span class="kobospan" id="kobo.391.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">EOF</span></strong><span class="kobospan" id="kobo.393.1">. </span><span class="kobospan" id="kobo.393.2">In some of the files, </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">DISPLAY_DATA_SECTION</span></strong><span class="kobospan" id="kobo.395.1"> is used instead </span><span><span class="kobospan" id="kobo.396.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">NODE_COORD_SECTION</span></strong></span><span><span class="kobospan" id="kobo.398.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.399.1">Are we ready to solve a sample problem? </span><span class="kobospan" id="kobo.399.2">Well, before we start doing that, we still need to figure out how </span><a id="_idIndexMarker263" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.400.1">a potential solution will be represented. </span><span class="kobospan" id="kobo.400.2">This will be addressed in the </span><span><span class="kobospan" id="kobo.401.1">next subsection.</span></span></p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor166" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.402.1">Solution representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.403.1">When solving the </span><a id="_idIndexMarker264" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.404.1">TSP, the cities are typically represented by numbers from </span><span><span class="kobospan" id="kobo.405.1">0</span></span><span> </span><span class="kobospan" id="kobo.406.1">to </span><em class="italic"><span class="kobospan" id="kobo.407.1">n-1</span></em><span class="kobospan" id="kobo.408.1">, and possible solutions will be sequences of these numbers. </span><span class="kobospan" id="kobo.408.2">A problem with five cities, for example, can have solutions of the form [0,1, 2, 3, 4], [2, 4, 3, 1, 0], and so on. </span><span class="kobospan" id="kobo.408.3">Each solution can be evaluated by calculating and totaling the distances between each two subsequent cities, then adding the distance between the last city to the first one. </span><span class="kobospan" id="kobo.408.4">Consequently, when applying the genetic algorithms approach to this problem, we can use a similar list of integers to serve as </span><span><span class="kobospan" id="kobo.409.1">the chromosome.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.410.1">The Python class described in the next subsection reads the contents of TSPLIB files and calculates the distances between each two cities. </span><span class="kobospan" id="kobo.410.2">In addition, it calculates the total distance covered by a given potential solution using the list representation we </span><span><span class="kobospan" id="kobo.411.1">just discussed.</span></span></p>
<h2 id="_idParaDest-123" class="calibre7"><a id="_idTextAnchor167" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.412.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.413.1">To encapsulate </span><a id="_idIndexMarker265" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.414.1">the TSP problem, we’ve created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">TravelingSalesmanProblem</span></strong><span class="kobospan" id="kobo.416.1">. </span><span class="kobospan" id="kobo.416.2">This class is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.417.1">tsp.py</span></strong><span class="kobospan" id="kobo.418.1"> file and can be found </span><span><span class="kobospan" id="kobo.419.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/tsp.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.420.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/tsp.py</span></span></a><span><span class="kobospan" id="kobo.421.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.422.1">The class provides the following </span><span><span class="kobospan" id="kobo.423.1">private methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.424.1">__create_data()</span></strong><span class="kobospan" id="kobo.425.1">: This reads the desired TSPLIB file, extracts the coordinates of all cities, calculates the distances between every two cities, and uses them to populate a distance matrix (two-dimensional array). </span><span class="kobospan" id="kobo.425.2">It then serializes the city locations and the calculated distances to disk using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.426.1">pickle</span></strong></span><span><span class="kobospan" id="kobo.427.1"> utility.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.428.1">__read_data()</span></strong><span class="kobospan" id="kobo.429.1">: This reads the serialized data and, if not available, calls </span><strong class="source-inline1"><span class="kobospan" id="kobo.430.1">__create_data()</span></strong><span class="kobospan" id="kobo.431.1"> to </span><span><span class="kobospan" id="kobo.432.1">prepare it.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.433.1">These methods are invoked internally by the constructor, so the data is initialized as soon as the instance </span><span><span class="kobospan" id="kobo.434.1">is created.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.435.1">In addition, the class provides the following </span><span><span class="kobospan" id="kobo.436.1">public methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.437.1">getTotalDistance(indices)</span></strong><span class="kobospan" id="kobo.438.1">: This calculates the total distance of the path described by the given list of </span><span><span class="kobospan" id="kobo.439.1">city indices</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.440.1">plotData(indices)</span></strong><span class="kobospan" id="kobo.441.1">: This clots the path described by the given list of </span><span><span class="kobospan" id="kobo.442.1">city indices</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.443.1">The main method of the class exercises the class methods mentioned previously: first, it creates the </span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">bayg29</span></strong><span class="kobospan" id="kobo.445.1"> problem (29 cities in Bavaria), then calculates the distance for the hard-coded </span><a id="_idIndexMarker266" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.446.1">optimal solution (as described in the matching </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">.opt.tour</span></strong><span class="kobospan" id="kobo.448.1"> file), and finally plots it. </span><span class="kobospan" id="kobo.448.2">So, if we run this class as a standalone Python program, the output will be </span><span><span class="kobospan" id="kobo.449.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.450.1">
Problem name: bayg29
Optimal solution = [0, 27, 5, 11, 8, 25, 2, 28, 4, 20, 1, 19, 9, 3, 14, 17, 13, 16, 21, 10, 18, 24, 6, 22, 7, 26, 15, 12, 23]
Optimal distance = 9074.147</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.451.1">The plot of the optimal solution looks </span><span><span class="kobospan" id="kobo.452.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer062">
<span class="kobospan" id="kobo.453.1"><img alt="Figure 4.3: A plot of the optimal solution for the “bayg29” TSP. The red dots represent cities" src="image/B20851_04_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.454.1">Figure 4.3: A plot of the optimal solution for the “bayg29” TSP. </span><span class="kobospan" id="kobo.454.2">The red dots represent cities</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.455.1">Next, we will try </span><a id="_idIndexMarker267" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.456.1">to reach this optimal solution using a </span><span><span class="kobospan" id="kobo.457.1">genetic algorithm.</span></span></p>
<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor168" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.458.1">Genetic algorithm solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.459.1">For our first attempt</span><a id="_idIndexMarker268" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.460.1"> at solving the TSP using a genetic algorithm, we created the </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">02-solve-tsp-first-attempt.py</span></strong><span class="kobospan" id="kobo.462.1"> Python program, which is located </span><span><span class="kobospan" id="kobo.463.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/02_solve_tsp_first_attempt.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.464.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/02_solve_tsp_first_attempt.py</span></span></a><span><span class="kobospan" id="kobo.465.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.466.1">The main parts of our solution are described in the </span><span><span class="kobospan" id="kobo.467.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.468.1">The program starts by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.469.1">bayg29</span></strong><span class="kobospan" id="kobo.470.1"> problem, </span><span><span class="kobospan" id="kobo.471.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.472.1">
TSP_NAME = "bayg29"
tsp = tsp.TravelingSalesmanProblem(TSP_NAME)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.473.1">Next, we need to define the fitness strategy. </span><span class="kobospan" id="kobo.473.2">Here, we want to minimize the distance, which translates to a single-objective minimizing </span><strong class="source-inline1"><span class="kobospan" id="kobo.474.1">fitness</span></strong><span class="kobospan" id="kobo.475.1"> class that’s defined using a single </span><span><span class="kobospan" id="kobo.476.1">negative weight:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.477.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.478.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.479.1">", base.Fitness, weights=(</span><strong class="bold1"><span class="kobospan1" id="kobo.480.1">-1.0</span></strong><span class="kobospan1" id="kobo.481.1">,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.482.1">As we discussed a little earlier, our choice of chromosome for the genetic algorithm is a list of integers from 0 to </span><em class="italic"><span class="kobospan" id="kobo.483.1">n-1</span></em><span class="kobospan" id="kobo.484.1">, where </span><em class="italic"><span class="kobospan" id="kobo.485.1">n</span></em><span class="kobospan" id="kobo.486.1"> is the number of cities, representing the city indices. </span><span class="kobospan" id="kobo.486.2">As an example, the optimal solution we saw earlier for the “</span><strong class="source-inline1"><span class="kobospan" id="kobo.487.1">bayg29</span></strong><span class="kobospan" id="kobo.488.1">” problem was represented with the </span><span><span class="kobospan" id="kobo.489.1">following chromosome:</span></span><p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.490.1">[0, 27, 5, 11, 8, 25, 2, 28, 4, 20, 1, 19, 9, 3, 14, 17, 13, 16, 21, 10, 18, 24, 6, 22, 7, 26, 15, </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.491.1">12, 23]</span></strong></span></p><p class="calibre3"><span class="kobospan" id="kobo.492.1">The following</span><a id="_idIndexMarker269" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.493.1"> code snippet is responsible for implementing this chromosome. </span><span class="kobospan" id="kobo.493.2">It’s explained </span><span><span class="kobospan" id="kobo.494.1">further after:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.495.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.496.1">Individual</span></strong><span class="kobospan1" id="kobo.497.1">", array.array, typecode='i', 
    fitness=creator.FitnessMin)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.498.1">randomOrder</span></strong><span class="kobospan1" id="kobo.499.1">", random.sample, 
    range(len(tsp)), len(tsp))
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.500.1">individualCreator</span></strong><span class="kobospan1" id="kobo.501.1">", tools.initIterate, 
    creator.Individual, toolbox.randomOrder)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.502.1">populationCreator</span></strong><span class="kobospan1" id="kobo.503.1">", tools.initRepeat, list, 
    toolbox.individualCreator)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.504.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">Individual</span></strong><span class="kobospan" id="kobo.506.1"> class is created first, extending an array of integers and augmenting it with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">FitnessMin</span></strong></span><span><span class="kobospan" id="kobo.508.1"> class.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.509.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.510.1">randomOrder</span></strong><span class="kobospan" id="kobo.511.1"> operator is then registered to provide the results of </span><strong class="source-inline"><span class="kobospan" id="kobo.512.1">random.sample()</span></strong><span class="kobospan" id="kobo.513.1"> invocation over a range defined by the length of the TSP problem (the number of cities, or </span><em class="italic"><span class="kobospan" id="kobo.514.1">n</span></em><span class="kobospan" id="kobo.515.1">). </span><span class="kobospan" id="kobo.515.2">This will result in a randomly generated list of indices between 0 </span><span><span class="kobospan" id="kobo.516.1">and </span></span><span><em class="italic"><span class="kobospan" id="kobo.517.1">n-1</span></em></span><span><span class="kobospan" id="kobo.518.1">.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.519.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.520.1">IndividualCreator</span></strong><span class="kobospan" id="kobo.521.1"> operator is created next. </span><span class="kobospan" id="kobo.521.2">When called, it will invoke the </span><strong class="source-inline"><span class="kobospan" id="kobo.522.1">randomOrder</span></strong><span class="kobospan" id="kobo.523.1"> operator and iterate over the results to create a valid chromosome consisting of the </span><span><span class="kobospan" id="kobo.524.1">city indices.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.525.1">The last operator, </span><strong class="source-inline"><span class="kobospan" id="kobo.526.1">populationCreator</span></strong><span class="kobospan" id="kobo.527.1">, is created to produce a list of individuals using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">IndividualCreator</span></strong></span><span><span class="kobospan" id="kobo.529.1"> operator.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.530.1">Now that the </span><a id="_idIndexMarker270" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.531.1">chromosome has been implemented, it’s time to define the fitness evaluation function. </span><span class="kobospan" id="kobo.531.2">This is carried out by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.532.1">tspDistance()</span></strong><span class="kobospan" id="kobo.533.1"> function, which directly utilizes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.534.1">getTotalDistance()</span></strong><span class="kobospan" id="kobo.535.1"> method of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.536.1">TravelingSalesmanProblem</span></strong></span><span><span class="kobospan" id="kobo.537.1"> class:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.538.1">
def tpsDistance(individual):
    return tsp.getTotalDistance(individual),  # return a tuple
toolbox.register("evaluate", tpsDistance)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.539.1">Next, we need to define the genetic operators. </span><span class="kobospan" id="kobo.539.2">For the selection operator, we can use tournament selection with a tournament size of </span><strong class="source-inline1"><span class="kobospan" id="kobo.540.1">3</span></strong><span class="kobospan" id="kobo.541.1">, as we did in </span><span><span class="kobospan" id="kobo.542.1">previous cases:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.543.1">
toolbox.register("select", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.544.1">selTournament</span></strong><span class="kobospan1" id="kobo.545.1">, tournsize=3)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.546.1">However, before picking the crossover and mutation operators, we need to remember that the chromosome we use is not just a list of integers but a list of indices (or an </span><strong class="bold"><span class="kobospan" id="kobo.547.1">ordered list</span></strong><span class="kobospan" id="kobo.548.1">) that represent the order of the cities, and therefore we cannot just mix parts of two lists or arbitrarily change an index in the list. </span><span class="kobospan" id="kobo.548.2">Instead, we need to use specialized operators that were designed to produce valid lists of indices. </span><span class="kobospan" id="kobo.548.3">In </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.549.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.550.1">, </span><em class="italic"><span class="kobospan" id="kobo.551.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.552.1">, we examined several of these operators, including </span><strong class="bold"><span class="kobospan" id="kobo.553.1">ordered crossover</span></strong><span class="kobospan" id="kobo.554.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.555.1">scramble mutation</span></strong><span class="kobospan" id="kobo.556.1">. </span><span class="kobospan" id="kobo.556.2">Here, we’re using DEAP’s corresponding implementations of these operators, </span><strong class="source-inline1"><span class="kobospan" id="kobo.557.1">cxOrdered</span></strong> <span><span class="kobospan" id="kobo.558.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.559.1">mutShuffleIndexes</span></strong></span><span><span class="kobospan" id="kobo.560.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.561.1">
toolbox.register("mate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.562.1">cxOrdered</span></strong><span class="kobospan1" id="kobo.563.1">)
toolbox.register("mutate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.564.1">mutShuffleIndexes</span></strong><span class="kobospan1" id="kobo.565.1">, 
    indpb=1.0/len(tsp))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.566.1">Finally, it’s time to invoke the genetic algorithm flow. </span><span class="kobospan" id="kobo.566.2">Here, we use the default DEAP built-in </span><strong class="source-inline1"><span class="kobospan" id="kobo.567.1">eaSimple</span></strong><span class="kobospan" id="kobo.568.1"> algorithm, with our default </span><strong class="source-inline1"><span class="kobospan" id="kobo.569.1">stats</span></strong><span class="kobospan" id="kobo.570.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.571.1">halloffame</span></strong><span class="kobospan" id="kobo.572.1"> objects to provide information we can </span><span><span class="kobospan" id="kobo.573.1">display later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.574.1">
population, logbook = algorithms.</span><strong class="bold1"><span class="kobospan1" id="kobo.575.1">eaSimple</span></strong><span class="kobospan1" id="kobo.576.1">(population, \
    toolbox, cxpb=P_CROSSOVER, mutpb=P_MUTATION, \
    ngen=MAX_GENERATIONS, stats=stats, halloffame=hof, \
    verbose=True)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.577.1">Running this</span><a id="_idIndexMarker271" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.578.1"> program with the constant values appearing at the top of the file (a population size of 300, 200 generations, a crossover probability of 0.9, and a mutation probability of 0.1) yields the </span><span><span class="kobospan" id="kobo.579.1">following results:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.580.1">
-- Best Ever Individual = Individual('i', [0, 27, 11, 5, 20, 4, 8, 25, 2, 28, 1, 19, 9, 3, 14, 17, 13, 16, 21, 10, 18, 12, 23, 7, 26, 22, 6, 24, 15])
-- Best Ever Fitness = 9549.9853515625</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.581.1">The best fitness found (9549.98) is not too far from the known optimal distance </span><span><span class="kobospan" id="kobo.582.1">of 9074.14.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.583.1">The program then produces two plots. </span><span class="kobospan" id="kobo.583.2">The first plot illustrates the path of the best individual found during </span><span><span class="kobospan" id="kobo.584.1">the run:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer063">
<span class="kobospan" id="kobo.585.1"><img alt="Figure 4.4: A plot of the best solution found by the first program attempting to solve the “bayg29” TSP" src="image/B20851_04_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.586.1">Figure 4.4: A plot of the best solution found by the first program attempting to solve the “bayg29” TSP</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.587.1">The second</span><a id="_idIndexMarker272" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.588.1"> plot shows the statistics of the genetic flow. </span><span class="kobospan" id="kobo.588.2">Note that this time, we chose to collect data for the </span><em class="italic"><span class="kobospan" id="kobo.589.1">minimum</span></em><span class="kobospan" id="kobo.590.1"> fitness value rather than the maximum as the objective of this problem is to minimize </span><span><span class="kobospan" id="kobo.591.1">the distance:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer064">
<span class="kobospan" id="kobo.592.1"><img alt="Figure 4.5: Stats of the first program attempting to solve the “bayg29” TSP" src="image/B20851_04_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.593.1">Figure 4.5: Stats of the first program attempting to solve the “bayg29” TSP</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">Now that we’ve found a good solution but not the best-known one, we can try and figure out ways to improve the results. </span><span class="kobospan" id="kobo.594.2">For example, we can experiment with changing the population size, number of generations, and probabilities. </span><span class="kobospan" id="kobo.594.3">We can also replace the genetic</span><a id="_idIndexMarker273" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.595.1"> operators with other compatible ones. </span><span class="kobospan" id="kobo.595.2">We can even change the random seed we set just to see the effect on the results or make multiple runs with different seeds. </span><span class="kobospan" id="kobo.595.3">In the next section, we will try to use </span><strong class="bold"><span class="kobospan" id="kobo.596.1">elitism</span></strong><span class="kobospan" id="kobo.597.1"> combined </span><a id="_idIndexMarker274" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.598.1">with </span><strong class="bold"><span class="kobospan" id="kobo.599.1">enhanced exploration</span></strong><span class="kobospan" id="kobo.600.1"> to improve </span><span><span class="kobospan" id="kobo.601.1">our results.</span></span></p>
<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor169" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.602.1">Improving the results with enhanced exploration and elitism</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.603.1">If we try to </span><a id="_idIndexMarker275" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.604.1">increase</span><a id="_idIndexMarker276" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.605.1"> the </span><a id="_idIndexMarker277" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.606.1">number of generations in the previous program, we will realize that the solution doesn’t improve – it’s stuck in the (somewhat) suboptimal solution that was reached sometime before generation 200. </span><span class="kobospan" id="kobo.606.2">This is shown in the following plot, which displays </span><span><span class="kobospan" id="kobo.607.1">500 generations:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer065">
<span class="kobospan" id="kobo.608.1"><img alt="Figure 4.6: Stats of the first program, running for 500 generations" src="image/B20851_04_06.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.609.1">Figure 4.6: Stats of the first program, running for 500 generations</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.610.1">From that point on, the similarity between the average value and the best value indicates that this solution took over the population and therefore we will not see any improvement unless a lucky mutation turns up. </span><span class="kobospan" id="kobo.610.2">In genetic algorithms terms, this means that </span><strong class="bold"><span class="kobospan" id="kobo.611.1">exploitation</span></strong><span class="kobospan" id="kobo.612.1"> has overpowered </span><strong class="bold"><span class="kobospan" id="kobo.613.1">exploration</span></strong><span class="kobospan" id="kobo.614.1">. </span><span class="kobospan" id="kobo.614.2">Exploitation generally means taking advantage</span><a id="_idIndexMarker278" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.615.1"> of </span><a id="_idIndexMarker279" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.616.1">the </span><a id="_idIndexMarker280" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.617.1">current available results, while exploration emphasizes the search for new solutions. </span><span class="kobospan" id="kobo.617.2">Striking a delicate balance between the two can lead to </span><span><span class="kobospan" id="kobo.618.1">better results.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.619.1">One way to increase exploration could involve reducing the tournament size of the tournament selection that’s used from 3 </span><span><span class="kobospan" id="kobo.620.1">to 2:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.621.1">
toolbox.register("select", tools.selTournament, </span><strong class="bold1"><span class="kobospan1" id="kobo.622.1">tournsize=2</span></strong><span class="kobospan1" id="kobo.623.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.624.1">As we discussed in </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.625.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.626.1">, </span><em class="italic"><span class="kobospan" id="kobo.627.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.628.1">, this will increase the chances of less successful individuals being selected. </span><span class="kobospan" id="kobo.628.2">These individuals may carry the key to better future solutions. </span><span class="kobospan" id="kobo.628.3">However, if we run the same program after making this change, the results are far from impressive – the best fitness value is over 13,000, and the best solution plot looks </span><span><span class="kobospan" id="kobo.629.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer066">
<span class="kobospan" id="kobo.630.1"><img alt="Figure 4.7: A plot of the best solution found by the program with the tournament size reduced to 2" src="image/B20851_04_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.631.1">Figure 4.7: A plot of the best solution found by the program with the tournament size reduced to 2</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.632.1">These </span><a id="_idIndexMarker281" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.633.1">poor</span><a id="_idIndexMarker282" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.634.1"> results</span><a id="_idIndexMarker283" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.635.1"> can be explained using the </span><span><span class="kobospan" id="kobo.636.1">statistics plot:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer067">
<span class="kobospan" id="kobo.637.1"><img alt="Figure 4.8: Stats of the program with the tournament size reduced to 2" src="image/B20851_04_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.638.1">Figure 4.8: Stats of the program with the tournament size reduced to 2</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.639.1">This plot illustrates that we cannot retain the best solutions. </span><span class="kobospan" id="kobo.639.2">As evident from the “noisy” graph, which</span><a id="_idIndexMarker284" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.640.1"> keeps </span><a id="_idIndexMarker285" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.641.1">jumping </span><a id="_idIndexMarker286" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.642.1">between better values to worse values, good solutions tend to quickly get “lost” due to the more permissive selection scheme, which often enables lesser solutions to be selected. </span><span class="kobospan" id="kobo.642.2">This means that we let exploration go too far, and to balance it out, we need to re-introduce a measure of exploitation into the mix. </span><span class="kobospan" id="kobo.642.3">This can be done using the </span><strong class="bold"><span class="kobospan" id="kobo.643.1">elitism</span></strong><span class="kobospan" id="kobo.644.1"> mechanism, which was first introduced in </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.645.1">Chapter 2</span></em></span></a><span><span class="kobospan" id="kobo.646.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.647.1">Elitism enables us to keep the best solutions intact by letting them “skip” the genetic operators of selection, crossover, and mutation during the genetic flow. </span><span class="kobospan" id="kobo.647.2">To implement elitism, we will have to go “under the hood” and modify DEAP’s </span><strong class="source-inline"><span class="kobospan" id="kobo.648.1">algorithms.eaSimple()</span></strong><span class="kobospan" id="kobo.649.1"> algorithm as the framework doesn’t provide a direct way to skip all </span><span><span class="kobospan" id="kobo.650.1">three operators.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.651.1">The modified algorithm, called </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">eaSimpleWithElitism()</span></strong><span class="kobospan" id="kobo.653.1">, can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.654.1">elitism.py</span></strong><span class="kobospan" id="kobo.655.1"> file, located </span><span><span class="kobospan" id="kobo.656.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.657.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py</span></span></a><span><span class="kobospan" id="kobo.658.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.659.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.660.1">eaSimpleWithElitism()</span></strong><span class="kobospan" id="kobo.661.1"> method is similar to the original </span><strong class="source-inline"><span class="kobospan" id="kobo.662.1">eaSimple()</span></strong><span class="kobospan" id="kobo.663.1">, with the modification that the </span><strong class="source-inline"><span class="kobospan" id="kobo.664.1">halloffame</span></strong><span class="kobospan" id="kobo.665.1"> object is now used to implement an elitism mechanism. </span><span class="kobospan" id="kobo.665.2">The individuals contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.666.1">halloffame</span></strong><span class="kobospan" id="kobo.667.1"> object are directly injected into the next generation and are not subject to the genetic operators of selection, crossover, and mutation. </span><span class="kobospan" id="kobo.667.2">This is essentially the outcome of the </span><span><span class="kobospan" id="kobo.668.1">following modifications:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.669.1">Instead of selecting several individuals equal to the population size, this number of selected individuals is reduced by the number of </span><span><span class="kobospan" id="kobo.670.1">hall-of-fame individuals:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.671.1">
offspring = toolbox.select(population, 
    len(population) </span><strong class="bold1"><span class="kobospan1" id="kobo.672.1">- hof_size</span></strong><span class="kobospan1" id="kobo.673.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.674.1">After the genetic operators have been applied, the hall-of-fame individuals are added back into </span><span><span class="kobospan" id="kobo.675.1">the population:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.676.1">
offspring.extend(halloffame.items)</span></pre></li> </ul>
<p class="calibre3"><span class="kobospan" id="kobo.677.1">We can now</span><a id="_idIndexMarker287" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.678.1"> replace the call to </span><strong class="source-inline"><span class="kobospan" id="kobo.679.1">algorithms.eaSimple()</span></strong><span class="kobospan" id="kobo.680.1"> with a call to </span><strong class="source-inline"><span class="kobospan" id="kobo.681.1">elitism.eaSimpleWithElitism()</span></strong><span class="kobospan" id="kobo.682.1">, without changing any of the parameters. </span><span class="kobospan" id="kobo.682.2">Then, we’ll</span><a id="_idIndexMarker288" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.683.1"> set the </span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">HALL_OF_FAME_SIZE</span></strong><span class="kobospan" id="kobo.685.1"> constant </span><a id="_idIndexMarker289" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.686.1">to 30, which means that we will always keep the best 30 individuals in </span><span><span class="kobospan" id="kobo.687.1">the population.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.688.1">The modified Python program, </span><strong class="source-inline"><span class="kobospan" id="kobo.689.1">03-solve-tsp.py</span></strong><span class="kobospan" id="kobo.690.1"> can be found </span><span><span class="kobospan" id="kobo.691.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.692.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py</span></span></a><span><span class="kobospan" id="kobo.693.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.694.1">Upon running this new program, we are now able to hit the </span><span><span class="kobospan" id="kobo.695.1">optimal solution:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.696.1">
-- Best Ever Individual = Individual('i', [0, 23, 12, 15, 26, 7, 22, 6, 24, 18, 10, 21, 16, 13, 17, 14, 3, 9, 19, 1, 20, 4, 28, 2, 25, 8, 11, 5, 27])
-- Best Ever Fitness = 9074.146484375</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.697.1">The solution plot is identical to the optimal one we </span><span><span class="kobospan" id="kobo.698.1">saw previously:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer068">
<span class="kobospan" id="kobo.699.1"><img alt="Figure 4.9: A plot of the best solution found by the program using a tournament size of 2 and elitism" src="image/B20851_04_09.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.700.1">Figure 4.9: A plot of the best solution found by the program using a tournament size of 2 and elitism</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.701.1">The</span><a id="_idIndexMarker290" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.702.1"> following</span><a id="_idIndexMarker291" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.703.1"> statistics </span><a id="_idIndexMarker292" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.704.1">plot indicates that we were able to eliminate the “noise” we observed before. </span><span class="kobospan" id="kobo.704.2">We were also able to keep some distance between the average value and the best values for a lot longer compared to the </span><span><span class="kobospan" id="kobo.705.1">original attempt:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer069">
<span class="kobospan" id="kobo.706.1"><img alt="Figure 4.10: Stats of the program using a tournament size of 2 and elitism" src="image/B20851_04_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.707.1">Figure 4.10: Stats of the program using a tournament size of 2 and elitism</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.708.1">In the next</span><a id="_idIndexMarker293" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.709.1"> section, we </span><a id="_idIndexMarker294" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.710.1">will look into</span><a id="_idIndexMarker295" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.711.1"> the </span><strong class="bold"><span class="kobospan" id="kobo.712.1">VRP</span></strong><span class="kobospan" id="kobo.713.1">, which adds an interesting twist to the problem we </span><span><span class="kobospan" id="kobo.714.1">just solved.</span></span></p>
<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor170" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.715.1">Solving the VRP</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.716.1">Imagine that you</span><a id="_idIndexMarker296" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.717.1"> now manage a larger fulfillment center. </span><span class="kobospan" id="kobo.717.2">You still need to deliver packages to a list of customers, but now, you have a fleet of several vehicles at your disposal. </span><span class="kobospan" id="kobo.717.3">What’s the best way to deliver the packages to the customers using </span><span><span class="kobospan" id="kobo.718.1">these vehicles?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.719.1">This is an example of the VRP, a generalization of the TSP described in the previous section. </span><span class="kobospan" id="kobo.719.2">The basic VRP consists of the following </span><span><span class="kobospan" id="kobo.720.1">three components:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.721.1">The list of locations that need to </span><span><span class="kobospan" id="kobo.722.1">be visited</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.723.1">The number </span><span><span class="kobospan" id="kobo.724.1">of vehicles</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.725.1">The location of the depot, which is used as the starting and ending point for each of </span><span><span class="kobospan" id="kobo.726.1">the vehicles</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.727.1">The problem has numerous variations, such as several depot locations, time-critical deliveries, different types of vehicles (varying capacity, varying fuel consumption), and </span><span><span class="kobospan" id="kobo.728.1">many more.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.729.1">The goal of the problem is to minimize the cost, which can also be defined in many different ways. </span><span class="kobospan" id="kobo.729.2">Examples include minimizing the time it takes to deliver all the packages, minimizing the cost of the fuel, and minimizing the variation in travel time among the </span><span><span class="kobospan" id="kobo.730.1">vehicles used.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.731.1">An illustration of a VRP with three vehicles is shown here. </span><span class="kobospan" id="kobo.731.2">The cities are marked with dark circles and the</span><a id="_idIndexMarker297" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.732.1"> depot location with an empty square, while the routes of the three vehicles are marked with three </span><span><span class="kobospan" id="kobo.733.1">different colors:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer070">
<span class="kobospan" id="kobo.734.1"><img alt="Figure 4.11: Example VRP with three vehicles" src="image/B20851_04_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.735.1">Figure 4.11: Example VRP with three vehicles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.736.1">In our example, we will aim to optimize the time it takes to deliver all the packages. </span><span class="kobospan" id="kobo.736.2">Since all the vehicles operate simultaneously, this measure is determined by the vehicle making the longest route. </span><span class="kobospan" id="kobo.736.3">Therefore, we can make it our objective to minimize the length of the longest route among the participating vehicles’ routes. </span><span class="kobospan" id="kobo.736.4">For example, if we have three vehicles, each solution consists of three routes. </span><span class="kobospan" id="kobo.736.5">We will evaluate all three, and then only consider the longest one of them for scoring – the longer the route, the worse the score. </span><span class="kobospan" id="kobo.736.6">This will inherently encourage all three routes to be shorter, as well as closer in size to </span><span><span class="kobospan" id="kobo.737.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.738.1">Thanks to the similarity between the two problems, we can utilize the code we wrote previously to solve the TSP for solving </span><span><span class="kobospan" id="kobo.739.1">the VRP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.740.1">To build on the solution</span><a id="_idIndexMarker298" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.741.1"> we created for the TSP, we can represent vehicle routing </span><span><span class="kobospan" id="kobo.742.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.743.1">A TSP instance, namely a list of cities and their coordinates (or their </span><span><span class="kobospan" id="kobo.744.1">mutual distances)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.745.1">The depot location, which is selected out of the existing cities, and represented by the index of </span><span><span class="kobospan" id="kobo.746.1">that city</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.747.1">The number of </span><span><span class="kobospan" id="kobo.748.1">vehicles used</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.749.1">In the next two subsections, we will show you how to implement </span><span><span class="kobospan" id="kobo.750.1">this solution.</span></span></p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor171" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.751.1">Solution representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.752.1">As usual, the firs</span><a id="_idTextAnchor172" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.753.1">t</span><a id="_idIndexMarker299" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.754.1"> question we need to address is how to represent a solution to </span><span><span class="kobospan" id="kobo.755.1">this problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.756.1">To illustrate our suggested representation, we will look at the 10-city example problem shown in the following figure, where the locations of the cities are marked with numbers from 0 </span><span><span class="kobospan" id="kobo.757.1">to 9:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer071">
<span class="kobospan" id="kobo.758.1"><img alt="Figure 4.12: Example VRP with numbered city locations" src="image/B20851_04_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.759.1">Figure 4.12: Example VRP with numbered city locations</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.760.1">A creative way to represent a candidate VRP solution while maintaining similarity to the previously solved TSP is by using a list that contains the numbers from 0 to </span><em class="italic"><span class="kobospan" id="kobo.761.1">(n-1) + (m-1)</span></em><span class="kobospan" id="kobo.762.1">, where </span><em class="italic"><span class="kobospan" id="kobo.763.1">n</span></em><span class="kobospan" id="kobo.764.1"> is the number of cities and </span><em class="italic"><span class="kobospan" id="kobo.765.1">m</span></em><span class="kobospan" id="kobo.766.1"> is the number of vehicles. </span><span class="kobospan" id="kobo.766.2">For example, if the number of cities is 10 and the number of vehicles is 3 (</span><em class="italic"><span class="kobospan" id="kobo.767.1">n = 10, m = 3</span></em><span class="kobospan" id="kobo.768.1">), we would have a list containing all the integers from 0 to 11, as </span><span><span class="kobospan" id="kobo.769.1">shown here:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.770.1">[0, 6, 8, 9, 11, 3, 4, 5, 7, 10, </span><span><span class="kobospan" id="kobo.771.1">1, 2]</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.772.1">The first </span><em class="italic"><span class="kobospan" id="kobo.773.1">n</span></em><span class="kobospan" id="kobo.774.1"> integer </span><a id="_idIndexMarker300" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.775.1">values, which is 0...9 in our case, still represent the cities, just like before. </span><span class="kobospan" id="kobo.775.2">However, the last </span><em class="italic"><span class="kobospan" id="kobo.776.1">(m - 1)</span></em><span class="kobospan" id="kobo.777.1"> integer values, 10 and 11 in our case, are used as delimiters (or “separators”) that break the list into routes. </span><span class="kobospan" id="kobo.777.2">As an example, [0, 6, 8, 9 </span><strong class="bold"><span class="kobospan" id="kobo.778.1">11</span></strong><span class="kobospan" id="kobo.779.1">, 3, 4, 5, 7, </span><strong class="bold"><span class="kobospan" id="kobo.780.1">10</span></strong><span class="kobospan" id="kobo.781.1">, 1, 2] will be broken into the following </span><span><span class="kobospan" id="kobo.782.1">three routes:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.783.1">[0, 6, 8, 9], [3, 4, 5, 7], [</span><span><span class="kobospan" id="kobo.784.1">1, 2]</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.785.1">Next, the index of the depot location needs to be removed since it is not part of a particular route. </span><span class="kobospan" id="kobo.785.2">If, for example, the depot location is index </span><strong class="bold"><span class="kobospan" id="kobo.786.1">7</span></strong><span class="kobospan" id="kobo.787.1">,  the resulting routes will be </span><span><span class="kobospan" id="kobo.788.1">as follows:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.789.1">[0, 6, 8, 9], [3, 4, 5], [</span><span><span class="kobospan" id="kobo.790.1">1, 2]</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.791.1">When calculating the distance that each route covers, we need to recall that each route starts and ends at the depot location (7). </span><span class="kobospan" id="kobo.791.2">So, to calculate the distances, as well as plot the routes, we will be using the </span><span><span class="kobospan" id="kobo.792.1">following data:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.793.1">[</span><strong class="bold"><span class="kobospan" id="kobo.794.1">7</span></strong><span class="kobospan" id="kobo.795.1">, 0, 6, 8, 9, </span><strong class="bold"><span class="kobospan" id="kobo.796.1">7</span></strong><span class="kobospan" id="kobo.797.1">], [</span><strong class="bold"><span class="kobospan" id="kobo.798.1">7</span></strong><span class="kobospan" id="kobo.799.1">, 3, 4, 5, </span><strong class="bold"><span class="kobospan" id="kobo.800.1">7</span></strong><span class="kobospan" id="kobo.801.1">], [</span><strong class="bold"><span class="kobospan" id="kobo.802.1">7</span></strong><span class="kobospan" id="kobo.803.1">, 1, </span><span><span class="kobospan" id="kobo.804.1">2, </span></span><span><strong class="bold"><span class="kobospan" id="kobo.805.1">7</span></strong></span><span><span class="kobospan" id="kobo.806.1">]</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.807.1">This candidate</span><a id="_idIndexMarker301" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.808.1"> solution is illustrated in the </span><span><span class="kobospan" id="kobo.809.1">following figure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer072">
<span class="kobospan" id="kobo.810.1"><img alt="Figure 4.13: Visualization of the candidate solution [0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2]" src="image/B20851_04_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.811.1">Figure 4.13: Visualization of the candidate solution [0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2]</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.812.1">In the next subsection, we will look into a Python implementation of </span><span><span class="kobospan" id="kobo.813.1">this idea.</span></span></p>
<h2 id="_idParaDest-128" class="calibre7"><a id="_idTextAnchor173" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.814.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.815.1">To encapsulate the VRP </span><a id="_idIndexMarker302" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.816.1">problem, we created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.817.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.818.1">. </span><span class="kobospan" id="kobo.818.2">This class is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.819.1">vrp.py</span></strong><span class="kobospan" id="kobo.820.1"> file and can be found </span><span><span class="kobospan" id="kobo.821.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.822.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py</span></span></a><span><span class="kobospan" id="kobo.823.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.824.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.825.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.826.1"> class contains an instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.827.1">TravelingSalesmanProblem</span></strong><span class="kobospan" id="kobo.828.1"> class, which is used as the container for the city indices and their corresponding locations and distances. </span><span class="kobospan" id="kobo.828.2">When creating an instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.829.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.830.1"> class, the instance of the underlying </span><strong class="source-inline"><span class="kobospan" id="kobo.831.1">TravelingSalesmanProblem</span></strong><span class="kobospan" id="kobo.832.1"> is created internally </span><span><span class="kobospan" id="kobo.833.1">and initialized.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.834.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.835.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.836.1"> class is initialized using the name of the underlying </span><strong class="source-inline"><span class="kobospan" id="kobo.837.1">TravelingSalesmanProblem</span></strong><span class="kobospan" id="kobo.838.1">, as well as the depot location index and the number </span><span><span class="kobospan" id="kobo.839.1">of vehicles.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.840.1">In addition, The </span><strong class="source-inline"><span class="kobospan" id="kobo.841.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.842.1"> class provides the following </span><span><span class="kobospan" id="kobo.843.1">public methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.844.1">getRoutes(indices)</span></strong><span class="kobospan" id="kobo.845.1">: This breaks the list of given indices into separate routes by detecting the “</span><span><span class="kobospan" id="kobo.846.1">separator” indices</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.847.1">getRouteDistance(indices)</span></strong><span class="kobospan" id="kobo.848.1">: This calculates total the distance of the path that starts at the depot location and goes through the cities described by the </span><span><span class="kobospan" id="kobo.849.1">given indices</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.850.1">getMaxDistance(indices)</span></strong><span class="kobospan" id="kobo.851.1">: This calculates the max distance among the distances of the various paths described by the given indices, after breaking the indices to </span><span><span class="kobospan" id="kobo.852.1">separate routes</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.853.1">getTotalDistance(indices)</span></strong><span class="kobospan" id="kobo.854.1">: This calculates the combined distance of the various paths described by the </span><span><span class="kobospan" id="kobo.855.1">given indices</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.856.1">plotData(indices)</span></strong><span class="kobospan" id="kobo.857.1">: This breaks the list of indices into separate routes and plots each route in a </span><span><span class="kobospan" id="kobo.858.1">different color</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.859.1">When executed as a standalone program, the </span><strong class="source-inline"><span class="kobospan" id="kobo.860.1">main</span></strong><span class="kobospan" id="kobo.861.1"> method of the class exercises these methods by creating an instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.862.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.863.1"> with the underlying TSP set to “bayg29” – the same problem we used in the previous section. </span><span class="kobospan" id="kobo.863.2">The number of vehicles is set to 3, and the depot location index is set to 12 (which maps to a city with a central location). </span><span class="kobospan" id="kobo.863.3">The following </span><a id="_idIndexMarker303" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.864.1">figure shows the locations of the cities (red dots) and the depot (</span><span><span class="kobospan" id="kobo.865.1">green “x”):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer073">
<span class="kobospan" id="kobo.866.1"><img alt="Figure 4.14: A plot of the VRP based on the “bayg29” TSP. " src="image/B20851_04_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.867.1">Figure 4.14: A plot of the VRP based on the “bayg29” TSP. </span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.868.1">Red dots mark the cities while the green “X” marks the depot</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.869.1">The main method then generates a random solution, breaks it down into routes, and calculates the distances, as </span><span><span class="kobospan" id="kobo.870.1">shown here:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.871.1">
random solution = [27, 23, 7, 18, 30, 14, 19, 3, 16, 2, 26, 9, 24, 22, 15, 17, 28, 11, 21, 12, 8, 4, 5, 13, 25, 6, 0, 29, 10, 1, 20]
route breakdown = [[27, 23, 7, 18], [14, 19, 3, 16, 2, 26, 9, 24, 22, 15, 17, 28, 11, 21, 8, 4, 5, 13, 25, 6, 0], [10, 1, 20]]
total distance = 26653.845703125
max distance = 21517.686</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.872.1">Note how the original list of indices of the random solution is broken down into separate routes using the separator indices (29 and 30). </span><span class="kobospan" id="kobo.872.2">The plot for this random solution is </span><span><span class="kobospan" id="kobo.873.1">shown here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer074">
<span class="kobospan" id="kobo.874.1"><img alt="Figure 4.15: A plot of a random solution for the VRP with three vehicles" src="image/B20851_04_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.875.1">Figure 4.15: A plot of a random solution for the VRP with three vehicles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.876.1">As we would </span><a id="_idIndexMarker304" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.877.1">expect from a random solution, it is far from optimal. </span><span class="kobospan" id="kobo.877.2">This is evident from the inefficient order of cities along the long (green) route, as well as one route (green) being much longer than the other two (red </span><span><span class="kobospan" id="kobo.878.1">and purple).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.879.1">In the next subsection, we will attempt to produce good solutions using the genetic </span><span><span class="kobospan" id="kobo.880.1">algorithms </span></span><span><a id="_idIndexMarker305" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.881.1">method.</span></span></p>
<h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor174" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.882.1">Genetic algorithm solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.883.1">The genetic</span><a id="_idIndexMarker306" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.884.1"> algorithm solution we created for the VRP resides in the </span><strong class="source-inline"><span class="kobospan" id="kobo.885.1">04-solve-vrp.py</span></strong><span class="kobospan" id="kobo.886.1"> Python file located </span><span><span class="kobospan" id="kobo.887.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/04_solve_vrp.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.888.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/04_solve_vrp.py</span></span></a><span><span class="kobospan" id="kobo.889.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.890.1">Since we were able to build on top of the TSP and used a similar representation for the solution – an array of indices – we could use the same genetic approach we used in the previous section. </span><span class="kobospan" id="kobo.890.2">We could also take advantage of elitism by reusing the elitist version that we created for the genetic flow. </span><span class="kobospan" id="kobo.890.3">This makes our genetic algorithm solution very similar to the one we used for </span><span><span class="kobospan" id="kobo.891.1">the TSP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.892.1">The following steps detail the main parts of </span><span><span class="kobospan" id="kobo.893.1">our solution:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.894.1">The program starts by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.895.1">VehicleRoutingProblem</span></strong><span class="kobospan" id="kobo.896.1"> class, using the “bayg29” TSP for its underlying data, and setting the depot location to 12 and the number of vehicles </span><span><span class="kobospan" id="kobo.897.1">to 3:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.898.1">
TSP_NAME = "bayg29"
NUM_OF_VEHICLES = 3
DEPOT_LOCATION = 12
vrp = vrp.</span><strong class="bold1"><span class="kobospan1" id="kobo.899.1">VehicleRoutingProblem</span></strong><span class="kobospan1" id="kobo.900.1">(TSP_NAME, NUM_OF_VEHICLES, 
    DEPOT_LOCATION)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.901.1">The fitness function is set to minimize the distance of the longest route among the three routes produced by </span><span><span class="kobospan" id="kobo.902.1">each solution:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.903.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.904.1">vrpDistance</span></strong><span class="kobospan1" id="kobo.905.1">(individual):
    return vrp.getMaxDistance(individual),
toolbox.register("evaluate", </span><strong class="bold1"><span class="kobospan1" id="kobo.906.1">vrpDistance</span></strong><span class="kobospan1" id="kobo.907.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.908.1">For the genetic operators, we once again use tournament selection with a tournament size of 2, which is assisted by the elitist approach,  and crossover and mutation operators that are specialized for </span><span><span class="kobospan" id="kobo.909.1">ordered lists:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.910.1">
# Genetic operators:
toolbox.register("select", tools.selTournament, </span><strong class="bold1"><span class="kobospan1" id="kobo.911.1">tournsize=2</span></strong><span class="kobospan1" id="kobo.912.1">)
toolbox.register("mate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.913.1">cxUniformPartialyMatched</span></strong><span class="kobospan1" id="kobo.914.1">, \
    indpb=2.0/len(vrp))
toolbox.register("mutate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.915.1">mutShuffleIndexes</span></strong><span class="kobospan1" id="kobo.916.1">, \
    indpb=1.0/len(vrp))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.917.1">As the VRP is inherently more difficult than TSP, we chose a larger population size and </span><a id="_idIndexMarker307" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.918.1">number of generations </span><span><span class="kobospan" id="kobo.919.1">than before:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.920.1">
# Genetic Algorithm constants:
POPULATION_SIZE = 500
P_CROSSOVER = 0.9
P_MUTATION = 0.2
MAX_GENERATIONS = 1000
HALL_OF_FAME_SIZE = 30</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.921.1">And that’s it! </span><span class="kobospan" id="kobo.921.2">We’re ready to run the program. </span><span class="kobospan" id="kobo.921.3">The results that we obtain with these settings are shown here – three routes, with a maximum length </span><span><span class="kobospan" id="kobo.922.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.923.1">3857</span></strong></span><span><span class="kobospan" id="kobo.924.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.925.1">
-- Best Ever Individual =  Individual('i', [0, 20, 17, 16, 13, 21, 10, 14, 3, 29, 15, 23, 7, 26, 12, 22, 6, 24, 18, 9, 19, 30, 27, 11, 5, 4, 8, 25, 2, 28, 1])
-- Best Ever Fitness =  3857.36376953125
-- Route Breakdown =  [[0, 20, 17, 16, 13, 21, 10, 14, 3], [15, 23, 7, 26, 22, 6, 24, 18, 9, 19], [27, 11, 5, 4, 8, 25, 2, 28, 1]]
-- total distance =  11541.875
-- max distance =  3857.3638</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.926.1">Note, again, how the solution is broken down into three separate routes using the highest two indices (29, 30) as separators, and ignoring the depot location (12). </span><span class="kobospan" id="kobo.926.2">We ended up with three routes, two of them covering nine cities each, and the third covering </span><span><span class="kobospan" id="kobo.927.1">10 cities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.928.1">Plotting the solution</span><a id="_idIndexMarker308" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.929.1"> produces the following figure depicting the three </span><span><span class="kobospan" id="kobo.930.1">resulting routes:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer075">
<span class="kobospan" id="kobo.931.1"><img alt="Figure 4.16: A plot of the best solution found by the program for the VRP with three vehicles" src="image/B20851_04_16.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.932.1">Figure 4.16: A plot of the best solution found by the program for the VRP with three vehicles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.933.1">The following statistics plot shows that the algorithm did most of the optimization before reaching 300 generations. </span><span class="kobospan" id="kobo.933.2">After, there are several </span><span><span class="kobospan" id="kobo.934.1">small improvements:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer076">
<span class="kobospan" id="kobo.935.1"><img alt="Figure 4.17: Stats of the program solving the VRP with three vehicles" src="image/B20851_04_17.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.936.1">Figure 4.17: Stats of the program solving the VRP with three vehicles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.937.1">How about </span><a id="_idIndexMarker309" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.938.1">changing the number of vehicles? </span><span class="kobospan" id="kobo.938.2">Let’s run the algorithm again after increasing the number of vehicles to six, and making no </span><span><span class="kobospan" id="kobo.939.1">other changes:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.940.1">
NUM_OF_VEHICLES = 6</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.941.1">The results for this run are shown here – six routes, with a maximum length </span><span><span class="kobospan" id="kobo.942.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.943.1">2803</span></strong></span><span><span class="kobospan" id="kobo.944.1">:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.945.1">
-- Best Ever Individual =  Individual('i', [27, 11, 5, 8, 4, 33, 12, 24, 6, 22, 7, 23, 29, 28, 20, 0, 26, 15, 32, 3, 18, 13, 17, 1, 31, 19, 25, 2, 30, 9, 14, 16, 21, 10])
-- Best Ever Fitness =  2803.584716796875
-- Route Breakdown =  [[27, 11, 5, 8, 4], [24, 6, 22, 7, 23], [28, 20, 0, 26, 15], [3, 18, 13, 17, 1], [19, 25, 2], [9, 14, 16, 21, 10]]
-- total distance =  16317.9892578125
-- max distance =  2803.5847</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.946.1">Note that increasing the number of vehicles two-fold didn’t decrease the maximum distance in a similar manner (</span><strong class="source-inline"><span class="kobospan" id="kobo.947.1">2803</span></strong><span class="kobospan" id="kobo.948.1"> with six compared to </span><strong class="source-inline"><span class="kobospan" id="kobo.949.1">3857</span></strong><span class="kobospan" id="kobo.950.1"> with three). </span><span class="kobospan" id="kobo.950.2">This is likely because each separate route still needs to start and end at the depot location, which is added to the cities in </span><span><span class="kobospan" id="kobo.951.1">the route.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.952.1">Plotting the</span><a id="_idIndexMarker310" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.953.1"> solution produces the following figure, depicting the six </span><span><span class="kobospan" id="kobo.954.1">resulting routes:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer077">
<span class="kobospan" id="kobo.955.1"><img alt="Figure 4.18: A plot of the best solution found by the program for the VRP with six vehicles" src="image/B20851_04_18.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.956.1">Figure 4.18: A plot of the best solution found by the program for the VRP with six vehicles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.957.1">One interesting point demonstrated by this plot is that the orange route doesn’t seem to be optimized. </span><span class="kobospan" id="kobo.957.2">Since we told the genetic algorithm to minimize the longest route, any route that is shorter than the longest route may not be optimized further. </span><span class="kobospan" id="kobo.957.3">You are encouraged to modify our solution to further optimize </span><span><span class="kobospan" id="kobo.958.1">the routes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.959.1">As with the three-vehicle case, the following statistics plot shows that the algorithm did most of the </span><a id="_idIndexMarker311" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.960.1">optimization before reaching 200 generations, after which there are several </span><span><span class="kobospan" id="kobo.961.1">small improvements:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer078">
<span class="kobospan" id="kobo.962.1"><img alt="Figure 4.19: Stats of the program solving the VRP with six vehicles" src="image/B20851_04_19.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.963.1">Figure 4.19: Stats of the program solving the VRP with six vehicles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.964.1">The solution we’ve found seems reasonable. </span><span class="kobospan" id="kobo.964.2">Can we do better than that? </span><span class="kobospan" id="kobo.964.3">What about other numbers of vehicles? </span><span class="kobospan" id="kobo.964.4">Or other depot locations? </span><span class="kobospan" id="kobo.964.5">Different genetic operators or different </span><a id="_idIndexMarker312" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.965.1">parameter settings? </span><span class="kobospan" id="kobo.965.2">Perhaps even a different fitness criteria? </span><span class="kobospan" id="kobo.965.3">We encourage you to experiment with all these and learn from </span><span><span class="kobospan" id="kobo.966.1">these experiments.</span></span></p>
<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor175" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.967.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.968.1">In this chapter, you were introduced to search problems and combinatorial optimization. </span><span class="kobospan" id="kobo.968.2">We then closely examined three classic combinatorial problems – each with numerous real-life applications – the knapsack problem, the TSP, and the VRP. </span><span class="kobospan" id="kobo.968.3">For Each of these problems, we followed a similar process of finding an appropriate representation for a solution, creating a class that encapsulates the problem and evaluates a given solution, and then creating a genetic algorithm solution that utilizes that class. </span><span class="kobospan" id="kobo.968.4">We ended up with valid solutions for all three problems while experimenting with genotype-to-phenotype mapping and </span><span><span class="kobospan" id="kobo.969.1">elitism-backed exploration.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.970.1">In the next chapter, we will look into a family of closely related tasks, namely </span><em class="italic"><span class="kobospan" id="kobo.971.1">constraint satisfaction problems</span></em><span class="kobospan" id="kobo.972.1">, starting with the classic </span><span><em class="italic"><span class="kobospan" id="kobo.973.1">n-queens</span></em></span><span><span class="kobospan" id="kobo.974.1"> problem.</span></span></p>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor176" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.975.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.976.1">For more information, please refer to the </span><span><span class="kobospan" id="kobo.977.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.978.1">Solving the knapsack problem using dynamic programming, from the book </span><em class="italic"><span class="kobospan" id="kobo.979.1">Keras Reinforcement Learning Projects</span></em><span class="kobospan" id="kobo.980.1">, by Giuseppe Ciaburro, </span><span><span class="kobospan" id="kobo.981.1">September 2018</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.982.1">The VRP, from the book </span><em class="italic"><span class="kobospan" id="kobo.983.1">Keras Reinforcement Learning Projects</span></em><span class="kobospan" id="kobo.984.1">, by Giuseppe Ciaburro, </span><span><span class="kobospan" id="kobo.985.1">September 2018</span></span></li>
</ul>
</div>
</body></html>