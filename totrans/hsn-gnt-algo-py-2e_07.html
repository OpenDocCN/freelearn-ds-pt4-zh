<html><head></head><body>
<div id="_idContainer094" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-132"><a id="_idTextAnchor177" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-133" class="calibre5"><a id="_idTextAnchor178" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Constraint Satisfaction</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, you will learn how genetic algorithms can be utilized to solve constraint satisfaction problems. </span><span class="kobospan" id="kobo.3.2">We will start by describing the concept of constraint satisfaction and how it applies to search problems and combinatorial optimization. </span><span class="kobospan" id="kobo.3.3">Then, we will look at several hands-on examples of constraint satisfaction problems and their Python-based solutions using the DEAP framework. </span><span class="kobospan" id="kobo.3.4">The problems we will cover include the well-known </span><strong class="bold"><span class="kobospan" id="kobo.4.1">N-Queen</span></strong><span class="kobospan" id="kobo.5.1"> problem, followed by the </span><strong class="bold"><span class="kobospan" id="kobo.6.1">nurse scheduling</span></strong><span class="kobospan" id="kobo.7.1"> problem, and finally the </span><strong class="bold"><span class="kobospan" id="kobo.8.1">graph coloring</span></strong><span class="kobospan" id="kobo.9.1"> problem. </span><span class="kobospan" id="kobo.9.2">Along the way, we will learn the difference between </span><strong class="bold"><span class="kobospan" id="kobo.10.1">hard and soft constraints</span></strong><span class="kobospan" id="kobo.11.1">, as well as how they can be incorporated into the </span><span><span class="kobospan" id="kobo.12.1">solution process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.13.1">In this chapter, we will cover the </span><span><span class="kobospan" id="kobo.14.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Understanding the nature of constraint </span><span><span class="kobospan" id="kobo.16.1">satisfaction problems</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">Solving the N-Queens problem using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.18.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.19.1">Solving an example of the nurse scheduling problem using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.20.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.21.1">Solving the graph coloring problem using a genetic algorithm coded with the </span><span><span class="kobospan" id="kobo.22.1">DEAP framework</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.23.1">Understanding the concepts of hard and soft constraints, as well as how to apply them when solving </span><span><span class="kobospan" id="kobo.24.1">a problem</span></span></li>
</ul>
<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor179" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.25.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">In this chapter, we will be using Python 3 with the following </span><span><span class="kobospan" id="kobo.27.1">supporting libraries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.28.1">deap</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.29.1">numpy</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.30.1">matplotlib</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.31.1">seaborn</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.32.1">networkx</span></strong><span class="kobospan" id="kobo.33.1"> – introduced in </span><span><span class="kobospan" id="kobo.34.1">this chapter</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.35.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.36.1">If you’re using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.37.1">requirements.txt</span></strong><span class="kobospan" id="kobo.38.1"> file we’ve provided (see </span><a href="B20851_03.xhtml#_idTextAnchor091" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.39.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.40.1">), these libraries will already be in </span><span><span class="kobospan" id="kobo.41.1">your environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">The programs that will be used in this chapter can be found in this book’s GitHub repository </span><span><span class="kobospan" id="kobo.43.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_05" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.44.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_05</span></span></a><span><span class="kobospan" id="kobo.45.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Check out the following video to see the Code in </span><span><span class="kobospan" id="kobo.47.1">Action: </span></span><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.48.1">https://packt.link/OEBOd</span></span></a><span><span class="kobospan" id="kobo.49.1">.</span></span></p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor180" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.50.1">Constraint satisfaction in search problems</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.51.1">In the </span><a id="_idIndexMarker313" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.52.1">previous chapter, we looked at solving search problems, which focused on methodically evaluating states and transitions between states. </span><span class="kobospan" id="kobo.52.2">Every state transition typically involves a cost or gain, and the objective of the search was to minimize the cost or maximize the gain. </span><span class="kobospan" id="kobo.52.3">Constraint satisfaction problems are a </span><em class="italic"><span class="kobospan" id="kobo.53.1">variant</span></em><span class="kobospan" id="kobo.54.1"> of search problems, where the states must satisfy several constraints or limitations. </span><span class="kobospan" id="kobo.54.2">If we can translate the various violations of constraints into cost and then strive to minimize the cost, solving a constraint satisfaction problem can resemble solving a general </span><span><span class="kobospan" id="kobo.55.1">search problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.56.1">Like combinatorial optimization problems, constraint satisfaction problems have important applications in fields such as artificial intelligence, operations research, and pattern matching. </span><span class="kobospan" id="kobo.56.2">A better understanding of these problems may help in solving numerous types of problems that may seem unrelated at first glance. </span><span class="kobospan" id="kobo.56.3">Constraint satisfaction problems often exhibit high complexity, which makes genetic algorithms a suitable candidate for </span><span><span class="kobospan" id="kobo.57.1">solving them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">The </span><strong class="bold"><span class="kobospan" id="kobo.59.1">N-Queens</span></strong><span class="kobospan" id="kobo.60.1"> problem, which</span><a id="_idIndexMarker314" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.61.1"> will be presented in the next section, illustrates the concept of constraint satisfaction problems and demonstrates how they can be solved in a very similar manner to the problems we looked at in the </span><span><span class="kobospan" id="kobo.62.1">previous </span></span><span><a id="_idIndexMarker315" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.63.1">chapter.</span></span></p>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor181" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.64.1">Solving the N-Queens problem</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">Originally known </span><a id="_idIndexMarker316" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.66.1">as the </span><em class="italic"><span class="kobospan" id="kobo.67.1">eight-queen puzzle</span></em><span class="kobospan" id="kobo.68.1">, the classic N-Queens problem originated from the game of chess, and the </span><em class="italic"><span class="kobospan" id="kobo.69.1">8x8</span></em><span class="kobospan" id="kobo.70.1"> chessboard was its early playground. </span><span class="kobospan" id="kobo.70.2">The task was to place eight chess queens on the board without any two of them threatening each other. </span><span class="kobospan" id="kobo.70.3">In other words, no two queens can share the same row, same column, or same diagonal. </span><span class="kobospan" id="kobo.70.4">The N-Queens problem is similar, using an </span><em class="italic"><span class="kobospan" id="kobo.71.1">N×N</span></em><span class="kobospan" id="kobo.72.1"> chessboard and </span><em class="italic"><span class="kobospan" id="kobo.73.1">N</span></em> <span><span class="kobospan" id="kobo.74.1">chess queens.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.75.1">The problem is known to have a solution for any natural number, </span><em class="italic"><span class="kobospan" id="kobo.76.1">n</span></em><span class="kobospan" id="kobo.77.1">, except for the cases of </span><em class="italic"><span class="kobospan" id="kobo.78.1">n=2</span></em><span class="kobospan" id="kobo.79.1"> and </span><em class="italic"><span class="kobospan" id="kobo.80.1">n=3</span></em><span class="kobospan" id="kobo.81.1">. </span><span class="kobospan" id="kobo.81.2">For the original eight-queen case, there are 92 solutions, or 12 unique solutions if we consider symmetrical solutions to be identical. </span><span class="kobospan" id="kobo.81.3">One of the solutions is </span><span><span class="kobospan" id="kobo.82.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer080">
<span class="kobospan" id="kobo.83.1"><img alt="Figure 5.1: One of the 92 possible solutions for the eight-queen puzzle" src="image/B20851_05_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.84.1">Figure 5.1: One of the 92 possible solutions for the eight-queen puzzle</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">By applying combinatorics, the count of all possible ways to place eight pieces on the </span><em class="italic"><span class="kobospan" id="kobo.86.1">8×8</span></em><span class="kobospan" id="kobo.87.1"> board yields 4,426,165,368 combinations. </span><span class="kobospan" id="kobo.87.2">However, if we can create our candidate solutions in a way that ensures that no two queens will be placed on the same row or the same column, the number of possible combinations is dramatically reduced to </span><em class="italic"><span class="kobospan" id="kobo.88.1">8!</span></em><span class="kobospan" id="kobo.89.1"> (factorial of 8), which amounts to 40,320. </span><span class="kobospan" id="kobo.89.2">We are going to take advantage of this idea in the next subsection</span><a id="_idIndexMarker317" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.90.1"> when we choose the way our solution to this problem will </span><span><span class="kobospan" id="kobo.91.1">be represented.</span></span></p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor182" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.92.1">Solution representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.93.1">When solving</span><a id="_idIndexMarker318" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.94.1"> the N-Queens problem, we can take advantage of the knowledge that each row will host exactly one queen, and no two queens will share the same column. </span><span class="kobospan" id="kobo.94.2">This means we can represent any candidate solution as an ordered list of integers – or a list of indices, with each index representing the column that one of the queens occupies for the </span><span><span class="kobospan" id="kobo.95.1">current row.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.96.1">For example, in a four-queen problem over a 4×4 chessboard, we have the following list </span><span><span class="kobospan" id="kobo.97.1">of indices:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.98.1">
[3, 2, 0, 1]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.99.1">This translates to the </span><span><span class="kobospan" id="kobo.100.1">following positions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.101.1">In the first row, the queen is placed in position 3 (</span><span><span class="kobospan" id="kobo.102.1">fourth column)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.103.1">In the second row, the queen is placed in position 2 (</span><span><span class="kobospan" id="kobo.104.1">third column).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.105.1">In the third row, the queen is placed in position 0 (</span><span><span class="kobospan" id="kobo.106.1">first column)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.107.1">In the fourth row, the queen is placed in position 1 (</span><span><span class="kobospan" id="kobo.108.1">second column)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">This is depicted in the </span><span><span class="kobospan" id="kobo.110.1">following figure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer081">
<span class="kobospan" id="kobo.111.1"><img alt="Figure 5.2: Illustration of the queen arrangement represented by the list [3, 2, 0, 1]" src="image/B20851_05_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.112.1">Figure 5.2: Illustration of the queen arrangement represented by the list [3, 2, 0, 1]</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">Similarly, another</span><a id="_idIndexMarker319" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.114.1"> arrangement of the indices may look </span><span><span class="kobospan" id="kobo.115.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.116.1">
[1, 3, 0, 2]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.117.1">This arrangement represents the candidate solution shown in the </span><span><span class="kobospan" id="kobo.118.1">following figure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer082">
<span class="kobospan" id="kobo.119.1"><img alt="Figure 5.3: Illustration of the queen arrangement represented by the list [1, 3, 0, 2]" src="image/B20851_05_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.120.1">Figure 5.3: Illustration of the queen arrangement represented by the list [1, 3, 0, 2]</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.121.1">The only constraint</span><a id="_idIndexMarker320" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.122.1"> violations that are possible in candidate solutions represented this way are shared diagonals between pairs </span><span><span class="kobospan" id="kobo.123.1">of queens.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.124.1">For example, the first candidate solution we discussed contains two violations, as </span><span><span class="kobospan" id="kobo.125.1">shown here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer083">
<span class="kobospan" id="kobo.126.1"><img alt="Figure 5.4: Illustration of the queen arrangement represented by the list [3, 2, 0, 1], with constraint violations indicated" src="image/B20851_05_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.127.1">Figure 5.4: Illustration of the queen arrangement represented by the list [3, 2, 0, 1], with constraint violations indicated</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.128.1">However, the preceding one exhibited </span><span><span class="kobospan" id="kobo.129.1">no violations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.130.1">This means that, when evaluating the solutions that are represented in this way, we only need to find and count the shared diagonals between the positions they </span><span><span class="kobospan" id="kobo.131.1">stand for.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.132.1">The solution</span><a id="_idIndexMarker321" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.133.1"> representation we just discussed is a central part of the Python class that we will describe in the </span><span><span class="kobospan" id="kobo.134.1">next subsection.</span></span></p>
<h2 id="_idParaDest-138" class="calibre7"><a id="_idTextAnchor183" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.135.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.136.1">To encapsulate</span><a id="_idIndexMarker322" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.137.1"> the N-Queens problem, we’ve created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.138.1">NQueensProblem</span></strong><span class="kobospan" id="kobo.139.1">. </span><span class="kobospan" id="kobo.139.2">This class can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.140.1">queens.py</span></strong><span class="kobospan" id="kobo.141.1"> file of this book’s GitHub repository:  </span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.142.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py</span></span></a><span><span class="kobospan" id="kobo.143.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.144.1">The class is initialized with the desired size of the problem and provides the following </span><span><span class="kobospan" id="kobo.145.1">public methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.146.1">getViolationsCount(positions)</span></strong><span class="kobospan" id="kobo.147.1">: This calculates the number of violations in the given solution, which is represented by a list of indices, as discussed in the </span><span><span class="kobospan" id="kobo.148.1">previous subsection</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.149.1">plotBoard(positions)</span></strong><span class="kobospan" id="kobo.150.1">: This plots the positions of the queens on the board according to the </span><span><span class="kobospan" id="kobo.151.1">given solution</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.152.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">main</span></strong><span class="kobospan" id="kobo.154.1"> method of the class exercises the class methods by creating an eight-queen problem and testing the following candidate solution </span><span><span class="kobospan" id="kobo.155.1">for it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.156.1">
[1, 2, 7, 5, 0, 3, 4, 6]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.157.1">This is followed by plotting the candidate solution and calculating the number of </span><span><span class="kobospan" id="kobo.158.1">constraint violations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.159.1">The resulting output is </span><span><span class="kobospan" id="kobo.160.1">shown here:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.161.1">
Number of violations =  3</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.162.1">The plot for </span><a id="_idIndexMarker323" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.163.1">this is as follows – can you spot all </span><span><span class="kobospan" id="kobo.164.1">three violations?</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer084">
<span class="kobospan" id="kobo.165.1"><img alt="Figure 5.5: Illustration of the eight-queen arrangement represented by the list [1, 2, 7, 5, 0, 3, 4, 6]" src="image/B20851_05_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.166.1">Figure 5.5: Illustration of the eight-queen arrangement represented by the list [1, 2, 7, 5, 0, 3, 4, 6]</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.167.1">In the next </span><a id="_idIndexMarker324" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.168.1">subsection, we will apply the genetic algorithm approach to solving the N- </span><span><span class="kobospan" id="kobo.169.1">Queens problem.</span></span></p>
<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor184" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.170.1">Genetic algorithms solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.171.1">To solve </span><a id="_idIndexMarker325" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.172.1">the N-Queens problem using a genetic algorithm, we’ve created a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">01-solve-n-queens.py</span></strong><span class="kobospan" id="kobo.174.1">, which is located </span><span><span class="kobospan" id="kobo.175.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.176.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py</span></span></a><span><span class="kobospan" id="kobo.177.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.178.1">Since the solution representation we chose for this problem is a list (or an array) of indices, which is similar to the representation we used for the </span><strong class="bold"><span class="kobospan" id="kobo.179.1">traveling salesman problem</span></strong><span class="kobospan" id="kobo.180.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.181.1">TSP</span></strong><span class="kobospan" id="kobo.182.1">) and </span><a id="_idIndexMarker326" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.183.1">the </span><strong class="bold"><span class="kobospan" id="kobo.184.1">vehicle routing problem</span></strong><span class="kobospan" id="kobo.185.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.186.1">VRP</span></strong><span class="kobospan" id="kobo.187.1">) in </span><a href="B20851_04.xhtml#_idTextAnchor155" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.188.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.189.1">, </span><em class="italic"><span class="kobospan" id="kobo.190.1">Combinatorial Optimization</span></em><span class="kobospan" id="kobo.191.1">, we can utilize a similar genetic</span><a id="_idIndexMarker327" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.192.1"> approach to the one we used there. </span><span class="kobospan" id="kobo.192.2">In addition, we’ll take advantage </span><a id="_idIndexMarker328" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.193.1">of </span><strong class="bold"><span class="kobospan" id="kobo.194.1">elitism</span></strong><span class="kobospan" id="kobo.195.1"> once more by reusing the elitist version that we created for DEAP’s simple </span><span><span class="kobospan" id="kobo.196.1">genetic flow.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.197.1">The following steps describe the main parts of </span><span><span class="kobospan" id="kobo.198.1">our solution:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.199.1">Our program starts by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.200.1">NQueensProblem</span></strong><span class="kobospan" id="kobo.201.1"> class using the size of the problem we would like </span><span><span class="kobospan" id="kobo.202.1">to solve:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.203.1">
nQueens = queens.NQueensProblem(NUM_OF_QUEENS)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.204.1">Since our goal is to minimize the count of violations (hopefully to a value of 0), we define a single objective, minimizing the </span><span><span class="kobospan" id="kobo.205.1">fitness strategy:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.206.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.207.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.208.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.209.1">Since the solution is represented by an ordered list of integers, where each integer denotes the column location of a queen, we can use the following toolbox definitions to create the </span><span><span class="kobospan" id="kobo.210.1">initial population:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.211.1">
# create an operator that generates randomly shuffled indices:
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.212.1">randomOrder</span></strong><span class="kobospan1" id="kobo.213.1">", random.sample, \
    range(len(nQueens)), len(nQueens))
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.214.1">individualCreator</span></strong><span class="kobospan1" id="kobo.215.1">", tools.initIterate, \
    creator.Individual, toolbox.randomOrder)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.216.1">populationCreator</span></strong><span class="kobospan1" id="kobo.217.1">", tools.initRepeat, \
    list, toolbox.individualCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.218.1">The actual fitness function is set to count the number of violations caused by the placement of the queens on the chessboard, as represented by </span><span><span class="kobospan" id="kobo.219.1">each solution:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.220.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.221.1">getViolationsCount</span></strong><span class="kobospan1" id="kobo.222.1">(individual):
    return nQueens.getViolationsCount(individual),
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.223.1">evaluate</span></strong><span class="kobospan1" id="kobo.224.1">", getViolationsCount)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.225.1">As for the</span><a id="_idIndexMarker329" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.226.1"> genetic operators, we use </span><em class="italic"><span class="kobospan" id="kobo.227.1">tournament selection</span></em><span class="kobospan" id="kobo.228.1"> with a tournament size of </span><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">2</span></strong><span class="kobospan" id="kobo.230.1">, as well as the </span><em class="italic"><span class="kobospan" id="kobo.231.1">crossover</span></em><span class="kobospan" id="kobo.232.1"> and </span><em class="italic"><span class="kobospan" id="kobo.233.1">mutation</span></em><span class="kobospan" id="kobo.234.1"> operators, which are specialized for </span><span><span class="kobospan" id="kobo.235.1">ordered lists:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.236.1">
# Genetic operators:
toolbox.register("select", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.237.1">selTournament</span></strong><span class="kobospan1" id="kobo.238.1">, \
    </span><strong class="bold1"><span class="kobospan1" id="kobo.239.1">tournsize=2</span></strong><span class="kobospan1" id="kobo.240.1">)
toolbox.register("mate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.241.1">cxUniformPartialyMatched</span></strong><span class="kobospan1" id="kobo.242.1">, \
    indpb=2.0/len(nQueens))
toolbox.register("mutate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.243.1">mutShuffleIndexes</span></strong><span class="kobospan1" id="kobo.244.1">, \
    indpb=1.0/len(nQueens))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.245.1">In addition, we continue </span><a id="_idIndexMarker330" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.246.1">to use the </span><strong class="bold"><span class="kobospan" id="kobo.247.1">elitist</span></strong><span class="kobospan" id="kobo.248.1"> approach, where</span><a id="_idIndexMarker331" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.249.1"> the </span><strong class="bold"><span class="kobospan" id="kobo.250.1">hall-of-fame</span></strong><span class="kobospan" id="kobo.251.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.252.1">HOF</span></strong><span class="kobospan" id="kobo.253.1">) members – the current best individuals – are always passed untouched to the next generation. </span><span class="kobospan" id="kobo.253.2">As we found out in the previous chapter, this approach works well with a tournament selection of </span><span><span class="kobospan" id="kobo.254.1">size 2:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.255.1">
population, logbook = elitism.</span><strong class="bold1"><span class="kobospan1" id="kobo.256.1">eaSimpleWithElitism</span></strong><span class="kobospan1" id="kobo.257.1">(population,
    toolbox,
    cxpb=P_CROSSOVER,
    mutpb=P_MUTATION,
    ngen=MAX_GENERATIONS,
    stats=stats,
    halloffame=hof,
    verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.258.1">Since each N-Queens problem can have multiple possible solutions, we print out all HOF members, instead of just the top one, so that we can see how many valid </span><a id="_idIndexMarker332" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.259.1">solutions </span><span><span class="kobospan" id="kobo.260.1">we found:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.261.1">
print("- Best solutions are:")
for i in range(HALL_OF_FAME_SIZE):
    print(i, ": ", </span><strong class="bold1"><span class="kobospan1" id="kobo.262.1">hof.items</span></strong><span class="kobospan1" id="kobo.263.1">[i].fitness.values[0], " -&gt; ", 
        hof.items[i])</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.264.1">As we saw earlier, our solution representation reduces the eight-queen case to only about 40,000 possible combinations, which makes it a rather small problem. </span><span class="kobospan" id="kobo.264.2">To make things more interesting, let’s increase the size to 16 queens, where the number of possible candidate solutions will be </span><em class="italic"><span class="kobospan" id="kobo.265.1">16!</span></em><span class="kobospan" id="kobo.266.1">. </span><span class="kobospan" id="kobo.266.2">This calculates to the colossal value of 20,922,789,888,000. </span><span class="kobospan" id="kobo.266.3">The number of valid solutions to this problem is quite large too, at just under 15 million. </span><span class="kobospan" id="kobo.266.4">However, compared to the number of possible combinations, searching for a valid solution is still like trying to find a needle in </span><span><span class="kobospan" id="kobo.267.1">a haystack.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.268.1">Before we run the program, let’s set the algorithm constants, </span><span><span class="kobospan" id="kobo.269.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.270.1">
NUM_OF_QUEENS = 16
POPULATION_SIZE = 300
MAX_GENERATIONS = 100
HALL_OF_FAME_SIZE = 30
P_CROSSOVER = 0.9
P_MUTATION = 0.1</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.271.1">Running the program with these settings yields the </span><span><span class="kobospan" id="kobo.272.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.273.1">
gen nevals min avg
0 300 3 10.4533
1 246 3 8.85333
..
</span><span class="kobospan1" id="kobo.273.2">23 250 1 4.38
24 227 0 4.32
..
</span><span class="kobospan1" id="kobo.273.3">- Best solutions are:
0 : 0.0 -&gt; Individual('i', [7, 2, 8, 14, 9, 4, 0, 15, 6, 11, 13, 1, 3, 5, 10, 12])
1 : 0.0 -&gt; Individual('i', [7, 2, 6, 14, 9, 4, 0, 15, 8, 11, 13, 1, 3, 5, 12, 10])
..
</span><span class="kobospan1" id="kobo.273.4">7 : 0.0 -&gt; Individual('i', [14, 2, 6, 12, 7, 4, 0, 15, 8, 11, 3, 1, 9, 5, 10, 13])
8 : 1.0 -&gt; Individual('i', [2, 13, 6, 12, 7, 4, 0, 15, 8, 14, 3, 1, 9, 5, 10, 11])
..</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.274.1">From the </span><a id="_idIndexMarker333" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.275.1">printouts, we can see that a solution was first found in generation 24, where the fitness value shows as </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">0</span></strong><span class="kobospan" id="kobo.277.1">, which means no violations. </span><span class="kobospan" id="kobo.277.2">In addition, the printout of the best solutions indicates that eight different solutions were found during the run. </span><span class="kobospan" id="kobo.277.3">These solutions are the entries of </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">0</span></strong><span class="kobospan" id="kobo.279.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">7</span></strong><span class="kobospan" id="kobo.281.1"> in the HOF, all of which have a fitness value of </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">0</span></strong><span class="kobospan" id="kobo.283.1">. </span><span class="kobospan" id="kobo.283.2">The next entry already has a fitness value of </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">1</span></strong><span class="kobospan" id="kobo.285.1">, denoting </span><span><span class="kobospan" id="kobo.286.1">a violation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.287.1">The first plot that’s produced by the program depicts the placement of the 16 queens on the </span><em class="italic"><span class="kobospan" id="kobo.288.1">16x16</span></em><span class="kobospan" id="kobo.289.1"> chessboard, as defined by the first valid solution that was found – </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">[7, 2, 8, 14, 9, 4, 0, 15, 6, 11, 13, 1, 3, 5, </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">10, 12]</span></strong></span><span><span class="kobospan" id="kobo.292.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer085">
<span class="kobospan" id="kobo.293.1"><img alt="Figure 5.6: A plot of a valid 16-queen arrangement found by the program" src="image/B20851_05_06.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.294.1">Figure 5.6: A plot of a valid 16-queen arrangement found by the program</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.295.1">The second </span><a id="_idIndexMarker334" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.296.1">plot contains a graph of the max and average fitness values over the generations. </span><span class="kobospan" id="kobo.296.2">From this graph, we can see that even though the best fitness value of zero was found early on – around generation 24 – the average fitness value kept decreasing as more solutions </span><span><span class="kobospan" id="kobo.297.1">were found:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer086">
<span class="kobospan" id="kobo.298.1"><img alt="Figure 5.7: Stats of the program solving the 16-queen problem" src="image/B20851_05_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.299.1">Figure 5.7: Stats of the program solving the 16-queen problem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.300.1">Increasing the value of </span><strong class="source-inline"><span class="kobospan" id="kobo.301.1">MAX_GENERATIONS</span></strong><span class="kobospan" id="kobo.302.1"> to 400 without making any other changes will result in us finding 38 valid solutions. </span><span class="kobospan" id="kobo.302.2">If we increase </span><strong class="source-inline"><span class="kobospan" id="kobo.303.1">MAX_GENERATIONS</span></strong><span class="kobospan" id="kobo.304.1"> to 500, all 50 members of the HOF will contain valid solutions. </span><span class="kobospan" id="kobo.304.2">You are encouraged to try out various combinations of the genetic algorithm’s settings, as well as solve other sizes of the </span><span><span class="kobospan" id="kobo.305.1">N-Queen </span></span><span><a id="_idIndexMarker335" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.306.1">problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.307.1">In the next section, we will be transitioning from arranging game pieces on a board to placing workers on a </span><span><span class="kobospan" id="kobo.308.1">work schedule.</span></span></p>
<h1 id="_idParaDest-140" class="calibre5"><a id="_idTextAnchor185" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.309.1">Solving the nurse scheduling problem</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.310.1">Imagine that you are</span><a id="_idIndexMarker336" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.311.1"> responsible for scheduling the shifts for the nurses in your hospital department for this week. </span><span class="kobospan" id="kobo.311.2">There are three shifts in a day – morning, afternoon, and night – and for each shift, you need to assign one or more of the eight nurses who work in your department. </span><span class="kobospan" id="kobo.311.3">If this sounds like a simple task, take a look at the list of relevant </span><span><span class="kobospan" id="kobo.312.1">hospital rules:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.313.1">A nurse is not allowed to work two </span><span><span class="kobospan" id="kobo.314.1">consecutive shifts</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.315.1">A nurse is not allowed to work more than five shifts </span><span><span class="kobospan" id="kobo.316.1">per week</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.317.1">The number of nurses per shift in your department should fall within the </span><span><span class="kobospan" id="kobo.318.1">following limits:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.319.1">Morning shift: </span><span><span class="kobospan" id="kobo.320.1">2-3 nurses</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.321.1">Afternoon shift: </span><span><span class="kobospan" id="kobo.322.1">2-4 nurses</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.323.1">Night shift: </span><span><span class="kobospan" id="kobo.324.1">1-2 nurses</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">In addition, each nurse can have shift preferences. </span><span class="kobospan" id="kobo.325.2">For example, one nurse prefers to only work morning shifts, another nurse prefers to not work afternoon shifts, and </span><span><span class="kobospan" id="kobo.326.1">so on.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.327.1">This task is an example of the </span><strong class="bold"><span class="kobospan" id="kobo.328.1">nurse scheduling problem</span></strong><span class="kobospan" id="kobo.329.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.330.1">NSP</span></strong><span class="kobospan" id="kobo.331.1">), which can have many variants. </span><span class="kobospan" id="kobo.331.2">Possible variations may include different specialties for different nurses, the ability to work on cover shifts (overtime), or even different types of shifts – such as 8-hour shifts and </span><span><span class="kobospan" id="kobo.332.1">12-hour shifts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.333.1">By now, it probably seems like a good idea to write a program that will do the scheduling for you. </span><span class="kobospan" id="kobo.333.2">Why</span><a id="_idIndexMarker337" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.334.1"> not apply our knowledge of genetic algorithms to implement such a program? </span><span class="kobospan" id="kobo.334.2">As usual, we will start by representing the solution to </span><span><span class="kobospan" id="kobo.335.1">the problem.</span></span></p>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor186" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.336.1">Solution representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.337.1">To solve the nurse </span><a id="_idIndexMarker338" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.338.1">scheduling problem, we decided to use a binary list (or array) to represent the schedule as it will be intuitive for us to interpret, and we’ve seen that genetic algorithms can handle this </span><span><span class="kobospan" id="kobo.339.1">representation naturally.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.340.1">For each nurse, we can </span><a id="_idIndexMarker339" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.341.1">have a </span><strong class="bold"><span class="kobospan" id="kobo.342.1">binary string</span></strong><span class="kobospan" id="kobo.343.1"> representing the 21 shifts of the week. </span><span class="kobospan" id="kobo.343.2">A value of 1 represents a shift that the nurse is scheduled to work on. </span><span class="kobospan" id="kobo.343.3">For example, take a look at the following </span><span><span class="kobospan" id="kobo.344.1">binary list:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.345.1">
[0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.346.1">This list can be broken into the following groups of three values, representing the shifts this nurse will be working each day of </span><span><span class="kobospan" id="kobo.347.1">the week:</span></span></p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.348.1">Sunday</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.349.1">Monday</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.350.1">Tuesday</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.351.1">Wednesday</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.352.1">Thursday</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.353.1">Friday</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.354.1">Saturday</span></strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.355.1">[0, 1, 0]</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.356.1">[1, 0, 1]</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.357.1">[0, 1, 1]</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.358.1">[0, 0, 0]</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.359.1">[0, 0, 1]</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.360.1">[1, 0, 0]</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.361.1">[0, 1, 0]</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.362.1">Afternoon</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.363.1">Morning and night</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.364.1">Afternoon and night</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.365.1">None</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.366.1">Night</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.367.1">Morning</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.368.1">Afternoon</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.369.1">Table 5.1: Converting the binary sequence into daily shifts</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.370.1">The schedules of all nurses can be then concatenated together to create one long binary list representing the </span><span><span class="kobospan" id="kobo.371.1">entire solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.372.1">When evaluating a solution, this long list can be broken down into the schedules of the individual nurses, and violations of the constraints can be checked for. </span><span class="kobospan" id="kobo.372.2">The preceding sample nurse schedule, for instance, contains two occurrences of consecutive 1 values that represent consecutive shifts being worked (afternoon followed by night, and night followed by morning). </span><span class="kobospan" id="kobo.372.3">The number of weekly shifts for that same nurse can be calculated by totaling the binary values of the list, which results in 8 shifts. </span><span class="kobospan" id="kobo.372.4">We can also easily check for adherence to the shift preferences by checking each day’s shifts against the given preferred shifts of </span><span><span class="kobospan" id="kobo.373.1">that nurse.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.374.1">Finally, to check for the constraints of the number of nurses per shift, we can sum the weekly schedules of all nurses and look for entries that are larger than the maximum allowed or smaller</span><a id="_idIndexMarker340" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.375.1"> than the </span><span><span class="kobospan" id="kobo.376.1">minimum allowed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.377.1">But before we continue with our implementation, we need to discuss the difference between </span><strong class="bold"><span class="kobospan" id="kobo.378.1">hard constraints</span></strong><span class="kobospan" id="kobo.379.1"> and </span><span><strong class="bold"><span class="kobospan" id="kobo.380.1">soft constraints</span></strong></span><span><span class="kobospan" id="kobo.381.1">.</span></span></p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor187" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.382.1">Hard constraints versus soft constraints</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.383.1">When solving </span><a id="_idIndexMarker341" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.384.1">the nurse </span><a id="_idIndexMarker342" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.385.1">scheduling problem, we </span><a id="_idIndexMarker343" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.386.1">should bear in mind that some of the constraints represent hospital rules that cannot be broken. </span><span class="kobospan" id="kobo.386.2">A schedule that contains one or more violations of these rules will be considered invalid. </span><span class="kobospan" id="kobo.386.3">More generally, these are known as </span><span><strong class="bold"><span class="kobospan" id="kobo.387.1">hard constraints</span></strong></span><span><span class="kobospan" id="kobo.388.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.389.1">The nurses’ preferences, on the other hand, can be considered </span><strong class="bold"><span class="kobospan" id="kobo.390.1">soft constraints</span></strong><span class="kobospan" id="kobo.391.1">. </span><span class="kobospan" id="kobo.391.2">We would like to adhere to them as much as possible, and a solution that contains no violations or fewer violations of these constraints is considered better than one that contains more violations. </span><span class="kobospan" id="kobo.391.3">However, a violation of these constraints does not invalidate </span><span><span class="kobospan" id="kobo.392.1">the solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.393.1">In the case of the N-Queens problem, all the constraints – row, column, and diagonal – were hard constraints. </span><span class="kobospan" id="kobo.393.2">Had we not found a solution where the number of violations was zero, we would not have a valid solution for the problem. </span><span class="kobospan" id="kobo.393.3">Here, on the other hand, we are looking for a solution that will not violate any of the hospital rules while minimizing the number of breaches to the </span><span><span class="kobospan" id="kobo.394.1">nurses’ preferences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.395.1">While dealing with soft constraints is similar to what we do in any optimization problem – that is, we strive</span><a id="_idIndexMarker344" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.396.1"> to </span><a id="_idIndexMarker345" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.397.1">minimize</span><a id="_idIndexMarker346" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.398.1"> them – how do we deal with the hard constraints that accompany them? </span><span class="kobospan" id="kobo.398.2">There are several </span><span><span class="kobospan" id="kobo.399.1">possible strategies:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.400.1">Find a particular representation (coding) of the solution that </span><strong class="bold"><span class="kobospan" id="kobo.401.1">eliminates the possibility</span></strong><span class="kobospan" id="kobo.402.1"> of a hard constraint violation. </span><span class="kobospan" id="kobo.402.2">When solving the N-Queens problem, we were able to represent a solution in a way that eliminated the possibility for two of the three constraints – row and column – which considerably simplified our solution. </span><span class="kobospan" id="kobo.402.3">But generally, such coding may be difficult </span><span><span class="kobospan" id="kobo.403.1">to find.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.404.1">When evaluating the solutions, </span><strong class="bold"><span class="kobospan" id="kobo.405.1">discard</span></strong><span class="kobospan" id="kobo.406.1"> candidate solutions that violate any hard constraint. </span><span class="kobospan" id="kobo.406.2">The disadvantage of this approach is the loss of information contained in these solutions, which may be valuable for the problem. </span><span class="kobospan" id="kobo.406.3">This could considerably slow down the </span><span><span class="kobospan" id="kobo.407.1">optimization process.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.408.1">When evaluating the solutions, </span><strong class="bold"><span class="kobospan" id="kobo.409.1">repair</span></strong><span class="kobospan" id="kobo.410.1"> candidate solutions that violate any hard constraint. </span><span class="kobospan" id="kobo.410.2">In other words, find a way to manipulate the solution and modify it so that it will no longer violate the constraint(s). </span><span class="kobospan" id="kobo.410.3">Creating such a repair procedure can prove difficult or impossible for most problems, and at the same time, the repair process may result in a significant loss </span><span><span class="kobospan" id="kobo.411.1">of information.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.412.1">When evaluating the solutions, </span><strong class="bold"><span class="kobospan" id="kobo.413.1">penalize</span></strong><span class="kobospan" id="kobo.414.1"> candidate solutions that violate any hard constraint. </span><span class="kobospan" id="kobo.414.2">This will degrade the solution’s score and make it less desirable, but will not eliminate it completely, so the information contained in it is not lost. </span><span class="kobospan" id="kobo.414.3">Effectively, this leads to a hard constraint to be considered similar to a soft constraint, but with a heavier penalty. </span><span class="kobospan" id="kobo.414.4">When using this method, the challenge may be to find the appropriate extent of the penalty. </span><span class="kobospan" id="kobo.414.5">Too harsh a penalty may lead to a de facto elimination of such solutions, while a penalty that’s too small may lead to these solutions appearing </span><span><span class="kobospan" id="kobo.415.1">as optimal.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.416.1">In our case, we chose to apply the fourth approach and penalize the violations of the hard constraints to a larger degree than those of the soft constraints. </span><span class="kobospan" id="kobo.416.2">We did this by creating a cost function, where the cost of a hard constraint violation is greater than that of a soft constraint violation. </span><span class="kobospan" id="kobo.416.3">The total cost is then used as the fitness function to be minimized. </span><span class="kobospan" id="kobo.416.4">This</span><a id="_idIndexMarker347" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.417.1"> is </span><a id="_idIndexMarker348" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.418.1">implemented</span><a id="_idIndexMarker349" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.419.1"> within the problem representation that will be discussed in the </span><span><span class="kobospan" id="kobo.420.1">next subsection.</span></span></p>
<h2 id="_idParaDest-143" class="calibre7"><a id="_idTextAnchor188" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.421.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.422.1">To encapsulate</span><a id="_idIndexMarker350" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.423.1"> the nurse scheduling problem we described at the beginning of this section, we’ve created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">NurseSchedulingProblem</span></strong><span class="kobospan" id="kobo.425.1">. </span><span class="kobospan" id="kobo.425.2">This class is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.426.1">nurses.py</span></strong><span class="kobospan" id="kobo.427.1"> file, which can be found </span><span><span class="kobospan" id="kobo.428.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.429.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py</span></span></a><span><span class="kobospan" id="kobo.430.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.431.1">The class constructor accepts the </span><strong class="source-inline"><span class="kobospan" id="kobo.432.1">hardConstraintPenalty</span></strong><span class="kobospan" id="kobo.433.1"> parameter, which represents the penalty factor for a hard constraint violation (while the penalty of a soft constraint violation is fixed to 1). </span><span class="kobospan" id="kobo.433.2">Then, it continues to initialize the various parameters, describing the </span><span><span class="kobospan" id="kobo.434.1">scheduling problem:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.435.1">
# list of nurses:
self.nurses = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
# nurses' respective shift preferences - morning, evening, night:
self.shiftPreference = [[1, 0, 0], [1, 1, 0], [0, 1, 1], [0, 1, 0], 
    [0, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 1]]
# min and max number of nurses allowed for each shift - morning, evening, night:
self.shiftMin = [2, 2, 1]
self.shiftMax = [3, 4, 2]
# max shifts per week allowed for each nurse:
self.maxShiftsPerWeek = 5</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.436.1">The class uses the following method to convert the given schedule into a dictionary with a separate schedule for </span><span><span class="kobospan" id="kobo.437.1">each nurse:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.438.1">getNurseShifts(schedule)</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">The following methods are used to count the various types </span><span><span class="kobospan" id="kobo.440.1">of violations:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.441.1">countConsecutiveShiftViolations(nurseShiftsDict)</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.442.1">countShiftsPerWeekViolations(nurseShiftsDict)</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.443.1">countNursesPerShiftViolations(nurseShiftsDict)</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">countShiftPreferenceViolations(nurseShiftsDict)</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.445.1">In addition, the class provides the following </span><span><span class="kobospan" id="kobo.446.1">public methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.447.1">getCost(schedule)</span></strong><span class="kobospan" id="kobo.448.1">: Calculates the total cost of the various violations in the given schedule. </span><span class="kobospan" id="kobo.448.2">This method uses the value of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">hardConstraintPenalty</span></strong></span><span><span class="kobospan" id="kobo.450.1"> variable.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.451.1">printScheduleInfo(schedule)</span></strong><span class="kobospan" id="kobo.452.1">: Prints the schedule and </span><span><span class="kobospan" id="kobo.453.1">violation details.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.454.1">The main method</span><a id="_idIndexMarker351" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.455.1"> of the class exercises the class’ methods by creating an instance of the nurse scheduling problem and testing a randomly generated solution for it. </span><span class="kobospan" id="kobo.455.2">The resulting output may look as follows, with the value of </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">hardConstraintPenalty</span></strong><span class="kobospan" id="kobo.457.1"> set </span><span><span class="kobospan" id="kobo.458.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">10</span></strong></span><span><span class="kobospan" id="kobo.460.1">:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.461.1">
Random Solution =
[0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 0 0 1 1 1 0 1 0 0 0 0 0 1 1 1 1 1 0 1 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 0 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 1 1 0 1 0]
Schedule for each nurse:
A : [0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 1 1 1 0 1]
B : [0 1 1 1 1 1 1 1 1 0 0 1 1 1 0 1 0 0 0 0 0]
C : [1 1 1 1 1 0 1 1 0 1 0 1 0 1 1 0 0 0 0 0 0]
D : [0 0 1 1 0 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1]
E : [0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1]
F : [1 1 1 1 0 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1]
G : [1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0]
H : [0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 1 1 0 1 0]
consecutive shift violations =  47
weekly Shifts =  [8, 12, 11, 13, 16, 13, 8, 8]
Shifts Per Week Violations =  49
Nurses Per Shift =  [3, 4, 7, 5, 4, 5, 4, 5, 5, 3, 4, 3, 5, 5, 5, 3, 4, 5, 4, 2, 4]
Nurses Per Shift Violations =  28
Shift Preference Violations =  39
Total Cost =  1279</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.462.1">As is evident from these results, a randomly generated solution is likely to yield a large number of violations, and consequently a large cost value. </span><span class="kobospan" id="kobo.462.2">In the next subsection, we’ll attempt to</span><a id="_idIndexMarker352" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.463.1"> minimize the cost and eliminate all hard constraint violations using a genetic </span><span><span class="kobospan" id="kobo.464.1">algorithm-based solution.</span></span></p>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor189" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.465.1">Genetic algorithms solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.466.1">To solve the </span><a id="_idIndexMarker353" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.467.1">nurse scheduling problem using a genetic algorithm, we’ve created a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">02-solve-nurses.py</span></strong><span class="kobospan" id="kobo.469.1">, which is located </span><span><span class="kobospan" id="kobo.470.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.471.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py</span></span></a><span><span class="kobospan" id="kobo.472.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.473.1">Since the solution representation we chose for this problem is a list (or an array) of binary values, we were able to use the same genetic approach we used for several problems we have solved already, such as the 0-1 knapsack problem we described in </span><a href="B20851_04.xhtml#_idTextAnchor155" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.474.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.475.1">, </span><span><em class="italic"><span class="kobospan" id="kobo.476.1">Combinatorial Optimization</span></em></span><span><span class="kobospan" id="kobo.477.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">The main parts of our solution are described in the </span><span><span class="kobospan" id="kobo.479.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.480.1">Our program starts by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.481.1">NurseSchedulingProblem</span></strong><span class="kobospan" id="kobo.482.1"> class with the desired value for </span><strong class="source-inline1"><span class="kobospan" id="kobo.483.1">hardConstraintPenalty</span></strong><span class="kobospan" id="kobo.484.1">, which is set by the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.485.1">HARD_CONSTRAINT_PENALTY</span></strong></span><span><span class="kobospan" id="kobo.486.1"> constant:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.487.1">
nsp = nurses.</span><strong class="bold1"><span class="kobospan1" id="kobo.488.1">NurseSchedulingProblem</span></strong><span class="kobospan1" id="kobo.489.1">(HARD_CONSTRAINT_PENALTY)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.490.1">Since our goal is to minimize the cost, we must define a single objective, minimizing the </span><span><span class="kobospan" id="kobo.491.1">fitness strategy:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.492.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.493.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.494.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.495.1">Since the solution is represented by a list of 0 or 1 values, we must use the following</span><a id="_idIndexMarker354" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.496.1"> toolbox definitions to create the </span><span><span class="kobospan" id="kobo.497.1">initial population:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.498.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.499.1">Individual</span></strong><span class="kobospan1" id="kobo.500.1">", list, fitness=creator.FitnessMin)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.501.1">zeroOrOne</span></strong><span class="kobospan1" id="kobo.502.1">", random.randint, 0, 1)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.503.1">individualCreator</span></strong><span class="kobospan1" id="kobo.504.1">", tools.initRepeat, \
    creator.Individual, toolbox.zeroOrOne, len(nsp))
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.505.1">populationCreator</span></strong><span class="kobospan1" id="kobo.506.1">", tools.initRepeat, \
    list, toolbox.individualCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.507.1">The actual fitness function is set to calculate the cost of the various violations in the schedule, represented by </span><span><span class="kobospan" id="kobo.508.1">each solution:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.509.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.510.1">getCost</span></strong><span class="kobospan1" id="kobo.511.1">(individual):
    return </span><strong class="bold1"><span class="kobospan1" id="kobo.512.1">nsp.getCost</span></strong><span class="kobospan1" id="kobo.513.1">(individual),
toolbox.register("evaluate", </span><strong class="bold1"><span class="kobospan1" id="kobo.514.1">getCost</span></strong><span class="kobospan1" id="kobo.515.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.516.1">As for the genetic operators, we must use tournament selection with a tournament size of </span><strong class="source-inline1"><span class="kobospan" id="kobo.517.1">2</span></strong><span class="kobospan" id="kobo.518.1">, along with two-point crossover and flip-bit mutation, since this is suitable for </span><span><span class="kobospan" id="kobo.519.1">binary lists:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.520.1">
toolbox.register("select", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.521.1">selTournament</span></strong><span class="kobospan1" id="kobo.522.1">, tournsize=2)
toolbox.register("mate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.523.1">cxTwoPoint</span></strong><span class="kobospan1" id="kobo.524.1">)
toolbox.register("mutate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.525.1">mutFlipBit</span></strong><span class="kobospan1" id="kobo.526.1">, indpb=1.0/len(nsp))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.527.1">We keep using the elitist approach, where HOF members – the current best individuals – are always passed untouched to the </span><span><span class="kobospan" id="kobo.528.1">next generation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.529.1">
population, logbook = elitism.eaSimpleWithElitism(
    population, toolbox, cxpb=P_CROSSOVER, \
    mutpb=P_MUTATION, ngen=MAX_GENERATIONS, \
    stats=stats, halloffame=hof, verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.530.1">When the algorithm concludes, we print the details of the best solution that </span><span><span class="kobospan" id="kobo.531.1">was found:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.532.1">
nsp.printScheduleInfo(</span><strong class="bold1"><span class="kobospan1" id="kobo.533.1">best</span></strong><span class="kobospan1" id="kobo.534.1">)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">Before we run</span><a id="_idIndexMarker355" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.536.1"> the program, let’s set the algorithm constants, </span><span><span class="kobospan" id="kobo.537.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.538.1">
POPULATION_SIZE = 300
P_CROSSOVER = 0.9
P_MUTATION = 0.1
MAX_GENERATIONS = 200
HALL_OF_FAME_SIZE = 30</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.539.1">In addition, let’s start by setting the penalty for violating hard constraints to a value of </span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">1</span></strong><span class="kobospan" id="kobo.541.1">, which makes the cost of violating a hard constraint similar to that of violating a </span><span><span class="kobospan" id="kobo.542.1">soft constraint:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.543.1">
HARD_CONSTRAINT_PENALTY = 1</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.544.1">Running the program with these settings yields the </span><span><span class="kobospan" id="kobo.545.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.546.1">
-- Best Fitness = 3.0
-- Schedule =
Schedule for each nurse:
A : [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]
B : [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]
C : [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
D : [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]
E : [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]
F : [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]
G : [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1]
H : [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]
consecutive shift violations = 0
weekly Shifts = [5, 6, 2, 5, 4, 5, 5, 5]
Shifts Per Week Violations = 1
Nurses Per Shift = [2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1]
Nurses Per Shift Violations = 0
Shift Preference Violations = 2</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.547.1">This may</span><a id="_idIndexMarker356" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.548.1"> seem like a good result since we ended up with only three constraint violations. </span><span class="kobospan" id="kobo.548.2">However, one of them is</span><a id="_idIndexMarker357" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.549.1"> a </span><strong class="bold"><span class="kobospan" id="kobo.550.1">shift-per-week violation</span></strong><span class="kobospan" id="kobo.551.1"> – nurse B was scheduled with six shifts for the week, exceeding the maximum allowed of five. </span><span class="kobospan" id="kobo.551.2">This is enough to make the entire </span><span><span class="kobospan" id="kobo.552.1">solution unacceptable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.553.1">In an attempt to eliminate this kind of violation, we’ll proceed to increase the hard constraint penalty value </span><span><span class="kobospan" id="kobo.554.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.555.1">10</span></strong></span><span><span class="kobospan" id="kobo.556.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.557.1">
HARD_CONSTRAINT_PENALTY = 10</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.558.1">Now, the </span><a id="_idIndexMarker358" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.559.1">result is </span><span><span class="kobospan" id="kobo.560.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.561.1">
-- Best Fitness = 3.0
-- Schedule =
Schedule for each nurse:
A : [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
B : [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]
C : [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1]
D : [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]
E : [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]
F : [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0]
G : [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]
H : [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]
consecutive shift violations = 0
weekly Shifts = [4, 5, 5, 5, 3, 5, 5, 5]
Shifts Per Week Violations = 0
Nurses Per Shift = [2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1]
Nurses Per Shift Violations = 0
Shift Preference Violations = 3</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.562.1">Again, we got three violations, but this time, they were all soft constraint violations, which makes this </span><span><span class="kobospan" id="kobo.563.1">solution valid.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.564.1">The following graph, which depicts the minimum and average fitness over the generations, indicates that over the first 40-50 generations, the algorithm was able to eliminate all hard constraint violations, and from there on there were only small incremental</span><a id="_idIndexMarker359" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.565.1"> improvements, which occurred whenever another soft constraint </span><span><span class="kobospan" id="kobo.566.1">was eliminated:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer087">
<span class="kobospan" id="kobo.567.1"><img alt="Figure 5.8: Stats of the program solving the nurse scheduling problem" src="image/B20851_05_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.568.1">Figure 5.8: Stats of the program solving the nurse scheduling problem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.569.1">It seems that, in our case, it was enough to set a 10-fold penalty on hard constraint violations. </span><span class="kobospan" id="kobo.569.2">In other problems, higher values may be required. </span><span class="kobospan" id="kobo.569.3">You are encouraged to experiment by altering the problem’s definitions, as well as the genetic </span><span><span class="kobospan" id="kobo.570.1">algorithm’s settings.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.571.1">The same trade-off we have just seen between soft and hard constraints is going to play a part in the </span><a id="_idIndexMarker360" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.572.1">next task we take on – the graph </span><span><span class="kobospan" id="kobo.573.1">coloring problem.</span></span></p>
<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor190" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.574.1">Solving the graph coloring problem</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.575.1">In the mathematical </span><a id="_idIndexMarker361" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.576.1">branch of graph theory, a </span><strong class="bold"><span class="kobospan" id="kobo.577.1">graph</span></strong><span class="kobospan" id="kobo.578.1"> is a</span><a id="_idIndexMarker362" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.579.1"> structured collection of objects that represents the relationships between pairs of these objects. </span><span class="kobospan" id="kobo.579.2">The objects appear </span><a id="_idIndexMarker363" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.580.1">as </span><strong class="bold"><span class="kobospan" id="kobo.581.1">vertices</span></strong><span class="kobospan" id="kobo.582.1"> (or nodes) in the graph, while the relation between a pair of objects is represented </span><a id="_idIndexMarker364" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.583.1">using an </span><strong class="bold"><span class="kobospan" id="kobo.584.1">edge</span></strong><span class="kobospan" id="kobo.585.1">. </span><span class="kobospan" id="kobo.585.2">A common way of illustrating a graph is by drawing the vertices as circles and the edges as connecting lines, as depicted in the following diagram of the </span><em class="italic"><span class="kobospan" id="kobo.586.1">Petersen graph</span></em><span class="kobospan" id="kobo.587.1">, named after the Danish mathematician </span><span><span class="kobospan" id="kobo.588.1">Julius Petersen:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer088">
<span class="kobospan" id="kobo.589.1"><img alt="Figure 5.9: Petersen graph" src="image/B20851_05_09.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.590.1">Figure 5.9: Petersen graph</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.591.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Petersen1_tiny.svg" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.592.1">https://commons.wikimedia.org/wiki/File:Petersen1_tiny.svg</span></a></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.593.1">Image by Leshabirukov. </span></p>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">Graphs are remarkably useful objects as they can represent and help us research an overwhelming variety of real-life structures, patterns, and relationships, such as social networks, power grid layouts, website structures, linguistic compositions, computer networks, atomic structures, migration patterns, </span><span><span class="kobospan" id="kobo.595.1">and more.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.596.1">The </span><strong class="bold"><span class="kobospan" id="kobo.597.1">graph coloring</span></strong><span class="kobospan" id="kobo.598.1"> task is </span><a id="_idIndexMarker365" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.599.1">used to assign a color for every node in the graph in such a way that no pair of connected (adjacent) nodes will share the same color. </span><span class="kobospan" id="kobo.599.2">This is also known</span><a id="_idIndexMarker366" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.600.1"> as the </span><strong class="bold"><span class="kobospan" id="kobo.601.1">proper coloring</span></strong><span class="kobospan" id="kobo.602.1"> of </span><span><span class="kobospan" id="kobo.603.1">the graph.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.604.1">The following diagram shows the same Petersen graph, but this time </span><span><span class="kobospan" id="kobo.605.1">colored properly:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer089">
<span class="kobospan" id="kobo.606.1"><img alt="Figure 5.10: Proper coloring of the Petersen graph" src="image/B20851_05_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.607.1">Figure 5.10: Proper coloring of the Petersen graph</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.608.1">Source: </span><a href="https://en.wikipedia.org/wiki/File:Petersen_graph_3-coloring.svg" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.609.1">https://en.wikipedia.org/wiki/File:Petersen_graph_3-coloring.svg</span></a><span class="kobospan" id="kobo.610.1">. </span></p>
<p class="calibre3"><span class="kobospan" id="kobo.611.1">The color assignment is often accompanied by an optimization requirement – use the </span><strong class="bold"><span class="kobospan" id="kobo.612.1">minimum possible</span></strong><span class="kobospan" id="kobo.613.1"> number </span><a id="_idIndexMarker367" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.614.1">of colors. </span><span class="kobospan" id="kobo.614.2">For example, the Peterson graph can be properly</span><a id="_idIndexMarker368" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.615.1"> colored using three colors, as demonstrated in the preceding diagram. </span><span class="kobospan" id="kobo.615.2">But it would be impossible to color it properly using only two colors. </span><span class="kobospan" id="kobo.615.3">In graph theory terms, this means that the </span><em class="italic"><span class="kobospan" id="kobo.616.1">chromatic number</span></em><span class="kobospan" id="kobo.617.1"> of this graph </span><span><span class="kobospan" id="kobo.618.1">is three.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.619.1">Why would we care about coloring the nodes of the graph? </span><span class="kobospan" id="kobo.619.2">Many real-life problems can be translated into a graph representation in such a way that the graph coloring will stand for a solution – for example, scheduling classes for a student, or shifts for an employee can be translated into a graph, where adjacent nodes represent classes or shifts that cause a conflict. </span><span class="kobospan" id="kobo.619.3">Such a conflict can be classes that fall at the same time or shifts that are consecutive (sound familiar?). </span><span class="kobospan" id="kobo.619.4">Due to this conflict, assigning the same person to both classes (or both shifts) will invalidate the schedule. </span><span class="kobospan" id="kobo.619.5">If each color represents a different person, assigning different colors to adjacent nodes will solve the conflicts. </span><span class="kobospan" id="kobo.619.6">The N-Queen problem we encountered at the beginning of this chapter can be represented as a graph coloring problem, where every node in the graph represents a square on the chessboard, and every pair of nodes that share a row, a column, or a diagonal is connected by an edge. </span><span class="kobospan" id="kobo.619.7">Other relevant examples include frequency assignments to radio stations, power grid redundancy planning, traffic light timing, and even </span><span><span class="kobospan" id="kobo.620.1">Sudoku puzzle-solving.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.621.1">Hopefully, this has</span><a id="_idIndexMarker369" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.622.1"> convinced you that graph coloring is a problem worth solving. </span><span class="kobospan" id="kobo.622.2">As usual, we will start by formulating an appropriate representation of a possible solution for </span><span><span class="kobospan" id="kobo.623.1">this problem.</span></span></p>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor191" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.624.1">Solution representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">Expanding on the</span><a id="_idIndexMarker370" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.626.1"> commonly used binary list (or array) representation, we can employ a list of integers, where each integer represents a unique color, while each element of the list matches one of the </span><span><span class="kobospan" id="kobo.627.1">graph’s nodes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.628.1">For example, since the Petersen graph has 10 nodes, we can assign each node an index between 0 and 9. </span><span class="kobospan" id="kobo.628.2">Then, we can represent the node coloring for that graph using a list of </span><span><span class="kobospan" id="kobo.629.1">10 elements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.630.1">For example, let’s have a look at what we have in this </span><span><span class="kobospan" id="kobo.631.1">particular representation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.632.1">
[0, 2, 1, 3, 1, 2, 0, 3, 3, 0]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.633.1">Let’s talk about what we have here </span><span><span class="kobospan" id="kobo.634.1">in detail:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.635.1">Four colors are used, represented by the integers </span><strong class="source-inline1"><span class="kobospan" id="kobo.636.1">0</span></strong><span class="kobospan" id="kobo.637.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.638.1">1</span></strong><span class="kobospan" id="kobo.639.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.640.1">2</span></strong><span class="kobospan" id="kobo.641.1">, </span><span><span class="kobospan" id="kobo.642.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.643.1">3</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.644.1">The first, seventh, and tenth nodes of the graph are colored with the first </span><span><span class="kobospan" id="kobo.645.1">color (</span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.646.1">0</span></strong></span><span><span class="kobospan" id="kobo.647.1">)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.648.1">The third and fifth nodes are colored with the second </span><span><span class="kobospan" id="kobo.649.1">color (</span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.650.1">1</span></strong></span><span><span class="kobospan" id="kobo.651.1">)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.652.1">The second and sixth nodes are colored with the third </span><span><span class="kobospan" id="kobo.653.1">color (</span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.654.1">2</span></strong></span><span><span class="kobospan" id="kobo.655.1">)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.656.1">The fourth, eighth, and ninth nodes are colored with the fourth </span><span><span class="kobospan" id="kobo.657.1">color (</span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.658.1">3</span></strong></span><span><span class="kobospan" id="kobo.659.1">)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.660.1">To evaluate the solution, we need to iterate over each pair of adjacent nodes and check if they share the same color. </span><span class="kobospan" id="kobo.660.2">If they do, this is a coloring violation, and we seek to minimize the number of violations to zero to achieve the proper coloring of </span><span><span class="kobospan" id="kobo.661.1">the graph.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.662.1">However, you may recall that we also wish to minimize the number of colors that are used. </span><span class="kobospan" id="kobo.662.2">If we happen to already know this number, we can just use as many integer values as the known number of colors. </span><span class="kobospan" id="kobo.662.3">But what if we don’t? </span><span class="kobospan" id="kobo.662.4">One way to go about this is to start with an estimate (or just a guess) for the number of colors used. </span><span class="kobospan" id="kobo.662.5">If we find a proper solution using this number, we can reduce the number and try again. </span><span class="kobospan" id="kobo.662.6">If no solution is found, we can increase the number and try again until we have the smallest number we can find a solution </span><a id="_idIndexMarker371" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.663.1">with. </span><span class="kobospan" id="kobo.663.2">However, we may be able to get to this number faster by using soft and hard constraints, as described in the </span><span><span class="kobospan" id="kobo.664.1">next subsection.</span></span></p>
<h2 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor192" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.665.1">Using hard and soft constraints for the graph coloring problem</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.666.1">When solving the</span><a id="_idIndexMarker372" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.667.1"> nurse scheduling problem earlier in this chapter, we noted the difference between hard constraints – those we have to adhere to for the solution to be considered valid – and soft constraints – those we strive to minimize to get the best solution. </span><span class="kobospan" id="kobo.667.2">In the graph coloring problem, the </span><strong class="bold"><span class="kobospan" id="kobo.668.1">color assignment</span></strong><span class="kobospan" id="kobo.669.1"> requirement – where no two adjacent nodes can have the same color – is a </span><strong class="bold"><span class="kobospan" id="kobo.670.1">hard constraint</span></strong><span class="kobospan" id="kobo.671.1">. </span><span class="kobospan" id="kobo.671.2">We have to minimize the number of violations of this constraint to zero to achieve a </span><span><span class="kobospan" id="kobo.672.1">valid solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.673.1">Minimizing the </span><strong class="bold"><span class="kobospan" id="kobo.674.1">number of colors</span></strong><span class="kobospan" id="kobo.675.1"> used, however, can be introduced as a </span><strong class="bold"><span class="kobospan" id="kobo.676.1">soft constraint</span></strong><span class="kobospan" id="kobo.677.1">. </span><span class="kobospan" id="kobo.677.2">We would like to minimize this number, but not at the expense of violating the </span><span><span class="kobospan" id="kobo.678.1">hard constraint.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.679.1">This will allow us to launch the algorithm with several colors higher than our estimate and let the algorithm minimize it until – ideally – it reaches the actual minimal </span><span><span class="kobospan" id="kobo.680.1">color count.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.681.1">As we did for the nurse scheduling problem, we will implement this approach by creating a cost function, where the cost of a hard constraint violation is greater than the cost induced by using more colors. </span><span class="kobospan" id="kobo.681.2">The total cost will then be used as the fitness function to be minimized. </span><span class="kobospan" id="kobo.681.3">This functionality can be incorporated into the Python class and will be described in the </span><span><span class="kobospan" id="kobo.682.1">next subsection.</span></span></p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor193" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.683.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.684.1">To encapsulate</span><a id="_idIndexMarker373" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.685.1"> the graph coloring problem, we’ve created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.686.1">GraphColoringProblem</span></strong><span class="kobospan" id="kobo.687.1">. </span><span class="kobospan" id="kobo.687.2">This class can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.688.1">graphs.py</span></strong><span class="kobospan" id="kobo.689.1"> file, which can be found </span><span><span class="kobospan" id="kobo.690.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/graphs.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.691.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/graphs.py</span></span></a><span><span class="kobospan" id="kobo.692.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.693.1">To implement this class, we’ll utilize the open source Python</span><a id="_idIndexMarker374" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.694.1"> package </span><strong class="bold"><span class="kobospan" id="kobo.695.1">NetworkX</span></strong><span class="kobospan" id="kobo.696.1"> (</span><a href="https://networkx.github.io" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.697.1">https://networkx.github.io</span></a><span class="kobospan" id="kobo.698.1">), which allows us to create, manipulate, and draw graphs, among other things. </span><span class="kobospan" id="kobo.698.2">The graph we’ll be using as the subject of the coloring problem is an instance of the NetworkX </span><strong class="source-inline"><span class="kobospan" id="kobo.699.1">graph</span></strong><span class="kobospan" id="kobo.700.1"> class. </span><span class="kobospan" id="kobo.700.2">Instead of creating this graph from scratch, we can take advantage of the numerous preexisting graphs contained in this library, such as the </span><em class="italic"><span class="kobospan" id="kobo.701.1">Petersen graph</span></em><span class="kobospan" id="kobo.702.1"> we </span><span><span class="kobospan" id="kobo.703.1">saw earlier.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.704.1">The constructor of the </span><strong class="source-inline"><span class="kobospan" id="kobo.705.1">GraphColoringProblem</span></strong><span class="kobospan" id="kobo.706.1"> class accepts the graph to be colored as a parameter. </span><span class="kobospan" id="kobo.706.2">In addition, it accepts the </span><strong class="source-inline"><span class="kobospan" id="kobo.707.1">hardConstraintPenalty</span></strong><span class="kobospan" id="kobo.708.1"> parameter, which represents the penalty factor for a hard </span><span><span class="kobospan" id="kobo.709.1">constraint violation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.710.1">The constructor then creates a list of the graph’s nodes, as well as an adjacency matrix, that allows us to quickly find out if any two nodes in the graph </span><span><span class="kobospan" id="kobo.711.1">are adjacent:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.712.1">
self.</span><strong class="bold1"><span class="kobospan1" id="kobo.713.1">nodeList</span></strong><span class="kobospan1" id="kobo.714.1"> = list(self.graph.nodes)
self.</span><strong class="bold1"><span class="kobospan1" id="kobo.715.1">adjMatrix</span></strong><span class="kobospan1" id="kobo.716.1"> = nx.adjacency_matrix(graph).todense()</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.717.1">This class uses the following method to calculate the number of coloring violations in the given </span><span><span class="kobospan" id="kobo.718.1">color</span></span><span><a id="_idIndexMarker375" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.719.1"> arrangement:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.720.1">getViolationsCount</span></strong></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.721.1">(colorArrangement)</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.722.1">The following method is used to calculate the number of colors used by the given </span><span><span class="kobospan" id="kobo.723.1">color arrangement:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.724.1">getNumberOfColors</span></strong></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.725.1">(colorArrangement)</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.726.1">In addition, the class provides the following </span><span><span class="kobospan" id="kobo.727.1">public methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.728.1">getCost</span></strong><strong class="source-inline1"><span class="kobospan" id="kobo.729.1">(colorArrangement)</span></strong><span class="kobospan" id="kobo.730.1">: This calculates the total cost of the given </span><span><span class="kobospan" id="kobo.731.1">color arrangement</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.732.1">plotGraph</span></strong><strong class="source-inline1"><span class="kobospan" id="kobo.733.1">(colorArrangement)</span></strong><span class="kobospan" id="kobo.734.1">: This plots the graph with the nodes colored according to the given </span><span><span class="kobospan" id="kobo.735.1">color arrangement</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.736.1">The main method of the class exercises the class’ methods by creating a Petersen graph instance and testing a randomly generated color arrangement for it, containing up to five colors. </span><span class="kobospan" id="kobo.736.2">In addition, it sets the value of </span><strong class="source-inline"><span class="kobospan" id="kobo.737.1">hardConstraintPenalty</span></strong> <span><span class="kobospan" id="kobo.738.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.739.1">10</span></strong></span><span><span class="kobospan" id="kobo.740.1">:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.741.1">
gcp = GraphColoringProblem(nx.petersen_graph(), 10)
solution = np.random.randint(5, size=len(gcp))</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.742.1">The resulting output may look </span><span><span class="kobospan" id="kobo.743.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.744.1">
solution = [2 4 1 3 0 0 2 2 0 3]
number of colors = 5
Number of violations = 1
Cost = 15</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.745.1">Since this particular random solution uses five colors and causes one coloring violation, the calculated cost </span><span><span class="kobospan" id="kobo.746.1">is 15.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.747.1">The plot for this </span><a id="_idIndexMarker376" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.748.1">solution is as follows – can you spot the single </span><span><span class="kobospan" id="kobo.749.1">coloring violation?</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer090">
<span class="kobospan" id="kobo.750.1"><img alt="Figure 5.11: Petersen graph improperly colored with five colors" src="image/B20851_05_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.751.1">Figure 5.11: Petersen graph improperly colored with five colors</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.752.1">In the next subsection, we’ll apply a genetic algorithm-based solution in an attempt to eliminate any coloring</span><a id="_idIndexMarker377" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.753.1"> violations while also minimizing the number of colors that </span><span><span class="kobospan" id="kobo.754.1">are used.</span></span></p>
<h2 id="_idParaDest-149" class="calibre7"><a id="_idTextAnchor194" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.755.1">Genetic algorithms solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.756.1">To solve the graph</span><a id="_idIndexMarker378" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.757.1"> coloring problem using a genetic algorithm, we’ve created a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">03-solve-graphs.py</span></strong><span class="kobospan" id="kobo.759.1">, which is located </span><span><span class="kobospan" id="kobo.760.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/03_solve_graphs.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.761.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/03_solve_graphs.py</span></span></a><span><span class="kobospan" id="kobo.762.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.763.1">Since the solution representation we chose for this problem is a list of integers, we need to expand the genetic approach of using a </span><span><span class="kobospan" id="kobo.764.1">binary list.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.765.1">The following steps describe the main points of </span><span><span class="kobospan" id="kobo.766.1">our solution:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.767.1">The program starts by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.768.1">GraphColoringProblem</span></strong><span class="kobospan" id="kobo.769.1"> class with the desired </span><em class="italic"><span class="kobospan" id="kobo.770.1">NetworkX</span></em><span class="kobospan" id="kobo.771.1"> graph to be solved – the familiar </span><em class="italic"><span class="kobospan" id="kobo.772.1">Petersen graph</span></em><span class="kobospan" id="kobo.773.1"> in this case – and the desired value for </span><strong class="source-inline1"><span class="kobospan" id="kobo.774.1">hardConstraintPenalty</span></strong><span class="kobospan" id="kobo.775.1">, which is set by the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.776.1">HARD_CONSTRAINT_PENALTY</span></strong></span><span><span class="kobospan" id="kobo.777.1"> constant:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.778.1">
gcp = graphs.</span><strong class="bold1"><span class="kobospan1" id="kobo.779.1">GraphColoringProblem</span></strong><span class="kobospan1" id="kobo.780.1">(nx.petersen_graph(), 
    HARD_CONSTRAINT_PENALTY)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.781.1">Since our goal is to minimize the cost, we’ll define a single objective, minimizing </span><span><span class="kobospan" id="kobo.782.1">fitness strategy:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.783.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.784.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.785.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.786.1">Since the</span><a id="_idIndexMarker379" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.787.1"> solution is represented by a list of integer values representing the participating colors, we need to define a random generator that creates an integer between 0 and the number of colors minus 1. </span><span class="kobospan" id="kobo.787.2">This random integer represents one of the participating colors. </span><span class="kobospan" id="kobo.787.3">Then, we must define a solution (individual) creator that generates a list of these random integers that match the given graph in length – this is how we randomly assign a color for each node in the graph. </span><span class="kobospan" id="kobo.787.4">Finally, we must define an operator that creates an entire population </span><span><span class="kobospan" id="kobo.788.1">of individuals:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.789.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.790.1">Integers</span></strong><span class="kobospan1" id="kobo.791.1">", random.randint, 0, MAX_COLORS - 1)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.792.1">individualCreator</span></strong><span class="kobospan1" id="kobo.793.1">", tools.initRepeat, \
    creator.Individual, toolbox.Integers, len(gcp))
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.794.1">populationCreator</span></strong><span class="kobospan1" id="kobo.795.1">", tools.initRepeat, \
    list, toolbox.individualCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.796.1">The fitness evaluation function is set to calculate the combined cost of the coloring violations and the number of colors used, which is associated with each solution, by calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.797.1">getCost()</span></strong><span class="kobospan" id="kobo.798.1"> method of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.799.1">GraphColoringProblem</span></strong></span><span><span class="kobospan" id="kobo.800.1"> class:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.801.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.802.1">getCost</span></strong><span class="kobospan1" id="kobo.803.1">(individual):
    return gcp.getCost(individual),
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.804.1">evaluate</span></strong><span class="kobospan1" id="kobo.805.1">", getCost)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.806.1">As for the genetic operators, we can still use the same </span><em class="italic"><span class="kobospan" id="kobo.807.1">selection</span></em><span class="kobospan" id="kobo.808.1"> and </span><em class="italic"><span class="kobospan" id="kobo.809.1">crossover</span></em><span class="kobospan" id="kobo.810.1"> operations we used for binary lists; however, the mutation operation needs to change. </span><span class="kobospan" id="kobo.810.2">The </span><em class="italic"><span class="kobospan" id="kobo.811.1">flip-bit mutation</span></em><span class="kobospan" id="kobo.812.1"> that’s used for binary lists flips between values of 0 and 1, while here, we need to change a given integer to another – randomly generated – integer in the allowed range. </span><span class="kobospan" id="kobo.812.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.813.1">mutUniformInt</span></strong><span class="kobospan" id="kobo.814.1"> operator does just that – we just </span><a id="_idIndexMarker380" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.815.1">need to set the range similar to what we did with the preceding </span><span><span class="kobospan" id="kobo.816.1">integers operator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.817.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.818.1">select</span></strong><span class="kobospan1" id="kobo.819.1">", tools.selTournament, tournsize=2)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.820.1">mate</span></strong><span class="kobospan1" id="kobo.821.1">", tools.cxTwoPoint)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.822.1">mutate</span></strong><span class="kobospan1" id="kobo.823.1">", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.824.1">mutUniformInt</span></strong><span class="kobospan1" id="kobo.825.1">, low=0, \
    up=MAX_COLORS - 1, indpb=1.0/len(gcp))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.826.1">We keep using the </span><em class="italic"><span class="kobospan" id="kobo.827.1">elitist approach</span></em><span class="kobospan" id="kobo.828.1">, where the HOF members – the current best individuals – are always passed untouched to the </span><span><span class="kobospan" id="kobo.829.1">next generation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.830.1">
population, logbook = elitism.</span><strong class="bold1"><span class="kobospan1" id="kobo.831.1">eaSimpleWithElitism</span></strong><span class="kobospan1" id="kobo.832.1">(\
    population, toolbox, cxpb=P_CROSSOVER, \
    mutpb=P_MUTATION, ngen=MAX_GENERATIONS, \
    stats=stats, halloffame=hof, verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.833.1">When the algorithm concludes, we print the details of the best solution that was found before plotting </span><span><span class="kobospan" id="kobo.834.1">the graphs.</span></span><pre class="source-code"><span class="kobospan1" id="kobo.835.1">
gcp.plotGraph(best)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.836.1">Before we run the program, let’s set the algorithm constants, </span><span><span class="kobospan" id="kobo.837.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.838.1">
POPULATION_SIZE = 100
P_CROSSOVER = 0.9
P_MUTATION = 0.1
MAX_GENERATIONS = 100
HALL_OF_FAME_SIZE = 5</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.839.1">In addition, we need to set a penalty for violating hard constraints to a value of </span><strong class="source-inline"><span class="kobospan" id="kobo.840.1">10</span></strong><span class="kobospan" id="kobo.841.1"> and the number of colors </span><span><span class="kobospan" id="kobo.842.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.843.1">10</span></strong></span><span><span class="kobospan" id="kobo.844.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.845.1">
HARD_CONSTRAINT_PENALTY = 10
MAX_COLORS = 10</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.846.1">Running the</span><a id="_idIndexMarker381" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.847.1"> program with these settings yields the </span><span><span class="kobospan" id="kobo.848.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.849.1">
-- Best Individual = [5, 0, 6, 5, 0, 6, 5, 0, 0, 6]
-- Best Fitness = 3.0
Number of colors = 3
Number of violations = 0
Cost = 3</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.850.1">This means that the algorithm was able to find a proper coloring for the graph using three colors, denoted by the integers </span><strong class="source-inline"><span class="kobospan" id="kobo.851.1">0</span></strong><span class="kobospan" id="kobo.852.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.853.1">5</span></strong><span class="kobospan" id="kobo.854.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.855.1">6</span></strong><span class="kobospan" id="kobo.856.1">. </span><span class="kobospan" id="kobo.856.2">As we mentioned previously, the actual integer values don’t matter – it’s the distinction between them that does. </span><span class="kobospan" id="kobo.856.3">Three is indeed the known chromatic number of the </span><span><span class="kobospan" id="kobo.857.1">Petersen graph.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.858.1">The preceding code creates the following plot, which illustrates the </span><span><span class="kobospan" id="kobo.859.1">solution’s validity:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer091">
<span class="kobospan" id="kobo.860.1"><img alt="Figure 5.12: A plot of the Petersen graph properly colored by the program using three colors" src="image/B20851_05_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.861.1">Figure 5.12: A plot of the Petersen graph properly colored by the program using three colors</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.862.1">The following</span><a id="_idIndexMarker382" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.863.1"> graph, which depicts the minimum and average fitness over the generations, indicates that the algorithm reached the solution rather quickly since the Petersen graph is </span><span><span class="kobospan" id="kobo.864.1">relatively small:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer092">
<span class="kobospan" id="kobo.865.1"><img alt="Figure 5.13: Stats of the program solving the graph coloring problem for the Petersen graph" src="image/B20851_05_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.866.1">Figure 5.13: Stats of the program solving the graph coloring problem for the Petersen graph</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.867.1">To try a larger</span><a id="_idIndexMarker383" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.868.1"> graph, let’s replace the </span><em class="italic"><span class="kobospan" id="kobo.869.1">Petersen graph</span></em><span class="kobospan" id="kobo.870.1"> with a </span><em class="italic"><span class="kobospan" id="kobo.871.1">Mycielski graph</span></em><span class="kobospan" id="kobo.872.1"> of order </span><strong class="source-inline"><span class="kobospan" id="kobo.873.1">5</span></strong><span class="kobospan" id="kobo.874.1">. </span><span class="kobospan" id="kobo.874.2">This graph contains 23 nodes and 71 edges, and is known to have a chromatic number </span><span><span class="kobospan" id="kobo.875.1">of 5:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.876.1">
gcp = graphs.GraphColoringProblem(nx.</span><strong class="bold1"><span class="kobospan1" id="kobo.877.1">mycielski_graph(5)</span></strong><span class="kobospan1" id="kobo.878.1">, 
    HARD_CONSTRAINT_PENALTY)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.879.1">Using the same parameters as before, including the setting of 10 colors, we get the </span><span><span class="kobospan" id="kobo.880.1">following results:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.881.1">
-- Best Individual = [9, 6, 9, 4, 0, 0, 6, 5, 4, 5, 1, 5, 1, 1, 6, 6, 9, 5, 9, 6, 5, 1, 4]
-- Best Fitness = 6.0
Number of colors = 6
Number of violations = 0
Cost = 6</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.882.1">Since we happen to know that the chromatic number for this graph is 5, this is not the optimal solution, although it’s close. </span><span class="kobospan" id="kobo.882.2">How can we get there? </span><span class="kobospan" id="kobo.882.3">And what if we didn’t know the chromatic number beforehand? </span><span class="kobospan" id="kobo.882.4">One way to go about this is to change the parameters of the genetic algorithm – for example, we could increase the population size (and possibly the HOF size) and/or increase the number of generations. </span><span class="kobospan" id="kobo.882.5">Another approach would be to start the same search again but with a reduced number of colors. </span><span class="kobospan" id="kobo.882.6">Since the algorithm found a solution with six colors, let’s reduce the maximum number of colors to </span><strong class="source-inline"><span class="kobospan" id="kobo.883.1">5</span></strong><span class="kobospan" id="kobo.884.1"> and see if the algorithm can still find a </span><span><span class="kobospan" id="kobo.885.1">valid solution:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.886.1">
MAX_COLORS = 5</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.887.1">Why would the algorithm find a five-color solution now if it didn’t find one in the first place? </span><span class="kobospan" id="kobo.887.2">As we lower the number of colors from 10 to 5, the search space is considerably reduced – in this case, from </span><span><span class="kobospan" id="kobo.888.1">10</span></span><span><span class="kobospan" id="kobo.889.1"> </span></span><span><span class="kobospan" id="kobo.890.1">23</span></span><span class="kobospan" id="kobo.891.1"> to </span><span><span class="kobospan" id="kobo.892.1">5</span></span><span><span class="kobospan" id="kobo.893.1"> </span></span><span><span class="kobospan" id="kobo.894.1">23</span></span><span class="kobospan" id="kobo.895.1"> (since we have 23 nodes in the graph) – and the algorithm has a better chance of finding the optimal solution(s), even with a short run and a limited population size. </span><span class="kobospan" id="kobo.895.2">So, while the first run of the algorithm may get us close to the solution, it </span><a id="_idIndexMarker384" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.896.1">could be good practice to keep decreasing the number of colors until the algorithm can’t find a </span><span><span class="kobospan" id="kobo.897.1">better solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.898.1">In our case, when started with five colors, the algorithm was able to find a five-color solution </span><span><span class="kobospan" id="kobo.899.1">rather easily:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.900.1">
-- Best Individual = [0, 3, 0, 2, 4, 4, 2, 2, 2, 4, 1, 4, 3, 1, 3, 3, 4, 4, 2, 2, 4, 3, 0]
-- Best Fitness = 5.0
Number of colors = 5
Number of violations = 0
Cost = 5</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.901.1">The plot of the colored graph looks </span><span><span class="kobospan" id="kobo.902.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer093">
<span class="kobospan" id="kobo.903.1"><img alt="Figure 5.14: A plot of the Mycielski graph properly colored by the program using five colors" src="image/B20851_05_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.904.1">Figure 5.14: A plot of the Mycielski graph properly colored by the program using five colors</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.905.1">Now, if we attempt to decrease the maximum number of colors to four, we will always get at least </span><a id="_idIndexMarker385" class="calibre6 pcalibre pcalibre1"/><span><span class="kobospan" id="kobo.906.1">one violation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.907.1">You are encouraged to try out other graphs and experiment with the various settings of </span><span><span class="kobospan" id="kobo.908.1">the algorithm.</span></span></p>
<h1 id="_idParaDest-150" class="calibre5"><a id="_idTextAnchor195" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.909.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.910.1">In this chapter, you were introduced to constraint satisfaction problems, which are close relatives of the previously studied combinatorial optimization problems. </span><span class="kobospan" id="kobo.910.2">Then, we explored three classic constraint satisfaction cases – the </span><em class="italic"><span class="kobospan" id="kobo.911.1">N-Queen</span></em><span class="kobospan" id="kobo.912.1"> problem, the </span><em class="italic"><span class="kobospan" id="kobo.913.1">nurse scheduling</span></em><span class="kobospan" id="kobo.914.1"> problem, and the </span><em class="italic"><span class="kobospan" id="kobo.915.1">graph coloring</span></em><span class="kobospan" id="kobo.916.1"> problem. </span><span class="kobospan" id="kobo.916.2">For each of these problems, we followed the now-familiar process of finding an appropriate representation for a solution, creating a class that encapsulates the problem and evaluates a given solution, and creating a genetic algorithm solution that utilizes that class. </span><span class="kobospan" id="kobo.916.3">We ended up with valid solutions for the problems while getting acquainted with the concept of </span><strong class="bold"><span class="kobospan" id="kobo.917.1">hard constraints</span></strong><span class="kobospan" id="kobo.918.1"> versus </span><span><strong class="bold"><span class="kobospan" id="kobo.919.1">soft constraints</span></strong></span><span><span class="kobospan" id="kobo.920.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.921.1">So far, we have been looking into discrete search problems consisting of states and state transitions. </span><span class="kobospan" id="kobo.921.2">In the next chapter, we will study search problems in a continuous space, to demonstrate the versatility of the genetic </span><span><span class="kobospan" id="kobo.922.1">algorithms approach.</span></span></p>
<h1 id="_idParaDest-151" class="calibre5"><a id="_idTextAnchor196" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.923.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.924.1">For more information on the topics that were covered in this chapter, please refer to the </span><span><span class="kobospan" id="kobo.925.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.926.1">Constraint Satisfaction Problems</span></em><span class="kobospan" id="kobo.927.1">, from the book </span><em class="italic"><span class="kobospan" id="kobo.928.1">Artificial Intelligence with Python</span></em><span class="kobospan" id="kobo.929.1">, by Prateek Joshi, </span><span><span class="kobospan" id="kobo.930.1">January 2017</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.931.1">Introduction to graph theory</span></em><span class="kobospan" id="kobo.932.1">, from the book </span><em class="italic"><span class="kobospan" id="kobo.933.1">Python Data Science Essentials – Second Edition</span></em><span class="kobospan" id="kobo.934.1">, by Alberto Boschetti, Luca Massaron, </span><span><span class="kobospan" id="kobo.935.1">October 2016</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.936.1">NetworkX </span><span><span class="kobospan" id="kobo.937.1">tutorial: </span></span><a href="https://networkx.github.io/documentation/stable/tutorial.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.938.1">https://networkx.github.io/documentation/stable/tutorial.html</span></span></a></li>
</ul>
</div>
</body></html>