<html><head></head><body>
<div id="_idContainer107" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-152"><a id="_idTextAnchor197" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-153" class="calibre5"><a id="_idTextAnchor198" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Optimizing Continuous Functions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">This chapter describes how </span><strong class="bold"><span class="kobospan" id="kobo.4.1">continuous search-space</span></strong><span class="kobospan" id="kobo.5.1"> optimization problems can be solved by </span><a id="_idIndexMarker386" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.6.1">genetic algorithms. </span><span class="kobospan" id="kobo.6.2">We will start by describing the chromosomes and genetic operators commonly used for genetic algorithms </span><a id="_idIndexMarker387" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.7.1">with real number-based populations and go over the tools offered by the </span><strong class="bold"><span class="kobospan" id="kobo.8.1">Distributed Evolutionary Algorithms in Python</span></strong><span class="kobospan" id="kobo.9.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.10.1">DEAP</span></strong><span class="kobospan" id="kobo.11.1">) framework for this domain. </span><span class="kobospan" id="kobo.11.2">We will then cover several hands-on examples of continuous function optimization problems and their Python-based solutions using the DEAP framework. </span><span class="kobospan" id="kobo.11.3">These include the optimization of the </span><em class="italic"><span class="kobospan" id="kobo.12.1">Eggholder function</span></em><span class="kobospan" id="kobo.13.1">, </span><em class="italic"><span class="kobospan" id="kobo.14.1">Himmelblau’s function</span></em><span class="kobospan" id="kobo.15.1">, as well as the constrained </span><a id="_idIndexMarker388" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.16.1">optimization of </span><em class="italic"><span class="kobospan" id="kobo.17.1">Simionescu’s function</span></em><span class="kobospan" id="kobo.18.1">. </span><span class="kobospan" id="kobo.18.2">Along the way, we will learn </span><a id="_idIndexMarker389" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.19.1">about finding </span><a id="_idIndexMarker390" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.20.1">multiple solutions using </span><strong class="bold"><span class="kobospan" id="kobo.21.1">niching</span></strong><span class="kobospan" id="kobo.22.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.23.1">sharing</span></strong><span class="kobospan" id="kobo.24.1"> and </span><span><span class="kobospan" id="kobo.25.1">handling </span></span><span><strong class="bold"><span class="kobospan" id="kobo.26.1">constraints</span></strong></span><span><span class="kobospan" id="kobo.27.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">By the end of this chapter, you will be able to do </span><span><span class="kobospan" id="kobo.29.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.30.1">Understand chromosomes and genetic operators used for </span><span><span class="kobospan" id="kobo.31.1">real numbers</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.32.1">Use DEAP to optimize </span><span><span class="kobospan" id="kobo.33.1">continuous functions</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.34.1">Optimize the </span><span><span class="kobospan" id="kobo.35.1">Eggholder function</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.36.1">Optimize </span><span><span class="kobospan" id="kobo.37.1">Himmelblau’s function</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.38.1">Perform constrained optimization with </span><span><span class="kobospan" id="kobo.39.1">Simionescu’s function</span></span></li>
</ul>
<h1 id="_idParaDest-154" class="calibre5"><a id="_idTextAnchor199" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.40.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">In this chapter, we will be using Python 3 with the following </span><span><span class="kobospan" id="kobo.42.1">supporting libraries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.43.1">deap</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.44.1">numpy</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.45.1">matplotlib</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.46.1">seaborn</span></strong></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.47.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.48.1">If you use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.49.1">requirements.txt</span></strong><span class="kobospan" id="kobo.50.1"> file we provide (see </span><a href="B20851_03.xhtml#_idTextAnchor091" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.51.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.52.1">), these libraries are already included in </span><span><span class="kobospan" id="kobo.53.1">your environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">The programs used in this chapter can be found in the book’s GitHub repository at the </span><span><span class="kobospan" id="kobo.55.1">following link:</span></span></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_06" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.56.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_06</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.57.1">Check out the following video to see the code in action: </span></p>
<p class="calibre3"><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.58.1">https://packt.link/OEBOd</span></span></a></p>
<h1 id="_idParaDest-155" class="calibre5"><a id="_idTextAnchor200" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.59.1">Chromosomes and genetic operators for real numbers</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.60.1">In previous chapters, we focused on search problems that inherently deal with the methodic evaluation </span><a id="_idIndexMarker391" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.61.1">of states and transitions between states. </span><span class="kobospan" id="kobo.61.2">Consequently, the solutions for these problems were best represented by lists (or arrays) of binary or integer parameters. </span><span class="kobospan" id="kobo.61.3">In contrast to that, this chapter covers problems where the solution space is </span><strong class="bold"><span class="kobospan" id="kobo.62.1">continuous</span></strong><span class="kobospan" id="kobo.63.1">, meaning the solutions are made up of real (floating-point) numbers. </span><span class="kobospan" id="kobo.63.2">As we mentioned in </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.64.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.65.1">, </span><em class="italic"><span class="kobospan" id="kobo.66.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.67.1">, representing real numbers using binary or integer lists was found to be far from ideal and, instead, lists (or arrays) of real-valued numbers are now considered to be a simpler and </span><span><span class="kobospan" id="kobo.68.1">better approach.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.69.1">Reiterating the example from </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.70.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.71.1">, if we have a problem involving three real-valued parameters, the chromosome will look like </span><span><span class="kobospan" id="kobo.72.1">the following:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.73.1">[</span></span><span><span class="kobospan" id="kobo.74.1">x</span></span><span><span class="kobospan" id="kobo.75.1"> </span></span><span><span class="kobospan" id="kobo.76.1">1</span></span><span><span class="kobospan" id="kobo.77.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.78.1">x</span></span><span><span class="kobospan" id="kobo.79.1"> </span></span><span><span class="kobospan" id="kobo.80.1">2</span></span><span><span class="kobospan" id="kobo.81.1">,</span></span><span> </span><span><span><span class="kobospan" id="kobo.82.1">x</span></span></span><span><span><span class="kobospan" id="kobo.83.1"> </span></span></span><span><span><span class="kobospan" id="kobo.84.1">3</span></span></span><span><span><span class="kobospan" id="kobo.85.1">]</span></span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.86.1">Here, </span><span><span class="kobospan" id="kobo.87.1">x</span></span><span><span class="kobospan" id="kobo.88.1"> </span></span><span><span class="kobospan" id="kobo.89.1">1</span></span><span><span class="kobospan" id="kobo.90.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.91.1">x</span></span><span><span class="kobospan" id="kobo.92.1"> </span></span><span><span class="kobospan" id="kobo.93.1">2</span></span><span><span class="kobospan" id="kobo.94.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.95.1">x</span></span><span><span class="kobospan" id="kobo.96.1"> </span></span><span><span class="kobospan" id="kobo.97.1">3</span></span><span class="kobospan" id="kobo.98.1"> represent real numbers, such as </span><span><span class="kobospan" id="kobo.99.1">the following:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.100.1">[1.23, 7.2134, -25.309] or  [-30.10, </span><span><span class="kobospan" id="kobo.101.1">100.2, 42.424]</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">In addition, we mentioned that while the various </span><em class="italic"><span class="kobospan" id="kobo.103.1">selection</span></em><span class="kobospan" id="kobo.104.1"> methods work the same for either integer-based or real-based chromosomes, specialized </span><em class="italic"><span class="kobospan" id="kobo.105.1">crossover</span></em><span class="kobospan" id="kobo.106.1"> and </span><em class="italic"><span class="kobospan" id="kobo.107.1">mutation</span></em><span class="kobospan" id="kobo.108.1"> methods are needed for the real-coded chromosomes. </span><span class="kobospan" id="kobo.108.2">These operators are usually applied on a dimension-by-dimension basis, illustrated </span><span><span class="kobospan" id="kobo.109.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">Suppose we have </span><a id="_idIndexMarker392" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.111.1">two parent chromosomes:  </span><span><span class="kobospan" id="kobo.112.1">p</span></span><span><span class="kobospan" id="kobo.113.1">a</span></span><span><span class="kobospan" id="kobo.114.1">r</span></span><span><span class="kobospan" id="kobo.115.1">e</span></span><span><span class="kobospan" id="kobo.116.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.117.1">t</span></span><span><span class="kobospan" id="kobo.118.1"> </span></span><span><span class="kobospan" id="kobo.119.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.120.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.121.1">[</span></span><span><span class="kobospan" id="kobo.122.1">x</span></span><span><span class="kobospan" id="kobo.123.1"> </span></span><span><span class="kobospan" id="kobo.124.1">1</span></span><span><span class="kobospan" id="kobo.125.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.126.1">x</span></span><span><span class="kobospan" id="kobo.127.1"> </span></span><span><span class="kobospan" id="kobo.128.1">2</span></span><span><span class="kobospan" id="kobo.129.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.130.1">x</span></span><span><span class="kobospan" id="kobo.131.1"> </span></span><span><span class="kobospan" id="kobo.132.1">3</span></span><span><span class="kobospan" id="kobo.133.1">]</span></span><span class="kobospan" id="kobo.134.1"> and </span><span><span class="kobospan" id="kobo.135.1">p</span></span><span><span class="kobospan" id="kobo.136.1">a</span></span><span><span class="kobospan" id="kobo.137.1">r</span></span><span><span class="kobospan" id="kobo.138.1">e</span></span><span><span class="kobospan" id="kobo.139.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.140.1">t</span></span><span><span class="kobospan" id="kobo.141.1"> </span></span><span><span class="kobospan" id="kobo.142.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.143.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.144.1">[</span></span><span><span class="kobospan" id="kobo.145.1">y</span></span><span><span class="kobospan" id="kobo.146.1"> </span></span><span><span class="kobospan" id="kobo.147.1">1</span></span><span><span class="kobospan" id="kobo.148.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.149.1">y</span></span><span><span class="kobospan" id="kobo.150.1"> </span></span><span><span class="kobospan" id="kobo.151.1">2</span></span><span><span class="kobospan" id="kobo.152.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.153.1">y</span></span><span><span class="kobospan" id="kobo.154.1"> </span></span><span><span class="kobospan" id="kobo.155.1">3</span></span><span><span class="kobospan" id="kobo.156.1">]</span></span><span class="kobospan" id="kobo.157.1">. </span><span class="kobospan" id="kobo.157.2">As the crossover operation is applied separately to each dimension, an offspring </span><span><span class="kobospan" id="kobo.158.1">[</span></span><span><span class="kobospan" id="kobo.159.1">o</span></span><span><span class="kobospan" id="kobo.160.1"> </span></span><span><span class="kobospan" id="kobo.161.1">1</span></span><span><span class="kobospan" id="kobo.162.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.163.1">o</span></span><span><span class="kobospan" id="kobo.164.1"> </span></span><span><span class="kobospan" id="kobo.165.1">2</span></span><span><span class="kobospan" id="kobo.166.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.167.1">o</span></span><span><span class="kobospan" id="kobo.168.1"> </span></span><span><span class="kobospan" id="kobo.169.1">3</span></span><span><span class="kobospan" id="kobo.170.1">]</span></span><span class="kobospan" id="kobo.171.1"> will be created, </span><span><span class="kobospan" id="kobo.172.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><span class="kobospan" id="kobo.173.1">o</span></span><span><span class="kobospan" id="kobo.174.1"> </span></span><span><span class="kobospan" id="kobo.175.1">1</span></span><span class="kobospan" id="kobo.176.1"> is the result of a crossover operator between </span><span><span class="kobospan" id="kobo.177.1">x</span></span><span><span class="kobospan" id="kobo.178.1"> </span></span><span><span class="kobospan" id="kobo.179.1">1</span></span><span class="kobospan" id="kobo.180.1"> and </span><span><span><span class="kobospan" id="kobo.181.1">y</span></span></span><span><span><span class="kobospan" id="kobo.182.1"> </span></span></span><span><span><span class="kobospan" id="kobo.183.1">1</span></span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.184.1">o</span></span><span><span class="kobospan" id="kobo.185.1"> </span></span><span><span class="kobospan" id="kobo.186.1">2</span></span><span class="kobospan" id="kobo.187.1"> is the result of a crossover operator between </span><span><span class="kobospan" id="kobo.188.1">x</span></span><span><span class="kobospan" id="kobo.189.1"> </span></span><span><span class="kobospan" id="kobo.190.1">2</span></span><span class="kobospan" id="kobo.191.1"> and </span><span><span><span class="kobospan" id="kobo.192.1">y</span></span></span><span><span><span class="kobospan" id="kobo.193.1"> </span></span></span><span><span><span class="kobospan" id="kobo.194.1">2</span></span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.195.1">o</span></span><span><span class="kobospan" id="kobo.196.1"> </span></span><span><span class="kobospan" id="kobo.197.1">3</span></span><span class="kobospan" id="kobo.198.1"> is the result of a crossover operator between </span><span><span class="kobospan" id="kobo.199.1">x</span></span><span><span class="kobospan" id="kobo.200.1"> </span></span><span><span class="kobospan" id="kobo.201.1">3</span></span><span class="kobospan" id="kobo.202.1"> and </span><span><span><span class="kobospan" id="kobo.203.1">y</span></span></span><span><span><span class="kobospan" id="kobo.204.1"> </span></span></span><span><span><span class="kobospan" id="kobo.205.1">3</span></span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">Similarly, the </span><em class="italic"><span class="kobospan" id="kobo.207.1">mutation</span></em><span class="kobospan" id="kobo.208.1"> operator will be individually applied to each dimension so that each of the components </span><span><span class="kobospan" id="kobo.209.1">o</span></span><span><span class="kobospan" id="kobo.210.1"> </span></span><span><span class="kobospan" id="kobo.211.1">1</span></span><span class="kobospan" id="kobo.212.1">, </span><span><span class="kobospan" id="kobo.213.1">o</span></span><span><span class="kobospan" id="kobo.214.1"> </span></span><span><span class="kobospan" id="kobo.215.1">2</span></span><span class="kobospan" id="kobo.216.1">, and </span><span><span class="kobospan" id="kobo.217.1">o</span></span><span><span class="kobospan" id="kobo.218.1"> </span></span><span><span class="kobospan" id="kobo.219.1">3</span></span><span class="kobospan" id="kobo.220.1"> can be subject </span><span><span class="kobospan" id="kobo.221.1">to mutation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.222.1">Some commonly used real-coded operators are </span><span><span class="kobospan" id="kobo.223.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.224.1">Blend Crossover</span></strong><span class="kobospan" id="kobo.225.1"> (also known as </span><strong class="bold"><span class="kobospan" id="kobo.226.1">BLX</span></strong><span class="kobospan" id="kobo.227.1">), where each offspring is randomly selected </span><a id="_idIndexMarker393" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.228.1">from the following interval created by </span><span><span class="kobospan" id="kobo.229.1">its parents:</span></span><p class="calibre3"><span><span class="kobospan" id="kobo.230.1">[</span></span><span><span class="kobospan" id="kobo.231.1">p</span></span><span><span class="kobospan" id="kobo.232.1">a</span></span><span><span class="kobospan" id="kobo.233.1">r</span></span><span><span class="kobospan" id="kobo.234.1">e</span></span><span><span class="kobospan" id="kobo.235.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.236.1">t</span></span><span><span class="kobospan" id="kobo.237.1"> </span></span><span><span class="kobospan" id="kobo.238.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.239.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.240.1">α</span></span><span><span class="kobospan" id="kobo.241.1">(</span></span><span><span class="kobospan" id="kobo.242.1">p</span></span><span><span class="kobospan" id="kobo.243.1">a</span></span><span><span class="kobospan" id="kobo.244.1">r</span></span><span><span class="kobospan" id="kobo.245.1">e</span></span><span><span class="kobospan" id="kobo.246.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.247.1">t</span></span><span><span class="kobospan" id="kobo.248.1"> </span></span><span><span class="kobospan" id="kobo.249.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.250.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.251.1">p</span></span><span><span class="kobospan" id="kobo.252.1">a</span></span><span><span class="kobospan" id="kobo.253.1">r</span></span><span><span class="kobospan" id="kobo.254.1">e</span></span><span><span class="kobospan" id="kobo.255.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.256.1">t</span></span><span><span class="kobospan" id="kobo.257.1"> </span></span><span><span class="kobospan" id="kobo.258.1">x</span></span><span><span class="kobospan" id="kobo.259.1">)</span></span><span><span class="kobospan" id="kobo.260.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.261.1">p</span></span><span><span class="kobospan" id="kobo.262.1">a</span></span><span><span class="kobospan" id="kobo.263.1">r</span></span><span><span class="kobospan" id="kobo.264.1">e</span></span><span><span class="kobospan" id="kobo.265.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.266.1">t</span></span><span><span class="kobospan" id="kobo.267.1"> </span></span><span><span class="kobospan" id="kobo.268.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.269.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.270.1">α</span></span><span><span class="kobospan" id="kobo.271.1">(</span></span><span><span class="kobospan" id="kobo.272.1">p</span></span><span><span class="kobospan" id="kobo.273.1">a</span></span><span><span class="kobospan" id="kobo.274.1">r</span></span><span><span class="kobospan" id="kobo.275.1">e</span></span><span><span class="kobospan" id="kobo.276.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.277.1">t</span></span><span><span class="kobospan" id="kobo.278.1"> </span></span><span><span class="kobospan" id="kobo.279.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.280.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.281.1">p</span></span><span><span class="kobospan" id="kobo.282.1">a</span></span><span><span class="kobospan" id="kobo.283.1">r</span></span><span><span class="kobospan" id="kobo.284.1">e</span></span><span><span class="kobospan" id="kobo.285.1">n</span></span><span> </span><span><span><span class="kobospan" id="kobo.286.1">t</span></span></span><span><span><span class="kobospan" id="kobo.287.1"> </span></span></span><span><span><span class="kobospan" id="kobo.288.1">x</span></span></span><span><span><span class="kobospan" id="kobo.289.1">)</span></span></span><span><span><span class="kobospan" id="kobo.290.1">]</span></span></span></p><p class="calibre3"><span class="kobospan" id="kobo.291.1">The α value is commonly set to 0.5, resulting in a selection interval twice as wide as the interval between </span><span><span class="kobospan" id="kobo.292.1">the parents.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.293.1">Simulated Binary Crossover</span></strong><span class="kobospan" id="kobo.294.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.295.1">SBX</span></strong><span class="kobospan" id="kobo.296.1">), where two offspring are created from two </span><a id="_idIndexMarker394" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.297.1">parents using the following formula, guaranteeing that the average of the offspring values is equal to that of the </span><span><span class="kobospan" id="kobo.298.1">parents’ values:</span></span><p class="calibre3"><span><span class="kobospan" id="kobo.299.1">o</span></span><span><span class="kobospan" id="kobo.300.1">f</span></span><span><span class="kobospan" id="kobo.301.1">f</span></span><span><span class="kobospan" id="kobo.302.1">s</span></span><span><span class="kobospan" id="kobo.303.1">p</span></span><span><span class="kobospan" id="kobo.304.1">r</span></span><span><span class="kobospan" id="kobo.305.1">i</span></span><span><span class="kobospan" id="kobo.306.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.307.1">g</span></span><span><span class="kobospan" id="kobo.308.1"> </span></span><span><span class="kobospan" id="kobo.309.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.310.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.311.1"> </span></span><span><span class="kobospan" id="kobo.312.1">1</span></span><span><span class="kobospan" id="kobo.313.1"> </span></span><span><span class="kobospan" id="kobo.314.1">_</span></span><span><span class="kobospan" id="kobo.315.1"> </span></span><span><span class="kobospan" id="kobo.316.1">2</span></span><span><span class="kobospan" id="kobo.317.1"> </span></span><span><span class="kobospan" id="kobo.318.1">[</span></span><span><span class="kobospan" id="kobo.319.1">(</span></span><span><span class="kobospan" id="kobo.320.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.321.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.322.1">β</span></span><span><span class="kobospan" id="kobo.323.1">)</span></span><span><span class="kobospan" id="kobo.324.1">p</span></span><span><span class="kobospan" id="kobo.325.1">a</span></span><span><span class="kobospan" id="kobo.326.1">r</span></span><span><span class="kobospan" id="kobo.327.1">e</span></span><span><span class="kobospan" id="kobo.328.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.329.1">t</span></span><span><span class="kobospan" id="kobo.330.1"> </span></span><span><span class="kobospan" id="kobo.331.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.332.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.333.1">(</span></span><span><span class="kobospan" id="kobo.334.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.335.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.336.1">β</span></span><span><span class="kobospan" id="kobo.337.1">)</span></span><span><span class="kobospan" id="kobo.338.1">p</span></span><span><span class="kobospan" id="kobo.339.1">a</span></span><span><span class="kobospan" id="kobo.340.1">r</span></span><span><span class="kobospan" id="kobo.341.1">e</span></span><span><span class="kobospan" id="kobo.342.1">n</span></span><span> </span><span><span><span class="kobospan" id="kobo.343.1">t</span></span></span><span><span><span class="kobospan" id="kobo.344.1"> </span></span></span><span><span><span class="kobospan" id="kobo.345.1">y</span></span></span><span><span><span class="kobospan" id="kobo.346.1">]</span></span></span></p><p class="calibre3"><span><span class="kobospan" id="kobo.347.1">o</span></span><span><span class="kobospan" id="kobo.348.1">f</span></span><span><span class="kobospan" id="kobo.349.1">f</span></span><span><span class="kobospan" id="kobo.350.1">s</span></span><span><span class="kobospan" id="kobo.351.1">p</span></span><span><span class="kobospan" id="kobo.352.1">r</span></span><span><span class="kobospan" id="kobo.353.1">i</span></span><span><span class="kobospan" id="kobo.354.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.355.1">g</span></span><span><span class="kobospan" id="kobo.356.1"> </span></span><span><span class="kobospan" id="kobo.357.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.358.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.359.1"> </span></span><span><span class="kobospan" id="kobo.360.1">1</span></span><span><span class="kobospan" id="kobo.361.1"> </span></span><span><span class="kobospan" id="kobo.362.1">_</span></span><span><span class="kobospan" id="kobo.363.1"> </span></span><span><span class="kobospan" id="kobo.364.1">2</span></span><span><span class="kobospan" id="kobo.365.1"> </span></span><span><span class="kobospan" id="kobo.366.1">[</span></span><span><span class="kobospan" id="kobo.367.1">(</span></span><span><span class="kobospan" id="kobo.368.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.369.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.370.1">β</span></span><span><span class="kobospan" id="kobo.371.1">)</span></span><span><span class="kobospan" id="kobo.372.1">p</span></span><span><span class="kobospan" id="kobo.373.1">a</span></span><span><span class="kobospan" id="kobo.374.1">r</span></span><span><span class="kobospan" id="kobo.375.1">e</span></span><span><span class="kobospan" id="kobo.376.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.377.1">t</span></span><span><span class="kobospan" id="kobo.378.1"> </span></span><span><span class="kobospan" id="kobo.379.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.380.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.381.1">(</span></span><span><span class="kobospan" id="kobo.382.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.383.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.384.1">β</span></span><span><span class="kobospan" id="kobo.385.1">)</span></span><span><span class="kobospan" id="kobo.386.1">p</span></span><span><span class="kobospan" id="kobo.387.1">a</span></span><span><span class="kobospan" id="kobo.388.1">r</span></span><span><span class="kobospan" id="kobo.389.1">e</span></span><span><span class="kobospan" id="kobo.390.1">n</span></span><span> </span><span><span><span class="kobospan" id="kobo.391.1">t</span></span></span><span><span><span class="kobospan" id="kobo.392.1"> </span></span></span><span><span><span class="kobospan" id="kobo.393.1">y</span></span></span><span><span><span class="kobospan" id="kobo.394.1">]</span></span></span></p><p class="calibre3"><span class="kobospan" id="kobo.395.1">The value of β, also known as the </span><em class="italic"><span class="kobospan" id="kobo.396.1">spread factor</span></em><span class="kobospan" id="kobo.397.1">, is calculated using a combination of a randomly chosen value and a pre-determined parameter known as η (eta), </span><em class="italic"><span class="kobospan" id="kobo.398.1">distribution index</span></em><span class="kobospan" id="kobo.399.1">, or </span><em class="italic"><span class="kobospan" id="kobo.400.1">crowding factor</span></em><span class="kobospan" id="kobo.401.1">. </span><span class="kobospan" id="kobo.401.2">With larger values of η, offspring will tend to be more similar to their parents. </span><span class="kobospan" id="kobo.401.3">Common values of η are between 10 </span><span><span class="kobospan" id="kobo.402.1">and 20.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.403.1">Normally distributed</span></strong><span class="kobospan" id="kobo.404.1"> (or </span><strong class="bold"><span class="kobospan" id="kobo.405.1">Gaussian</span></strong><span class="kobospan" id="kobo.406.1">) </span><strong class="bold"><span class="kobospan" id="kobo.407.1">mutation</span></strong><span class="kobospan" id="kobo.408.1">, where the original value is replaced </span><a id="_idIndexMarker395" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.409.1">with a random number that is generated using a normal distribution, with predetermined values for mean and </span><span><span class="kobospan" id="kobo.410.1">standard deviation.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.411.1">In the next section, we will see how real-coded chromosomes and genetic operators are supported by the </span><span><span class="kobospan" id="kobo.412.1">DEAP framework.</span></span></p>
<h1 id="_idParaDest-156" class="calibre5"><a id="_idTextAnchor201" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.413.1">Using DEAP with continuous functions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.414.1">The DEAP framework can be used for optimizing continuous functions in a very similar manner </span><a id="_idIndexMarker396" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.415.1">to what we have seen so far, when we solved discrete search problems. </span><span class="kobospan" id="kobo.415.2">All that’s needed are a few </span><span><span class="kobospan" id="kobo.416.1">subtle modifications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.417.1">For the chromosome encoding, we can use a list (or array) of floating-point numbers. </span><span class="kobospan" id="kobo.417.2">One thing to keep in mind, though, is that the existing genetic operators of DEAP will </span><strong class="bold"><span class="kobospan" id="kobo.418.1">not</span></strong><span class="kobospan" id="kobo.419.1"> work well with individual objects extending the </span><strong class="source-inline"><span class="kobospan" id="kobo.420.1">numpy.ndarray</span></strong><span class="kobospan" id="kobo.421.1"> class due to the way these objects are being sliced, as well as the way they are being compared to </span><span><span class="kobospan" id="kobo.422.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.423.1">Using </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">numpy.ndarray</span></strong><span class="kobospan" id="kobo.425.1">-based individuals will require redefining the genetic operators accordingly. </span><span class="kobospan" id="kobo.425.2">This is further covered in the DEAP documentation, under </span><em class="italic"><span class="kobospan" id="kobo.426.1">Inheriting from NumPy</span></em><span class="kobospan" id="kobo.427.1">. </span><span class="kobospan" id="kobo.427.2">For this reason, as well as for performance reasons, </span><strong class="bold"><span class="kobospan" id="kobo.428.1">ordinary</span></strong><span class="kobospan" id="kobo.429.1"> Python lists or arrays of floating-point numbers are generally </span><strong class="bold"><span class="kobospan" id="kobo.430.1">preferred</span></strong><span class="kobospan" id="kobo.431.1"> when </span><span><span class="kobospan" id="kobo.432.1">using DEAP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.433.1">As for real-coded genetic operators, the DEAP framework offers several implementations out of the box, contained in the crossover and the </span><span><span class="kobospan" id="kobo.434.1">mutation modules:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.435.1">cxBlend()</span></strong><span class="kobospan" id="kobo.436.1"> is DEAP’s implementation of </span><em class="italic"><span class="kobospan" id="kobo.437.1">Blend Crossover</span></em><span class="kobospan" id="kobo.438.1">, using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.439.1">alpha</span></strong><span class="kobospan" id="kobo.440.1"> argument as the </span><span><span class="kobospan" id="kobo.441.1">α value</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.442.1">cxSimulatedBinary()</span></strong><span class="kobospan" id="kobo.443.1"> implements </span><em class="italic"><span class="kobospan" id="kobo.444.1">Simulated Binary Crossover</span></em><span class="kobospan" id="kobo.445.1">, using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.446.1">eta</span></strong><span class="kobospan" id="kobo.447.1"> argument as the η (crowding </span><span><span class="kobospan" id="kobo.448.1">factor) value</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">mutGaussian()</span></strong><span class="kobospan" id="kobo.450.1"> implements </span><em class="italic"><span class="kobospan" id="kobo.451.1">normally distributed mutation</span></em><span class="kobospan" id="kobo.452.1">, using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.453.1">mu</span></strong><span class="kobospan" id="kobo.454.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.455.1">sigma</span></strong><span class="kobospan" id="kobo.456.1"> arguments as the values for the mean and standard </span><span><span class="kobospan" id="kobo.457.1">deviation, respectively</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.458.1">In </span><a id="_idIndexMarker397" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.459.1">addition, since the optimization of continuous functions is typically done on a particular </span><strong class="bold"><span class="kobospan" id="kobo.460.1">bounded region</span></strong><span class="kobospan" id="kobo.461.1"> rather than on the entire space, DEAP provides a couple of operators that accept boundary parameters and guarantee that the resulting individuals will reside within </span><span><span class="kobospan" id="kobo.462.1">these boundaries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">cxSimulatedBinaryBounded()</span></strong><span class="kobospan" id="kobo.464.1"> is a bounded version of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.465.1">cxSimulatedBinary()</span></strong><span class="kobospan" id="kobo.466.1"> operator, accepting the </span><strong class="source-inline1"><span class="kobospan" id="kobo.467.1">low</span></strong><span class="kobospan" id="kobo.468.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.469.1">up</span></strong><span class="kobospan" id="kobo.470.1"> arguments as the lower and upper boundaries of the search </span><span><span class="kobospan" id="kobo.471.1">space, respectively.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.472.1">mutPolynomialBounded()</span></strong><span class="kobospan" id="kobo.473.1"> is a bounded </span><em class="italic"><span class="kobospan" id="kobo.474.1">mutation</span></em><span class="kobospan" id="kobo.475.1"> operator that uses a polynomial function (instead of Gaussian) for the probability distribution. </span><span class="kobospan" id="kobo.475.2">This operator also accepts the </span><strong class="source-inline1"><span class="kobospan" id="kobo.476.1">low</span></strong><span class="kobospan" id="kobo.477.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">up</span></strong><span class="kobospan" id="kobo.479.1"> arguments as the lower and upper boundaries of the search space. </span><span class="kobospan" id="kobo.479.2">In addition, it uses the </span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">eta</span></strong><span class="kobospan" id="kobo.481.1"> parameter as a crowding factor, where a high value will yield a mutant close to its original value, while a small value will produce a mutant very different from its </span><span><span class="kobospan" id="kobo.482.1">original value.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.483.1">In the next section, we will demonstrate the usage of bounded operators when optimizing a classic </span><span><span class="kobospan" id="kobo.484.1">benchmark function.</span></span></p>
<h1 id="_idParaDest-157" class="calibre5"><a id="_idTextAnchor202" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.485.1">Optimizing the Eggholder function</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.486.1">The Eggholder </span><a id="_idIndexMarker398" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.487.1">function, depicted in the following diagram, is often used as a benchmark for function optimization algorithms. </span><span class="kobospan" id="kobo.487.2">Finding the single </span><strong class="bold"><span class="kobospan" id="kobo.488.1">global minimum</span></strong><span class="kobospan" id="kobo.489.1"> of this function is considered a difficult task due to the large number of local minima, which give it the </span><span><span class="kobospan" id="kobo.490.1">eggholder shape:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer095">
<span class="kobospan" id="kobo.491.1"><img alt="Figure 6.1: The Eggholder function " src="image/B20851_06_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.492.1">Figure 6.1: The Eggholder function </span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.493.1">Source: </span><a href="https://en.wikipedia.org/wiki/File:Eggholder_function.pdf" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.494.1">https://en.wikipedia.org/wiki/File:Eggholder_function.pdf</span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">The function can be mathematically expressed </span><span><span class="kobospan" id="kobo.496.1">as follows:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.497.1">f</span></span><span><span class="kobospan" id="kobo.498.1">(</span></span><span><span class="kobospan" id="kobo.499.1">x</span></span><span><span class="kobospan" id="kobo.500.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.501.1">y</span></span><span><span class="kobospan" id="kobo.502.1">)</span></span><span> </span><span><span class="kobospan" id="kobo.503.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.504.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.505.1">(</span></span><span><span class="kobospan" id="kobo.506.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.507.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.508.1">47</span></span><span><span class="kobospan" id="kobo.509.1">)</span></span><span> </span><span><span class="kobospan" id="kobo.510.1">⋅</span></span><span> </span><span><span class="kobospan" id="kobo.511.1">s</span></span><span><span class="kobospan" id="kobo.512.1">i</span></span><span><span class="kobospan" id="kobo.513.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.514.1">√</span></span><span><span class="kobospan" id="kobo.515.1"> </span></span><span><span class="kobospan" id="kobo.516.1">_</span></span><span><span class="kobospan" id="kobo.517.1">__________</span></span><span><span class="kobospan" id="kobo.518.1"> </span></span><span><span class="kobospan" id="kobo.519.1">|</span></span><span><span class="kobospan" id="kobo.520.1"> </span></span><span><span class="kobospan" id="kobo.521.1">x</span></span><span><span class="kobospan" id="kobo.522.1"> </span></span><span><span class="kobospan" id="kobo.523.1">_</span></span><span><span class="kobospan" id="kobo.524.1"> </span></span><span><span class="kobospan" id="kobo.525.1">2</span></span><span><span class="kobospan" id="kobo.526.1"> </span></span><span> </span><span><span class="kobospan" id="kobo.527.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.528.1">(</span></span><span><span class="kobospan" id="kobo.529.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.530.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.531.1">47</span></span><span><span class="kobospan" id="kobo.532.1">)</span></span><span><span class="kobospan" id="kobo.533.1">|</span></span><span><span class="kobospan" id="kobo.534.1"> </span></span><span> </span><span><span class="kobospan" id="kobo.535.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.536.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.537.1">⋅</span></span><span> </span><span><span class="kobospan" id="kobo.538.1">s</span></span><span><span class="kobospan" id="kobo.539.1">i</span></span><span><span class="kobospan" id="kobo.540.1">n</span></span><span> </span><span><span class="kobospan" id="kobo.541.1">√</span></span><span><span class="kobospan" id="kobo.542.1"> </span></span><span><span class="kobospan" id="kobo.543.1">_</span></span><span><span class="kobospan" id="kobo.544.1">__________</span></span><span><span class="kobospan" id="kobo.545.1"> </span></span><span><span class="kobospan" id="kobo.546.1">|</span></span><span><span class="kobospan" id="kobo.547.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.548.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.549.1">(</span></span><span><span class="kobospan" id="kobo.550.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.551.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.552.1">47</span></span><span><span class="kobospan" id="kobo.553.1">)</span></span><span><span class="kobospan" id="kobo.554.1">|</span></span><span><span class="kobospan" id="kobo.555.1"> </span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.556.1">It is usually </span><a id="_idIndexMarker399" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.557.1">evaluated on the search space bounded by [-512, 512] in each dimension. </span><span class="kobospan" id="kobo.557.2">The global minimum of the function is known to be at </span><em class="italic"><span class="kobospan" id="kobo.558.1">x=512, y = 404.2319</span></em><span class="kobospan" id="kobo.559.1">, where the function’s value </span><span><span class="kobospan" id="kobo.560.1">is </span></span><span><em class="italic"><span class="kobospan" id="kobo.561.1">-959.6407</span></em></span><span><span class="kobospan" id="kobo.562.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.563.1">In the next subsection, we will attempt to find the global minimum using the genetic </span><span><span class="kobospan" id="kobo.564.1">algorithms method.</span></span></p>
<h2 id="_idParaDest-158" class="calibre7"><a id="_idTextAnchor203" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.565.1">Optimizing the Eggholder function with genetic algorithms</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.566.1">The </span><a id="_idIndexMarker400" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.567.1">genetic algorithm-based </span><a id="_idIndexMarker401" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.568.1">program we created for optimizing the Eggholder function resides in the </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">01_optimize_eggholder.py</span></strong><span class="kobospan" id="kobo.570.1"> Python program located at the </span><span><span class="kobospan" id="kobo.571.1">following link:</span></span></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/01_optimize_eggholder.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.572.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/01_optimize_eggholder.py</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.573.1">The following steps highlight the main parts of </span><span><span class="kobospan" id="kobo.574.1">this program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.575.1">The </span><a id="_idIndexMarker402" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.576.1">program starts </span><a id="_idIndexMarker403" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.577.1">by setting the function constants, namely the number of input dimensions (2, as this function is defined over the </span><em class="italic"><span class="kobospan" id="kobo.578.1">x</span></em><span class="kobospan" id="kobo.579.1">-</span><em class="italic"><span class="kobospan" id="kobo.580.1">y</span></em><span class="kobospan" id="kobo.581.1"> plane), and the search space boundaries that were </span><span><span class="kobospan" id="kobo.582.1">mentioned previously:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.583.1">
DIMENSIONS = </span><strong class="bold1"><span class="kobospan1" id="kobo.584.1">2</span></strong><span class="kobospan1" id="kobo.585.1">  # number of dimensions
# boundaries, same for all dimensions
BOUND_LOW, BOUND_UP = </span><strong class="bold1"><span class="kobospan1" id="kobo.586.1">-512.0, 512.0</span></strong><span class="kobospan1" id="kobo.587.1">  </span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.588.1">Since we are dealing with floating-point numbers confined by certain boundaries, we next define a helper function that creates random floating-point numbers, uniformly distributed within the </span><span><span class="kobospan" id="kobo.589.1">given range:</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.590.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.591.1">This function assumes that the upper and lower boundaries are the same for </span><span><span class="kobospan" id="kobo.592.1">all dimensions.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.593.1">
def randomFloat(low, up):
    return [random.uniform(l, u) for l, \
        u in zip([</span><strong class="bold1"><span class="kobospan1" id="kobo.594.1">low</span></strong><span class="kobospan1" id="kobo.595.1">] * DIMENSIONS, [</span><strong class="bold1"><span class="kobospan1" id="kobo.596.1">up</span></strong><span class="kobospan1" id="kobo.597.1">] * DIMENSIONS)]</span></pre> <ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.598.1">We next define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.599.1">attrFloat</span></strong><span class="kobospan" id="kobo.600.1"> operator. </span><span class="kobospan" id="kobo.600.2">This operator utilizes the previous helper function to create a single, random floating-point number within the given boundaries. </span><span class="kobospan" id="kobo.600.3">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.601.1">attrFloat</span></strong><span class="kobospan" id="kobo.602.1"> operator is then used by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">individualCreator</span></strong><span class="kobospan" id="kobo.604.1"> operator to create random individuals. </span><span class="kobospan" id="kobo.604.2">This is followed by </span><strong class="source-inline1"><span class="kobospan" id="kobo.605.1">populationCreator</span></strong><span class="kobospan" id="kobo.606.1">, which can generate the desired number </span><span><span class="kobospan" id="kobo.607.1">of individuals:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.608.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.609.1">attrFloat</span></strong><span class="kobospan1" id="kobo.610.1">", randomFloat, BOUND_LOW, BOUND_UP)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.611.1">individualCreator</span></strong><span class="kobospan1" id="kobo.612.1">", tools.initIterate, \
    creator.Individual, toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.613.1">attrFloat</span></strong><span class="kobospan1" id="kobo.614.1">)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.615.1">populationCreator</span></strong><span class="kobospan1" id="kobo.616.1">", tools.initRepeat, \
    list, toolbox.individualCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.617.1">Given </span><a id="_idIndexMarker404" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.618.1">that the </span><a id="_idIndexMarker405" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.619.1">object to be minimized is the Eggholder function, we use it directly as the fitness evaluator. </span><span class="kobospan" id="kobo.619.2">As the individual is a list of floating-point numbers with a dimension (or length) of 2, we extract the </span><strong class="source-inline1"><span class="kobospan" id="kobo.620.1">x</span></strong><span class="kobospan" id="kobo.621.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.622.1">y</span></strong><span class="kobospan" id="kobo.623.1"> values from the individual accordingly, and then calculate </span><span><span class="kobospan" id="kobo.624.1">the function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.625.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.626.1">eggholder</span></strong><span class="kobospan1" id="kobo.627.1">(individual):
    x = individual[0]
    y = individual[1]
    f = (
        -(y + 47.0) * np.sin(np.sqrt(abs(x / 2.0 + (y + 47.0))))
        - x * np.sin(np.sqrt(abs(x - (y + 47.0))))
    )
    return f,   # return a tuple
toolbox.register("evaluate", </span><strong class="bold1"><span class="kobospan1" id="kobo.628.1">eggholder</span></strong><span class="kobospan1" id="kobo.629.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.630.1">Next are the genetic operators. </span><span class="kobospan" id="kobo.630.2">Given that the </span><em class="italic"><span class="kobospan" id="kobo.631.1">selection</span></em><span class="kobospan" id="kobo.632.1"> operator is independent of the individual type, and we’ve had a good experience so far using the </span><em class="italic"><span class="kobospan" id="kobo.633.1">tournament selection</span></em><span class="kobospan" id="kobo.634.1"> with a tournament size of 2, coupled with the </span><em class="italic"><span class="kobospan" id="kobo.635.1">elitist approach</span></em><span class="kobospan" id="kobo.636.1">, we’ll continue to use it here. </span><span class="kobospan" id="kobo.636.2">The </span><em class="italic"><span class="kobospan" id="kobo.637.1">crossover</span></em><span class="kobospan" id="kobo.638.1"> and </span><em class="italic"><span class="kobospan" id="kobo.639.1">mutation</span></em><span class="kobospan" id="kobo.640.1"> operators, on the other hand, need to be specialized for floating-point numbers within </span><a id="_idIndexMarker406" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.641.1">given boundaries, and </span><a id="_idIndexMarker407" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.642.1">therefore we use the DEAP-provided </span><strong class="source-inline1"><span class="kobospan" id="kobo.643.1">cxSimulatedBinaryBounded</span></strong><span class="kobospan" id="kobo.644.1"> operator for crossover and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.645.1">mutPolynomialBounded</span></strong><span class="kobospan" id="kobo.646.1"> operator </span><span><span class="kobospan" id="kobo.647.1">for mutation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.648.1">
# Genetic operators:
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.649.1">select</span></strong><span class="kobospan1" id="kobo.650.1">", tools.selTournament, tournsize=2)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.651.1">mate</span></strong><span class="kobospan1" id="kobo.652.1">", tools.cxSimulatedBinaryBounded, \
    low=BOUND_LOW, up=BOUND_UP, eta=CROWDING_FACTOR)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.653.1">mutate</span></strong><span class="kobospan1" id="kobo.654.1">", tools.mutPolynomialBounded, \
    low=BOUND_LOW, up=BOUND_UP, eta=CROWDING_FACTOR, \
    indpb=1.0/DIMENSIONS)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.655.1">As we have done multiple times, we use our modified version of DEAP’s simple genetic algorithm flow, where we added </span><em class="italic"><span class="kobospan" id="kobo.656.1">elitism</span></em><span class="kobospan" id="kobo.657.1">—keeping the best individuals (members of the hall of fame) and moving them to the next generation, untouched by the </span><span><span class="kobospan" id="kobo.658.1">genetic operators:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.659.1">
population, logbook = elitism.</span><strong class="bold1"><span class="kobospan1" id="kobo.660.1">eaSimpleWithElitism</span></strong><span class="kobospan1" id="kobo.661.1">(population,
    toolbox,
    cxpb=P_CROSSOVER,
    mutpb=P_MUTATION,
    ngen=MAX_GENERATIONS,
    stats=stats,
    halloffame=hof,
    verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.662.1">We will </span><a id="_idIndexMarker408" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.663.1">start with </span><a id="_idIndexMarker409" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.664.1">the following parameters for the genetic algorithm settings. </span><span class="kobospan" id="kobo.664.2">As the Eggholder function may be somewhat difficult to optimize, we use a relatively large population size considering the low </span><span><span class="kobospan" id="kobo.665.1">dimension count:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.666.1">
# Genetic Algorithm constants:
POPULATION_SIZE = 300
P_CROSSOVER = 0.9
P_MUTATION = 0.1
MAX_GENERATIONS = 300
HALL_OF_FAME_SIZE = 30</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.667.1">In addition </span><a id="_idIndexMarker410" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.668.1">to the previous ordinary genetic algorithm constants, we now need a new one, the </span><strong class="bold"><span class="kobospan" id="kobo.669.1">crowding factor</span></strong><span class="kobospan" id="kobo.670.1"> (eta) that is used by both the crossover and </span><span><span class="kobospan" id="kobo.671.1">mutation operations:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.672.1">
CROWDING_FACTOR = 20.0</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.673.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.674.1">It is also possible to define separate crowding factors for crossover </span><span><span class="kobospan" id="kobo.675.1">and mutation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.676.1">We are finally ready to run the program. </span><span class="kobospan" id="kobo.676.2">The results obtained with these settings are shown </span><span><span class="kobospan" id="kobo.677.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.678.1">
-- Best Individual = [512.0, 404.23180541839946]
-- Best Fitness = -959.6406627208509</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.679.1">This means that we have found the </span><span><span class="kobospan" id="kobo.680.1">global minimum.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.681.1">If we examine the statistics plot generated by the program, shown next, we can tell that the algorithm found some local minima values right away and then</span><a id="_idTextAnchor204" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.682.1"> made small i</span><a id="_idTextAnchor205" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.683.1">ncremental </span><a id="_idIndexMarker411" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.684.1">improvements </span><a id="_idIndexMarker412" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.685.1">until it eventually found the </span><span><span class="kobospan" id="kobo.686.1">global minima:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer096">
<span class="kobospan" id="kobo.687.1"><img alt="Figure 6.2: Stats of the first program optimizing the Eggholder function" src="image/B20851_06_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.688.1">Figure 6.2: Stats of the first program optimizing the Eggholder function</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.689.1">One interesting area is around generation 180—let’s explore it further in the </span><span><span class="kobospan" id="kobo.690.1">next subsection.</span></span></p>
<h2 id="_idParaDest-159" class="calibre7"><a id="_idTextAnchor206" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.691.1">Improving the speed with an increased mutation rate</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.692.1">If we </span><a id="_idIndexMarker413" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.693.1">zoom in at the lower part of the fitness axis, we will notice a relatively large improvement of the best result found (red line) around generation 180, accompanied by a large swing of the average results (</span><span><span class="kobospan" id="kobo.694.1">green line):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer097">
<span class="kobospan" id="kobo.695.1"><img alt="Figure 6.3: Enlarged section of the first program’s stats graph" src="image/B20851_06_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.696.1">Figure 6.3: Enlarged section of the first program’s stats graph</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.697.1">One way </span><a id="_idIndexMarker414" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.698.1">to interpret this observation is that perhaps introducing more noise can lead to better results faster. </span><span class="kobospan" id="kobo.698.2">This </span><a id="_idIndexMarker415" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.699.1">could be another manifestation of the familiar principle of </span><strong class="bold"><span class="kobospan" id="kobo.700.1">exploration versus exploitation</span></strong><span class="kobospan" id="kobo.701.1"> we’ve discussed several times before—increasing the exploration (which manifests itself as noise in the diagram) may help us locate the global minimum faster. </span><span class="kobospan" id="kobo.701.2">An easy way to increase the measure of exploration is to boost the probability of mutations. </span><span class="kobospan" id="kobo.701.3">Hopefully, the use of elitism—keeping the best results untouched—will keep us from over-exploring, which leads to random </span><span><span class="kobospan" id="kobo.702.1">search-like behavior.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.703.1">To test this idea, let’s increase the probability of mutation from 0.1 </span><span><span class="kobospan" id="kobo.704.1">to 0.5:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.705.1">
P_MUTATION = 0.5</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.706.1">Running the modified program, we again found the global minimum, but much faster, as is evident from the output, as well as from the statistic plot shown next, where the red line (the best result) reaches the optimum quickly, while the average score (green) is noisier than before and is more distanced from the </span><span><span class="kobospan" id="kobo.707.1">best result:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer098">
<span class="kobospan" id="kobo.708.1"><img alt="Figure 6.4: Stats of the program optimizing the Eggholder function with an increased mutation probability" src="image/B20851_06_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.709.1">Figure 6.4: Stats of the program optimizing the Eggholder function with an increased mutation probability</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.710.1">We will </span><a id="_idIndexMarker416" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.711.1">keep this idea in mind when dealing with our next benchmark function, known as </span><span><span class="kobospan" id="kobo.712.1">Himmelblau’s function.</span></span></p>
<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor207" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.713.1">Optimizing Himmelblau’s function</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.714.1">Another </span><a id="_idIndexMarker417" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.715.1">frequently used function for benchmarking optimization algorithms is Himmelblau’s function, depicted in the </span><span><span class="kobospan" id="kobo.716.1">following diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer099">
<span class="kobospan" id="kobo.717.1"><img alt="Figure 6.5: Himmelblau’s function " src="image/B20851_06_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.718.1">Figure 6.5: Himmelblau’s function </span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.719.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.720.1">https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg</span></a> </p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.721.1">Image by Morn the Gorn</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.722.1">The function can be mathematically expressed </span><span><span class="kobospan" id="kobo.723.1">as follows:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.724.1">f</span></span><span><span class="kobospan" id="kobo.725.1">(</span></span><span><span class="kobospan" id="kobo.726.1">x</span></span><span><span class="kobospan" id="kobo.727.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.728.1">y</span></span><span><span class="kobospan" id="kobo.729.1">)</span></span><span> </span><span><span class="kobospan" id="kobo.730.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.731.1">(</span></span><span><span class="kobospan" id="kobo.732.1">x</span></span><span><span class="kobospan" id="kobo.733.1"> </span></span><span><span class="kobospan" id="kobo.734.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.735.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.736.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.737.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.738.1">11</span></span><span><span class="kobospan" id="kobo.739.1">)</span></span><span><span class="kobospan" id="kobo.740.1"> </span></span><span><span class="kobospan" id="kobo.741.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.742.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.743.1">(</span></span><span><span class="kobospan" id="kobo.744.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.745.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.746.1">y</span></span><span><span class="kobospan" id="kobo.747.1"> </span></span><span><span class="kobospan" id="kobo.748.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.749.1">−</span></span><span> </span><span><span><span class="kobospan" id="kobo.750.1">7</span></span></span><span><span><span class="kobospan" id="kobo.751.1">)</span></span></span><span><span><span class="kobospan" id="kobo.752.1"> </span></span></span><span><span><span class="kobospan" id="kobo.753.1">2</span></span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.754.1">It is usually </span><a id="_idIndexMarker418" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.755.1">evaluated on the search space bounded by [-5, 5] in </span><span><span class="kobospan" id="kobo.756.1">each dimension.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.757.1">Although this </span><a id="_idIndexMarker419" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.758.1">function seems simpler in comparison to the Eggholder function, it draws interest as it is </span><strong class="bold"><span class="kobospan" id="kobo.759.1">multi-modal</span></strong><span class="kobospan" id="kobo.760.1">; in other words, it has more than one global minimum. </span><span class="kobospan" id="kobo.760.2">To be exact, the function has four global minima evaluating to 0, which can be found in the </span><span><span class="kobospan" id="kobo.761.1">following locations:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><span class="kobospan" id="kobo.762.1">x=3.0, y=2.0</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.763.1">x=−2.805118, y=3.131312</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.764.1">x=−3.779310, y=−3.283186</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.765.1">x=3.584458, y=−1.848126</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.766.1">These locations are depicted in the following function </span><span><span class="kobospan" id="kobo.767.1">contour diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer100">
<span class="kobospan" id="kobo.768.1"><img alt="Figure 6.6: Contour diagram of Himmelblau’s function " src="image/B20851_06_06.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.769.1">Figure 6.6: Contour diagram of Himmelblau’s function </span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.770.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Himmelblau_contour.svg" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.771.1">https://commons.wikimedia.org/wiki/File:Himmelblau_contour.svg</span></a> </p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.772.1">Image by Nicoguaro</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.773.1">When optimizing </span><a id="_idIndexMarker420" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.774.1">multi-modal functions, we are often interested in finding all (or most) minima locations. </span><span class="kobospan" id="kobo.774.2">However, let’s start with finding one, which we are going to do in the </span><span><span class="kobospan" id="kobo.775.1">next subsection.</span></span></p>
<h2 id="_idParaDest-161" class="calibre7"><a id="_idTextAnchor208" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.776.1">Optimizing Himmelblau’s function with genetic algorithms</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.777.1">The </span><a id="_idIndexMarker421" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.778.1">genetic algorithm-based </span><a id="_idIndexMarker422" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.779.1">program we created for finding a single minimum of Himmelblau’s function resides in the </span><strong class="source-inline"><span class="kobospan" id="kobo.780.1">02_optimize_himmelblau.py</span></strong><span class="kobospan" id="kobo.781.1"> Python program, located at the </span><span><span class="kobospan" id="kobo.782.1">following link:</span></span></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/02_optimize_himmelblau.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.783.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/02_optimize_himmelblau.py</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.784.1">The program is similar to the one we used for optimizing the Eggholder function, with a few differen</span><a id="_idTextAnchor209" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.785.1">ces highlighted </span><span><span class="kobospan" id="kobo.786.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.787.1">We </span><a id="_idIndexMarker423" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.788.1">set the boundaries for this function to [-</span><span><span class="kobospan" id="kobo.789.1">5.0, 5.0]:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.790.1">
BOUND_LOW, BOUND_UP = -5.0, 5.0  # boundaries for all dimensions</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.791.1">We </span><a id="_idIndexMarker424" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.792.1">now use Himmelblau’s function as the </span><span><span class="kobospan" id="kobo.793.1">fitness evaluator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.794.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.795.1">himmelblau</span></strong><span class="kobospan1" id="kobo.796.1">(individual):
    x = individual[0]
    y = individual[1]
    f = (x ** 2 + y - 11) ** 2 + (x + y ** 2 - 7) ** 2
    return f,  # return a tuple
toolbox.register("evaluate", </span><strong class="bold1"><span class="kobospan1" id="kobo.797.1">himmelblau</span></strong><span class="kobospan1" id="kobo.798.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.799.1">Since the function we optimize has several minima, it may be interesting to observe the distribution of the solutions found at the end of the run. </span><span class="kobospan" id="kobo.799.2">We, therefore, add a scatter graph containing the locations of the four global minima and the final population on the same </span><span><em class="italic"><span class="kobospan" id="kobo.800.1">x</span></em></span><span><span class="kobospan" id="kobo.801.1">-</span></span><span><em class="italic"><span class="kobospan" id="kobo.802.1">y</span></em></span><span><span class="kobospan" id="kobo.803.1"> plane:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.804.1">
plt.figure(1)
globalMinima = [[3.0, 2.0], [-2.805118, 3.131312],
     [-3.779310, -3.283186], [3.584458, -1.848126]]
plt.scatter(*zip(*globalMinima), marker='X', color='red', 
    zorder=1)
plt.scatter(*zip(*population), marker='.', color='blue', 
    zorder=0)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.805.1">We also print the members of the hall of fame—the best individuals found during </span><span><span class="kobospan" id="kobo.806.1">the run:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.807.1">
print("- Best solutions are:")
for i in range(HALL_OF_FAME_SIZE):
    print(i, ": ", hof.items[i].fitness.values[0],
           " -&gt; ", hof.it</span><a id="_idTextAnchor210" class="calibre17 pcalibre pcalibre1"/><span class="kobospan1" id="kobo.808.1">ems[i])</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.809.1">Running </span><a id="_idIndexMarker425" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.810.1">the program, the </span><a id="_idIndexMarker426" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.811.1">results indicate that we found one of the four minima (</span><span><span class="kobospan" id="kobo.812.1">x=3.0, y=2.0):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.813.1">
-- Best Individual = [2.9999999999987943, 2.0000000000007114]
-- Best Fitness = 4.523490304795033e-23</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.814.1">The printout of the hall-of-fame members suggests they all represent the </span><span><span class="kobospan" id="kobo.815.1">same solution:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.816.1">
- Best solutions are:
0 : 4.523490304795033e-23 -&gt; [2.9999999999987943, 2.0000000000007114]
1 : 4.523732642865117e-23 -&gt; [2.9999999999987943, 2.000000000000697]
2 : 4.523900512465748e-23 -&gt; [2.9999999999987943, 2.0000000000006937]
3 : 4.5240633333565856e-23 -&gt; [2.9999999999987943, 2.00000000000071]
...</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.817.1">The following diagram, illustrating the distribution of the entire population, further confirms that the genetic algorithms have converged to one of the four functions’ minima—the one residing at (</span><span><span class="kobospan" id="kobo.818.1">x=3.0, y=2.0):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer101">
<span class="kobospan" id="kobo.819.1"><img alt="Figure 6.7: Scatter graph of the population at the end of the first run, alongside the four functions’ minima" src="image/B20851_06_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.820.1">Figure 6.7: Scatter graph of the population at the end of the first run, alongside the four functions’ minima</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.821.1">In addition, it is evident that many of the individuals in the population have either the </span><strong class="source-inline"><span class="kobospan" id="kobo.822.1">x</span></strong><span class="kobospan" id="kobo.823.1"> or the </span><strong class="source-inline"><span class="kobospan" id="kobo.824.1">y</span></strong><span class="kobospan" id="kobo.825.1"> component of the minima </span><span><span class="kobospan" id="kobo.826.1">we found.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.827.1">These </span><a id="_idIndexMarker427" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.828.1">results represent </span><a id="_idIndexMarker428" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.829.1">what we generally expect from the genetic algorithm—to identify a global optimum and converge to it. </span><span class="kobospan" id="kobo.829.2">Since, in this case, we have several minima, it is expected to converge to one of them. </span><span class="kobospan" id="kobo.829.3">Which one it will be is largely based on the random initialization of the algorithm. </span><span class="kobospan" id="kobo.829.4">As you may recall, in all our programs so far, we have been using a fixed random seed (of </span><span><span class="kobospan" id="kobo.830.1">value 42):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.831.1">
RANDOM_SEED = 42
random.seed(RANDOM_SEED)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.832.1">This is done to enable the repeatability of the results; however, in real life, we will typically use different random seed values for different runs, either by commenting out these lines or by explicitly setting the constant to </span><span><span class="kobospan" id="kobo.833.1">different values.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.834.1">For </span><a id="_idIndexMarker429" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.835.1">example, if we set the </span><a id="_idIndexMarker430" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.836.1">seed value to 13, we will end up with the solution (x=−2.805118, y=3.131312), as illustrated in the </span><span><span class="kobospan" id="kobo.837.1">following diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer102">
<span class="kobospan" id="kobo.838.1"><img alt="Figure 6.8: Scatter graph of the population at the end of the second run, alongside the four functions’ minima" src="image/B20851_06_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.839.1">Figure 6.8: Scatter graph of the population at the end of the second run, alongside the four functions’ minima</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.840.1">If we proceed to change the seed value to 17, the program execution will yield the solution (x=3.584458, y=−1.848126), as illustrated by the </span><span><span class="kobospan" id="kobo.841.1">following diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer103">
<span class="kobospan" id="kobo.842.1"><img alt="Figure 6.9: Scatter graph of the population at the end of the third run, alongside the four fu﻿nctions’ minima" src="image/B20851_06_09.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.843.1">Figure 6.9: Scatter graph of the population at the end of the third run, alongside the four fu</span><a id="_idTextAnchor211" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.844.1">nctions’ minima</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.845.1">However, what </span><a id="_idIndexMarker431" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.846.1">if we </span><a id="_idIndexMarker432" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.847.1">wanted to find </span><em class="italic"><span class="kobospan" id="kobo.848.1">all</span></em><span class="kobospan" id="kobo.849.1"> global minima in a single run? </span><span class="kobospan" id="kobo.849.2">As we will see in the next subsection, genetic algorithms offer us a way to pursue </span><span><span class="kobospan" id="kobo.850.1">this goal.</span></span></p>
<h2 id="_idParaDest-162" class="calibre7"><a id="_idTextAnchor212" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.851.1">Using niching and sharing to find multiple solutions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.852.1">In </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.853.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.854.1">, </span><em class="italic"><span class="kobospan" id="kobo.855.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.856.1">, we mentioned </span><a id="_idIndexMarker433" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.857.1">that </span><strong class="bold"><span class="kobospan" id="kobo.858.1">niching</span></strong><span class="kobospan" id="kobo.859.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.860.1">sharing</span></strong><span class="kobospan" id="kobo.861.1"> in genetic algorithms mimic the way a natural environment is divided </span><a id="_idIndexMarker434" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.862.1">into multiple sub-environments or </span><em class="italic"><span class="kobospan" id="kobo.863.1">niches</span></em><span class="kobospan" id="kobo.864.1">. </span><span class="kobospan" id="kobo.864.2">These niches are populated by different species, or sub-populations, taking advantage of the unique resources available in each niche, while specimens that coexist in the same niche have to compete over the same resources. </span><span class="kobospan" id="kobo.864.3">Implementing a sharing mechanism within the genetic algorithm will encourage individuals to explore new niches and can be used for finding several optimal solutions, each considered a niche. </span><span class="kobospan" id="kobo.864.4">One common way to accomplish sharing is to divide the raw fitness value of each individual with (some function of) the combined distances from all the other individuals, effectively penalizing a crowded population by sharing the local bounty between </span><span><span class="kobospan" id="kobo.865.1">i</span><a id="_idTextAnchor213" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.866.1">ts individuals.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.867.1">Let’s try </span><a id="_idIndexMarker435" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.868.1">to apply this </span><a id="_idIndexMarker436" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.869.1">idea to Himmelblau’s function optimization process and see whether it can help locate all four minima in a single run. </span><span class="kobospan" id="kobo.869.2">This attempt is implemented in the </span><strong class="source-inline"><span class="kobospan" id="kobo.870.1">03_optimize_himmelblau_sharing.py</span></strong><span class="kobospan" id="kobo.871.1"> program, located at the </span><span><span class="kobospan" id="kobo.872.1">following link:</span></span></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/03_optimize_himmelblau_sharing.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.873.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/03_optimize_himmelblau_sharing.py</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.874.1">The program is based on the previous one, but we had to make some important modifications, described </span><span><span class="kobospan" id="kobo.875.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.876.1">For starters, the implementation of a sharing mechanism usually requires us to optimize a function that produces positive fitness values and to look for </span><em class="italic"><span class="kobospan" id="kobo.877.1">maxima</span></em><span class="kobospan" id="kobo.878.1"> values rather than </span><em class="italic"><span class="kobospan" id="kobo.879.1">minima</span></em><span class="kobospan" id="kobo.880.1">. </span><span class="kobospan" id="kobo.880.2">This enables us to divide the raw fitness values as a way to decrease fitness and practically share the resources between neighboring individuals. </span><span class="kobospan" id="kobo.880.3">As Himmelblau’s function produces values between 0 and (roughly) 2,000, we can instead use a modified function that returns 2,000 minus the original value, which will guarantee that all function values are positive, while transforming the minima points into maxima points that return the value of 2,000. </span><span class="kobospan" id="kobo.880.4">As the locations of these points are not going to change, finding them will still serve our </span><span><span class="kobospan" id="kobo.881.1">original purpose:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.882.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.883.1">himmelblauInverted</span></strong><span class="kobospan1" id="kobo.884.1">(individual):
    x = individual[0]
    y = individual[1]
    f = (x ** 2 + y - 11) ** 2 + (x + y ** 2 - 7) ** 2
    return </span><strong class="bold1"><span class="kobospan1" id="kobo.885.1">2000.0 - f</span></strong><span class="kobospan1" id="kobo.886.1">,  # return a tuple
toolbox.register("evaluate", </span><strong class="bold1"><span class="kobospan1" id="kobo.887.1">himmelblauInverted</span></strong><span class="kobospan1" id="kobo.888.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.889.1">To complete the conversion, we redefine the fitness strategy to be a </span><span><em class="italic"><span class="kobospan" id="kobo.890.1">maximizing</span></em></span><span><span class="kobospan" id="kobo.891.1"> one:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.892.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.893.1">FitnessMax</span></strong><span class="kobospan1" id="kobo.894.1">", base.Fitness, weights=(</span><strong class="bold1"><span class="kobospan1" id="kobo.895.1">1.0</span></strong><span class="kobospan1" id="kobo.896.1">,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.897.1">To enable the implementation of </span><em class="italic"><span class="kobospan" id="kobo.898.1">sharing</span></em><span class="kobospan" id="kobo.899.1">, we first create two </span><span><span class="kobospan" id="kobo.900.1">additional constants:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.901.1">
DISTANCE_THRESHOLD = 0.1
SHARING_EXTENT = 5.0</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.902.1">Next, we need to implement the sharing mechanism. </span><span class="kobospan" id="kobo.902.2">One convenient location for this </span><a id="_idIndexMarker437" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.903.1">implementation is within the </span><em class="italic"><span class="kobospan" id="kobo.904.1">selection</span></em><span class="kobospan" id="kobo.905.1"> genetic operator. </span><span class="kobospan" id="kobo.905.2">The selection operator </span><a id="_idIndexMarker438" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.906.1">is where the fitness values of all individuals are examined and used to select the parents for the next generation. </span><span class="kobospan" id="kobo.906.2">This enables us to inject some code that recalculates these fitness values just before the selection takes place and then retrieves the original fitness values before continuing, for the purpose of tracking. </span><span class="kobospan" id="kobo.906.3">To make this happen, we implemented a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.907.1">selTournamentWithSharing()</span></strong><span class="kobospan" id="kobo.908.1"> function, which has the same signature as the original </span><strong class="source-inline1"><span class="kobospan" id="kobo.909.1">tools.selTournament()</span></strong><span class="kobospan" id="kobo.910.1"> function we have been using </span><span><span class="kobospan" id="kobo.911.1">until now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.912.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.913.1">selTournamentWithSharing</span></strong><span class="kobospan1" id="kobo.914.1">(individuals, k, tournsize, 
    fit_attr="fitness"):</span></pre><p class="calibre3"><span class="kobospan" id="kobo.915.1">This function starts by setting the original fitnesses aside so that they can be retrieved later. </span><span class="kobospan" id="kobo.915.2">It then iterates over each individual and calculates a number, </span><strong class="source-inline"><span class="kobospan" id="kobo.916.1">sharingSum</span></strong><span class="kobospan" id="kobo.917.1">, by which its fitness value will be divided. </span><span class="kobospan" id="kobo.917.2">This sum value is accumulated by calculating the distance between the location of the current individual and the location of each of the other individuals in the population. </span><span class="kobospan" id="kobo.917.3">If the distance is smaller than the threshold defined by the </span><strong class="source-inline"><span class="kobospan" id="kobo.918.1">DISTANCE_THRESHOLD</span></strong><span class="kobospan" id="kobo.919.1"> constant, the following value is added to the </span><span><span class="kobospan" id="kobo.920.1">accumulating sum:</span></span></p><p class="calibre3"><span><span class="kobospan" id="kobo.921.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.922.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.923.1"> </span></span><span><span class="kobospan" id="kobo.924.1">𝒹</span></span><span><span class="kobospan" id="kobo.925.1">𝒾</span></span><span><span class="kobospan" id="kobo.926.1">𝓈</span></span><span><span class="kobospan" id="kobo.927.1">𝓉</span></span><span><span class="kobospan" id="kobo.928.1">𝒶</span></span><span><span class="kobospan" id="kobo.929.1">𝓃</span></span><span><span class="kobospan" id="kobo.930.1">𝒸</span></span><span><span class="kobospan" id="kobo.931.1">ℯ</span></span><span><span class="kobospan" id="kobo.932.1">  </span></span><span><span class="kobospan" id="kobo.933.1">_</span></span><span><span class="kobospan" id="kobo.934.1">__________________</span></span><span><span class="kobospan" id="kobo.935.1">  </span></span><span><span class="kobospan" id="kobo.936.1">D</span></span><span><span class="kobospan" id="kobo.937.1">I</span></span><span><span class="kobospan" id="kobo.938.1">S</span></span><span><span class="kobospan" id="kobo.939.1">T</span></span><span><span class="kobospan" id="kobo.940.1">A</span></span><span><span class="kobospan" id="kobo.941.1">N</span></span><span><span class="kobospan" id="kobo.942.1">C</span></span><span> </span><span><span class="kobospan" id="kobo.943.1">E</span></span><span><span class="kobospan" id="kobo.944.1"> </span></span><span><span class="kobospan" id="kobo.945.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.946.1">T</span></span><span><span class="kobospan" id="kobo.947.1">H</span></span><span><span class="kobospan" id="kobo.948.1">R</span></span><span><span class="kobospan" id="kobo.949.1">E</span></span><span><span class="kobospan" id="kobo.950.1">S</span></span><span><span class="kobospan" id="kobo.951.1">H</span></span><span><span class="kobospan" id="kobo.952.1">O</span></span><span><span class="kobospan" id="kobo.953.1">L</span></span><span><span class="kobospan" id="kobo.954.1">D</span></span><span><span class="kobospan" id="kobo.955.1"> </span></span><span> </span><span><span class="kobospan" id="kobo.956.1">×</span></span><span> </span><span><span class="kobospan" id="kobo.957.1"> </span></span><span><span class="kobospan" id="kobo.958.1">1</span></span><span><span class="kobospan" id="kobo.959.1"> </span></span><span><span class="kobospan" id="kobo.960.1">_</span></span><span><span class="kobospan" id="kobo.961.1">______________</span></span><span><span class="kobospan" id="kobo.962.1">  </span></span><span><span class="kobospan" id="kobo.963.1">S</span></span><span><span class="kobospan" id="kobo.964.1">H</span></span><span><span class="kobospan" id="kobo.965.1">A</span></span><span><span class="kobospan" id="kobo.966.1">R</span></span><span><span class="kobospan" id="kobo.967.1">I</span></span><span><span class="kobospan" id="kobo.968.1">N</span></span><span> </span><span><span class="kobospan" id="kobo.969.1">G</span></span><span><span class="kobospan" id="kobo.970.1"> </span></span><span><span class="kobospan" id="kobo.971.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.972.1">E</span></span><span><span class="kobospan" id="kobo.973.1">X</span></span><span><span class="kobospan" id="kobo.974.1">T</span></span><span><span class="kobospan" id="kobo.975.1">E</span></span><span><span class="kobospan" id="kobo.976.1">N</span></span><span><span class="kobospan" id="kobo.977.1">T</span></span><span><span class="kobospan" id="kobo.978.1"> </span></span></p><p class="calibre3"><span class="kobospan" id="kobo.979.1">This means that the </span><em class="italic"><span class="kobospan" id="kobo.980.1">reduction</span></em><span class="kobospan" id="kobo.981.1"> in the fitness value will be greater in the </span><span><span class="kobospan" id="kobo.982.1">following scenarios:</span></span></p><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.983.1">The (normalized) distance between the individuals </span><span><span class="kobospan" id="kobo.984.1">is smaller</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.985.1">The value of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.986.1">SHARING_EXTENT</span></strong><span class="kobospan" id="kobo.987.1"> constant </span><span><span class="kobospan" id="kobo.988.1">is larger</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.989.1">After recalculating the fitness value for each individual, </span><em class="italic"><span class="kobospan" id="kobo.990.1">tournament selection </span></em><span class="kobospan" id="kobo.991.1">is conducted using the new </span><span><span class="kobospan" id="kobo.992.1">fitness values:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.993.1">selected = tools.selTournament(individuals, k, tournsize, 
    fit_attr)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.994.1">Lastly, the original fitness values </span><span><span class="kobospan" id="kobo.995.1">are retrieved:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.996.1">for i, ind in enumerate(individuals):
    ind.fitness.values = origFitnesses[i],</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.997.1">As a </span><a id="_idIndexMarker439" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.998.1">final touch, we </span><a id="_idIndexMarker440" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.999.1">added a plot showing the locations of the best individuals—the hall-of-fame members—on the </span><em class="italic"><span class="kobospan" id="kobo.1000.1">x</span></em><span class="kobospan" id="kobo.1001.1">-</span><em class="italic"><span class="kobospan" id="kobo.1002.1">y</span></em><span class="kobospan" id="kobo.1003.1"> plane, alongside the known optima location, similar to what we already do for the </span><span><span class="kobospan" id="kobo.1004.1">entire population:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1005.1">
plt.figure(2)
plt.scatter(*zip(*globalMaxima), marker='x', color='red', 
    zorder=1)
plt.scatter(*zip(*hof.items), marker='.', color='blue', 
    zorder=0)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1006.1">When we run this program, the results don’t disappoint. </span><span class="kobospan" id="kobo.1006.2">Examining the members of the hall of fame, it seems that we have located all four </span><span><span class="kobospan" id="kobo.1007.1">optima locations:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.1008.1">
- Best solutions are:
0 : 1999.9997428476076 -&gt; [3.00161237138945, 1.9958270919300878]
1 : 1999.9995532774788 -&gt; [3.585506608049694, -1.8432407550446581]
2 : 1999.9988186889173 -&gt; [3.585506608049694, -1.8396197402430106]
3 : 1999.9987642838498 -&gt; [-3.7758887140006174, -3.285804345540637]
4 : 1999.9986563457114 -&gt; [-2.8072634380293766, 3.125893564009283]
...</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1009.1">The </span><a id="_idIndexMarker441" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1010.1">following diagram, illustrating </span><a id="_idIndexMarker442" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1011.1">the distribution of the hall-of-fame members, further </span><span><span class="kobospan" id="kobo.1012.1">confirms that:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer104">
<span class="kobospan" id="kobo.1013.1"><img alt="Figure 6.10: Scatter graph of the best solutions at the end of the run, alongside the four functions’ minima, when using niching" src="image/B20851_06_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1014.1">Figure 6.10: Scatter graph of the best solutions at the end of the run, alongside the four functions’ minima, when using niching</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1015.1">Meanwhile, the diagram depicting the distribution of the </span><em class="italic"><span class="kobospan" id="kobo.1016.1">entire</span></em><span class="kobospan" id="kobo.1017.1"> population demonstrates how the population is scattered around the </span><span><span class="kobospan" id="kobo.1018.1">four solutions:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer105">
<span class="kobospan" id="kobo.1019.1"><img alt="Figure 6.11: Scatter graph of the population at the end of the run, alongside the four functions’ minima, when using niching" src="image/B20851_06_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1020.1">Figure 6.11: Scatter graph of the population at the end of the run, alongside the four functions’ minima, when using niching</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1021.1">As impressive as this may seem, we need to remember that what we did here can prove harder </span><a id="_idIndexMarker443" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1022.1">to implement in real-life situations. </span><span class="kobospan" id="kobo.1022.2">For one, the modifications we added to the selection process </span><a id="_idIndexMarker444" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1023.1">increase the calculation complexity and the time consumed by the algorithm. </span><span class="kobospan" id="kobo.1023.2">In addition, the population size usually needs to be increased so that it can sufficiently cover all areas of interest. </span><span class="kobospan" id="kobo.1023.3">The values of the sharing constants may be difficult to determine in some cases—for example, if we don’t know in advance how close together the various peaks may be. </span><span class="kobospan" id="kobo.1023.4">However, we can always use this technique to roughly locate areas of interest and then further explore each one of them using the standard version of </span><span><span class="kobospan" id="kobo.1024.1">the algorithm.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1025.1">An alternative </span><a id="_idIndexMarker445" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1026.1">approach for finding several optima points falls within the realm of </span><strong class="bold"><span class="kobospan" id="kobo.1027.1">constrained optimization</span></strong><span class="kobospan" id="kobo.1028.1">, which is the subject of the </span><span><span class="kobospan" id="kobo.1029.1">next section.</span></span></p>
<h1 id="_idParaDest-163" class="calibre5"><a id="_idTextAnchor214" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1030.1">Simionescu’s function and constrained optimization</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1031.1">At first glance, Simionescu’s function may not look particularly interesting. </span><span class="kobospan" id="kobo.1031.2">However, it has a </span><a id="_idIndexMarker446" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1032.1">constraint attached to it that makes it intriguing to work with as well as pleasant to </span><span><span class="kobospan" id="kobo.1033.1">look at.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1034.1">The function is </span><a id="_idIndexMarker447" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1035.1">usually evaluated on the search space bounded by [-1.25, 1.25] in each dimension and can be mathematically expressed </span><span><span class="kobospan" id="kobo.1036.1">as follows:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1037.1">f</span></span><span><span class="kobospan" id="kobo.1038.1">(</span></span><span><span class="kobospan" id="kobo.1039.1">x</span></span><span><span class="kobospan" id="kobo.1040.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.1041.1">y</span></span><span><span class="kobospan" id="kobo.1042.1">)</span></span><span> </span><span><span class="kobospan" id="kobo.1043.1">=</span></span><span> </span><span><span><span class="kobospan" id="kobo.1044.1">0.1</span></span></span><span><span><span class="kobospan" id="kobo.1045.1">x</span></span></span><span><span><span class="kobospan" id="kobo.1046.1">y</span></span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1047.1">Here, the values of </span><em class="italic"><span class="kobospan" id="kobo.1048.1">x, y</span></em><span class="kobospan" id="kobo.1049.1"> are subject to the </span><span><span class="kobospan" id="kobo.1050.1">following condition:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1051.1">x</span></span><span><span class="kobospan" id="kobo.1052.1"> </span></span><span><span class="kobospan" id="kobo.1053.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.1054.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.1055.1">y</span></span><span><span class="kobospan" id="kobo.1056.1"> </span></span><span><span class="kobospan" id="kobo.1057.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.1058.1">≤</span></span><span> </span><span><span class="kobospan" id="kobo.1059.1">[</span></span><span><span class="kobospan" id="kobo.1060.1">1</span></span><span> </span><span><span class="kobospan" id="kobo.1061.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.1062.1">0.2</span></span><span> </span><span><span class="kobospan" id="kobo.1063.1">⋅</span></span><span> </span><span><span class="kobospan" id="kobo.1064.1">cos</span></span><span><span class="kobospan" id="kobo.1065.1">(</span></span><span><span class="kobospan" id="kobo.1066.1">8</span></span><span> </span><span><span class="kobospan" id="kobo.1067.1">⋅</span></span><span> </span><span><span class="kobospan" id="kobo.1068.1">arctan</span></span><span> </span><span><span class="kobospan" id="kobo.1069.1"> </span></span><span><span class="kobospan" id="kobo.1070.1">x</span></span><span><span class="kobospan" id="kobo.1071.1"> </span></span><span><span class="kobospan" id="kobo.1072.1">_</span></span><span><span class="kobospan" id="kobo.1073.1"> </span></span><span><span class="kobospan" id="kobo.1074.1">y</span></span><span><span class="kobospan" id="kobo.1075.1"> </span></span><span><span class="kobospan" id="kobo.1076.1">)</span></span><span><span class="kobospan" id="kobo.1077.1">]</span></span><span><span class="kobospan" id="kobo.1078.1"> </span></span><span><span class="kobospan" id="kobo.1079.1">2</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1080.1">This constraint effectively limits the values of </span><em class="italic"><span class="kobospan" id="kobo.1081.1">x</span></em><span class="kobospan" id="kobo.1082.1"> and </span><em class="italic"><span class="kobospan" id="kobo.1083.1">y</span></em><span class="kobospan" id="kobo.1084.1"> that are considered valid for this function. </span><span class="kobospan" id="kobo.1084.2">The result is depicted in the following </span><span><span class="kobospan" id="kobo.1085.1">contour diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer106">
<span class="kobospan" id="kobo.1086.1"><img alt="Figure 6.12: Contour diagram of the constrained Simionescu’s function" src="image/B20851_06_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1087.1">Figure 6.12: Contour diagram of the constrained Simionescu’s function</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1088.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Simionescu%27s_function.PNG" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.1089.1">https://commons.wikimedia.org/wiki/File:Simionescu%27s_function.PNG</span></a></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1090.1">Image by Simiprof</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1091.1">The flower-shaped </span><a id="_idIndexMarker448" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1092.1">border is created by the constraint, while the </span><a id="_idIndexMarker449" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1093.1">colors of the contours denote the actual value—red for the highest values and purple for the lowest. </span><span class="kobospan" id="kobo.1093.2">If it weren’t for the constraint, the minima points would have been at (1.25, -1.25) and (-1.25, 1.25). </span><span class="kobospan" id="kobo.1093.3">However, after applying the constraint, the global minima of the function are located at the </span><span><span class="kobospan" id="kobo.1094.1">following locations:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><em class="italic"><span class="kobospan" id="kobo.1095.1">x</span></em></span><span><span class="kobospan" id="kobo.1096.1">=0.84852813, </span></span><span><em class="italic"><span class="kobospan" id="kobo.1097.1">y</span></em></span><span><span class="kobospan" id="kobo.1098.1">=–0.84852813</span></span></li>
<li class="calibre11"><span><em class="italic"><span class="kobospan" id="kobo.1099.1">x</span></em></span><span><span class="kobospan" id="kobo.1100.1">=−0.84852813, </span></span><span><em class="italic"><span class="kobospan" id="kobo.1101.1">y</span></em></span><span><span class="kobospan" id="kobo.1102.1">=0.84852813</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1103.1">These represent the tips of the two opposite petals containing the purple contours. </span><span class="kobospan" id="kobo.1103.2">Both minima evaluate to the value </span><span><span class="kobospan" id="kobo.1104.1">of -0.072.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1105.1">In the next subsection, we will attempt to find these minima using our real-coded genetic </span><span><span class="kobospan" id="kobo.1106.1">algorithms approach.</span></span></p>
<h2 id="_idParaDest-164" class="calibre7"><a id="_idTextAnchor215" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1107.1">Constrained optimization with genetic algorithms</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1108.1">We have already dealt with constraints in </span><a href="B20851_05.xhtml#_idTextAnchor177" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.1109.1">Chapter 5</span></em></span></a><span class="kobospan" id="kobo.1110.1">, </span><em class="italic"><span class="kobospan" id="kobo.1111.1">Constraint Satisfaction</span></em><span class="kobospan" id="kobo.1112.1">, when we tackled </span><a id="_idIndexMarker450" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1113.1">constraints within the realm </span><a id="_idIndexMarker451" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1114.1">of search problems. </span><span class="kobospan" id="kobo.1114.2">However, while search problems presented us with invalid states or combinations, here we need to address constraints in the continuous space, defined as </span><span><span class="kobospan" id="kobo.1115.1">mathematical inequalities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1116.1">The approaches for both cases, however, are similar, and the differences lie in the implementation. </span><span class="kobospan" id="kobo.1116.2">Let’s revisit </span><span><span class="kobospan" id="kobo.1117.1">these approaches:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1118.1">The best approach, when available, is to eliminate the possibility of a constraint violation. </span><span class="kobospan" id="kobo.1118.2">We have actually been doing it all along in this chapter as we have used bounded regions for our functions. </span><span class="kobospan" id="kobo.1118.3">These are actually simple constraints on each input variable. </span><span class="kobospan" id="kobo.1118.4">We were able to go around them by generating initial populations within the given boundaries and by utilizing bounded genetic operators such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.1119.1">cxSimulatedBinaryBounded()</span></strong><span class="kobospan" id="kobo.1120.1">, which produced results within the given boundaries. </span><span class="kobospan" id="kobo.1120.2">Unfortunately, this approach can prove difficult to implement when the constraints are more complex than just the upper and lower bounds for an </span><span><span class="kobospan" id="kobo.1121.1">input variable.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1122.1">Another approach is to discard candidate solutions that violate any given constraint. </span><span class="kobospan" id="kobo.1122.2">As we mentioned before, this approach leads to the loss of information contained in these solutions and can considerably slow down the </span><span><span class="kobospan" id="kobo.1123.1">optimization process.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1124.1">The next approach is to repair any candidate solution that violates a constraint by modifying it so it will no longer violate the constraint(s). </span><span class="kobospan" id="kobo.1124.2">This can prove difficult to implement and, at the same time, may lead to significant loss </span><span><span class="kobospan" id="kobo.1125.1">of information.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1126.1">Finally, the approach that worked for us in </span><a href="B20851_05.xhtml#_idTextAnchor177" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.1127.1">Chapter 5</span></em></span></a><span class="kobospan" id="kobo.1128.1">, </span><em class="italic"><span class="kobospan" id="kobo.1129.1">Constraint Satisfaction</span></em><span class="kobospan" id="kobo.1130.1">, was to penalize candidate solutions that violated a constraint by degrading the solution’s score and making it less desirable. </span><span class="kobospan" id="kobo.1130.2">For search problems, we implemented this approach by creating a cost function that added a fixed cost to each constraint violation. </span><span class="kobospan" id="kobo.1130.3">Here, in the continuous space case, we can either use a fixed penalty or increase the penalty based on the degree to which the constraint </span><span><span class="kobospan" id="kobo.1131.1">was violated.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1132.1">When </span><a id="_idIndexMarker452" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1133.1">taking the last approach—penalizing the score for constraint violations—we can utilize a feature offered </span><a id="_idIndexMarker453" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1134.1">by the DEAP framework, namely </span><a id="_idIndexMarker454" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1135.1">the </span><strong class="bold"><span class="kobospan" id="kobo.1136.1">penalty function</span></strong><span class="kobospan" id="kobo.1137.1">, as we will demonstrate in the </span><span><span class="kobospan" id="kobo.1138.1">next subsection.</span></span></p>
<h2 id="_idParaDest-165" class="calibre7"><a id="_idTextAnchor216" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1139.1">Optimizing Simionescu’s function using genetic algorithms</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1140.1">The genetic </span><a id="_idIndexMarker455" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1141.1">algorithm-based </span><a id="_idIndexMarker456" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1142.1">program we created for optimizing Simionescu’s function resides in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1143.1">04_optimize_simionescu.py</span></strong><span class="kobospan" id="kobo.1144.1"> Python program, located at the </span><span><span class="kobospan" id="kobo.1145.1">following link:</span></span></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/04_optimize_simionescu.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1146.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/04_optimize_simionescu.py</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.1147.1">The program is very similar to the first one we used in this chapter, created originally for the Eggholder function, with the following </span><span><span class="kobospan" id="kobo.1148.1">highlighted differences:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1149.1">The constants setting the boundaries are adjusted to match the domain of </span><span><span class="kobospan" id="kobo.1150.1">Simionescu’s function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1151.1">
BOUND_LOW, BOUND_UP = -1.25, 1.25</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1152.1">In addition, a new constant determines a fixed penalty (or cost) for violating </span><span><span class="kobospan" id="kobo.1153.1">the constraint:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1154.1">
PENALTY_VALUE = 10.0</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1155.1">The fitness is now determined by the definition of </span><span><span class="kobospan" id="kobo.1156.1">Simionescu’s function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1157.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.1158.1">simionescu</span></strong><span class="kobospan1" id="kobo.1159.1">(individual):
    x = individual[0]
    y = individual[1]
    f = 0.1 * x * y
    return f,  # return a tuple
toolbox.register("evaluate",</span><strong class="bold1"><span class="kobospan1" id="kobo.1160.1">simionescu</span></strong><span class="kobospan1" id="kobo.1161.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1162.1">Here is where the interesting part begins: we now define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1163.1">feasible()</span></strong><span class="kobospan" id="kobo.1164.1"> function </span><a id="_idIndexMarker457" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1165.1">that specifies </span><a id="_idIndexMarker458" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1166.1">the valid input domain using the constraints. </span><span class="kobospan" id="kobo.1166.2">This function returns a value of </span><strong class="source-inline1"><span class="kobospan" id="kobo.1167.1">True</span></strong><span class="kobospan" id="kobo.1168.1"> for </span><em class="italic"><span class="kobospan" id="kobo.1169.1">x, y</span></em><span class="kobospan" id="kobo.1170.1"> values that comply with the constraints, and a value of </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1171.1">False</span></strong></span><span><span class="kobospan" id="kobo.1172.1"> otherwise:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1173.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.1174.1">feasible</span></strong><span class="kobospan1" id="kobo.1175.1">(individual):
    x = individual[0]
    y = individual[1]
    return x**2 + y**2 &lt;= 
        (1 + 0.2 * math.cos(8.0 * math.atan2(x, y)))**2</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1176.1">We then use DEAP’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.1177.1">toolbox.decorate()</span></strong><span class="kobospan" id="kobo.1178.1"> operator in combination with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1179.1">tools.DeltaPenalty()</span></strong><span class="kobospan" id="kobo.1180.1"> function to modify (</span><em class="italic"><span class="kobospan" id="kobo.1181.1">decorate</span></em><span class="kobospan" id="kobo.1182.1">) the original fitness function so that the fitness values will be penalized whenever the constraints are not satisfied. </span><strong class="source-inline1"><span class="kobospan" id="kobo.1183.1">DeltaPenalty()</span></strong><span class="kobospan" id="kobo.1184.1"> accepts the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1185.1">feasible()</span></strong><span class="kobospan" id="kobo.1186.1"> function and the fixed penalty value </span><span><span class="kobospan" id="kobo.1187.1">as parameters:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1188.1">
toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1189.1">decorate</span></strong><span class="kobospan1" id="kobo.1190.1">("evaluate", tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.1191.1">DeltaPenalty(</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1192.1">feasible</span></strong><span class="kobospan1" id="kobo.1193.1">,PENALTY_VALUE))</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1194.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1195.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1196.1">DeltaPenalty()</span></strong><span class="kobospan" id="kobo.1197.1"> function </span><a id="_idIndexMarker459" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1198.1">can also accept a third parameter that represents the distance from the feasible region, causing the penalty to increase with </span><span><span class="kobospan" id="kobo.1199.1">the distance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1200.1">Now, the program is ready to use! </span><span class="kobospan" id="kobo.1200.2">The results indicate that we have indeed found one of the two known </span><span><span class="kobospan" id="kobo.1201.1">minima locations:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1202.1">
-- Best Individual = [0.8487712463169383, -0.8482833185888866]
-- Best Fitness = -0.07199984895485578</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1203.1">What </span><a id="_idIndexMarker460" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1204.1">about the second </span><a id="_idIndexMarker461" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1205.1">location? </span><span class="kobospan" id="kobo.1205.2">Read on—we will be looking for it in the </span><span><span class="kobospan" id="kobo.1206.1">next subsection.</span></span></p>
<h2 id="_idParaDest-166" class="calibre7"><a id="_idTextAnchor217" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1207.1">Using constraints to find multiple solutions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1208.1">Earlier in this chapter, when optimizing Himmelblau’s function, we were looking for more than </span><a id="_idIndexMarker462" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1209.1">one minimum location, and observed two possible ways to do that—one was changing the random seed, and the other was using </span><strong class="bold"><span class="kobospan" id="kobo.1210.1">niching and sharing</span></strong><span class="kobospan" id="kobo.1211.1">. </span><span class="kobospan" id="kobo.1211.2">Here, we will demonstrate a third option, powered </span><span><span class="kobospan" id="kobo.1212.1">by... </span><span class="kobospan" id="kobo.1212.2">constraints!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1213.1">The niching technique we used for Himmelblau’s function is sometimes called </span><em class="italic"><span class="kobospan" id="kobo.1214.1">parallel niching</span></em><span class="kobospan" id="kobo.1215.1"> as it attempts to locate several solutions at the same time. </span><span class="kobospan" id="kobo.1215.2">As we already mentioned, it is prone to several practical drawbacks. </span><em class="italic"><span class="kobospan" id="kobo.1216.1">Serial niching</span></em><span class="kobospan" id="kobo.1217.1"> (or </span><em class="italic"><span class="kobospan" id="kobo.1218.1">sequential niching</span></em><span class="kobospan" id="kobo.1219.1">), on the other hand, is a method used to find one solution at a time. </span><span class="kobospan" id="kobo.1219.2">To implement serial niching, we use the genetic algorithm as usual and find the best solution. </span><span class="kobospan" id="kobo.1219.3">We then update the fitness function so that the area of the solution(s) already found is penalized, thereby encouraging the algorithm to explore other areas of the problem space. </span><span class="kobospan" id="kobo.1219.4">This can be repeated multiple times until no additional viable solutions </span><span><span class="kobospan" id="kobo.1220.1">are found.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1221.1">Interestingly, penalizing the areas around the previously found solutions can be implemented by imposing constraints on the search space and, as we just learned how to apply constraints to the function at hand, we can use this knowledge to implement serial niching, demonstrated </span><span><span class="kobospan" id="kobo.1222.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1223.1">To find the second minimum for Simionescu’s function, we created the </span><strong class="source-inline"><span class="kobospan" id="kobo.1224.1">05_ optimize_simionescu_second.py</span></strong><span class="kobospan" id="kobo.1225.1"> Python program, located at the </span><span><span class="kobospan" id="kobo.1226.1">following link:</span></span></p>
<p class="calibre3"><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/05_optimize_simionescu_second.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1227.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/05_optimize_simionescu_second.py</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.1228.1">The program is almost identical to the previous one, with a couple of changes, </span><span><span class="kobospan" id="kobo.1229.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1230.1">We first add a constant that defines the </span><em class="italic"><span class="kobospan" id="kobo.1231.1">distance threshold</span></em><span class="kobospan" id="kobo.1232.1"> from previously found solutions—new solutions that are closer than this threshold value to any of the old ones will </span><span><span class="kobospan" id="kobo.1233.1">be penalized:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1234.1">
DISTANCE_THRESHOLD = 0.1</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1235.1">We then add a second constraint to the definition of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1236.1">feasible()</span></strong><span class="kobospan" id="kobo.1237.1"> function using a conditional statement with multiple clauses. </span><span class="kobospan" id="kobo.1237.2">The new constraint applies to input </span><a id="_idIndexMarker463" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1238.1">values closer than the threshold to the already found solution (x=0.848, y = -</span><span><span class="kobospan" id="kobo.1239.1">0.848):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1240.1">
def feasible(individual): 
    x = individual[0] 
    y = individual[1] 
    if x**2 + y**2 &gt; (1 + 0.2 * math.cos(
        8.0 * math.atan2(x, y))
    )**2: 
        return False
    elif (x - 0.848)**2 + (y + 0.848)**2 &lt; 
        DISTANCE_THRESHOLD**2:
        return False
    else:
        return True</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1241.1">When running this program, the results indicate that we have indeed found the </span><span><span class="kobospan" id="kobo.1242.1">second minimum:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1243.1">
-- Best Individual = [-0.8473430282562487, 0.8496942440090975]
-- Best Fitness = -0.07199824938105727</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1244.1">You are encouraged to add this minimum point as another constraint to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1245.1">feasible()</span></strong><span class="kobospan" id="kobo.1246.1"> function and </span><a id="_idIndexMarker464" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1247.1">verify that running the program again does </span><em class="italic"><span class="kobospan" id="kobo.1248.1">not</span></em><span class="kobospan" id="kobo.1249.1"> find any other equally minimum-valued locations in the </span><span><span class="kobospan" id="kobo.1250.1">input space.</span></span></p>
<h1 id="_idParaDest-167" class="calibre5"><a id="_idTextAnchor218" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1251.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1252.1">In this chapter, you were introduced to continuous search-space optimization problems and how they can be represented and solved using genetic algorithms, specifically by utilizing the DEAP framework. </span><span class="kobospan" id="kobo.1252.2">We then explored several hands-on examples of continuous function optimization problems—the Eggholder function, Himmelblau’s function, and Simionescu’s function—along with their Python-based solutions. </span><span class="kobospan" id="kobo.1252.3">In addition, we covered approaches for finding multiple solutions and for </span><span><span class="kobospan" id="kobo.1253.1">handling constraints.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1254.1">In the next four chapters of the book, we will demonstrate how the various techniques we’ve learned so far in this book can be applied when solving </span><strong class="bold"><span class="kobospan" id="kobo.1255.1">machine learning</span></strong><span class="kobospan" id="kobo.1256.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1257.1">ML</span></strong><span class="kobospan" id="kobo.1258.1">)- and </span><strong class="bold"><span class="kobospan" id="kobo.1259.1">artificial intelligence</span></strong><span class="kobospan" id="kobo.1260.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1261.1">AI</span></strong><span class="kobospan" id="kobo.1262.1">)-related problems. </span><span class="kobospan" id="kobo.1262.2">The first of these chapters will provide a quick overview of </span><strong class="bold"><span class="kobospan" id="kobo.1263.1">supervised learning</span></strong><span class="kobospan" id="kobo.1264.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1265.1">SL</span></strong><span class="kobospan" id="kobo.1266.1">) and then demonstrate how genetic algorithms can improve the outcome of learning models by selecting the most relevant portions of the </span><span><span class="kobospan" id="kobo.1267.1">given dataset.</span></span></p>
<h1 id="_idParaDest-168" class="calibre5"><a id="_idTextAnchor219" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1268.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1269.1">For more information, please refer to the </span><span><span class="kobospan" id="kobo.1270.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1271.1">Mathematical optimization: finding minima </span></em><span><em class="italic"><span class="kobospan" id="kobo.1272.1">of functions</span></em></span><span><span class="kobospan" id="kobo.1273.1">:</span></span><p class="calibre3"><a href="http://scipy-lectures.org/advanced/mathematical_optimization/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1274.1">http://scipy-lectures.org/advanced/mathematical_optimization/</span></span></a></p></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1275.1">Optimization Test Functions </span></em><span><em class="italic"><span class="kobospan" id="kobo.1276.1">and Datasets</span></em></span><span><span class="kobospan" id="kobo.1277.1">:</span></span><p class="calibre3"><a href="https://www.sfu.ca/~ssurjano/optimization.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1278.1">https://www.sfu.ca/~ssurjano/optimization.html</span></span></a></p></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1279.1">Introduction to </span></em><span><em class="italic"><span class="kobospan" id="kobo.1280.1">Constrained Optimization</span></em></span><span><span class="kobospan" id="kobo.1281.1">:</span></span><p class="calibre3"><a href="https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.1introandgraphical.pdf" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1282.1">https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.1introandgraphical.pdf</span></span></a></p></li>
<li class="calibre11"><span class="kobospan" id="kobo.1283.1">Constraint handling </span><span><span class="kobospan" id="kobo.1284.1">in DEAP:</span></span><p class="calibre3"><a href="https://deap.readthedocs.io/en/master/tutorials/advanced/constraints.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1285.1">https://deap.readthedocs.io/en/master/tutorials/advanced/constraints.html</span></span></a></p></li>
</ul>
</div>
</body></html>