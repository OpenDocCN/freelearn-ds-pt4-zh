["```py\n    DIMENSIONS = 2  # number of dimensions\n    # boundaries, same for all dimensions\n    BOUND_LOW, BOUND_UP = -512.0, 512.0  \n    ```", "```py\ndef randomFloat(low, up):\n    return [random.uniform(l, u) for l, \\\n        u in zip([low] * DIMENSIONS, [up] * DIMENSIONS)]\n```", "```py\n    toolbox.register(\"attrFloat\", randomFloat, BOUND_LOW, BOUND_UP)\n    toolbox.register(\"individualCreator\", tools.initIterate, \\\n        creator.Individual, toolbox.attrFloat)\n    toolbox.register(\"populationCreator\", tools.initRepeat, \\\n        list, toolbox.individualCreator)\n    ```", "```py\n    def eggholder(individual):\n        x = individual[0]\n        y = individual[1]\n        f = (\n            -(y + 47.0) * np.sin(np.sqrt(abs(x / 2.0 + (y + 47.0))))\n            - x * np.sin(np.sqrt(abs(x - (y + 47.0))))\n        )\n        return f,   # return a tuple\n    toolbox.register(\"evaluate\", eggholder)\n    ```", "```py\n    # Genetic operators:\n    toolbox.register(\"select\", tools.selTournament, tournsize=2)\n    toolbox.register(\"mate\", tools.cxSimulatedBinaryBounded, \\\n        low=BOUND_LOW, up=BOUND_UP, eta=CROWDING_FACTOR)\n    toolbox.register(\"mutate\", tools.mutPolynomialBounded, \\\n        low=BOUND_LOW, up=BOUND_UP, eta=CROWDING_FACTOR, \\\n        indpb=1.0/DIMENSIONS)\n    ```", "```py\n    population, logbook = elitism.eaSimpleWithElitism(population,\n        toolbox,\n        cxpb=P_CROSSOVER,\n        mutpb=P_MUTATION,\n        ngen=MAX_GENERATIONS,\n        stats=stats,\n        halloffame=hof,\n        verbose=True)\n    ```", "```py\n    # Genetic Algorithm constants:\n    POPULATION_SIZE = 300\n    P_CROSSOVER = 0.9\n    P_MUTATION = 0.1\n    MAX_GENERATIONS = 300\n    HALL_OF_FAME_SIZE = 30\n    ```", "```py\n    CROWDING_FACTOR = 20.0\n    ```", "```py\n-- Best Individual = [512.0, 404.23180541839946]\n-- Best Fitness = -959.6406627208509\n```", "```py\nP_MUTATION = 0.5\n```", "```py\n    BOUND_LOW, BOUND_UP = -5.0, 5.0  # boundaries for all dimensions\n    ```", "```py\n    def himmelblau(individual):\n        x = individual[0]\n        y = individual[1]\n        f = (x ** 2 + y - 11) ** 2 + (x + y ** 2 - 7) ** 2\n        return f,  # return a tuple\n    toolbox.register(\"evaluate\", himmelblau)\n    ```", "```py\n    plt.figure(1)\n    globalMinima = [[3.0, 2.0], [-2.805118, 3.131312],\n         [-3.779310, -3.283186], [3.584458, -1.848126]]\n    plt.scatter(*zip(*globalMinima), marker='X', color='red', \n        zorder=1)\n    plt.scatter(*zip(*population), marker='.', color='blue', \n        zorder=0)\n    ```", "```py\n    print(\"- Best solutions are:\")\n    for i in range(HALL_OF_FAME_SIZE):\n        print(i, \": \", hof.items[i].fitness.values[0],\n               \" -> \", hof.items[i])\n    ```", "```py\n-- Best Individual = [2.9999999999987943, 2.0000000000007114]\n-- Best Fitness = 4.523490304795033e-23\n```", "```py\n- Best solutions are:\n0 : 4.523490304795033e-23 -> [2.9999999999987943, 2.0000000000007114]\n1 : 4.523732642865117e-23 -> [2.9999999999987943, 2.000000000000697]\n2 : 4.523900512465748e-23 -> [2.9999999999987943, 2.0000000000006937]\n3 : 4.5240633333565856e-23 -> [2.9999999999987943, 2.00000000000071]\n...\n```", "```py\nRANDOM_SEED = 42\nrandom.seed(RANDOM_SEED)\n```", "```py\n    def himmelblauInverted(individual):\n        x = individual[0]\n        y = individual[1]\n        f = (x ** 2 + y - 11) ** 2 + (x + y ** 2 - 7) ** 2\n        return 2000.0 - f,  # return a tuple\n    toolbox.register(\"evaluate\", himmelblauInverted)\n    ```", "```py\n    creator.create(\"FitnessMax\", base.Fitness, weights=(1.0,))\n    ```", "```py\n    DISTANCE_THRESHOLD = 0.1\n    SHARING_EXTENT = 5.0\n    ```", "```py\n    def selTournamentWithSharing(individuals, k, tournsize, \n        fit_attr=\"fitness\"):\n    ```", "```py\n    selected = tools.selTournament(individuals, k, tournsize, \n        fit_attr)\n    ```", "```py\n    for i, ind in enumerate(individuals):\n        ind.fitness.values = origFitnesses[i],\n    ```", "```py\n    plt.figure(2)\n    plt.scatter(*zip(*globalMaxima), marker='x', color='red', \n        zorder=1)\n    plt.scatter(*zip(*hof.items), marker='.', color='blue', \n        zorder=0)\n    ```", "```py\n- Best solutions are:\n0 : 1999.9997428476076 -> [3.00161237138945, 1.9958270919300878]\n1 : 1999.9995532774788 -> [3.585506608049694, -1.8432407550446581]\n2 : 1999.9988186889173 -> [3.585506608049694, -1.8396197402430106]\n3 : 1999.9987642838498 -> [-3.7758887140006174, -3.285804345540637]\n4 : 1999.9986563457114 -> [-2.8072634380293766, 3.125893564009283]\n...\n```", "```py\n    BOUND_LOW, BOUND_UP = -1.25, 1.25\n    ```", "```py\n    PENALTY_VALUE = 10.0\n    ```", "```py\n    def simionescu(individual):\n        x = individual[0]\n        y = individual[1]\n        f = 0.1 * x * y\n        return f,  # return a tuple\n    toolbox.register(\"evaluate\",simionescu)\n    ```", "```py\n    def feasible(individual):\n        x = individual[0]\n        y = individual[1]\n        return x**2 + y**2 <= \n            (1 + 0.2 * math.cos(8.0 * math.atan2(x, y)))**2\n    ```", "```py\n    toolbox.decorate(\"evaluate\", tools.DeltaPenalty(\n    feasible,PENALTY_VALUE))\n    ```", "```py\n-- Best Individual = [0.8487712463169383, -0.8482833185888866]\n-- Best Fitness = -0.07199984895485578\n```", "```py\n    DISTANCE_THRESHOLD = 0.1\n    ```", "```py\n    def feasible(individual): \n        x = individual[0] \n        y = individual[1] \n        if x**2 + y**2 > (1 + 0.2 * math.cos(\n            8.0 * math.atan2(x, y))\n        )**2: \n            return False\n        elif (x - 0.848)**2 + (y + 0.848)**2 < \n            DISTANCE_THRESHOLD**2:\n            return False\n        else:\n            return True\n    ```", "```py\n-- Best Individual = [-0.8473430282562487, 0.8496942440090975]\n-- Best Fitness = -0.07199824938105727\n```"]