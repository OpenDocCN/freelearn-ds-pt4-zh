<html><head></head><body>
<div id="_idContainer136" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-256"><a id="_idTextAnchor308" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-257" class="calibre5"><a id="_idTextAnchor309" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Explainable AI, Causality, and Counterfactuals with Genetic Algorithms</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">This chapter explores the application of genetic algorithms for generating “what-if” scenarios, providing valuable insights into the analysis of datasets and associated machine learning models, and enabling actionable insights, which help achieve </span><span><span class="kobospan" id="kobo.4.1">desired outcomes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">This chapter begins by introducing the fields of </span><strong class="bold"><span class="kobospan" id="kobo.6.1">Explainable AI</span></strong><span class="kobospan" id="kobo.7.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.8.1">XAI</span></strong><span class="kobospan" id="kobo.9.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.10.1">causality</span></strong><span class="kobospan" id="kobo.11.1"> before explaining the concept of </span><strong class="bold"><span class="kobospan" id="kobo.12.1">counterfactuals</span></strong><span class="kobospan" id="kobo.13.1">. </span><span class="kobospan" id="kobo.13.2">We’ll use this technique to explore the ubiquitous </span><em class="italic"><span class="kobospan" id="kobo.14.1">German Credit Risk</span></em><span class="kobospan" id="kobo.15.1"> dataset and use genetic algorithms to apply a counterfactual analysis to it and discover </span><span><span class="kobospan" id="kobo.16.1">valuable insights.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.17.1">By the end of this chapter, you will be able to do </span><span><span class="kobospan" id="kobo.18.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.19.1">Be familiar with the fields of XAI and causality, as well as </span><span><span class="kobospan" id="kobo.20.1">their applications</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.21.1">Understand the concept of counterfactuals and </span><span><span class="kobospan" id="kobo.22.1">their importance</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.23.1">Get acquainted with the German Credit Risk dataset, as well as </span><span><span class="kobospan" id="kobo.24.1">its shortcomings</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.25.1">Implement an application to create counterfactual “what-if” scenarios that provide actionable insights for this dataset and shed light on the operation of its associated machine </span><span><span class="kobospan" id="kobo.26.1">learning model</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">We will start this chapter with a quick overview of XAI and causality. </span><span class="kobospan" id="kobo.27.2">If you are a seasoned data scientist, feel free to skip this </span><span><span class="kobospan" id="kobo.28.1">introductory section.</span></span></p>
<h1 id="_idParaDest-258" class="calibre5"><a id="_idTextAnchor310" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.29.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">In this chapter, we will be using Python 3 with the following </span><span><span class="kobospan" id="kobo.31.1">supporting libraries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.32.1">deap</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.33.1">numpy</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.34.1">pandas</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.35.1">scikit-learn</span></strong></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.36.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.37.1">If you’re using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.38.1">requirements.txt</span></strong><span class="kobospan" id="kobo.39.1"> file we’ve provided (see </span><a href="B20851_03.xhtml#_idTextAnchor091" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.40.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.41.1">), these libraries are already included in </span><span><span class="kobospan" id="kobo.42.1">your environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">The programs that will be used in this chapter can be found in this book’s GitHub repository </span><span><span class="kobospan" id="kobo.44.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_12" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.45.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_12</span></span></a><span><span class="kobospan" id="kobo.46.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">Check out the following video to see the Code in Action: </span></p>
<p class="calibre3"><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.48.1">https://packt.link/OEBOd</span></span></a><span><span class="kobospan" id="kobo.49.1">.</span></span></p>
<h1 id="_idParaDest-259" class="calibre5"><a id="_idTextAnchor311" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.50.1">Unlocking the black box – XAI</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.51.1">XAI</span></strong><span class="kobospan" id="kobo.52.1"> is a crucial element in the realm of </span><strong class="bold"><span class="kobospan" id="kobo.53.1">artificial intelligence</span></strong><span class="kobospan" id="kobo.54.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.55.1">AI</span></strong><span class="kobospan" id="kobo.56.1">) that aims to demystify the intricate workings</span><a id="_idIndexMarker748" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.57.1"> of machine learning models. </span><span class="kobospan" id="kobo.57.2">As AI applications continue to grow, understanding </span><a id="_idIndexMarker749" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.58.1">the decision-making processes of models becomes paramount for building trust and ensuring </span><span><span class="kobospan" id="kobo.59.1">responsible deployment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.60.1">XAI intends to address the inherent complexity and opacity of such models and to provide clear and accessible explanations for predictions. </span><span class="kobospan" id="kobo.60.2">This transparency not only enhances the interpretability of AI models but also empowers users, stakeholders, and regulatory bodies to scrutinize and comprehend these processes. </span><span class="kobospan" id="kobo.60.3">In critical domains such as healthcare and finance, where decisions have real-world consequences, XAI is indispensable. </span><span class="kobospan" id="kobo.60.4">For instance, in medical diagnoses, an explainable model not only delivers accurate predictions but also sheds light on specific features in medical images or patient records that influenced the diagnosis, building trust and aligning with </span><span><span class="kobospan" id="kobo.61.1">ethical standards.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.62.1">One effective approach to achieving explainability is through </span><em class="italic"><span class="kobospan" id="kobo.63.1">model-agnostic </span></em><span class="kobospan" id="kobo.64.1">techniques. </span><span class="kobospan" id="kobo.64.2">These </span><a id="_idIndexMarker750" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.65.1">methods offer </span><strong class="bold"><span class="kobospan" id="kobo.66.1">post-hoc</span></strong><span class="kobospan" id="kobo.67.1"> (“after the fact”) explanations for any machine learning model, regardless of its architecture. </span><span class="kobospan" id="kobo.67.2">Techniques such as </span><em class="italic"><span class="kobospan" id="kobo.68.1">SHAP values</span></em><span class="kobospan" id="kobo.69.1"> and </span><em class="italic"><span class="kobospan" id="kobo.70.1">LIME</span></em><span class="kobospan" id="kobo.71.1"> generate</span><a id="_idIndexMarker751" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.72.1"> explanations by making small, controlled changes to input data or model parameters, revealing the features that contribute most to </span><span><span class="kobospan" id="kobo.73.1">a prediction.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">Building on the foundation of XAI, </span><strong class="bold"><span class="kobospan" id="kobo.75.1">causality</span></strong><span class="kobospan" id="kobo.76.1"> adds a layer of depth by exploring the “why” behind the “what,”  as described in the </span><span><span class="kobospan" id="kobo.77.1">next section.</span></span></p>
<h1 id="_idParaDest-260" class="calibre5"><a id="_idTextAnchor312" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.78.1">Unraveling cause and effect – causality in AI</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.79.1">Knowing not just what AI predicts but also understanding the causal links behind those predictions can be vital, particularly in domains where decisions carry </span><span><span class="kobospan" id="kobo.80.1">significant consequences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.81.1">In AI, causality explores whether</span><a id="_idIndexMarker752" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.82.1"> changes in aspects of the data impact the predictions or decisions of the model. </span><span class="kobospan" id="kobo.82.2">For example, in healthcare, understanding the causal links between patient parameters and predicted outcomes helps tailor treatments more effectively. </span><span class="kobospan" id="kobo.82.3">The aim is not just accurate predictions but also understanding the mechanisms behind them for a nuanced and actionable insight into </span><span><span class="kobospan" id="kobo.83.1">the data.</span></span></p>
<h2 id="_idParaDest-261" class="calibre7"><a id="_idTextAnchor313" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.84.1">What-if scenarios – counterfactuals</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.85.1">Counterfactuals</span></strong><span class="kobospan" id="kobo.86.1"> further augment the interpretability of AI systems by exploring “what-if” scenarios and considering </span><a id="_idIndexMarker753" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.87.1">alternative outcomes. </span><span class="kobospan" id="kobo.87.2">Counterfactual explanations help us </span><a id="_idIndexMarker754" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.88.1">understand how changes in input could affect model predictions by tweaking these inputs and observing variations (or lack thereof) in the model’s decisions. </span><span class="kobospan" id="kobo.88.2">This process essentially poses the question, “</span><em class="italic"><span class="kobospan" id="kobo.89.1">What if?</span></em><span class="kobospan" id="kobo.90.1">” and enables us to gain valuable insights into the sensitivity and robustness of </span><span><span class="kobospan" id="kobo.91.1">AI models.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.92.1">For example, let’s imagine a scenario where an AI-driven car decides to avoid a pedestrian. </span><span class="kobospan" id="kobo.92.2">Through counterfactual analysis, we can uncover how this decision might change under different conditions, providing valuable insights into the model’s behavior. </span><span class="kobospan" id="kobo.92.3">As another example, consider a recommendation system. </span><span class="kobospan" id="kobo.92.4">Counterfactuals could help us understand how adjusting certain user preferences might change the recommended items, offering users a clearer understanding of the system’s inner workings and allowing developers to enhance </span><span><span class="kobospan" id="kobo.93.1">user satisfaction.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.94.1">In addition to providing a deeper understanding of model behavior, counterfactuals can be utilized for model improvement </span><a id="_idIndexMarker755" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.95.1">and debugging. </span><span class="kobospan" id="kobo.95.2">By exploring alternative scenarios and observing how changes </span><a id="_idIndexMarker756" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.96.1">propagate through the model, developers can identify potential weaknesses, biases, or areas </span><span><span class="kobospan" id="kobo.97.1">for optimization.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.98.1">As we will illustrate in the following sections, the exploration of “what-if” scenarios can also empower users to anticipate and interpret the AI </span><span><span class="kobospan" id="kobo.99.1">system’s responses.</span></span></p>
<h2 id="_idParaDest-262" class="calibre7"><a id="_idTextAnchor314" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.100.1">Genetic algorithms in counterfactual analysis – navigating alternative scenarios</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">Genetic algorithms emerge as</span><a id="_idIndexMarker757" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.102.1"> useful tools for performing counterfactual analysis, offering a flexible approach to modify </span><a id="_idIndexMarker758" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.103.1">model inputs to attain a desired outcome. </span><span class="kobospan" id="kobo.103.2">Here, each solution in the genetic algorithm represents a unique input combination. </span><span class="kobospan" id="kobo.103.3">The optimization objective depends on the model’s output and can incorporate conditions linked to input values, such as restricting changes or maximizing a particular </span><span><span class="kobospan" id="kobo.104.1">input value.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.105.1">In the following sections, we will leverage genetic algorithms to perform counterfactual analysis on a machine learning model tasked with determining the credit risk of a loan applicant. </span><span class="kobospan" id="kobo.105.2">Through this exploration, we aim to answer various questions concerning a particular applicant, gaining insights into the model’s inner workings. </span><span class="kobospan" id="kobo.105.3">Additionally, this analysis can provide actionable information to assist the applicants in improving their chances of securing </span><span><span class="kobospan" id="kobo.106.1">a loan.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.107.1">Let’s begin by familiarizing ourselves with the dataset that will be used to train </span><span><span class="kobospan" id="kobo.108.1">the model.</span></span></p>
<h2 id="_idParaDest-263" class="calibre7"><a id="_idTextAnchor315" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.109.1">The German Credit Risk dataset</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">For our experiments in this </span><a id="_idIndexMarker759" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.111.1">chapter, we will </span><a id="_idIndexMarker760" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.112.1">utilize a modified version of the well-known </span><em class="italic"><span class="kobospan" id="kobo.113.1">German Credit Risk</span></em><span class="kobospan" id="kobo.114.1"> dataset, which is widely used for research and benchmarking in the fields of machine learning and statistics. </span><span class="kobospan" id="kobo.114.2">The original dataset can be accessed from the </span><em class="italic"><span class="kobospan" id="kobo.115.1">UCI Machine Learning Repository</span></em><span class="kobospan" id="kobo.116.1"> and comprises 1,000 instances, each with 20 attributes. </span><span class="kobospan" id="kobo.116.2">This dataset is designed for a binary classification task that aims to predict whether a loan applicant is creditworthy or poses a </span><span><span class="kobospan" id="kobo.117.1">credit risk.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.118.1">In contemporary standards, certain original attributes in this dataset are considered </span><em class="italic"><span class="kobospan" id="kobo.119.1">protected</span></em><span class="kobospan" id="kobo.120.1">, notably those representing the gender and age of the candidate. </span><span class="kobospan" id="kobo.120.2">In our adapted version of this dataset, these attributes have been excluded. </span><span class="kobospan" id="kobo.120.3">Additionally, several other features have</span><a id="_idIndexMarker761" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.121.1"> either been removed or their values have been converted into numerical formats </span><span><span class="kobospan" id="kobo.122.1">for</span></span><span><a id="_idIndexMarker762" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.123.1"> simplicity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.124.1">The modified dataset can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.125.1">chapter_12/data/credit_risk_data.csv</span></strong><span class="kobospan" id="kobo.126.1"> file and consists of the </span><span><span class="kobospan" id="kobo.127.1">following columns:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.128.1">checking</span></strong><span class="kobospan" id="kobo.129.1">: The status of the applicant’s </span><span><span class="kobospan" id="kobo.130.1">checking account:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.131.1">0</span></strong><span class="kobospan" id="kobo.132.1">: No </span><span><span class="kobospan" id="kobo.133.1">checking account</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.134.1">1</span></strong><span class="kobospan" id="kobo.135.1">: Balance &lt; </span><span><span class="kobospan" id="kobo.136.1">100 DM</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.137.1">2</span></strong><span class="kobospan" id="kobo.138.1">: 100 &lt;= balance &lt; </span><span><span class="kobospan" id="kobo.139.1">200 DM</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.140.1">3</span></strong><span class="kobospan" id="kobo.141.1">: Balance &gt;= </span><span><span class="kobospan" id="kobo.142.1">200 DM</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">duration</span></strong><span class="kobospan" id="kobo.144.1">: The duration of the requested loan </span><span><span class="kobospan" id="kobo.145.1">in months</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.146.1">credit_history</span></strong><span class="kobospan" id="kobo.147.1">: Information about the applicant’s </span><span><span class="kobospan" id="kobo.148.1">credit history:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.149.1">0</span></strong><span class="kobospan" id="kobo.150.1">: No loans taken/all loans paid </span><span><span class="kobospan" id="kobo.151.1">back duly</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.152.1">1</span></strong><span class="kobospan" id="kobo.153.1">: Existing loans paid back duly </span><span><span class="kobospan" id="kobo.154.1">till now</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.155.1">2</span></strong><span class="kobospan" id="kobo.156.1">: All loans at this bank are paid </span><span><span class="kobospan" id="kobo.157.1">back duly</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.158.1">3</span></strong><span class="kobospan" id="kobo.159.1">: There’s been a delay in paying off in </span><span><span class="kobospan" id="kobo.160.1">the past</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">4</span></strong><span class="kobospan" id="kobo.162.1">: Critical account/other </span><span><span class="kobospan" id="kobo.163.1">loans existing</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.164.1">amount</span></strong><span class="kobospan" id="kobo.165.1">: The amount of the </span><span><span class="kobospan" id="kobo.166.1">requested loan</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.167.1">savings</span></strong><span class="kobospan" id="kobo.168.1">: The status of the applicant’s </span><span><span class="kobospan" id="kobo.169.1">savings account:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.170.1">0</span></strong><span class="kobospan" id="kobo.171.1">: Unknown/no </span><span><span class="kobospan" id="kobo.172.1">savings account</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.173.1">1</span></strong><span class="kobospan" id="kobo.174.1">: Balance &lt; </span><span><span class="kobospan" id="kobo.175.1">100 DM</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.176.1">2</span></strong><span class="kobospan" id="kobo.177.1">: 100 &lt;= balance &lt; </span><span><span class="kobospan" id="kobo.178.1">500 DM</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.179.1">3</span></strong><span class="kobospan" id="kobo.180.1">: 500 &lt;= balance &lt; </span><span><span class="kobospan" id="kobo.181.1">1000 DM</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.182.1">4</span></strong><span class="kobospan" id="kobo.183.1">: Balance &gt;= </span><span><span class="kobospan" id="kobo.184.1">1000 DM</span></span></li></ul></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.185.1">employment_duration</span></strong></span><span><span class="kobospan" id="kobo.186.1">:</span></span><ul class="calibre16"><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.187.1">0</span></strong></span><span><span class="kobospan" id="kobo.188.1">: Unemployed</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">1</span></strong><span class="kobospan" id="kobo.190.1">: Duration &lt; </span><span><span class="kobospan" id="kobo.191.1">1 year</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">2</span></strong><span class="kobospan" id="kobo.193.1">: 1 &lt;= duration &lt; </span><span><span class="kobospan" id="kobo.194.1">4 years</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.195.1">3</span></strong><span class="kobospan" id="kobo.196.1">: 4 &lt;= duration &lt; </span><span><span class="kobospan" id="kobo.197.1">7 years</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.198.1">4</span></strong><span class="kobospan" id="kobo.199.1">: Duration &gt;= </span><span><span class="kobospan" id="kobo.200.1">7 years</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">other_debtors</span></strong><span class="kobospan" id="kobo.202.1">: Any </span><a id="_idIndexMarker763" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.203.1">other individuals who might be co-debtors</span><a id="_idIndexMarker764" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.204.1"> or share financial responsibility for the loan, aside from the </span><span><span class="kobospan" id="kobo.205.1">primary applicant:</span></span><ul class="calibre16"><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.206.1">none</span></strong></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.207.1">guarantor</span></strong></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.208.1">co-applicant</span></strong></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.209.1">present_residence</span></strong><span class="kobospan" id="kobo.210.1">: The duration of the applicant’s current residence at the present address, represented as an integer between 1 </span><span><span class="kobospan" id="kobo.211.1">and 4</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.212.1">housing</span></strong><span class="kobospan" id="kobo.213.1">: The housing situation of </span><span><span class="kobospan" id="kobo.214.1">the applicant:</span></span><ul class="calibre16"><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.215.1">for free</span></strong></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.216.1">own</span></strong></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.217.1">rent</span></strong></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.218.1">number_credits</span></strong><span class="kobospan" id="kobo.219.1">: The number of credit accounts held at the </span><span><span class="kobospan" id="kobo.220.1">same bank</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.221.1">people_liable</span></strong><span class="kobospan" id="kobo.222.1">: The number of people who are financially dependent on </span><span><span class="kobospan" id="kobo.223.1">the applicant</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.224.1">telephone</span></strong><span class="kobospan" id="kobo.225.1">: Whether the applicant has a telephone (</span><strong class="source-inline1"><span class="kobospan" id="kobo.226.1">1</span></strong><span class="kobospan" id="kobo.227.1"> = yes, </span><strong class="source-inline1"><span class="kobospan" id="kobo.228.1">0</span></strong><span class="kobospan" id="kobo.229.1"> = </span><span><span class="kobospan" id="kobo.230.1">no)</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.231.1">credit_risk</span></strong><span class="kobospan" id="kobo.232.1">: The value to </span><span><span class="kobospan" id="kobo.233.1">be predicted:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">1</span></strong><span class="kobospan" id="kobo.235.1">: High risk (indicating</span><a id="_idIndexMarker765" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.236.1"> a higher likelihood of default or </span><span><span class="kobospan" id="kobo.237.1">credit issues)</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.238.1">0</span></strong><span class="kobospan" id="kobo.239.1">: </span><span><span class="kobospan" id="kobo.240.1">Low risk</span></span></li></ul></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.241.1">For illustration purposes, here</span><a id="_idIndexMarker766" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.242.1"> are the first 10 lines of </span><span><span class="kobospan" id="kobo.243.1">the data:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.244.1">
1,6,4,1169,0,4,none,4,own,2,1,1,1
2,48,1,5951,1,2,none,2,own,1,1,0,0
0,12,4,2096,1,3,none,3,own,1,2,0,1
1,42,1,7882,1,3,guarantor,4,for free,1,2,0,1
1,24,3,4870,1,2,none,4,for free,2,2,0,0
0,36,1,9055,0,2,none,4,for free,1,2,1,1
0,24,1,2835,3,4,none,4,own,1,1,0,1
2,36,1,6948,1,2,none,2,rent,1,1,1,1
0,12,1,3059,4,3,none,4,own,1,1,0,1
2,30,4,5234,1,0,none,2,own,2,1,0,0</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.245.1">While in previous cases of working with datasets, our main goal was to develop a machine learning model for precise predictions on new data, we will now employ counterfactuals to turn things around and identify data that matches a </span><span><span class="kobospan" id="kobo.246.1">desired prediction.</span></span></p>
<h1 id="_idParaDest-264" class="calibre5"><a id="_idTextAnchor316" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.247.1">Exploring counterfactual scenarios for credit risk prediction</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.248.1">As evident from the data, many applicants are deemed a credit risk (indicated by </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">1</span></strong><span class="kobospan" id="kobo.250.1"> as the last value), leading to loan disapproval. </span><span class="kobospan" id="kobo.250.2">For such applicants, the following question arises: Is there any action they can take </span><a id="_idIndexMarker767" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.251.1">to change this decision and be considered creditworthy (indicated by </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">0</span></strong><span class="kobospan" id="kobo.253.1"> as the outcome)? </span><span class="kobospan" id="kobo.253.2">By </span><em class="italic"><span class="kobospan" id="kobo.254.1">action</span></em><span class="kobospan" id="kobo.255.1">, we mean changing the status of one or more of their attributes, such as the amount they are requesting </span><span><span class="kobospan" id="kobo.256.1">to borrow.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.257.1">Upon inspecting the dataset, some attributes are challenging or even impossible for an applicant to change, such as employment duration, number of dependents, or current housing. </span><span class="kobospan" id="kobo.257.2">For our examples, we will focus on the following four attributes, all of which offer </span><span><span class="kobospan" id="kobo.258.1">some flexibility:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.259.1">amount</span></strong><span class="kobospan" id="kobo.260.1">: The amount of the </span><span><span class="kobospan" id="kobo.261.1">requested loan</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.262.1">duration</span></strong><span class="kobospan" id="kobo.263.1">: The duration of the requested loan </span><span><span class="kobospan" id="kobo.264.1">in months</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">checking</span></strong><span class="kobospan" id="kobo.266.1">: The status of the applicant’s </span><span><span class="kobospan" id="kobo.267.1">checking account</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.268.1">savings</span></strong><span class="kobospan" id="kobo.269.1">: The status of the applicant’s </span><span><span class="kobospan" id="kobo.270.1">savings account</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.271.1">The question can now be phrased as follows: For a candidate currently labeled as a credit risk, what is the minimal change (if any) we could make to these four attributes, or some of them, such that the outcome changes </span><span><span class="kobospan" id="kobo.272.1">to creditworthy?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.273.1">To address this question, as well as other relevant questions, we will create </span><span><span class="kobospan" id="kobo.274.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.275.1">A machine learning model that has been trained on our dataset. </span><span class="kobospan" id="kobo.275.2">This model will then be used to provide predictions that will enable us to test potential outcomes when an applicant’s data </span><span><span class="kobospan" id="kobo.276.1">is modified.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.277.1">A genetic algorithm-based solution that searches for the new attribute values to answer </span><span><span class="kobospan" id="kobo.278.1">our question(s).</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.279.1">These components will be implemented using Python, as described in the </span><span><span class="kobospan" id="kobo.280.1">following sections.</span></span></p>
<h2 id="_idParaDest-265" class="calibre7"><a id="_idTextAnchor317" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.281.1">The Applicant class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.282.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.283.1">Applicant</span></strong><span class="kobospan" id="kobo.284.1"> class represents an applicant from the dataset; in other words, a row from the CSV file. </span><span class="kobospan" id="kobo.284.2">The class also enables us to </span><a id="_idIndexMarker768" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.285.1">modify the values of the </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">amount</span></strong><span class="kobospan" id="kobo.287.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">duration</span></strong><span class="kobospan" id="kobo.289.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">checking</span></strong><span class="kobospan" id="kobo.291.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">savings</span></strong><span class="kobospan" id="kobo.293.1"> fields, representing the corresponding attributes of the applicant. </span><span class="kobospan" id="kobo.293.2">This class can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.294.1">applicant.py</span></strong><span class="kobospan" id="kobo.295.1"> file, which is located </span><span><span class="kobospan" id="kobo.296.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/applicant.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.297.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/applicant.py</span></span></a><span><span class="kobospan" id="kobo.298.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.299.1">The main functionality of this class is highlighted </span><span><span class="kobospan" id="kobo.300.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.301.1">The class’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">__init__()</span></strong><span class="kobospan" id="kobo.303.1"> method uses the value of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.304.1">dataset_row </span></strong><span class="kobospan" id="kobo.305.1">argument to copy the values from the corresponding dataset row and create an instance representing </span><span><span class="kobospan" id="kobo.306.1">the applicant.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.307.1">In addition to setters and getters for the four attributes mentioned previously, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.308.1">get_values()</span></strong><span class="kobospan" id="kobo.309.1"> method returns the current values of the four attributes, while the </span><strong class="source-inline1"><span class="kobospan" id="kobo.310.1">with_values()</span></strong><span class="kobospan" id="kobo.311.1"> method creates a copy of the original applicant instance and subsequently modifies the copied values of the same four attributes. </span><span class="kobospan" id="kobo.311.2">Both of these methods utilize a list of integers for the four attribute values as they will be used directly by a genetic algorithm that represents potential applicants as a list of </span><span><span class="kobospan" id="kobo.312.1">four integers.</span></span></li>
</ul>
<h2 id="_idParaDest-266" class="calibre7"><a id="_idTextAnchor318" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.313.1">The CreditRiskData class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.314.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">CreditRiskData</span></strong><span class="kobospan" id="kobo.316.1"> class encapsulates the credit risk dataset and the machine learning model trained on this data. </span><span class="kobospan" id="kobo.316.2">It </span><a id="_idIndexMarker769" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.317.1">can be found in the </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">credit_risk_data.py</span></strong><span class="kobospan" id="kobo.319.1"> file, located </span><span><span class="kobospan" id="kobo.320.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/credit_risk_data.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.321.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/credit_risk_data.py</span></span></a><span><span class="kobospan" id="kobo.322.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.323.1">The main functionality of this class is highlighted in the </span><span><span class="kobospan" id="kobo.324.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.325.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.326.1">__init__() </span></strong><span class="kobospan" id="kobo.327.1">method of the class initializes the random seed; it then calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.328.1">read_dataset()</span></strong><span class="kobospan" id="kobo.329.1"> method, which reads the dataset from the </span><span><span class="kobospan" id="kobo.330.1">CSV file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.331.1">
self.randomSeed = randomSeed
self.dataset = self.</span><strong class="bold1"><span class="kobospan1" id="kobo.332.1">read_dataset()</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.333.1">Next, it checks if a trained model has already been created and saved to a file. </span><span class="kobospan" id="kobo.333.2">If the model file exists, it is loaded. </span><span class="kobospan" id="kobo.333.3">Otherwise, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.334.1">train_model()</span></strong><span class="kobospan" id="kobo.335.1"> method </span><span><span class="kobospan" id="kobo.336.1">is called.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.337.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.338.1">train_model()</span></strong><span class="kobospan" id="kobo.339.1"> method created a </span><em class="italic"><span class="kobospan" id="kobo.340.1">Random Forest classifier</span></em><span class="kobospan" id="kobo.341.1">, which is first evaluated using a 5-fold </span><a id="_idIndexMarker770" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.342.1">cross-validation procedure, to validate its </span><span><span class="kobospan" id="kobo.343.1">generalization ability:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.344.1">
classifier = </span><strong class="bold1"><span class="kobospan1" id="kobo.345.1">RandomForestClassifier</span></strong><span class="kobospan1" id="kobo.346.1">(
    random_state=self.randomSeed)
kfold = model_selection.</span><strong class="bold1"><span class="kobospan1" id="kobo.347.1">KFold</span></strong><span class="kobospan1" id="kobo.348.1">(n_splits=NUM_FOLDS)
cv_results = model_selection.</span><strong class="bold1"><span class="kobospan1" id="kobo.349.1">cross_val_score</span></strong><span class="kobospan1" id="kobo.350.1">(
    classifier, X, y, cv=kfold, scoring='accuracy')
print(f"Model's Mean k-fold accuracy = {</span><strong class="bold1"><span class="kobospan1" id="kobo.351.1">cv_results.mean</span></strong><span class="kobospan1" id="kobo.352.1">()}")</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.353.1">Next, the model is trained using the entire dataset and evaluated </span><span><span class="kobospan" id="kobo.354.1">on it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.355.1">
classifier.</span><strong class="bold1"><span class="kobospan1" id="kobo.356.1">fit</span></strong><span class="kobospan1" id="kobo.357.1">(X, y)
y_pred = classifier.</span><strong class="bold1"><span class="kobospan1" id="kobo.358.1">predict</span></strong><span class="kobospan1" id="kobo.359.1">(X)
print(f"Model's Training Accuracy = {</span><strong class="bold1"><span class="kobospan1" id="kobo.360.1">accuracy_score</span></strong><span class="kobospan1" id="kobo.361.1">(y, 
    y_pred)}")</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.362.1">Once trained, the </span><em class="italic"><span class="kobospan" id="kobo.363.1">Random Forest</span></em><span class="kobospan" id="kobo.364.1"> model can assign </span><em class="italic"><span class="kobospan" id="kobo.365.1">feature importance</span></em><span class="kobospan" id="kobo.366.1"> values to the various attributes of the dataset, indicating the contribution of each attribute to the model’s predictions. </span><span class="kobospan" id="kobo.366.2">While these values provide insights into the factors influencing the model’s decisions, we will use them here to validate our assumption that the four attributes we chose can make </span><span><span class="kobospan" id="kobo.367.1">a difference:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.368.1">
feature_importances = dict(zip(X.columns, 
    classifier.</span><strong class="bold1"><span class="kobospan1" id="kobo.369.1">feature_importances_</span></strong><span class="kobospan1" id="kobo.370.1">))
print(dict(</span><strong class="bold1"><span class="kobospan1" id="kobo.371.1">sorted</span></strong><span class="kobospan1" id="kobo.372.1">(feature_importances.items(), 
    key=lambda item: -item[1])))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.373.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.374.1">is_credit_risk()</span></strong><span class="kobospan" id="kobo.375.1"> method utilizes the trained model to predict the outcome for a given applicant’s data using </span><em class="italic"><span class="kobospan" id="kobo.376.1">Scikit-learn</span></em><span class="kobospan" id="kobo.377.1">’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.378.1">predict()</span></strong><span class="kobospan" id="kobo.379.1"> method, returning </span><strong class="source-inline1"><span class="kobospan" id="kobo.380.1">True</span></strong><span class="kobospan" id="kobo.381.1"> when the candidate is considered a </span><span><span class="kobospan" id="kobo.382.1">credit risk.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.383.1">Additionally, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.384.1">risk_probability()</span></strong><span class="kobospan" id="kobo.385.1"> method provides a float between 0 and 1 indicating the</span><a id="_idIndexMarker771" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.386.1"> degree to which the candidate is considered a credit risk. </span><span class="kobospan" id="kobo.386.2">It utilizes the model’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.387.1">predict_proba()</span></strong><span class="kobospan" id="kobo.388.1"> method, capturing the continuous output value just before a threshold is applied to convert it into a discrete value of 0 </span><span><span class="kobospan" id="kobo.389.1">or 1.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.390.1">The convenience method, </span><strong class="source-inline1"><span class="kobospan" id="kobo.391.1">get_applicant()</span></strong><span class="kobospan" id="kobo.392.1">, allows us to select an applicant’s row from the dataset and print </span><span><span class="kobospan" id="kobo.393.1">its data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.394.1">Finally, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.395.1">main()</span></strong><span class="kobospan" id="kobo.396.1"> function starts by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.397.1">CreditRiskData</span></strong><span class="kobospan" id="kobo.398.1"> class, which trains the model for the first time if needed. </span><span class="kobospan" id="kobo.398.2">It then retrieves information about the 25th applicant from the dataset and prints it. </span><span class="kobospan" id="kobo.398.3">Afterward, it modifies the values of the four mutable attributes and prints the information of the </span><span><span class="kobospan" id="kobo.399.1">modified applicant.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.400.1">When executing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">main()</span></strong><span class="kobospan" id="kobo.402.1"> function for the first time, the results of the cross-validation test evaluation, as well as the training accuracy, are </span><span><span class="kobospan" id="kobo.403.1">printed out:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.404.1">
Loading the dataset...
</span><span class="kobospan1" id="kobo.404.2">Model's Mean k-fold accuracy = 0.7620000000000001
Model's Training Accuracy = 1.0</span></pre><p class="calibre3"><span class="kobospan" id="kobo.405.1">These results indicate that, while the trained model can fully reproduce the dataset’s results, its accuracy is approximately 76% when making predictions for unseen samples – a reasonable outcome for </span><span><span class="kobospan" id="kobo.406.1">this dataset.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.407.1">Next, the feature importance values are printed in descending order. </span><span class="kobospan" id="kobo.407.2">Notably, among the top attributes in the list are the four we chose </span><span><span class="kobospan" id="kobo.408.1">to modify:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.409.1">
------- Feature Importance values:
{
    "</span><strong class="bold1"><span class="kobospan1" id="kobo.410.1">amount</span></strong><span class="kobospan1" id="kobo.411.1">": 0.2357488244229738,
    "</span><strong class="bold1"><span class="kobospan1" id="kobo.412.1">duration</span></strong><span class="kobospan1" id="kobo.413.1">": 0.15326057481242433,
    "</span><strong class="bold1"><span class="kobospan1" id="kobo.414.1">checking</span></strong><span class="kobospan1" id="kobo.415.1">": 0.1323559111404014,
    "employment_duration": 0.08332785367394725,
    "credit_history": 0.07824885834794511,
    "</span><strong class="bold1"><span class="kobospan1" id="kobo.416.1">savings</span></strong><span class="kobospan1" id="kobo.417.1">": 0.06956484835261427,
    "present_residence": 0.06271797270697153,
     …
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.418.1">The information about the attributes and the predicted outcome for the applicant in row 25 of the dataset is now printed. </span><span class="kobospan" id="kobo.418.2">It’s worth noting that in the file, this corresponds to</span><a id="_idIndexMarker772" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.419.1"> the 27th row, given that the first row contains headers, and the data rows start counting </span><span><span class="kobospan" id="kobo.420.1">from 0:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.421.1">
applicant = credit_data.</span><strong class="bold1"><span class="kobospan1" id="kobo.422.1">get_applicant(25)</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.423.1">The output is </span><span><span class="kobospan" id="kobo.424.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.425.1">Before modifications: -------------
Applicant 25:
checking                        1
duration                        6
credit_history                  1
amount                       1374
savings                         1
employment_duration             2
present_residence               2
…
=&gt; Credit risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.426.1">True</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.427.1">As the output shows, this applicant is considered a </span><span><span class="kobospan" id="kobo.428.1">credit risk.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.429.1">The program </span><a id="_idIndexMarker773" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.430.1">now modifies all four values using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.431.1">with_values()</span></strong></span><span><span class="kobospan" id="kobo.432.1"> method:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.433.1">
modified_applicant = applicant.</span><strong class="bold1"><span class="kobospan1" id="kobo.434.1">with_values([1000, 20, 2, 0])</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.435.1">Then, it repeats the printing, reflecting </span><span><span class="kobospan" id="kobo.436.1">the changes:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.437.1">After modifications: -------------
Applicant 25:
</span><strong class="bold1"><span class="kobospan1" id="kobo.438.1">checking                        2</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.439.1">duration</span></strong><strong class="bold1"><span class="kobospan1" id="kobo.440.1">                       20</span></strong><span class="kobospan1" id="kobo.441.1">
credit_history                  1
</span><strong class="bold1"><span class="kobospan1" id="kobo.442.1">amount                       1000</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.443.1">savings                         0</span></strong><span class="kobospan1" id="kobo.444.1">
employment_duration             2
present_residence               2
…
=&gt; Credit risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.445.1">False</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.446.1">As the preceding output illustrates, when using the new values, the applicant is no longer considered a credit risk. </span><span class="kobospan" id="kobo.446.2">While these modified values were manually selected through trial and error, it’s now time to automate this process using </span><span><span class="kobospan" id="kobo.447.1">genetic algorithms.</span></span></p>
<h2 id="_idParaDest-267" class="calibre7"><a id="_idTextAnchor319" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.448.1">Counterfactuals with genetic algorithms</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.449.1">To demonstrate how genetic algorithms can work with counterfactuals, we will start with the same applicant of row 25, who</span><a id="_idIndexMarker774" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.450.1"> is originally considered a credit risk, and search for the smallest set of changes</span><a id="_idIndexMarker775" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.451.1"> that will make their prediction creditworthy. </span><span class="kobospan" id="kobo.451.2">As we mentioned previously, we will consider making changes to the </span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">amount</span></strong><span class="kobospan" id="kobo.453.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">duration</span></strong><span class="kobospan" id="kobo.455.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">checking</span></strong><span class="kobospan" id="kobo.457.1">, and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">savings</span></strong></span><span><span class="kobospan" id="kobo.459.1"> attributes.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.460.1">Solution representation</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.461.1">When approaching this problem, a </span><a id="_idIndexMarker776" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.462.1">straightforward way to represent a candidate solution is using a list of four integer values, each corresponding to one of the four attributes we want </span><span><span class="kobospan" id="kobo.463.1">to modify:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.464.1">[</span></span><span><span class="kobospan" id="kobo.465.1">a</span></span><span><span class="kobospan" id="kobo.466.1">m</span></span><span><span class="kobospan" id="kobo.467.1">o</span></span><span><span class="kobospan" id="kobo.468.1">u</span></span><span><span class="kobospan" id="kobo.469.1">n</span></span><span><span class="kobospan" id="kobo.470.1">t</span></span><span><span class="kobospan" id="kobo.471.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.472.1">d</span></span><span><span class="kobospan" id="kobo.473.1">u</span></span><span><span class="kobospan" id="kobo.474.1">r</span></span><span><span class="kobospan" id="kobo.475.1">a</span></span><span><span class="kobospan" id="kobo.476.1">t</span></span><span><span class="kobospan" id="kobo.477.1">i</span></span><span><span class="kobospan" id="kobo.478.1">o</span></span><span><span class="kobospan" id="kobo.479.1">n</span></span><span><span class="kobospan" id="kobo.480.1">,</span></span><span> </span><span><span><span class="kobospan" id="kobo.481.1">c</span></span></span><span><span><span class="kobospan" id="kobo.482.1">h</span></span></span><span><span><span class="kobospan" id="kobo.483.1">e</span></span></span><span><span><span class="kobospan" id="kobo.484.1">c</span></span></span><span><span><span class="kobospan" id="kobo.485.1">k</span></span></span><span><span><span class="kobospan" id="kobo.486.1">i</span></span></span><span><span><span class="kobospan" id="kobo.487.1">n</span></span></span><span><span><span class="kobospan" id="kobo.488.1">g</span></span></span><span><span><span class="kobospan" id="kobo.489.1">,</span></span></span><span><span> </span></span><span><span><span class="kobospan" id="kobo.490.1">s</span></span></span><span><span><span class="kobospan" id="kobo.491.1">a</span></span></span><span><span><span class="kobospan" id="kobo.492.1">v</span></span></span><span><span><span class="kobospan" id="kobo.493.1">i</span></span></span><span><span><span class="kobospan" id="kobo.494.1">n</span></span></span><span><span><span class="kobospan" id="kobo.495.1">g</span></span></span><span><span><span class="kobospan" id="kobo.496.1">s</span></span></span><span><span><span class="kobospan" id="kobo.497.1">]</span></span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.498.1">For example, the modified values we used in the main function of the </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">credit_risk_data.py</span></strong><span class="kobospan" id="kobo.500.1"> program will be represented </span><span><span class="kobospan" id="kobo.501.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.502.1">
[1000, 20, 2, 0]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.503.1">As we did in previous chapters, we will utilize floating-point, real numbers to represent the integers. </span><span class="kobospan" id="kobo.503.2">This enables the genetic algorithm to use the tried-and-true real number operators for crossover and mutation and use the same representation for each item regardless of its range. </span><span class="kobospan" id="kobo.503.3">Before evaluation, the real numbers will be converted into integers using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.504.1">int()</span></strong></span><span><span class="kobospan" id="kobo.505.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.506.1">We’ll evaluate each of these solutions in the </span><span><span class="kobospan" id="kobo.507.1">next subsection.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.508.1">Evaluating the solutions</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.509.1">Since our goal is to find the </span><em class="italic"><span class="kobospan" id="kobo.510.1">smallest</span></em><span class="kobospan" id="kobo.511.1"> degree of changes that will reverse the prediction, a question arises: How do we measure the extent of the changes made? </span><span class="kobospan" id="kobo.511.2">One possible approach is to use the sum</span><a id="_idIndexMarker777" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.512.1"> of the absolute differences between the current solution’s values and the original values, each divided by the range of that value, as </span><span><span class="kobospan" id="kobo.513.1">shown here:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.514.1">∑</span></span><span><span class="kobospan" id="kobo.515.1"> </span></span><span><span class="kobospan" id="kobo.516.1">i</span></span><span><span class="kobospan" id="kobo.517.1">=</span></span><span><span class="kobospan" id="kobo.518.1">1</span></span><span><span class="kobospan" id="kobo.519.1"> </span></span><span><span class="kobospan" id="kobo.520.1">4</span></span><span><span class="kobospan" id="kobo.521.1"> </span></span><span><span class="kobospan" id="kobo.522.1"> </span></span><span><span class="kobospan" id="kobo.523.1">|</span></span><span><span class="kobospan" id="kobo.524.1">c</span></span><span><span class="kobospan" id="kobo.525.1">u</span></span><span><span class="kobospan" id="kobo.526.1">r</span></span><span><span class="kobospan" id="kobo.527.1">r</span></span><span><span class="kobospan" id="kobo.528.1">e</span></span><span><span class="kobospan" id="kobo.529.1">n</span></span><span><span class="kobospan" id="kobo.530.1">t</span></span><span> </span><span><span class="kobospan" id="kobo.531.1">v</span></span><span><span class="kobospan" id="kobo.532.1">a</span></span><span><span class="kobospan" id="kobo.533.1">l</span></span><span><span class="kobospan" id="kobo.534.1">u</span></span><span> </span><span><span class="kobospan" id="kobo.535.1">e</span></span><span><span class="kobospan" id="kobo.536.1"> </span></span><span><span class="kobospan" id="kobo.537.1">i</span></span><span> </span><span><span class="kobospan" id="kobo.538.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.539.1">o</span></span><span><span class="kobospan" id="kobo.540.1">r</span></span><span><span class="kobospan" id="kobo.541.1">i</span></span><span><span class="kobospan" id="kobo.542.1">g</span></span><span><span class="kobospan" id="kobo.543.1">i</span></span><span><span class="kobospan" id="kobo.544.1">n</span></span><span><span class="kobospan" id="kobo.545.1">a</span></span><span><span class="kobospan" id="kobo.546.1">l</span></span><span> </span><span><span class="kobospan" id="kobo.547.1">v</span></span><span><span class="kobospan" id="kobo.548.1">a</span></span><span><span class="kobospan" id="kobo.549.1">l</span></span><span><span class="kobospan" id="kobo.550.1">u</span></span><span> </span><span><span class="kobospan" id="kobo.551.1">e</span></span><span><span class="kobospan" id="kobo.552.1"> </span></span><span><span class="kobospan" id="kobo.553.1">i</span></span><span><span class="kobospan" id="kobo.554.1">|</span></span><span><span class="kobospan" id="kobo.555.1">  </span></span><span><span class="kobospan" id="kobo.556.1">_</span></span><span><span class="kobospan" id="kobo.557.1">______________________</span></span><span><span class="kobospan" id="kobo.558.1">  </span></span><span><span class="kobospan" id="kobo.559.1">r</span></span><span><span class="kobospan" id="kobo.560.1">a</span></span><span><span class="kobospan" id="kobo.561.1">n</span></span><span><span class="kobospan" id="kobo.562.1">g</span></span><span><span class="kobospan" id="kobo.563.1">e</span></span><span> </span><span><span class="kobospan" id="kobo.564.1">o</span></span><span><span class="kobospan" id="kobo.565.1">f</span></span><span> </span><span><span class="kobospan" id="kobo.566.1">v</span></span><span><span class="kobospan" id="kobo.567.1">a</span></span><span><span class="kobospan" id="kobo.568.1">l</span></span><span><span class="kobospan" id="kobo.569.1">u</span></span><span> </span><span><span class="kobospan" id="kobo.570.1">e</span></span><span><span class="kobospan" id="kobo.571.1"> </span></span><span><span class="kobospan" id="kobo.572.1">i</span></span><span><span class="kobospan" id="kobo.573.1"> </span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">Now that we have established the representation and evaluation of the candidate solutions, we are ready to </span><a id="_idIndexMarker778" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.575.1">cover the Python implementation of the </span><span><span class="kobospan" id="kobo.576.1">genetic algorithm.</span></span></p>
<h2 id="_idParaDest-268" class="calibre7"><a id="_idTextAnchor320" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.577.1">The genetic algorithm solution</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.578.1">The genetic algorithm-based</span><a id="_idIndexMarker779" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.579.1"> counterfactual search is implemented in a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">01_counterfactual_search.py</span></strong><span class="kobospan" id="kobo.581.1">, which is located </span><span><span class="kobospan" id="kobo.582.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/01_counterfactual_search.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.583.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/01_counterfactual_search.py</span></span></a><span><span class="kobospan" id="kobo.584.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.585.1">The following steps describe the main parts of </span><span><span class="kobospan" id="kobo.586.1">this program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.587.1">We begin by defining several constants. </span><span class="kobospan" id="kobo.587.2">Then, we create an instance of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.588.1">CreditRiskData</span></strong></span><span><span class="kobospan" id="kobo.589.1"> class:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.590.1">
credit_data = </span><strong class="bold1"><span class="kobospan1" id="kobo.591.1">CreditRiskData</span></strong><span class="kobospan1" id="kobo.592.1">(randomSeed=RANDOM_SEED)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.593.1">The next several code segments are dedicated to setting the ranges of the four attributes that will be used as the solution variables. </span><span class="kobospan" id="kobo.593.2">We start by declaring placeholders, </span><span><span class="kobospan" id="kobo.594.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.595.1">
bounds_low = []
bounds_high = []
ranges = []</span></pre><p class="calibre3"><span class="kobospan" id="kobo.596.1">The first list holds the lower bounds of the four attributes, the second holds the upper bounds, and the third holds the difference </span><span><span class="kobospan" id="kobo.597.1">between them.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.598.1">Now comes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.599.1">set_ranges()</span></strong><span class="kobospan" id="kobo.600.1"> method, which accepts the lower and upper bound for each of the four attributes and populates the placeholders accordingly. </span><span class="kobospan" id="kobo.600.2">Since we are using real numbers that will be converted into integers, we’ll increment each range to ensure uniform distribution of the </span><span><span class="kobospan" id="kobo.601.1">resulting integers:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.602.1">
bounds_low = [amount_low, duration_low, checking_low, 
    savings_low]
bounds_high = [amount_high, duration_high, checking_high, 
    savings_high]
bounds_high = [</span><strong class="bold1"><span class="kobospan1" id="kobo.603.1">high + 1</span></strong><span class="kobospan1" id="kobo.604.1"> for high in bounds_high]
ranges = [high - low for high, low in zip(bounds_high, 
    bounds_low)]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.605.1">Next, we’ll use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.606.1">set_ranges()</span></strong><span class="kobospan" id="kobo.607.1"> method to set the ranges for the problem at hand. </span><span class="kobospan" id="kobo.607.2">We’ve picked</span><a id="_idIndexMarker780" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.608.1"> the </span><span><span class="kobospan" id="kobo.609.1">following values:</span></span><ul class="calibre16"><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.610.1">amount</span></strong></span><span><span class="kobospan" id="kobo.611.1">: 100..5000</span></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.612.1">duration</span></strong></span><span><span class="kobospan" id="kobo.613.1">: 2..72</span></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.614.1">checking</span></strong></span><span><span class="kobospan" id="kobo.615.1">: 0..3</span></span></li><li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.616.1">savings</span></strong></span><span><span class="kobospan" id="kobo.617.1">: 0..4:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.618.1">
bounds_low, bounds_high, ranges =
set_ranges(</span><strong class="bold1"><span class="kobospan1" id="kobo.619.1">100, 5000, 2, 72, 0, 3, 0, 4</span></strong><span class="kobospan1" id="kobo.620.1">)</span></pre></li></ul></li> <li class="calibre11"><span class="kobospan" id="kobo.621.1">Now, we must select the applicant from row 25 of the dataset (the same one we used earlier) and save its original four values in a separate </span><span><span class="kobospan" id="kobo.622.1">variable, </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.623.1">applicant_values</span></strong></span><span><span class="kobospan" id="kobo.624.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.625.1">
applicant = credit_data.get_applicant(25)
applicant_values = applicant.get_values()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.626.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.627.1">get_score()</span></strong><span class="kobospan" id="kobo.628.1"> function is used to evaluate the fitness of each solution by calculating the cost to be minimized. </span><span class="kobospan" id="kobo.628.2">The cost consists of two parts: first, as mentioned in the </span><em class="italic"><span class="kobospan" id="kobo.629.1">Evaluating the solutions</span></em><span class="kobospan" id="kobo.630.1"> section, we calculate the distance between the values of the four attributes that the solution represents and the matching original values of the candidate – the larger the distance, the larger </span><span><span class="kobospan" id="kobo.631.1">the cost:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.632.1">
cost = sum(
    [
        abs(int(individual[i]) - applicant_values[i])/ranges[i]
        for i in range(NUM_OF_PARAMS)
    ]
)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.633.1">Since we would like the solution to represent a creditworthy candidate, the second, optional, part of the </span><a id="_idIndexMarker781" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.634.1">cost is meant to penalize solutions that are considered a credit risk. </span><span class="kobospan" id="kobo.634.2">Here, we’ll utilize the </span><strong class="source-inline1"><span class="kobospan" id="kobo.635.1">is_credit_risk()</span></strong><span class="kobospan" id="kobo.636.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.637.1">risk_probability()</span></strong><span class="kobospan" id="kobo.638.1"> methods so that when the former indicates that the solution is not creditworthy, the latter is used to determine the extent of the </span><span><span class="kobospan" id="kobo.639.1">added penalty:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.640.1">
if credit_data.</span><strong class="bold1"><span class="kobospan1" id="kobo.641.1">is_credit_risk</span></strong><span class="kobospan1" id="kobo.642.1">(
    applicant.with_values(individual)
):
    cost += PENALTY * credit_data.</span><strong class="bold1"><span class="kobospan1" id="kobo.643.1">risk_probability</span></strong><span class="kobospan1" id="kobo.644.1">(
        applicant.with_values(individual))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.645.1">The rest of the program is very similar to the ones we saw previously when we used a list of real numbers to represent the individuals – for example, the one in </span><a href="B20851_09.xhtml#_idTextAnchor257" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.646.1">Chapter 9</span></em></span></a><span class="kobospan" id="kobo.647.1">, </span><em class="italic"><span class="kobospan" id="kobo.648.1">Architecture Optimization of Deep Learning Networks</span></em><span class="kobospan" id="kobo.649.1">. </span><span class="kobospan" id="kobo.649.2">We’ll get underway with the single-objective strategy for minimizing fitness as our goal is to minimize the value calculated by the cost function </span><span><span class="kobospan" id="kobo.650.1">defined earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.651.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.652.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.653.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.654.1">Since the solution is represented by a list of four float values, one for each of the attributes we can modify, each with its own range, we must define separate toolbox </span><em class="italic"><span class="kobospan" id="kobo.655.1">creator</span></em><span class="kobospan" id="kobo.656.1"> operators for them using the corresponding </span><strong class="source-inline1"><span class="kobospan" id="kobo.657.1">bounds_low</span></strong><span class="kobospan" id="kobo.658.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.659.1">bounds_high</span></strong></span><span><span class="kobospan" id="kobo.660.1"> values:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.661.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.662.1">amount</span></strong><span class="kobospan1" id="kobo.663.1">", random.uniform, \
    bounds_low[0], bounds_high[0])
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.664.1">duration</span></strong><span class="kobospan1" id="kobo.665.1">", random.uniform, \
    bounds_low[1], bounds_high[1])
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.666.1">checking</span></strong><span class="kobospan1" id="kobo.667.1">", random.uniform, \
    bounds_low[2], bounds_high[2])
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.668.1">savings</span></strong><span class="kobospan1" id="kobo.669.1">", random.uniform, \
    bounds_low[3], bounds_high[3])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.670.1">These four operators are </span><a id="_idIndexMarker782" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.671.1">then used in the definition </span><span><span class="kobospan" id="kobo.672.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.673.1">individualCreator</span></strong></span><span><span class="kobospan" id="kobo.674.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.675.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.676.1">individualCreator</span></strong><span class="kobospan1" id="kobo.677.1">",
    tools.initCycle,
    creator.Individual,
    (toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.678.1">amount</span></strong><span class="kobospan1" id="kobo.679.1">, toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.680.1">duration</span></strong><span class="kobospan1" id="kobo.681.1">,
        toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.682.1">checking</span></strong><span class="kobospan1" id="kobo.683.1">, toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.684.1">savings</span></strong><span class="kobospan1" id="kobo.685.1">),
    n=1)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.686.1">After assigning the </span><em class="italic"><span class="kobospan" id="kobo.687.1">selection</span></em><span class="kobospan" id="kobo.688.1"> operator to the usual </span><em class="italic"><span class="kobospan" id="kobo.689.1">tournament selection</span></em><span class="kobospan" id="kobo.690.1"> with a tournament size of </span><strong class="source-inline1"><span class="kobospan" id="kobo.691.1">2</span></strong><span class="kobospan" id="kobo.692.1">, we assign the </span><em class="italic"><span class="kobospan" id="kobo.693.1">crossover</span></em><span class="kobospan" id="kobo.694.1"> and </span><em class="italic"><span class="kobospan" id="kobo.695.1">mutation</span></em><span class="kobospan" id="kobo.696.1"> operators, which are specialized for bounded float-list chromosomes, and provide them with the ranges we </span><span><span class="kobospan" id="kobo.697.1">defined earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.698.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.699.1">select</span></strong><span class="kobospan1" id="kobo.700.1">",
                  tools.selTournament,
                  tournsize=2)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.701.1">mate</span></strong><span class="kobospan1" id="kobo.702.1">",
                 tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.703.1">cxSimulatedBinaryBounded</span></strong><span class="kobospan1" id="kobo.704.1">,
                 low=bounds_low,
                 up= bounds_high,
                 eta=CROWDING_FACTOR)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.705.1">mutate</span></strong><span class="kobospan1" id="kobo.706.1">",
                 tools.</span><strong class="bold1"><span class="kobospan1" id="kobo.707.1">mutPolynomialBounded</span></strong><span class="kobospan1" id="kobo.708.1">,
                 low= bounds_low,
                 up=bounds_high,
                 eta=CROWDING_FACTOR,
                 indpb=1.0 / NUM_OF_PARAMS)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.709.1">In addition, we’ll continue to use the </span><em class="italic"><span class="kobospan" id="kobo.710.1">elitist</span></em><span class="kobospan" id="kobo.711.1"> approach, where the </span><strong class="bold"><span class="kobospan" id="kobo.712.1">hall-of-fame</span></strong><span class="kobospan" id="kobo.713.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.714.1">HOF</span></strong><span class="kobospan" id="kobo.715.1">) members – the </span><a id="_idIndexMarker783" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.716.1">current best individuals – are always passed untouched to the </span><span><span class="kobospan" id="kobo.717.1">next generation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.718.1">
population, logbook = elitism.</span><strong class="bold1"><span class="kobospan1" id="kobo.719.1">eaSimpleWithElitism</span></strong><span class="kobospan1" id="kobo.720.1">(
    population,
    toolbox,
    cxpb=P_CROSSOVER,
    mutpb=P_MUTATION,
    ngen=MAX_GENERATIONS,
    stats=stats,
    halloffame=hof,
    verbose=True)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.721.1">We end by printing the best </span><a id="_idIndexMarker784" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.722.1">solution found, as well as the prediction for </span><span><span class="kobospan" id="kobo.723.1">that solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.724.1">It’s time to try out the program and see the results! </span><span class="kobospan" id="kobo.724.2">The output starts with printing out the original attributes and status of the </span><span><span class="kobospan" id="kobo.725.1">chosen applicant:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.726.1">
Loading the dataset...
</span><span class="kobospan1" id="kobo.726.2">Applicant 25:
</span><strong class="bold1"><span class="kobospan1" id="kobo.727.1">checking                        1</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.728.1">duration                        6</span></strong><span class="kobospan1" id="kobo.729.1">
credit_history                  1
</span><strong class="bold1"><span class="kobospan1" id="kobo.730.1">amount                       1374</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.731.1">savings                         1</span></strong><span class="kobospan1" id="kobo.732.1">
employment_duration             2
present_residence               2
...
</span><span class="kobospan1" id="kobo.732.2">=&gt; Credit risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.733.1">True</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.734.1">As we already know, this candidate is considered a credit risk. </span><span class="kobospan" id="kobo.734.2">Next, the genetic algorithm runs for 30 </span><a id="_idIndexMarker785" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.735.1">generations with a population size of 50, attempting to reverse the prediction while making minimal changes to the applicant’s four attributes of </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">amount</span></strong><span class="kobospan" id="kobo.737.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.738.1">duration</span></strong><span class="kobospan" id="kobo.739.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.740.1">checking</span></strong><span class="kobospan" id="kobo.741.1">, </span><span><span class="kobospan" id="kobo.742.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.743.1">savings</span></strong></span><span><span class="kobospan" id="kobo.744.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.745.1">
gen     nevals  min             avg
0       50      0.450063        51.7213
1       42      0.450063        30.2695
2       44      0.393725        14.2223
3       37      0.38311         7.62647
...
</span><span class="kobospan1" id="kobo.745.2">28      40      0.141661        0.169646
29      40      0.141661        0.175401
30      44      0.141661        0.172197
-- Best solution: </span><strong class="bold1"><span class="kobospan1" id="kobo.746.1">Amount = 1370, Duration = 16, checking = 1, savings = 1</span></strong><span class="kobospan1" id="kobo.747.1">
-- Prediction: is_risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.748.1">False</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.749.1">The preceding output indicates that it is possible to reverse the original prediction and render the applicant creditworthy by extending the duration to 16 months (instead of the original 6). </span><span class="kobospan" id="kobo.749.2">The status of the </span><strong class="source-inline"><span class="kobospan" id="kobo.750.1">checking</span></strong><span class="kobospan" id="kobo.751.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">savings</span></strong><span class="kobospan" id="kobo.753.1"> accounts does not need to </span><span><span class="kobospan" id="kobo.754.1">be changed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.755.1">Although the amount was altered to </span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">1,374</span></strong><span class="kobospan" id="kobo.757.1">, it could have remained unchanged at 1,374. </span><span class="kobospan" id="kobo.757.2">This can be verified by directly calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">is_credit_risk()</span></strong><span class="kobospan" id="kobo.759.1"> function with the values [1374, 16, 1, 1]. </span><span class="kobospan" id="kobo.759.2">The way our cost function is defined, the difference between 1,370 and 1,374 divided</span><a id="_idIndexMarker786" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.760.1"> by the range of 4,900 is minute, potentially causing the algorithm to take many more generations to recognize that the value of 1,374 is better than 1,370. </span><span class="kobospan" id="kobo.760.2">By narrowing the range for the amount to 1,000..2,000, the same program identifies the value of 1,374 well within the allotted </span><span><span class="kobospan" id="kobo.761.1">30 generations.</span></span></p>
<h2 id="_idParaDest-269" class="calibre7"><a id="_idTextAnchor321" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.762.1">More “what-if” scenarios</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.763.1">We found that altering the loan duration from 6 to 16 months for applicant 25 could render the application</span><a id="_idIndexMarker787" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.764.1"> creditworthy. </span><span class="kobospan" id="kobo.764.2">However, what if the applicant prefers a shorter duration, or wants to maximize the loan’s amount? </span><span class="kobospan" id="kobo.764.3">These are precisely the kind of “what-if” scenarios that counterfactuals explore, and the code we have written enables us to simulate various scenarios and address such questions, as will be demonstrated in the </span><span><span class="kobospan" id="kobo.765.1">following subsections.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.766.1">Reducing the duration</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.767.1">Let’s start with the case where </span><a id="_idIndexMarker788" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.768.1">the same applicant prefers to keep the duration shorter than the value of 16 months found earlier – can other changes compensate </span><span><span class="kobospan" id="kobo.769.1">for that?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.770.1">Based on the experience of the previous run, it may prove beneficial to narrow the allowed ranges of the four attributes. </span><span class="kobospan" id="kobo.770.2">Let’s try to be more conservative and use the </span><span><span class="kobospan" id="kobo.771.1">following ranges:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.772.1">amount</span></strong></span><span><span class="kobospan" id="kobo.773.1">: 1000..2000</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.774.1">duration</span></strong></span><span><span class="kobospan" id="kobo.775.1">: 2..12</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.776.1">checking</span></strong></span><span><span class="kobospan" id="kobo.777.1">: 0..1</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.778.1">savings</span></strong></span><span><span class="kobospan" id="kobo.779.1">: 0..1</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.780.1">Here, we’ll limit the duration to 12 months and aim to avoid increasing the current balance in either the </span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">checking</span></strong><span class="kobospan" id="kobo.782.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.783.1">savings</span></strong><span class="kobospan" id="kobo.784.1"> account. </span><span class="kobospan" id="kobo.784.2">This can be achieved by modifying the call to </span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">set_ranges()</span></strong><span class="kobospan" id="kobo.786.1">, </span><span><span class="kobospan" id="kobo.787.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.788.1">
bounds_low, bounds_high, ranges = set_ranges(</span><strong class="bold1"><span class="kobospan1" id="kobo.789.1">1000, 2000, 2, 12, 0, 1, 0, 1</span></strong><span class="kobospan1" id="kobo.790.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.791.1">When we run the modified program, the outcome is </span><span><span class="kobospan" id="kobo.792.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.793.1">
-- Best solution: Amount = 1249, Duration = 12, checking = 1, savings = 1
-- Prediction: is_risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.794.1">False</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.795.1">This indicates that if the applicant is willing to somewhat lower the requested loan amount, a reduced duration value of 12 months can </span><span><span class="kobospan" id="kobo.796.1">be achieved.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.797.1">What if we want to reduce</span><a id="_idIndexMarker789" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.798.1"> the duration even further? </span><span class="kobospan" id="kobo.798.2">Let’s change the duration range to 1..10, for example. </span><span class="kobospan" id="kobo.798.3">This yields the </span><span><span class="kobospan" id="kobo.799.1">following outcome:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.800.1">
-- Best solution: Amount = 1003, Duration = 10, checking = 1, savings = 0
-- Prediction: is_risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.801.1">True</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.802.1">This indicates that the algorithm has failed to find a solution where the applicant is creditworthy using these ranges. </span><span class="kobospan" id="kobo.802.2">Note that it does not necessarily mean that such a solution does not exist, but it </span><span><span class="kobospan" id="kobo.803.1">seems unlikely.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.804.1">Even if we go back and allow the ranges for the </span><strong class="source-inline"><span class="kobospan" id="kobo.805.1">checking</span></strong><span class="kobospan" id="kobo.806.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.807.1">savings</span></strong><span class="kobospan" id="kobo.808.1"> accounts to have their original ranges of 0..3 and 0..4, a solution is not found so long as the duration is limited to 10 months or less. </span><span class="kobospan" id="kobo.808.2">However, allowing the amount to go under 1,000 seems to do the trick. </span><span class="kobospan" id="kobo.808.3">Let’s use the </span><span><span class="kobospan" id="kobo.809.1">following ranges:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.810.1">amount</span></strong></span><span><span class="kobospan" id="kobo.811.1">: 100..2000</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.812.1">duration</span></strong></span><span><span class="kobospan" id="kobo.813.1">: 2..10</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.814.1">checking</span></strong></span><span><span class="kobospan" id="kobo.815.1">: 0..1</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.816.1">savings</span></strong></span><span><span class="kobospan" id="kobo.817.1">: 0..1</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.818.1">Here, we get the </span><span><span class="kobospan" id="kobo.819.1">following</span></span><span><a id="_idIndexMarker790" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.820.1"> solution:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.821.1">
-- Best solution: Amount = 971, Duration = 10, checking = 1, </span><strong class="bold1"><span class="kobospan1" id="kobo.822.1">savings = 0</span></strong><span class="kobospan1" id="kobo.823.1">
-- Prediction: is_risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.824.1">False</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.825.1">This implies that if the applicant reduces the loan amount to 971, the application will be approved for the desired duration </span><span><span class="kobospan" id="kobo.826.1">of 10.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.827.1">More surprisingly, however, is the value of 0 that was found for the </span><strong class="source-inline"><span class="kobospan" id="kobo.828.1">savings</span></strong><span class="kobospan" id="kobo.829.1"> attribute, which is lower than the</span><a id="_idIndexMarker791" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.830.1"> original 1. </span><span class="kobospan" id="kobo.830.2">As you may recall, the values of this attribute are interpreted </span><span><span class="kobospan" id="kobo.831.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.832.1">0</span></strong><span class="kobospan" id="kobo.833.1">: Unknown/no </span><span><span class="kobospan" id="kobo.834.1">savings account</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.835.1">1</span></strong><span class="kobospan" id="kobo.836.1">: Balance &lt; </span><span><span class="kobospan" id="kobo.837.1">100 DM</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.838.1">2</span></strong><span class="kobospan" id="kobo.839.1">: 100 &lt;= balance &lt; </span><span><span class="kobospan" id="kobo.840.1">500 DM</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.841.1">3</span></strong><span class="kobospan" id="kobo.842.1">: 500 &lt;= balance &lt; </span><span><span class="kobospan" id="kobo.843.1">1000 DM</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.844.1">4</span></strong><span class="kobospan" id="kobo.845.1">: Balance &gt;= </span><span><span class="kobospan" id="kobo.846.1">1000 DM</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.847.1">It seems unlikely that having no savings would be advantageous when applying for a loan. </span><span class="kobospan" id="kobo.847.2">Furthermore, if we try all possible values other than 0, by setting the range to 1..3, no solution is found. </span><span class="kobospan" id="kobo.847.3">This indicates that, according to the model used, having no savings account is considered preferable to having one, even with a high balance. </span><span class="kobospan" id="kobo.847.4">This is likely an indication of a flaw in the model, or an issue in the dataset itself, such as biased or incomplete data. </span><span class="kobospan" id="kobo.847.5">Such findings are one of the use cases </span><span><span class="kobospan" id="kobo.848.1">for counterfactuals.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.849.1">Maximizing the loan’s amount</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.850.1">So far, we have manipulated the outcome for an applicant who was initially considered a credit risk. </span><span class="kobospan" id="kobo.850.2">However, we </span><a id="_idIndexMarker792" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.851.1">can play this “what-if” game with </span><em class="italic"><span class="kobospan" id="kobo.852.1">any</span></em><span class="kobospan" id="kobo.853.1"> applicant, including those who were already approved. </span><span class="kobospan" id="kobo.853.2">Let’s consider an applicant from row 68 (the 70th line in the file). </span><span class="kobospan" id="kobo.853.3">When printing out the applicant’s information, we see </span><span><span class="kobospan" id="kobo.854.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.855.1">
Applicant 68:
</span><strong class="bold1"><span class="kobospan1" id="kobo.856.1">checking                        0</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.857.1">duration                       36</span></strong><span class="kobospan1" id="kobo.858.1">
credit_history                  1
</span><strong class="bold1"><span class="kobospan1" id="kobo.859.1">amount</span></strong><strong class="bold1"><span class="kobospan1" id="kobo.860.1">                       1819</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.861.1">savings                         1</span></strong><span class="kobospan1" id="kobo.862.1">
employment_duration             2
present_residence               4
...
</span><span class="kobospan1" id="kobo.862.2">=&gt; Credit risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.863.1">False</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.864.1">Can this applicant be approved for a higher amount without changing the other attributes? </span><span class="kobospan" id="kobo.864.2">To answer this question, we will use a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.865.1">02_counterfactual_search.py</span></strong><span class="kobospan" id="kobo.866.1">, which is located </span><span><span class="kobospan" id="kobo.867.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/02_counterfactual_search.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.868.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/02_counterfactual_search.py</span></span></a><span><span class="kobospan" id="kobo.869.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.870.1">This program is identical to the previous one, except for three small changes. </span><span class="kobospan" id="kobo.870.2">The first change is the use of</span><a id="_idIndexMarker793" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.871.1"> this </span><span><span class="kobospan" id="kobo.872.1">particular applicant:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.873.1">
applicant = credit_data.get_applicant(68)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.874.1">The second change is to the </span><span><span class="kobospan" id="kobo.875.1">range values:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.876.1">
bounds_low, bounds_high, ranges = set_ranges(2000, 50000, 36, 36, 0, 
    0, 1, 1)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.877.1">The amount range is modified to allow up to a sum of 50,000, while the other ranges have been fixed to the existing values of the candidate. </span><span class="kobospan" id="kobo.877.2">This will enable the genetic algorithm to only modify </span><span><span class="kobospan" id="kobo.878.1">the amount.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.879.1">But how do we instruct the genetic algorithm to </span><em class="italic"><span class="kobospan" id="kobo.880.1">maximize</span></em><span class="kobospan" id="kobo.881.1"> the loan amount? </span><span class="kobospan" id="kobo.881.2">As you may recall, the cost function was initially designed to minimize the distance between the modified individual and the original one within the given range. </span><span class="kobospan" id="kobo.881.3">However, in this scenario, we want the loan amount to be as large as possible compared to the original amount. </span><span class="kobospan" id="kobo.881.4">One approach to address this is to replace the cost function with a new one. </span><span class="kobospan" id="kobo.881.5">However, we’ll explore a somewhat simpler solution: we’ll set the original loan amount value to the same value we use for the upper end of the range, which is 50,000 in this case. </span><span class="kobospan" id="kobo.881.6">By doing this, when the algorithm aims to find the closest possible solution, it will work inherently to maximize the amount toward this upper limit. </span><span class="kobospan" id="kobo.881.7">This can be done by adding a single line of code that overrides the original amount value of the applicant. </span><span class="kobospan" id="kobo.881.8">The line is placed immediately following the one that stores the original attribute values to be used by the </span><span><span class="kobospan" id="kobo.882.1">cost function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.883.1">
applicant_values = applicant.get_values()
applicant_values[</span><strong class="bold1"><span class="kobospan1" id="kobo.884.1">0</span></strong><span class="kobospan1" id="kobo.885.1">] = </span><strong class="bold1"><span class="kobospan1" id="kobo.886.1">50000</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.887.1">Note that an index of </span><strong class="source-inline"><span class="kobospan" id="kobo.888.1">0</span></strong><span class="kobospan" id="kobo.889.1"> is used since the </span><strong class="source-inline"><span class="kobospan" id="kobo.890.1">amount</span></strong><span class="kobospan" id="kobo.891.1"> attribute is the first of the four values utilized by </span><span><span class="kobospan" id="kobo.892.1">the program.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.893.1">Running this program yields the </span><span><span class="kobospan" id="kobo.894.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.895.1">
-- Best solution: </span><strong class="bold1"><span class="kobospan1" id="kobo.896.1">Amount = 14165</span></strong><span class="kobospan1" id="kobo.897.1">, Duration = 36, checking = 0, savings = 1
-- Prediction: is_risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.898.1">False</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.899.1">The preceding output demonstrates that this applicant can maintain the original creditworthy status </span><a id="_idIndexMarker794" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.900.1">while increasing the loan amount, without making any changes to the </span><span><span class="kobospan" id="kobo.901.1">other attributes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.902.1">The next question we’ll address is whether we can </span><em class="italic"><span class="kobospan" id="kobo.903.1">further</span></em><span class="kobospan" id="kobo.904.1"> increase the loan amount by allowing changes to the </span><strong class="source-inline"><span class="kobospan" id="kobo.905.1">checking</span></strong><span class="kobospan" id="kobo.906.1"> and/or </span><strong class="source-inline"><span class="kobospan" id="kobo.907.1">savings</span></strong><span class="kobospan" id="kobo.908.1"> attributes. </span><span class="kobospan" id="kobo.908.2">To this effect, we will modify the boundaries so that these two attributes can be adjusted to any </span><span><span class="kobospan" id="kobo.909.1">valid value:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.910.1">
bounds_low, bounds_high, ranges = set_ranges(2000, 50000, 36, 36, 0, 
    3, 0, 4)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.911.1">The outcome of the modified program is </span><span><span class="kobospan" id="kobo.912.1">somewhat surprising:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.913.1">
-- Best solution: </span><strong class="bold1"><span class="kobospan1" id="kobo.914.1">Amount = 50000</span></strong><span class="kobospan1" id="kobo.915.1">, Duration = 36, checking = 1, savings = 1
-- Prediction: is_risk = </span><strong class="bold1"><span class="kobospan1" id="kobo.916.1">False</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.917.1">This result suggests that changing the status of the checking account from 0 (no checking account) to 1 (balance &lt; 100 DM) is sufficient to secure a significantly higher loan amount. </span><span class="kobospan" id="kobo.917.2">If we repeat the experiment with much higher amounts (for example, 500,000, replacing the previous value in two different spots in the program), the result will be similar – the candidate is creditworthy for that high amount, so long as the checking status is changed from 0 </span><span><span class="kobospan" id="kobo.918.1">to 1.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.919.1">This observation is true when experimenting with other applicants as well, indicating a potential vulnerability in </span><span><span class="kobospan" id="kobo.920.1">the model.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.921.1">You are encouraged to make additional modifications to the program and explore your own what-if scenarios. </span><span class="kobospan" id="kobo.921.2">In addition to providing valuable insights and a deeper understanding of the model’s behavior, experimenting with “what-if” scenarios can be a lot </span><span><span class="kobospan" id="kobo.922.1">of fun!</span></span></p>
<h1 id="_idParaDest-270" class="calibre5"><a id="_idTextAnchor322" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.923.1">Extending to other datasets</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.924.1">The same process demonstrated in this chapter can be applied to other datasets. </span><span class="kobospan" id="kobo.924.2">For instance, consider a dataset that’s used for predicting the expected price of a rental apartment. </span><span class="kobospan" id="kobo.924.3">In this scenario, you can use similar counterfactual analysis to determine what modifications the landlord can introduce to the apartment to achieve a certain rent. </span><span class="kobospan" id="kobo.924.4">Using programs similar to the ones introduced here, you could apply genetic algorithms to explore the sensitivity of the model’s predictions to changes in input features and identify actionable insights for achieving </span><span><span class="kobospan" id="kobo.925.1">desired outcomes.</span></span></p>
<h1 id="_idParaDest-271" class="calibre5"><a id="_idTextAnchor323" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.926.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.927.1">In this chapter, you were introduced to the concepts of </span><strong class="bold"><span class="kobospan" id="kobo.928.1">XAI</span></strong><span class="kobospan" id="kobo.929.1">, </span><strong class="bold"><span class="kobospan" id="kobo.930.1">causality</span></strong><span class="kobospan" id="kobo.931.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.932.1">counterfactuals</span></strong><span class="kobospan" id="kobo.933.1">. </span><span class="kobospan" id="kobo.933.2">After getting acquainted with the </span><em class="italic"><span class="kobospan" id="kobo.934.1">German Credis Risk</span></em><span class="kobospan" id="kobo.935.1"> dataset, we created a machine learning model that predicts whether an applicant is creditworthy.  </span><span class="kobospan" id="kobo.935.2">Next, we applied genetic algorithm-based counterfactual analysis of the dataset to the trained model, explored several “what-if” scenarios, and gained </span><span><span class="kobospan" id="kobo.936.1">valuable insights.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.937.1">In the next two chapters, we will shift our focus to accelerating the execution of genetic algorithm-based programs, such as the ones we’ve developed throughout this book, by exploring different strategies for </span><span><span class="kobospan" id="kobo.938.1">applying concurrency.</span></span></p>
<h1 id="_idParaDest-272" class="calibre5"><a id="_idTextAnchor324" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.939.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.940.1">For more information on the topics that were covered in this chapter, please refer to the </span><span><span class="kobospan" id="kobo.941.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.942.1">Hands-On Explainable AI (XAI) with Python</span></em><span class="kobospan" id="kobo.943.1">, by Denis Rothman, </span><span><span class="kobospan" id="kobo.944.1">July 2020</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.945.1">Causal Inference and Discovery in Python</span></em><span class="kobospan" id="kobo.946.1">, by Aleksander Molak, </span><span><span class="kobospan" id="kobo.947.1">May 2023</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.948.1">Responsible AI in the Enterprise</span></em><span class="kobospan" id="kobo.949.1">, by Adnan Masood, </span><span><span class="kobospan" id="kobo.950.1">July 2023</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.951.1">Scikit-learn </span></em><span><em class="italic"><span class="kobospan" id="kobo.952.1">RandomForestClassifier</span></em></span><span><span class="kobospan" id="kobo.953.1">: </span></span><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.954.1">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html</span></span></a></li>
</ul>
</div>
</body></html>