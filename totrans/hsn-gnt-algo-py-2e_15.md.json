["```py\n1,6,4,1169,0,4,none,4,own,2,1,1,1\n2,48,1,5951,1,2,none,2,own,1,1,0,0\n0,12,4,2096,1,3,none,3,own,1,2,0,1\n1,42,1,7882,1,3,guarantor,4,for free,1,2,0,1\n1,24,3,4870,1,2,none,4,for free,2,2,0,0\n0,36,1,9055,0,2,none,4,for free,1,2,1,1\n0,24,1,2835,3,4,none,4,own,1,1,0,1\n2,36,1,6948,1,2,none,2,rent,1,1,1,1\n0,12,1,3059,4,3,none,4,own,1,1,0,1\n2,30,4,5234,1,0,none,2,own,2,1,0,0\n```", "```py\n    self.randomSeed = randomSeed\n    self.dataset = self.read_dataset()\n    ```", "```py\n    classifier = RandomForestClassifier(\n        random_state=self.randomSeed)\n    kfold = model_selection.KFold(n_splits=NUM_FOLDS)\n    cv_results = model_selection.cross_val_score(\n        classifier, X, y, cv=kfold, scoring='accuracy')\n    print(f\"Model's Mean k-fold accuracy = {cv_results.mean()}\")\n    ```", "```py\n    classifier.fit(X, y)\n    y_pred = classifier.predict(X)\n    print(f\"Model's Training Accuracy = {accuracy_score(y, \n        y_pred)}\")\n    ```", "```py\n    feature_importances = dict(zip(X.columns, \n        classifier.feature_importances_))\n    print(dict(sorted(feature_importances.items(), \n        key=lambda item: -item[1])))\n    ```", "```py\n    Loading the dataset...\n    Model's Mean k-fold accuracy = 0.7620000000000001\n    Model's Training Accuracy = 1.0\n    ```", "```py\n    ------- Feature Importance values:\n    {\n        \"amount\": 0.2357488244229738,\n        \"duration\": 0.15326057481242433,\n        \"checking\": 0.1323559111404014,\n        \"employment_duration\": 0.08332785367394725,\n        \"credit_history\": 0.07824885834794511,\n        \"savings\": 0.06956484835261427,\n        \"present_residence\": 0.06271797270697153,\n         …\n    }\n    ```", "```py\n    applicant = credit_data.get_applicant(25)\n    ```", "```py\n    Before modifications: -------------\n    Applicant 25:\n    checking                        1\n    duration                        6\n    credit_history                  1\n    amount                       1374\n    savings                         1\n    employment_duration             2\n    present_residence               2\n    …\n    => Credit risk = True\n    ```", "```py\n    modified_applicant = applicant.with_values([1000, 20, 2, 0])\n    ```", "```py\n    After modifications: -------------\n    Applicant 25:\n    checking                        2\n    duration                       20\n    credit_history                  1\n    amount                       1000\n    savings                         0\n    employment_duration             2\n    present_residence               2\n    …\n    => Credit risk = False\n    ```", "```py\n[1000, 20, 2, 0]\n```", "```py\n    credit_data = CreditRiskData(randomSeed=RANDOM_SEED)\n    ```", "```py\n    bounds_low = []\n    bounds_high = []\n    ranges = []\n    ```", "```py\n    bounds_low = [amount_low, duration_low, checking_low, \n        savings_low]\n    bounds_high = [amount_high, duration_high, checking_high, \n        savings_high]\n    bounds_high = [high + 1 for high in bounds_high]\n    ranges = [high - low for high, low in zip(bounds_high, \n        bounds_low)]\n    ```", "```py\n        bounds_low, bounds_high, ranges =\n        set_ranges(100, 5000, 2, 72, 0, 3, 0, 4)\n        ```", "```py\n    applicant = credit_data.get_applicant(25)\n    applicant_values = applicant.get_values()\n    ```", "```py\n    cost = sum(\n        [\n            abs(int(individual[i]) - applicant_values[i])/ranges[i]\n            for i in range(NUM_OF_PARAMS)\n        ]\n    )\n    ```", "```py\n    if credit_data.is_credit_risk(\n        applicant.with_values(individual)\n    ):\n        cost += PENALTY * credit_data.risk_probability(\n            applicant.with_values(individual))\n    ```", "```py\n    creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))\n    ```", "```py\n    toolbox.register(\"amount\", random.uniform, \\\n        bounds_low[0], bounds_high[0])\n    toolbox.register(\"duration\", random.uniform, \\\n        bounds_low[1], bounds_high[1])\n    toolbox.register(\"checking\", random.uniform, \\\n        bounds_low[2], bounds_high[2])\n    toolbox.register(\"savings\", random.uniform, \\\n        bounds_low[3], bounds_high[3])\n    ```", "```py\n    toolbox.register(\"individualCreator\",\n        tools.initCycle,\n        creator.Individual,\n        (toolbox.amount, toolbox.duration,\n            toolbox.checking, toolbox.savings),\n        n=1)\n    ```", "```py\n    toolbox.register(\"select\",\n                      tools.selTournament,\n                      tournsize=2)\n    toolbox.register(\"mate\",\n                     tools.cxSimulatedBinaryBounded,\n                     low=bounds_low,\n                     up= bounds_high,\n                     eta=CROWDING_FACTOR)\n    toolbox.register(\"mutate\",\n                     tools.mutPolynomialBounded,\n                     low= bounds_low,\n                     up=bounds_high,\n                     eta=CROWDING_FACTOR,\n                     indpb=1.0 / NUM_OF_PARAMS)\n    ```", "```py\n    population, logbook = elitism.eaSimpleWithElitism(\n        population,\n        toolbox,\n        cxpb=P_CROSSOVER,\n        mutpb=P_MUTATION,\n        ngen=MAX_GENERATIONS,\n        stats=stats,\n        halloffame=hof,\n        verbose=True)\n    ```", "```py\nLoading the dataset...\nApplicant 25:\nchecking                        1\nduration                        6\ncredit_history                  1\namount                       1374\nsavings                         1\nemployment_duration             2\npresent_residence               2\n...\n=> Credit risk = amount, duration, checking, and savings:\n\n```", "```py\nbounds_low, bounds_high, ranges = set_ranges(1000, 2000, 2, 12, 0, 1, 0, 1)\n```", "```py\n-- Best solution: Amount = 1249, Duration = 12, checking = 1, savings = 1\n-- Prediction: is_risk = False\n```", "```py\n-- Best solution: Amount = 1003, Duration = 10, checking = 1, savings = 0\n-- Prediction: is_risk = True\n```", "```py\n-- Best solution: Amount = 971, Duration = 10, checking = 1, savings = 0\n-- Prediction: is_risk = False\n```", "```py\nApplicant 68:\nchecking                        0\nduration                       36\ncredit_history                  1\namount                       1819\nsavings                         1\nemployment_duration             2\npresent_residence               4\n...\n=> Credit risk = 02_counterfactual_search.py, which is located at https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_12/02_counterfactual_search.py.\nThis program is identical to the previous one, except for three small changes. The first change is the use of this particular applicant:\n\n```", "```py\n\n The second change is to the range values:\n\n```", "```py\n\n The amount range is modified to allow up to a sum of 50,000, while the other ranges have been fixed to the existing values of the candidate. This will enable the genetic algorithm to only modify the amount.\nBut how do we instruct the genetic algorithm to *maximize* the loan amount? As you may recall, the cost function was initially designed to minimize the distance between the modified individual and the original one within the given range. However, in this scenario, we want the loan amount to be as large as possible compared to the original amount. One approach to address this is to replace the cost function with a new one. However, we’ll explore a somewhat simpler solution: we’ll set the original loan amount value to the same value we use for the upper end of the range, which is 50,000 in this case. By doing this, when the algorithm aims to find the closest possible solution, it will work inherently to maximize the amount toward this upper limit. This can be done by adding a single line of code that overrides the original amount value of the applicant. The line is placed immediately following the one that stores the original attribute values to be used by the cost function:\n\n```", "```py\n-- Best solution: Amount = 14165, Duration = 36, checking = 0, savings = 1\n-- Prediction: is_risk = False\n```", "```py\nbounds_low, bounds_high, ranges = set_ranges(2000, 50000, 36, 36, 0, \n    3, 0, 4)\n```", "```py\n-- Best solution: Amount = 50000, Duration = 36, checking = 1, savings = 1\n-- Prediction: is_risk = False\n```", "```py\n\n```", "```py\n\n```"]