["```py\n    def oneMaxFitness(individual):\n        return sum(individual), # return a tuple\n    toolbox.register(\"evaluate\", oneMaxFitness)\n    ```", "```py\n    if __name__ == \"__main__\":\n        start = time.time()\n        main()\n        end = time.time()\n    print(f\"Elapsed time = {(end - start):.2f} seconds\")\n    ```", "```py\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nElapsed time = 0.00 seconds\n```", "```py\n    def busy_wait(duration):\n        current_time = time.time()\n        while (time.time() < current_time + duration):\n            pass\n    ```", "```py\n    def oneMaxFitness(individual):\n        busy_wait(DELAY_SECONDS)\n        return sum(individual), # return a tuple\n    ```", "```py\n          DELAY_SECONDS = 3\n    ```", "```py\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nElapsed time = 285.01 seconds\n```", "```py\n    import multiprocessing\n    ```", "```py\n    toolbox.register(\"map\", pool.map)\n    ```", "```py\n    def main():\n        with multiprocessing.Pool() as pool:\n            toolbox.register(\"map\", pool.map)\n            # create initial population (generation 0):\n            population = toolbox.populationCreator(\n                n=POPULATION_SIZE)\n            ...\n    ```", "```py\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nElapsed time = 78.49 seconds\n```", "```py\nmultiprocessing.Pool(processes=<number of processes>)\n```", "```py\n    with multiprocessing.Pool(processes=num_processes) as pool:\n    ```", "```py\n        run_times = []\n        for num_processes in range(1, 21):\n            start = time.time()\n            run(num_processes)\n            end = time.time()\n            run_time = end – start\n            run_times.append(run_time)\n    ```", "```py\n    plot_graph(1, run_times, \"Number of Processes\", \n        \"Run Time (seconds)\", hr=33)\n    plot_graph(2, [1/rt for rt in run_times], \"Number of Processes\", \n        \"(1 / Run Time)\", \"orange\")\n    ```", "```py\nnum_processes = 1\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nNumber of Processes = 1 => Run time = 286.62 seconds\nnum_processes = 2\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nNumber of Processes = 2 => Run time = 151.75 seconds\n...\nnum_processes = 20\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nNumber of Processes = 20 => Run time = 33.30 seconds\n```", "```py\n    from scoop import futures\n    ```", "```py\n    toolbox.register(\"map\", futures.map)\n    ```", "```py\npython3 -m scoop 05_one_max_scoop.py\n```", "```py\nSCOOP 0.7 2.0 on darwin using Python 3.11.1\nDeploying 4 worker(s) over 1 host(s).\nWorker distribution:\n127.0.0.1: 3 + origin\nLaunching 4 worker(s) using /bin/zsh.\ngen     nevals  max     avg\n0       20      7       4.35\n1       14      7       6.1\n2       16      9       6.85\n3       16      9       7.6\n4       16      9       8.45\n5       13      10      8.9\nBest Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n03_one_max_pool.py program, as both programs employed four concurrent processes.\nHowever, we have seen that “oversubscription” (i.e., using more concurrent processes than the number of available cores) could yield better results. Luckily, SCOOP enables us to control the number of processes, or “workers,” via a command-line argument. Let’s run the program again but, this time, use 16 workers:\n\n```", "```py\n\n The resulting output is as follows:\n\n```", "```py\n\n```"]