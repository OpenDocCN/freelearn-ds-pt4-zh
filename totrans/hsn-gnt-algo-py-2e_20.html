<html><head></head><body>
<div id="_idContainer165" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-313"><a id="_idTextAnchor365" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-314" class="calibre5"><a id="_idTextAnchor366" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Evolutionary Image Reconstruction with Genetic Algorithms</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, we are going to experiment with one of the most popular ways genetic algorithms have been applied to image processing – the reconstruction of an image with a set of semi-transparent polygons. </span><span class="kobospan" id="kobo.3.2">Along the way, we will gain useful experience in </span><strong class="bold"><span class="kobospan" id="kobo.4.1">image processing</span></strong><span class="kobospan" id="kobo.5.1">, coupled</span><a id="_idIndexMarker906" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.6.1"> with a visual insight into the </span><span><span class="kobospan" id="kobo.7.1">evolutionary process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.8.1">We will start with an overview of image processing in Python and get acquainted with two useful libraries – </span><em class="italic"><span class="kobospan" id="kobo.9.1">Pillow</span></em><span class="kobospan" id="kobo.10.1"> and </span><em class="italic"><span class="kobospan" id="kobo.11.1">OpenCV-Python</span></em><span class="kobospan" id="kobo.12.1">. </span><span class="kobospan" id="kobo.12.2">Then, we will find out how an image can be drawn from scratch using polygons and how the difference between two images can be calculated. </span><span class="kobospan" id="kobo.12.3">Next, we will develop a genetic algorithm-based program to reconstruct a segment of a famous painting using polygons and examine </span><span><span class="kobospan" id="kobo.13.1">the results.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">In this chapter, we will cover the </span><span><span class="kobospan" id="kobo.15.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.16.1">Getting familiar with several image processing libraries </span><span><span class="kobospan" id="kobo.17.1">for Python</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.18.1">Understanding how to programmatically draw an image </span><span><span class="kobospan" id="kobo.19.1">using polygons</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.20.1">Finding out how to programmatically compare two </span><span><span class="kobospan" id="kobo.21.1">given images</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.22.1">Using genetic algorithms, in combination with image processing libraries, to reconstruct an image </span><span><span class="kobospan" id="kobo.23.1">using polygons</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">We will start this chapter by providing an overview of the image </span><span><span class="kobospan" id="kobo.25.1">reconstruction task.</span></span></p>
<h1 id="_idParaDest-315" class="calibre5"><a id="_idTextAnchor367" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.26.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">In this chapter, we will be using Python 3 with the following </span><span><span class="kobospan" id="kobo.28.1">supporting libraries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.29.1">deap</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.30.1">numpy</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.31.1">matplotlib</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.32.1">seaborn</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.33.1">pillow</span></strong><span class="kobospan" id="kobo.34.1"> – introduced in </span><span><span class="kobospan" id="kobo.35.1">this chapter</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.36.1">opencv-python (cv2)</span></strong><span class="kobospan" id="kobo.37.1"> – introduced in </span><span><span class="kobospan" id="kobo.38.1">this chapter</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.39.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.40.1">If you use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.41.1">requirements.txt</span></strong><span class="kobospan" id="kobo.42.1"> file we provide (see </span><a href="B20851_03.xhtml#_idTextAnchor091" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.43.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.44.1">), these libraries are already included in </span><span><span class="kobospan" id="kobo.45.1">your environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">The programs that will be used in this chapter can be found in this book’s GitHub repository </span><span><span class="kobospan" id="kobo.47.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_15" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.48.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_15</span></span></a><span><span class="kobospan" id="kobo.49.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">Check out the following video to see the code </span><span><span class="kobospan" id="kobo.51.1">in action:</span></span></p>
<p class="calibre3"><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.52.1">https://packt.link/OEBOd</span></span></a></p>
<h1 id="_idParaDest-316" class="calibre5"><a id="_idTextAnchor368" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.53.1">Reconstructing images with polygons</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">One of the</span><a id="_idIndexMarker907" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.55.1"> most captivating applications of genetic algorithms in image processing is reconstructing a given image using a collection of semi-transparent, overlapping shapes. </span><span class="kobospan" id="kobo.55.2">This approach is not only enjoyable and educational in </span><a id="_idIndexMarker908" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.56.1">terms of image processing experience but also offers a compelling visual representation of the evolutionary process. </span><span class="kobospan" id="kobo.56.2">Furthermore, these experiments can lead to a deeper understanding of visual arts and potentially contribute to advancements in image analysis </span><span><span class="kobospan" id="kobo.57.1">and compression.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">In these image reconstruction experiments – multiple variations of which can be found on the internet – a familiar image, often a famous painting or a fragment of it, is used as a reference. </span><span class="kobospan" id="kobo.58.2">The goal is to construct a similar image by assembling a collection of overlapping shapes, typically polygons, of varying colors </span><span><span class="kobospan" id="kobo.59.1">and transparencies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.60.1">Here, we will address this challenge by utilizing the genetic algorithms approach and the </span><strong class="source-inline"><span class="kobospan" id="kobo.61.1">deap</span></strong><span class="kobospan" id="kobo.62.1"> library, just like we’ve done for numerous types of problems throughout this book. </span><span class="kobospan" id="kobo.62.2">However, since we will need to draw images and compare them to a reference image, let’s get acquainted with the basics of image processing </span><span><span class="kobospan" id="kobo.63.1">in Python.</span></span></p>
<h1 id="_idParaDest-317" class="calibre5"><a id="_idTextAnchor369" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.64.1">Image processing in Python</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">To </span><a id="_idIndexMarker909" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.66.1">achieve our goal, we will need to carry out various image processing operations; for example, we will need to create an image from scratch, draw shapes onto an image, plot an image, open an image file, save an image to a file, compare two images, and possibly resize an image. </span><span class="kobospan" id="kobo.66.2">In the following sections, we will explore some of the ways these operations can be performed when </span><span><span class="kobospan" id="kobo.67.1">using Python.</span></span></p>
<h2 id="_idParaDest-318" class="calibre7"><a id="_idTextAnchor370" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.68.1">Python image processing libraries</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.69.1">Out of </span><a id="_idIndexMarker910" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.70.1">the wealth of image processing libraries available for Python programmers, we chose to use two of the most </span><a id="_idIndexMarker911" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.71.1">prominent ones. </span><span class="kobospan" id="kobo.71.2">These libraries will be briefly discussed in the </span><span><span class="kobospan" id="kobo.72.1">following subsections.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.73.1">The Pillow library</span></h3>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.74.1">Pillow</span></em><span class="kobospan" id="kobo.75.1"> is a</span><a id="_idIndexMarker912" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.76.1"> currently maintained fork of the original </span><em class="italic"><span class="kobospan" id="kobo.77.1">Python Imaging Library</span></em><span class="kobospan" id="kobo.78.1"> (</span><strong class="source-inline"><span class="kobospan" id="kobo.79.1">PIL</span></strong><span class="kobospan" id="kobo.80.1">). </span><span class="kobospan" id="kobo.80.2">It offers support for opening, manipulating, and saving image files of various formats. </span><span class="kobospan" id="kobo.80.3">Since it allows us to handle image</span><a id="_idIndexMarker913" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.81.1"> files, draw shapes, control their transparency, and manipulate pixels, we will use it as our main tool in creating the </span><span><span class="kobospan" id="kobo.82.1">reconstructed image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.83.1">The home page of this </span><a id="_idIndexMarker914" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.84.1">library can be found at </span><a href="https://python-pillow.org/" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.85.1">https://python-pillow.org/</span></a><span class="kobospan" id="kobo.86.1">. </span><span class="kobospan" id="kobo.86.2">A typical installation of Pillow uses the </span><strong class="source-inline"><span class="kobospan" id="kobo.87.1">pip</span></strong><span class="kobospan" id="kobo.88.1"> command, </span><span><span class="kobospan" id="kobo.89.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.90.1">
pip install Pillow</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.91.1">The Pillow library uses the </span><strong class="source-inline"><span class="kobospan" id="kobo.92.1">PIL</span></strong><span class="kobospan" id="kobo.93.1"> namespace. </span><span class="kobospan" id="kobo.93.2">If you have the original </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">PIL</span></strong><span class="kobospan" id="kobo.95.1"> library already installed, you will have to uninstall it first. </span><span class="kobospan" id="kobo.95.2">More information can be found in the documentation, which is located </span><span><span class="kobospan" id="kobo.96.1">at </span></span><a href="https://pillow.readthedocs.io/en/stable/index.html" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.97.1">https://pillow.readthedocs.io/en/stable/index.html</span></span></a><span><span class="kobospan" id="kobo.98.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.99.1">The OpenCV-Python library</span></h3>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.100.1">OpenCV</span></em><span class="kobospan" id="kobo.101.1"> is an </span><a id="_idIndexMarker915" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.102.1">elaborate library that provides numerous algorithms related to computer vision and</span><a id="_idIndexMarker916" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.103.1"> machine learning. </span><span class="kobospan" id="kobo.103.2">It supports a wide variety of programming languages and is available on different </span><a id="_idIndexMarker917" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.104.1">platforms. </span><em class="italic"><span class="kobospan" id="kobo.105.1">OpenCV-Python</span></em><span class="kobospan" id="kobo.106.1"> is the Python API for this library. </span><span class="kobospan" id="kobo.106.2">It combines the speed of the C++ API with the ease of use of the Python language. </span><span class="kobospan" id="kobo.106.3">Here, we will mainly make use of this library to calculate the difference between two images, since it allows us to represent an image as a numeric array. </span><span class="kobospan" id="kobo.106.4">We will also use its </span><strong class="source-inline"><span class="kobospan" id="kobo.107.1">GaussianBlur</span></strong><span class="kobospan" id="kobo.108.1"> function, which produces a blurred version of </span><span><span class="kobospan" id="kobo.109.1">an image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">The home page</span><a id="_idIndexMarker918" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.111.1"> of OpenCV-Python can be found </span><span><span class="kobospan" id="kobo.112.1">here: </span></span><a href="https://github.com/opencv/opencv-python" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.113.1">https://github.com/opencv/opencv-python</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.114.1">The library consists of four different packages, all of which use the same namespace (</span><strong class="source-inline"><span class="kobospan" id="kobo.115.1">cv2</span></strong><span class="kobospan" id="kobo.116.1">). </span><span class="kobospan" id="kobo.116.2">Only one of these packages should be selected to be installed in a single environment. </span><span class="kobospan" id="kobo.116.3">For our purposes, we can use the following command, which only installs the </span><span><span class="kobospan" id="kobo.117.1">main modules:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.118.1">
pip install opencv-python</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.119.1">More information can be found in the OpenCV documentation, which is located </span><span><span class="kobospan" id="kobo.120.1">at </span></span><a href="https://docs.opencv.org/master/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.121.1">https://docs.opencv.org/master/</span></span></a><span><span class="kobospan" id="kobo.122.1">.</span></span></p>
<h2 id="_idParaDest-319" class="calibre7"><a id="_idTextAnchor371" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.123.1">Drawing images with polygons</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.124.1">To </span><a id="_idIndexMarker919" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.125.1">draw an image from scratch, we can use </span><em class="italic"><span class="kobospan" id="kobo.126.1">Pillow</span></em><span class="kobospan" id="kobo.127.1">’s </span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">Image</span></strong><span class="kobospan" id="kobo.129.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.130.1">ImageDraw</span></strong><span class="kobospan" id="kobo.131.1"> classes </span><span><span class="kobospan" id="kobo.132.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.133.1">
image = </span><strong class="bold1"><span class="kobospan1" id="kobo.134.1">Image</span></strong><span class="kobospan1" id="kobo.135.1">.new('RGB', (width, height))
draw = </span><strong class="bold1"><span class="kobospan1" id="kobo.136.1">ImageDraw</span></strong><span class="kobospan1" id="kobo.137.1">.Draw(image, 'RGBA')</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.138.1">'RGB'</span></strong><span class="kobospan" id="kobo.139.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.140.1">'RGBA'</span></strong><span class="kobospan" id="kobo.141.1"> are the values for the </span><strong class="source-inline"><span class="kobospan" id="kobo.142.1">mode</span></strong><span class="kobospan" id="kobo.143.1"> argument. </span><span class="kobospan" id="kobo.143.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.144.1">'RGB'</span></strong><span class="kobospan" id="kobo.145.1"> value indicates three 8-bit values per pixel – one for each of the colors of red (R), green (G), and blue (B). </span><span class="kobospan" id="kobo.145.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">'RGBA'</span></strong><span class="kobospan" id="kobo.147.1"> value adds a fourth 8-bit value (A) representing the </span><em class="italic"><span class="kobospan" id="kobo.148.1">alpha</span></em><span class="kobospan" id="kobo.149.1"> (opacity) level of the drawings to be added. </span><span class="kobospan" id="kobo.149.2">The combination of an RGB base image and an RGBA drawing will allow us to draw polygons of varying degrees of transparency on top of a </span><span><span class="kobospan" id="kobo.150.1">black background.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.151.1">Now, we can add a polygon to the base image by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.152.1">ImageDraw</span></strong><span class="kobospan" id="kobo.153.1"> class’s </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">polygon</span></strong><span class="kobospan" id="kobo.155.1"> function, as shown in the following example. </span><span class="kobospan" id="kobo.155.2">The following statement will draw a triangle on </span><span><span class="kobospan" id="kobo.156.1">the image:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.157.1">
draw.</span><strong class="bold1"><span class="kobospan1" id="kobo.158.1">polygon</span></strong><span class="kobospan1" id="kobo.159.1">([(x1, y1), (x2, y2), (x3, y3)], (red, green, blue, 
    alpha))</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.160.1">The following list explains the </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">polygon</span></strong><span class="kobospan" id="kobo.162.1"> function arguments in </span><span><span class="kobospan" id="kobo.163.1">more detail:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.164.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.165.1">(x1, y1)</span></strong><span class="kobospan" id="kobo.166.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.167.1">(x2, y2)</span></strong><span class="kobospan" id="kobo.168.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.169.1">(x3, y3)</span></strong><span class="kobospan" id="kobo.170.1"> tuples represent the triangle’s three vertices. </span><span class="kobospan" id="kobo.170.2">Each tuple contains the </span><em class="italic"><span class="kobospan" id="kobo.171.1">x, y</span></em><span class="kobospan" id="kobo.172.1"> coordinates of the corresponding vertex within </span><span><span class="kobospan" id="kobo.173.1">the image.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.174.1">red</span></strong><span class="kobospan" id="kobo.175.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.176.1">green</span></strong><span class="kobospan" id="kobo.177.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.178.1">blue</span></strong><span class="kobospan" id="kobo.179.1"> are integer values in the range of [0, 255], each representing the intensity of the corresponding color of </span><span><span class="kobospan" id="kobo.180.1">the polygon.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.181.1">Alp~ha</span></strong><span class="kobospan" id="kobo.182.1"> is an integer value in the range of [0, 255], representing the opacity value of the polygon (a lower value means </span><span><span class="kobospan" id="kobo.183.1">more transparency).</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.184.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.185.1">To draw a polygon with more vertices, we would need to add more </span><span><span class="kobospan" id="kobo.186.1">(</span></span><span><span class="kobospan" id="kobo.187.1">x</span></span><span><span class="kobospan" id="kobo.188.1"> </span></span><span><span class="kobospan" id="kobo.189.1">i</span></span><span class="kobospan" id="kobo.190.1">, </span><span><span class="kobospan" id="kobo.191.1">y</span></span><span><span class="kobospan" id="kobo.192.1"> </span></span><span><span class="kobospan" id="kobo.193.1">i</span></span><span><span class="kobospan" id="kobo.194.1">)</span></span><span class="kobospan" id="kobo.195.1"> tuples to </span><span><span class="kobospan" id="kobo.196.1">the list.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.197.1">Using </span><a id="_idIndexMarker920" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.198.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">polygon</span></strong><span class="kobospan" id="kobo.200.1"> function repetitively, we can add more and more polygons, all drawn onto the same image and possibly overlapping each other, as shown in the </span><span><span class="kobospan" id="kobo.201.1">following figure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer157">
<span class="kobospan" id="kobo.202.1"><img alt="Figure 15.1: A plot of overlapping polygons with varying colors and opacity values" src="image/B20851_15_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.203.1">Figure 15.1: A plot of overlapping polygons with varying colors and opacity values</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.204.1">Once we draw an image using polygons, we need to compare it to the reference image, as described in the </span><span><span class="kobospan" id="kobo.205.1">next subsection.</span></span></p>
<h2 id="_idParaDest-320" class="calibre7"><a id="_idTextAnchor372" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.206.1">Measuring the difference between images</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.207.1">Since we</span><a id="_idIndexMarker921" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.208.1"> would like to construct an image that is as similar as possible to the original one, we need a way to evaluate the similarity or the difference between the two given images. </span><span class="kobospan" id="kobo.208.2">The most common method to evaluate the similarity between images is the pixel-based </span><strong class="bold"><span class="kobospan" id="kobo.209.1">mean squared error</span></strong><span class="kobospan" id="kobo.210.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.211.1">MSE</span></strong><span class="kobospan" id="kobo.212.1">), which</span><a id="_idIndexMarker922" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.213.1"> involves conducting a pixel-by-pixel comparison. </span><span class="kobospan" id="kobo.213.2">This requires, of course, that both images are of the same dimensions. </span><span class="kobospan" id="kobo.213.3">The MSE metric can be calculated </span><span><span class="kobospan" id="kobo.214.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.215.1">Calculate the square of the difference between each pair of matching pixels from both images. </span><span class="kobospan" id="kobo.215.2">Since each pixel in the drawing is represented using three separate values – red, green, and blue – the difference for each pixel is calculated across these </span><span><span class="kobospan" id="kobo.216.1">three dimensions.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.217.1">Compute the sum of all </span><span><span class="kobospan" id="kobo.218.1">these squares.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.219.1">Divide the sum by the total number </span><span><span class="kobospan" id="kobo.220.1">of pixels.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.221.1">When both images are represented using the OpenCV (cv2) library, which essentially represents an image as a numeric array, this calculation can be performed in a straightforward manner </span><span><span class="kobospan" id="kobo.222.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.223.1">
MSE = np.</span><strong class="bold1"><span class="kobospan1" id="kobo.224.1">sum</span></strong><span class="kobospan1" id="kobo.225.1">(
    (cv2Image1.astype("float") -
     cv2Image2.astype("float"))</span><strong class="bold1"><span class="kobospan1" id="kobo.226.1">**2</span></strong><span class="kobospan1" id="kobo.227.1">)/float(</span><strong class="bold1"><span class="kobospan1" id="kobo.228.1">numPixels</span></strong><span class="kobospan1" id="kobo.229.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.230.1">When the </span><a id="_idIndexMarker923" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.231.1">two images are identical, the MSE value will be zero. </span><span class="kobospan" id="kobo.231.2">Consequently, minimizing this metric can be used as the objective of our algorithm, which will be further discussed in the </span><span><span class="kobospan" id="kobo.232.1">next section.</span></span></p>
<h1 id="_idParaDest-321" class="calibre5"><a id="_idTextAnchor373" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.233.1">Using genetic algorithms to reconstruct images</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.234.1">As we </span><a id="_idIndexMarker924" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.235.1">discussed previously, our goal in this experiment is to use a familiar image as a reference</span><a id="_idIndexMarker925" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.236.1"> and create a second image, as similar as possible to the reference, using a collection of overlapping polygons of varying colors and transparencies. </span><span class="kobospan" id="kobo.236.2">Using the genetic algorithms approach, each candidate solution is a set of such polygons, and evaluating the solution is carried out by creating an image using these polygons and comparing it to the </span><span><span class="kobospan" id="kobo.237.1">reference image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.238.1">As usual, the first decision we need to make is how these solutions are represented. </span><span class="kobospan" id="kobo.238.2">We will discuss this in the </span><span><span class="kobospan" id="kobo.239.1">next subsection.</span></span></p>
<h2 id="_idParaDest-322" class="calibre7"><a id="_idTextAnchor374" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.240.1">Solution representation and evaluation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.241.1">As </span><a id="_idIndexMarker926" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.242.1">we mentioned previously, our solution consists of a set of polygons within the image boundaries. </span><span class="kobospan" id="kobo.242.2">Each polygon has its own color and transparency. </span><span class="kobospan" id="kobo.242.3">Drawing such a polygon using the Pillow library requires the </span><span><span class="kobospan" id="kobo.243.1">following arguments:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.244.1">A list of tuple, </span><span><span class="kobospan" id="kobo.245.1">[</span></span><span><span class="kobospan" id="kobo.246.1">(</span></span><span><span class="kobospan" id="kobo.247.1">x</span></span><span><span class="kobospan" id="kobo.248.1"> </span></span><span><span class="kobospan" id="kobo.249.1">1</span></span><span><span class="kobospan" id="kobo.250.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.251.1">y</span></span><span><span class="kobospan" id="kobo.252.1"> </span></span><span><span class="kobospan" id="kobo.253.1">1</span></span><span><span class="kobospan" id="kobo.254.1">)</span></span><span><span class="kobospan" id="kobo.255.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.256.1">(</span></span><span><span class="kobospan" id="kobo.257.1">x</span></span><span><span class="kobospan" id="kobo.258.1"> </span></span><span><span class="kobospan" id="kobo.259.1">2</span></span><span><span class="kobospan" id="kobo.260.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.261.1">y</span></span><span><span class="kobospan" id="kobo.262.1"> </span></span><span><span class="kobospan" id="kobo.263.1">2</span></span><span><span class="kobospan" id="kobo.264.1">)</span></span><span><span class="kobospan" id="kobo.265.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.266.1">…</span></span><span> </span><span><span class="kobospan" id="kobo.267.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.268.1">(</span></span><span><span class="kobospan" id="kobo.269.1">x</span></span><span><span class="kobospan" id="kobo.270.1"> </span></span><span><span class="kobospan" id="kobo.271.1">n</span></span><span><span class="kobospan" id="kobo.272.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.273.1">y</span></span><span><span class="kobospan" id="kobo.274.1"> </span></span><span><span class="kobospan" id="kobo.275.1">n</span></span><span><span class="kobospan" id="kobo.276.1">)</span></span><span><span class="kobospan" id="kobo.277.1">]</span></span><span class="kobospan" id="kobo.278.1">, representing the vertices of the polygon. </span><span class="kobospan" id="kobo.278.2">Each tuple contains the </span><em class="italic"><span class="kobospan" id="kobo.279.1">x, y</span></em><span class="kobospan" id="kobo.280.1"> coordinates of the corresponding vertex within the image. </span><span class="kobospan" id="kobo.280.2">Therefore, the values of the </span><em class="italic"><span class="kobospan" id="kobo.281.1">x</span></em><span class="kobospan" id="kobo.282.1"> coordinates are in the range [0, image width – 1], while the values of the </span><em class="italic"><span class="kobospan" id="kobo.283.1">y</span></em><span class="kobospan" id="kobo.284.1"> coordinates are in the range [0, image height – </span><span><span class="kobospan" id="kobo.285.1">1].</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.286.1">Three integer values in the range of [0, 255], representing the </span><em class="italic"><span class="kobospan" id="kobo.287.1">red</span></em><span class="kobospan" id="kobo.288.1">, </span><em class="italic"><span class="kobospan" id="kobo.289.1">green</span></em><span class="kobospan" id="kobo.290.1">, and </span><em class="italic"><span class="kobospan" id="kobo.291.1">blue</span></em><span class="kobospan" id="kobo.292.1"> components of the </span><span><span class="kobospan" id="kobo.293.1">polygon’s color.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.294.1">An additional integer value in the range of [0, 255], representing the </span><em class="italic"><span class="kobospan" id="kobo.295.1">alpha</span></em><span class="kobospan" id="kobo.296.1"> – or opacity – value of </span><span><span class="kobospan" id="kobo.297.1">the polygon.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.298.1">This </span><a id="_idIndexMarker927" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.299.1">means that for each polygon in our collection, we will need </span><span><span class="kobospan" id="kobo.300.1">[</span></span><span><span class="kobospan" id="kobo.301.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.302.1">×</span></span><span> </span><span><span class="kobospan" id="kobo.303.1">(</span></span><span><span class="kobospan" id="kobo.304.1">p</span></span><span><span class="kobospan" id="kobo.305.1">o</span></span><span><span class="kobospan" id="kobo.306.1">l</span></span><span><span class="kobospan" id="kobo.307.1">y</span></span><span><span class="kobospan" id="kobo.308.1">g</span></span><span><span class="kobospan" id="kobo.309.1">o</span></span><span> </span><span><span class="kobospan" id="kobo.310.1">n</span></span><span><span class="kobospan" id="kobo.311.1"> </span></span><span><span class="kobospan" id="kobo.312.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.313.1">s</span></span><span><span class="kobospan" id="kobo.314.1">i</span></span><span><span class="kobospan" id="kobo.315.1">z</span></span><span><span class="kobospan" id="kobo.316.1">e</span></span><span><span class="kobospan" id="kobo.317.1">)</span></span><span> </span><span><span class="kobospan" id="kobo.318.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.319.1">4</span></span><span><span class="kobospan" id="kobo.320.1">]</span></span><span class="kobospan" id="kobo.321.1"> parameters. </span><span class="kobospan" id="kobo.321.2">A </span><em class="italic"><span class="kobospan" id="kobo.322.1">triangle</span></em><span class="kobospan" id="kobo.323.1">, for example, will require 10 parameters (2x3+4), while a </span><em class="italic"><span class="kobospan" id="kobo.324.1">hexagon</span></em><span class="kobospan" id="kobo.325.1"> will require 16 parameters (2x6+4). </span><span class="kobospan" id="kobo.325.2">Consequently, a collection of triangles will be represented using a list in the following format, where every 10 parameters represent a </span><span><span class="kobospan" id="kobo.326.1">single triangle:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.327.1">[</span></span><span><span class="kobospan" id="kobo.328.1">x</span></span><span><span class="kobospan" id="kobo.329.1"> </span></span><span><span class="kobospan" id="kobo.330.1">11</span></span><span><span class="kobospan" id="kobo.331.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.332.1">y</span></span><span><span class="kobospan" id="kobo.333.1"> </span></span><span><span class="kobospan" id="kobo.334.1">11</span></span><span><span class="kobospan" id="kobo.335.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.336.1">x</span></span><span><span class="kobospan" id="kobo.337.1"> </span></span><span><span class="kobospan" id="kobo.338.1">12</span></span><span><span class="kobospan" id="kobo.339.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.340.1">y</span></span><span><span class="kobospan" id="kobo.341.1"> </span></span><span><span class="kobospan" id="kobo.342.1">12</span></span><span><span class="kobospan" id="kobo.343.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.344.1">x</span></span><span><span class="kobospan" id="kobo.345.1"> </span></span><span><span class="kobospan" id="kobo.346.1">13</span></span><span><span class="kobospan" id="kobo.347.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.348.1">y</span></span><span><span class="kobospan" id="kobo.349.1"> </span></span><span><span class="kobospan" id="kobo.350.1">13</span></span><span><span class="kobospan" id="kobo.351.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.352.1">r</span></span><span><span class="kobospan" id="kobo.353.1"> </span></span><span><span class="kobospan" id="kobo.354.1">1</span></span><span><span class="kobospan" id="kobo.355.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.356.1">g</span></span><span><span class="kobospan" id="kobo.357.1"> </span></span><span><span class="kobospan" id="kobo.358.1">1</span></span><span><span class="kobospan" id="kobo.359.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.360.1">b</span></span><span><span class="kobospan" id="kobo.361.1"> </span></span><span><span class="kobospan" id="kobo.362.1">1</span></span><span><span class="kobospan" id="kobo.363.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.364.1">a</span></span><span><span class="kobospan" id="kobo.365.1">l</span></span><span><span class="kobospan" id="kobo.366.1">p</span></span><span><span class="kobospan" id="kobo.367.1">h</span></span><span> </span><span><span class="kobospan" id="kobo.368.1">a</span></span><span><span class="kobospan" id="kobo.369.1"> </span></span><span><span class="kobospan" id="kobo.370.1">1</span></span><span><span class="kobospan" id="kobo.371.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.372.1">x</span></span><span><span class="kobospan" id="kobo.373.1"> </span></span><span><span class="kobospan" id="kobo.374.1">21</span></span><span><span class="kobospan" id="kobo.375.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.376.1">y</span></span><span><span class="kobospan" id="kobo.377.1"> </span></span><span><span class="kobospan" id="kobo.378.1">21</span></span><span><span class="kobospan" id="kobo.379.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.380.1">x</span></span><span><span class="kobospan" id="kobo.381.1"> </span></span><span><span class="kobospan" id="kobo.382.1">22</span></span><span><span class="kobospan" id="kobo.383.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.384.1">y</span></span><span><span class="kobospan" id="kobo.385.1"> </span></span><span><span class="kobospan" id="kobo.386.1">22</span></span><span><span class="kobospan" id="kobo.387.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.388.1">x</span></span><span><span class="kobospan" id="kobo.389.1"> </span></span><span><span class="kobospan" id="kobo.390.1">23</span></span><span><span class="kobospan" id="kobo.391.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.392.1">y</span></span><span><span class="kobospan" id="kobo.393.1"> </span></span><span><span class="kobospan" id="kobo.394.1">23</span></span><span><span class="kobospan" id="kobo.395.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.396.1">r</span></span><span><span class="kobospan" id="kobo.397.1"> </span></span><span><span class="kobospan" id="kobo.398.1">2</span></span><span><span class="kobospan" id="kobo.399.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.400.1">g</span></span><span><span class="kobospan" id="kobo.401.1"> </span></span><span><span class="kobospan" id="kobo.402.1">2</span></span><span><span class="kobospan" id="kobo.403.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.404.1">b</span></span><span><span class="kobospan" id="kobo.405.1"> </span></span><span><span class="kobospan" id="kobo.406.1">2</span></span><span><span class="kobospan" id="kobo.407.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.408.1">a</span></span><span><span class="kobospan" id="kobo.409.1">l</span></span><span><span class="kobospan" id="kobo.410.1">p</span></span><span><span class="kobospan" id="kobo.411.1">h</span></span><span> </span><span><span class="kobospan" id="kobo.412.1">a</span></span><span><span class="kobospan" id="kobo.413.1"> </span></span><span><span><span class="kobospan" id="kobo.414.1">2</span></span></span><span><span><span class="kobospan" id="kobo.415.1">,</span></span></span><span><span> </span></span><span><span><span class="kobospan" id="kobo.416.1">…</span></span></span><span><span><span class="kobospan" id="kobo.417.1">]</span></span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">To simplify this representation, we will use float numbers in the range of [0, 1] for each of the parameters. </span><span class="kobospan" id="kobo.418.2">Before drawing the polygons, we will expand each parameter accordingly so that it fits within its required range – image width and height for the coordinates of the vertices and [0, 255] for the colors and </span><span><span class="kobospan" id="kobo.419.1">opacity values.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.420.1">Using this representation, a collection of 50 triangles will be represented as a list of 500 float values between 0 and 1, </span><span><span class="kobospan" id="kobo.421.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.422.1">
[0.1499488467959301, 0.3812631075049196, 0.000439458056299,
0.9988170920722447, 0.9975357316889601, 0.9997461395379549,
...
</span><span class="kobospan1" id="kobo.422.2">0.9998952203500615, 0.48148512088979356, 0.083285509827404]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.423.1">Evaluating a given solution means dividing this long list into “chunks” representing individual polygons – in the case of triangles, each chunk will have a length of 10. </span><span class="kobospan" id="kobo.423.2">Then, we need to create a new, blank image and draw the various polygons from the list on top of it, one </span><span><span class="kobospan" id="kobo.424.1">by one.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">Finally, the difference between the resulting image and the original (reference) image needs to be calculated. </span><span class="kobospan" id="kobo.425.2">As discussed in the previous section, this will be done using the </span><span><span class="kobospan" id="kobo.426.1">pixel-based MSE.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">This (somewhat elaborate) score evaluation procedure is implemented by a Python class, which will be described in the </span><span><span class="kobospan" id="kobo.428.1">next subsection.</span></span></p>
<h2 id="_idParaDest-323" class="calibre7"><a id="_idTextAnchor375" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.429.1">Python problem representation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.430.1">To </span><a id="_idIndexMarker928" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.431.1">encapsulate the image reconstruction challenge, we’ve created a Python class called </span><strong class="source-inline"><span class="kobospan" id="kobo.432.1">ImageTest</span></strong><span class="kobospan" id="kobo.433.1">. </span><span class="kobospan" id="kobo.433.2">This class is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.434.1">image_test.py</span></strong><span class="kobospan" id="kobo.435.1"> file, which is located </span><span><span class="kobospan" id="kobo.436.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_15/image_test.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.437.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_15/image_test.py</span></span></a><span><span class="kobospan" id="kobo.438.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">The class is initialized with two parameters: the path of the file containing the reference image and the number of vertices of the polygons that are being used to construct the image. </span><span class="kobospan" id="kobo.439.2">The class provides the following </span><span><span class="kobospan" id="kobo.440.1">public methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.441.1">polygonDataToImage()</span></strong><span class="kobospan" id="kobo.442.1">: Accepts the list containing the polygon data we discussed in the previous subsection, divides this list into chunks representing individual polygons, and creates an image containing these polygons by drawing the polygons one by one onto a </span><span><span class="kobospan" id="kobo.443.1">blank image.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">getDifference()</span></strong><span class="kobospan" id="kobo.445.1">: Accepts polygon data, creates an image containing these polygons, and calculates the difference between this image and the reference image using the </span><span><em class="italic"><span class="kobospan" id="kobo.446.1">MSE</span></em></span><span><span class="kobospan" id="kobo.447.1"> method.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.448.1">blur()</span></strong><span class="kobospan" id="kobo.449.1">: Accepts an image in PIL format, converts it to OpenCV (cv2) format, and then applies Gaussian blurring. </span><span class="kobospan" id="kobo.449.2">The intensity of the blur is determined by the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.450.1">BLUR_KERNEL_SIZE</span></strong></span><span><span class="kobospan" id="kobo.451.1"> constant.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.452.1">plotImages()</span></strong><span class="kobospan" id="kobo.453.1">: For visual comparison purposes, creates a side-by-side plot of </span><span><span class="kobospan" id="kobo.454.1">three images:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.455.1">The reference image (to </span><span><span class="kobospan" id="kobo.456.1">the left)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.457.1">The given, polygon-reconstructed image (to </span><span><span class="kobospan" id="kobo.458.1">the right)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.459.1">A blurred version of the reconstructed image (in </span><span><span class="kobospan" id="kobo.460.1">the middle)</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.461.1">saveImage()</span></strong><span class="kobospan" id="kobo.462.1">: Accepts polygon data, creates an image containing these polygons, creates a side-by-side plot of this image next to the reference image, and saves the plot in </span><span><span class="kobospan" id="kobo.463.1">a file.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.464.1">During the run of the genetic algorithm, the </span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">saveImage()</span></strong><span class="kobospan" id="kobo.466.1"> method will be called every 100 generations in order to save a side-by-side image comparison representing a snapshot of the reconstruction process. </span><span class="kobospan" id="kobo.466.2">Calling this method will be carried out by a callback function, as described in the </span><span><span class="kobospan" id="kobo.467.1">next subsection.</span></span></p>
<h2 id="_idParaDest-324" class="calibre7"><a id="_idTextAnchor376" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.468.1">Genetic algorithm implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.469.1">To</span><a id="_idIndexMarker929" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.470.1"> reconstruct a given image with a set of semi-transparent overlapping polygons using a genetic algorithm, we’ve created a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">01_reconstruct_with_polygons.py</span></strong><span class="kobospan" id="kobo.472.1">, which is located </span><span><span class="kobospan" id="kobo.473.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_15/01_reconstruct_with_polygons.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.474.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_15/01_reconstruct_with_polygons.py</span></span></a><span><span class="kobospan" id="kobo.475.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.476.1">Since we are using a list of floats to represent a solution – the polygons’ vertices, colors, and transparency values – this program is very similar to the function optimization programs we saw in </span><a href="B20851_06.xhtml#_idTextAnchor197" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.477.1">Chapter 6</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.478.1">, Optimizing Continuous Functions</span></em><span class="kobospan" id="kobo.479.1">, such as the one we used for the </span><em class="italic"><span class="kobospan" id="kobo.480.1">Eggholder </span></em><span><em class="italic"><span class="kobospan" id="kobo.481.1">function</span></em></span><span><span class="kobospan" id="kobo.482.1">’s optimization.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.483.1">The following steps describe the main parts of </span><span><span class="kobospan" id="kobo.484.1">this program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.485.1">We start by setting the problem-related constant values. </span><strong class="source-inline1"><span class="kobospan" id="kobo.486.1">POLYGON_SIZE</span></strong><span class="kobospan" id="kobo.487.1"> determines the number of vertices for each polygon, while </span><strong class="source-inline1"><span class="kobospan" id="kobo.488.1">NUM_OF_POLYGONS</span></strong><span class="kobospan" id="kobo.489.1"> determines the total number of polygons that will be used to create the </span><span><span class="kobospan" id="kobo.490.1">reconstructed image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.491.1">
POLYGON_SIZE = 3
NUM_OF_POLYGONS = 100</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.492.1">After setting the genetic algorithm constants, we continue by creating an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.493.1">ImageTest</span></strong><span class="kobospan" id="kobo.494.1"> class, which will allow us to create images from polygons and compare these images to the reference image, as well as save snapshots of </span><span><span class="kobospan" id="kobo.495.1">our progress:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.496.1">
imageTest = image_test.ImageTest(MONA_LISA_PATH, POLYGON_SIZE)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.497.1">Next, we set the upper and lower boundaries for the float values we will be searching for. </span><span class="kobospan" id="kobo.497.2">As we mentioned previously, we will use float values for all our parameters and set them all to the same range, between 0.0 and 1.0, for convenience. </span><span class="kobospan" id="kobo.497.3">When evaluating a solution, the values will be expanded to their actual range, and converted into integers </span><span><span class="kobospan" id="kobo.498.1">when needed:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.499.1">
BOUNDS_LOW, BOUNDS_HIGH = 0.0, 1.0</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.500.1">Since </span><a id="_idIndexMarker930" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.501.1">our goal is to minimize the difference between the images – the reference image and the one we are creating using polygons – we define a single objective, </span><em class="italic"><span class="kobospan" id="kobo.502.1">minimizing</span></em> <span><span class="kobospan" id="kobo.503.1">fitness strategy:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.504.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.505.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.506.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.507.1">Now, we need to create a helper function that will create random real numbers that are uniformly distributed within a given range. </span><span class="kobospan" id="kobo.507.2">This function assumes that the range is the same for every dimension, as is the case in </span><span><span class="kobospan" id="kobo.508.1">our solution:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.509.1">
def randomFloat(low, up):
    return [random.</span><strong class="bold1"><span class="kobospan1" id="kobo.510.1">uniform</span></strong><span class="kobospan1" id="kobo.511.1">(l, u) for l, u in zip([</span><strong class="bold1"><span class="kobospan1" id="kobo.512.1">low</span></strong><span class="kobospan1" id="kobo.513.1">] * \
        NUM_OF_PARAMS, [</span><strong class="bold1"><span class="kobospan1" id="kobo.514.1">up</span></strong><span class="kobospan1" id="kobo.515.1">] * NUM_OF_PARAMS)]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.516.1">Next, we use the preceding function to create an operator that randomly returns a list of floats, all in the desired range of [</span><span><span class="kobospan" id="kobo.517.1">0, 1]:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.518.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.519.1">attrFloat</span></strong><span class="kobospan1" id="kobo.520.1">", randomFloat, BOUNDS_LOW, 
    BOUNDS_HIGH)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.521.1">This is followed by defining an operator that fills up an individual instance using the </span><span><span class="kobospan" id="kobo.522.1">preceding operator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.523.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.524.1">individualCreator</span></strong><span class="kobospan1" id="kobo.525.1">",
    tools.initIterate,
    creator.Individual,
    toolbox.attrFloat)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.526.1">Then, we instruct the genetic algorithm to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.527.1">getDiff()</span></strong><span class="kobospan" id="kobo.528.1"> method for fitness evaluation. </span><span class="kobospan" id="kobo.528.2">This, in turn, calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.529.1">getDifference()</span></strong><span class="kobospan" id="kobo.530.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.531.1">ImageTest</span></strong><span class="kobospan" id="kobo.532.1"> instance. </span><span class="kobospan" id="kobo.532.2">As a reminder, this method, which we described in the previous subsection, accepts an individual representing a list of polygons, creates</span><a id="_idIndexMarker931" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.533.1"> an image containing these polygons, and calculates the difference between this image and the reference image using the </span><span><em class="italic"><span class="kobospan" id="kobo.534.1">MSE</span></em></span><span><span class="kobospan" id="kobo.535.1"> method:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.536.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.537.1">getDiff</span></strong><span class="kobospan1" id="kobo.538.1">(individual):
    return imageTest.getDifference(individual, METRIC),
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.539.1">evaluate</span></strong><span class="kobospan1" id="kobo.540.1">", getDiff)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.541.1">It’s time to choose our genetic operators. </span><span class="kobospan" id="kobo.541.2">For the selection operator, we will use </span><em class="italic"><span class="kobospan" id="kobo.542.1">tournament selection</span></em><span class="kobospan" id="kobo.543.1"> with a tournament size of 2. </span><span class="kobospan" id="kobo.543.2">As we saw in </span><a href="B20851_04.xhtml#_idTextAnchor155" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.544.1">Chapter 4</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.545.1">, Combinatorial Optimization</span></em><span class="kobospan" id="kobo.546.1">, this selection scheme works well in conjunction with the </span><em class="italic"><span class="kobospan" id="kobo.547.1">elitist approach</span></em><span class="kobospan" id="kobo.548.1"> that we plan to utilize here </span><span><span class="kobospan" id="kobo.549.1">as well:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.550.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.551.1">select</span></strong><span class="kobospan1" id="kobo.552.1">", tools.selTournament, tournsize=2)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.553.1">As for the </span><em class="italic"><span class="kobospan" id="kobo.554.1">crossover</span></em><span class="kobospan" id="kobo.555.1"> operator (aliased with </span><strong class="source-inline1"><span class="kobospan" id="kobo.556.1">mate</span></strong><span class="kobospan" id="kobo.557.1">) and the </span><em class="italic"><span class="kobospan" id="kobo.558.1">mutation</span></em><span class="kobospan" id="kobo.559.1"> operator (</span><strong class="source-inline1"><span class="kobospan" id="kobo.560.1">mutate</span></strong><span class="kobospan" id="kobo.561.1">), since our solution representation is a list of floats bounded to a range, we will use the specialized continuous bounded operators provided by the DEAP framework – </span><strong class="source-inline1"><span class="kobospan" id="kobo.562.1">cxSimulatedBinaryBounded</span></strong><span class="kobospan" id="kobo.563.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.564.1">mutPolynomialBounded</span></strong><span class="kobospan" id="kobo.565.1">, respectively – which we first saw in </span><a href="B20851_06.xhtml#_idTextAnchor197" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.566.1">Chapter 6</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.567.1">, Optimizing </span></em><span><em class="italic"><span class="kobospan" id="kobo.568.1">Continuous Functions</span></em></span><span><span class="kobospan" id="kobo.569.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.570.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.571.1">mate</span></strong><span class="kobospan1" id="kobo.572.1">",
    tools.cxSimulatedBinaryBounded,
    low=BOUNDS_LOW,
    up=BOUNDS_HIGH,
    eta=CROWDING_FACTOR)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.573.1">mutate</span></strong><span class="kobospan1" id="kobo.574.1">",
    tools.mutPolynomialBounded,
    low=BOUNDS_LOW,
    up=BOUNDS_HIGH,
    eta=CROWDING_FACTOR,
    indpb=1.0/NUM_OF_PARAMS)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.575.1">As we </span><a id="_idIndexMarker932" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.576.1">have done multiple times before, we will use the </span><em class="italic"><span class="kobospan" id="kobo.577.1">elitist approach</span></em><span class="kobospan" id="kobo.578.1">, where the </span><strong class="bold"><span class="kobospan" id="kobo.579.1">hall of fame</span></strong><span class="kobospan" id="kobo.580.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.581.1">HOF</span></strong><span class="kobospan" id="kobo.582.1">) members – the current best individuals – are always passed untouched</span><a id="_idIndexMarker933" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.583.1"> to the next generation. </span><span class="kobospan" id="kobo.583.2">However, this time, we’re going to add a new feature to this implementation – a </span><em class="italic"><span class="kobospan" id="kobo.584.1">callback function</span></em><span class="kobospan" id="kobo.585.1"> that will be used to save the image every 100 generations (we will discuss this callback in more detail in the </span><span><span class="kobospan" id="kobo.586.1">next subsection):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.587.1">
population, logbook = \
    elitism_callback.</span><strong class="bold1"><span class="kobospan1" id="kobo.588.1">eaSimpleWithElitismAndCallback</span></strong><span class="kobospan1" id="kobo.589.1">(
        population,
        toolbox,
        cxpb=P_CROSSOVER,
        mutpb=P_MUTATION,
        ngen=MAX_GENERATIONS,
        callback=saveImage,
        stats=stats,
        halloffame=hof,
        verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.590.1">At the end of the run, we print the best solution and use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.591.1">plotImages()</span></strong><span class="kobospan" id="kobo.592.1"> function to show a side-by-side visual comparison to the </span><span><span class="kobospan" id="kobo.593.1">reference image:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.594.1">
best = hof.items[0]
print("Best Solution = ", best)
print("Best Score = ", best.fitness.values[0])
imageTest.</span><strong class="bold1"><span class="kobospan1" id="kobo.595.1">plotImages</span></strong><span class="kobospan1" id="kobo.596.1">(imageTest.polygonDataToImage(best))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.597.1">In addition, we </span><a id="_idIndexMarker934" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.598.1">have employed the multiprocessing method of using a process pool, as demonstrated and tested in </span><a href="B20851_13.xhtml#_idTextAnchor326" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.599.1">Chapter 13</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.600.1">, Accelerating Genetic Algorithms: The Power of Concurrency</span></em><span class="kobospan" id="kobo.601.1">. </span><span class="kobospan" id="kobo.601.2">This approach is a straightforward way to accelerate the execution of our algorithm. </span><span class="kobospan" id="kobo.601.3">It simply involves adding the following lines to encapsulate the call </span><span><span class="kobospan" id="kobo.602.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">eaSimpleWithElitismAndCallback()</span></strong></span><span><span class="kobospan" id="kobo.604.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.605.1">
with </span><strong class="bold1"><span class="kobospan1" id="kobo.606.1">multiprocessing.Pool</span></strong><span class="kobospan1" id="kobo.607.1">(processes=20) as </span><strong class="bold1"><span class="kobospan1" id="kobo.608.1">pool</span></strong><span class="kobospan1" id="kobo.609.1">:
    toolbox.register("map", </span><strong class="bold1"><span class="kobospan1" id="kobo.610.1">pool.map</span></strong><span class="kobospan1" id="kobo.611.1">)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.612.1">Before we look at the results, let’s discuss the implementation of the </span><span><span class="kobospan" id="kobo.613.1">callback function.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.614.1">Adding a callback to the genetic run</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.615.1">To be able</span><a id="_idIndexMarker935" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.616.1"> to save the best current image every 100 generations, we need to introduce a modification to the main genetic loop. </span><span class="kobospan" id="kobo.616.2">As you may recall, toward the end of </span><a href="B20851_04.xhtml#_idTextAnchor155" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.617.1">Chapter 4</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.618.1">, Combinatorial Optimization</span></em><span class="kobospan" id="kobo.619.1">, we already made one modification to </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">deap</span></strong><span class="kobospan" id="kobo.621.1">’s simple genetic algorithm main loop that allowed us to introduce the </span><em class="italic"><span class="kobospan" id="kobo.622.1">elitist approach</span></em><span class="kobospan" id="kobo.623.1">. </span><span class="kobospan" id="kobo.623.2">To be able to introduce that change, we created the </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">eaSimpleWithElitism()</span></strong><span class="kobospan" id="kobo.625.1"> method, which is contained in a file called </span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">elitism.py</span></strong><span class="kobospan" id="kobo.627.1">. </span><span class="kobospan" id="kobo.627.2">This method was a modified version of the DEAP framework’s </span><strong class="source-inline"><span class="kobospan" id="kobo.628.1">eaSimple()</span></strong><span class="kobospan" id="kobo.629.1"> method, which is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.630.1">algorithms.py</span></strong><span class="kobospan" id="kobo.631.1"> file. </span><span class="kobospan" id="kobo.631.2">We modified the original method by adding the elitism functionality, which takes the members of the HOF – the current best individuals – and passes them untouched to the next generation at every iteration of the loop. </span><span class="kobospan" id="kobo.631.3">Now, for the purpose of implementing a callback, we will introduce another small modification and change the name of the method to </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">eaSimpleWithElitismAndCallback()</span></strong><span class="kobospan" id="kobo.633.1">. </span><span class="kobospan" id="kobo.633.2">We will also rename the file containing it </span><span><span class="kobospan" id="kobo.634.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.635.1">elitism_and_callback.py</span></strong></span><span><span class="kobospan" id="kobo.636.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.637.1">There are two parts to this modification, </span><span><span class="kobospan" id="kobo.638.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.639.1">The first part of the modification consists of adding an argument called </span><strong class="source-inline1"><span class="kobospan" id="kobo.640.1">callback</span></strong><span class="kobospan" id="kobo.641.1"> to the </span><span><span class="kobospan" id="kobo.642.1">main-loop method:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.643.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.644.1">eaSimpleWithElitismAndCallback</span></strong><span class="kobospan1" id="kobo.645.1">(population,
    toolbox, cxpb, mutpb, ngen, </span><strong class="bold1"><span class="kobospan1" id="kobo.646.1">callback=None</span></strong><span class="kobospan1" id="kobo.647.1">,
    stats=None, halloffame=None, verbose=__debug__):</span></pre><p class="calibre3"><span class="kobospan" id="kobo.648.1">This new argument represents an external function that will be called after </span><span><span class="kobospan" id="kobo.649.1">each iteration.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.650.1">The other</span><a id="_idIndexMarker936" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.651.1"> part is within the method. </span><span class="kobospan" id="kobo.651.2">Here, the callback function is called after the new generation has been created and evaluated. </span><span class="kobospan" id="kobo.651.3">The current generation number and the current best individual are passed to the callback </span><span><span class="kobospan" id="kobo.652.1">as arguments:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.653.1">
if callback:
    </span><strong class="bold1"><span class="kobospan1" id="kobo.654.1">callback</span></strong><span class="kobospan1" id="kobo.655.1">(gen, halloffame.items[0])</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.656.1">Being able to define a callback function that will be called after each generation may prove useful in various situations. </span><span class="kobospan" id="kobo.656.2">To take advantage of it here, we’ll define the </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">saveImage()</span></strong><span class="kobospan" id="kobo.658.1"> function back in our </span><strong class="source-inline"><span class="kobospan" id="kobo.659.1">01_reconstruct_with_polygons.py</span></strong><span class="kobospan" id="kobo.660.1"> program. </span><span class="kobospan" id="kobo.660.2">We will use it to save a side-by-side image of the current best image and the reference image, every 100 generations, </span><span><span class="kobospan" id="kobo.661.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.662.1">We use the </span><em class="italic"><span class="kobospan" id="kobo.663.1">modulus</span></em><span class="kobospan" id="kobo.664.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.665.1">%</span></strong><span class="kobospan" id="kobo.666.1">) operator to activate the method only once every </span><span><span class="kobospan" id="kobo.667.1">100 generations:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.668.1">
if gen </span><strong class="bold1"><span class="kobospan1" id="kobo.669.1">%</span></strong><span class="kobospan1" id="kobo.670.1"> 100 == 0:</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.671.1">If this is one of these generations, we create a folder for the images if one does not exist. </span><span class="kobospan" id="kobo.671.2">The folder’s name references the polygon size and the number of polygons – for example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.672.1">run-3-100</span></strong><span class="kobospan" id="kobo.673.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.674.1">run-6-50</span></strong><span class="kobospan" id="kobo.675.1">, under the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.676.1">images/results/</span></strong></span><span><span class="kobospan" id="kobo.677.1"> path:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.678.1">
RESULTS_PATH = os.path.join(BASE_PATH, "results", 
    f"</span><strong class="bold1"><span class="kobospan1" id="kobo.679.1">run-{POLYGON_SIZE}-{NUM_OF_POLYGONS}</span></strong><span class="kobospan1" id="kobo.680.1">")
...
</span><span class="kobospan1" id="kobo.680.2">if not os.path.exists(RESULTS_PATH):
    os.</span><strong class="bold1"><span class="kobospan1" id="kobo.681.1">makedirs</span></strong><span class="kobospan1" id="kobo.682.1">(RESULTS_PATH)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.683.1">Next, we save the image of the best current individual in that folder. </span><span class="kobospan" id="kobo.683.2">The name of the image contains the number of generations that have been passed – for </span><span><span class="kobospan" id="kobo.684.1">example, </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.685.1">after-300-generations.png</span></strong></span><span><span class="kobospan" id="kobo.686.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.687.1">
imageTest.imageTest.</span><strong class="bold1"><span class="kobospan1" id="kobo.688.1">saveImage</span></strong><span class="kobospan1" id="kobo.689.1">(polygonData,
    os.path.join(</span><strong class="bold1"><span class="kobospan1" id="kobo.690.1">RESULTS_PATH</span></strong><span class="kobospan1" id="kobo.691.1">, f"</span><strong class="bold1"><span class="kobospan1" id="kobo.692.1">after-{gen}-gen.png</span></strong><span class="kobospan1" id="kobo.693.1">"),
    f"After {gen} Generations")</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.694.1">We are finally</span><a id="_idIndexMarker937" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.695.1"> ready to run this algorithm with reference images and check out </span><span><span class="kobospan" id="kobo.696.1">the results.</span></span></p>
<h2 id="_idParaDest-325" class="calibre7"><a id="_idTextAnchor377" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.697.1">Image reconstruction results</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.698.1">To test</span><a id="_idIndexMarker938" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.699.1"> our program, we will use a section of the famous Mona Lisa portrait by </span><em class="italic"><span class="kobospan" id="kobo.700.1">Leonardo da Vinci</span></em><span class="kobospan" id="kobo.701.1">, considered the most well-known painting in the world, as </span><span><span class="kobospan" id="kobo.702.1">seen here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer158">
<span class="kobospan" id="kobo.703.1"><img alt="Figure 15.2: Head crop of the Mona Lisa painting" src="image/B20851_15_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.704.1">Figure 15.2: Head crop of the Mona Lisa painting</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.705.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Mona_Lisa_headcrop.jpg" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.706.1">https://commons.wikimedia.org/wiki/File:Mona_Lisa_headcrop.jpg</span></a></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.707.1">Artist: Leonardo da Vinci. </span><span class="kobospan" id="kobo.707.2">Licensed under Creative Commons CC0 1.0: </span><a href="https://creativecommons.org/publicdomain/zero/1.0/" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.708.1">https://creativecommons.org/publicdomain/zero/1.0/</span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.709.1">Before proceeding with the program, it’s important to note that the extensive polygon data and complex image processing operations involved make the running time for our genetic image reconstruction experiments significantly longer than other programs tested earlier in this book. </span><span class="kobospan" id="kobo.709.2">These experiments could take several hours each </span><span><span class="kobospan" id="kobo.710.1">to complete.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.711.1">We will begin our image reconstruction using 100 triangles as </span><span><span class="kobospan" id="kobo.712.1">the polygons:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.713.1">
POLYGON_SIZE = 3
NUM_OF_POLYGONS = 100</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.714.1">The algorithm </span><a id="_idIndexMarker939" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.715.1">will run for 5,000 generations with a population size of 200. </span><span class="kobospan" id="kobo.715.2">As discussed earlier, a side-by-side image comparison is saved every 100 generations. </span><span class="kobospan" id="kobo.715.3">At the end of the run, we can review these saved images to observe the evolution of the </span><span><span class="kobospan" id="kobo.716.1">reconstructed image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.717.1">The following figure showcases various milestones from the resulting side-by-side saved images. </span><span class="kobospan" id="kobo.717.2">As mentioned before, the middle image in each row presents a blurred version of the reconstructed image. </span><span class="kobospan" id="kobo.717.3">This blurring aims to soften the sharp corners and straight lines that are typical of polygon-based reconstructions, creating an effect akin to squinting when viewing </span><span><span class="kobospan" id="kobo.718.1">the image:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer159">
<span class="kobospan" id="kobo.719.1"><img alt="Figure 15.3: Milestone results of Mona Lisa reconstruction using 100 triangles" src="image/B20851_15_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.720.1">Figure 15.3: Milestone results of Mona Lisa reconstruction using 100 triangles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.721.1">The end result bears a close resemblance to the original image and can be readily recognized as the </span><a id="_idIndexMarker940" class="calibre6 pcalibre pcalibre1"/><span><span class="kobospan" id="kobo.722.1">Mona Lisa.</span></span></p>
<h2 id="_idParaDest-326" class="calibre7"><a id="_idTextAnchor378" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.723.1">Reducing the triangle count</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.724.1">It is reasonable</span><a id="_idIndexMarker941" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.725.1"> to assume that the results would be even better when increasing the number of triangles. </span><span class="kobospan" id="kobo.725.2">But what if we wanted to </span><em class="italic"><span class="kobospan" id="kobo.726.1">minimize</span></em><span class="kobospan" id="kobo.727.1"> this number? </span><span class="kobospan" id="kobo.727.2">If we reduce the number of triangles to 20, we might still be able to tell that this is the Mona Lisa, as the following </span><span><span class="kobospan" id="kobo.728.1">results show:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer160">
<span class="kobospan" id="kobo.729.1"><img alt="Figure 15.4: Results of Mona Lisa reconstruction using 20 triangles and MSE" src="image/B20851_15_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.730.1">Figure 15.4: Results of Mona Lisa reconstruction using 20 triangles and MSE</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.731.1">However, when the triangle count is further reduced to 15, the results are no longer recognizable, as </span><span><span class="kobospan" id="kobo.732.1">seen here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer161">
<span class="kobospan" id="kobo.733.1"><img alt="Figure 15.5: Results of Mona Lisa reconstruction using 15 triangles and MSE" src="image/B20851_15_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.734.1">Figure 15.5: Results of Mona Lisa reconstruction using 15 triangles and MSE</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.735.1">A possible way </span><a id="_idIndexMarker942" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.736.1">to improve these results is described in the </span><span><span class="kobospan" id="kobo.737.1">next subsection.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.738.1">Blurring the fitness</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.739.1">Since the</span><a id="_idIndexMarker943" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.740.1"> reconstruction becomes significantly cruder when the triangle count is low, perhaps we can improve this result by basing the fitness on the similarity between the original image and the </span><em class="italic"><span class="kobospan" id="kobo.741.1">blurred version</span></em><span class="kobospan" id="kobo.742.1"> of the reconstructed image, which is less crude. </span><span class="kobospan" id="kobo.742.2">To try this out, we’ve created a slightly modified version of the original Python program, called </span><strong class="source-inline"><span class="kobospan" id="kobo.743.1">02_reconstruct_with_polygons_blur.py</span></strong><span class="kobospan" id="kobo.744.1">, which is located </span><span><span class="kobospan" id="kobo.745.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_15/02_reconstruct_with_polygons_blur.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.746.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_15/02_reconstruct_with_polygons_blur.py</span></span></a><span><span class="kobospan" id="kobo.747.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.748.1">The modifications are highlighted </span><span><span class="kobospan" id="kobo.749.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.750.1">The image comparison results of this program are saved into a separate directory </span><span><span class="kobospan" id="kobo.751.1">called </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.752.1">blur</span></strong></span><span><span class="kobospan" id="kobo.753.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.754.1">The fitness function calculation now includes an optional argument, </span><strong class="source-inline1"><span class="kobospan" id="kobo.755.1">blur=True</span></strong><span class="kobospan" id="kobo.756.1">, when calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.757.1">getDifference()</span></strong><span class="kobospan" id="kobo.758.1"> function. </span><span class="kobospan" id="kobo.758.2">Consequently, this function will call </span><strong class="source-inline1"><span class="kobospan" id="kobo.759.1">getMseBlur()</span></strong><span class="kobospan" id="kobo.760.1"> instead of the original </span><strong class="source-inline1"><span class="kobospan" id="kobo.761.1">getMse()</span></strong><span class="kobospan" id="kobo.762.1">. </span><span class="kobospan" id="kobo.762.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">getMseBlur()</span></strong><span class="kobospan" id="kobo.764.1"> function blurs the given image before calculating </span><span><span class="kobospan" id="kobo.765.1">the MSE:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.766.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.767.1">getMseBlur</span></strong><span class="kobospan1" id="kobo.768.1">(self, image):
    return np.sum(
        (self.</span><strong class="bold1"><span class="kobospan1" id="kobo.769.1">blur(image)</span></strong><span class="kobospan1" id="kobo.770.1">.astype("float") - 
         self.refImageCv2.astype("float")) ** 2
    ) / float(self.numPixels)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.771.1">The results </span><a id="_idIndexMarker944" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.772.1">of running this program for 20 triangles are shown in the </span><span><span class="kobospan" id="kobo.773.1">following figure:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer162">
<span class="kobospan" id="kobo.774.1"><img alt="Figure 15.6: Results of Mona Lisa reconstruction using 20 triangles and MSE with blur" src="image/B20851_15_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.775.1">Figure 15.6: Results of Mona Lisa reconstruction using 20 triangles and MSE with blur</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.776.1">Meanwhile, the results for 15 triangles are </span><span><span class="kobospan" id="kobo.777.1">shown here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer163">
<span class="kobospan" id="kobo.778.1"><img alt="Figure 15.7: Results of Mona Lisa reconstruction using 15 triangles and MSE with blur" src="image/B20851_15_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.779.1">Figure 15.7: Results of Mona Lisa reconstruction using 15 triangles and MSE with blur</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.780.1">The resulting images appear more recognizable, which makes this method a potentially viable way to achieve a lower </span><span><span class="kobospan" id="kobo.781.1">polygon count.</span></span></p>
<h2 id="_idParaDest-327" class="calibre7"><a id="_idTextAnchor379" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.782.1">Other experiments</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.783.1">There are</span><a id="_idIndexMarker945" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.784.1"> many variations that you can explore. </span><span class="kobospan" id="kobo.784.2">One straightforward variation is increasing the number of vertices in the polygons. </span><span class="kobospan" id="kobo.784.3">We anticipate more accurate results from this approach, as the shapes become more versatile. </span><span class="kobospan" id="kobo.784.4">However, it’s important to note that the size of the individual polygons grows, which typically necessitates a larger population and/or more generations to achieve </span><span><span class="kobospan" id="kobo.785.1">reasonable results.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.786.1">Another interesting variation is to apply the “blur” fitness, previously used to minimize the number of polygons, to a large polygon count. </span><span class="kobospan" id="kobo.786.2">This approach might lead to a somewhat “erratic” reconstruction, which is then smoothed by the blur function. </span><span class="kobospan" id="kobo.786.3">The following result illustrates this, using 100 hexagons with 400 individuals and 5,000 generations, employing the “blur” </span><span><span class="kobospan" id="kobo.787.1">MSE-based fitness:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer164">
<span class="kobospan" id="kobo.788.1"><img alt="Figure 15.8: Results of Mona Lisa reconstruction using 100 hexagons and MSE with blur" src="image/B20851_15_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.789.1">Figure 15.8: Results of Mona Lisa reconstruction using 100 hexagons and MSE with blur</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.790.1">There are many other possibilities and combinations to experiment with, such as </span><span><span class="kobospan" id="kobo.791.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.792.1">Increasing the number </span><span><span class="kobospan" id="kobo.793.1">of polygons</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.794.1">Changing the population size and the number </span><span><span class="kobospan" id="kobo.795.1">of generations</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.796.1">Using non-polygonal shapes (such as circles or ellipses) or regular shapes (such as squares or </span><span><span class="kobospan" id="kobo.797.1">equilateral triangles)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.798.1">Using </span><a id="_idIndexMarker946" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.799.1">different types of reference images (including paintings, drawings, photos, </span><span><span class="kobospan" id="kobo.800.1">and logos)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.801.1">Opting for grayscale images instead of </span><span><span class="kobospan" id="kobo.802.1">colored ones</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.803.1">Have fun creating and experimenting with your </span><span><span class="kobospan" id="kobo.804.1">own variations!</span></span></p>
<h1 id="_idParaDest-328" class="calibre5"><a id="_idTextAnchor380" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.805.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.806.1">In this chapter, you were introduced to the popular concept of reconstructing existing images with overlapping, semi-transparent polygons. </span><span class="kobospan" id="kobo.806.2">You explored various image processing libraries in Python, learning how to programmatically create images from scratch using polygons and calculate the difference between two images. </span><span class="kobospan" id="kobo.806.3">Subsequently, we developed a genetic algorithm-based program to reconstruct a segment of a famous painting using polygons and explored several variations in the process. </span><span class="kobospan" id="kobo.806.4">We also discussed numerous possibilities for </span><span><span class="kobospan" id="kobo.807.1">further experimentation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">In the next chapter, we will describe and demonstrate several problem-solving techniques related to genetic algorithms, as well as other biologically inspired </span><span><span class="kobospan" id="kobo.809.1">computational algorithms.</span></span></p>
<h1 id="_idParaDest-329" class="calibre5"><a id="_idTextAnchor381" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.810.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.811.1">For more information about the topics that were covered in this chapter, please refer to the </span><span><span class="kobospan" id="kobo.812.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.813.1">Hands-On Image Processing with Python</span></em><span class="kobospan" id="kobo.814.1">, Sandipan Dey, November </span><span><span class="kobospan" id="kobo.815.1">30, 2018</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.816.1">Grow Your Own </span></em><span><em class="italic"><span class="kobospan" id="kobo.817.1">Picture</span></em></span><span><span class="kobospan" id="kobo.818.1">: </span></span><a href="https://chriscummins.cc/s/genetics" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.819.1">https://chriscummins.cc/s/genetics</span></span></a></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.820.1">Genetic Programming: Evolution of Mona </span></em><span><em class="italic"><span class="kobospan" id="kobo.821.1">Lisa</span></em></span><span><span class="kobospan" id="kobo.822.1">: </span></span><a href="https://rogerjohansson.blog/2008/12/07/genetic-programming-evolution-of-mona-lisa/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.823.1">https://rogerjohansson.blog/2008/12/07/genetic-programming-evolution-of-mona-lisa/</span></span></a></li>
</ul>
</div>
</body></html>