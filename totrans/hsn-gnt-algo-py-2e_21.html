<html><head></head><body>
<div id="_idContainer174" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-330"><a id="_idTextAnchor382" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-331" class="calibre5"><a id="_idTextAnchor383" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Other Evolutionary and Bio-Inspired Computation Techniques</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, you will broaden your horizons and discover several new problem-solving and optimization techniques related to genetic algorithms. </span><span class="kobospan" id="kobo.3.2">Three different techniques of this extended family – </span><strong class="bold"><span class="kobospan" id="kobo.4.1">genetic programming</span></strong><span class="kobospan" id="kobo.5.1">, </span><strong class="bold"><span class="kobospan" id="kobo.6.1">NeuroEvolution of Augmenting Topologies</span></strong><span class="kobospan" id="kobo.7.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.8.1">NEAT</span></strong><span class="kobospan" id="kobo.9.1">), and </span><strong class="bold"><span class="kobospan" id="kobo.10.1">particle swarm optimization</span></strong><span class="kobospan" id="kobo.11.1"> – will be then demonstrated through the implementation of problem-solving Python programs. </span><span class="kobospan" id="kobo.11.2">Finally, we will provide a brief overview of several other related </span><span><span class="kobospan" id="kobo.12.1">computation paradigms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.13.1">This chapter will cover the </span><span><span class="kobospan" id="kobo.14.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.15.1">The evolutionary computation family </span><span><span class="kobospan" id="kobo.16.1">of algorithms</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">Understanding the concepts of </span><strong class="bold"><span class="kobospan" id="kobo.18.1">genetic programming</span></strong><span class="kobospan" id="kobo.19.1"> and how they differ from </span><span><span class="kobospan" id="kobo.20.1">genetic algorithms</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.21.1">Using genetic programming to solve the </span><strong class="bold"><span class="kobospan" id="kobo.22.1">even parity </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.23.1">check</span></strong></span><span><span class="kobospan" id="kobo.24.1"> problem</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.25.1">Understanding the concepts of </span><strong class="bold"><span class="kobospan" id="kobo.26.1">NEAT</span></strong><span class="kobospan" id="kobo.27.1"> and how they differ from </span><span><span class="kobospan" id="kobo.28.1">genetic algorithms</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.29.1">Using NEAT to solve the even parity </span><span><span class="kobospan" id="kobo.30.1">check problem</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.31.1">Understanding the concepts of particle </span><span><span class="kobospan" id="kobo.32.1">swarm optimization</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.33.1">Using particle swarm optimization to optimize </span><span><strong class="bold"><span class="kobospan" id="kobo.34.1">Himmelblau’s function</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.35.1">Understanding the principles behind several other evolutionary and </span><strong class="bold"><span class="kobospan" id="kobo.36.1">biologically </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.37.1">inspired techniques</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">We will start this chapter by unveiling the extended family of </span><strong class="bold"><span class="kobospan" id="kobo.39.1">evolutionary computation</span></strong><span class="kobospan" id="kobo.40.1"> and discussing the main characteristics shared by </span><span><span class="kobospan" id="kobo.41.1">its members.</span></span></p>
<h1 id="_idParaDest-332" class="calibre5"><a id="_idTextAnchor384" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.42.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">In this chapter, we will be using Python 3 alongside the following </span><span><span class="kobospan" id="kobo.44.1">supporting libraries:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.45.1">deap</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.46.1">numpy</span></strong></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.47.1">networkx</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.48.1">neatpy</span></strong><span class="kobospan" id="kobo.49.1"> – introduced in </span><span><span class="kobospan" id="kobo.50.1">this chapter</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.51.1">pygame</span></strong></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.52.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.53.1">If you’re using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.54.1">requirements.txt</span></strong><span class="kobospan" id="kobo.55.1"> file we’ve provided (see </span><a href="B20851_03.xhtml#_idTextAnchor091" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.56.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.57.1">), these libraries will already be in </span><span><span class="kobospan" id="kobo.58.1">your environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">The programs that will be used in this chapter can be found in this book’s GitHub repository </span><span><span class="kobospan" id="kobo.60.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_16" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.61.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_16</span></span></a><span><span class="kobospan" id="kobo.62.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">Check out the following video to see the Code in Action: </span></p>
<p class="calibre3"><a href="https://packt.link/OEBOd" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.64.1">https://packt.link/OEBOd</span></span></a><span><span class="kobospan" id="kobo.65.1">.</span></span></p>
<h1 id="_idParaDest-333" class="calibre5"><a id="_idTextAnchor385" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.66.1">Evolutionary computation and bio-inspired computing</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">Throughout this book, we have covered the problem-solving technique known as </span><em class="italic"><span class="kobospan" id="kobo.68.1">genetic algorithms</span></em><span class="kobospan" id="kobo.69.1"> and applied it to numerous types of problems, including </span><strong class="bold"><span class="kobospan" id="kobo.70.1">combinatorial optimization</span></strong><span class="kobospan" id="kobo.71.1">, </span><strong class="bold"><span class="kobospan" id="kobo.72.1">constraint satisfaction,</span></strong><span class="kobospan" id="kobo.73.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.74.1">continuous function optimization</span></strong><span class="kobospan" id="kobo.75.1">, as well as to </span><strong class="bold"><span class="kobospan" id="kobo.76.1">machine learning</span></strong><span class="kobospan" id="kobo.77.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.78.1">artificial intelligence</span></strong><span class="kobospan" id="kobo.79.1">. </span><span class="kobospan" id="kobo.79.2">However, as we mentioned in </span><a href="B20851_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.80.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.81.1">, </span><em class="italic"><span class="kobospan" id="kobo.82.1">An Introduction to Genetic Algorithms</span></em><span class="kobospan" id="kobo.83.1">, genetic algorithms are just one branch within a larger </span><a id="_idIndexMarker947" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.84.1">family of algorithms called </span><strong class="bold"><span class="kobospan" id="kobo.85.1">evolutionary computation</span></strong><span class="kobospan" id="kobo.86.1">. </span><span class="kobospan" id="kobo.86.2">This family consists of</span><a id="_idIndexMarker948" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.87.1"> various related problem-solving and optimization techniques, all of which draw inspiration from Charles Darwin’s theory of </span><span><span class="kobospan" id="kobo.88.1">natural evolution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.89.1">The main characteristics that are shared by these techniques are </span><span><span class="kobospan" id="kobo.90.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.91.1">The starting point is an initial set (</span><strong class="bold"><span class="kobospan" id="kobo.92.1">population</span></strong><span class="kobospan" id="kobo.93.1">) of </span><span><span class="kobospan" id="kobo.94.1">candidate solutions.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.95.1">The candidate solutions (</span><strong class="bold"><span class="kobospan" id="kobo.96.1">individuals</span></strong><span class="kobospan" id="kobo.97.1">) are updated iteratively to create </span><span><span class="kobospan" id="kobo.98.1">new generations.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.99.1">Creating a new generation involves removing less successful individuals (</span><strong class="bold"><span class="kobospan" id="kobo.100.1">selection</span></strong><span class="kobospan" id="kobo.101.1">), as well as introducing small random changes (</span><strong class="bold"><span class="kobospan" id="kobo.102.1">mutations</span></strong><span class="kobospan" id="kobo.103.1">) to some individuals. </span><span class="kobospan" id="kobo.103.2">Other operators, such </span><a id="_idIndexMarker949" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.104.1">as interaction with other individuals (</span><strong class="bold"><span class="kobospan" id="kobo.105.1">crossover</span></strong><span class="kobospan" id="kobo.106.1">), may also </span><span><span class="kobospan" id="kobo.107.1">be </span></span><span><a id="_idIndexMarker950" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.108.1">applied.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.109.1">As a result, as generations go by, the </span><strong class="bold"><span class="kobospan" id="kobo.110.1">fitness</span></strong><span class="kobospan" id="kobo.111.1"> of the population increases; in other words, the candidate solutions become better at solving the problem </span><span><span class="kobospan" id="kobo.112.1">at hand.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">More broadly, since evolutionary computation techniques are based on various biological systems or behaviors, they generally overlap with the algorithm family known as </span><span><strong class="bold"><span class="kobospan" id="kobo.114.1">bio-inspired computing</span></strong></span><span><span class="kobospan" id="kobo.115.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.116.1">In the following sections, we will cover some of the most frequently used members of evolutionary computation and bio-inspired computing – some will be covered in greater detail, while the others will only be mentioned briefly. </span><span class="kobospan" id="kobo.116.2">We will start by providing a detailed account of a fascinating technique that allows us to evolve actual computer programs: </span><span><strong class="bold"><span class="kobospan" id="kobo.117.1">genetic programming</span></strong></span><span><span class="kobospan" id="kobo.118.1">.</span></span></p>
<h1 id="_idParaDest-334" class="calibre5"><a id="_idTextAnchor386" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.119.1">Genetic programming</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">Genetic programming is a special form of genetic algorithm – that is, the technique we have been applying throughout this book. </span><span class="kobospan" id="kobo.120.2">In this special case, the candidate solutions – or individuals – that we are evolving</span><a id="_idIndexMarker951" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.121.1"> to find the best one for our purpose are computer programs, hence the name. </span><span class="kobospan" id="kobo.121.2">In other words, when we apply genetic programming, we evolve </span><em class="italic"><span class="kobospan" id="kobo.122.1">computer programs</span></em><span class="kobospan" id="kobo.123.1"> to find a program that will excel at performing a </span><span><span class="kobospan" id="kobo.124.1">particular task.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.125.1">As you may recall, genetic algorithms use a representation of the candidate solutions, often referred to as a </span><em class="italic"><span class="kobospan" id="kobo.126.1">chromosome</span></em><span class="kobospan" id="kobo.127.1">. </span><span class="kobospan" id="kobo.127.2">This representation is subject to genetic operators, namely </span><em class="italic"><span class="kobospan" id="kobo.128.1">selection</span></em><span class="kobospan" id="kobo.129.1">, </span><em class="italic"><span class="kobospan" id="kobo.130.1">crossover</span></em><span class="kobospan" id="kobo.131.1">, and </span><em class="italic"><span class="kobospan" id="kobo.132.1">mutation</span></em><span class="kobospan" id="kobo.133.1">. </span><span class="kobospan" id="kobo.133.2">Applying these operators to the current generation results in a new generation of solutions that is expected to produce better results than its predecessor. </span><span class="kobospan" id="kobo.133.3">In most of the problems we have looked at so far, this representation was a list (or an array) of values of a certain type, such as integers, Booleans, or floats. </span><span class="kobospan" id="kobo.133.4">To</span><a id="_idIndexMarker952" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.134.1"> represent a </span><em class="italic"><span class="kobospan" id="kobo.135.1">program</span></em><span class="kobospan" id="kobo.136.1">, however, we typically use a </span><em class="italic"><span class="kobospan" id="kobo.137.1">tree structure</span></em><span class="kobospan" id="kobo.138.1">, as shown in the </span><span><span class="kobospan" id="kobo.139.1">following diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer166">
<span class="kobospan" id="kobo.140.1"><img alt="Figure 16.1: Tree structure representation of a simple program" src="image/B20851_16_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.141.1">Figure 16.1: Tree structure representation of a simple program</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.142.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Genetic_Program_Tree.png" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.143.1">https://commons.wikimedia.org/wiki/File:Genetic_Program_Tree.png</span></a></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.144.1">Image by Baxelrod. </span></p>
<p class="calibre3"><span class="kobospan" id="kobo.145.1">The tree structure depicted in the preceding diagram represents the calculation shown underneath the tree. </span><span class="kobospan" id="kobo.145.2">This calculation is equivalent to a short program (or a function) that accepts two arguments, </span><em class="italic"><span class="kobospan" id="kobo.146.1">X</span></em><span class="kobospan" id="kobo.147.1"> and </span><em class="italic"><span class="kobospan" id="kobo.148.1">Y</span></em><span class="kobospan" id="kobo.149.1">, and returns a certain output based on their values. </span><span class="kobospan" id="kobo.149.2">To create and evolve such tree structures, we</span><a id="_idIndexMarker953" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.150.1"> need to define two </span><span><span class="kobospan" id="kobo.151.1">different sets:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.152.1">Terminals</span></strong><span class="kobospan" id="kobo.153.1">, or the </span><em class="italic"><span class="kobospan" id="kobo.154.1">leaves</span></em><span class="kobospan" id="kobo.155.1"> of the tree. </span><span class="kobospan" id="kobo.155.2">These are arguments and the constant values that can be used in the tree. </span><span class="kobospan" id="kobo.155.3">In our </span><a id="_idIndexMarker954" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.156.1">example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.157.1">X</span></strong><span class="kobospan" id="kobo.158.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">Y</span></strong><span class="kobospan" id="kobo.160.1"> are arguments, while </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">2.2</span></strong><span class="kobospan" id="kobo.162.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.163.1">11</span></strong><span class="kobospan" id="kobo.164.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.165.1">7</span></strong><span class="kobospan" id="kobo.166.1"> are constants. </span><span class="kobospan" id="kobo.166.2">Constants can also be generated randomly, within a certain range, when a tree </span><span><span class="kobospan" id="kobo.167.1">is created.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.168.1">Primitives</span></strong><span class="kobospan" id="kobo.169.1">, or the </span><em class="italic"><span class="kobospan" id="kobo.170.1">internal nodes</span></em><span class="kobospan" id="kobo.171.1"> of the tree. </span><span class="kobospan" id="kobo.171.2">These are functions (or operators) that accept one or more</span><a id="_idIndexMarker955" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.172.1"> arguments and generate a single output value. </span><span class="kobospan" id="kobo.172.2">In our example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.173.1">+</span></strong><span class="kobospan" id="kobo.174.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.175.1">-</span></strong><span class="kobospan" id="kobo.176.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.177.1">*</span></strong><span class="kobospan" id="kobo.178.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.179.1">÷</span></strong><span class="kobospan" id="kobo.180.1"> are primitives that accept two arguments, while </span><strong class="source-inline1"><span class="kobospan" id="kobo.181.1">cos</span></strong><span class="kobospan" id="kobo.182.1"> is a primitive that accepts a </span><span><span class="kobospan" id="kobo.183.1">single argument.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.184.1">In </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.185.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.186.1">, </span><em class="italic"><span class="kobospan" id="kobo.187.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.188.1">, we demonstrated how the genetic operator of </span><em class="italic"><span class="kobospan" id="kobo.189.1">single-point crossover</span></em><span class="kobospan" id="kobo.190.1"> operates on binary-valued lists. </span><span class="kobospan" id="kobo.190.2">The crossover </span><a id="_idIndexMarker956" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.191.1">operation created two offspring from two parents by cutting out a part of each parent and swapping the detached parts between the parents. </span><span class="kobospan" id="kobo.191.2">Similarly, a crossover operator for the tree representation may detach a </span><em class="italic"><span class="kobospan" id="kobo.192.1">subtree</span></em><span class="kobospan" id="kobo.193.1"> (a branch or a group of branches) from each parent and swap the detached branches between the parents to create offspring trees, as demonstrated in the </span><span><span class="kobospan" id="kobo.194.1">following diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer167">
<span class="kobospan" id="kobo.195.1"><img alt="Figure 16.2: Crossover operation between two tree structures representing programs" src="image/B20851_16_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.196.1">Figure 16.2: Crossover operation between two tree structures representing programs</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.197.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:GP_crossover.png" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.198.1">https://commons.wikimedia.org/wiki/File:GP_crossover.png</span></a></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.199.1">Image by U-ichi</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.200.1">In this example, the two parents on the top row have subtrees that have been swapped between them to create the</span><a id="_idIndexMarker957" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.201.1"> two offspring in the second row. </span><span class="kobospan" id="kobo.201.2">The swapped subtrees are marked by the rectangles </span><span><span class="kobospan" id="kobo.202.1">surrounding them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">Along the same lines, the </span><em class="italic"><span class="kobospan" id="kobo.204.1">mutation</span></em><span class="kobospan" id="kobo.205.1"> operator, which</span><a id="_idIndexMarker958" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.206.1"> intends to introduce random changes to a single individual, can be implemented by picking a subtree within the candidate solution and replacing it with a randomly </span><span><span class="kobospan" id="kobo.207.1">generated one.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">The </span><strong class="bold"><span class="kobospan" id="kobo.209.1">deap</span></strong><span class="kobospan" id="kobo.210.1"> library, which we have been using throughout this book, provides inherent support for genetic programming. </span><span class="kobospan" id="kobo.210.2">In the next </span><a id="_idIndexMarker959" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.211.1">section, we will implement a simple genetic programming example</span><a id="_idIndexMarker960" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.212.1"> using </span><span><span class="kobospan" id="kobo.213.1">this library.</span></span></p>
<h2 id="_idParaDest-335" class="calibre7"><a id="_idTextAnchor387" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.214.1">Genetic programming example – even parity check</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.215.1">For our example, we will use genetic </span><a id="_idIndexMarker961" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.216.1">programming to create a program that implements an even parity check. </span><span class="kobospan" id="kobo.216.2">In this task, the possible values of the inputs are 0 or 1. </span><span class="kobospan" id="kobo.216.3">The output value should be 1 if the number of the inputs with the value 1 is odd, thereby producing a total even number of 1 values; otherwise, the output value should be 0. </span><span class="kobospan" id="kobo.216.4">The following table lists the various possible combinations of input values for the case of three inputs, along with the matching even parity </span><span><span class="kobospan" id="kobo.217.1">output values:</span></span></p>
<table class="no-table-style" id="table001-8">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.218.1">in_0</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.219.1">in_1</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.220.1">in_2</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.221.1">Even Parity</span></strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.222.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.223.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.224.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.225.1">0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.226.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.227.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.228.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.229.1">1</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.230.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.231.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.232.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.233.1">1</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.234.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.235.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.236.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.237.1">0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.238.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.239.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.240.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.241.1">1</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.242.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.243.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.244.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.245.1">0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.246.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.247.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.248.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.249.1">0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.250.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.251.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.252.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.253.1">1</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.254.1">Table 16.1: Truth table of even parity as a function of three inputs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.255.1">This kind of table is often referred to as the </span><em class="italic"><span class="kobospan" id="kobo.256.1">truth table</span></em><span class="kobospan" id="kobo.257.1"> of the operation at hand. </span><span class="kobospan" id="kobo.257.2">As evident from this truth table, one reason that the parity check is often used as a benchmark is that any single change in the input values will result in a change to the </span><span><span class="kobospan" id="kobo.258.1">output value.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.259.1">The parity check can also be represented using logic gates, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">AND</span></strong><span class="kobospan" id="kobo.261.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">OR</span></strong><span class="kobospan" id="kobo.263.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">NOT</span></strong><span class="kobospan" id="kobo.265.1">, and exclusive </span><strong class="source-inline"><span class="kobospan" id="kobo.266.1">OR</span></strong><span class="kobospan" id="kobo.267.1"> (</span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">XOR</span></strong><span class="kobospan" id="kobo.269.1">). </span><span class="kobospan" id="kobo.269.2">While the </span><strong class="source-inline"><span class="kobospan" id="kobo.270.1">NOT</span></strong><span class="kobospan" id="kobo.271.1"> gate accepts a single input and inverts it, each of the three other gate types accepts two inputs. </span><span class="kobospan" id="kobo.271.2">For the respective output to be 1, the </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">AND</span></strong><span class="kobospan" id="kobo.273.1"> gate requires both inputs to be 1, the </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">OR</span></strong><span class="kobospan" id="kobo.275.1"> gate requires at least one of them to be 1, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">XOR</span></strong><span class="kobospan" id="kobo.277.1"> gate requires that </span><a id="_idIndexMarker962" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.278.1">exactly one of them is 1, as shown in the </span><span><span class="kobospan" id="kobo.279.1">following table:</span></span></p>
<table class="no-table-style" id="table002-2">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.280.1">in_0</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.281.1">in_1</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.282.1">AND</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.283.1">OR</span></strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.284.1">XOR</span></strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.285.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.286.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.287.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.288.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.289.1">0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.290.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.291.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.292.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.293.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.294.1">1</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.295.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.296.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.297.1">0</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.298.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.299.1">1</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.300.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.301.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.302.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.303.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.304.1">0</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.305.1">Table 16.2: Truth tables of AND, OR and XOR operations of two inputs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.306.1">There are many possible ways to implement the three-input parity check using logic gates. </span><span class="kobospan" id="kobo.306.2">The simplest way to do this is by using two </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">XOR</span></strong><span class="kobospan" id="kobo.308.1"> gates, as shown in the </span><span><span class="kobospan" id="kobo.309.1">following diagram:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer168">
<span class="kobospan" id="kobo.310.1"><img alt="Figure 16.3: A three-input even parity check implemented using two XOR gates" src="image/B20851_16_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.311.1">Figure 16.3: A three-input even parity check implemented using two XOR gates</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.312.1">In the next subsection, we will use genetic programming to create a small program that implements an even parity check using the </span><strong class="source-inline"><span class="kobospan" id="kobo.313.1">AND</span></strong><span class="kobospan" id="kobo.314.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">OR</span></strong><span class="kobospan" id="kobo.316.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.317.1">NOT</span></strong><span class="kobospan" id="kobo.318.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">XOR</span></strong> <span><span class="kobospan" id="kobo.320.1">logic operations.</span></span></p>
<h2 id="_idParaDest-336" class="calibre7"><a id="_idTextAnchor388" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.321.1">Genetic programming implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">To evolve a program that implements the even parity check logic, we’ve created a genetic programming-based Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.323.1">01_gp_even_parity.py</span></strong> <span><span class="kobospan" id="kobo.324.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/01_gp_even_parity.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.325.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/01_gp_even_parity.py</span></span></a><span><span class="kobospan" id="kobo.326.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.327.1">Since genetic programming is a special case of</span><a id="_idIndexMarker963" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.328.1"> genetic algorithms, much of this program will look familiar to you if you have gone over the programs we presented in earlier chapters of </span><span><span class="kobospan" id="kobo.329.1">this book.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.330.1">The following steps describe the main parts of </span><span><span class="kobospan" id="kobo.331.1">this program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.332.1">We start by setting the problem-related constant values. </span><span class="kobospan" id="kobo.332.2">Here, </span><strong class="source-inline1"><span class="kobospan" id="kobo.333.1">NUM_INPUTS</span></strong><span class="kobospan" id="kobo.334.1"> determines the number of inputs for the even parity checker. </span><span class="kobospan" id="kobo.334.2">We will use a value of </span><strong class="source-inline1"><span class="kobospan" id="kobo.335.1">3</span></strong><span class="kobospan" id="kobo.336.1"> for simplicity; however, larger values can be set as well. </span><span class="kobospan" id="kobo.336.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.337.1">NUM_COMBINATIONS</span></strong><span class="kobospan" id="kobo.338.1"> constant represents the number of possible combinations of values for the inputs, which is analogous to the number of rows in the truth table we </span><span><span class="kobospan" id="kobo.339.1">saw earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.340.1">
NUM_INPUTS = 3
NUM_COMBINATIONS = 2 ** NUM_INPUTS</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.341.1">This is followed by the familiar genetic algorithm constants we have seen numerous </span><span><span class="kobospan" id="kobo.342.1">times before:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.343.1">
POPULATION_SIZE = 60
P_CROSSOVER = 0.9
P_MUTATION = 0.5
MAX_GENERATIONS = 20
HALL_OF_FAME_SIZE = 10</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.344.1">However, genetic programming requires several additional constants that refer to the tree representation of the candidate solutions. </span><span class="kobospan" id="kobo.344.2">These are defined in the following code. </span><span class="kobospan" id="kobo.344.3">We will see how they are used as we examine the rest of </span><span><span class="kobospan" id="kobo.345.1">this program:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.346.1">
MIN_TREE_HEIGHT = 3
MAX_TREE_HEIGHT = 5
MUT_MIN_TREE_HEIGHT = 0
MUT_MAX_TREE_HEIGHT = 2
LIMIT_TREE_HEIGHT = 17</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.347.1">Next, we calculate the </span><em class="italic"><span class="kobospan" id="kobo.348.1">truth table</span></em><span class="kobospan" id="kobo.349.1"> of the even parity check so that we can use it as a reference when we need to check the accuracy of a given candidate solution. </span><span class="kobospan" id="kobo.349.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">parityIn</span></strong><span class="kobospan" id="kobo.351.1"> matrix represents the input columns of the truth table, while the </span><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">parityOut</span></strong><span class="kobospan" id="kobo.353.1"> vector </span><a id="_idIndexMarker964" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.354.1">represents the output column. </span><span class="kobospan" id="kobo.354.2">The Python </span><strong class="source-inline1"><span class="kobospan" id="kobo.355.1">itertools.product()</span></strong><span class="kobospan" id="kobo.356.1"> function is an elegant replacement for nested </span><strong class="source-inline1"><span class="kobospan" id="kobo.357.1">for</span></strong><span class="kobospan" id="kobo.358.1"> loops that would be otherwise required to iterate over all the combinations of </span><span><span class="kobospan" id="kobo.359.1">input values:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.360.1">parityIn </span></strong><span class="kobospan1" id="kobo.361.1">= list(</span><strong class="bold1"><span class="kobospan1" id="kobo.362.1">itertools.product</span></strong><span class="kobospan1" id="kobo.363.1">([0, 1], repeat=NUM_INPUTS))
</span><strong class="bold1"><span class="kobospan1" id="kobo.364.1">parityOut </span></strong><span class="kobospan1" id="kobo.365.1">= [sum(row) % 2 for row in parityIn]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.366.1">Now, it is time to create the set of </span><em class="italic"><span class="kobospan" id="kobo.367.1">primitives</span></em><span class="kobospan" id="kobo.368.1"> – that is, the operators that will be used in our evolved programs. </span><span class="kobospan" id="kobo.368.2">The first declaration creates a set using the following </span><span><span class="kobospan" id="kobo.369.1">three arguments:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.370.1">The name of the program to be generated using the primitives from the set (here, we called </span><span><span class="kobospan" id="kobo.371.1">it </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.372.1">main</span></strong></span><span><span class="kobospan" id="kobo.373.1">)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.374.1">The number of inputs to </span><span><span class="kobospan" id="kobo.375.1">the program</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.376.1">The prefix to be used when naming the </span><span><span class="kobospan" id="kobo.377.1">inputs (optional)</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.378.1">These three arguments are used to create the following </span><span><span class="kobospan" id="kobo.379.1">primitive set:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.380.1">
primitiveSet = gp.PrimitiveSet("main", NUM_INPUTS, "in_")</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.381.1">Now, we fill the primitive set with the various functions (or operators) that will be used as the building blocks of the program. </span><span class="kobospan" id="kobo.381.2">For each operator, we will use a reference to the function that implements it and the number of arguments it expects. </span><span class="kobospan" id="kobo.381.3">Although we could define our own functions for this purpose, in this case, we’re making use of the existing Python </span><strong class="source-inline1"><span class="kobospan" id="kobo.382.1">operator</span></strong><span class="kobospan" id="kobo.383.1"> module, which contains numerous </span><a id="_idIndexMarker965" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.384.1">useful functions, including the logical operators </span><span><span class="kobospan" id="kobo.385.1">we need:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.386.1">
primitiveSet.addPrimitive(operator.</span><strong class="bold1"><span class="kobospan1" id="kobo.387.1">and_</span></strong><span class="kobospan1" id="kobo.388.1">, 2)
primitiveSet.addPrimitive(operator.</span><strong class="bold1"><span class="kobospan1" id="kobo.389.1">or_</span></strong><span class="kobospan1" id="kobo.390.1">, 2)
primitiveSet.addPrimitive(operator.</span><strong class="bold1"><span class="kobospan1" id="kobo.391.1">xor</span></strong><span class="kobospan1" id="kobo.392.1">, 2)
primitiveSet.addPrimitive(operator.</span><strong class="bold1"><span class="kobospan1" id="kobo.393.1">not_</span></strong><span class="kobospan1" id="kobo.394.1">, 1)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.395.1">The following definitions set the </span><em class="italic"><span class="kobospan" id="kobo.396.1">terminal</span></em><span class="kobospan" id="kobo.397.1"> values to be used. </span><span class="kobospan" id="kobo.397.2">As we mentioned earlier, these are constants that can be used as input values for the tree. </span><span class="kobospan" id="kobo.397.3">In our case, it makes sense to use </span><strong class="source-inline1"><span class="kobospan" id="kobo.398.1">0</span></strong><span class="kobospan" id="kobo.399.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.400.1">1</span></strong> <span><span class="kobospan" id="kobo.401.1">as values:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.402.1">
primitiveSet.addTerminal(</span><strong class="bold1"><span class="kobospan1" id="kobo.403.1">1</span></strong><span class="kobospan1" id="kobo.404.1">)
primitiveSet.addTerminal(</span><strong class="bold1"><span class="kobospan1" id="kobo.405.1">0</span></strong><span class="kobospan1" id="kobo.406.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.407.1">Since our goal is to create a program that implements the truth table of the </span><em class="italic"><span class="kobospan" id="kobo.408.1">even parity check</span></em><span class="kobospan" id="kobo.409.1">, we will attempt to minimize the difference between the program’s output and the known output values. </span><span class="kobospan" id="kobo.409.2">For this purpose, we will define a single objective – that is, minimizing the </span><span><span class="kobospan" id="kobo.410.1">fitness strategy:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.411.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.412.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.413.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.414.1">Now, we will create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.415.1">Individual</span></strong><span class="kobospan" id="kobo.416.1"> class, based on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.417.1">PrimitiveTree</span></strong><span class="kobospan" id="kobo.418.1"> class provided by the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.419.1">deap</span></strong></span><span><span class="kobospan" id="kobo.420.1"> library:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.421.1">
creator.create("Individual", </span><strong class="bold1"><span class="kobospan1" id="kobo.422.1">gp.PrimitiveTree</span></strong><span class="kobospan1" id="kobo.423.1">,\
    fitness=creator.FitnessMin)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.424.1">To help us construct an individual in the population, we will create a helper function that will generate random trees using the primitive set we defined earlier. </span><span class="kobospan" id="kobo.424.2">Here, we’re making use of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">genFull()</span></strong><span class="kobospan" id="kobo.426.1"> function offered by </span><strong class="source-inline1"><span class="kobospan" id="kobo.427.1">deap</span></strong><span class="kobospan" id="kobo.428.1"> and providing it with the primitive set, as well as with the values for defining the minimum and maximum height of the </span><span><span class="kobospan" id="kobo.429.1">generated trees:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.430.1">
toolbox.register("expr",
                  </span><strong class="bold1"><span class="kobospan1" id="kobo.431.1">gp.genFull</span></strong><span class="kobospan1" id="kobo.432.1">,
                  pset=primitiveSet,
                  min_=MIN_TREE_HEIGHT,
                  max_=MAX_TREE_HEIGHT)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.433.1">This is followed by defining two operators, the first of which creates an individual instance</span><a id="_idIndexMarker966" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.434.1"> using the preceding helper operator. </span><span class="kobospan" id="kobo.434.2">The other generates a list of </span><span><span class="kobospan" id="kobo.435.1">such individuals:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.436.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.437.1">individualCreator</span></strong><span class="kobospan1" id="kobo.438.1">",
                  tools.initIterate,
                  creator.Individual,
                  toolbox.expr)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.439.1">populationCreator</span></strong><span class="kobospan1" id="kobo.440.1">",
                  tools.initRepeat,
                  list,
                  toolbox.individualCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.441.1">Next, we create an operator to </span><em class="italic"><span class="kobospan" id="kobo.442.1">compile</span></em><span class="kobospan" id="kobo.443.1"> a given primitive tree into Python code using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">compile()</span></strong><span class="kobospan" id="kobo.445.1"> function offered by </span><strong class="source-inline1"><span class="kobospan" id="kobo.446.1">deap</span></strong><span class="kobospan" id="kobo.447.1">. </span><span class="kobospan" id="kobo.447.2">Consequently, we’ll use this compile operator in a function we’ll create, called </span><strong class="source-inline1"><span class="kobospan" id="kobo.448.1">parityError()</span></strong><span class="kobospan" id="kobo.449.1">. </span><span class="kobospan" id="kobo.449.2">For a given individual – a tree representing an expression – this function counts the number of rows in the truth table for which the result of the calculation differs from the </span><span><span class="kobospan" id="kobo.450.1">expected one:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.451.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.452.1">compile</span></strong><span class="kobospan1" id="kobo.453.1">", gp.compile, pset=primitiveSet)
def parityError(individual):
    func = toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.454.1">compile</span></strong><span class="kobospan1" id="kobo.455.1">(expr=individual)
    return sum(func(*</span><strong class="bold1"><span class="kobospan1" id="kobo.456.1">pIn</span></strong><span class="kobospan1" id="kobo.457.1">) != </span><strong class="bold1"><span class="kobospan1" id="kobo.458.1">pOut</span></strong><span class="kobospan1" id="kobo.459.1"> for pIn,
        pOut in zip(parityIn, parityOut))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.460.1">Then, we must instruct the genetic programming algorithm to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.461.1">getCost()</span></strong><span class="kobospan" id="kobo.462.1"> function for</span><a id="_idIndexMarker967" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.463.1"> fitness evaluation. </span><span class="kobospan" id="kobo.463.2">This function returns the parity error we just saw in tuple form that’s required by the underlying </span><span><span class="kobospan" id="kobo.464.1">evolutionary algorithm:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.465.1">
def getCost(individual):
    return </span><strong class="bold1"><span class="kobospan1" id="kobo.466.1">parityError</span></strong><span class="kobospan1" id="kobo.467.1">(individual),
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.468.1">evaluate</span></strong><span class="kobospan1" id="kobo.469.1">", getCost)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.470.1">It’s time to choose our genetic operators, starting with the </span><em class="italic"><span class="kobospan" id="kobo.471.1">selection</span></em><span class="kobospan" id="kobo.472.1"> operator (aliased with </span><strong class="source-inline1"><span class="kobospan" id="kobo.473.1">select</span></strong><span class="kobospan" id="kobo.474.1">). </span><span class="kobospan" id="kobo.474.2">For genetic programming, this operator is typically the same </span><em class="italic"><span class="kobospan" id="kobo.475.1">tournament selection</span></em><span class="kobospan" id="kobo.476.1"> we have been using throughout this book. </span><span class="kobospan" id="kobo.476.2">Here, we’re using it with a tournament size </span><span><span class="kobospan" id="kobo.477.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">2</span></strong></span><span><span class="kobospan" id="kobo.479.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.480.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.481.1">select</span></strong><span class="kobospan1" id="kobo.482.1">", tools.selTournament, tournsize=2)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.483.1">As for the </span><em class="italic"><span class="kobospan" id="kobo.484.1">crossover</span></em><span class="kobospan" id="kobo.485.1"> operator (aliased with </span><strong class="source-inline1"><span class="kobospan" id="kobo.486.1">mate</span></strong><span class="kobospan" id="kobo.487.1">), we will use the specialized genetic programming </span><strong class="source-inline1"><span class="kobospan" id="kobo.488.1">cxOnePoint()</span></strong><span class="kobospan" id="kobo.489.1"> operator that’s provided by </span><strong class="source-inline1"><span class="kobospan" id="kobo.490.1">deap</span></strong><span class="kobospan" id="kobo.491.1">. </span><span class="kobospan" id="kobo.491.2">Since the evolving programs are represented by trees, this operator takes two parent trees and exchanges sections of them to create two valid </span><span><span class="kobospan" id="kobo.492.1">offspring trees:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.493.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.494.1">mate</span></strong><span class="kobospan1" id="kobo.495.1">", gp.cxOnePoint)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.496.1">Next is the </span><em class="italic"><span class="kobospan" id="kobo.497.1">mutation</span></em><span class="kobospan" id="kobo.498.1"> operator, which introduces random changes to an existing tree. </span><span class="kobospan" id="kobo.498.2">The mutation is defined in two stages. </span><span class="kobospan" id="kobo.498.3">First, we specify a helper operator that utilizes the specialized genetic programming </span><strong class="source-inline1"><span class="kobospan" id="kobo.499.1">genGrow()</span></strong><span class="kobospan" id="kobo.500.1"> function, provided by </span><strong class="source-inline1"><span class="kobospan" id="kobo.501.1">deap</span></strong><span class="kobospan" id="kobo.502.1">. </span><span class="kobospan" id="kobo.502.2">This operator creates a subtree within the limits defined by the two constants. </span><span class="kobospan" id="kobo.502.3">Then, we define the mutation operator itself (aliased with </span><strong class="source-inline1"><span class="kobospan" id="kobo.503.1">mutate</span></strong><span class="kobospan" id="kobo.504.1">). </span><span class="kobospan" id="kobo.504.2">This operator utilizes DEAP’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.505.1">mutUniform()</span></strong><span class="kobospan" id="kobo.506.1"> function, which randomly replaces a subtree in a given tree with a random one that was generated using the </span><span><span class="kobospan" id="kobo.507.1">helper operator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.508.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.509.1">expr_mut</span></strong><span class="kobospan1" id="kobo.510.1">",
                  gp.</span><strong class="bold1"><span class="kobospan1" id="kobo.511.1">genGrow</span></strong><span class="kobospan1" id="kobo.512.1">,
                  min_=MUT_MIN_TREE_HEIGHT,
                  max_=MUT_MAX_TREE_HEIGHT)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.513.1">mutate</span></strong><span class="kobospan1" id="kobo.514.1">",
                  gp.mutUniform,
                  expr=toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.515.1">expr_mut</span></strong><span class="kobospan1" id="kobo.516.1">,
                  pset=primitiveSet)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.517.1">To prevent individuals in the population from growing into overly large trees, potentially containing an </span><a id="_idIndexMarker968" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.518.1">excessive number of primitives, we need to introduce </span><em class="italic"><span class="kobospan" id="kobo.519.1">bloat control</span></em><span class="kobospan" id="kobo.520.1"> measures. </span><span class="kobospan" id="kobo.520.2">We can do this using DEAP’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.521.1">staticLimit()</span></strong><span class="kobospan" id="kobo.522.1"> function, which imposes a tree height restriction on the results of the </span><em class="italic"><span class="kobospan" id="kobo.523.1">crossover</span></em><span class="kobospan" id="kobo.524.1"> and </span><span><em class="italic"><span class="kobospan" id="kobo.525.1">mutation</span></em></span><span><span class="kobospan" id="kobo.526.1"> operations:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.527.1">
toolbox.decorate("</span><strong class="bold1"><span class="kobospan1" id="kobo.528.1">mate</span></strong><span class="kobospan1" id="kobo.529.1">",
    gp.staticLimit(
        key=operator.attrgetter("</span><strong class="bold1"><span class="kobospan1" id="kobo.530.1">height</span></strong><span class="kobospan1" id="kobo.531.1">"),
        max_value=LIMIT_TREE_HEIGHT))
toolbox.decorate("</span><strong class="bold1"><span class="kobospan1" id="kobo.532.1">mutate</span></strong><span class="kobospan1" id="kobo.533.1">",
    gp.staticLimit(
        key=operator.attrgetter("</span><strong class="bold1"><span class="kobospan1" id="kobo.534.1">height</span></strong><span class="kobospan1" id="kobo.535.1">"),
        max_value=LIMIT_TREE_HEIGHT))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.536.1">The program’s main loop is very similar to the ones we saw in earlier chapters. </span><span class="kobospan" id="kobo.536.2">After creating the initial population, defining the statistics measurements, and creating the HOF object, we call the evolutionary algorithm. </span><span class="kobospan" id="kobo.536.3">Like we’ve done multiple times before, we</span><a id="_idIndexMarker969" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.537.1"> must apply the </span><em class="italic"><span class="kobospan" id="kobo.538.1">elitist approach</span></em><span class="kobospan" id="kobo.539.1">, where the HOF members – the current best individuals – are always passed untouched to the </span><span><span class="kobospan" id="kobo.540.1">next generation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.541.1">
population, logbook = elitism.</span><strong class="bold1"><span class="kobospan1" id="kobo.542.1">eaSimpleWithElitism</span></strong><span class="kobospan1" id="kobo.543.1">(
    population,
    toolbox,
    cxpb=P_CROSSOVER,
    mutpb=P_MUTATION,
    ngen=MAX_GENERATIONS,
    stats=stats,
    halloffame=hof,
    verbose=True)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.544.1"> At the end of the run, we print the best solution, as well as the height of the tree that’s being used to represent it, and its length – that is, the total number of operators contained in </span><span><span class="kobospan" id="kobo.545.1">the tree:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.546.1">
best = </span><strong class="bold1"><span class="kobospan1" id="kobo.547.1">hof</span></strong><span class="kobospan1" id="kobo.548.1">.items[0]
print("-- Best Individual = ", </span><strong class="bold1"><span class="kobospan1" id="kobo.549.1">best</span></strong><span class="kobospan1" id="kobo.550.1">)
print(f"-- </span><strong class="bold1"><span class="kobospan1" id="kobo.551.1">length</span></strong><span class="kobospan1" id="kobo.552.1">={len(best)}, </span><strong class="bold1"><span class="kobospan1" id="kobo.553.1">height</span></strong><span class="kobospan1" id="kobo.554.1">={best.height}")
print("-- Best Fitness = ", best.fitness.values[0])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.555.1">The last thing we need to do is plot a graphic illustration of the tree representing the best solution. </span><span class="kobospan" id="kobo.555.2">To that end, we must utilize the graph and networks library known as </span><em class="italic"><span class="kobospan" id="kobo.556.1">NetworkX</span></em><span class="kobospan" id="kobo.557.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.558.1">nx</span></strong><span class="kobospan" id="kobo.559.1">), which we introduced in </span><a href="B20851_05.xhtml#_idTextAnchor177" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.560.1">Chapter 5</span></em></span></a><span class="kobospan" id="kobo.561.1">, </span><em class="italic"><span class="kobospan" id="kobo.562.1">Constraint Satisfaction</span></em><span class="kobospan" id="kobo.563.1">. </span><span class="kobospan" id="kobo.563.2">We start by calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.564.1">graph()</span></strong><span class="kobospan" id="kobo.565.1"> function provided by </span><strong class="source-inline1"><span class="kobospan" id="kobo.566.1">deap</span></strong><span class="kobospan" id="kobo.567.1">, which breaks down the individual tree into the nodes, edges, and labels that are required for the graph, and then create the graph using the appropriate </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.568.1">networkx</span></strong></span><span><span class="kobospan" id="kobo.569.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.570.1">
nodes, edges, labels = </span><strong class="bold1"><span class="kobospan1" id="kobo.571.1">gp.graph</span></strong><span class="kobospan1" id="kobo.572.1">(best)
g = </span><strong class="bold1"><span class="kobospan1" id="kobo.573.1">nx.Graph</span></strong><span class="kobospan1" id="kobo.574.1">()
g.add_nodes_from(</span><strong class="bold1"><span class="kobospan1" id="kobo.575.1">nodes</span></strong><span class="kobospan1" id="kobo.576.1">)
g.add_edges_from(</span><strong class="bold1"><span class="kobospan1" id="kobo.577.1">edges</span></strong><span class="kobospan1" id="kobo.578.1">)
pos = nx.spring_layout(g)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.579.1">Then, we draw the nodes, edges, and labels. </span><span class="kobospan" id="kobo.579.2">Since the layout of this graph is not a classic hierarchical</span><a id="_idIndexMarker970" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.580.1"> tree, we must distinguish the top node by coloring it red and </span><span><span class="kobospan" id="kobo.581.1">enlarging it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.582.1">
nx.</span><strong class="bold1"><span class="kobospan1" id="kobo.583.1">draw_networkx_nodes</span></strong><span class="kobospan1" id="kobo.584.1">(g, pos, node_color=</span><strong class="bold1"><span class="kobospan1" id="kobo.585.1">'cyan'</span></strong><span class="kobospan1" id="kobo.586.1">)
nx.</span><strong class="bold1"><span class="kobospan1" id="kobo.587.1">draw_networkx_nodes</span></strong><span class="kobospan1" id="kobo.588.1">(g, pos, nodelist=[0],
    node_color=</span><strong class="bold1"><span class="kobospan1" id="kobo.589.1">'red'</span></strong><span class="kobospan1" id="kobo.590.1">, </span><strong class="bold1"><span class="kobospan1" id="kobo.591.1">node_size=400</span></strong><span class="kobospan1" id="kobo.592.1">)
nx.</span><strong class="bold1"><span class="kobospan1" id="kobo.593.1">draw_networkx_edges</span></strong><span class="kobospan1" id="kobo.594.1">(g, pos)
nx.</span><strong class="bold1"><span class="kobospan1" id="kobo.595.1">draw_networkx_labels</span></strong><span class="kobospan1" id="kobo.596.1">(g, pos, **{"labels": labels, 
    "font_size": 8})</span></pre><p class="calibre3"><span class="kobospan" id="kobo.597.1">When running this program, we get the </span><span><span class="kobospan" id="kobo.598.1">following output:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.599.1">gen nevals min avg
0 60 2 3.91667
1 50 1 3.75
2 47 1 3.45
...
</span><span class="kobospan1" id="kobo.599.2">5 47 0 3.15
...
</span><span class="kobospan1" id="kobo.599.3">20 48 0 1.68333
-- Best Individual = xor(and_(not_(and_(in_1, in_2)), not_(and_(1, in_2))), xor(or_(xor(in_1, in_0), and_(0, 0)), 1))
-- length=19, height=4
-- Best Fitness = 0.0</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.600.1">Since this is a simple problem, the fitness has quickly reached the minimum value of 0, which means we were able to find a solution that correctly reproduces the </span><em class="italic"><span class="kobospan" id="kobo.601.1">even parity check</span></em><span class="kobospan" id="kobo.602.1"> truth table. </span><span class="kobospan" id="kobo.602.2">However, the</span><a id="_idIndexMarker971" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.603.1"> resulting expression, which consists of 19 elements and four levels in the hierarchy, seems overly complex. </span><span class="kobospan" id="kobo.603.2">This is illustrated by the following plot that was produced by </span><span><span class="kobospan" id="kobo.604.1">the program:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer169">
<span class="kobospan" id="kobo.605.1"><img alt="Figure 16.4: A plot representing the parity check solution that was found by the initial program" src="image/B20851_16_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.606.1">Figure 16.4: A plot representing the parity check solution that was found by the initial program</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.607.1">As we mentioned previously, the red node in the graph represents the top of the program’s tree, which maps to the first </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">XOR</span></strong><span class="kobospan" id="kobo.609.1"> operation in </span><span><span class="kobospan" id="kobo.610.1">the expression.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.611.1">The reason for this relatively complex graph is that there is no advantage to using simpler expressions. </span><span class="kobospan" id="kobo.611.2">So long as they fall within the imposed limitation of tree height, the expressions that are evaluated incur no penalty for complexity. </span><span class="kobospan" id="kobo.611.3">In the next subsection, we will attempt to change this situation by making a small modification to the program in the hope of achieving the same outcome – the implementation of the even parity check – but with a </span><span><span class="kobospan" id="kobo.612.1">simpler</span></span><span><a id="_idIndexMarker972" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.613.1"> solution.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.614.1">Simplifying the solution</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.615.1">In the implementation we have just seen, there were measures in place to restrict the size of the trees that represent the candidate solutions. </span><span class="kobospan" id="kobo.615.2">However, the best solution we found seems overly complex. </span><span class="kobospan" id="kobo.615.3">One way to pressure the algorithm into producing simpler results is to impose a small cost penalty for complexity. </span><span class="kobospan" id="kobo.615.4">This penalty should be small enough that it refrains from favoring </span><a id="_idIndexMarker973" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.616.1">simpler solutions that fail to solve the problem. </span><span class="kobospan" id="kobo.616.2">Rather, it should serve as a tie-breaker between two good solutions, so the simpler of the two will be preferred. </span><span class="kobospan" id="kobo.616.3">This approach has been implemented in the </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">02_gp_even_parity_reduced.py</span></strong><span class="kobospan" id="kobo.618.1"> Python program, which is located </span><span><span class="kobospan" id="kobo.619.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/02_gp_even_parity_reduced.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.620.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/02_gp_even_parity_reduced.py</span></span></a><span><span class="kobospan" id="kobo.621.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.622.1">This program is nearly identical to the previous one, except for a couple of </span><span><span class="kobospan" id="kobo.623.1">small changes:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.624.1">The main change was introduced to the </span><em class="italic"><span class="kobospan" id="kobo.625.1">cost function</span></em><span class="kobospan" id="kobo.626.1">, which the algorithm seeks to minimize. </span><span class="kobospan" id="kobo.626.2">To the original calculated error, a small penalty measure was added that depends on the height of </span><span><span class="kobospan" id="kobo.627.1">the tree:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.628.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.629.1">getCost</span></strong><span class="kobospan1" id="kobo.630.1">(individual):
    return parityError(individual) +
               </span><strong class="bold1"><span class="kobospan1" id="kobo.631.1">individual.height / 100</span></strong><span class="kobospan1" id="kobo.632.1">,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.633.1">The only other change was at the end of the run, after printing the best solution that was found. </span><span class="kobospan" id="kobo.633.2">Here, in addition to printing the fitness value, we print the actual </span><em class="italic"><span class="kobospan" id="kobo.634.1">parity error</span></em><span class="kobospan" id="kobo.635.1"> that was obtained, without the penalty that’s present in </span><span><span class="kobospan" id="kobo.636.1">the fitness:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.637.1">
print("-- Best Parity Error = ", </span><strong class="bold1"><span class="kobospan1" id="kobo.638.1">parityError(best)</span></strong><span class="kobospan1" id="kobo.639.1">)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.640.1">By running this modified version, we get the </span><span><span class="kobospan" id="kobo.641.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.642.1">
gen nevals min avg
0 60 2.03 3.9565
1 50 2.03 3.7885
...
</span><span class="kobospan1" id="kobo.642.2">5 47 0.04 3.45233
...
</span><span class="kobospan1" id="kobo.642.3">10 48 0.03 3.0145
...
</span><span class="kobospan1" id="kobo.642.4">15 49 0.02 2.57983
...
</span><span class="kobospan1" id="kobo.642.5">20 45 0.02 2.88533
-- Best Individual = xor(xor(in_0, in_1), in_2)
-- length=5, height=2
-- Best Fitness = 0.02
-- Best Parity Error = 0</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.643.1">From the preceding output, we can tell that, after five generations, the algorithm was able to find a solution that correctly reproduces the even parity check truth table since the fitness value at that point was nearly 0. </span><span class="kobospan" id="kobo.643.2">However, as the algorithm kept running, the tree height was reduced from</span><a id="_idIndexMarker974" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.644.1"> four (a penalty of </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">0.04</span></strong><span class="kobospan" id="kobo.646.1">) to two (a penalty of </span><strong class="source-inline"><span class="kobospan" id="kobo.647.1">0.02</span></strong><span class="kobospan" id="kobo.648.1">). </span><span class="kobospan" id="kobo.648.2">As a result, the best solution is very simple and consists of only five elements – the three inputs and two </span><strong class="source-inline"><span class="kobospan" id="kobo.649.1">XOR</span></strong><span class="kobospan" id="kobo.650.1"> operators. </span><span class="kobospan" id="kobo.650.2">The solution we found represents the simplest known solution that we saw earlier, which consists of two </span><strong class="source-inline"><span class="kobospan" id="kobo.651.1">XOR</span></strong><span class="kobospan" id="kobo.652.1"> gates. </span><span class="kobospan" id="kobo.652.2">This is illustrated by the following plot, which was produced by </span><span><span class="kobospan" id="kobo.653.1">the program:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer170">
<span class="kobospan" id="kobo.654.1"><img alt="Figure 16.5: A plot representing the parity check solution that was found by the modified program" src="image/B20851_16_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.655.1">Figure 16.5: A plot representing the parity check solution that was found by the modified program</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.656.1">While genetic programming is considered a subset of genetic algorithms, the next section describes a more </span><a id="_idIndexMarker975" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.657.1">specialized form of evolutionary computation – one that is dedicated to creating neural </span><span><span class="kobospan" id="kobo.658.1">network architectures.</span></span></p>
<h1 id="_idParaDest-337" class="calibre5"><a id="_idTextAnchor389" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.659.1">NEAT</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.660.1">In </span><a href="B20851_09.xhtml#_idTextAnchor257" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.661.1">Chapter 9</span></em></span></a><span class="kobospan" id="kobo.662.1">, </span><em class="italic"><span class="kobospan" id="kobo.663.1">Architecture Optimization of Deep Learning Networks</span></em><span class="kobospan" id="kobo.664.1">, we demonstrated how a simple genetic algorithm can be used to find the best architecture of a feed-forward neural network (also known as </span><strong class="bold"><span class="kobospan" id="kobo.665.1">multilayer perceptron</span></strong><span class="kobospan" id="kobo.666.1"> or </span><strong class="bold"><span class="kobospan" id="kobo.667.1">MLP</span></strong><span class="kobospan" id="kobo.668.1">) for a particular task. </span><span class="kobospan" id="kobo.668.2">To do that, we limited </span><a id="_idIndexMarker976" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.669.1">ourselves to three hidden layers and coded </span><a id="_idIndexMarker977" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.670.1">each network using a fixed-size chromosome that had placeholders for each of the layers, where a 0 or a negative value meant that the layer did </span><span><span class="kobospan" id="kobo.671.1">not exist.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.672.1">Taking this idea further, </span><strong class="bold"><span class="kobospan" id="kobo.673.1">NEAT</span></strong><span class="kobospan" id="kobo.674.1"> is an evolutionary technique dedicated to creating neural networks more flexibly and incrementally and was created in 2002 by </span><em class="italic"><span class="kobospan" id="kobo.675.1">Kenneth Stanley</span></em><span class="kobospan" id="kobo.676.1"> and </span><span><em class="italic"><span class="kobospan" id="kobo.677.1">Risto Miikkulainen</span></em></span><span><span class="kobospan" id="kobo.678.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.679.1">NEAT starts with small, simple neural networks and allows them to evolve by adding and modifying neurons and connections over generations. </span><span class="kobospan" id="kobo.679.2">Rather than using a fixed-size chromosome, NEAT represents solutions as </span><em class="italic"><span class="kobospan" id="kobo.680.1">directed graphs</span></em><span class="kobospan" id="kobo.681.1"> that directly map into artificial neural networks, where nodes represent neurons, and connections between nodes represent synapses. </span><span class="kobospan" id="kobo.681.2">This allows NEAT to evolve not only the weights of the connections but also the network’s structure itself, including adding and removing neurons </span><span><span class="kobospan" id="kobo.682.1">and connections.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.683.1">NEAT’s </span><em class="italic"><span class="kobospan" id="kobo.684.1">crossover</span></em><span class="kobospan" id="kobo.685.1"> operator is designed specifically for neural networks. </span><span class="kobospan" id="kobo.685.2">It aligns and combines matching neurons and connections from parent networks while maintaining unique ‘innovation’ identifiers. </span><span class="kobospan" id="kobo.685.3">To enable this kind of matching, the history of genes is tracked by the use of a </span><strong class="bold"><span class="kobospan" id="kobo.686.1">global innovation number</span></strong><span class="kobospan" id="kobo.687.1">, which increases as </span><a id="_idIndexMarker978" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.688.1">new genes </span><span><span class="kobospan" id="kobo.689.1">are added.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.690.1">In addition, NEAT employs a </span><strong class="bold"><span class="kobospan" id="kobo.691.1">speciation</span></strong><span class="kobospan" id="kobo.692.1"> mechanism that </span><a id="_idIndexMarker979" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.693.1">groups individuals (neural networks) into species based on their structural similarity. </span><span class="kobospan" id="kobo.693.2">This grouping encourages competition </span><em class="italic"><span class="kobospan" id="kobo.694.1">within</span></em><span class="kobospan" id="kobo.695.1"> species rather than </span><em class="italic"><span class="kobospan" id="kobo.696.1">between</span></em><span class="kobospan" id="kobo.697.1"> species. </span><span class="kobospan" id="kobo.697.2">This mechanism helps ensure that innovations have a chance to thrive within their respective niches before being subjected to </span><span><span class="kobospan" id="kobo.698.1">intense competition.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.699.1">NEAT (along with other related neuroevolutionary techniques) has been applied in many areas, including financial forecasting, drug discovery, evolving art, electronic circuit design, and robotics; however, it is most commonly found in </span><em class="italic"><span class="kobospan" id="kobo.700.1">reinforcement learning</span></em><span class="kobospan" id="kobo.701.1"> applications, such as </span><span><span class="kobospan" id="kobo.702.1">game </span></span><span><a id="_idIndexMarker980" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.703.1">playing.</span></span></p>
<h2 id="_idParaDest-338" class="calibre7"><a id="_idTextAnchor390" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.704.1">NEAT example – even parity check</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.705.1">We will illustrate using the NEAT</span><a id="_idIndexMarker981" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.706.1"> technique by solving the same three-input </span><em class="italic"><span class="kobospan" id="kobo.707.1">even parity check</span></em><span class="kobospan" id="kobo.708.1"> problem we used in the previous section to demonstrate genetic programming. </span><span class="kobospan" id="kobo.708.2">Here, we’ll employ NEAT to create a feed-forward neural network implementation of the same parity </span><span><span class="kobospan" id="kobo.709.1">check function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.710.1">In regards to neural networks, the even parity </span><a id="_idIndexMarker982" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.711.1">check, also known as </span><strong class="bold"><span class="kobospan" id="kobo.712.1">the XOR problem</span></strong><span class="kobospan" id="kobo.713.1">, is known to be impossible for a single perceptron to implement as it forms a pattern that cannot be separated by a single line or a simple linear function. </span><span class="kobospan" id="kobo.713.2">To capture this non-linearity, the minimal required network consists of, in addition to the input and output layers, a hidden layer of two neurons. </span><span class="kobospan" id="kobo.713.3">In the next subsection, we will set out to see if NEAT can find this </span><span><span class="kobospan" id="kobo.714.1">minimal solution.</span></span></p>
<h2 id="_idParaDest-339" class="calibre7"><a id="_idTextAnchor391" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.715.1">NEAT implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.716.1">To evolve a neural network that implements the even parity check logic using the NEAT technique, we’ve created a</span><a id="_idIndexMarker983" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.717.1"> Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.718.1">03_neat_even_parity.py</span></strong> <span><span class="kobospan" id="kobo.719.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/03_neat_even_parity.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.720.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/03_neat_even_parity.py</span></span></a><span><span class="kobospan" id="kobo.721.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.722.1">Python NEAT library</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.723.1">There are several capable Python libraries</span><a id="_idIndexMarker984" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.724.1"> available that implement the NEAT technique, most notably the </span><strong class="bold"><span class="kobospan" id="kobo.725.1">NEAT-Python</span></strong><span class="kobospan" id="kobo.726.1"> library. </span><span class="kobospan" id="kobo.726.2">However, for our </span><a id="_idIndexMarker985" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.727.1">example, we will be using the lightweight </span><strong class="bold"><span class="kobospan" id="kobo.728.1">neatpy</span></strong><span class="kobospan" id="kobo.729.1"> library, owing to its conciseness and ease of use. </span><span class="kobospan" id="kobo.729.2">This library can be installed (if not already present) using the </span><span><span class="kobospan" id="kobo.730.1">following command:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.731.1">
pip install neatpy</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.732.1">In addition, the </span><strong class="bold"><span class="kobospan" id="kobo.733.1">PyGame</span></strong><span class="kobospan" id="kobo.734.1"> library is required </span><a id="_idIndexMarker986" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.735.1">for visualizing the progress of the solution. </span><span class="kobospan" id="kobo.735.2">If it’s not been installed yet, it can</span><a id="_idIndexMarker987" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.736.1"> be added using the </span><span><span class="kobospan" id="kobo.737.1">following command:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.738.1">
pip install pygame</span></pre> <h3 class="calibre9"><span class="kobospan" id="kobo.739.1">Program</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.740.1">The following</span><a id="_idIndexMarker988" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.741.1"> steps describe the main parts of </span><span><span class="kobospan" id="kobo.742.1">this program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.743.1">Similar to the genetic programming example, we’ll start by setting the problem-related constant values. </span><strong class="source-inline1"><span class="kobospan" id="kobo.744.1">NUM_INPUTS</span></strong><span class="kobospan" id="kobo.745.1"> determines the number of inputs for the even </span><span><span class="kobospan" id="kobo.746.1">parity checker.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.747.1">Since we would like to save an image with the best solution’s network structure at the end of the program, let’s make sure a folder for it has </span><span><span class="kobospan" id="kobo.748.1">been created:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.749.1">IMAGE_PATH</span></strong><span class="kobospan1" id="kobo.750.1"> = os.path.join(
    os.path.dirname(os.path.realpath(__file__)),
    </span><strong class="bold1"><span class="kobospan1" id="kobo.751.1">"images"</span></strong><span class="kobospan1" id="kobo.752.1">)
if not os.path.exists(IMAGE_PATH):
    os.</span><strong class="bold1"><span class="kobospan1" id="kobo.753.1">makedirs</span></strong><span class="kobospan1" id="kobo.754.1">(IMAGE_PATH)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.755.1">Now, we must set up the graphical display for the real-time “animation” of the algorithm’s progress by using the functionality of the </span><span><em class="italic"><span class="kobospan" id="kobo.756.1">PyGame</span></em></span><span><span class="kobospan" id="kobo.757.1"> library:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.758.1">
pg.init()
</span><strong class="bold1"><span class="kobospan1" id="kobo.759.1">screen </span></strong><span class="kobospan1" id="kobo.760.1">= pg.display.set_mode((400, 400))
screen.fill(colors[</span><strong class="bold1"><span class="kobospan1" id="kobo.761.1">'lightblue'</span></strong><span class="kobospan1" id="kobo.762.1">])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.763.1">Next, we must set several options for the NEAT algorithm that will </span><span><span class="kobospan" id="kobo.764.1">be used:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.765.1">The number of inputs for our network (which would be identical </span><span><span class="kobospan" id="kobo.766.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.767.1">NUM_INPUTS</span></strong></span><span><span class="kobospan" id="kobo.768.1">).</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.769.1">The number of outputs (1, in </span><span><span class="kobospan" id="kobo.770.1">our case).</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.771.1">Population size (150, in </span><span><span class="kobospan" id="kobo.772.1">our example).</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.773.1">A fitness threshold. </span><span class="kobospan" id="kobo.773.2">If the best solution surpasses this value, the algorithm considers the problem as solved and stops. </span><span class="kobospan" id="kobo.773.3">As the best fitness possible is equal to the number of rows in the truth table (indicating we got the correct results for all</span><a id="_idIndexMarker989" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.774.1"> rows), we must set the threshold to a value just </span><span><span class="kobospan" id="kobo.775.1">under that:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.776.1">
Options.</span><strong class="bold1"><span class="kobospan1" id="kobo.777.1">set_options</span></strong><span class="kobospan1" id="kobo.778.1">(NUM_INPUTS, 1, 150, </span><strong class="bold1"><span class="kobospan1" id="kobo.779.1">2**NUM_INPUTS - 0.1</span></strong><span class="kobospan1" id="kobo.780.1">)</span></pre></li></ul></li> <li class="calibre11"><span class="kobospan" id="kobo.781.1">Next, we must calculate </span><strong class="source-inline1"><span class="kobospan" id="kobo.782.1">parityIn</span></strong><span class="kobospan" id="kobo.783.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">parityOut</span></strong><span class="kobospan" id="kobo.785.1"> while implementing the inputs and outputs of the desired parity check, similar to what we did in the genetic </span><span><span class="kobospan" id="kobo.786.1">programming example:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.787.1">parityIn </span></strong><span class="kobospan1" id="kobo.788.1">= list(</span><strong class="bold1"><span class="kobospan1" id="kobo.789.1">itertools.product</span></strong><span class="kobospan1" id="kobo.790.1">([0, 1], repeat=NUM_INPUTS))
</span><strong class="bold1"><span class="kobospan1" id="kobo.791.1">parityOut </span></strong><span class="kobospan1" id="kobo.792.1">= [sum(row) % 2 for row in parityIn]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.793.1">Now, it’s time to define </span><strong class="source-inline1"><span class="kobospan" id="kobo.794.1">parityScore()</span></strong><span class="kobospan" id="kobo.795.1">, the function that evaluates a given neural network (represented by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.796.1">nn</span></strong><span class="kobospan" id="kobo.797.1"> parameter). </span><span class="kobospan" id="kobo.797.2">Since the score needs to be positive, we’ll start from the maximum score, and then subtract the square of the difference between each expected network output and the actual (float) value produced by </span><span><span class="kobospan" id="kobo.798.1">the network:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.799.1">
score = 2**NUM_INPUTS
for pIn, pOut in zip(parityIn, parityOut):
    output = nn.predict(pIn)[0]
    score-= (output - pOut) ** 2</span></pre><p class="calibre3"><span class="kobospan" id="kobo.800.1">In addition, the score includes a small penalty term for each node in the network, giving smaller architectures </span><span><span class="kobospan" id="kobo.801.1">an advantage:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.802.1">score -= </span><strong class="bold1"><span class="kobospan1" id="kobo.803.1">len(nn.nodes)</span></strong><span class="kobospan1" id="kobo.804.1"> * 0.01</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.805.1">Coming up next is another utility function, </span><strong class="source-inline1"><span class="kobospan" id="kobo.806.1">draw_current()</span></strong><span class="kobospan" id="kobo.807.1">. </span><span class="kobospan" id="kobo.807.2">It draws the architecture (nodes and connections) of the current best solution by calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.808.1">neatpy</span></strong><span class="kobospan" id="kobo.809.1"> library’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.810.1">draw_brain_pygame()</span></strong><span class="kobospan" id="kobo.811.1">; in addition, it illustrates the </span><em class="italic"><span class="kobospan" id="kobo.812.1">speciation</span></em><span class="kobospan" id="kobo.813.1"> mechanism by drawing the current status of species using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.814.1">draw_species_bar_pygame()</span></strong></span><span><span class="kobospan" id="kobo.815.1"> function.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.816.1">After creating the initial </span><strong class="source-inline1"><span class="kobospan" id="kobo.817.1">population</span></strong><span class="kobospan" id="kobo.818.1">, we get to the main loop of the NEAT algorithm. </span><span class="kobospan" id="kobo.818.2">Thanks to the simplicity of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.819.1">neatpy</span></strong><span class="kobospan" id="kobo.820.1"> library, this loop is very concise. </span><span class="kobospan" id="kobo.820.2">It starts by</span><a id="_idIndexMarker990" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.821.1"> scoring the current population, as is the usual case for </span><span><span class="kobospan" id="kobo.822.1">evolutionary algorithms:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.823.1">
for nn in p.pool:
    nn.fitness = </span><strong class="bold1"><span class="kobospan1" id="kobo.824.1">parityScore</span></strong><span class="kobospan1" id="kobo.825.1">(nn)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.826.1">The main loop continues by calling the library’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">epoch()</span></strong><span class="kobospan" id="kobo.828.1"> function, which performs a single NEAT evolutionary step, resulting in a new population. </span><span class="kobospan" id="kobo.828.2">Then, it prints out the current population and draws the current best individual, as well as the speciation status, by </span><span><span class="kobospan" id="kobo.829.1">calling </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.830.1">draw_current()</span></strong></span><span><span class="kobospan" id="kobo.831.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.832.1">Once the loop exits, the results are printed, the truth table is checked, and the latest drawing is saved to an </span><span><span class="kobospan" id="kobo.833.1">image file.</span></span><p class="calibre3"><span class="kobospan" id="kobo.834.1">When running the program, the drawing containing the visualizations of the network and the speciation appears and updates itself at each generation, thereby creating an “animated” view of the status. </span><span class="kobospan" id="kobo.834.2">The following figure contains four “snapshots” of the drawing that were captured during </span><span><span class="kobospan" id="kobo.835.1">the run:</span></span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer171">
<span class="kobospan" id="kobo.836.1"><img alt="Figure 16.6: Stages in the evolution of the NEAT solution for the three-input even parity check problem" src="image/B20851_16_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.837.1">Figure 16.6: Stages in the evolution of the NEAT solution for the three-input even parity check problem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.838.1">These snapshots demonstrate how the network starts with only the input and output layer nodes and a single</span><a id="_idIndexMarker991" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.839.1"> species, then develops numerous species, followed by the addition of a single hidden layer node, and then a </span><span><span class="kobospan" id="kobo.840.1">second one.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.841.1">At the end of the run, the program saves one last snapshot as an image under the </span><strong class="source-inline"><span class="kobospan" id="kobo.842.1">images</span></strong><span class="kobospan" id="kobo.843.1"> folder. </span><span class="kobospan" id="kobo.843.2">This looks </span><span><span class="kobospan" id="kobo.844.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer172">
<span class="kobospan" id="kobo.845.1"><img alt="Figure 16.7: The final stage in the evolution of the NEAT solution for the three-input even parity check problem" src="image/B20851_16_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.846.1">Figure 16.7: The final stage in the evolution of the NEAT solution for the three-input even parity check problem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.847.1">In the drawings, the white circles represent the nodes of the network, except for the top left circle, which is used to represent the </span><em class="italic"><span class="kobospan" id="kobo.848.1">bias</span></em><span class="kobospan" id="kobo.849.1"> values of the hidden and output layer nodes. </span><span class="kobospan" id="kobo.849.2">The blue edges represent connections of positive weight (or a positive bias value), while the orange edges</span><a id="_idIndexMarker992" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.850.1"> represent negative weights (or bias values). </span><span class="kobospan" id="kobo.850.2">Unlike traditional MLPs, the networks created by the NEAT algorithm can have connections that “skip” a layer, such as the orange edge connecting the bottom input node directly to the output node, as well as </span><span><span class="kobospan" id="kobo.851.1">intra-layer connections.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.852.1">The printed output of the program indicates that the best network that was found was able to solve </span><span><span class="kobospan" id="kobo.853.1">the problem:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.854.1">
best fitness = 7.9009068332812635
Number of nodes = 7
Checking the truth table:
input (0, 0, 0), expected output 0, got 0.050 -&gt; 0
input (0, 0, 1), expected output 1, got 0.963 -&gt; 1
input (0, 1, 0), expected output 1, got 0.933 -&gt; 1
input (0, 1, 1), expected output 0, got 0.077 -&gt; 0
input (1, 0, 0), expected output 1, got 0.902 -&gt; 1
input (1, 0, 1), expected output 0, got 0.042 -&gt; 0
input (1, 1, 0), expected output 0, got 0.029 -&gt; 0
input (1, 1, 1), expected output 1, got 0.949 -&gt; 1</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.855.1">As we can see, the best architecture that was found included a single hidden layer of </span><span><span class="kobospan" id="kobo.856.1">two nodes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.857.1">In the next section, we will</span><a id="_idIndexMarker993" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.858.1"> examine another biologically inspired, population-based algorithm. </span><span class="kobospan" id="kobo.858.2">However, this algorithm deviates from using the familiar genetic operators of selection, crossover, and mutation, and instead utilizes a different set of rules to modify the population at each generation – welcome to the world of </span><span><span class="kobospan" id="kobo.859.1">swarm behavior!</span></span></p>
<h1 id="_idParaDest-340" class="calibre5"><a id="_idTextAnchor392" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.860.1">Particle swarm optimization</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.861.1">Particle swarm optimization</span></strong><span class="kobospan" id="kobo.862.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.863.1">PSO</span></strong><span class="kobospan" id="kobo.864.1">) draws its inspiration from natural groupings of individual organisms, such as</span><a id="_idIndexMarker994" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.865.1"> flocks of birds or schools of fish, generally referred to as </span><em class="italic"><span class="kobospan" id="kobo.866.1">swarms</span></em><span class="kobospan" id="kobo.867.1">. </span><span class="kobospan" id="kobo.867.2">The organisms interact within the swarm without central supervision, working together toward a common goal. </span><span class="kobospan" id="kobo.867.3">This observed behavior gave rise to a computational method that can solve or optimize a given problem by using a group of candidate solutions, represented by </span><em class="italic"><span class="kobospan" id="kobo.868.1">particles</span></em><span class="kobospan" id="kobo.869.1"> analogous to organisms in a swarm. </span><span class="kobospan" id="kobo.869.2">The particles move in the search space, looking for the best solution, and their movement is governed by simple rules that involve their position and </span><em class="italic"><span class="kobospan" id="kobo.870.1">velocity</span></em><span class="kobospan" id="kobo.871.1"> (</span><span><span class="kobospan" id="kobo.872.1">directional speed).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.873.1">The PSO algorithm is iterative, and in each iteration, every particle’s position gets evaluated, and its best location so far, as well as the best location within the entire group of particles, are updated if necessary. </span><span class="kobospan" id="kobo.873.2">Then, each particle’s velocity is updated according to the </span><span><span class="kobospan" id="kobo.874.1">following information:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.875.1">The particle’s current speed and direction of movement – </span><span><span class="kobospan" id="kobo.876.1">representing </span></span><span><em class="italic"><span class="kobospan" id="kobo.877.1">inertia</span></em></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.878.1">The particle’s best position found so far (local best) – representing </span><span><em class="italic"><span class="kobospan" id="kobo.879.1">cognitive force</span></em></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.880.1">The entire group’s best position found so far (global best) – representing </span><span><em class="italic"><span class="kobospan" id="kobo.881.1">social force</span></em></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.882.1">This is followed by an update to the particle’s position, based on the newly </span><span><span class="kobospan" id="kobo.883.1">calculated velocity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.884.1">This iterative process</span><a id="_idIndexMarker995" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.885.1"> continues until some stopping condition, such as the </span><em class="italic"><span class="kobospan" id="kobo.886.1">iterations limit</span></em><span class="kobospan" id="kobo.887.1">, is met. </span><span class="kobospan" id="kobo.887.2">At this point, the group’s current best position is taken as the solution by </span><span><span class="kobospan" id="kobo.888.1">the algorithm.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.889.1">This simple yet efficient process will be illustrated in detail in the next section, where we will go over a program that optimizes a function using the </span><span><span class="kobospan" id="kobo.890.1">PSO algorithm.</span></span></p>
<h2 id="_idParaDest-341" class="calibre7"><a id="_idTextAnchor393" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.891.1">PSO example – function optimization</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.892.1">For demonstration purposes, we will use</span><a id="_idIndexMarker996" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.893.1"> the PSO algorithm to find the minimum location(s) of </span><em class="italic"><span class="kobospan" id="kobo.894.1">Himmelblau’s function</span></em><span class="kobospan" id="kobo.895.1">, a commonly used benchmark that we previously optimized using genetic algorithms in </span><a href="B20851_06.xhtml#_idTextAnchor197" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.896.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.897.1">, </span><em class="italic"><span class="kobospan" id="kobo.898.1">Optimizing Continuous Functions</span></em><span class="kobospan" id="kobo.899.1">. </span><span class="kobospan" id="kobo.899.2">This function can be depicted </span><span><span class="kobospan" id="kobo.900.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer173">
<span class="kobospan" id="kobo.901.1"><img alt="Figure 16.8: Himmelblau’s function" src="image/B20851_16_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.902.1">Figure 16.8: Himmelblau’s function</span></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.903.1">Source: </span><a href="https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.904.1">https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg</span></a></p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.905.1">Image by Morn the Gorn. </span></p>
<p class="calibre3"><span class="kobospan" id="kobo.906.1">As a reminder, the function can be mathematically expressed </span><span><span class="kobospan" id="kobo.907.1">as follows:</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.908.1">f</span></span><span><span class="kobospan" id="kobo.909.1">(</span></span><span><span class="kobospan" id="kobo.910.1">x</span></span><span><span class="kobospan" id="kobo.911.1">,</span></span><span> </span><span><span class="kobospan" id="kobo.912.1">y</span></span><span><span class="kobospan" id="kobo.913.1">)</span></span><span> </span><span><span class="kobospan" id="kobo.914.1">=</span></span><span> </span><span><span class="kobospan" id="kobo.915.1">(</span></span><span><span class="kobospan" id="kobo.916.1">x</span></span><span><span class="kobospan" id="kobo.917.1"> </span></span><span><span class="kobospan" id="kobo.918.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.919.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.920.1">y</span></span><span> </span><span><span class="kobospan" id="kobo.921.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.922.1">11</span></span><span><span class="kobospan" id="kobo.923.1">)</span></span><span><span class="kobospan" id="kobo.924.1"> </span></span><span><span class="kobospan" id="kobo.925.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.926.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.927.1">(</span></span><span><span class="kobospan" id="kobo.928.1">x</span></span><span> </span><span><span class="kobospan" id="kobo.929.1">+</span></span><span> </span><span><span class="kobospan" id="kobo.930.1">y</span></span><span><span class="kobospan" id="kobo.931.1"> </span></span><span><span class="kobospan" id="kobo.932.1">2</span></span><span> </span><span><span class="kobospan" id="kobo.933.1">−</span></span><span> </span><span><span class="kobospan" id="kobo.934.1">7</span></span><span><span class="kobospan" id="kobo.935.1">)</span></span><span><span class="kobospan" id="kobo.936.1"> </span></span><span><span class="kobospan" id="kobo.937.1">2</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.938.1">It has four global minima, evaluating</span><a id="_idIndexMarker997" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.939.1"> to 0, indicated by the blue areas in the plot. </span><span class="kobospan" id="kobo.939.2">These are located at the </span><span><span class="kobospan" id="kobo.940.1">following coordinates:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><em class="italic"><span class="kobospan" id="kobo.941.1">x=3.0, y=2.0</span></em></span></li>
<li class="calibre11"><span><em class="italic"><span class="kobospan" id="kobo.942.1">x=−2.805118, y=3.131312</span></em></span></li>
<li class="calibre11"><span><em class="italic"><span class="kobospan" id="kobo.943.1">x=−3.779310, y=−3.283186</span></em></span></li>
<li class="calibre11"><span><em class="italic"><span class="kobospan" id="kobo.944.1">x=3.584458, y=−1.848126</span></em></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.945.1">For our example, we will attempt to find any one of </span><span><span class="kobospan" id="kobo.946.1">these minima.</span></span></p>
<h2 id="_idParaDest-342" class="calibre7"><a id="_idTextAnchor394" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.947.1">Particle swarm optimization implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.948.1">To locate a minimum of </span><em class="italic"><span class="kobospan" id="kobo.949.1">Himmelblau’s function</span></em><span class="kobospan" id="kobo.950.1"> using particle swarm optimization, we’ve created a Python program called </span><strong class="source-inline"><span class="kobospan" id="kobo.951.1">04_pso_himmelblau.py</span></strong> <span><span class="kobospan" id="kobo.952.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/04_pso_himmelblau.py" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.953.1">https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/04_pso_himmelblau.py</span></span></a><span><span class="kobospan" id="kobo.954.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.955.1">The following steps</span><a id="_idIndexMarker998" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.956.1"> describe the main parts of </span><span><span class="kobospan" id="kobo.957.1">this program:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.958.1">We start by setting various constants that will be used throughout the program. </span><span class="kobospan" id="kobo.958.2">First, we have the </span><em class="italic"><span class="kobospan" id="kobo.959.1">dimensionality</span></em><span class="kobospan" id="kobo.960.1"> of the problem at hand – </span><strong class="source-inline1"><span class="kobospan" id="kobo.961.1">2</span></strong><span class="kobospan" id="kobo.962.1">, in our case – which, in turn, determines the dimensionality of the </span><em class="italic"><span class="kobospan" id="kobo.963.1">location</span></em><span class="kobospan" id="kobo.964.1"> and </span><em class="italic"><span class="kobospan" id="kobo.965.1">velocity</span></em><span class="kobospan" id="kobo.966.1"> of each particle. </span><span class="kobospan" id="kobo.966.2">Next comes the population size – the total number of particles in the swarm – and the number of generations, or iterations, of running </span><span><span class="kobospan" id="kobo.967.1">the algorithm:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.968.1">
DIMENSIONS = 2
POPULATION_SIZE = 20
MAX_GENERATIONS = 500</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.969.1">This is followed by several additional constants that affect how the particles are created and updated. </span><span class="kobospan" id="kobo.969.2">We will see how they play their roles as we examine the rest of </span><span><span class="kobospan" id="kobo.970.1">the program:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.971.1">
MIN_START_POSITION, MAX_START_POSITION = -5, 5
MIN_SPEED, MAX_SPEED = -3, 3
MAX_LOCAL_UPDATE_FACTOR = MAX_GLOBAL_UPDATE_FACTOR = 2.0</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.972.1">Since our goal is to locate a minimum in </span><em class="italic"><span class="kobospan" id="kobo.973.1">Himmelblau’s function</span></em><span class="kobospan" id="kobo.974.1">, we need to define a single objective – that is, minimizing the </span><span><span class="kobospan" id="kobo.975.1">fitness strategy:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.976.1">
creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.977.1">FitnessMin</span></strong><span class="kobospan1" id="kobo.978.1">", base.Fitness, weights=(-1.0,))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.979.1">Now, we need to create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.980.1">Particle</span></strong><span class="kobospan" id="kobo.981.1"> class. </span><span class="kobospan" id="kobo.981.2">Since this class represents a location in the continuous space, we could base it on an ordinary list of floats. </span><span class="kobospan" id="kobo.981.3">However, here, we decided to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.982.1">numpy</span></strong><span class="kobospan" id="kobo.983.1"> library’s </span><em class="italic"><span class="kobospan" id="kobo.984.1">N</span></em><span class="kobospan" id="kobo.985.1">-dimensional array (</span><strong class="source-inline1"><span class="kobospan" id="kobo.986.1">ndarray</span></strong><span class="kobospan" id="kobo.987.1">) since it lends itself to element-wise algebraic operations such as addition and multiplication, which will be needed when we update the particle’s location. </span><span class="kobospan" id="kobo.987.2">Besides the</span><a id="_idIndexMarker999" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.988.1"> current location, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.989.1">Particle</span></strong><span class="kobospan" id="kobo.990.1"> class is given several </span><span><span class="kobospan" id="kobo.991.1">additional attributes:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.992.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.993.1">fitness</span></strong><span class="kobospan" id="kobo.994.1"> attribute, using the minimizing fitness we </span><span><span class="kobospan" id="kobo.995.1">defined earlier.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.996.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.997.1">speed</span></strong><span class="kobospan" id="kobo.998.1"> attribute, which is used to hold the current speed of the particle in each dimension. </span><span class="kobospan" id="kobo.998.2">Although its initial value is </span><strong class="source-inline1"><span class="kobospan" id="kobo.999.1">None</span></strong><span class="kobospan" id="kobo.1000.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1001.1">speed</span></strong><span class="kobospan" id="kobo.1002.1"> will be populated with another </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1003.1">ndarray</span></strong></span><span><span class="kobospan" id="kobo.1004.1"> later.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.1005.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1006.1">best</span></strong><span class="kobospan" id="kobo.1007.1"> attribute, which represents the best location that’s been recorded so far for this particular particle (</span><span><em class="italic"><span class="kobospan" id="kobo.1008.1">local best</span></em></span><span><span class="kobospan" id="kobo.1009.1">).</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.1010.1">The resulting definition for the </span><strong class="source-inline"><span class="kobospan" id="kobo.1011.1">Particle</span></strong><span class="kobospan" id="kobo.1012.1"> class creator looks </span><span><span class="kobospan" id="kobo.1013.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.1014.1">
 creator.create("</span><strong class="bold1"><span class="kobospan1" id="kobo.1015.1">Particle</span></strong><span class="kobospan1" id="kobo.1016.1">",
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1017.1">np.ndarray</span></strong><span class="kobospan1" id="kobo.1018.1">,
    fitness=creator.FitnessMin,
    speed=None,
    best=None)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1019.1">To help us construct an individual particle in the population, we need to define a helper function that will create and initialize a random particle. </span><span class="kobospan" id="kobo.1019.2">We will use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1020.1">numpy</span></strong><span class="kobospan" id="kobo.1021.1"> library’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.1022.1">random.uniform()</span></strong><span class="kobospan" id="kobo.1023.1"> function to randomly generate the location and speed arrays of the new particle, within the </span><span><span class="kobospan" id="kobo.1024.1">given boundaries:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1025.1">
def createParticle():
    particle = </span><strong class="bold1"><span class="kobospan1" id="kobo.1026.1">creator.Particle</span></strong><span class="kobospan1" id="kobo.1027.1">(
        np.random.uniform(
            MIN_START_POSITION,
            MAX_START_POSITION,
            DIMENSIONS))
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1028.1">particle.speed</span></strong><span class="kobospan1" id="kobo.1029.1"> = np.random.uniform(
        MIN_SPEED,
        MAX_SPEED,
        DIMENSIONS)
    return particle</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1030.1">This function is used in the definition of the operator that creates a particle instance. </span><span class="kobospan" id="kobo.1030.2">This, in turn, is used by the population </span><span><span class="kobospan" id="kobo.1031.1">creation operator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1032.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1033.1">particleCreator</span></strong><span class="kobospan1" id="kobo.1034.1">", createParticle)
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1035.1">populationCreator</span></strong><span class="kobospan1" id="kobo.1036.1">",
                  tools.initRepeat,
                  list,
                  toolbox.particleCreator)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1037.1">Next comes the method that serves</span><a id="_idIndexMarker1000" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1038.1"> as the heart of the algorithm, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1039.1">updateParticle()</span></strong><span class="kobospan" id="kobo.1040.1">. </span><span class="kobospan" id="kobo.1040.2">This method is responsible for updating the location and speed of each particle in the population. </span><span class="kobospan" id="kobo.1040.3">The arguments of this function are a single particle in the population and the best currently </span><span><span class="kobospan" id="kobo.1041.1">recorded position.</span></span><p class="calibre3"><span class="kobospan" id="kobo.1042.1">The method starts by creating two random update factors – one for the local update and the other for the global update – within the preset range. </span><span class="kobospan" id="kobo.1042.2">Then, it calculates two corresponding speed updates (local and global) and adds them to the current </span><span><span class="kobospan" id="kobo.1043.1">particle’s speed.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.1044.1">Note that all the values that are involved that are of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1045.1">ndarray</span></strong><span class="kobospan" id="kobo.1046.1"> type are </span><em class="italic"><span class="kobospan" id="kobo.1047.1">two- dimensional</span></em><span class="kobospan" id="kobo.1048.1"> in our case, and the calculations are performed element-wise, one </span><span><span class="kobospan" id="kobo.1049.1">per dimension.</span></span></p></li>
<li class="calibre11"><span class="kobospan" id="kobo.1050.1">The updated particle speed is </span><a id="_idIndexMarker1001" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1051.1">effectively a combination of the particle’s original speed (representing </span><em class="italic"><span class="kobospan" id="kobo.1052.1">inertia</span></em><span class="kobospan" id="kobo.1053.1">), the particle’s best-known location (</span><em class="italic"><span class="kobospan" id="kobo.1054.1">cognitive force</span></em><span class="kobospan" id="kobo.1055.1">), and the best-known location of the entire population (</span><span><em class="italic"><span class="kobospan" id="kobo.1056.1">social force</span></em></span><span><span class="kobospan" id="kobo.1057.1">):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1058.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.1059.1">updateParticle</span></strong><span class="kobospan1" id="kobo.1060.1">(particle, best):
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1061.1">localUpdateFactor </span></strong><span class="kobospan1" id="kobo.1062.1">= np.random.uniform(
        0,
        MAX_LOCAL_UPDATE_FACTOR,
        particle.size)
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1063.1">globalUpdateFactor </span></strong><span class="kobospan1" id="kobo.1064.1">= np.random.uniform(
        0,
        MAX_GLOBAL_UPDATE_FACTOR,
        particle.size)
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1065.1">localSpeedUpdate </span></strong><span class="kobospan1" id="kobo.1066.1">= localUpdateFactor *
        (particle.best - particle)
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1067.1">globalSpeedUpdate </span></strong><span class="kobospan1" id="kobo.1068.1">= globalUpdateFactor * (best - particle)
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1069.1">particle.speed</span></strong><span class="kobospan1" id="kobo.1070.1"> = particle.speed +
        (localSpeedUpdate + lobalSpeedUpdate)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1071.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1072.1">updateParticle()</span></strong><span class="kobospan" id="kobo.1073.1"> method continues by making sure that the new speed does not exceed the preset limits and updates the location of the particles using the updated speed. </span><span class="kobospan" id="kobo.1073.2">As we mentioned previously, both </span><strong class="source-inline1"><span class="kobospan" id="kobo.1074.1">location</span></strong><span class="kobospan" id="kobo.1075.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.1076.1">speed</span></strong><span class="kobospan" id="kobo.1077.1"> are of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1078.1">ndarray</span></strong><span class="kobospan" id="kobo.1079.1"> type and have separate components for </span><span><span class="kobospan" id="kobo.1080.1">each dimension:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1081.1">particle.speed</span></strong><span class="kobospan1" id="kobo.1082.1"> = </span><strong class="bold1"><span class="kobospan1" id="kobo.1083.1">np.clip</span></strong><span class="kobospan1" id="kobo.1084.1">(particle.speed, MIN_SPEED, MAX_SPEED)
</span><strong class="bold1"><span class="kobospan1" id="kobo.1085.1">particle[:]</span></strong><span class="kobospan1" id="kobo.1086.1"> = particle + particle.speed</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1087.1">Then, we must register the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1088.1">updateParticle()</span></strong><span class="kobospan" id="kobo.1089.1"> method as a toolbox operator that will be in the main </span><span><span class="kobospan" id="kobo.1090.1">loop later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1091.1">
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1092.1">update</span></strong><span class="kobospan1" id="kobo.1093.1">", updateParticle)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1094.1">We still need to define</span><a id="_idIndexMarker1002" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1095.1"> the function to be optimized – </span><em class="italic"><span class="kobospan" id="kobo.1096.1">Himmelblau’s function</span></em><span class="kobospan" id="kobo.1097.1">, in our case – and register it as the fitness </span><span><span class="kobospan" id="kobo.1098.1">evaluation operator:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1099.1">
def </span><strong class="bold1"><span class="kobospan1" id="kobo.1100.1">himmelblau</span></strong><span class="kobospan1" id="kobo.1101.1">(particle):
    x = particle[0]
    y = particle[1]
    f = (x ** 2 + y - 11) ** 2 + (x + y ** 2 - 7) ** 2
    return f,  # return a tuple
toolbox.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1102.1">evaluate</span></strong><span class="kobospan1" id="kobo.1103.1">", himmelblau)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1104.1">Now that we’re finally at the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1105.1">main()</span></strong><span class="kobospan" id="kobo.1106.1"> method, we can start it by creating the population </span><span><span class="kobospan" id="kobo.1107.1">of particles:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1108.1">
population = toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1109.1">populationCreator</span></strong><span class="kobospan1" id="kobo.1110.1">(
    n=POPULATION_SIZE)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1111.1">Before starting the algorithm’s main loop, we need to create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1112.1">stats</span></strong><span class="kobospan" id="kobo.1113.1"> object, to calculate the population’s statistics, and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1114.1">logbook</span></strong><span class="kobospan" id="kobo.1115.1"> object, to record the statistics at </span><span><span class="kobospan" id="kobo.1116.1">every iteration:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1117.1">stats</span></strong><span class="kobospan1" id="kobo.1118.1"> = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1119.1">min</span></strong><span class="kobospan1" id="kobo.1120.1">", np.min)
stats.register("</span><strong class="bold1"><span class="kobospan1" id="kobo.1121.1">avg</span></strong><span class="kobospan1" id="kobo.1122.1">", np.mean)
</span><strong class="bold1"><span class="kobospan1" id="kobo.1123.1">logbook </span></strong><span class="kobospan1" id="kobo.1124.1">= tools.Logbook()
logbook.</span><strong class="bold1"><span class="kobospan1" id="kobo.1125.1">header </span></strong><span class="kobospan1" id="kobo.1126.1">= ["gen", "evals"] + stats.fields</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1127.1">The program’s main loop contains an external loop that iterates over the generations/update cycles. </span><span class="kobospan" id="kobo.1127.2">Within each iteration, there are two secondary loops, each iterating over all the particles in the population. </span><span class="kobospan" id="kobo.1127.3">The first loop, which can be seen in the</span><a id="_idIndexMarker1003" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1128.1"> following code, evaluates each particle against the function to be optimized and updates the </span><em class="italic"><span class="kobospan" id="kobo.1129.1">local best</span></em><span class="kobospan" id="kobo.1130.1"> and the </span><em class="italic"><span class="kobospan" id="kobo.1131.1">global best</span></em> <span><span class="kobospan" id="kobo.1132.1">if necessary:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1133.1">
particle.fitness.values = toolbox.evaluate(particle)
# local best:
if (</span><strong class="bold1"><span class="kobospan1" id="kobo.1134.1">particle.best</span></strong><span class="kobospan1" id="kobo.1135.1"> is None or particle.best.size == 0 or 
    particle.best.fitness &lt; particle.fitness):
    particle.best = creator.Particle(particle)
    particle.best.fitness.values = particle.fitness.values
# global best:
if (</span><strong class="bold1"><span class="kobospan1" id="kobo.1136.1">best</span></strong><span class="kobospan1" id="kobo.1137.1"> is None or best.size == 0 or 
    best.fitness &lt; particle.fitness):
    best = creator.Particle(particle)
    best.fitness.values = particle.fitness.values</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1138.1">The second inner loop calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1139.1">update</span></strong><span class="kobospan" id="kobo.1140.1"> operator. </span><span class="kobospan" id="kobo.1140.2">As we saw previously, this operator updates the speed and the location of the particle using a combination of </span><em class="italic"><span class="kobospan" id="kobo.1141.1">inertia</span></em><span class="kobospan" id="kobo.1142.1">, </span><em class="italic"><span class="kobospan" id="kobo.1143.1">cognitive force</span></em><span class="kobospan" id="kobo.1144.1">, and </span><span><em class="italic"><span class="kobospan" id="kobo.1145.1">social force</span></em></span><span><span class="kobospan" id="kobo.1146.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1147.1">
toolbox.</span><strong class="bold1"><span class="kobospan1" id="kobo.1148.1">update</span></strong><span class="kobospan1" id="kobo.1149.1">(particle, best)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1150.1">At the end of the outer loop, we record the statistics for the current generation and </span><span><span class="kobospan" id="kobo.1151.1">print them:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1152.1">logbook.record</span></strong><span class="kobospan1" id="kobo.1153.1">(gen=generation,
               evals=len(population),
               **stats.compile(population))
print(logbook.stream)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1154.1">Once the outer loop is done, we print the information for the best location that was recorded during the run. </span><span class="kobospan" id="kobo.1154.2">This is considered the solution that the algorithm has found for the problem </span><span><span class="kobospan" id="kobo.1155.1">at hand:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1156.1">
print("-- Best Particle = ", best)
print("-- Best Fitness = ", best.fitness.values[0])</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1157.1">By running this program, we</span><a id="_idIndexMarker1004" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1158.1"> get the </span><span><span class="kobospan" id="kobo.1159.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1160.1">
gen evals min avg
0 20 8.74399 167.468
1 20 19.0871 357.577
2 20 32.4961 219.132
...
</span><span class="kobospan1" id="kobo.1160.2">479 20 3.19693 316.08
480 20 0.00102484 322.134
481 20 3.32515 254.994
...
</span><span class="kobospan1" id="kobo.1160.3">497 20 7.2162 412.189
498 20 6.87945 273.712
499 20 16.1034 272.385
-- Best Particle = [-3.77695478 -3.28649153]
-- Best Fitness = 0.0010248367255068806</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1161.1">These results indicate that the algorithm was able to locate one of the minima, around x=−3.77 and y=−3.28. </span><span class="kobospan" id="kobo.1161.2">Looking at the stats we recorded along the way, we can see that the best result was achieved at generation 480. </span><span class="kobospan" id="kobo.1161.3">It is also evident that the particles move around quite a bit and, during the run, oscillate about the </span><span><span class="kobospan" id="kobo.1162.1">best result.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1163.1">To find the other minimum locations, you can rerun the algorithm with a different random seed. </span><span class="kobospan" id="kobo.1163.2">You can also penalize the solutions in the areas around the previously found minima, just like we did with </span><em class="italic"><span class="kobospan" id="kobo.1164.1">Simionescu’s function</span></em><span class="kobospan" id="kobo.1165.1"> in </span><a href="B20851_06.xhtml#_idTextAnchor197" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.1166.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.1167.1">, </span><em class="italic"><span class="kobospan" id="kobo.1168.1">Optimizing Continuous Functions</span></em><span class="kobospan" id="kobo.1169.1">. </span><span class="kobospan" id="kobo.1169.2">Another approach could be using multiple simultaneous swarms to locate several minima in the same run – you are encouraged to try this on your own (see the </span><em class="italic"><span class="kobospan" id="kobo.1170.1">Further reading</span></em><span class="kobospan" id="kobo.1171.1"> section for </span><span><span class="kobospan" id="kobo.1172.1">more information).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1173.1">In the next section, we will</span><a id="_idIndexMarker1005" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1174.1"> briefly review several more members of the extended evolutionary </span><span><span class="kobospan" id="kobo.1175.1">computation family.</span></span></p>
<h1 id="_idParaDest-343" class="calibre5"><a id="_idTextAnchor395" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1176.1">Other related techniques</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1177.1">Besides the techniques we have covered so far, numerous other problem-solving and optimization techniques draw their inspiration from the Darwinian evolution theory, as well as from various biological systems and behaviors. </span><span class="kobospan" id="kobo.1177.2">The following subsections briefly describe several more of </span><span><span class="kobospan" id="kobo.1178.1">these techniques.</span></span></p>
<h2 id="_idParaDest-344" class="calibre7"><a id="_idTextAnchor396" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1179.1">Evolution strategies</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1180.1">Evolution strategies</span></strong><span class="kobospan" id="kobo.1181.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1182.1">ES</span></strong><span class="kobospan" id="kobo.1183.1">) are a kind of genetic algorithm that emphasizes </span><em class="italic"><span class="kobospan" id="kobo.1184.1">mutation</span></em><span class="kobospan" id="kobo.1185.1"> rather than </span><em class="italic"><span class="kobospan" id="kobo.1186.1">crossover</span></em><span class="kobospan" id="kobo.1187.1"> as the evolutionary</span><a id="_idIndexMarker1006" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1188.1"> facilitator. </span><span class="kobospan" id="kobo.1188.2">The mutation is adaptive, and its strength is learned over the generations. </span><span class="kobospan" id="kobo.1188.3">The selection operator in ES is always based on </span><em class="italic"><span class="kobospan" id="kobo.1189.1">rank</span></em><span class="kobospan" id="kobo.1190.1"> rather than on actual fitness values. </span><span class="kobospan" id="kobo.1190.2">A simple version of this technique is called </span><em class="italic"><span class="kobospan" id="kobo.1191.1">(1 + 1)</span></em><span class="kobospan" id="kobo.1192.1">. </span><span class="kobospan" id="kobo.1192.2">It includes only two individuals – a parent and its mutated offspring. </span><span class="kobospan" id="kobo.1192.3">The best of them continue to be the parent of the next mutated offspring. </span><span class="kobospan" id="kobo.1192.4">In the more general case, called </span><em class="italic"><span class="kobospan" id="kobo.1193.1">(1 + λ)</span></em><span class="kobospan" id="kobo.1194.1">, there is one parent and λ mutated offspring, and the best of the offspring continues to be the parent of the next λ offspring. </span><span class="kobospan" id="kobo.1194.2">Some newer variations of the algorithm include more than one parent, as well as a </span><span><em class="italic"><span class="kobospan" id="kobo.1195.1">crossover</span></em></span><span><span class="kobospan" id="kobo.1196.1"> operator.</span></span></p>
<h2 id="_idParaDest-345" class="calibre7"><a id="_idTextAnchor397" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1197.1">Differential evolution</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1198.1">Differential evolution</span></strong><span class="kobospan" id="kobo.1199.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1200.1">DE</span></strong><span class="kobospan" id="kobo.1201.1">) is a specialized variant of genetic algorithms that’s used to optimize real-valued functions. </span><span class="kobospan" id="kobo.1201.2">DE differs from genetic algorithms in the </span><span><span class="kobospan" id="kobo.1202.1">following aspects:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1203.1">The DE population is </span><a id="_idIndexMarker1007" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1204.1">always represented as a collection of </span><span><span class="kobospan" id="kobo.1205.1">real-valued vectors.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1206.1">Instead of replacing the entire current generation with a new generation, DE keeps iterating over the population, modifying one individual at a time, or keeping the original individual if it’s better than its </span><span><span class="kobospan" id="kobo.1207.1">modified version.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1208.1">The traditional </span><em class="italic"><span class="kobospan" id="kobo.1209.1">crossover</span></em><span class="kobospan" id="kobo.1210.1"> and </span><em class="italic"><span class="kobospan" id="kobo.1211.1">mutation</span></em><span class="kobospan" id="kobo.1212.1"> operators are replaced by specialized ones, thereby modifying the value of the current individual using the values of three other individuals that are chosen </span><span><span class="kobospan" id="kobo.1213.1">at random.</span></span></li>
</ul>
<h2 id="_idParaDest-346" class="calibre7"><a id="_idTextAnchor398" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1214.1">Ant colony optimization</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1215.1">Ant colony optimization</span></strong><span class="kobospan" id="kobo.1216.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1217.1">ACO</span></strong><span class="kobospan" id="kobo.1218.1">) algorithms are inspired by the way certain species of ants locate food. </span><span class="kobospan" id="kobo.1218.2">The ants start </span><a id="_idIndexMarker1008" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1219.1">by wandering randomly, and when any of them locates food, they go back to their colony while depositing pheromones along the way, marking the path for other ants. </span><span class="kobospan" id="kobo.1219.2">Other ants finding food at the same location will reinforce the trail by depositing their own pheromones. </span><span class="kobospan" id="kobo.1219.3">The pheromone marks fade away over time, giving the shorter paths and the paths that are traveled more often </span><span><span class="kobospan" id="kobo.1220.1">an advantage.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1221.1">ACO algorithms use artificial ants that move about in the search space looking for the location of the best solutions. </span><span class="kobospan" id="kobo.1221.2">The “ants” keep track of their locations and the candidate solutions they have found along the way. </span><span class="kobospan" id="kobo.1221.3">This information is used by the ants of the subsequent iterations so that they can find better solutions. </span><span class="kobospan" id="kobo.1221.4">These algorithms are often combined with the </span><em class="italic"><span class="kobospan" id="kobo.1222.1">local search</span></em><span class="kobospan" id="kobo.1223.1"> method, which is activated after locating an area </span><span><span class="kobospan" id="kobo.1224.1">of interest.</span></span></p>
<h2 id="_idParaDest-347" class="calibre7"><a id="_idTextAnchor399" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1225.1">Artificial immune systems</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1226.1">Artificial immune systems</span></strong><span class="kobospan" id="kobo.1227.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1228.1">AIS</span></strong><span class="kobospan" id="kobo.1229.1">) draw their inspiration</span><a id="_idIndexMarker1009" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1230.1"> from the characteristics of adaptive immune systems found in mammals. </span><span class="kobospan" id="kobo.1230.2">These systems are capable of identifying and learning new threats, as well as applying the acquired knowledge and responding faster the next time a similar threat </span><span><span class="kobospan" id="kobo.1231.1">is detected.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1232.1">Recent AIS can be used in various machine learning and optimization tasks, and generally belong to one of the </span><a id="_idIndexMarker1010" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1233.1">following </span><span><span class="kobospan" id="kobo.1234.1">three subfields:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1235.1">Clonal selection</span></strong><span class="kobospan" id="kobo.1236.1">: This involves imitating the process by which the immune system selects the best cell to recognize and eliminate an antigen that enters the body. </span><span class="kobospan" id="kobo.1236.2">The cell is chosen out of a pool of pre-existing cells with varying specificities, and once chosen, it is cloned to create a population of cells that eliminates the invading antigen. </span><span class="kobospan" id="kobo.1236.3">This paradigm is typically applied to optimization and pattern </span><span><span class="kobospan" id="kobo.1237.1">recognition tasks.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1238.1">Negative selection</span></strong><span class="kobospan" id="kobo.1239.1">: This follows a process that identifies and deletes cells that may attack self-tissues. </span><span class="kobospan" id="kobo.1239.2">These algorithms are typically used in anomaly detection tasks, where normal patterns are used to “negatively” train filters that will then be able to detect </span><span><span class="kobospan" id="kobo.1240.1">anomalous patterns.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1241.1">Immune network algorithms</span></strong><span class="kobospan" id="kobo.1242.1">: This is inspired by the theory that suggests that the immune system is regulated using special types of antibodies that bind to other antibodies. </span><span class="kobospan" id="kobo.1242.2">In this type of algorithm, antibodies represent nodes in a network and the learning process involves creating or removing edges between the nodes, resulting in an evolving network graph structure. </span><span class="kobospan" id="kobo.1242.3">These algorithms are typically used in non-supervised machine learning tasks, as well as in the fields of control </span><span><span class="kobospan" id="kobo.1243.1">and optimization.</span></span></li>
</ul>
<h2 id="_idParaDest-348" class="calibre7"><a id="_idTextAnchor400" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1244.1">Artificial life</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1245.1">Rather than being a branch of evolutionary computation, </span><strong class="bold"><span class="kobospan" id="kobo.1246.1">artificial life</span></strong><span class="kobospan" id="kobo.1247.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1248.1">ALife</span></strong><span class="kobospan" id="kobo.1249.1">) is a broader field that involves systems and</span><a id="_idIndexMarker1011" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1250.1"> processes that imitate natural life in different ways, such as computer simulations and </span><span><span class="kobospan" id="kobo.1251.1">robotic systems.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1252.1">Evolutionary computation can be viewed as an application of ALife, where the population seeking to optimize a certain fitness function is a metaphor for organisms searching for food. </span><span class="kobospan" id="kobo.1252.2">The niching and sharing mechanisms, which we described in </span><a href="B20851_02.xhtml#_idTextAnchor053" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.1253.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.1254.1">, </span><em class="italic"><span class="kobospan" id="kobo.1255.1">Understanding the Key Components of Genetic Algorithms</span></em><span class="kobospan" id="kobo.1256.1">, draw directly from the </span><span><span class="kobospan" id="kobo.1257.1">food metaphor.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1258.1">The main branches of ALife are </span><span><span class="kobospan" id="kobo.1259.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1260.1">Soft</span></strong><span class="kobospan" id="kobo.1261.1">: Represents </span><a id="_idIndexMarker1012" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1262.1">software-based (</span><span><span class="kobospan" id="kobo.1263.1">digital) simulation</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1264.1">Hard</span></strong><span class="kobospan" id="kobo.1265.1">: Represents</span><a id="_idIndexMarker1013" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1266.1"> hardware-based (</span><span><span class="kobospan" id="kobo.1267.1">physical) robotics</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1268.1">Wet</span></strong><span class="kobospan" id="kobo.1269.1">: Represents biochemical-based</span><a id="_idIndexMarker1014" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1270.1"> manipulation or </span><span><span class="kobospan" id="kobo.1271.1">synthetic biology</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1272.1">ALife can also be viewed </span><a id="_idIndexMarker1015" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1273.1">as the bottom-up counterpart to artificial intelligence since ALife typically builds on the biological environment, mechanisms, and structures rather than </span><span><span class="kobospan" id="kobo.1274.1">high-level cognition.</span></span></p>
<h1 id="_idParaDest-349" class="calibre5"><a id="_idTextAnchor401" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1275.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1276.1">In this chapter, you were introduced to the extended family of </span><em class="italic"><span class="kobospan" id="kobo.1277.1">evolutionary computation</span></em><span class="kobospan" id="kobo.1278.1"> and some of the common characteristics of its members. </span><span class="kobospan" id="kobo.1278.2">Then, we used </span><em class="italic"><span class="kobospan" id="kobo.1279.1">genetic programming</span></em><span class="kobospan" id="kobo.1280.1"> – a special case of genetic algorithms – to implement the </span><em class="italic"><span class="kobospan" id="kobo.1281.1">even parity check</span></em><span class="kobospan" id="kobo.1282.1"> task using Boolean logic </span><span><span class="kobospan" id="kobo.1283.1">building blocks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1284.1">Next, we created a neural network implementation of the same even parity check task by utilizing the </span><span><span class="kobospan" id="kobo.1285.1">NEAT technique.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1286.1">This was followed by creating a program that utilized the </span><em class="italic"><span class="kobospan" id="kobo.1287.1">particle swarm optimization</span></em><span class="kobospan" id="kobo.1288.1"> technique to optimize </span><span><em class="italic"><span class="kobospan" id="kobo.1289.1">Himmelblau’s function</span></em></span><span><span class="kobospan" id="kobo.1290.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1291.1">We concluded this chapter with a brief overview of several other related </span><span><span class="kobospan" id="kobo.1292.1">problem-solving techniques.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1293.1">Now that this book has come to its end, I wanted to thank you for taking this journey with me while going through the various aspects and use cases of genetic algorithms and evolutionary computation. </span><span class="kobospan" id="kobo.1293.2">I hope that you found this book interesting as well as thought-provoking. </span><span class="kobospan" id="kobo.1293.3">As this book demonstrated, genetic algorithms and their related techniques can be applied to a plethora of tasks in virtually any computation and engineering field, including – very likely – the ones you are currently involved with. </span><span class="kobospan" id="kobo.1293.4">Remember, all that is required for the genetic algorithm to start crunching a problem is a way to represent a solution and a way to evaluate a solution – or compare two solutions. </span><span class="kobospan" id="kobo.1293.5">Since this is the age of artificial intelligence and cloud computing, you will find that genetic algorithms lend themselves well to both and can be a powerful tool in your arsenal when you’re approaching a </span><span><span class="kobospan" id="kobo.1294.1">new challenge.</span></span></p>
<h1 id="_idParaDest-350" class="calibre5"><a id="_idTextAnchor402" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1295.1">Further reading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1296.1">For more information, please refer to the </span><span><span class="kobospan" id="kobo.1297.1">following resources:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1298.1">Genetic Programming: bio-inspired machine </span></em><span><em class="italic"><span class="kobospan" id="kobo.1299.1">learning</span></em></span><span><span class="kobospan" id="kobo.1300.1">: </span></span><a href="http://geneticprogramming.com/tutorial/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1301.1">http://geneticprogramming.com/tutorial/</span></span></a></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1302.1">Artificial Intelligence for Big Data</span></em><span class="kobospan" id="kobo.1303.1">, by Manish Kumar and Anand Deshpande, May </span><span><span class="kobospan" id="kobo.1304.1">21, 2018</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1305.1">Hands-On Neuroevolution with Python</span></em><span class="kobospan" id="kobo.1306.1">, by Iaroslav Omelianenko, December </span><span><span class="kobospan" id="kobo.1307.1">24, 2019</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1308.1">Multimodal optimization using particle swarm optimization algorithms</span></em><span class="kobospan" id="kobo.1309.1">: CEC 2015 competition on single objective multi-niche </span><span><span class="kobospan" id="kobo.1310.1">optimization: </span></span><a href="https://ieeexplore.ieee.org/document/7257009" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.1311.1">https://ieeexplore.ieee.org/document/7257009</span></span></a></li>
</ul>
</div>
</body></html>