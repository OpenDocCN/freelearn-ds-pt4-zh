["```py\n    NUM_INPUTS = 3\n    NUM_COMBINATIONS = 2 ** NUM_INPUTS\n    ```", "```py\n    POPULATION_SIZE = 60\n    P_CROSSOVER = 0.9\n    P_MUTATION = 0.5\n    MAX_GENERATIONS = 20\n    HALL_OF_FAME_SIZE = 10\n    ```", "```py\n    MIN_TREE_HEIGHT = 3\n    MAX_TREE_HEIGHT = 5\n    MUT_MIN_TREE_HEIGHT = 0\n    MUT_MAX_TREE_HEIGHT = 2\n    LIMIT_TREE_HEIGHT = 17\n    ```", "```py\n    parityIn = list(itertools.product([0, 1], repeat=NUM_INPUTS))\n    parityOut = [sum(row) % 2 for row in parityIn]\n    ```", "```py\n    primitiveSet = gp.PrimitiveSet(\"main\", NUM_INPUTS, \"in_\")\n    ```", "```py\n    primitiveSet.addPrimitive(operator.and_, 2)\n    primitiveSet.addPrimitive(operator.or_, 2)\n    primitiveSet.addPrimitive(operator.xor, 2)\n    primitiveSet.addPrimitive(operator.not_, 1)\n    ```", "```py\n    primitiveSet.addTerminal(1)\n    primitiveSet.addTerminal(0)\n    ```", "```py\n    creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))\n    ```", "```py\n    creator.create(\"Individual\", gp.PrimitiveTree,\\\n        fitness=creator.FitnessMin)\n    ```", "```py\n    toolbox.register(\"expr\",\n                      gp.genFull,\n                      pset=primitiveSet,\n                      min_=MIN_TREE_HEIGHT,\n                      max_=MAX_TREE_HEIGHT)\n    ```", "```py\n    toolbox.register(\"individualCreator\",\n                      tools.initIterate,\n                      creator.Individual,\n                      toolbox.expr)\n    toolbox.register(\"populationCreator\",\n                      tools.initRepeat,\n                      list,\n                      toolbox.individualCreator)\n    ```", "```py\n    toolbox.register(\"compile\", gp.compile, pset=primitiveSet)\n    def parityError(individual):\n        func = toolbox.compile(expr=individual)\n        return sum(func(*pIn) != pOut for pIn,\n            pOut in zip(parityIn, parityOut))\n    ```", "```py\n    def getCost(individual):\n        return parityError(individual),\n    toolbox.register(\"evaluate\", getCost)\n    ```", "```py\n    toolbox.register(\"select\", tools.selTournament, tournsize=2)\n    ```", "```py\n    toolbox.register(\"mate\", gp.cxOnePoint)\n    ```", "```py\n    toolbox.register(\"expr_mut\",\n                      gp.genGrow,\n                      min_=MUT_MIN_TREE_HEIGHT,\n                      max_=MUT_MAX_TREE_HEIGHT)\n    toolbox.register(\"mutate\",\n                      gp.mutUniform,\n                      expr=toolbox.expr_mut,\n                      pset=primitiveSet)\n    ```", "```py\n    toolbox.decorate(\"mate\",\n        gp.staticLimit(\n            key=operator.attrgetter(\"height\"),\n            max_value=LIMIT_TREE_HEIGHT))\n    toolbox.decorate(\"mutate\",\n        gp.staticLimit(\n            key=operator.attrgetter(\"height\"),\n            max_value=LIMIT_TREE_HEIGHT))\n    ```", "```py\n    population, logbook = elitism.eaSimpleWithElitism(\n        population,\n        toolbox,\n        cxpb=P_CROSSOVER,\n        mutpb=P_MUTATION,\n        ngen=MAX_GENERATIONS,\n        stats=stats,\n        halloffame=hof,\n        verbose=True)\n    ```", "```py\n    best = hof.items[0]\n    print(\"-- Best Individual = \", best)\n    print(f\"-- length={len(best)}, height={best.height}\")\n    print(\"-- Best Fitness = \", best.fitness.values[0])\n    ```", "```py\n    nodes, edges, labels = gp.graph(best)\n    g = nx.Graph()\n    g.add_nodes_from(nodes)\n    g.add_edges_from(edges)\n    pos = nx.spring_layout(g)\n    ```", "```py\n    nx.draw_networkx_nodes(g, pos, node_color='cyan')\n    nx.draw_networkx_nodes(g, pos, nodelist=[0],\n        node_color='red', node_size=400)\n    nx.draw_networkx_edges(g, pos)\n    nx.draw_networkx_labels(g, pos, **{\"labels\": labels, \n        \"font_size\": 8})\n    ```", "```py\n    gen nevals min avg\n    0 60 2 3.91667\n    1 50 1 3.75\n    2 47 1 3.45\n    ...\n    5 47 0 3.15\n    ...\n    20 48 0 1.68333\n    -- Best Individual = xor(and_(not_(and_(in_1, in_2)), not_(and_(1, in_2))), xor(or_(xor(in_1, in_0), and_(0, 0)), 1))\n    -- length=19, height=4\n    -- Best Fitness = 0.0\n    ```", "```py\n    def getCost(individual):\n        return parityError(individual) +\n                   individual.height / 100,\n    ```", "```py\n    print(\"-- Best Parity Error = \", parityError(best))\n    ```", "```py\ngen nevals min avg\n0 60 2.03 3.9565\n1 50 2.03 3.7885\n...\n5 47 0.04 3.45233\n...\n10 48 0.03 3.0145\n...\n15 49 0.02 2.57983\n...\n20 45 0.02 2.88533\n-- Best Individual = xor(xor(in_0, in_1), in_2)\n-- length=5, height=2\n-- Best Fitness = 0.02\n-- Best Parity Error = 0\n```", "```py\npip install neatpy\n```", "```py\npip install pygame\n```", "```py\n    IMAGE_PATH = os.path.join(\n        os.path.dirname(os.path.realpath(__file__)),\n        \"images\")\n    if not os.path.exists(IMAGE_PATH):\n        os.makedirs(IMAGE_PATH)\n    ```", "```py\n    pg.init()\n    screen = pg.display.set_mode((400, 400))\n    screen.fill(colors['lightblue'])\n    ```", "```py\n        Options.set_options(NUM_INPUTS, 1, 150, 2**NUM_INPUTS - 0.1)\n        ```", "```py\n    parityIn = list(itertools.product([0, 1], repeat=NUM_INPUTS))\n    parityOut = [sum(row) % 2 for row in parityIn]\n    ```", "```py\n    score = 2**NUM_INPUTS\n    for pIn, pOut in zip(parityIn, parityOut):\n        output = nn.predict(pIn)[0]\n        score-= (output - pOut) ** 2\n    ```", "```py\n    score -= len(nn.nodes) * 0.01\n    ```", "```py\n    for nn in p.pool:\n        nn.fitness = parityScore(nn)\n    ```", "```py\nbest fitness = 7.9009068332812635\nNumber of nodes = 7\nChecking the truth table:\ninput (0, 0, 0), expected output 0, got 0.050 -> 0\ninput (0, 0, 1), expected output 1, got 0.963 -> 1\ninput (0, 1, 0), expected output 1, got 0.933 -> 1\ninput (0, 1, 1), expected output 0, got 0.077 -> 0\ninput (1, 0, 0), expected output 1, got 0.902 -> 1\ninput (1, 0, 1), expected output 0, got 0.042 -> 0\ninput (1, 1, 0), expected output 0, got 0.029 -> 0\ninput (1, 1, 1), expected output 1, got 0.949 -> 1\n```", "```py\n    DIMENSIONS = 2\n    POPULATION_SIZE = 20\n    MAX_GENERATIONS = 500\n    ```", "```py\n    MIN_START_POSITION, MAX_START_POSITION = -5, 5\n    MIN_SPEED, MAX_SPEED = -3, 3\n    MAX_LOCAL_UPDATE_FACTOR = MAX_GLOBAL_UPDATE_FACTOR = 2.0\n    ```", "```py\n    creator.create(\"Particle class creator looks as follows:\n\n    ```", "```py\n\n    ```", "```py\n    def createParticle():\n        particle = creator.Particle(\n            np.random.uniform(\n                MIN_START_POSITION,\n                MAX_START_POSITION,\n                DIMENSIONS))\n        particle.speed = np.random.uniform(\n            MIN_SPEED,\n            MAX_SPEED,\n            DIMENSIONS)\n        return particle\n    ```", "```py\n    toolbox.register(\"particleCreator\", createParticle)\n    toolbox.register(\"populationCreator\",\n                      tools.initRepeat,\n                      list,\n                      toolbox.particleCreator)\n    ```", "```py\n    def updateParticle(particle, best):\n        localUpdateFactor = np.random.uniform(\n            0,\n            MAX_LOCAL_UPDATE_FACTOR,\n            particle.size)\n        globalUpdateFactor = np.random.uniform(\n            0,\n            MAX_GLOBAL_UPDATE_FACTOR,\n            particle.size)\n        localSpeedUpdate = localUpdateFactor *\n            (particle.best - particle)\n        globalSpeedUpdate = globalUpdateFactor * (best - particle)\n        particle.speed = particle.speed +\n            (localSpeedUpdate + lobalSpeedUpdate)\n    ```", "```py\n    particle.speed = np.clip(particle.speed, MIN_SPEED, MAX_SPEED)\n    particle[:] = particle + particle.speed\n    ```", "```py\n    toolbox.register(\"update\", updateParticle)\n    ```", "```py\n    def himmelblau(particle):\n        x = particle[0]\n        y = particle[1]\n        f = (x ** 2 + y - 11) ** 2 + (x + y ** 2 - 7) ** 2\n        return f,  # return a tuple\n    toolbox.register(\"evaluate\", himmelblau)\n    ```", "```py\n    population = toolbox.populationCreator(\n        n=POPULATION_SIZE)\n    ```", "```py\n    stats = tools.Statistics(lambda ind: ind.fitness.values)\n    stats.register(\"min\", np.min)\n    stats.register(\"avg\", np.mean)\n    logbook = tools.Logbook()\n    logbook.header = [\"gen\", \"evals\"] + stats.fields\n    ```", "```py\n    particle.fitness.values = toolbox.evaluate(particle)\n    # local best:\n    if (particle.best is None or particle.best.size == 0 or \n        particle.best.fitness < particle.fitness):\n        particle.best = creator.Particle(particle)\n        particle.best.fitness.values = particle.fitness.values\n    # global best:\n    if (best is None or best.size == 0 or \n        best.fitness < particle.fitness):\n        best = creator.Particle(particle)\n        best.fitness.values = particle.fitness.values\n    ```", "```py\n    toolbox.update(particle, best)\n    ```", "```py\n    logbook.record(gen=generation,\n                   evals=len(population),\n                   **stats.compile(population))\n    print(logbook.stream)\n    ```", "```py\n    print(\"-- Best Particle = \", best)\n    print(\"-- Best Fitness = \", best.fitness.values[0])\n    ```", "```py\ngen evals min avg\n0 20 8.74399 167.468\n1 20 19.0871 357.577\n2 20 32.4961 219.132\n...\n479 20 3.19693 316.08\n480 20 0.00102484 322.134\n481 20 3.32515 254.994\n...\n497 20 7.2162 412.189\n498 20 6.87945 273.712\n499 20 16.1034 272.385\n-- Best Particle = [-3.77695478 -3.28649153]\n-- Best Fitness = 0.0010248367255068806\n```"]