- en: Graph Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have got a taste of linear algebra, calculus, statistics, and optimization,
    it is time to move on to a very fascinating topic, known as graph theory. This
    involves, as the name suggests, the study of graphs, which we use to model relationships
    between objects. We use these graphs to help visualize and analyze problems, which
    in turn helps us solve them.
  prefs: []
  type: TYPE_NORMAL
- en: Graph theory is a very important field and is used for a variety of problems,
    including page ranking in search engines, social network analysis, and in a GPS
    to find the best route home. It is also important for us to further our understanding
    of deep neural networks since the majority of them are based on a type of graph
    known as a **directed acyclic graph** (**DAG**).
  prefs: []
  type: TYPE_NORMAL
- en: Covering everything in graph theory goes beyond the scope of this chapter (and
    this book), but we will cover everything that is important for developing a deeper
    understanding of neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that are covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic concepts and terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Laplacian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic concepts and terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graph theory was first introduced in the 18th century by Leonhard Euler to
    solve a famous problem known as the **Königsberg bridge problem**, which asks
    whether it is possible to walk around the Königsberg bridge while crossing over
    each of the seven bridges exactly once. The bridge looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd858c4c-fd3e-4815-9e1c-f6c3bbff3541.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we move on, try it out for yourself by using your finger to trace along
    the path or draw it and trace it with a pencil. Did you manage to find a solution?
    It's alright if you didn't!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stop for a moment and ask ourselves what exactly a graph is. A graph
    (*G*) is a mathematical structure made up of two sets—vertices (*V(G)*) and edges (*E(G)*).
    Two vertices (*v[1]* and *v[2]*) are connected if there is an edge (*e* or *(v[1],
    v[2])*) between them. Now that that''s settled, there are some rules associated
    with graphs that are important to our understanding of them. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If [![](img/73ef2410-22d1-4e17-b7c5-e785edf5b06b.png)], then *v[1]* and *v[2]* are
    adjacent (connected/neighbors); but if [![](img/9345c28f-6993-4c90-9d00-1ab2c3b6518a.png)],
    then *v[1]* and *v[2]* are non-adjacent (not connected/not neighbors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *v[1]* is adjacent to *v[2]*, then we can say that the neighborhood of *v[1]* (denoted
    as [![](img/da83ba4f-80bf-4c35-b505-55d3fc1b13c4.png)]) is the set of vertices
    that are connected to *v[1]*. We write this as [![](img/0dd6ac04-174c-472d-8552-a82d6d88db89.png)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If [![](img/3378ba88-e0e4-4bc0-b85d-22919dc75865.png)], then ![](img/0138795d-1306-41f3-bc97-7ab2162451a0.png) is
    incident to *v[1]* and *v[2]* (that is, *v[1]* and *v[2]* are ![](img/680b9810-2665-42aa-914b-9e3dd5345afc.png)'s
    endpoints).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *G* has *n* vertices, then *v[1]* can have, at most, *n-1* neighbors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *v[1]* has neighbors, then the degree of *v[1]* is the number of neighbors
    (or incidences) it has. We can write this as [![](img/66cf6e82-e339-478c-89a1-9c5122456125.png)].
    The minimum degree of a vertex in the graph is denoted as [![](img/d4013c4b-a0a4-467e-93fd-0c2bb66369ad.png)] and
    the maximum degree of a vertex in the graph is denoted as [![](img/7820024d-0549-400d-a711-8e7b7c5b5f79.png)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If [![](img/cd56360c-ca05-46be-b207-51fa5e0bdd8f.png)], then it is an isolated
    vertex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know what the fundamental rules of graphs are, let''s revisit the
    preceding problem we introduced and see if we can work out its solution. We can
    redraw the bridge problem as a graph, as in the following diagram (refer to the
    color version provided in the graphics bundle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a56d7c27-f3e2-45dd-a04e-9de4073e6d25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The green vertex is *A*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The red vertex is *B*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blue vertex is *C*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orange vertex is *D*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The curved edge connecting *A* and *B* is bridge *a*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The straight edge connecting *A* and *B* is bridge *b*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The curved edge connecting *A* and *C* is bridge *c*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The straight edge connecting *A* and *B* is bridge *d*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The straight edge connecting *A* and *D* is bridge *e*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The straight edge connecting *B* and *D* is bridge *f*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The straight edge connecting *C* and *D* is bridge *g*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look at the graph and traverse over the edges, we can easily observe that
    there is no solution to the Königsberg bridge problem, regardless of what path
    we take. However, if we were to add an extra path from *D* to *A*, *D* to *B*,
    or *D* to *C*, then we do in fact have a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we have a bunch of polyhedrons. In geometry, polyhedra
    are three-dimensional objects, such as tetrahedrons (pyramids), cubes, dipiramids,
    deltoidals, dodecahedrons, pentagonal hexacontahedrons, and so on (don''t worry,
    you don''t need to know what all of them are). In the following diagram, we have
    two different polyhedrons, along with their corresponding graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c8c0ab5-4e1d-47fc-b30d-8d42d48024e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s observe the shapes and their graphs for a moment. As you can see, the
    graph looks a bit different from the actual structure but still captures the properties
    of the shape. Each graph here has vertices (*V*) and edges (*E*), which we already
    know. But there is one additional property—faces (*F*). Using the preceding diagrams,
    we can deduce a general rule that captures the relationships between the vertices,
    edges, and faces. It is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e87d716-137e-4267-8f0f-bf8042fe9ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, |*V*| = *n*, |*E*| = *m*, and |*F*| = *r*. To verify this, let's take
    a look at the preceding graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the cube, there are 8 vertices, 12 edges, and 6 faces, so we
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c370e747-b1f3-49e7-aa96-f005809f37a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of the octahedron, there are 6 vertices, 12 edges, and 8 faces,
    so we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bf004ea-4692-49e5-a9c8-0361c1d8f161.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we understand the basics, it is time for us to learn about what is
    often referred to as the first theorem in graph theory. Suppose we have a graph
    that has *n* vertices and *m* edges. Then, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5cbcc94-dcf6-49de-b108-cc27dca1de6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This tells us that the sum of the degrees of each vertex of the graph is twice
    the number of edges in the graph. Alternatively, we can write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ad3a689-993d-4aab-8b17-6a4d00c4f0af.png)'
  prefs: []
  type: TYPE_IMG
- en: Adjacency matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can imagine, writing down all the pairs of connected nodes (that is,
    those that have edges between them) to keep track of the relationships in a graph
    can get tedious, especially as graphs can get very large. For this reason, we
    use what is known as the adjacency matrix, which is the fundamental mathematical
    representation of a graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have a graph with *n* nodes, each of which has a unique integer
    label ([![](img/53ea9237-a078-40ef-9b41-885f16fa745a.png)]) so that we can refer
    to it easily and without any ambiguity whatsoever. For the sake of simplicity,
    in this example, *n *= 6\. Then, this graph''s corresponding adjacency matrix
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6943f34-cf84-43b5-a5d2-f057eddbbdb1.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the matrix for a moment and see why it is the way it is.
    The first thing that immediately pops out is that the matrix has a size of 6 ×
    6 (or *n* × *n*) because size is important to us. Next, we notice that it is symmetric
    and there are only zeros along the diagonal. But why? What is the significance
    of it being written this way?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the diagram of the graph in the preceding section, we can see
    that the edges are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7861fc62-3732-4635-85f3-fd61e397b284.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking back at the matrix at either the upper triangle or lower triangle,
    we can see that there are seven 1s at specific *(i, j)* locations. Each 1 represents
    an edge between two numbered nodes, and there is a 0 if there is no edge between
    the two nodes. We can generalize this and write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e646d82-108f-42bb-a5c5-dc803e962cf9.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason for there only being zeros along the diagonal is that there are no
    self-edges; that is, no node has a connection back to itself. This is referred
    to as a simple graph. However, there are also more complex graphs, such as those
    with self-edges and multi-edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between graphs with multi-edges and simple graphs is that there
    can be one or more edges between a pair of nodes in a multi-edge graph. To get
    a clearer understanding of this, let''s consider the following adjacency matrix,
    where we can see that there are now self-edges and multiple edges between pairs
    of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20d57bb8-b98d-4c6f-a44f-e416d609f4ef.png)'
  prefs: []
  type: TYPE_IMG
- en: There are some notable differences in this adjacency matrix compared with that
    of the simple graph. The first thing we notice is that the matrix no longer consists
    of just ones (1) and zeroes (0). What do you think the numbers represent? In this
    adjacency matrix, a double-edge between two nodes is written as *A[i,j]* = *A[j,i]* =
    2\. Self-edges, on the other hand, are those that go from *i* to *i*; that is,
    we can write this as *A*[*i,i*] and it is equal to 2\. The reason for it being
    equal to 2 and not 1 is that the edge is connected to *i* at both ends (and it
    also makes things easier when doing calculations).
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned about the basics of graph theory, and as
    you saw, this is a very powerful mathematical tool that can be used for a plethora
    of tasks in various fields. However, there is no one-size-fits-all solution and
    so we need additional tools to help us because each problem is unique. In this
    section, we will learn about the various types of graphs and their use cases and
    strengths. This includes weighted graphs, directed graphs, multilayer graphs,
    dynamic graphs, and tree graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen graphs that have a sort of binary representation, where
    1 represents the existence of an edge between two nodes and 0 signifies that there
    is no connection between two edges. We have also seen graphs that have self-edges
    and multiple edges. However, sometimes we may want to represent the strength between
    the two nodes instead, which we represent as a weight. The greater the weight,
    the greater the strength.
  prefs: []
  type: TYPE_NORMAL
- en: These sorts of graphs can be used in a variety of settings, such as in social
    networks where the weight represents how frequently two people communicate with
    each other, which we can use to determine their closeness. In the adjacency matrix
    for a weighted graph, each *A[i,j]* instance represents the weight between nodes
    *i* and *j*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have the following adjacency matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/023e1dd5-8f3f-4061-be40-cda7ef3054ba.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the weight (or strength) between nodes 1 and 2 is twice that
    of the weight between nodes 1 and 3, and the weight between nodes 2 and 3 is four
    times that between nodes 1 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: The weight on these edges doesn't necessarily have to represent how strong the
    connection between two nodes is; it could also represent the time it takes to
    travel from one node to another or the distance between two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between regular graphs and directed graphs is that the edges
    in regular graphs could go in either direction, which is why the adjacency matrix
    was symmetric. So, if there is an edge between node *i* and node *j*, then we
    can go from *i* to *j* or from *j* to *i*. However, in the case of directed graphs,
    the edges have a direction. These edges are directed edges and can only go in
    one direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency matrix for this type of graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee858687-837e-43d6-9630-0f9ac1d45772.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, suppose we have the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70fcaab7-b1a3-4285-af12-dae3794cccdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, its corresponding adjacency matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3866f9cf-12bd-4530-aac1-a8f379a4208e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this matrix is asymmetric (not symmetric). For example, node
    3 goes to node 2 and node 6 goes to node 4, but they don't ever go in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of undirected networks, directed networks, too, can have multiple
    edges and self-edges. However, in this case, if there is a self-edge, then the
    element along the diagonal will hold a value of 1 instead of 2.
  prefs: []
  type: TYPE_NORMAL
- en: Directed acyclic graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A DAG is a type of directed graph that doesn''t have cycles in it. What this
    means is that there are no closed loops; that is, three or more nodes in a similar
    direction. So, suppose we have the following adjacency matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7c3aa9f-7a7c-43dd-b24d-2ce81fc347be.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see, in the preceding adjacency matrix, that we have an edge from node
    1 to node 3, an edge from node 3 to node 4, and an edge from node 4 to node 1\.
    This creates a cycle within the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Visually, you can think of a DAG as having a hierarchy where nodes can flow
    downward or upward through subsequent levels. So, if our edges are all directed
    upwards, none of the nodes will ever point from a higher level back to a lower
    level. But if this is the case, our network could go on forever, so where does
    this graph end? Surely there must be at least one node that has incoming edges,
    but none outgoing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether our network is acyclic, we can use a simple procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a node that does not have any outgoing edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a node such as this does not exist, then the graph is acyclic. However, if
    there is a node like this, then remove it and its incoming edges from the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all of these nodes have been removed, then the graph is acyclic. Else start
    from *Step 1* again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the adjacency matrix for this type of graph is rather interesting. Suppose
    we number all our nodes so that the edges point from higher-numbered nodes to
    lower-numbered nodes. Then, its adjacency matrix will be strictly triangular with
    zeros along the diagonal. If we have the following adjacency matrix, we can clearly
    observe that there are no self edges and this will always be true for acyclic
    graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf23ac45-4db9-40e4-b4a9-ca5a3df229a0.png)'
  prefs: []
  type: TYPE_IMG
- en: It is very important that we notice why this adjacency matrix is strictly triangular.
    It is because of the ordering (numbering) of the nodes. If this is not done properly,
    we will not have a triangular matrix. Curiously, there is always at least one
    ordering of nodes that results in an upper-triangular matrix, and it can be found
    using the preceding three-step procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Multilayer and dynamic graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we use graphs to map very complex relationships. So, suppose we wanted
    to create a graph for all the modes of transportation and the routes, similar
    to how Google Maps give us routes that involve buses, trains, cars, planes, or
    even combinations of them. We could create something like this using a multilayer
    graph, where nodes represent airports, bus stops, train stations, and other transportation
    modes, whereas edges represent flights, routes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could just label the edges and nodes to describe what each one represents,
    but that could turn out quite messy. So, instead, we can use a multilayer graph,
    where each layer is its own network representing a particular type or class of
    nodes. These layers are then stacked on top of each other and there are interlinking
    edges connecting nodes in different layers. These multilayer edges could be used
    to represent nodes that are within a certain radius of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bcf5c93-4d2f-471a-9aec-ae05bcf76115.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A particularly important subclass of multilayer networks is the multiplex graph
    where each layer has the same nodes, which could represent people, objects, places,
    and so on, but it has various types of edges representing different relationships.
    This is very useful in social networks where different people are related in different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c40da01f-d176-409f-b00c-85ab7a3e8db5.png)'
  prefs: []
  type: TYPE_IMG
- en: Another subclass of multilayer graphs is the dynamic (or temporal) graph. The
    significance of these graphs is that their structure changes over time. These
    could either be a fixed number of nodes, where the edges keep changing or nodes
    can be added to or removed from the graph over time.
  prefs: []
  type: TYPE_NORMAL
- en: We can represent a multiplex graph mathematically using a set of *n* × *n* adjacency
    matrices, *A^α*, where *α* represents the layer number or a time step (if it is
    a dynamic or temporal graph). We can write the elements of the matrices as [![](img/175e2cf3-60fa-4394-b30c-a02dde594502.png)].
    These elements form a three-dimensional tensor. In comparison, multilayer graphs
    are a lot more complicated because the number of nodes at each layer can differ
    and they have both intralayer and interlayer edges. We can represent the intralayer
    edges using adjacency matrices, *A^α*, where each layer, *α*, has an adjacency
    matrix with a size of *n[α ]*× *n[α]*. The adjacency matrix for the interlayer
    edges, on the other hand, can be represented as *B^(αβ)* (which is of size *n[α ]*× *n*[β]),
    where the matrices element is [![](img/60e6f2bc-8ed5-423d-9ca2-0b76df4f0cd5.png)] if
    there is an edge between node *i* in layer *α* and node *j* and layer *β*.
  prefs: []
  type: TYPE_NORMAL
- en: Tree graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tree graphs are types of graphs that, as the name suggests, have a tree-like
    structure. They are undirected and do not have any loops. They also have a rather
    interesting property, referred to as **connectedness**, where we can find a path
    to any node on the graph from any other node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see what a tree graph looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96228fd6-4f3c-4765-b72d-ac58ff04262b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the graph starts at one node (the root node) and ends with leaf
    nodes. In between, they branch out to form smaller sub-trees. An interesting property
    is that a tree graph with *n* nodes has *n-1* edges.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Laplacian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, in the *Adjacency matrix* section, we learned about
    the adjacency matrix and how we can use it to tell what the structure of a graph
    is. However, there are other ways of representing graphs in matrix form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we have an undirected, unweighted graph. Then, its Laplacian
    matrix will be a symmetric *n* × *n* matrix, *L*, whose elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bba5a9d-78d4-4bc0-b5d1-2c2f82f38562.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, [![](img/c5341f20-5d40-43bc-8f59-20d7d471a4bf.png)]. We can also write
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26bb8b67-a30f-437b-b0a0-466e0683d8b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *A[i,j]* is the adjacency matrix and *δ[i,j]* is the Kronecker delta.
    We can rewrite this in matrix form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f0927b-ec76-4376-a0e2-55f912a9033e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12698959-6e57-4a51-8eb9-245fedbc3c7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can also write the graph Laplacian matrix for a weighted graph
    by replacing the adjacency matrix here with the one we defined previously for
    weighted graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a very fascinating topic in mathematics that
    has applications in nearly every field, from social sciences, to social networking,
    to the World Wide Web, to artificial intelligence—but particularly, in our case
    of neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about linear neural networks, which are the
    simplest type of neural networks and are used most frequently in statistical learning.
  prefs: []
  type: TYPE_NORMAL
