["```py\nimport numpy as np \n\nx = np.array([1.8, -4.5, 9.2, 7.3]) \ny = np.array([-5.2, -1.1, 0.7, 5.1])\n```", "```py\ndef add(x: np.ndarray, y: np.ndarray): \n    x_plus_y = np.zeros(shape=len(x)) \n\n    for i in range(len(x_plus_y)): \n        x_plus_y[i] = x[i] + y[i] \n\n    return x_plus_y\n```", "```py\nadd(x, y)\n```", "```py\narray([-3.4, -5.6,  9.9, 12.4])\n```", "```py\nnp.equal(x + y, add(x, y))\n```", "```py\narray([ True,  True,  True,  True])\n```", "```py\n1.0 == 0.3*3 + 0.1\n```", "```py\nFalse\n```", "```py\n0.3*3 + 0.1\n```", "```py\n0.9999999999999999\n```", "```py\nall(np.equal(x + y, add(x, y)))\n```", "```py\nTrue\n```", "```py\ndef just_a_quadratic_polynomial(x):\n    return 3*x**2 + 1\n\nx = np.array([1.8, -4.5, 9.2, 7.3])\njust_a_quadratic_polynomial(x)\n```", "```py\narray([ 10.72,  61.75, 254.92, 160.87])\n```", "```py\nfrom math import exp \n\nexp(x)\n```", "```py\n--------------------------------------------------------------------------- \nTypeError                               Traceback (most recent call last) \nCell In[10], line 3 \n     1 from math import exp \n---->/span> 3 exp(x) \n\nTypeError: only length-1 arrays can be converted to Python scalars\n```", "```py\ndef naive_exp(x: np.ndarray): \n    x_exp = np.empty_like(x) \n\n    for i in range(len(x)): \n        x_exp[i] = exp(x[i]) \n\n    return x_exp\n```", "```py\nnaive_exp(x)\n```", "```py\narray([6.04964746e+00, 1.11089965e-02, 9.89712906e+03, 1.48029993e+03])\n```", "```py\ndef bit_less_naive_exp(x: np.ndarray): \n    return np.array([exp(x_i) for x_i in x]) \n\nbit_less_naive_exp(x)\n```", "```py\narray([   6\\. ,    0\\. , 9897.1, 1480.3])\n```", "```py\nnp.exp(x)\n```", "```py\narray([6.04964746e+00, 1.11089965e-02, 9.89712906e+03, 1.48029993e+03])\n```", "```py\nall(np.equal(naive_exp(x), np.exp(x)))\n```", "```py\nTrue\n```", "```py\nall(np.equal(bit_less_naive_exp(x), np.exp(x)))\n```", "```py\nTrue\n```", "```py\nfrom timeit import timeit\n\nn_runs = 100000\nsize = 1000\n\nt_naive_exp = timeit(\n    \"np.array([exp(x_i) for x_i in x])\",\n    setup=f\"import numpy as np; from math import exp; x = np.ones({size})\",\n    number=n_runs\n)\n\nt_numpy_exp = timeit(\n    \"np.exp(x)\",\n    setup=f\"import numpy as np; from math import exp; x = np.ones({size})\",\n    number=n_runs\n)\n\nprint(f\"Built-in exponential:    \\t{t_naive_exp:.5f} s\")\nprint(f\"NumPy exponential:       \\t{t_numpy_exp:.5f} s\")\nprint(f\"Performance improvement: \\t{t_naive_exp/t_numpy_exp:.5f} times faster\")\n```", "```py\nBuilt-in exponential:         18.35177 s \nNumPy exponential:             0.87458 s \nPerformance improvement:       20.98356 times faster\n```", "```py\ndef naive_sum(x: np.ndarray): \n    val = 0 \n\n    for x_i in x: \n        val += x_i \n\n    return val \n\nnaive_sum(x)\n```", "```py\nnp.float64(13.799999999999999)\n```", "```py\nsum(x)\n```", "```py\nnp.float64(13.799999999999999)\n```", "```py\nnp.sum(x)\n```", "```py\nnp.float64(13.799999999999999)\n```", "```py\nx.sum()\n```", "```py\nnp.float64(13.799999999999999)\n```", "```py\nt_naive_sum = timeit( \n    /span>sum(x) \n    setup=f/span>import numpy as np; x = np.ones({size}) \n    number=n_runs \n) \n\nt_numpy_sum = timeit( \n    /span>np.sum(x) \n    setup=f/span>import numpy as np; x = np.ones({size}) \n    number=n_runs \n) \n\nprint(f/span>Built-in sum:            \\t{t_naive_sum:.5f} s \nprint(f/span>NumPy sum:               \\t{t_numpy_sum:.5f} s \nprint(f/span>Performance improvement: \\t{t_naive_sum/t_numpy_sum:.5f} times faster\n```", "```py\nBuilt-in sum:                 5.52380 s \nNumPy sum:                     0.35774 s \nPerformance improvement:       15.44076 times faster\n```", "```py\nnp.prod(x)\n```", "```py\nnp.float64(-543.996)\n```", "```py\ndef euclidean_norm(x: np.ndarray): \n    return np.sqrt(np.sum(x**2))\n```", "```py\n# a 1D array with 4 elements, which is a vector in 4-dimensional space \nx = np.array([-3.0, 1.2, 1.2, 2.1]) \n\n# a 1D array with 2 elements, which is a vector in 2-dimensional space \ny = np.array([8.1, 6.3]) \n\neuclidean_norm(x)\n```", "```py\nnp.float64(4.036087214122113)\n```", "```py\neuclidean_norm(y)\n```", "```py\nnp.float64(10.261578825892242)\n```", "```py\nnp.linalg.norm(x)\n```", "```py\nnp.float64(4.036087214122113)\n```", "```py\nnp.equal(euclidean_norm(x), np.linalg.norm(x))\n```", "```py\nnp.True_\n```", "```py\ntype(np.inf)\n```", "```py\nfloat\n```", "```py\ndef p_norm(x: np.ndarray, p: float): \n    if np.isinf(p): \n        return np.max(np.abs(x)) \n    elif p  1: \n        return (np.sum(np.abs(x)**p))**(1/p) \n    else: \n        raise ValueError(\"/span>p must be a float larger or equal than 1.0 or inf.\"\n```", "```py\nx = np.array([-3.0, 1.2, 1.2, 2.1]) \n\nfor p in [1, 2, 42, np.inf]: \n    print(f/span>p-norm for p = {p}: \\t {p_norm(x, p=p):.5f}\"\n```", "```py\np-norm for p = 1:        7.50000 \np-norm for p = 2:        4.03609 \np-norm for p = 42:     3.00000 \np-norm for p = inf:       3.00000\n```", "```py\nfor p in [1, 2, 42, np.inf]: \n    print(f/span>p-norm for p = {p}: \\t {np.linalg.norm(x, ord=p):.5f}\"\n```", "```py\np-norm for p = 1:        7.50000 \np-norm for p = 2:        4.03609 \np-norm for p = 42:     3.00000 \np-norm for p = inf:       3.00000\n```", "```py\ndef euclidean_distance(x: np.ndarray, y: np.ndarray): \n    return np.linalg.norm(x - y, ord=2)\n```", "```py\ndef dot_product(x: np.ndarray, y: np.ndarray): \n    return np.sum(x*y)\n```", "```py\nx = np.array([-3.0, 1.2, 1.2, 2.1]) \ny = np.array([1.9, 2.5, 3.9, 1.2]) \n\ndot_product(x, y)\n```", "```py\nnp.float64(4.5)\n```", "```py\nx = np.array([-3.0, 1.2, 1.2, 2.1]) \ny = np.array([1.9, 2.5]) \n\ndot_product(x, y)\n```", "```py\n--------------------------------------------------------------------------- \nValueError                              Traceback (most recent call last) \nCell In[39], line 4 \n     1 x = np.array([-3.0, 1.2, 1.2, 2.1]) \n     2 y = np.array([1.9, 2.5]) \n---->/span> 4 dot_product(x, y) \n\nCell In[37], line 2, in dot_product(x, y) \n     1 def dot_product(x: np.ndarray, y: np.ndarray): \n---->/span> 2    return np.sum(x*y) \n\nValueError: operands could not be broadcast together with shapes (4,) (2,)\n```", "```py\nx = np.array([-3.0, 1.2, 1.2, 2.1]) \ny = np.array([2.0]) \n\ndot_product(x, y)\n```", "```py\nnp.float64(3.0)\n```", "```py\nx*y\n```", "```py\narray([-6\\. ,  2.4,  2.4,  4.2])\n```", "```py\nx = np.array([-3.0, 1.2, 1.2, 2.1]) \ny = np.array([1.9, 2.5, 3.9, 1.2]) \n\nnp.dot(x, y)\n```", "```py\nnp.float64(4.5)\n```", "```py\nx = np.array([-3.0, 1.2, 1.2, 2.1]) \ny = np.array([2.0]) \n\nnp.dot(x, y)\n```", "```py\n--------------------------------------------------------------------------- \nValueError                              Traceback (most recent call last) \nCell In[43], line 4 \n     1 x = np.array([-3.0, 1.2, 1.2, 2.1]) \n     2 y = np.array([2.0]) \n---->/span> 4 np.dot(x, y) \n\nValueError: shapes (4,) and (1,) not aligned: 4 (dim 0) != 1 (dim 0)\n```", "```py\nvectors = [np.random.rand(5) for _ in range(5)]    # randomly generated vectors in a list \nvectors\n```", "```py\n[array([0.85885635, 0.05917163, 0.42449235, 0.39776749, 0.89750107]), \n array([0.49579437, 0.42797077, 0.21057023, 0.3091438 , 0.52590854]), \n array([0.73079791, 0.58140107, 0.09823772, 0.14323477, 0.63606972]), \n array([0.89495164, 0.40614454, 0.60637559, 0.61614928, 0.69006552]), \n array([0.1996764 , 0.90298211, 0.70604567, 0.45721469, 0.02375226])]\n```", "```py\nfrom typing import List \n\ndef projection(x: np.ndarray, to: List[np.ndarray]): \n    #x0022;\"/span> \n    Computes the orthogonal projection of the vector ‘x‘ \n    onto the subspace spanned by the set of vectors ‘to‘. \n    #x0022;\"/span> \n    p_x = np.zeros_like(x) \n\n    for e in to: \n        e_norm_square = np.dot(e, e) \n        p_x += np.dot(x, e)*e/e_norm_square \n\n    return p_x\n```", "```py\nx = np.array([1.0, 2.0]) \ne = np.array([2.0, 1.0]) \n\nx_to_e = projection(x, to=[e])\n```", "```py\nimport matplotlib.pyplot as plt \n\nwith plt.style.context(\"/span>seaborn-v0_8\": \n    plt.figure(figsize=(7, 7)) \n    plt.xlim([-0, 3]) \n    plt.ylim([-0, 3]) \n    plt.arrow(0, 0, x[0], x[1], head_width=0.1, color=\"/span>r label=\"/span>x linewidth=2) \n    plt.arrow(0, 0, e[0], e[1], head_width=0.1, color=\"/span>g label=\"/span>e linewidth=2) \n    plt.arrow(x_to_e[0], x_to_e[1], x[0] - x_to_e[0], x[1] - x_to_e[1], linestyle=\"-\" \n    plt.arrow(0, 0, x_to_e[0], x_to_e[1], head_width=0.1, color=\"/span>b label=\"/span>projection(x, to=[e]) \n    plt.legend() \n    plt.show()\n```", "```py\nnp.allclose(np.dot(e, x - x_to_e), 0.0)\n```", "```py\nTrue\n```", "```py\ndef gram_schmidt(vectors: List[np.ndarray]): \n    #x0022;\"/span> \n    Creates an orthonormal set of vectors from the input \n    that spans the same subspaces. \n    #x0022;\"/span> \n    output = [] \n\n    # 1st step: finding an orthogonal set of vectors \n    output.append(vectors[0]) \n    for v in vectors[1:]: \n        v_proj = projection(v, to=output) \n        output.append(v - v_proj) \n\n    # 2nd step: normalizing the result \n    output = [v/np.linalg.norm(v, ord=2) for v in output] \n\n    return output \n\ngram_schmidt([np.array([2.0, 1.0, 1.0]), \n              np.array([1.0, 2.0, 1.0]), \n              np.array([1.0, 1.0, 2.0])])\n```", "```py\n[array([0.81649658, 0.40824829, 0.40824829]), \n array([-0.49236596,  0.86164044,  0.12309149]), \n array([-0.30151134, -0.30151134,  0.90453403])]\n```", "```py\ntest_vectors = [np.array([1.0, 0.0, 0.0]), \n                np.array([1.0, 1.0, 0.0]), \n                np.array([1.0, 1.0, 1.0])] \n\ngram_schmidt(test_vectors)\n```", "```py\n[array([1., 0., 0.]), array([0., 1., 0.]), array([0., 0., 1.])]\n```", "```py\noutput = [v/np.linalg.norm(v, ord=2) for v in output]\n```", "```py\ndef projection(x: np.ndarray, to: List[np.ndarray]): \n    #x0022;\"/span> \n    Computes the orthogonal projection of the vector ‘x‘ \n    onto the subspace spanned by the set of vectors ‘to‘. \n    #x0022;\"/span> \n    p_x = np.zeros_like(x) \n\n    for e in to: \n        e_norm_square = np.dot(e, e) \n        p_x += np.dot(x, e)*e / e_norm_square \n\n    return p_x\n```", "```py\ndef projection(x: np.ndarray, to: List[np.ndarray]): \n    p_x = np.zeros_like(x) \n\n    for e in to: \n        e_norm_square = np.dot(e, e) \n\n        # note the change below: \n        p_x += np.dot(x, e)*e / (e_norm_square + 1e-16) \n\n    return p_x\n```", "```py\nfrom typing import Tuple \n\nclass Matrix: \n    def __init__(self, shape: Tuple[int, int]): \n        if len(shape) != 2: \n            raise ValueError(\"/span>The shape of a Matrix object must be a two-dimensional tuple.\" \n\n        self.shape = shape \n        self.data = [0.0 for _ in range(shape[0]*shape[1])] \n\n    def _linear_idx(self, i: int, j: int): \n        return i*self.shape[1] + j \n\n    def __getitem__(self, key: Tuple[int, int]): \n        linear_idx = self._linear_idx(*key) \n        return self.data[linear_idx] \n\n    def __setitem__(self, key: Tuple[int, int], value): \n        linear_idx = self._linear_idx(*key) \n        self.data[linear_idx] = value \n\n    def __repr__(self): \n        array_form = [ \n            [self[i, j] for j in range(self.shape[1])] \n            for i in range(self.shape[0]) \n        ] \n        return njoin([\"tjoin([fx}\"/span> for x in row]) for row in array_form])\n```", "```py\nM = Matrix(shape=(3, 4))\n```", "```py\nM[1, 2] = 3.14 \nM[1, 2]\n```", "```py\n3.14\n```", "```py\nM\n```", "```py\n0.0    0.0    0.0    0.0 \n0.0    0.0    3.14    0.0 \n0.0    0.0    0.0    0.0\n```", "```py\nimport numpy as np \n\nA = np.array([[0, 1, 2, 3], \n              [4, 5, 6, 7], \n              [8, 9, 10, 11]]) \n\nB = np.array([[5, 5, 5, 5], \n              [5, 5, 5, 5], \n              [5, 5, 5, 5]]) \nA\n```", "```py\narray([[ 0,  1,  2,  3], \n      [ 4,  5,  6,  7], \n      [ 8,  9, 10, 11]])\n```", "```py\nA + B       # pointwise addition\n```", "```py\narray([[ 5,  6,  7,  8], \n      [ 9, 10, 11, 12], \n      [13, 14, 15, 16]])\n```", "```py\nA*B         # pointwise multiplication\n```", "```py\narray([[ 0,  5, 10, 15], \n      [20, 25, 30, 35], \n      [40, 45, 50, 55]])\n```", "```py\nnp.exp(A)   # pointwise application of the exponential function\n```", "```py\narray([[1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01], \n      [5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03], \n      [2.98095799e+03, 8.10308393e+03, 2.20264658e+04, 5.98741417e+04]])\n```", "```py\nnp.transpose(A)\n```", "```py\narray([[ 0,  4,  8], \n      [ 1,  5,  9], \n      [ 2,  6, 10], \n      [ 3,  7, 11]])\n```", "```py\nA.T         # is the same as np.transpose(A)\n```", "```py\narray([[ 0,  4,  8], \n      [ 1,  5,  9], \n      [ 2,  6, 10], \n      [ 3,  7, 11]])\n```", "```py\nA[1, 2]    # 1st row, 2nd column (if we index rows and columns from zero)\n```", "```py\nnp.int64(6)\n```", "```py\nA[:, 2]    # 2nd column\n```", "```py\narray([ 2,  6, 10])\n```", "```py\nA[1, :]    # 1st row\n```", "```py\narray([4, 5, 6, 7])\n```", "```py\nA[2, 1:4]   # 2nd row, 1st-4th elements\n```", "```py\narray([ 9, 10, 11])\n```", "```py\nA[1]        # 1st row\n```", "```py\narray([4, 5, 6, 7])\n```", "```py\nfor row in A: \n    print(row)\n```", "```py\n[0 1 2 3] \n[4 5 6 7] \n[ 8  9 10 11]\n```", "```py\nnp.zeros(shape=(4, 5))\n```", "```py\narray([[0., 0., 0., 0., 0.], \n      [0., 0., 0., 0., 0.], \n      [0., 0., 0., 0., 0.], \n      [0., 0., 0., 0., 0.]])\n```", "```py\nA = np.array([[0, 1, 2, 3], \n              [4, 5, 6, 7], \n              [8, 9, 10, 11]]) \nA\n```", "```py\narray([[ 0,  1,  2,  3], \n      [ 4,  5,  6,  7], \n      [ 8,  9, 10, 11]])\n```", "```py\nA.shape\n```", "```py\n(3, 4)\n```", "```py\nA.reshape(6, 2)    # reshapes A into a 6 x 2 matrix\n```", "```py\narray([[ 0,  1], \n      [ 2,  3], \n      [ 4,  5], \n      [ 6,  7], \n      [ 8,  9], \n      [10, 11]])\n```", "```py\nA\n```", "```py\narray([[ 0,  1,  2,  3], \n      [ 4,  5,  6,  7], \n      [ 8,  9, 10, 11]])\n```", "```py\nA.reshape(-1, 2)\n```", "```py\narray([[ 0,  1], \n      [ 2,  3], \n      [ 4,  5], \n      [ 6,  7], \n      [ 8,  9], \n      [10, 11]])\n```", "```py\nA.reshape(-1, 4)\n```", "```py\narray([[ 0,  1,  2,  3], \n      [ 4,  5,  6,  7], \n      [ 8,  9, 10, 11]])\n```", "```py\nfrom itertools import product \n\ndef matrix_multiplication(A: np.ndarray, B: np.ndarray): \n    # checking if multiplication is possible \n    if A.shape[1] != B.shape[0]: \n        raise ValueError(\"/span>The number of columns in A must match the number of rows in B.\" \n\n    # initializing an array for the product \n    AB = np.zeros(shape=(A.shape[0], B.shape[1])) \n\n    # calculating the elements of AB \n    for i, j in product(range(A.shape[0]), range(B.shape[1])): \n        AB[i, j] = np.sum(A[i, :]*B[:, j]) \n\n    return AB\n```", "```py\nA = np.ones(shape=(4, 6)) \nB = np.ones(shape=(6, 3)) \nmatrix_multiplication(A, B)\n```", "```py\narray([[6., 6., 6.], \n      [6., 6., 6.], \n      [6., 6., 6.], \n      [6., 6., 6.]])\n```", "```py\nnp.matmul(A, B)\n```", "```py\narray([[6., 6., 6.], \n      [6., 6., 6.], \n      [6., 6., 6.], \n      [6., 6., 6.]])\n```", "```py\nfor _ in range(100): \n    n, m, l = np.random.randint(1, 100), np.random.randint(1, 100), np.random.randint(1, 100) \n    A = np.random.rand(n, m) \n    B = np.random.rand(m, l) \n\n    if not np.allclose(np.matmul(A, B), matrix_multiplication(A, B)): \n        print(f/span>Result mismatch for\\n{A}\\n and\\n{B}\" \n        break \nelse: \n    print(\"/span>All good! Yay!\"\n```", "```py\nAll good! Yay!\n```", "```py\nA = np.ones(shape=(4, 6)) \nB = np.ones(shape=(6, 3)) \n\nnp.allclose(A @ B, np.matmul(A, B))\n```", "```py\nTrue\n```", "```py\nx1 = np.array([2, 0, 0, 0])       # first data point \nx2 = np.array([-1, 1, 0, 0])      # second data point \n\nA = np.array([[0, 1, 2, 3], \n              [4, 5, 6, 7], \n              [8, 9, 10, 11]])    # a feature transformation\n```", "```py\nA.shape\n```", "```py\n(3, 4)\n```", "```py\nx1.shape\n```", "```py\n(4,)\n```", "```py\nnp.matmul(A, x1)\n```", "```py\narray([ 0,  8, 16])\n```", "```py\nnp.hstack([x1, x2])    # np.hstack takes a list of np.ndarrays as its argument\n```", "```py\narray([ 2,  0,  0,  0, -1,  1,  0,  0])\n```", "```py\n# x.reshape(-1,1) turns x into a column vector \ndata = np.hstack([x1.reshape(-1, 1), x2.reshape(-1, 1)]) \ndata\n```", "```py\narray([[ 2, -1], \n      [ 0,  1], \n      [ 0,  0], \n      [ 0,  0]])\n```", "```py\nnp.matmul(A, data)\n```", "```py\narray([[ 0,  1], \n      [ 8,  1], \n      [16,  1]])\n```", "```py\ndef p_norm(x: np.ndarray, p: float): \n    if p  1: \n        return (np.sum(np.abs(x)**p))**(1/p) \n    elif np.isinf(p): \n        return np.max(np.abs(x)) \n    else: \n        raise ValueError(\"/span>p must be a float larger or equal than 1.0 or inf.\"\n```"]