["```py\nimport numpy as np \n\ndef cross_entropy_loss(X, y): \n    #x0022;\"/span> \n    Args: \n        X: numpy.ndarray of shape (n_batch, n_dim). \n            Contains the predictions in form of a probability distribution. \n        y: numpy.ndarray of shape (n_batch, 1). \n            Contains class labels for each data point in X. \n\n    Returns: \n        loss: numpy.float. \n            Cross entropy loss of the predictions. \n    #x0022;\"/span> \n\n    exp_x = np.exp(X) \n    probs = exp_x / np.sum(exp_x, axis=1, keepdims=True) \n    log_probs = - np.log([probs[i, y[i]] for i in range(len(probs))]) \n    loss = np.mean(log_probs) \n\n    return loss\n```", "```py\nimport numpy as np \nimport matplotlib.pyplot as plt \n\nx = np.linspace(-10, 10, 400) \nrelu = np.maximum(0, x) \n\nwith plt.style.context(\"/span>seaborn-v0_8-white: \n    plt.figure() \n    plt.plot(x, relu, label=\"/span>ReLU(x) color=\"/span>blue \n    plt.axhline(0, color=’black’, linewidth=0.8, linestyle=\"-\" \n    plt.title(\"/span>ReLU fontsize=14) \n    plt.xlabel(\"/span>x fontsize=12) \n    plt.ylabel(\"/span>ReLU(x) fontsize=12) \n    plt.grid(alpha=0.3) \n    plt.show()\n```", "```py\ndef square(x): \n    return x**2\n```", "```py\ntype(square)\n```", "```py\nfunction\n```", "```py\nsquare(12)\n```", "```py\n144\n```", "```py\ndef cube(x): \n    return x**3 \nx = 2 \n\nsquare(x) + cube(x)    # addition\n```", "```py\n 12\n```", "```py\nsquare(x)*cube(x)      # multiplication\n```", "```py\n32\n```", "```py\nsquare(cube(x))        # composition\n```", "```py\n64\n```", "```py\ndef compose(f, g): \n\n    def composition(*args, **kwargs): \n        return f(g(*args, **kwargs)) \n\n    return composition \nsquare_cube_composition = compose(square, cube) \n\nsquare_cube_composition(2)\n```", "```py\n64\n```", "```py\ndef linear(x, a, b):\n    return a*x + b\n```", "```py\nclass Linear: \n    def __init__(self, a, b): \n        self.a = a \n        self.b = b \n\n    def __call__(self, x): \n        return self.a*x + self.b \nf = Linear(2, -1) # this represents the function f(x) = 2*x - 1 \nf(2.1)\n```", "```py\n3.2\n```", "```py\nf.a, f.b\n```", "```py\n(2, -1)\n```", "```py\nclass Linear: \n    def __init__(self, a, b): \n        self.a = a \n        self.b = b \n\n    def __call__(self, x): \n        return self.a*x + self.b \n\n    def parameters(self): \n        return {\"/span>a self.a, /span>b self.b}\n```", "```py\nf = Linear(2, -1) \nf.parameters()\n```", "```py\n{’a’: 2, ’b’: -1}\n```", "```py\nf\n```", "```py\n/span>__main__.Linear at 0x7c9fbef31190/span>\n```", "```py\nclass Linear: \n    def __init__(self, a, b): \n        self.a = a \n        self.b = b \n\n    def __call__(self, x): \n        return self.a*x + self.b \n\n    def __repr__(self): \n        return f/span>Linear(a={self.a}, b={self.b})/span> \n\n    def parameters(self): \n        return {\"/span>a self.a, /span>b self.b} \nf = Linear(2, -1) \nf\n```", "```py\nLinear(a=2, b=-1)\n```", "```py\nclass Function: \n    def __init__(self): \n        pass \n\n    def __call__(self, *args, **kwargs): \n        pass \n\n    def parameters(self): \n        return dict()\n```", "```py\nimport numpy as np \n\nclass Sigmoid(Function):            # the parent class is explicitly declared \n    def __call__(self, x): \n        return 1/(1 + np.exp(-x)) \n\nsigmoid = Sigmoid() \nsigmoid(2)\n```", "```py\nnp.float64(0.8807970779778823)\n```", "```py\nsigmoid.parameters()\n```", "```py\n{}\n```", "```py\ncomposed = compose(Linear(2, -1), Sigmoid())\ncomposed(2)\n```", "```py\nnp.float64(0.7615941559557646)\n```", "```py\nisinstance(composed, Function)\n```", "```py\nFalse\n```", "```py\ncomposed.parameters()\n```", "```py\n--------------------------------------------------------------------------- \nAttributeError                          Traceback (most recent call last) \nCell In[33], line 1 \n---->/span> 1 composed.parameters() \n\nAttributeError: ’function’ object has no attribute ’parameters’\n```", "```py\nclass Composition(Function): \n    def __init__(self, *functions): \n        self.functions = functions \n\n    def __call__(self, x): \n\n        for f in reversed(self.functions): \n            x = f(x) \n\n        return x\n```", "```py\ncomposed = Composition(Linear(2, -1), Sigmoid()) \ncomposed(2)\n```", "```py\nnp.float64(0.7615941559557646)\n```", "```py\ncomposed.parameters()\n```", "```py\n{}\n```", "```py\nisinstance(composed, Function)\n```", "```py\nTrue\n```"]