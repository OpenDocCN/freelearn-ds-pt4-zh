- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers, Sequences, and Series
  prefs: []
  type: TYPE_NORMAL
- en: ”It’s like asking why is Ludwig van Beethoven’s Ninth Symphony beautiful. If
    you don’t see why, someone can’t tell you. I know numbers are beautiful. If they
    aren’t beautiful, nothing is.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Paul Erdős
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When I was about to take my first mathematical analysis course at the university,
    coming straight from high school, I wondered why we would spend several lectures
    on real numbers. At the time, I was confident in my knowledge and thought that
    I knew what numbers were. This was my first painful encounter with the [Dunning–Kruger
    effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect): the less
    you know, the more confident you are. Suffice to say, after a few classes, I was
    left confused about numbers, taking a while to finally understand them.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at numbers under a magnifying glass, they become extremely complex.
    In this chapter, we are going to make sense of them. To look ahead and keep machine
    learning in our sights, consider that gradient descent (you know, the optimization
    algorithm that is used everywhere) is not possible for functions that are not
    differentiable. In turn, a function f is differentiable at x if the limit
  prefs: []
  type: TYPE_NORMAL
- en: '![lim f(x)−-f-(y)- x→y x− y ](img/file895.png)'
  prefs: []
  type: TYPE_IMG
- en: exists. To understand limits, we must understand real numbers first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good reason to dig deep into the patterns and structures of numbers:
    they are beautiful (as said above by Paul Erdős, one of the greatest mathematicians
    ever). There is a particular joy to understanding seemingly familiar things on
    a deep level. Even though you might not use this knowledge every day, it teaches
    you perspective about the objects you encounter during your work.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five famous classes of numbers that one has to know in order to become
    adept in mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: natural numbers, denoted by ℕ,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: integers, denoted by ℤ,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rational numbers, denoted by ℚ,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: real numbers, denoted by ℝ,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and finally, complex numbers, denoted by ℂ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These classes increase in order, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![ℕ ⊆ ℤ ⊆ ℚ ⊆ ℝ ⊆ ℂ. ](img/file896.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we are going to concern ourselves with the first four. (Complex
    numbers will get their own chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1 Natural numbers and integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Natural numbers are simply defined as
  prefs: []
  type: TYPE_NORMAL
- en: '![ℕ := {1,2,3,...}. ](img/file897.png)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes 0 is included; sometimes it is not. Believe it or not, after a few
    thousand years, mathematicians still cannot decide whether or not 0 is a natural
    number. This problem might sound comical, but trust me, I have seen senior professors
    almost get into a fistfight upon debating this issue. For some people, this is
    a religious question.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t particularly care, and neither should you. I propose using the more
    common and practical definition, which is the one without 0\. When we really need
    to talk about the natural numbers AND 0, I will use the notation ℕ[0] = {0,1,2,…}.
  prefs: []
  type: TYPE_NORMAL
- en: The cardinality of the set of natural numbers is countably infinite. In fact,
    countability is defined as jℕj. (If you are not familiar with the concept of cardinality,
    check out Appendix C.)
  prefs: []
  type: TYPE_NORMAL
- en: To be able to express negative and zero quantities, we extend natural numbers
    to obtain the set of integers, defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![ℤ = {...,− 2,− 1,0,1,2,...}. ](img/file898.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, so good. Integers are also countable: one can enumerate all of its
    elements by'
  prefs: []
  type: TYPE_NORMAL
- en: '![0,1,− 1,2,− 2,3,− 3,.... ](img/file899.png)'
  prefs: []
  type: TYPE_IMG
- en: One significant advantage of integers over natural numbers is that they contain
    the additive inverse for each element. In plain English, if n ∈ℤ, then so does
    −n ∈ℤ. This makes it possible to define all kinds of algebraic structures over
    the integers, giving us mathematical tools to reason about phenomena modeled by
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if n,m ∈ℤ, then n + m ∈ℤ. In mathematical terminology, we say that
    ℤ is closed to addition.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, ℤ is
  prefs: []
  type: TYPE_NORMAL
- en: closed to addition,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and every element has an additive inverse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two properties will guide us on how to go from natural numbers to real
    numbers. Each extension is constructed so that these two properties hold, but
    for different operations.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.2 Rational numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, we obtained ℤ from ℕ by extending it with 0 and the additive inverses for
    each element. What about the multiplicative inverses? This idea leads us to the
    concept of rational numbers, numbers that can be written as a ratio of two integers.
    It is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![ℚ = {p-: p,q ∈ ℤ,q ⁄= 0}, q ](img/file900.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is both closed to multiplication and every element (except 0) has a multiplicative
    inverse. This is not just a l’art pour l’art mathematical construction: rational
    numbers model quantities that are all around us. ”7.9 seconds” to ”100.0 km/h”.
    78.4 kilograms to carry. 0.5 pizza to eat. You get it.'
  prefs: []
  type: TYPE_NORMAL
- en: It might be surprising, but ℚ is also countable.
  prefs: []
  type: TYPE_NORMAL
- en: 'One easy way to prove this is to notice that it can be obtained as the countable
    union of countable sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ⋃ ℚ = {p-: q ∈ ℤ ∖{0}}. p∈ℤ q ](img/file901.png)'
  prefs: []
  type: TYPE_IMG
- en: (If you are not familiar with the basic set operations like union and setminus,
    check out Appendix C.)
  prefs: []
  type: TYPE_NORMAL
- en: Since the union of countable sets is countable, ℚ is countable as well. Another
    (and perhaps more visual) way to see this is to simply enumerate them in the sequence,
    illustrated by Figure 10.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file902.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Enumeration of rational numbers, where the arrows indicate the
    ordering'
  prefs: []
  type: TYPE_NORMAL
- en: Rational numbers can be written in decimal form, like ![1 2](img/file903.png)
    = 0.5, for example. In general, the following is true.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 55\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any rational number x can be represented as a:'
  prefs: []
  type: TYPE_NORMAL
- en: (a) finite decimal
  prefs: []
  type: TYPE_NORMAL
- en: '![x = x0 ...xk.xk+1 ...xn, xi ∈ {0,1,2,...,9} ](img/file904.png)'
  prefs: []
  type: TYPE_IMG
- en: (b) or a repeating decimal
  prefs: []
  type: TYPE_NORMAL
- en: '![x = x0...xk.xk+1 ...x˙n ...x˙m, xi ∈ {0,1,2,...,9}, ](img/file905.png)'
  prefs: []
  type: TYPE_IMG
- en: where the decimals between the two dots repeat infinitely. (This can be just
    a single digit as well.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the decimal representation is not unique: for example, 1.0 0.˙9 are
    equal.'
  prefs: []
  type: TYPE_NORMAL
- en: The above theorem fully characterizes rational numbers. But what about numbers
    with an infinite decimal form that does not repeat?
  prefs: []
  type: TYPE_NORMAL
- en: Like the famous mathematical constant π describing the half circumference of
    the unit circle, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![π = 3.14159265358979323846264338327950288419716939937510..., ](img/file906.png)'
  prefs: []
  type: TYPE_IMG
- en: with no repeating patterns. These are called irrational numbers, and together
    with rationals, they make up the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.3 Real numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to imagine real numbers is a line, where each point represents
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file907.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The real number line'
  prefs: []
  type: TYPE_NORMAL
- en: If we temporarily let mathematical correctness slide, we can say that
  prefs: []
  type: TYPE_NORMAL
- en: ℝ = finite decimals∪in finite repeating decimals∪infinite nonrepeating decimals
  prefs: []
  type: TYPE_NORMAL
- en: Real numbers are also the first we have encountered in our journey that are
    not countable, and we will prove this! Its proof is so beautiful that it belongs
    in The Book, a collection of the most elegant and beautiful mathematical proofs.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 56\.
  prefs: []
  type: TYPE_NORMAL
- en: ℝ is not countable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. To show that ℝ is not countable, let’s take an indirect approach: assume
    that it is countable and deduce a contradiction. This method is called an indirect
    proof, a top-tier tool in a mathematician’s toolkit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since [0,1) ⊆ℝ, it is enough to show that [0,1) is not countable. If it is
    countable, we can enumerate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![[0,1) = {a1,a2,...}. ](img/file909.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can write out the decimal forms of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![a = 0.a a a ..., 1 11 12 13 a2 = 0.a21a22a23..., a3 = 0.a31a32a33.... . ..
    ](img/file910.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s focus on the diagonal! By changing the digits there, we define
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{5, if ann ⁄= 5, ˆann := |(1, if ann = 5\. ](img/file911.png)'
  prefs: []
  type: TYPE_IMG
- en: Can the number
  prefs: []
  type: TYPE_NORMAL
- en: '![aˆ:= 0.ˆa11ˆa22ˆa33... ](img/file912.png)'
  prefs: []
  type: TYPE_IMG
- en: be found in the sequence {a[1],a[2],…}? No, because the i-th decimal of a[i]
    and â must be different for all i ∈ ℕ! We have constructed â by changing the i-th
    decimal of a[i].
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, our assumption that [0,1) can be enumerated leads to a contradiction
    because we have found an element that cannot possibly be in our enumeration. So,
    [0,1) is not countable, hence ℝ is not countable as well. This is what we needed
    to show!
  prefs: []
  type: TYPE_NORMAL
- en: The method of proof that you have seen above is called Cantor’s diagonal argument.
    This is a beautiful and powerful idea, and although we won’t encounter it anymore,
    it is the key to proving several difficult theorems. (Like Gödel’s famous incompleteness
    theorems, essentially stating that an axiomatic system is either inexpressive
    or inconsistent. These threw a huge monkey wrench into the machinery of mathematics
    at the beginning of the 20th century.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that real numbers break the pattern we observed previously. Integers
    were constructed by extending the natural numbers with additive inverses and closing
    them to addition; rationals were obtained the same way, except doing it for multiplication.
    As we shall see later, real numbers follow a similar process: we obtain them from
    rationals by closing them to limits.'
  prefs: []
  type: TYPE_NORMAL
- en: But what are limits? Let’s see – by studying sequences, the objects that provide
    the context of limits!
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequences lie at the very heart of mathematics. Sequences and their limits describe
    long-term behavior, like the (occasional) convergence of gradient descent to a
    local optimum. By definition, a sequence is an enumeration of mathematical objects.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of a sequence can be any mathematical object, like sets, functions,
    or Hilbert spaces. (Whatever those might be.) For us, sequences are composed of
    numbers. We formally denote them as
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞ {an }n=1, an ∈ ℝ. ](img/file913.png)'
  prefs: []
  type: TYPE_IMG
- en: For simplicity, the subscripts and the superscripts are often omitted, so don’t
    panic if you see {a[n]}, as it is just an abbreviation. (Or a[n]. Mathematicians
    love abbreviations.) If all elements of the sequence belong to a set A, we often
    write {a[n]}⊆A.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences can be bidirectional as well. Those are denoted as {a[n]}[n=−∞]^∞.
    We don’t need them for now, but they will frequently come up in the context of
    probability distributions later.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we don’t need an entire sequence, just a subsequence. We will not
    do anything special with them just yet, but here is the formal definition.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 38\. (Subsequences)
  prefs: []
  type: TYPE_NORMAL
- en: Let a[nn=1]^∞, and let n[kk=1]^∞⊆ℕ be a strictly increasing sequence of natural
    numbers. Then, the sequence {a[n[k]]}[k=1]^∞ is a subsequence of {a[n]}.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it as throwing elements away from a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.1 Convergence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important aspects of sequences is their asymptotic behavior,
    or in other words, what they do in the long term. A particular property we often
    look for is convergence. In plain English, the sequence {a[n]} converges to a
    if no matter how small of an interval (a−𝜀,a + 𝜀) we define (where 𝜀 can be really
    small), eventually all of the elements of {a[n]} fall into it.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the mathematically precise definition of convergence.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 39\. (Convergence of sequences)
  prefs: []
  type: TYPE_NORMAL
- en: The sequence {a[n]}⊆ℝ is said to converge to some a ∈ℝ if for every 𝜀/span>0,
    there is a cutoff index n[0] ∈ℕ such that
  prefs: []
  type: TYPE_NORMAL
- en: '![|an − a| <𝜀 ](img/file914.png)'
  prefs: []
  type: TYPE_IMG
- en: holds for all indices n/span>n[0]. The value a is said to be the limit of {a[n]},
    and we write
  prefs: []
  type: TYPE_NORMAL
- en: '![lni→m∞ an = a ](img/file915.png)'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![an → a (n → ∞ ). ](img/file916.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the cutoff index n[0] depends on 𝜀. We could write n[0](𝜀) to emphasize
    this dependency, but we rarely do so. To avoid referencing and naming the cutoff
    index n[0] all the time, we often simply say that a given property “holds for
    all n large enough.” (Did I mention that mathematicians love abbreviations?)
  prefs: []
  type: TYPE_NORMAL
- en: In plain English, the definition means that no matter how small of an interval
    you enclose a in, all members of the sequence will eventually fall into it.
  prefs: []
  type: TYPE_NORMAL
- en: Although mathematically extremely precise and correct, this definition doesn’t
    give us a lot of tools to show if a sequence is convergent or not. First, we have
    to conjure up the limit a and then construct the cutoff indexes. For example,
    consider a[n] := ![1 n](img/file917.png).
  prefs: []
  type: TYPE_NORMAL
- en: To make our job easier, we can plot this to visualize the situation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![PIC](img/file918.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The 1∕n sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can explicitly construct the cutoff index n[0] for every 𝜀. Since we
    want to have
  prefs: []
  type: TYPE_NORMAL
- en: '![1 --< 𝜀, n ](img/file919.png)'
  prefs: []
  type: TYPE_IMG
- en: we can reorganize the inequality to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![1- 𝜀 <n. ](img/file920.png)'
  prefs: []
  type: TYPE_IMG
- en: So,
  prefs: []
  type: TYPE_NORMAL
- en: '![n0 := ⌊ 1⌋+ 1 𝜀 ](img/file921.png)'
  prefs: []
  type: TYPE_IMG
- en: will do the job.
  prefs: []
  type: TYPE_NORMAL
- en: We had it easy in this example, but this is pretty much as far as we can go
    with the definition. For example, how do you show the convergence of
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1 1 1 an := (-+ ----- + ⋅⋅⋅+ ---)−1 n n + 1 2n ](img/file922.png)'
  prefs: []
  type: TYPE_IMG
- en: with the definition only? You don’t.
  prefs: []
  type: TYPE_NORMAL
- en: There are more advanced tools for this, as we shall see. (By the way, lim[n→∞]a[n]
    = ![-1- ln 2](img/file923.png)). For sequences that are defined recursively and
    there is no analytic formula available, like
  prefs: []
  type: TYPE_NORMAL
- en: '![{L (⃗wn,⃗x,⃗y)}∞n=1, ](img/file924.png)'
  prefs: []
  type: TYPE_IMG
- en: where L is the loss function for a neural network with weights ![⃗w](img/file925.png)[n]
    and training data (![⃗x](img/file926.png),![⃗y](img/file927.png)), we have even
    more complications. There is no need to worry about them yet; let’s focus on one
    thing at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.2 Properties of convergence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In essence, the study of convergence for a particular sequence comes down to
    breaking it into simpler and simpler parts until the limit is known.
  prefs: []
  type: TYPE_NORMAL
- en: Is this a “famous” sequence where the limit is known? If yes, we are done. If
    not, go to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you decompose it into simpler parts? If yes, is the convergence known for
    them? If the convergence is unknown, can you simplify it further?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can do this because convergence has some particularly nice properties, as
    summarized in the theorem below.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 57\. (Properties of convergence)
  prefs: []
  type: TYPE_NORMAL
- en: Let {a[n]}and {b[n]}be two convergent sequences with
  prefs: []
  type: TYPE_NORMAL
- en: '![ln→im∞ an = a and nli→m∞ bn = b. ](img/file928.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim (an + bn) = a + b, n→ ∞ ](img/file929.png)'
  prefs: []
  type: TYPE_IMG
- en: (b)
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim can = ca for all c ∈ ℝ, n→ ∞ ](img/file930.png)'
  prefs: []
  type: TYPE_IMG
- en: (c)
  prefs: []
  type: TYPE_NORMAL
- en: '![nli→m∞ anbn = ab, ](img/file931.png)'
  prefs: []
  type: TYPE_IMG
- en: (d) and if a[n]≠0 and a≠0, then
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1-- 1- nli→m∞ an = a . ](img/file932.png)'
  prefs: []
  type: TYPE_IMG
- en: The properties (a) and (b) together are called linearity of convergence.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we shall see later, the continuity of functions also provides a great tool
    to study convergence properties of a sequence. In fact, continuity is nothing
    more than the interchangeability of limits and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![lnim→∞ f(xn) = f(nl→im∞ xn). ](img/file933.png)'
  prefs: []
  type: TYPE_IMG
- en: One essential property of convergent sequences is that under certain circumstances,
    they preserve inequalities. This is true of function limits as well, so it is
    important for us.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 58\. (The transfer principle)
  prefs: []
  type: TYPE_NORMAL
- en: Let {a[n]}[n=1]^∞ be a convergent sequence. If a[n] ≥α holds for all n ∈ℕ, where
    α ∈ℝ is some lower bound, then lim[n→∞]a[n] ≥α.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. We are going to do this indirectly. If lim[n→∞]a[n] α, then by the definition
    of convergence,
  prefs: []
  type: TYPE_NORMAL
- en: '|a[n] −a|/span> ![|a−α| 2](img/file934.png) for all large n. This means that
    those a[n]-s are actually below α, contradicting our assumptions.'
  prefs: []
  type: TYPE_NORMAL
- en: This proof is straightforward to understand if you draw a figure and visualize
    what happens, so I encourage you to do so. The identical result is true if we
    replace ≥ with ≤ in the above, with the wording of the proof staying the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if a[n]/span>α for all n, lim[n→∞]a[n]/span>α is not guaranteed! The
    best example to show this is a[n] := 1∕n, which converges to 0, although all of
    its terms are positive.
  prefs: []
  type: TYPE_NORMAL
- en: As a corollary, we obtain a tool that will be very useful for showing the convergence
    of particular sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Corollary 3\. (The squeeze principle)
  prefs: []
  type: TYPE_NORMAL
- en: Let ![{an} ∞n=1 ](img/file935.png), ![{bn}∞n=1 ](img/file936.png), and ![{cn}∞n=1
    ](img/file937.png) be three sequences such that ![an ≤ bn ≤ cn ](img/file938.png)
    for all large enough ![n ](img/file939.png). If
  prefs: []
  type: TYPE_NORMAL
- en: '![lim an = lim cn = α, n→∞ n→ ∞ ](img/file940.png)'
  prefs: []
  type: TYPE_IMG
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: '![lnim→∞ bn = α. ](img/file941.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, squeezing {b[n]} between two convergent sequences that have
    the same limit implies convergence of b[n] to the joint limit.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.3 Famous convergent sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because convergence behaves nicely with respect to certain operations (Section [10.2.2](ch018.xhtml#properties-of-convergence)),
    we study sequences by decomposing them into building blocks. Let’s see the most
    important ones that will be useful for us later!
  prefs: []
  type: TYPE_NORMAL
- en: Example 1\. For any x ≥ 0,
  prefs: []
  type: TYPE_NORMAL
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(16).png)(10.1)'
  prefs: []
  type: TYPE_IMG
- en: If you think about it for a minute, this is easy to see. The x = 0 and x = 1
    cases are trivial. Regarding the others, because taking the logarithm turns exponentiation
    into multiplication, we have log x^n = nlog x. So,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ − ∞ if 0 <x <1, lim nlogx = n→ ∞ |( ∞ if x >1\. ](img/file943.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the logarithm is increasing and invertible, ([10.1](ch018.xhtml#famous-convergent-sequences))
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2\. For any x ≥ 0,
  prefs: []
  type: TYPE_NORMAL
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(17).png)(10.2)'
  prefs: []
  type: TYPE_IMG
- en: Similarly to the previous example, this can be shown with the use of logarithms.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3\. Let’s consider the sequences
  prefs: []
  type: TYPE_NORMAL
- en: '![a = log n, b = n, c = 2n, d = n!. n n n n ](img/file945.png)'
  prefs: []
  type: TYPE_IMG
- en: Can you order them according to the speed of growth? This is quite important
    throughout computer science, as these could represent time complexities. It’s
    almost folklore that logarithmic time complexity beats linear, which beats exponential,
    which beats factorial. In other terms,
  prefs: []
  type: TYPE_NORMAL
- en: '![ logn n 2n lim -----= lim -n-= lim ---= 0\. n→ ∞ n n→ ∞ 2 n→ ∞ n! ](img/file946.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 4\. We have just learned that n grows faster than log n. From this,
    it follows that
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim n√n-= 1, n→ ∞ ](img/file947.png)'
  prefs: []
  type: TYPE_IMG
- en: 'a surprising result (at least, it surprised me as a young student)! To show
    this, we apply the good old logarithm trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ √n-- 1 lnim→∞ n = nli→m∞ nn 1n = nli→m∞ elogn logn = nli→m∞ e n = e0 = 1\.
    ](img/file948.png)'
  prefs: []
  type: TYPE_IMG
- en: 10.2.4 The role of convergence in machine learning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Convergence is everywhere. You’ve just come across this concept for the first
    time, so you might not realize its importance just yet. However, it is central
    to mathematics and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to look ahead and give a few examples, differentiation is defined by a
    limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![f ′(x) := lim f-(x-)−-f(y). y→x x − y ](img/file949.png)'
  prefs: []
  type: TYPE_IMG
- en: Regarding derivatives, integrals (the “inverse” of differentiation) are limits
    of convergent sequences. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ 1 2 ∑n k2- 0 x dx = lni→m∞ n3\. k=1 ](img/file950.png)'
  prefs: []
  type: TYPE_IMG
- en: Because integrals are limits, so is every quantity calculated with integration,
    such as expected values, like for the standard normal distribution,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ ∞ 𝔼[𝒩 (0,1)] = x √1--e−x2∕2dx. −∞ 2π ](img/file951.png)'
  prefs: []
  type: TYPE_IMG
- en: Convergence is also central to probability and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two famous theorems: the law of large numbers, stating that'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑n lim 1- Xk = μ n→∞ nk=1 ](img/file952.png)'
  prefs: []
  type: TYPE_IMG
- en: holds; and the central limit theorem, which says
  prefs: []
  type: TYPE_NORMAL
- en: '![√ --X1 + ⋅⋅⋅ + Xn 2 n(------n------ − μ) → 𝒩 (μ, σ ) (n → ∞ ) ](img/file953.png)'
  prefs: []
  type: TYPE_IMG
- en: in distribution, for independent and identically distributed random variables
    X[1],X[2],… with finite expected value 𝔼[X[i]] = μ and variance var(X[i]) = σ².
    They are both very important in machine learning and neural networks; for instance,
    the law of large numbers is one of the fundamental ideas behind stochastic gradient
    descent.
  prefs: []
  type: TYPE_NORMAL
- en: Even the gradient descent optimization process is a recursively defined sequence
    of model weights, converging toward an optimum where the model best fits the data.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about all of these in detail. So, even if you don’t understand
    these right now, don’t worry. It’ll become clear soon. Before finishing up with
    sequences, we shall discuss what happens when a sequence is not convergent.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.5 Divergent sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have talked about how convergent sequences are everywhere, and they are at
    the core of mathematics and machine learning. However, not all sequences are convergent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![a := sin(n ). n ](img/file954.png)'
  prefs: []
  type: TYPE_IMG
- en: When plotted, this is how it looks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![PIC](img/file955.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The sin(n) sequence'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is hard to prove, this sequence does not converge. Its value is
    constantly oscillating in [ − 1,1]. We call non-convergent sequences divergent.
    Among these, there is a special kind of divergence: approaching infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: Definition 40\. (∞-divergence)
  prefs: []
  type: TYPE_NORMAL
- en: The sequence {a[n]} is said to be ∞-divergent if for every arbitrarily large
    number x, there is a cutoff index n[0] such that
  prefs: []
  type: TYPE_NORMAL
- en: '![a >x n ](img/file956.png)'
  prefs: []
  type: TYPE_IMG
- en: holds for all indices n/span>n[0].
  prefs: []
  type: TYPE_NORMAL
- en: We denote ∞-divergence by writing x[n] →∞. Analogously, (−∞)-divergent sequences
    can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'An obvious example is {n} or {nlog n}. These are all across computer science
    as well: the runtime of algorithms given the number of steps or the size of the
    input is ∞-divergent.'
  prefs: []
  type: TYPE_NORMAL
- en: When you see something like a[n] = O(n), it means that there is a constant c
    such that
  prefs: []
  type: TYPE_NORMAL
- en: '![0 ≤ an ≤ cn ](img/file957.png)'
  prefs: []
  type: TYPE_IMG
- en: holds for all large enough n.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.6 The big and small O notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have some experience with computer science, you are probably familiar
    with the big O small O notation. There, it is used to express the runtime of algorithms,
    but it is not limited to that. In general, it is used to compare the long-term
    behavior of sequences. Let’s start with the definitions first, and then I’ll explain
    the intuition and some use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 41\. (Big and small O notation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let ![{an}∞ n=1 ](img/file958.png) and ![{bn}∞ n=1 ](img/file959.png) be two
    arbitrary sequences. We say that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![bn = O (an) ](img/file960.png), if there is a constant ![C > 0 ](img/file961.png)
    such that ![|bn | ≤ Can ](img/file962.png) for all sufficiently large ![n ](img/file963.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![bn = o(an) ](img/file964.png), if for every ![𝜀 >0 ](img/file965.png), there
    exists a cutoff index ![N ∈ ℕ ](img/file966.png) such that ![|bn| ≤ 𝜀an ](img/file967.png)
    for every ![n >N ](img/file968.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In plain English, “b[n] is big O of a[n]” means that b[n] grows roughly at the
    same rate as a[n], while “b[n] is small O of a[n]” means that b[n] is an order
    of magnitude smaller than a[n].
  prefs: []
  type: TYPE_NORMAL
- en: So, when we say that the runtime of an algorithm is O(n) steps where n is the
    input size, we mean that the algorithm will finish in Cn steps. Often, we don’t
    care about the constant multiplier since it doesn’t mean an order of magnitude
    difference in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.7 Real numbers are sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the concept of convergent sequences,
    we shall take another look at rational and real numbers. When extending the classes
    of numbers going from ℕ to ℝ, we pick an operation, close the set with respect
    to it, and add inverse elements to that operation.
  prefs: []
  type: TYPE_NORMAL
- en: Extending ℕ with additive inverses −n for all n ∈ℕ yields ℤ. Extending ℤ with
    multiplicative inverses 1∕n for all n and closing it for multiplication yields
    ℚ. The pattern is seemingly different in the case of ℝ, but this is not the case.
    After understanding what convergence is, we have the tools to see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ 1 n an := (1+ n-) , n = 1,2,.... ](img/file969.png)'
  prefs: []
  type: TYPE_IMG
- en: Since rational numbers are closed to addition and multiplication, we see that
    a[n] is rational. However,
  prefs: []
  type: TYPE_NORMAL
- en: '![lim (1 + 1)n = e, n→∞ n ](img/file970.png)'
  prefs: []
  type: TYPE_IMG
- en: which is the famous Euler constant, is not rational.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we have found what is missing: ℚ is not closed to taking limits. So,
    we can obtain the set of real numbers by closing ℚ to taking limits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that every irrational number can be approximated with rational numbers
    as close as possible is often under-appreciated. Think about this: can you represent
    all real numbers with a computer? Nope. This follows from a simple cardinality
    argument: the number of possible floats is finite, but there are uncountably many
    real numbers. However, certain numbers (like π or e) are essential in engineering
    calculations and simulations. Without approximations, working with irrational
    numbers would be unfeasible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of e: how would you approximate it for computational purposes? In
    theory, it is enough to take a large enough n and use the value (1 + 1∕n)^n. In
    practice, there are several potential problems: the convergence might be slow,
    and taking a large power of a quantity so close to 1 can be numerically unstable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a solution: the form'
  prefs: []
  type: TYPE_NORMAL
- en: '![ N e = lim ∑ -1 N→ ∞ n! n=0 ](img/file971.png)'
  prefs: []
  type: TYPE_IMG
- en: solves both of these problems! From a numerical point of view, addition is much
    better than multiplication. Moreover, as n! grows extremely rapidly, the term
    ![ 1 n!](img/file972.png) becomes negligible even for small n-s. Thus, the convergence
    is fast. Check this out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![PIC](img/file973.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Approximating e: Definition vs. series'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions of form ∑ [n=0]^∞a[n] are called series, and they are one of the
    most important mathematical objects, both in theory and practice. Let’s see what
    they are and how can we work with them!
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a great pizza place in my hometown that I used to visit quite a lot.
    There, each pizza is packed in a box that contains a pizza coupon. Ten pizza coupons
    can be exchanged for a free pizza. This begs the question: how much pizza do you
    get with a single purchase?'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately, you’ll receive a pizza. You’ll also get 1∕10-th of a pizza in the
    form of a coupon, making the “value” of the purchase at least 1 + ![-1 10](img/file974.png)
    pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: However, upon exchanging ten coupons, you get another one. Thus, a coupon represents
    ![1- 10](img/file975.png) + ![-1- 100](img/file976.png) pizzas. Continuing with
    this logic, we’ll obtain that the true value of each purchase is
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ -1--= 1+ 1--+ -1--+ .... n=0 10n 10 100 ](img/file977.png)'
  prefs: []
  type: TYPE_IMG
- en: What is the value of this number? To find out, we’ll take a look at infinite
    series, a main pillar of mathematics. Infinite series (or series for short) are
    sums of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞ ∑ an. n=1 ](img/file978.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding infinitely many terms together might seem like a trivial matter, but
    I assure you, this is far from the truth. For instance, consider the sum
  prefs: []
  type: TYPE_NORMAL
- en: '![∞∑ (− 1)n = 1− 1 + 1 − 1+ .... n=0 ](img/file979.png)'
  prefs: []
  type: TYPE_IMG
- en: On one hand,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞ ∑ (− 1)n = (1− 1)+ (1 − 1)+ ... n=0 = 0+ 0 + ... = 0, ](img/file980.png)'
  prefs: []
  type: TYPE_IMG
- en: but on the other,
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ (− 1)n = 1 + (− 1 + 1)+ (− 1+ 1) + ... n=0 = 1 + 0+ 0 + ... = 1\. ](img/file981.png)'
  prefs: []
  type: TYPE_IMG
- en: Which one is it? Zero or one? It is neither. We’ll see why in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1 Convergent and divergent series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The natural way to make sense of the infinite series
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞ ∑ an n=1 ](img/file982.png)'
  prefs: []
  type: TYPE_IMG
- en: is by taking the limit of the so-called partial sums
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑N SN = an. n=1 ](img/file983.png)'
  prefs: []
  type: TYPE_IMG
- en: This is formalized by the following definition.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 42\.
  prefs: []
  type: TYPE_NORMAL
- en: (Convergent and divergent series)
  prefs: []
  type: TYPE_NORMAL
- en: Let ![{an}∞n=1 ](img/file984.png) be an arbitrary real sequence. The infinite
    series ![∑ ∞ n=1 an ](img/file985.png) is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ ∑N an := Nli→m∞ an. n=1 n=1 ](img/file986.png)'
  prefs: []
  type: TYPE_IMG
- en: If the above limit exists, we say that ![∑ ∞ n=1 an ](img/file987.png) is convergent.
    Otherwise, it is divergent.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds simple enough. Let’s see some examples!
  prefs: []
  type: TYPE_NORMAL
- en: Example 1\. The geometric series, given by
  prefs: []
  type: TYPE_NORMAL
- en: '![∞ ∑ qn = --1--, q ∈ (− 1,1). n=0 1 − q ](img/file988.png)'
  prefs: []
  type: TYPE_IMG
- en: As S[N] + q^(N+1) = S[N+1] = 1 + qS[N], it follows that S[N] = ![1−qN+1 1−q](img/file989.png).
    Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![ (| ∞ ||| undefined if q ≤ − 1, ∑ n 1-−-qN+1- { 1 q = Nli→m∞ 1 − q = | 1−-q
    if − 1 <q <1, n=0 |||( ∞ if 1 ≤ q. ](img/file990.png)'
  prefs: []
  type: TYPE_IMG
- en: This is where the famous formula ∑ [n=1]^∞![1- 2n](img/file991.png) = 1 comes
    from. (Figure [10.6](#) illustrates this fact as well.)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file992.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: The visual proof of the convergence of a geometric series for
    q = 1∕2'
  prefs: []
  type: TYPE_NORMAL
- en: The geometric series is also the one that appears in our introductory pizza
    coupon example. Now, we can see that the value of a single purchase is
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞∑ 1 1 10 --n-= ----1-= --- n=0 10 1− 10 9 ](img/file993.png)'
  prefs: []
  type: TYPE_IMG
- en: pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2\. The harmonic series, given by
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ -1 = ∞. n=1n ](img/file994.png)'
  prefs: []
  type: TYPE_IMG
- en: Why is the harmonic series divergent? To see why, first notice that
  prefs: []
  type: TYPE_NORMAL
- en: '![2k+1−1 2k+1−1 ∑ 1- ∑ --1-- n ≥ 2k+1 n=2k n=2k -2k-- = 2k+1 1 = 2-. ](img/file995.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, by grouping the terms appropriately, we obtain that
  prefs: []
  type: TYPE_NORMAL
- en: '![ k+1 ∞∑ 1- ∞∑ 2∑ −11- n = ( n ) n=1 k=0 n=2k ∞∑ 1 ≥ -- k=02 = ∞. ](img/file996.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are having trouble imagining this, here is the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![PIC](img/file997.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: The harmonic series'
  prefs: []
  type: TYPE_NORMAL
- en: According to the Euler-Maclaurin formula,
  prefs: []
  type: TYPE_NORMAL
- en: '![N∑ 1- n ≈ logN + γ, n=1 ](img/file998.png)'
  prefs: []
  type: TYPE_IMG
- en: where γ ≈ 0.5772156649… is the famous Euler–Mascheroni constant. Check it out.
    (When the base is omitted, log denotes the natural logarithm, also often denoted
    by ln.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![PIC](img/file999.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: The harmonic series and the log(x + γ) function'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3\. The alternating harmonic series, given by
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ 1 (− 1)n+1--= log2\. n=1 n ](img/file1000.png)'
  prefs: []
  type: TYPE_IMG
- en: Surprisingly, the alternating harmonic series is convergent, with the sum log
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4\. The Basel problem. Believe it or not, solving polynomial equations
    and evaluating infinite sums were some kind of sport for mathematicians of previous
    eras. One of the most famous ones was the Basel problem, concerning the infinite
    sum of inverse squares. In 1735, the legendary Euler showed that
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞ ∑ 1-- π2- n2 = 6 , n=1 ](img/file1001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'which is a stunning result. What on Earth is π doing there? The constant π
    is defined as the half circumference of a circle of radius 1, and seeing it pop
    up in the infinite sum of inverse squares is puzzling to say the least. (There
    is an explanation: the numbers 1∕n² are the (scaled) Fourier coefficients of the
    function f(x) = x, and the sum of the Fourier coefficients always evaluates to
    the integral of the function over the interval [ −π,π]. However, this method is
    beyond the scope of this book.)'
  prefs: []
  type: TYPE_NORMAL
- en: On a personal note, ∑ [n=1]^∞![1 n2](img/file1002.png) = ![π2 6-](img/file1003.png)
    was the favorite identity of my calculus professor, a teacher who I loved so much
    that I ended up specializing in mathematical analysis. Once, he hit his head in
    an accident. Upon arrival of the ambulance, he was asked by the paramedic to talk,
    just to gauge if his cognitive capabilities were intact. So, he started to explain
    the Basel problem to the medical staff. He was almost shipped to the trauma center,
    but fortunately, his wife was there to explain that he is normal; he’s just a
    mathematician.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5\. Apéry’s constant. We’ve seen the harmonic series and the Basel problem,
    so what about the sum of inverse cubes? Although it is known that the series
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ 1-- n=1 n3 ](img/file1004.png)'
  prefs: []
  type: TYPE_IMG
- en: is convergent and its value is irrational, we don’t have a closed-form solution
    just yet!
  prefs: []
  type: TYPE_NORMAL
- en: Example 6\. The alternating series
  prefs: []
  type: TYPE_NORMAL
- en: '![∞∑ (− 1)n. n=0 ](img/file1005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the first example of a divergent series: as'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ∑N |{ 1 if n is even (− 1)n = n=0 |( 0 if n is odd, ](img/file1006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'the limit lim[N→∞]∑ [n=0]^N(−1)^n doesn’t exist. This is the resolution of
    the seemingly paradoxical result from the introduction: as ∑ [n=0]^∞(−1)^n is
    divergent, associativity breaks down.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7\. The famous Euler number, defined by e = lim[n→∞](1 + ![1n](img/file1008.png))^n,
    is also given by the infinite series
  prefs: []
  type: TYPE_NORMAL
- en: e = ∑ [n=0]^∞![1- n!](img/file1010.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, this is beyond our scope, but later, we’ll see why this is true.
    (Spoiler alert: This is a so-called Taylor series, which we’ll talk about in Chapter [12](ch020.xhtml#differentiation).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the following question: is there a method that tells if a series
    is convergent or not? Finding a closed formula for the partial sums is not always
    possible. I urge you to try finding one for ∑ [n=0]^N1∕n!, if you don’t believe
    me.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 Properties of series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at some of the most important properties of series. First,
    it is immediately clear that the general term of a convergent series should converge
    to 0 as well.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Let ∑ n = 1^∞a[n] be a convergent series. Then lim[N→∞]a[N] = 0.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. As a[N] = ∑ [n=1]^Na[n] −∑ [n=1]^(N−1)a[n], we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ N N−1 lim a = lim (∑ a − ∑ a ) N→ ∞ N N →∞ n=1 n n=1 n N N −1 ∑ ∑ = Nlim→∞
    an − Nlim→∞ an ∞ n=1 ∞ n=1 ∑ ∑ = an − an n=1 n=1 = 0, ](img/file1011.png)'
  prefs: []
  type: TYPE_IMG
- en: which is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition [2](ch018.xhtml#x1-175002r2) can be used to quickly gauge the convergence
    of certain series. For instance, ∑ [n=1]^∞![n+1- n](img/file1012.png) cannot be
    convergent, as lim[n→∞]![n+1- n](img/file1013.png) = 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, note that the reverse of Proposition [2](ch018.xhtml#x1-175002r2)
    is not true: there are divergent series with a general term converging to 0\.
    One immediate example is the harmonic series ∑ [n=1]^∞![1 n](img/file1014.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Just like sequences, convergent series behave with respect to addition and scalar
    multiplication, as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 59\. (Linearity of convergent series)
  prefs: []
  type: TYPE_NORMAL
- en: Let ∑ n = 1^∞a[n] and ∑ n = 1^∞b[n] be two convergent series, and let α,β ∈ℝ
    be two arbitrary real numbers. Then,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞ ∞ ∞ α ∑ a + β ∑ b = ∑ (αa + βb ). n n n n n=1 n=1 n=1 ](img/file1015.png)'
  prefs: []
  type: TYPE_IMG
- en: The proof is a direct consequence of Theorem [57](ch018.xhtml#x1-167006r57).
    Feel free to work it out by hand for practice!
  prefs: []
  type: TYPE_NORMAL
- en: Note that Theorem [59](ch018.xhtml#x1-175004r59) does not apply to divergent
    series. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ n n+1 [(− 1) + (− 1) ] = 0, n=0 ](img/file1016.png)'
  prefs: []
  type: TYPE_IMG
- en: However,
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ ∑∞ (− 1)n and (− 1)n+1 n=0 n=0 ](img/file1017.png)'
  prefs: []
  type: TYPE_IMG
- en: are both divergent.
  prefs: []
  type: TYPE_NORMAL
- en: The product of a series is slightly more convoluted. We’ll deal with this later
    in the chapter, I promise.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.3 Conditional and absolute convergence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s turn the weirdness up a notch. Recall the alternating harmonic series
    ∑ [n=1]^∞(−1)^(n+1)![1 n](img/file1018.png), whose sum is log 2\. What happens
    if we rearrange its terms?
  prefs: []
  type: TYPE_NORMAL
- en: Instead of alternating between one odd and one even term, let’s do one odd and
    two even. (Odd and even with respect to their indices.)
  prefs: []
  type: TYPE_NORMAL
- en: This is illustrated by Figure [10.9](#).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: A rearrangement of the alternating harmonic series'
  prefs: []
  type: TYPE_NORMAL
- en: The change is small, but carries a profound impact. As it turns out, by simply
    rearranging the terms, we change the value of the sum! Check out Figure [10.10](#)
    to see why.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: A rearrangement of the alternating harmonic series, explained'
  prefs: []
  type: TYPE_NORMAL
- en: This happens because rearrangements are not valid operations in the world of
    series. However, the notion of convergence can be refined in a way that’ll enable
    us to differentiate between rearrangeable and non-rearrangeable series.
  prefs: []
  type: TYPE_NORMAL
- en: Enter absolute and conditional convergence.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 43\. (Absolute and conditional convergence)
  prefs: []
  type: TYPE_NORMAL
- en: Let ∑ [n=1]^∞a[n] be an infinite series.
  prefs: []
  type: TYPE_NORMAL
- en: (a) If ∑ [n=1]^∞ja[n]j is convergent, then ∑ [n=1]^∞a[n] is called absolutely
    convergent.
  prefs: []
  type: TYPE_NORMAL
- en: (b) If ∑ [n=1]^∞a[n] is convergent but not absolutely convergent, then it is
    called conditionally convergent.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the geometric series ∑ [n=0]^∞![( ) − 1 2](img/file1021.png)^n
    is absolutely convergent, while the alternating harmonic series ∑ [n=1]^∞(−1)^n![1
    n](img/file1022.png) is only conditionally convergent.
  prefs: []
  type: TYPE_NORMAL
- en: If a series is absolutely convergent, then it is convergent as well. (We’ll
    skip the proof, as the minute technical details are not that important for us.)
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4 Revisiting rearrangements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being absolutely or conditionally convergent has a profound impact on the behavior
    of the series. One prime example is its rearrangeability. As it turns out, absolutely
    convergent series can be rearranged, while conditionally convergent series go
    crazy.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically speaking, rearrangements can be formalized via permutations of
    the index set.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 44\. (Permutations)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let A be an arbitrary set. The mapping σ : A →A is called a permutation of
    A if it is bijective.'
  prefs: []
  type: TYPE_NORMAL
- en: It seems quite abstract, but permutations are easy to grasp. Think about the
    index set as the increasing sequence
  prefs: []
  type: TYPE_NORMAL
- en: '![1,2,3,4,5,6,.... ](img/file1023.png)'
  prefs: []
  type: TYPE_IMG
- en: (It may include 0, or might even start from a larger number.) The simple permutation
  prefs: []
  type: TYPE_NORMAL
- en: '![ (| { 2k − 1 if n = 2k, σ(n) = | ( 2k if n = 2k − 1 ](img/file1024.png)'
  prefs: []
  type: TYPE_IMG
- en: swaps the neighboring even and odd numbers, turning the index set into
  prefs: []
  type: TYPE_NORMAL
- en: '![σ(1) = 2,σ(2) = 1,σ (3) = 4,σ(4) = 3,.... ](img/file1025.png)'
  prefs: []
  type: TYPE_IMG
- en: For a general series ∑ [n=1]^∞a[n], its rearrangement given by the permutation
    σ is ∑ [n=1]^∞a[σ(n)].
  prefs: []
  type: TYPE_NORMAL
- en: So, can you rearrange a convergent series? If it is absolutely convergent, without
    a doubt.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 60\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let ![∑ ∞ n=1 an ](img/file1026.png) be an absolutely convergent series and
    ![σ : ℕ → ℕ ](img/file1027.png) be an arbitrary permutation. Then, the rearrangement
    ![∑ ∞ aσ(n) n=1 ](img/file1028.png) is convergent as well and'
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ ∑∞ aσ(n) = an. n=1 n=1 ](img/file1029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not going to prove this here, but the essence is, convergent series
    absolutely behave as we expect: we can change the order of terms without affecting
    the result.'
  prefs: []
  type: TYPE_NORMAL
- en: What about conditionally convergent series? We have seen that rearranging can
    change the value, but the situation is much more interesting. Meet the Riemann
    rearrangement theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 61\. (The Riemann rearrangement theorem)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let ∑ [n=1]^∞a[n] be a conditionally convergent series and let c ∈ ℝ be an
    arbitrary real number. Then, there exists a permutation σ : ℕ →ℕ such that'
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ aσ(n) = c. n=1 ](img/file1030.png)'
  prefs: []
  type: TYPE_IMG
- en: This is quite wild. The Riemann rearrangement theorem states that if you give
    me an arbitrary real number, I can conjure a rearrangement that’ll change the
    value to the number you gave me.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t prove this either, but here is an intuitive explanation. Suppose that
    you want to rearrange the series to change its sum to 10\. You start putting the
    positive terms in descending order to the front, and when the partial sum overshoots
    10, you continue with the negative terms. When the partial sum undershoots 10,
    you turn to positive values once more, and you keep repeating this until infinity.
    The property of conditional convergence guarantees that this method works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the subtle differences between absolute and conditional
    convergence, let’s turn to one of the burning questions we should have asked already:
    how do we know if a series is convergent or not?'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.5 Convergence tests for series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Showing if a series is convergent or not is a hard task. Finding a closed form
    for the partial sums is often impossible, even in the seemingly simplest cases,
    such as ∑ [n=1]^∞![1n2](img/file1031.png).
  prefs: []
  type: TYPE_NORMAL
- en: What to do, then? The simplest way is to compare the series with another one
    that we are familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 62\. (The direct comparison test)
  prefs: []
  type: TYPE_NORMAL
- en: Let ![∑ ∞ an n=1 ](img/file1032.png) be an arbitrary series.
  prefs: []
  type: TYPE_NORMAL
- en: (a) If ∑ [n=1]^∞b[n] is absolutely convergent and ja[n]j ≤jb[n]j for all n after
    a certain cutoff, ∑ [n=1]^∞a[n] is absolutely convergent.
  prefs: []
  type: TYPE_NORMAL
- en: (a) If ∑ [n=1]^∞b[n] = ∞and jb[n]j ≤ja[n]j for all n after a certain cutoff,
    then ∑ [n=1]^∞a[n] = ∞.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple use case for Theorem [62](ch018.xhtml#x1-178003r62): the series'
  prefs: []
  type: TYPE_NORMAL
- en: '![∞∑ -1-. n=1n α ](img/file1033.png)'
  prefs: []
  type: TYPE_IMG
- en: For ![α >2 ](img/file1034.png), since ![n1α < 12 n ](img/file1035.png), the
    series
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ 1 -α- n=1 n ](img/file1036.png)'
  prefs: []
  type: TYPE_IMG
- en: is convergent via comparison to
  prefs: []
  type: TYPE_NORMAL
- en: '![∑∞ 1 --2\. n=1n ](img/file1037.png)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, for α/span>1, as ![1- nα](img/file1038.png)/span>![1 n](img/file1039.png),
    ∑ [n=1]^∞![1- nα](img/file1040.png) is divergent via comparison to the harmonic
    series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the direct comparison test is powerful, it has a significant downside:
    you have to conjure up a series for comparison. This is not always simple. Thus,
    we need other tests to show convergence. We’ll talk about two of them: the root
    test and the alternating series test.'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 63\.
  prefs: []
  type: TYPE_NORMAL
- en: (The root test)
  prefs: []
  type: TYPE_NORMAL
- en: Let ∑ [n=1]^∞a[n] be an arbitrary series. If there exists a positive integer
    N such that
  prefs: []
  type: TYPE_NORMAL
- en: '![∘ ---- n |an | <1 ](img/file1041.png)'
  prefs: []
  type: TYPE_IMG
- en: for all n ≥N, then ∑ [n=1]^∞a[n] is absolutely convergent.
  prefs: []
  type: TYPE_NORMAL
- en: The most important use case for the root test is showing the convergence of
    ![∑ ∞n=0 1n! ](img/file1042.png) (which sums up to the Euler constant ![e ](img/file1043.png),
    but we have no way to evaluate the sum yet). We’ll have one soon, coming from
    the most unexpected place. But I don’t want to spoil the fun yet.
  prefs: []
  type: TYPE_NORMAL
- en: About that sum. As ![lim √nn!- = ∞ n→ ∞ ](img/file1044.png) (which, trust me,
    it really is), ![limn → ∞ n√1n!-= 0 ](img/file1045.png). Thus, the conditions
    of Theorem [63](ch018.xhtml#x1-178005r63) are satisfied, hence ![∑ ∞ 1- n=1 n!
    ](img/file1046.png) is convergent.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of the root test is that studying the behavior of ![n√--- an](img/file1047.png)
    can be surprisingly hard. We have to be true calculus ninjas to handle all the
    bounds and limits the root test will throw at us. So, we’ll take a look at one
    more convergence test.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 64\.
  prefs: []
  type: TYPE_NORMAL
- en: (The alternating test, a.k.a. the Leibniz criterion)
  prefs: []
  type: TYPE_NORMAL
- en: Let ![{an}∞n=0 ](img/file1048.png) be a sequence whose terms are either all
    nonnegative or all negative. If
  prefs: []
  type: TYPE_NORMAL
- en: (a) ja[n]j decreases monotonically
  prefs: []
  type: TYPE_NORMAL
- en: (b) and ![limn →∞ an = 0 ](img/file1049.png),
  prefs: []
  type: TYPE_NORMAL
- en: then ∑ [n=0]^∞(−1)^na[n] is conditionally convergent.
  prefs: []
  type: TYPE_NORMAL
- en: It’s that simple. The alternating test is the easiest to apply, but in turn,
    it only implies conditional convergence. With this, we can finally see that the
    alternating harmonic series ∑ [n=1]^∞(−1)^(n+1)![1 n](img/file1050.png) is conditionally
    convergent.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.6 The Cauchy product of series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To close this chapter, let’s talk about the product of two series. We’ve seen
    that the linear combination of convergent series behaves nicely, but what about
    the product? This is slightly more complicated than addition. Here is the exact
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 65\. (Mertens’ theorem)
  prefs: []
  type: TYPE_NORMAL
- en: Let ![∑ ∞ n=0 an ](img/file1051.png) and ![∑ ∞ n=0 bn ](img/file1052.png) be
    two convergent series, and assume that at least one of them converges absolutely.
    Then, the series
  prefs: []
  type: TYPE_NORMAL
- en: ∑[n=0]^∞ ( ∑[k=0]^n *a*[k]*b*[n−k] ) (10.3)
  prefs: []
  type: TYPE_NORMAL
- en: is convergent and
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑∞ ∑∞ ∑∞ ∑n ( ak)( bn) = ( akbn−k). k=0 n=0 n=0 k=0 ](img/file1055.png)'
  prefs: []
  type: TYPE_IMG
- en: The series ([65](ch018.xhtml#x1-179004r65)) is called the Cauchy product of
    ![∑ ∞n=0 an ](img/file1056.png) and ![∑ ∞n=0bn ](img/file1057.png). Note that
    in the sum ![∑n k=0akbn−k ](img/file1058.png), the indices of each term ![akbn−
    k ](img/file1059.png) sum up to ![n ](img/file1060.png).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of an exact proof, here is an intuitive explanation. Let’s unpack what
    is going on when we take the product of sums.
  prefs: []
  type: TYPE_NORMAL
- en: As the product is calculated term by term, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑∞ ∑∞ ∑∞ ∑∞ ( ak )( bn) = (ak bn) k=0 n=0 k=0 n=0 = a0(b0 + b1 + b2 + ...)
    + a1(b0 + b1 + b2 + ...) + a2(b0 + b1 + b2 + ...) + ... = a0b0 + a0b1 + a0b2 +
    ... + a b + a b + a b + ... 1 0 1 1 12 + a2b0 + a2b1 + a2b2 + ... + .... ](img/file1061.png)'
  prefs: []
  type: TYPE_IMG
- en: After spelling out the product term by term, the terms a[k]b[l] are arranged
    in a table. Upon taking the product of ∑ [n=0]^∞a[n] and ∑ [n=0]^∞b[n], we simply
    take the terms in this table and sum them up, row by row.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can sum the terms diagonally. By taking a look at the table
  prefs: []
  type: TYPE_NORMAL
- en: '![a0b0 + a0b1 + a0b2 + ... a1b0 + a1b1 + a1b2 + ... a2b2 + a2b1 + a2b2 + ...
    ](img/file1062.png)'
  prefs: []
  type: TYPE_IMG
- en: you can notice that the diagonals sum up to ∑ [k=0]^na[k]b[n−k]. Thus, by taking
    all of them into account, we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∞∑ ∑∞ ∑∞ ∑n ( ak)( bn ) = ( akbn−k). k=0 n=0 n=0 k=0 ](img/file1063.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, this is not an exact proof, as we’ve used rearrangements without
    showing absolute convergence.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until this chapter, our mathematical study was quite close to machine learning.
    Vectors, matrices, functions: they are all there at the ground zero of theory
    and practice.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, however, we’ve gone far below the surface. We rarely work directly
    with sequences in practice, but despite appearances, they are all over the place,
    providing a solid theoretical foundation for everything that is quantitative.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn? What numbers are, for one. Going from natural numbers
    to real numbers is nothing short of a revelation, allowing us to see the evolution
    of the concept of a number. But deep down, sequences hold the concept of numbers
    together. And whenever we talk about sequences, limits and convergence enter the
    picture.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, gradient descent is about the limit of the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '![ ′ xn+1 = xn − hf (xn), ](img/file1064.png)'
  prefs: []
  type: TYPE_IMG
- en: converging to a local minima of f if the stars are aligned. In the following
    chapters, our main goal is to understand x[n+1] = x[n] −hf^′(x[n]). What is f^′(x),
    and why does x[n] converge to a local minimum? To see the full picture, we need
    to study differentiation and integration, or in other words, calculus.
  prefs: []
  type: TYPE_NORMAL
- en: However, to get there, there’s one more step to take. It’s time to move beyond
    sequences and study the concept of limits in the context of functions!
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem 1\. Which sequences are convergent, ∞-divergent, or neither?
  prefs: []
  type: TYPE_NORMAL
- en: (a) a[n] = 2^(−n²) (b) b[n] = ![√2n--](img/file1065.png) (c) c[n] = ![nn+1-](img/file1066.png)
    (d) d[n] = sin(1∕n) (e) e[n] = e^(n(−1)^n)
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2\. Calculate the following limits.
  prefs: []
  type: TYPE_NORMAL
- en: (a) ![lim -5n2+2- n→∞ 3n2−12 ](img/file1067.png)
  prefs: []
  type: TYPE_NORMAL
- en: (b) ![ ( 5n2+2-) limn →∞ ln 3n2− 12 ](img/file1068.png)
  prefs: []
  type: TYPE_NORMAL
- en: (c) ![limn→ ∞ √1+n2n2- ](img/file1069.png)
  prefs: []
  type: TYPE_NORMAL
- en: (d) ![limn →∞ n1sin (n ) ](img/file1070.png)
  prefs: []
  type: TYPE_NORMAL
- en: (e) lim[n→∞](1 + ![2 n](img/file1072.png))^n
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3\. Which series are absolute convergent, conditionally convergent,
    or divergent? (Use the direct comparison test, the root test, and the alternating
    series test.)
  prefs: []
  type: TYPE_NORMAL
- en: (a) ![∑ ∞ 2 n=0e− n ](img/file1074.png)
  prefs: []
  type: TYPE_NORMAL
- en: (b) ![∑ ( ) ∞n=0(− 1 )n sin 1n ](img/file1075.png)
  prefs: []
  type: TYPE_NORMAL
- en: (c) ![∑ ∞ -nn n=02 ](img/file1076.png)
  prefs: []
  type: TYPE_NORMAL
- en: (d) ![∑ ∞ n+1- n=1 n2 ](img/file1077.png)
  prefs: []
  type: TYPE_NORMAL
- en: (e) ∑ [n=0]^∞![--1-- 2n+n](img/file1078.png)
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
