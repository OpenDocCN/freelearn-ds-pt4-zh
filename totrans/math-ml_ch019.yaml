- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topology, Limits, and Continuity
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned all (that’s relevant to us) about numbers,
    sequences, and series. These are the foundational objects of calculus: numbers
    define sequences, sequences define limits, and limits define almost every quantity
    that interests us. However, there’s a snag. Let’s look ahead and take a look at
    the definition of the derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ′ f-(x-)−-f(y) f (y) = xli→my x − y ](img/file1079.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you’re feeling a sense of déjà vu, don’t be surprised. We looked at this
    exact formula in the introduction of the previous chapter as well, and we are
    much closer to understanding it. We have learned about limits, but there seems
    to be an issue: limits were defined in terms of sequences, and the expression
    lim[x→y]whatever(x) does not seem to be it.'
  prefs: []
  type: TYPE_NORMAL
- en: What is it, then? This is what we’ll learn in this chapter, starting with the
    topology of real numbers. Let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the [Cambridge English Dictionary](https://dictionary.cambridge.org/dictionary/english/topology),
    the word “topology” means
  prefs: []
  type: TYPE_NORMAL
- en: the way the parts of something are organized or connected.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From a mathematical perspective, topology studies the local properties of structures
    and spaces.
  prefs: []
  type: TYPE_NORMAL
- en: In machine learning, we are often interested in global properties like minima
    and maxima but only have local tools to search for them. One example is the derivative
    of functions. Derivatives describe the slope of the tangent plane, and as Figure [11.1](#)
    illustrates, this doesn’t change if the function is modified away from the point
    where the derivative is taken.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1080.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The derivatives of two functions are equal if the functions are
    equal in any small interval around the point'
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, local properties are handled in terms of sequences and neighborhoods.
    We learned about sequences in the last chapter, and now we will tackle the subject
    of neighborhoods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to focus on three fundamental aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: open and closed sets,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the behavior of sequences within sets,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and their smallest and largest elements, upper and lower bounds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our main goal with mathematical analysis is to understand gradient descent,
    a fundamental tool for training models. To do that, we need to understand limits.
    For that, we need understand sequences and real numbers, leading us deep into
    the rabbit hole where we are now.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it as learning the Python language versus learning TensorFlow or PyTorch.
    Since we want to do machine learning, we ultimately want to learn a high-level
    framework. However, if we lack the understanding of the basic keywords in Python,
    like import or def, we are not ready to learn and productively use advanced tools.
    Sequences, open and closed sets, limits, and others are the fundamental building
    blocks of mathematical analysis, the language of optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.1 Open and closed sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start our discussion with open and closed sets! (In this chapter, when
    we refer to something as a subset or set, it is implicitly assumed to be within
    ℝ.)
  prefs: []
  type: TYPE_NORMAL
- en: Definition 45\. (Open and closed sets)
  prefs: []
  type: TYPE_NORMAL
- en: Let A ⊆ℝ be a subset of the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: (a) A is open if for every x ∈A, there is a 𝜀/span>0 such that (x−𝜀,x + 𝜀) ⊆A.
  prefs: []
  type: TYPE_NORMAL
- en: (b) A is closed if its complement ℝ ∖A is open.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start analyzing the properties of open and closed sets, here are some
    key examples for building up useful mental models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1\. Intervals of the form (a,b) = {x ∈ℝ : a/span>x/span>b} are open.
    This can be easily seen by picking any x ∈ (a,b) and letting 𝜀 = min{jx −aj∕2,jx
    −bj∕2}. Essentially, we take the distance from the closest endpoint and cut that
    in half. Any point that is closer to x than the half-distance of the closest endpoint
    will also be in (a,b).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2\. Intervals of the form [a,b] = {x ∈ℝ : a ≤x ≤b} are closed. Indeed,
    its complement is ℝ ∖ [a,b] = (−∞,a) ∪ (b,∞). Using the reasoning above, it is
    easy to see that (−∞,a) ∪ (b,∞) is open.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3\. Intervals of the form (a,b] = {x ∈ℝ : a/span>x ≤b} are neither
    open nor closed. To see that it is not open, observe that no interval containing
    b is fully within (a,b], since b is an endpoint. For similar reasons, its complement
    ℝ ∖ (a,b] = (−∞,a] ∪ (b,∞) is not open.'
  prefs: []
  type: TYPE_NORMAL
- en: An important takeaway from the last example is that if a set is not closed,
    it doesn’t mean that it is open and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: We can rephrase the definition of openness by introducing the concept of neighborhoods.
    The neighborhoods of a given point x are the open intervals (a,b) containing x.
    With this terminology, any set A is open if, for any x ∈A, there exists a neighborhood
    of x that is fully contained within A. From this aspect, openness means that there
    is still “room to move” from any point.
  prefs: []
  type: TYPE_NORMAL
- en: The most fundamental property of open and closed sets is their behavior under
    union and intersection. As this holds for any collection of open and closed sets,
    we need to introduce a new notation here. Recall that if we have the sets A[1],…,A[n],
    their union can be abbreviated as
  prefs: []
  type: TYPE_NORMAL
- en: '![∪nk=1Ak = A1 ∪⋅⋅⋅∪ An. ](img/file1081.png)'
  prefs: []
  type: TYPE_IMG
- en: This is denoted similarly for the intersection. If we have countable sets, we
    can even write
  prefs: []
  type: TYPE_NORMAL
- en: '![⋃∞ Ak, k=1 ](img/file1082.png)'
  prefs: []
  type: TYPE_IMG
- en: but what can we do if we have an uncountable collection of sets? Say, ![Ac =
    [0,c] ](img/file1083.png) for all ![c ∈ (0,∞ ) ](img/file1084.png). In this case,
    we use the expression
  prefs: []
  type: TYPE_NORMAL
- en: '![⋃ Ac. c> ](img/file1085.png)'
  prefs: []
  type: TYPE_IMG
- en: For a general set ![Γ ](img/file1086.png), we talk about the collection of sets
    defined by ![{Aγ }γ∈ Γ ](img/file1087.png), and the union/intersection
  prefs: []
  type: TYPE_NORMAL
- en: '![ ⋃ A , ⋂ A . γ∈Γ γ γ∈Γ γ ](img/file1088.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s see our first theorem!
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 66\.
  prefs: []
  type: TYPE_NORMAL
- en: Let ![{Aγ} γ∈ Γ ](img/file1089.png) be an arbitrary collection of sets.
  prefs: []
  type: TYPE_NORMAL
- en: (a) If each ![A γ ](img/file1090.png) is open, then
  prefs: []
  type: TYPE_NORMAL
- en: '![ ⋃ A γ∈Γ γ ](img/file1091.png)'
  prefs: []
  type: TYPE_IMG
- en: is also open.
  prefs: []
  type: TYPE_NORMAL
- en: (b) If each ![Aγ ](img/file1092.png) is closed, then
  prefs: []
  type: TYPE_NORMAL
- en: '![ ⋂ Aγ γ∈Γ ](img/file1093.png)'
  prefs: []
  type: TYPE_IMG
- en: is also closed.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (a) Suppose that A[γ],γ ∈ Γ are open sets and let x ∈∪[γ∈Γ]A[γ]. Because
    x is in the union, there is some γ[0] ∈ Γ such that x ∈ A[γ[0]]. Because A[γ[0]]
    is open, there is a small neighborhood (a,b) of x such that (a,b) ⊆A[γ[0]]. Because
    of this, (a,b) ⊆∪[γ∈Γ]A[γ], which is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Now let A[γ],γ ∈ Γ be closed sets. In this case, De Morgan’s laws (Theorem [153](ch037.xhtml#x1-377003r153))
    imply that ℝ ∖ (∩[γ∈Γ]A[γ]) = ∪[γ∈Γ](ℝ ∖A[γ]). Since each A[γ] is closed, ℝ ∖A[γ]
    is open. As we have previously seen, the union of open sets is open.
  prefs: []
  type: TYPE_NORMAL
- en: The closedness and openness of a set influence its behavior regarding set sequences.
    The first fundamental result regarding this is Cantor’s axiom.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 67\. (Cantor’s axiom)
  prefs: []
  type: TYPE_NORMAL
- en: Let I[n] = [a[n],b[n]] ⊆ ℝ be a sequence of intervals such that I[n+1] ⊆ I[n]
    for every n ∈ℕ. Then, the intersection ∩[n=1]^∞I[n] is nonempty.
  prefs: []
  type: TYPE_NORMAL
- en: This seemingly simple proposition is a profound property of real numbers, one
    that ultimately follows from their mathematical construction. Cantor’s axiom is
    not true, for instance, if we talk about subsets of ℚ instead of ℝ. Think about
    a sequence of rational numbers a[n] →π that approximates π from below, and another
    sequence b[n] →π that approximates π from above, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![an <π <bn, an,bn ∈ ℚ. ](img/file1094.png)'
  prefs: []
  type: TYPE_IMG
- en: The intersection of the intervals [a[n],b[n]] only contains π, which is not
    rational. Thus, in the space of rational numbers, ∩[n=1]^∞[a[n],b[n]] = ∅, therefore
    Cantor’s axiom doesn’t hold there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an old proverb about losing the war because of a nail in a horseshoe.
    It goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: For want of a nail the shoe was lost. For want of a shoe the horse was lost.
    For want of a horse the rider was lost. For want of a rider the message was lost.
    For want of a message the battle was lost. For want of a battle the kingdom was
    lost. And all for the want of a horseshoe nail.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about Cantor’s axiom as the nail in the horseshoe. Without it, we can’t
    talk about taking limits of sequences. Without limits, there are no gradients.
    Without gradients, there is no gradient descent, and consequently, we can’t fit
    machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.2 Distance and topology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Originally, we defined open sets in terms of small open intervals like (x −𝜀,x
    + 𝜀). We called a set open if you could squeeze in such a small interval for each
    of its points. By taking a step of abstraction, we can rephrase the definition
    in terms of norms (Definition [7](ch008.xhtml#x1-40015r7)).
  prefs: []
  type: TYPE_NORMAL
- en: From this viewpoint, an interval (x−𝜀,x + 𝜀) is the same as a one-dimensional
    open ball. Given a normed space V with the norm j ⋅j, the ball of radius r/span>0
    centered at x is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![B(x,r) := {y ∈ V : ∥x − y∥ <r}. ](img/file1095.png)'
  prefs: []
  type: TYPE_IMG
- en: Equivalently, a ball of radius r is the set of points with distance less than
    r from the center point. In the Euclidean spaces ℝ^n, with the norm ∥x∥ = ![∘
    -2---------2 x1 + ⋅⋅⋅+ x n](img/file1096.png), this matches our intuitive understanding.
    This is illustrated in Figure [11.2](#).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1097.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Balls, from one to three dimensions'
  prefs: []
  type: TYPE_NORMAL
- en: However, in one dimension, the Euclidean norm simplifies to ∥x∥ = jxj. Thus,
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '![B (x,r) = {y ∈ ℝ : |x − y| <r} = (x − r,x+ r). ](img/file1098.png)'
  prefs: []
  type: TYPE_IMG
- en: We don’t often think about the interval (x −𝜀,x + 𝜀) as the one-dimensional
    ball B(x,𝜀). However, making this connection will make it easy to later extend
    the topology of ℝ to ℝ^n, which is where we want to work eventually.
  prefs: []
  type: TYPE_NORMAL
- en: With norms and balls, we can rephrase the definition of open sets in the following
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 46\. (Open sets, second take)
  prefs: []
  type: TYPE_NORMAL
- en: Let A ⊆ℝ be a subset of the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: A is open if for every x ∈A, there is a one-dimensional ball B(x,𝜀) of radius
    𝜀 centered around x such that B(x,𝜀) ⊆A.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in a sense, open sets are determined by open balls.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.3 Sets and sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Closed sets can be characterized in terms of their sequences. The following
    theorem shows an equivalent definition of closed sets, giving us a helpful way
    of thinking about them.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 68\. (Characterization of closed sets with sequences)
  prefs: []
  type: TYPE_NORMAL
- en: Let A ⊆ℝ be a set. The following are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: (a) A is closed.
  prefs: []
  type: TYPE_NORMAL
- en: (b) If {a[n]}[n=1]^∞⊆A is a convergent sequence, then lim[n→∞]a[n] ∈A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. To prove that the two statements are equivalent, we have to show two
    things: that (a) implies (b) and that (b) implies (a). Don’t worry if this proof
    seems too complicated when you read it the first time. If you don’t understand
    it right away, I suggest thinking about A as a closed interval and drawing a figure.
    You can also skip it since I will refer back to this fact every time we need it
    later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s see that (a) implies (b). Thus, suppose that A is closed and {a[n]}[n=1]^∞
    ⊆ A is a convergent sequence, a := lim[n→∞]a[n]. We have to show that a ∈A, and
    we are going to do this by contradiction. The plan is the following: assume that
    a![∕∈](img/file1099.png)A and deduce that {a[n]} must eventually leave A.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, suppose that a ∈ℝ ∖A. Because A is closed, ℝ ∖A is open, so there is
    a small neighborhood (a −𝜀,a + 𝜀) ⊆ℝ ∖A. In plain English, this means that we
    can separate a from A. This contradicts the fact that {a[n]} ⊆ A and a[n] → a,
    because according to the definition of convergence (Definition [39](ch018.xhtml#x1-166003r39)),
    eventually all members of the sequence have to fall into (a −𝜀,a + 𝜀). This is
    a contradiction, so a ∈A.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we will show that (b) implies (a), that is, if the limit of every convergent
    sequence of A is also in A, then the set is closed. Our goal is to show that ℝ
    ∖A is open. More precisely, if x ∈ ℝ ∖A, we want to find a small neighborhood
    (x −𝜀,x + 𝜀) that is disjointed from A. Again, we can show this via contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that no matter how small 𝜀 > 0 is, we can find an a ∈ A∩(x−𝜀,x+𝜀). Thus,
    we can define a sequence {a[n]}[n=1]^∞ such that a[n] ∈A ∩ (x − 1∕n,x + 1∕n).
    Due to the construction lim[n→∞]a[n] = a, and as A is closed to taking limits
    according to the premise (b), this would imply that a ∈A, which is a contradiction.
    This is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: This result also explains the origins of the terminology closed. A closed set
    is such because it is closed to limits.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.4 Bounded sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a (very) high-level view, machine learning can be described as an optimization
    problem. For inputs x and predictions y, we are looking at a parametrized family
    of functions f(x,w), where our parameters are condensed in the variable w.
  prefs: []
  type: TYPE_NORMAL
- en: Given a set of samples and observations, our goal is to find the minimum of
    the set
  prefs: []
  type: TYPE_NORMAL
- en: '{Loss(*f*(**x**, **w**), **y**) : **w** ∈ ℝ^(a very large number)} ⊆ ℝ, (11.1)'
  prefs: []
  type: TYPE_NORMAL
- en: and the parameter configuration w where the optimum is attained. To make sure
    that our foundations are not missing this building block, we are going to take
    some time to study this.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 47\. (Bounded sets)
  prefs: []
  type: TYPE_NORMAL
- en: Let A ⊆ℝ.
  prefs: []
  type: TYPE_NORMAL
- en: (a) A is bounded from below if there is an m ∈ ℝ such that m/span>x for all
    x ∈A. The number m is called a lower bound.
  prefs: []
  type: TYPE_NORMAL
- en: (b) A is bounded from above if there is an M ∈ ℝ such that x/span>M for all
    x ∈A. Similar to before, M is called an upper bound.
  prefs: []
  type: TYPE_NORMAL
- en: (c) A is bounded if it is bounded from above and below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being bounded means that we can include the set in a large interval [m,M].
    For optimization, there are a few essential quantities that are related to bounds:
    minimal and maximal elements, smallest upper bounds, and largest lower bounds.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with formalizing the concept of the smallest and largest elements
    within a set.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 48\. (Minimal and maximal elements)
  prefs: []
  type: TYPE_NORMAL
- en: Let A ⊆ℝ.
  prefs: []
  type: TYPE_NORMAL
- en: (a) m ∈ A is called the minimal element of A if for every a ∈ A, m ≤ a holds.
    The minimal element is denoted by m = minA.
  prefs: []
  type: TYPE_NORMAL
- en: (b) M ∈A is called the maximal element of A if for every a ∈A, a ≤M holds. The
    maximal element is denoted by M = maxA.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, let’s see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1\. The set A = [0,1] ∪ [2,3] has both minimal and maximal elements.
    Its minimal element is 0, and its maximal element is 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2\. The set A = {![1n](img/file1102.png) : n ∈ℕ} has no minimal element.
    0 is the largest lower bound, but since it is not in the set, it is not a minimal
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway is that minimal and maximal elements do not necessarily exist.
    To avoid the inconvenience, we need related quantities that always exist.
  prefs: []
  type: TYPE_NORMAL
- en: These will be the infimum and supremum.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 49\. (Infimum and supremum)
  prefs: []
  type: TYPE_NORMAL
- en: Let A ⊆ℝ.
  prefs: []
  type: TYPE_NORMAL
- en: (a) inf A ∈ℝ is the largest lower bound of A if m ≤ inf A holds for every lower
    bound m. This is called the infimum.
  prefs: []
  type: TYPE_NORMAL
- en: (b) supA ∈ℝ is the smallest upper bound of A if M ≥ supA holds for every upper
    bound M. This is called the supremum.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into great detail here, but the infimum and supremum always exist.
    However, it is essential to note that there is a sequence {a[n]}[n=1]^∞⊆A such
    that a[n] → inf A. (This is true for the supremum as well.)
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.5 Compact sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the concept of infimum and supremum, we can formalize the optimization
    problem for machine learning described by ([11.1](ch019.xhtml#bounded-sets)) as
  prefs: []
  type: TYPE_NORMAL
- en: '![inf {Loss(f (x, w),y) : w ∈ ℝn }, ](img/file1103.png)'
  prefs: []
  type: TYPE_IMG
- en: where this number represents the smallest possible value of the loss function
    and w is the parameter of our model.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a significant issue with the w ∈ℝ^n part. First, our parameter
    space is high-dimensional. In practice, n can be in the millions. Besides that,
    we are looking at an unbounded parameter space, where such an optimum might not
    even exist. Finally, is there even a parameter w where the infimum is attained?
    After all, this is what we are primarily interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can restrict the parameter space to a closed and bounded set to fix these
    issues. These sets are so prevalent that they have their own name: compact sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Definition 50\. (Compact sets)
  prefs: []
  type: TYPE_NORMAL
- en: The set A ⊆ℝ is compact if it is bounded and closed.
  prefs: []
  type: TYPE_NORMAL
- en: We love compact sets. Even though their definition seems straightforward, these
    two properties have profound consequences regarding optimization. At this point,
    we are not ready to talk about this in detail, but we can find minima or maxima
    in practice because continuous functions behave nicely on compact sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a key result about compact sets that will constantly resurface during
    our studies of functions: the Bolzano-Weierstrass theorem.'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 69\. (Bolzano-Weierstrass)
  prefs: []
  type: TYPE_NORMAL
- en: In a compact set, every sequence has a convergent subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. Let A ⊆ ℝ be a compact set, and {a[n]}[n=1]^∞ be an arbitrary sequence
    in A.
  prefs: []
  type: TYPE_NORMAL
- en: Because A is compact, there exists an interval I[1] := [m,M] that contains A
    in its entirety. By cutting this interval in half, we obtain [m,(m+M)∕2] and [(m+M)∕2,M].
    At least one of these will contain infinitely many points from {a[n]}; let that
    be I[2]. Repeating this process will yield a sequence of closed intervals I[1]
    ⊇I[2] ⊇I[3]…. The length of I[k] is (M −m)∕2^(k−1), so eventually these will get
    really small.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the construction of these intervals, we can also define a subsequence
    {a[n[k]]}[k=1]^∞ by selecting a[n[k]] such that a[n[k]] ∈I[k].
  prefs: []
  type: TYPE_NORMAL
- en: According to Cantor’s axiom (Theorem [67](ch019.xhtml#x1-185005r67)), ∩[k=1]^∞I[k]
    is nonempty, so let a ∈∩[k=1]^∞I[k]. Because both a[n[k]] and a are elements of
    I[k], we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ M − m |a − ank| ≤ --k−1--, k ∈ ℕ. 2 ](img/file1104.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows that lim[k→∞]a[n[k]] = a, which is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: The technique we used here is called lion catching. How does a mathematician
    catch a lion in the desert? By cutting the desert in half. The lion will be located
    in one half or the other. This section can be cut in half repeatedly until the
    area becomes smaller. Thus, the lion will be trapped there eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the topological structure of real numbers and the relation
    to convergent sequences, we can move forward and finally talk about the limit
    of functions!
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that in Section [10.2](ch018.xhtml#sequences) about sequences, we defined
    limits of convergent sequences. Intuitively, limits capture the notion that eventually,
    all elements get as close to the limit as we wish. This concept can be extended
    to functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 51\. (Limits of functions)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ be an arbitrary function. We say that'
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim f (x ) = a x→x0 ](img/file1105.png)'
  prefs: []
  type: TYPE_IMG
- en: if for every sequence x[n] →x[0], where x[n] does not equal x[0] for all n,
  prefs: []
  type: TYPE_NORMAL
- en: '![nl→im∞ f(xn) = a ](img/file1106.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: Right off the bat, there are two essential things to note.
  prefs: []
  type: TYPE_NORMAL
- en: The limit of a function is defined in terms of limits of sequences. If all possible
    sequences of the form {f(x[n])} with x[n] → x[0] have the same limit, then lim[x→x[0]]f(x)
    is defined as the common limit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With ∞-divergent sequences, limits at ±∞ are defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a figure that helps visualize the process.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1107.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Illustration of limits: as x[n] gets closer to 0, f(x[n]) gets
    closer to lim[n→∞]f(x[n])'
  prefs: []
  type: TYPE_NORMAL
- en: To further illustrate the concept of limits for functions, let’s see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1\. Define the function
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{1 if x = 0, f(x) = |(0 otherwise, ](img/file1108.png)'
  prefs: []
  type: TYPE_IMG
- en: illustrated by Figure [11.4](#). In other words, f(x) is 0 everywhere except
    at 0, where it is 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Plot of f(x)'
  prefs: []
  type: TYPE_NORMAL
- en: Does lim[x→0]f(x) exist? Yes. Because for any sequence x[n] → 0 that is not
    0, the limit lim[n→∞]f(x[n]) = 0\. On the other hand, note that lim[x→0]f(x)≠f(0).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2\. For our second example, define
  prefs: []
  type: TYPE_NORMAL
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(18).png)(11.2)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the (in)famous Dirichlet function, which is hard to imagine and impossible
    to plot: its value is 1 at rationals and 0 at irrationals. Not surprisingly, lim[x→x[0]]D(x)
    does not exist for all x[0], because rational and irrational numbers are “dense”:
    every number x[0] can be obtained as a limit of rationals and as a limit of irrationals.'
  prefs: []
  type: TYPE_NORMAL
- en: Since limits of functions are defined as the common limit of sequences, many
    of its properties are inherited from sequences. How sequences behave under operations
    (Theorem [57](ch018.xhtml#x1-167006r57)) determines how function limits behave.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 70\. (Operations and limits)
  prefs: []
  type: TYPE_NORMAL
- en: Let f and g be two functions.
  prefs: []
  type: TYPE_NORMAL
- en: (a)
  prefs: []
  type: TYPE_NORMAL
- en: '![xli→mx0 f(x)+ g(x) = xli→mx0 f(x)+ xli→mx0 g(x), ](img/file1111.png)'
  prefs: []
  type: TYPE_IMG
- en: (b)
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim cf(x) = c lim f(x) for all c ∈ ℝ, x→x0 x→x0 ](img/file1112.png)'
  prefs: []
  type: TYPE_IMG
- en: (c)
  prefs: []
  type: TYPE_NORMAL
- en: '![lim f(x)g(x) = lim f (x ) lim g(x), x→x0 x→x0 x→x0 ](img/file1113.png)'
  prefs: []
  type: TYPE_IMG
- en: (d) If f(x)≠0 in some small interval (x[0] − 𝜀,x[0] + 𝜀) around x[0] and lim[x→x[0]]f(x)≠0,
    then
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim -1---= -----1------. x→x0 f(x) limx →x0 f(x) ](img/file1114.png)'
  prefs: []
  type: TYPE_IMG
- en: Proof. This follows directly from Theorem [57](ch018.xhtml#x1-167006r57).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly as we have seen for convergent sequences, (a) and (b) above are referred
    to as the linearity of limits.
  prefs: []
  type: TYPE_NORMAL
- en: Remember how the big and small O notation (Definition [41](ch018.xhtml#x1-171003r41))
    expressed asymptotic properties of sequences? We have a similar tool for functions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 52\. (Big and small O notation for functions)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ and g : ℝ →ℝ be two arbitrary functions. We say that'
  prefs: []
  type: TYPE_NORMAL
- en: (a) g(x) = O(f(x)) as x → a if there is a constant C such that for some δ/span>0,
    we have jg(x)j ≤Cf(x) for all x ∈ (a −δ,a) ∪ (a,a + δ). Similarly, g(x) = O(f(x))
    as x →∞ if there is a constant C and a cutoff number N such that jg(x)j ≤Cf(x)
    holds for all x/span>N.
  prefs: []
  type: TYPE_NORMAL
- en: (b) g(x) = o(f(x)) as x →a if for any 𝜀/span>0, there is a δ/span>0 such that
    we have jg(x)j ≤𝜀f(x) for all x ∈ (a−δ,a) ∪ (a,a + δ). Similarly, g(x) = o(f(x))
    as x →∞ if for any 𝜀/span>0, there is a cutoff number N such that jg(x)j ≤𝜀f(x)
    for all x/span>N.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.1 Equivalent definitions of limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have a sharp eye (and some experience in mathematics), you might have
    already posed the question: won’t showing convergence of {f(x[n])} for all sequences
    x[n] →x[0] be difficult?'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, it is often not the most convenient way to think about function limits.
    Another equivalent definition expresses limits in terms of smaller and smaller
    neighborhoods around the point in question.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 71\. (Limits as error terms)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ be an arbitrary function and x[0] ∈ℝ. Then, the following are
    equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) lim[x→x[0]]f(x) = a.
  prefs: []
  type: TYPE_NORMAL
- en: (b) For every 𝜀/span>0, there exists a small neighborhood (x[0] −δ,x[0] + δ)
    around x[0] such that for every x ∈ (x[0] −δ,x[0]) ∪ (x[0],x[0] + δ),
  prefs: []
  type: TYPE_NORMAL
- en: '![|f (x )− a| <𝜀 ](img/file1115.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (a) ⇒ (b). We are going to do this indirectly, so we assume that (a)
    holds and (b) is not true. The negation of (b) states that there is a 𝜀 >0 such
    that for every δ >0, there is an x ∈ (x[0] −δ,x[0]) ∪ (x[0],x[0] + δ) such that
    |f(x) −a|𝜀. (If you don’t see why this is the negation, check out the Appendix
    A about logic.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we define a sequence that will contradict (a). If we select δ = 1∕n, we
    can let x[n] be the one in (x[0] −δ,x[0]) ∪ (x[0],x[0] + δ) such that |f(x[n])
    −a| 𝜀, as guaranteed by our assumption that (b) is false. Due to its construction,
    {f(x[n])}[n=1]^∞ does not converge to a. This contradicts (a), which completes
    our indirect proof.
  prefs: []
  type: TYPE_NORMAL
- en: (b) ⇒ (a). Let {x[n]}[n=1]^∞ be an arbitrary sequence that converges to x[0].
    If n is large enough (that is, larger than some cutoff index N), x[n] will fall
    into (x[0] −δ,x[0] + δ), where δ >0 is an arbitrary small constant. Since (b)
    says that |f(x[n]) −a| 𝜀 here for all such n, we have lim[n→∞]f(x[n]) = a by the
    definition of convergence (Definition [39](ch018.xhtml#x1-166003r39)).
  prefs: []
  type: TYPE_NORMAL
- en: In plain English, this theorem says that f(x) gets arbitrarily close to lim[x→x[0]]f(x)
    if x is close enough to x[0]. Definitions similar to (b) are called epsilon-delta
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: There is yet another equivalent definition that, although it might seem trivial,
    is a useful mental model when thinking about limits.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 72\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ be an arbitrary function and x[0] ∈ℝ. Then, the following are
    equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) lim[x→x[0]]f(x) = a.
  prefs: []
  type: TYPE_NORMAL
- en: (b) There exists a function error(x) such that lim[x→x[0]]error(x) = 0 and
  prefs: []
  type: TYPE_NORMAL
- en: '![f(x) = a+ error(x). ](img/file1118.png)'
  prefs: []
  type: TYPE_IMG
- en: Proof. (a) ⇒ (b). Due to how limits behave with respect to operations (Theorem [70](ch019.xhtml#x1-190011r70)),
    it is easy to see that
  prefs: []
  type: TYPE_NORMAL
- en: '![error(x) := f(x)− a ](img/file1120.png)'
  prefs: []
  type: TYPE_IMG
- en: satisfies the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '(b) ⇒ (a). Again, this is trivial because of the linearity of the limit operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![lim f (x ) = lim (a+ error(x )) = a. x→x0 x→x0 ](img/file1122.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we don’t need to know the exact limits of a function; it is enough to
    know that the limit is above or below a specific bound.
  prefs: []
  type: TYPE_NORMAL
- en: To give a specific example, we will look slightly ahead and talk about differentiation.
    I’ll explain everything in detail in the next chapter, but the derivative of a
    function f at the point x[0] is defined as the limit
  prefs: []
  type: TYPE_NORMAL
- en: '![ f (x )− f(x0) lx→imx0 ---x-−-x----. 0 ](img/file1123.png)'
  prefs: []
  type: TYPE_IMG
- en: If the function is increasing, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![f(x) − f(x ) ----------0- ≥ 0, x − x0 ](img/file1124.png)'
  prefs: []
  type: TYPE_IMG
- en: which, given the things we are about to see, implies that the derivative is
    positive.
  prefs: []
  type: TYPE_NORMAL
- en: Without any further ado, let’s see the result!
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 73\. (The transfer principle for functions)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ → ℝ be an arbitrary function. If f(x) ≥ α for all x ∈ (a −δ,a) ∪
    (a,a + δ) and some δ/span> constant and α ∈ℝ lower bound, then lim[x→a]f(x) ≥α
    if the limit exists.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. Due to the definition of function limits, this is the immediate consequence
    of the transfer principle for convergent sequences (Theorem [58](ch018.xhtml#x1-167010r58)).
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of special limits that come up all the time in calculations.
    These are the building blocks for calculating more complicated limits, as they
    can often be reduced to a form for which the limit is known.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t include the proofs here, as they are not that useful for our purposes
    (which is understanding how machine learning algorithms work).
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 74\. (a)
  prefs: []
  type: TYPE_NORMAL
- en: lim[*x*→0] sin x x = 1. (11.3)
  prefs: []
  type: TYPE_NORMAL
- en: (b)
  prefs: []
  type: TYPE_NORMAL
- en: lim[*x* → 0] *x* log *x* = 0. (11.4)
  prefs: []
  type: TYPE_NORMAL
- en: (c)
  prefs: []
  type: TYPE_NORMAL
- en: lim[*x* → ∞] *x*^k e^(−ax) = 0, a ∈ (0, ∞), k = 0, 1, 2, … (11.5)
  prefs: []
  type: TYPE_NORMAL
- en: With the extension of limits from sequences to functions, we saw that if the
    limit exists, it is not necessarily equal to the function’s value at the given
    point. However, when it does, the function is much easier to handle. This is called
    continuity, and this is what we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Continuity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If I asked you to conjure up a random function from your mind, I am almost certain
    that you would come up with one that is both continuous and differentiable. (unless
    you have weird tastes, as many mathematicians do).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the vast majority of functions are neither. In terms of cardinality,
    if you count all real functions f : ℝ→ℝ, it turns out that there are 2^c of them
    in total, but the subset of continuous ones have cardinality c. It is hard to
    imagine such quantities: c and 2^c are both infinite, but, well, 2^c is more infinite.
    Yeah, I know. Set theory is weird. (Recall that c denotes the cardinality of the
    set of real numbers. If you would like a refresher on the topic, check out the
    set theory appendix Appendix C.)'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, as we shall see, continuity and differentiability allow us to do meaningful
    work with functions. For instance, the usual gradient descent-based optimization
    for neural networks doesn’t work if the loss function and the layers are not differentiable.
    That alone would throw a huge wrench into the cogs of machine learning since this
    is used all the time in the deep learning part of the field.
  prefs: []
  type: TYPE_NORMAL
- en: This section explores how these concepts work together and ultimately enable
    us to train neural networks. So, let’s dive straight into the deep water and precisely
    define the notion of continuity!
  prefs: []
  type: TYPE_NORMAL
- en: Definition 53\. (Continuity)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ be an arbitrary function. We say that f is continuous at a if'
  prefs: []
  type: TYPE_NORMAL
- en: '![lxim→a f(x) = f (a ) ](img/file1127.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, continuity means that if x is close to y, then f(x) will also
    be close to f(y). This is how most of our mental models work. This is also what
    we want from many machine learning models. For example, if f is a model that takes
    images and decides if they feature a cat or not, we would expect that after changing
    a few pixels on x, the prediction would stay the same. (However, this is definitely
    not the case in general, which is exploited by certain adversarial attacks.)
  prefs: []
  type: TYPE_NORMAL
- en: We can rephrase the above definition by unpacking the limits. If you think it
    through a bit, it is easy to see that continuity of f at a is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim f(a ) = f ( lim a ) n→ ∞ n n→∞ n ](img/file1128.png)'
  prefs: []
  type: TYPE_IMG
- en: for all convergent sequences a[n] →a. In other words, the limit and function
    application are interchangeable. We are going to use this very frequently.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we’ll see some examples first. We’ll revisit the ones we saw Section [11.2](ch019.xhtml#limits).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1\. Let’s revisit
  prefs: []
  type: TYPE_NORMAL
- en: '![ (| {1 if x = 0, f(x) = | (0 otherwise. ](img/file1129.png)'
  prefs: []
  type: TYPE_IMG
- en: While f(x) is not continuous at 0 since lim[x→0]f(x) = 0≠f(0), as we have seen
    before, f(x) is continuous everywhere else (since it is constant 0).
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though the function is not continuous at 0, the limit does exist!
  prefs: []
  type: TYPE_NORMAL
- en: Example 2\. What about the Dirichlet function D(x)? (See ([11.2](#)) for the
    definition.) Since the limit doesn’t even exist, this is a nowhere near a continuous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3\. Define
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ f(x) = x if x ∈ ℚ, |( − x otherwise. ](img/file1130.png)'
  prefs: []
  type: TYPE_IMG
- en: Surprisingly, f(x) is continuous at 0, but nowhere else. As you can see, (almost)
    nothing is off the table with continuity. Functions, in general, can be wild objects,
    and without certain regularity conditions, optimizing them is extremely hard.
    In essence, this chapter aims to understand when and how we can optimize functions
    that we used to do when training a machine learning model.
  prefs: []
  type: TYPE_NORMAL
- en: One final example!
  prefs: []
  type: TYPE_NORMAL
- en: Example 4\. We call a function an elementary function if it can be obtained
    by taking a finite sum, product, and combination of
  prefs: []
  type: TYPE_NORMAL
- en: constant functions,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: power functions x,x²,x³,…,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n-th root functions x^(1∕2),x^(1∕3),x^(1∕4),…,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exponential functions a^x,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: logarithms log [a]x,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: trigonometric and inverse trigonometric functions sinx,cosx,arcsinx,arccosx,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hyperbolic and inverse hyperbolic functions sinhx,coshx,sinh^(−1)x,cosh^(−1)x.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '![ 2 x 1-−-3x-+√-5x4 f(x) = sin(x + e )− 2x − x ](img/file1131.png)'
  prefs: []
  type: TYPE_IMG
- en: is an elementary function. Elementary functions are continuous wherever they
    are defined. This is going to be extremely useful for us since showing the continuity
    of a complicated function like f(x) is hard with the definition alone. This way,
    if it is elementary, we know it is continuous. This will also be true for multivariate
    functions (like a neural network).
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1 Properties of continuous functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical pattern in mathematics, as you have seen when discussing the properties
    of convergent sequences in Theorem [57](ch018.xhtml#x1-167006r57), is to study
    certain properties on basic building blocks first, then show how it behaves with
    respect to operations.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to follow a similar pattern to the previous example regarding the
    continuity of elementary functions.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 75\.
  prefs: []
  type: TYPE_NORMAL
- en: Let f and g be two functions.
  prefs: []
  type: TYPE_NORMAL
- en: (a) If f and g are continuous at a, then f + g and fg are also continuous at
    a.
  prefs: []
  type: TYPE_NORMAL
- en: (b) If f and g are continuous at a and g(a)≠0, then f∕g is also continuous at
    a.
  prefs: []
  type: TYPE_NORMAL
- en: (c) If g is continuous at a and f is continuous at g(a), then f ∘g is also continuous
    at a.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (a) and (b) follow directly from the properties of limits (Theorem [70](ch019.xhtml#x1-190011r70)).
  prefs: []
  type: TYPE_NORMAL
- en: To see (c), we simply let {a[n]}[n=1]^∞ be a sequence that converges to a. Then,
    assuming that f is continuous at g(a) and g is continuous at a, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![lim f(g(an)) = f( lim g(an )) = f(g( lim an)) = f (g(a )), n→∞ n→ ∞ n→ ∞
    ](img/file1132.png)'
  prefs: []
  type: TYPE_IMG
- en: which shows the continuity of f ∘g at a.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only defined continuity at a single point. In general, a function
    f : ℝ →ℝ is continuous on the set A simply if it is continuous at its every point.'
  prefs: []
  type: TYPE_NORMAL
- en: We have arrived at the point that partly explains why we love continuous functions
    and compact sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is simple: functions that are continuous on compact sets are bounded
    there and attain their optima.'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 76\.
  prefs: []
  type: TYPE_NORMAL
- en: Let f be continuous on a compact set K. There exists α,β ∈K such that f(α) ≤f(x)
    ≤f(β) holds for all x ∈K.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let {α[n]}[n=1]^∞ ⊆ K be a sequence such that f(α[n]) → inf{f(x) : x ∈K}. (This
    is guaranteed to exist, as follows from the properties of infimum and supremum.)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, according to the Bolzano-Weierstrass theorem (Theorem [69](ch019.xhtml#x1-189006r69)),
    {α[n]}[n=1]^∞ has a convergent subsequence {α[n[k]]}[k=1]^∞ with lim[k→∞]α[n[k]]
    = α. Since K is compact, α ∈K. (Recall that a compact set is closed, and closed
    sets contain the limits of their convergent sequences, as Theorem [68](ch019.xhtml#x1-187002r68)
    implies.)
  prefs: []
  type: TYPE_NORMAL
- en: Because f is continuous, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![f(α) = f( lim αnk) = lim f(αnk) = inf{f (x) : x ∈ K }, k→ ∞ k→ ∞ ](img/file1133.png)'
  prefs: []
  type: TYPE_IMG
- en: which is what we had to show. An identical argument shows the existence of a
    β ∈K such that f(x) ≤f(β) for all x ∈K.
  prefs: []
  type: TYPE_NORMAL
- en: This statement is not true for sets that are not closed and bounded. For example,
    f(x) = ![1 x](img/file1134.png) is continuous on (0,1], but has no upper bound.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I admit, the fine details of topology, limits, and continuity can feel complex
    and abstract. However, in my experience, taking the hardest path is the most rewarding,
    especially when learning technical topics. To sum up, we’ve learned
  prefs: []
  type: TYPE_NORMAL
- en: what topology is,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what it has to do with sequences and limits,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to take limits of functions,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and finally, what a continuous function is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we are familiar with all the above, we are ready to tackle a subject
    at the heart of machine learning: differentiation. We’ll look at how to analyze
    functions and what makes a function “behave nicely.”'
  prefs: []
  type: TYPE_NORMAL
- en: If you think through what machine learning is really about, you’ll find that
    it is quite straightforward from a bird’s eye view. In essence, all we want to
    do is 1\. Design parameterized functions to explain the relationships between
    data and observations and 2\. Find the parameters that best fit our data.
  prefs: []
  type: TYPE_NORMAL
- en: To find models that are expressive enough yet easy to work with, we need to
    restrict ourselves to functions that satisfy certain properties. The two most
    important are continuity and differentiability. Now that we have seen what continuity
    is, we can move on to study differentiable functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will exclusively deal with univariate real functions.
    This is to introduce concepts without adding many layers of complexity at once.
    In later chapters, we will slowly turn toward multivariate functions, and by the
    time we get to machine learning, we will have mastered their use.
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem 1\. Which of the following subsets of ℝ are open, closed, or neither?
  prefs: []
  type: TYPE_NORMAL
- en: (a) ℤ (b) ℚ (c) ∩[n=1]^∞(−![n1](img/file1135.png),![1n](img/file1136.png)) (d)
    ∪[n=1]^∞[0,1 −![1 n](img/file1137.png)]
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2\. Let ![A ⊆ ℝ ](img/file1138.png) be an arbitrary set. Show that there
    exists a sequence ![{an} ∞n=1 ⊆ A ](img/file1139.png) such that
  prefs: []
  type: TYPE_NORMAL
- en: '![lnim→∞ an = sup A. ](img/file1140.png)'
  prefs: []
  type: TYPE_IMG
- en: (An identical statement is true for ![inf A ](img/file1141.png) as well, which
    can be shown in the same way.)
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3\. Let D(x) be the Dirichlet function, defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ D (x) = 1 if x ∈ ℚ, |( 0 otherwise. ](img/file1142.png)'
  prefs: []
  type: TYPE_IMG
- en: Give a mathematically rigorous proof that the limit lim[x→x[0]]D(x) does not
    exist for any x[0] ∈ℝ.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 4\. Let X be an arbitrary set, and let τ ⊆P(X) be a collection of its
    subsets. (Recall that P(A) denotes all subsets of A.) The structure (X,τ) is called
    a topological space, if
  prefs: []
  type: TYPE_NORMAL
- en: ∅∈τ and X ∈τ,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For any collection of sets in τ, the union is also in τ,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For any finite collection of sets in τ, the intersection is also in τ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sets in τ are called open sets. Show that the following are topological
    spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '(a) X is any set, τ = {∅,X}. (b) X is any set, τ = P(X). (c) (ℕ,τ), where τ
    = {S ⊆ℕ : 0![∕∈](img/file1143.png)τ}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 5\. Let f : ℝ →ℝ be an arbitrary function. Show that f is continuous
    at x[0] if and only if for every 𝜀/span>0 there exists a δ/span>0 such that for
    any x ∈ (x[0] −δ,x[0] + δ), jf(x) −f(x[0])j/span>𝜀.'
  prefs: []
  type: TYPE_NORMAL
- en: The above is an equivalent definition of continuity, called the epsilon-delta
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 6\. Let f : ℝ →ℝ be an arbitrary function. Show that f is continuous
    everywhere if and only if the set'
  prefs: []
  type: TYPE_NORMAL
- en: '![f(X ) = {f(x) : x ∈ X } ](img/file1144.png)'
  prefs: []
  type: TYPE_IMG
- en: is open for every open set X!
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
