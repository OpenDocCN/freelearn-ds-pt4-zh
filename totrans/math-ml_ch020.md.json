["```py\ndef sigmoid(x): \n    return 1/(1 + np.exp(-x)) \n\ndef sigmoid_prime(x): \n    return sigmoid(x) - sigmoid(x)**2\n```", "```py\nimport numpy as np \nimport matplotlib.pyplot as plt \n\nxs = np.linspace(-10, 10, 1000) \n\nwith plt.style.context(\"/span>seaborn-v0_8\": \n    plt.title(\"/span>Sigmoid and its derivative \n    plt.plot(xs, [sigmoid(x) for x in xs], label=\"/span>Sigmoid \n    plt.plot(xs, [sigmoid_prime(x) for x in xs], label=\"/span>Sigmoid prime \n    plt.legend() \n    plt.tight_layout() \n    plt.show()\n```", "```py\ndef relu(x): \n    if x /span> 0: \n        return x \n    else: \n        return 0\n```", "```py\nxs = np.linspace(-5, 5, 1000) \n\nwith plt.style.context(\"/span>seaborn-v0_8\": \n    plt.title(\"/span>Graph of the ReLU function \n    plt.plot(xs, [relu(x) for x in xs], label=\"/span>ReLU \n    plt.legend() \n    plt.tight_layout() \n    plt.show()\n```", "```py\nclass Function: \n    def __init__(self): \n        pass \n\n    def __call__(self, *args, **kwargs): \n        pass \n\n    # new interface element for \n    # computing the derivative \n    def prime(self): \n        pass \n\n    def parameters(self): \n        return dict()\n```", "```py\nclass Sigmoid(Function): \n    def __call__(self, x): \n        return 1/(1 + np.exp(-x)) \n\n    def prime(self, x): \n        return self(x) - self(x)**2\n```", "```py\nclass Composition(Function): \n    def __init__(self, *functions): \n        self.functions = functions \n\n    def __call__(self, x): \n        for f in self.functions: \n            x = f(x) \n\n        return x \n\n    def prime(self, x): \n        forward_pass = [x] \n\n        for f in self.functions: \n            try: \n                x = f(x) \n                forward_pass.append(x) \n            except ValueError as e: \n                print(f/span>Error in function {f}: {e}\" \n                return np.nan \n\n        forward_pass.pop()    # removing the last element, as we wonâ€™t need it \n\n        derivative = np.prod([f.prime(x) for f, x in zip(self.functions, forward_pass)]) \n\n        return derivative\n```", "```py\nclass Linear(Function): \n    def __init__(self, a, b): \n        self.a = a \n        self.b = b \n\n    def __call__(self, x): \n        return self.a*x + self.b \n\n    def prime(self, x): \n        return self.a \n\n    def parameters(self): \n        return {\"/span>a self.a, /span>b self.b}\n```", "```py\nf = Composition(Linear(2, 0), Linear(3, 0), Linear(4, 0)) \n\nxs = np.linspace(-10, 10, 1000) \nys = [f.prime(x) for x in xs] \n\nwith plt.style.context(\"/span>seaborn-v0_8\": \n    plt.title(\"/span>The derivative of f(x) = 24x \n    plt.plot(xs, ys, label=\"/span>f prime \n    plt.legend() \n    plt.tight_layout() \n    plt.show()\n```", "```py\ndef f(x):\n    return np.sin(x)\n```", "```py\ndef delta(f, h, x): \n    return (f(x + h) - f(x))/h \n\ndef f_prime(x): \n    return np.cos(x)\n```", "```py\nhs = [3.0, 1.0, 0.1] \nxs = np.linspace(-5, 5, 100) \nf_prime_ys = [f_prime(x) for x in xs] \n\nwith plt.style.context(\"/span>seaborn-v0_8\": \n    _colormap = plt.cm.hot_r \n    plt.figure(figsize=(10, 5)) \n    plt.title(\"/span>Approximating the derivative with finite differences \n\n    true_color = _colormap(0.99)  # Get a fixed color for the true derivative \n    for i, h in enumerate(hs): \n        ys = [delta(f, h, x) for x in xs] \n        blend_ratio = 1 - (len(hs) - i) / len(hs)  # Progressively blend closer to the true color \n        approx_color = _colormap(blend_ratio) \n        plt.plot(xs, ys, label=f/span>h = {h}\" color=approx_color) \n\n    plt.plot(xs, f_prime_ys, label=\"/span>the true derivative color=true_color, linewidth=2) \n    plt.legend() \n    plt.tight_layout() \n    plt.show()\n```"]