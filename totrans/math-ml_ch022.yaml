- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration
  prefs: []
  type: TYPE_NORMAL
- en: When we first encountered the concept of derivatives in Chapter [12](ch020.xhtml#differentiation),
    we introduced it through an example from physics. As Newton created it, the derivative
    describes the velocity of a moving object as calculated from its time-distance
    graph. In other words, the velocity can be derived from the time-distance information.
  prefs: []
  type: TYPE_NORMAL
- en: Can the distance be reconstructed given the velocity? In a sense, this is the
    inverse of differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions such as these are hard to answer if we only look at the most general
    case, so let’s consider a special one. Suppose that our object is moving with
    a constant velocity v(t) = v[0]![ms-](img/file1312.png), for a duration of T seconds.
    With some elementary logic, we can conclude that the total distance traveled is
    v[0]T meters.
  prefs: []
  type: TYPE_NORMAL
- en: When taking a look at the time-velocity plot, we can immediately see that the
    distance is the area under the time-velocity function graph v(t) = v[0].
  prefs: []
  type: TYPE_NORMAL
- en: The graph of v(t) describes a rectangle with width v[0] and length T, hence
    its area is indeed v[0]T.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1313.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Time-velocity plot of an object, moving with constant velocity'
  prefs: []
  type: TYPE_NORMAL
- en: Does the area under v(t) equal the distance traveled in the general case? For
    instance, what happens when the time-velocity plot looks something like this?
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1314.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Time-velocity plot of an object, moving with a changing velocity'
  prefs: []
  type: TYPE_NORMAL
- en: 'The speed is not constant here. In this case, we can do a simple trick: partition
    the time interval [0,T] into smaller ones and approximate the object’s motion
    as a constant-speed motion on each of these intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1315.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Approximating with a constant velocity motion'
  prefs: []
  type: TYPE_NORMAL
- en: If the time intervals [t[i],t[i+1]] are sufficiently granular, the distance
    traveled will roughly match a constant velocity motion with the average velocity
    at [t[i],t[i+1]]. That is, if we introduce the notation
  prefs: []
  type: TYPE_NORMAL
- en: '![vi := average velocity during the time interval [ti−1,ti], i = 1,2,...,n,](img/file1316.png)'
  prefs: []
  type: TYPE_IMG
- en: we should have
  prefs: []
  type: TYPE_NORMAL
- en: '![∑n vi(ti − ti−1) ≈ total distance traveled during [0,T]. i=1 ](img/file1317.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s think about this whole process as approximating the function v(t) with
    a stepwise constant function v[approx](t). From this angle, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ n ∑ vi(ti − ti−1) = area under vapprox(t), i=1 ](img/file1318.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![area under vapprox(t) ≈ area under v(t). ](img/file1319.png)'
  prefs: []
  type: TYPE_IMG
- en: (Very) loosely speaking, if the granularity of the time intervals [t[i],t[i+1]]
    gets infinitesimally small, the approximations turn into equality. Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![total distance traveled during [0,T ] = area under v(t) in [0,T ]. ](img/file1320.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two key points that we need to remember: if s(t) is the distance
    traveled and v(t) is the velocity, then'
  prefs: []
  type: TYPE_NORMAL
- en: v(t) is the derivative s^′(t),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and s(T) is the area under the graph v(t) between 0 and T.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, calculating the area under the curve is the same as inverting
    differentiation. This process is called integration.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, things are not as simple as they seem. We missed a lot of mathematical
    detail in the above discussion. For one, does the sum
  prefs: []
  type: TYPE_NORMAL
- en: '![∑n vi(ti − ti−1) i=1 ](img/file1321.png)'
  prefs: []
  type: TYPE_IMG
- en: converge if the partition of [0,T] gets more granular? Does the limit depend
    on the partitions? Can we even define the area under the “graph” for all functions?
    Like the Dirichlet function, defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(20).png)(14.1)'
  prefs: []
  type: TYPE_IMG
- en: How do we calculate limits of ∑ [i=1]^nv[i](t[i] −t[i−1]) in practice? In addition,
    what does all of this have to do with machine learning?
  prefs: []
  type: TYPE_NORMAL
- en: Fasten your seatbelts! Here comes the rigorous study of integration, clearing
    up all of these questions.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Integration in theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s build a solid theoretical foundation for the intuitive explanation! Let
    f : [a,b] →ℝ be an arbitrary bounded function, and our goal is to calculate the
    signed area under the graph. (Note that the signed area is negative if the graph
    goes below the x axis. In the time-speed graph example above, this is equivalent
    to moving backward, thus decreasing the distance traveled from the starting point.)'
  prefs: []
  type: TYPE_NORMAL
- en: Let a = x[0]/span>x[1]/span>…/span>x[n] = b an arbitrary partition of the interval
    [a,b].
  prefs: []
  type: TYPE_NORMAL
- en: For notational convenience, we’ll denote this partition as X = {x[0],…,x[n]}
    as well. The granularity (or mesh) of X is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![|X | := max |xi − xi−1|, i=1,...,n ](img/file1323.png)'
  prefs: []
  type: TYPE_IMG
- en: which is the length of the biggest gap in X. Note that the partition is not
    necessarily uniform, so jx[i] −x[i−1]j is not constant.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use an argument similar to the squeeze principle (Corollary [3](ch018.xhtml#x1-167012r3))
    to make the approximation idea rigorous. (You know, the one where we replaced
    the speed of a moving object with a piecewise constant one.) Instead of using
    the averages of f(x) on each interval [x[i−1],x[i]], we are going to provide an
    upper and lower estimation by using
  prefs: []
  type: TYPE_NORMAL
- en: '![mi := inf f (x ) x∈[xi−1,xi] ](img/file1324.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![Mi := sup f(x). x∈ [xi− 1,xi] ](img/file1325.png)'
  prefs: []
  type: TYPE_IMG
- en: Mathematically speaking, the infimum and the supremum are much easier to work
    with than the average. Now we can approximate f(x) with a piecewise constant function
    from both above and below. This is visualized by Figure [14.4](#).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1326.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Estimating the area under the curve of f using the partition X'
  prefs: []
  type: TYPE_NORMAL
- en: Our plan is to squeeze the area between the lower and upper sums
  prefs: []
  type: TYPE_NORMAL
- en: L[f, X] := ∑[i=1]^n m[i](x[i] − x[i−1]) (14.2)
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: U[f, X] := ∑[i=1]^n M[i](x[i] − x[i−1]), (14.3)
  prefs: []
  type: TYPE_NORMAL
- en: then study if these two match. (As usual, the dependence on f and X will be
    omitted if it is clear from the context.)
  prefs: []
  type: TYPE_NORMAL
- en: It is clear from the construction that
  prefs: []
  type: TYPE_NORMAL
- en: '![L[f,X ] ≤ area under the graph ≤ U [f,X ] ](img/file1327.png)'
  prefs: []
  type: TYPE_IMG
- en: holds for any partition X.
  prefs: []
  type: TYPE_NORMAL
- en: As the granularity of the partition X goes to zero, hopefully, both L[f,X] and
    U[f,X] will converge to the same number. Intuitively, this common limit should
    be the “area under the function graph,” but currently, our notion of the area
    is not general enough to make such bold statements. For instance, how would you
    define the “area” under the Dirichlet function, defined by ([14.1](#))? As we
    shall see soon, integration will generalize our heuristic notion of area. To get
    to that point, we have a lot to do. First, we’ll take a closer look at the partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1 Partitions and their refinements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to introduce some basic facts about refining partitions to construct
    mathematically correct arguments regarding the convergence of the approximating
    sums L[f,X] and U[f,X].
  prefs: []
  type: TYPE_NORMAL
- en: Definition 63\. (Refinement of partitions)
  prefs: []
  type: TYPE_NORMAL
- en: Let X = {x[0],…,x[n]} and Y = {y[0],…,y[m]} be two partitions of [a,b]. We say
    that Y is a refinement of X if X ⊆Y .
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize this easily.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1328.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The partition Y , as a refinement of X'
  prefs: []
  type: TYPE_NORMAL
- en: Refinements are vital for understanding why integration works. One of the core
    reasons is the following result.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 64\. Monotonicity of upper and lower sums
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : [a,b] →ℝ be a bounded function and X and Y be two partitions of [a,b].
    Suppose that Y is a refinement of X. Then'
  prefs: []
  type: TYPE_NORMAL
- en: L[f, X] ≤ L[f, Y] (14.4)
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: U[f, Y] ≤ U[f, X]. (14.5)
  prefs: []
  type: TYPE_NORMAL
- en: Proof. We are going to show L[f,X] ≤ L[f,Y ], as ([14.5](ch022.xhtml#x1-233006r64))
    follows from a similar argument. Suppose that x[i−1] ≤ y[j] ≤ ⋅⋅⋅ ≤ y[l] ≤ x[i].
    Mathematically speaking, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ inf f(x) ≤ inf f(x), k = j + 1,...,l. x∈[xi−1,xi] x∈[yk−1,yk] ](img/file1330.png)'
  prefs: []
  type: TYPE_IMG
- en: Since x[i] −x[i−1] = ∑ [k=j+1]^ly[k] −y[k−1], the above implies that
  prefs: []
  type: TYPE_NORMAL
- en: '![L(U,V ) = {f : U → V | f is linear}](img/file1331.png)(14.6)'
  prefs: []
  type: TYPE_IMG
- en: Don’t worry if these mathematical formalisms make this hard to follow. Just
    take a look at Figure [14.6](#) below, which summarizes all that we have done
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1332.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Refinement of lower sums'
  prefs: []
  type: TYPE_NORMAL
- en: Since L[f,X] and L[f,Y ] are composed from parts like in ([14.6](ch022.xhtml)),
    summing over i in the above immediately yields L[f,X] ≤L[f,Y ].
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost there. There is one thing left for us to show: that for any two
    partitions, the lower sum is always smaller than the upper sum. Hence, the squeeze
    principle (Corollary [3](ch018.xhtml#x1-167012r3)) could be applied to show that
    the lower and upper sums converge to the same limit in some instances.'
  prefs: []
  type: TYPE_NORMAL
- en: For that, we need a simple but fundamental fact about partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Let ![X ](img/file1333.png) and ![Y ](img/file1334.png) be two partitions of
    ![[a,b] ](img/file1335.png). Then there exists a partition ![Z ](img/file1336.png)
    that is a refinement of both ![X ](img/file1337.png) and ![Y ](img/file1338.png).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. It is easy to see that ![Z = X ∪Y ](img/file1339.png) satisfies our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The above Z is called a mutual refinement of X and Y . We can show a fundamental
    relation between the upper and lower sums with this idea.
  prefs: []
  type: TYPE_NORMAL
- en: Proposition 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : [a,b] → ℝ be a bounded real function and let X and Y be two partitions
    of the interval [a,b]. Then'
  prefs: []
  type: TYPE_NORMAL
- en: '![L [f,X ] ≤ U[f,Y ] ](img/file1340.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. Let Z be a mutual refinement of X and Y , as guaranteed by the previous
    result. Then, ([14.4](ch022.xhtml#x1-233006r64)) and ([14.5](ch022.xhtml#x1-233006r64))
    imply that
  prefs: []
  type: TYPE_NORMAL
- en: '![L[f,X ] ≤ L [f,Z ] ≤ U [f,Z ] ≤ U [f,Y], ](img/file1341.png)'
  prefs: []
  type: TYPE_IMG
- en: which is what we wanted to show.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.2 The Riemann integral
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s denote the set of all partitions on [a,b] by ℱ[a,b]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ℱ [a,b] = {X : X is a partition of [a,b]}. ](img/file1342.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to define the integral of the function as the single value
    that separates upper and lower sums.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 65\. (Riemann-integrability)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : [a,b] → ℝ be a bounded function. We say that f is Riemann-integrable
    (or just integrable) on [a,b] if'
  prefs: []
  type: TYPE_NORMAL
- en: '![X∈suℱp[a,b]L[f,X ] = X i∈nℱf[a,b]U [f,X ]. ](img/file1343.png)'
  prefs: []
  type: TYPE_IMG
- en: This value is called the Riemann integral (or just the integral) of f over [a,b],
    denoted by
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b f (x )dx. a ](img/file1344.png)'
  prefs: []
  type: TYPE_IMG
- en: The function f in ∫ [a]^bf(x)dx is called the integrand. How do we calculate
    the integral itself? The hard way is to define a sequence of partitions X[n] and
    show that
  prefs: []
  type: TYPE_NORMAL
- en: '![ lim L[f,Xn ] = lim U[f,Xn ], n→ ∞ n→ ∞ ](img/file1345.png)'
  prefs: []
  type: TYPE_IMG
- en: so this number is necessarily ∫ [a]^bf(x)dx. We’ll see the easy way soon, but
    let’s see an example demonstrating this process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s calculate ∫ [0]¹x²dx!
  prefs: []
  type: TYPE_NORMAL
- en: The simplest is to use the uniform partition X[n] = i∕n[i=0]^n, obtaining
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑n i − 1 21 L[x2,Xn ] = (-----) -- i=1 n n 1 ∑n = -3- (i− 1)2\. n i=1 ](img/file1346.png)'
  prefs: []
  type: TYPE_IMG
- en: Since ∑ [k=1]^nk² = ![n(n+1)6(2n+1)](img/file1347.png) (as it can be shown by
    induction), it is easy to see that
  prefs: []
  type: TYPE_NORMAL
- en: '![ 2 1 nli→m∞ L[x ,Xn ] = 3\. ](img/file1348.png)'
  prefs: []
  type: TYPE_IMG
- en: With a similar argument, you can check that lim[n→∞]U[x²,X[n]] = ![1 3](img/file1349.png)
    as well, thus, ∫ [0]¹x²dx exists and
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ 1 1 x2dx = -. 0 3 ](img/file1350.png)'
  prefs: []
  type: TYPE_IMG
- en: Although this method works for simple cases such as f(x) = x², it breaks down
    for more complex functions, as calculating limits of upper and lower sums can
    be difficult. In addition, selecting the right partition is also a challenge.
    For instance, can you calculate ∫ [0]^π sin(x)dx by the definition?
  prefs: []
  type: TYPE_NORMAL
- en: Because we are lazy (just like any good mathematician), we want to find a general
    method to calculate integrals. Lower and upper sums are needed to make the notion
    of an integral mathematically precise. Combined with the squeeze principle (Corollary [3](ch018.xhtml#x1-167012r3)),
    they are used to provide a definition.
  prefs: []
  type: TYPE_NORMAL
- en: However, other tools become available once we know that a function is integrable.
    Such as the general approximating sum, as we are about to see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem 91\. Let ![f : ℝ → ℝ ](img/file1351.png) be an arbitrary bounded function,
    and let ![Xn = {x0,n,...,xn,n} ](img/file1352.png) be a sequence of partitions
    on ![[a,b] ](img/file1353.png) such that ![|Xn | → 0 ](img/file1354.png). Then
    ![f ](img/file1355.png) is integrable if and only if the limit'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑n lim f(ξi)(xi,n − xi− 1,n) n→∞ i=1 ](img/file1356.png)'
  prefs: []
  type: TYPE_IMG
- en: exists and in this case,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑n ∫ b nl→im∞ f (ξi)(xi,n − xi−1,n) = f(x)dx i=1 a ](img/file1357.png)'
  prefs: []
  type: TYPE_IMG
- en: holds, where ξ[i] ∈ [x[i−1,n],x[i,n]].
  prefs: []
  type: TYPE_NORMAL
- en: (Note that jX[n]j → 0 means that the length of the largest subinterval of X[n]
    gets extremely small. In other words, the resolution of X[n] gets extremely large.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not prove the above theorem, as the proof is technical and doesn’t
    provide any valuable insight. However, the point is clear: local infima and suprema
    in lower and upper sums can be replaced with any local value.'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we’ll denote this sum by
  prefs: []
  type: TYPE_NORMAL
- en: S[f, X, \xi_X] = \sum_{i=1}^n f(\xi_i)(x_i - x_{i-1}) (14.7)
  prefs: []
  type: TYPE_NORMAL
- en: for any X = {x[0],…,x[n]} and ξ[X] = {ξ[1],…,ξ[n]} with ξ[i] ∈ [x[i−1],x[i]].
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.3 Integration as the inverse of differentiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we understand the mathematical definition of the integral, it is time
    to find some tools that enable its use in practice. The most important result
    is the Newton-Leibniz formula, named after Isaac Newton and Gottfried Wilhelm
    Leibniz, the inventors of calculus. (Fun fact: these men discovered calculus independently
    and were mortal enemies throughout their lives.)'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 92\. (The fundamental theorem of calculus, a.k.a. the Newton-Leibniz
    formula)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ a function that is integrable on [a,b] and suppose that there
    is an F : ℝ →ℝ such that F^′(x) = f(x). Then'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ₐᵇ f(x) dx = F(b) − F(a) (14.8)
  prefs: []
  type: TYPE_NORMAL
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, by defining x→F(a) + ∫ [a]^xf(x)dx, we can effectively reconstruct
    a function from its derivative.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. Let ![a = x0 <x1 <⋅⋅⋅ <xn = b ](img/file1359.png) be an arbitrary partition
    of ![[a,b] ](img/file1360.png). According to Lagrange’s mean value theorem (Theorem [89](ch021.xhtml#x1-215010r89)),
    there exists a ![ξi ∈ (xi−1,xi) ](img/file1361.png) for all ![i = 1,...,n ](img/file1362.png)
    such that
  prefs: []
  type: TYPE_NORMAL
- en: '![ ′ F(xi)− F (xi−1) = F (ξi)(xi − xi−1) = f (ξ )(x − x ). i i i−1 ](img/file1363.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, we can sum these numbers up, eliminating all but the first and last elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![∑n ∑n f(ξi)(xi − xi−1) = F(xi)− F (xi− 1) i=1 i=1 = F (b)− F (a ). ](img/file1364.png)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, due to the properties of lower and upper sums, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑n L[f,X ] ≤ f(ξ)(x − x ) ≤ U[f,X ] i=1 i i i−1 ](img/file1365.png)'
  prefs: []
  type: TYPE_IMG
- en: Since f is integrable, the squeeze principle (Corollary [3](ch018.xhtml#x1-167012r3))
    and Theorem [91](ch022.xhtml#x1-234006r91) imply that
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∑n f (x )dx = f(ξi)(xi − xi− 1) = F (b) − F(a) a i=1 ](img/file1366.png)'
  prefs: []
  type: TYPE_IMG
- en: must hold. This is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: Remark 10\. (Increments of functions)
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the increments of a function F on the interval [a,b] is also
    denoted by
  prefs: []
  type: TYPE_NORMAL
- en: '![ x=b [F(x)]x=a := F (b)− F (a ). ](img/file1367.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, according to the fundamental theorem of calculus (Theorem [92](ch022.xhtml#x1-235004r92)),
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b f(x)dx = [F (x)]x=x=ba a ](img/file1368.png)'
  prefs: []
  type: TYPE_IMG
- en: holds if F^′(x) = f(x).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that integration is insensitive towards changing the values of f(x) at
    countably many points. To be more precise, suppose that f : ℝ →ℝ is a function
    that is integrable on [ − 1,1]. Let’s change its value at a single point and define'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ f(0)+ 1 if x = 0 f∗(x) = |( f(x) otherwise. ](img/file1369.png)'
  prefs: []
  type: TYPE_IMG
- en: If a partition is given by −1 = x[0]/span>…/span>x[k−1] ≤ 0/span>x[k]/span>…/span>x[n]
    = 1, then
  prefs: []
  type: TYPE_NORMAL
- en: '![|L[f,X] − L[f∗,X ]| = | inf f (x)− inf f∗(x)|(xk − xk− 1) x∈[xk−1,xk] x∈[xk−1,xk]
    ◟------------=◝:◜m--------------◞ k ](img/file1370.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∗ ∗ |U [f,X] − U[f ,X ]| = |x∈s[xukp−1,xk]f(x)− x∈[sxuk−p1,xk]f (x )|(xk
    − xk −1) ◟-------------◝◜--------------◞ =:Mk ](img/file1371.png)'
  prefs: []
  type: TYPE_IMG
- en: holds. We can select the partition such that ![xk − xk−1 <𝜀 ](img/file1372.png)
    for some arbitrary ![𝜀 >0 ](img/file1373.png), thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![|L[f,X ]− L[f∗,X ]| and |U [f,X ]− U[f∗,X ]| ](img/file1374.png)'
  prefs: []
  type: TYPE_IMG
- en: can be made as small as needed. This implies that
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∫ b f(x)dx = f∗(x)dx. a a ](img/file1375.png)'
  prefs: []
  type: TYPE_IMG
- en: Hence, saying that integration is the inverse of differentiation is mathematically
    a bit imprecise. Given a differentiable function F(x), its derivative is unique,
    but there are infinitely many functions whose integral F(a) + ∫ [a]^xg(y)dy reconstructs
    F.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental theorem of calculus allows us to formulate Lagrange’s mean value
    theorem (Theorem [89](ch021.xhtml#x1-215010r89)) in terms of integrals.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 93\. (The mean value theorem for definite integrals)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : ℝ →ℝ a function that is continuous on [a,b]. Then there exists an ξ
    ∈ [a,b] such that'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b f(x)dx = (b− a)f(ξ). a ](img/file1376.png)'
  prefs: []
  type: TYPE_IMG
- en: Proof. According to the fundamental theorem of calculus (Theorem [92](ch022.xhtml#x1-235004r92)),
    the function
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ t F (t) = a f(x)dx ](img/file1377.png)'
  prefs: []
  type: TYPE_IMG
- en: is differentiable on [a,b] and F^′(t) = f(t).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, Lagrange’s mean value theorem (Theorem [89](ch021.xhtml#x1-215010r89))
    gives that
  prefs: []
  type: TYPE_NORMAL
- en: '![F-(b)−-F-(a-) b− a = f (ξ) ](img/file1378.png)'
  prefs: []
  type: TYPE_IMG
- en: for some ξ ∈ (a,b), from which
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b f(x)dx = F(b)− F (a) a = (b− a)f(ξ) ](img/file1379.png)'
  prefs: []
  type: TYPE_IMG
- en: follows. This is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all this theory, you might ask: what does integration have to do with
    machine learning? Without being mathematically rigorous, here is a (very) brief
    overview of what’s to come.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you can think about integration as a continuous generalization of the
    arithmetic mean. As you can see, for equidistant partitions, an approximating
    sum
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑n S[f,X,ξ] = 1- f(ξi) n i=1 ](img/file1380.png)'
  prefs: []
  type: TYPE_IMG
- en: 'is exactly the average of f(ξ[1]),…,f(ξ[n]). In machine learning, averages
    are frequently used to express various quantities, like the mean-squared error.
    Think about it: loss functions are often averages of certain individual losses.
    On a fine enough scale, averages become integrals.'
  prefs: []
  type: TYPE_NORMAL
- en: Along with linear algebra and calculus, the central pillar of machine learning
    is probability theory and statistics, which gives us a way to model the world
    based on our observations. Probability and statistics are the logic of science
    and decision-making. There, integration is used to express probabilities, expected
    value, information, and much more. Without a rigorous theory of integration, we
    cannot build probabilistic models beyond a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Integration in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though we understand what an integral is, we are far from computing them
    in practice. As opposed to differentiation, analytically evaluating integrals
    can be really difficult and sometimes downright impossible. The formula ([92](ch022.xhtml#x1-235004r92))
    suggests that the key is to find the function whose derivative is the integrand,
    called the antiderivative or primitive function. This is harder than you think.
    Nevertheless, there are several tools for this, and we are going to devote this
    section to studying the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the key is finding the antiderivative, so we introduce the notation
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ F(x) = f (x)dx, ](img/file1381.png)'
  prefs: []
  type: TYPE_IMG
- en: for the functions where F^′ = f. (Sometimes we abbreviate this to F = ∫ fdx.)
    Note that since (F + some constant)^′ = F^′, the antiderivative ∫ f(x)dx is not
    uniquely determined. However, this is not an issue for us, as the Newton-Leibniz
    formula states that
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b f (x )dx = F (b)− F (a). a ](img/file1382.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, any additional constants would be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: With this under our belt, we are ready to dig deep into evaluating integrals
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1 Integrals and operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen this several times (for instance, when discussing the rules
    of differentiation in Theorem [80](ch020.xhtml#x1-202002r80)), the relations of
    an operation with addition, multiplication, and possibly others are extremely
    useful for gaining insight and developing practical tools.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same for integration as well. Similar to before, the linearity of
    the integral is our main tool to evaluate it.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 94\. (Linearity of the Riemann integral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f,g : ℝ →ℝ be two functions that are integrable on [a,b]. Then'
  prefs: []
  type: TYPE_NORMAL
- en: (a) ∫ [a]^b(f(x) + g(x))dx = ∫ [a]^bf(x)dx + ∫ [a]^bg(x)dx,
  prefs: []
  type: TYPE_NORMAL
- en: (b) ∫ [a]^bcf(x)dx = c∫ [a]^bf(x)dx.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (a) If f and g are integrable, then for any 𝜀 >0, there are partitions
    X[f],X[g] such that
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ ∫ b b a f(x)dx− 𝜀 ≤ L [f,Xf ] ≤ U [f,Xf] ≤ a f(x)dx + 𝜀 ](img/file1385.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∫ b g(x)dx− 𝜀 ≤ L [g,Xg ] ≤ U [g,Xg ] ≤ g(x )dx + 𝜀, a a ](img/file1386.png)'
  prefs: []
  type: TYPE_IMG
- en: where the lower and upper sums are defined by ([14.2](#)) and ([14.3](#)). So,
    for the mutual refinement X = X[f] ∪X[g], we have
  prefs: []
  type: TYPE_NORMAL
- en: '![L[f,Xf ] ≤ L [f,X ], L [g,Xg ] ≤ L [g,X ], U[f,X ] ≤ U [f,Xf ], U[g,X ] ≤
    U [g,X ] g ](img/file1387.png)'
  prefs: []
  type: TYPE_IMG
- en: due to the Proposition [4](ch022.xhtml#x1-233014r4). Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ ∫ b b f(x)dx+ g(x)dx− 2𝜀 ≤ L [f,Xf ]+ L [g,Xg ] a a ≤ L [f,X ]+ L [g,X
    ] ≤ S [f,X, ξX]+ S[g,X,ξX ] ≤ U [f, X]+ U[g,X ] ≤ U [f, Xf]+ U [g,Xg] ∫ ∫ b b
    ≤ a f (x)dx+ a g(x )dx + 2𝜀, ](img/file1388.png)'
  prefs: []
  type: TYPE_IMG
- en: where S is defined by ([14.7](#)). From this definition, it can also be seen
    that
  prefs: []
  type: TYPE_NORMAL
- en: '![S[f + g,X, ξX ] = S[f,X, ξX]+ S [g,X, ξX]. ](img/file1389.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](img/file1390.png)'
  prefs: []
  type: TYPE_IMG
- en: implying that
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](img/file1391.png)'
  prefs: []
  type: TYPE_IMG
- en: Theorem [91](ch022.xhtml#x1-234006r91) regarding the approximating sum S implies
    that f + g is integrable on [a,b] and
  prefs: []
  type: TYPE_NORMAL
- en: '![ ](img/file1392.png)'
  prefs: []
  type: TYPE_IMG
- en: (b) This follows from the fact that S[cf,X,ξ[X]] = cS[f,X,ξ[X]].
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.2 Integration by parts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have learned when studying the rules of differentiation (Theorem [80](ch020.xhtml#x1-202002r80)),
    for an arbitrary f and g, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![(fg)′ = f ′g + fg′. ](img/file1393.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying this logic to the antiderivatives,
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ f g = (f ′g + fg′)dx ](img/file1394.png)'
  prefs: []
  type: TYPE_IMG
- en: 'holds. Rearranging the equation a bit, we obtain the formula of integration
    by parts:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫ f′g dx = fg − ∫ fg′ dx. 14.9
  prefs: []
  type: TYPE_NORMAL
- en: This is summed up in the following theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 95\. (Integration by parts)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f,g : ℝ →ℝ be two functions. If both are differentiable on the interval
    [a,b], then'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∫ b f′(x)g(x)dx = [f(x)g(x)]x=b − f(x)g′(x)dx a x=a a ](img/file1395.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: How is this useful for us? Consider a situation where finding the antiderivative
    of f and the derivative of g is easy, but the antiderivative of the product fg
    is hard. For example, can you quickly calculate the following?
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ x log xdx ](img/file1396.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying ([14.9](ch022.xhtml#integration-by-parts)) with the roles f^′(x) =
    x and g(x) = log x immediately yields
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ ∫ 1-2 1- x log x = 2x log x− 2xdx 1 1 = -x2log |x|− -x2 + C, 2 4 ](img/file1397.png)'
  prefs: []
  type: TYPE_IMG
- en: where C ∈ℝ is an arbitrary constant.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.3 Integration by substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the integration by parts formula is the “opposite” of the differentiation
    rule for products, there is an analogue for the chain formula as well. Recall
    that for two differentiable functions, we had
  prefs: []
  type: TYPE_NORMAL
- en: '![(f ∘ g)′(x) = f′(g(x ))g′(x). ](img/file1398.png)'
  prefs: []
  type: TYPE_IMG
- en: Translating this to the language of integrals, we obtain the following result.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 96\. (Integration by substitution)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f,g : ℝ → ℝ be integrable functions on [a,b]. Suppose that f is continuous
    and g is differentiable. Then'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∫ g(b) f(g(y))g′(y)dy = f(x)dx a g(a) ](img/file1399.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: This is called integration by substitution. To give you an example of its use,
    consider
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ 2 x sin(x )dx. ](img/file1400.png)'
  prefs: []
  type: TYPE_IMG
- en: With the roles y(x) = x², we have
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ 1∫ xsin(x2 )dx = -- sin ydy 2 = − 1-cosy + C 2 = − 1-cos(x2)+ C, 2 ](img/file1401.png)'
  prefs: []
  type: TYPE_IMG
- en: where C ∈ℝ is an arbitrary constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration by parts and substitution are our main weapons for calculating
    integrals on paper. Most of the integrals one might encounter can be solved with
    the creative (and possibly iterated) application of these two rules. The recipe
    is simple: find the antiderivative, then use the Newton-Leibniz formula (Theorem [92](ch022.xhtml#x1-235004r92))
    to compute the value of the integral.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a serious issue: antiderivatives can be extremely hard to
    find, maybe even impossible. This makes integrals difficult to compute symbolically.
    For instance, consider'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ −x2 e dx, ](img/file1402.png)'
  prefs: []
  type: TYPE_IMG
- en: where the function e^(−x²) describes the well-known Gaussian bell curve. As
    surprising as it is, ∫ e^(−x²) dx cannot be described with a closed formula! (That
    is, one that uses a finite number of operations and only elementary functions.)
    It’s not that mathematicians were not clever enough to find a closed formula for
    the antiderivative; this doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, computing integrals is much simpler to do numerically. This is in stark
    contrast with differentiation, which is easy to do symbolically but hard numerically.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.4 Numerical integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using symbolic computation to get the exact value of an integral,
    we will resolve to approximation once again. Previously, Theorem [91](ch022.xhtml#x1-234006r91)
    showed us that an integral is the limit of the Riemann-sums:'
  prefs: []
  type: TYPE_NORMAL
- en: ∫[a]^b f(x) dx = lim[n→∞] ∑[i=1]^n f(ξ[i]) (x[i,n] − x[i−1,n]), (14.10)
  prefs: []
  type: TYPE_NORMAL
- en: where X[n] = {x[0,n],…,x[n,n]} is a partition of [a,b] and ξ[i] ∈ [x[i−1,n],x[i,n]]
    are arbitrary intermediate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, if n is large enough, the sum ∑ [i=1]^nf(ξ[i])(x[i,n] −x[i−1,n])
    is close to ∫ [a]^bf(x)dx. There are two crucial issues: first, how to select
    the partition and the intermediate values; second, how fast is the convergence?'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to make ([14.11](ch022.xhtml#numerical-integration)) useful, we have
    to devise a concrete method that prescribes the x[i]-s, ξ[i]-s, and tells us how
    large of an n we should select. This is an extremely rich subject that has been
    the focus of studies ever since the introduction of integration. So, there is
    a lot to talk about here. To keep things simple, let’s just focus on the essentials.
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward method is to select a uniform partition, then approximate
    the area under the function curve with a sequence of trapezoids.
  prefs: []
  type: TYPE_NORMAL
- en: That is, let X = {a,a + ![b−a n](img/file1403.png),a + 2![b−a n](img/file1404.png),…,b}
    be an equidistant partition, which we’ll use to estimate the integral via calculating
    the areas determined by the trapezoids given by the partition and the graph, as
    illustrated in Figure [14.7](#).
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1405.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Approximating the area under a function with successive trapezoids'
  prefs: []
  type: TYPE_NORMAL
- en: As the trapezoid’s area is given by h![a+2b](img/file1406.png), the area under
    the curve in [x[i−1],x[i]] is approximated by
  prefs: []
  type: TYPE_NORMAL
- en: '![ f (xi) + f(xi− 1) b− a (xi − xi−1)------2-------= -2n-(f(xi)+ f (xi− 1))
    ](img/file1407.png)'
  prefs: []
  type: TYPE_IMG
- en: and we have the approximation
  prefs: []
  type: TYPE_NORMAL
- en: '![L(U,V ) = {f : U → V | f is linear}](img/file1408.png)(14.11)'
  prefs: []
  type: TYPE_IMG
- en: This is the trapezoidal rule. It might seem complicated, but ([14.11](ch022.xhtml))
    is just a weighted sum of the f(x[i]) values.
  prefs: []
  type: TYPE_NORMAL
- en: Its rate of convergence is quadratic, as stated by the following theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 97\. (Trapezoidal rule)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let f : [a,b] →ℝ be a twicely differentiable function, and let'
  prefs: []
  type: TYPE_NORMAL
- en: '![ n I := 1-∑ f(xi−-1)+-f(xi)- n n 2 i=1 ](img/file1409.png)'
  prefs: []
  type: TYPE_IMG
- en: be the approximation given by the trapezoidal rule. Then
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ b 3 | f (x )dx − In| = O((b-−-a)-). a n2 ](img/file1410.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are other methods, for instance, Simpson’s rule approximates the function
    with a piecewise quadratic one. (Instead of a piecewise linear one, like the trapezoidal
    rule.) Since the approximation is more accurate, the convergence is also faster:
    Simpson’s rule converges at a O(n^(−4)) rate. Without going into details, it is
    given by'
  prefs: []
  type: TYPE_NORMAL
- en: S[n] = ![b − a ----- 3n](img/file1411.png) ∑[i=1]^(⌊n/2⌋) ( f(x[2i−2]) + 4f(x[2i−1])
    + f(x[2i]) ), (14.12)
  prefs: []
  type: TYPE_NORMAL
- en: with error
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ b 5 | f(x)dx − S | = O((b-−-a)-), a n n4 ](img/file1414.png)'
  prefs: []
  type: TYPE_IMG
- en: where x[i] is again the equidistant partition x[i] = a + i![b−na](img/file1415.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula ([14.12](#)) can be difficult to unpack, but the essence remains
    the same: we compute the function’s values at given points, then take their weighted
    sum.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.5 Implementing the trapezoidal rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show you how straightforward the trapezoidal rule is, let’s implement it
    in practice! To keep it simple, we are implementing this as a function that takes
    another function as its input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This can be made even simpler with NumPy, but I’ll leave this to you as an exercise.
    Let’s test it on an example instead!
  prefs: []
  type: TYPE_NORMAL
- en: With the use of the Newton-Leibniz formula (Theorem [92](ch022.xhtml#x1-235004r92)),
    you can verify that
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ 1 x2dx = 1\. 0 3 ](img/file1416.png)'
  prefs: []
  type: TYPE_IMG
- en: (We even computed this with our bare hands, using lower and upper sums.) After
    plugging the function lambda x: x**2 into trapezoidal_rule, we can see that this
    method is indeed correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![PIC](img/file1417.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: The trapezoidal rule'
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have learned about integration, one of the technically most
    challenging subjects so far. Intuitively, the integral of a function describes
    the signed area under its graph, but mathematically, it is given by the limit
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∑n f(x)dx = lim (xi − xi− 1)f (xi), a n→∞ k=1 ](img/file1418.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where a = x[0]/span>x[1]/span>…/span>x[n] = b is a partition of the interval
    [a,b]. Of course, we don’t often calculate integrals by the definition; we have
    the Newton-Leibniz formula for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b f (x )dx = F (b)− F (a), a ](img/file1419.png)'
  prefs: []
  type: TYPE_IMG
- en: where F is the so-called antiderivative, satisfying F^′(x) = f(x). This is why
    integration is thought of as the inverse of differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As one of my professors used to say, symbolic differentiation is easy, numeric
    differentiation is hard. It’s the opposite for integrals: symbolic integration
    is hard, and numeric integration is easy. We’ve learned a couple of tricks to
    pin down the symbolic part, namely the integration by parts formula'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ ∫ b ′ x=b b ′ a f(x)g(x)dx = [f(x)g(x)]x=a − a f(x)g (x)dx ](img/file1420.png)'
  prefs: []
  type: TYPE_IMG
- en: and the integration by substitution formula
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∫ g(b) f(g(y))g′(y)dy = f(x)dx. a g(a) ](img/file1421.png)'
  prefs: []
  type: TYPE_IMG
- en: When symbolic integration is hard (and it’s almost always hard), we can resort
    to numerical methods, such as the Simpson’s rule, given by
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b b − a⌊n∑∕2⌋ f(x)dx ∼ ----- (f(x2i−2) + 4f(x2i− i) + f(x2i)). a 3n i=1
    ](img/file1422.png)'
  prefs: []
  type: TYPE_IMG
- en: Although integration is quite technical and complicated, its proper exposition
    is extremely important if you want to understand mathematics. The idea of approximating
    complex shapes with a sequence of rectangles (as shown in Figure [14.3](#)) is
    the foundation of measure theory, which, in turn, is the foundation of probability
    theory. (Hell, the idea of approximating complex objects with simpler ones is
    the foundation of mathematics.)
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, we have mastered differentiation and integration for single-variable
    functions. However, univariate functions are rare in practice: in machine learning,
    we often deal with millions or billions of variables. To handle them in practice,
    we’ll generalize all we’ve learned to higher dimensions. This is the subject of
    multivariable calculus, our next big milestone. Let’s get to it!'
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem 1\. Use integration by parts to find the following antiderivates.
  prefs: []
  type: TYPE_NORMAL
- en: (a) ∫ sin(x)cos(x)dx (b) ∫ xe^xdx (c) ∫ x²e^xdx (d) ∫ e^x sinxdx
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2\. Use integration by substitution to find the following antiderivatives.
  prefs: []
  type: TYPE_NORMAL
- en: (a) ∫ xcos(x²)dx (b) ∫ sin(x)e^({-x)2}dx (c) ∫ ![sinx cosx-](img/file1423.png)
    (d) ∫ x![√x2-+-1](img/file1424.png)dx
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3\. Let f : [a,b] →ℝ be an integrable function. Show that'
  prefs: []
  type: TYPE_NORMAL
- en: '![∫ b ∫ b | f(x)dx| ≤ |f(x)|dx. a a ](img/file1425.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Problem 4\. Let f,g : [a,b] →ℝ be two integrable functions such that jfj² and
    jgj² are integrable as well. Show that'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∫ ∫ ∫ b 2 b 2 b 2 | a f(x)g(x)dx| ≤ a |f(x)| dx a |g(x)| dx. ](img/file1426.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hint: revisit Chapter 2 about normed spaces, and find an inequality that feels
    similar to this one.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 5\. The famous Dirichlet function is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ 1 if x ∈ ℚ, D (x) = |( 0 otherwise. ](img/file1427.png)'
  prefs: []
  type: TYPE_IMG
- en: Is D(x) integrable?
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
