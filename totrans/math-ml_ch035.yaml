- en: Appendix A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s Just Logic
  prefs: []
  type: TYPE_NORMAL
- en: The rules of logic are to mathematics what those of structure are to architecture.
    — Bertrand Russell
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Mathematics is a language,” one of my professors used to say all the time.
    “Learning mathematics starts with building up a basic vocabulary.”
  prefs: []
  type: TYPE_NORMAL
- en: 'What he forgot to add is that mathematics is the language of thinking. I often
    get asked the question: do you need to know mathematics to be a software engineer/data
    scientist/random technical professional? My answer is simple. If you regularly
    have to solve problems in your profession, then mathematics is extremely beneficial
    to you. You don’t have to think effectively, but you are better off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The learning curve of mathematics is steep. You have experienced it yourself,
    and the difficulty may have deterred you from reaching a familiarity with its
    fundamentals. I have good news: if we treat learning mathematics as learning a
    foreign language, we can start by building up a basic vocabulary instead of diving
    straight into poems and novels. As my professor suggested.'
  prefs: []
  type: TYPE_NORMAL
- en: A.1 Mathematical logic 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logic and clear thinking lie at the very foundations of mathematics. But what
    are those? How would you explain what “logic” is?
  prefs: []
  type: TYPE_NORMAL
- en: Our thinking processes are formalized by the field of mathematical logic. In
    logic, we work with propositions, that is, statements that are either true or
    false. “It is raining outside.” “The sidewalk is wet.” These are both valid propositions.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to reason about propositions effectively, we often denote them with
    roman capital letters, such as
  prefs: []
  type: TYPE_NORMAL
- en: '![A = ”It is raining outside.” B = ”The sidewalk is wet.” ](img/file2083.png)'
  prefs: []
  type: TYPE_IMG
- en: Each proposition has a corresponding truth value, which is either true or false.
    These are often abbreviated as 1 and 0\. Although this seems like no big deal,
    finding the truth value can be extremely hard. Think about the proposition
  prefs: []
  type: TYPE_NORMAL
- en: '![A = “If the solutions of an algorithm can be verified in polynomial time,
    it can also be solved in polynomial time.” ](img/file2084.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the famous P = NP conjecture, one of the longest-standing unsolved problems
    in mathematics. The statement is easy to understand, but solving the problem (that
    is, finding the truth value of the corresponding proposition) has eluded even
    the smartest minds.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the entire body of our scientific knowledge lies in propositions
    whose truth values we have identified. So, how do we do that in practice?
  prefs: []
  type: TYPE_NORMAL
- en: A.2 Logical connectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In themselves, propositions are not enough to provide an effective framework
    for reasoning. Mathematics (and the entirety of modern science) is the collection
    of complex propositions formulated from smaller building blocks with logical connectives.
    Each connective takes one or more propositions and transforms their truth value.
  prefs: []
  type: TYPE_NORMAL
- en: '“If it is raining outside, then the sidewalk is wet.” This is the combination
    of two propositions, strung together by the implication connective. There are
    four essential connectives: negation, disjunction, conjunction, and implication.
    We will take a close look at each one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Negation flips the truth value of a proposition to its opposite. It is denoted
    by the mathematical symbol ¬: if A is a proposition, then ¬A is its negation.
    Connectives are defined by truth tables that enumerate all the possible truth
    values of the resulting expression, given its inputs. In writing, this looks complicated,
    so here is the truth table of ¬ to illustrate the concept.'
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | |A |¬A | |--|----| |0 | 1 | |1 | 0 | | | | | ](img/file2085.png)'
  prefs: []
  type: TYPE_IMG
- en: When expressing propositions in a natural language, negation translates to the
    word “not.” For instance, the negation of the proposition “the screen is black”
    is “the screen is not black.” (Not “the screen is white.”)
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical conjunction is equivalent to grammatical conjunction “and”, denoted
    by the symbol ∧. The proposition A ∧B is true if and only if both A and B are
    true. For example, when we say that “the table is set and the food is ready,”
    we mean to convey that both conjuncts are true. Here is the truth table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | |A-|B--|A-∧-B-| |0 | 0 | 0 | | | | | |0 | 1 | 0 | | | | | |1 | 0
    | 0 | |1 | 1 | 1 | | | ](img/file2086.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Disjunction is known as “or” in the English language and is denoted by the
    symbol ∨. The proposition A ∨B is true whenever either one is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | |A-|B--|A-∨-B-| | | | | |0 | 0 | 0 | |0 | 1 | 1 | | | | | |1 | 0
    | 1 | |1 | 1 | 1 | | | | | ](img/file2087.png)'
  prefs: []
  type: TYPE_IMG
- en: Disjunction is inclusive, unlike the exclusive or we frequently use in our natural
    language. When you say “I am traveling by train or car,” both cannot be true.
    The disjunction connective is not exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the implication connective (→) formalizes the deduction of a conclusion
    B from a premise A: “if A, then B.”'
  prefs: []
  type: TYPE_NORMAL
- en: The implication is false only when the premise is true and the conclusion is
    false; otherwise, it is true.
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | |A |B |A → B | |---|--|--------| | 0 |0 | 1 | | 0 |1 | 1 | | | |
    | | 1 |0 | 0 | | 1 |1 | 1 | | | | | ](img/file2088.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One example would be the famous quote from Descartes: “I think, therefore I
    am.” Translated to the language of formal logic, this is simply'
  prefs: []
  type: TYPE_NORMAL
- en: '![”I think” → ”I exist”. ](img/file2089.png)'
  prefs: []
  type: TYPE_IMG
- en: Sentences of the form “if A, then B” are called conditionals. It’s not all just
    philosophy. Science is the collection of propositions such as “if X is a closed
    system, then the entropy of X cannot decrease.” (As the 2nd law of thermodynamics
    states.)
  prefs: []
  type: TYPE_NORMAL
- en: Most of our scientific knowledge is made of A →B propositions, and scientific
    research is equivalent to pursuing the truth value of implications. When solving
    problems in practice, we rely on theorems (that is, implications) that turn our
    premises into conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: A.3 The propositional calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you got the feeling that the connectives are akin to arithmetic operations,
    you are correct. Connectives yield propositions. Thus connectives can again be
    applied, resulting in complex expressions such as ¬(A ∨B) ∧C. Constructing such
    expressions and deductive arguments is called the propositional calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Just like arithmetic operations, expressions made up of propositions and connectives
    also have identities. Think about the famous algebraic identity
  prefs: []
  type: TYPE_NORMAL
- en: '![(a+ b)(a − b) = a2 − b2, ](img/file2090.png)'
  prefs: []
  type: TYPE_IMG
- en: which is one of the most frequently used symbolic expressions. Such an identity
    means we can write one thing in another form.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical logic, we call these logical equivalences.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 102\. (Logical equivalences)
  prefs: []
  type: TYPE_NORMAL
- en: The propositions P and Q are logically equivalent if they always have the same
    truth value.
  prefs: []
  type: TYPE_NORMAL
- en: If P and Q are logically equivalent, we write
  prefs: []
  type: TYPE_NORMAL
- en: P ≡ Q.
  prefs: []
  type: TYPE_NORMAL
- en: To show you an example, let’s look at our first theorem, one that establishes
    logical equivalences for the conjunction connective.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 140\. (Properties of conjunction)
  prefs: []
  type: TYPE_NORMAL
- en: Let A, B, and C be arbitrary propositions. Then,
  prefs: []
  type: TYPE_NORMAL
- en: (a) (A ∧B) ∧C ≡A ∧ (B ∧C) (associativity)
  prefs: []
  type: TYPE_NORMAL
- en: (b) A ∧B ≡B ∧A (commutativity)
  prefs: []
  type: TYPE_NORMAL
- en: (c) A ∨ (B ∧C) ≡ (A ∨B) ∧ (A ∨C) (distributivity)
  prefs: []
  type: TYPE_NORMAL
- en: (d) A ∧A ≡A (idempotence)
  prefs: []
  type: TYPE_NORMAL
- en: Proof. Showing these properties is done by drawing up their truth tables. We
    will do this for (a), while the rest is left for you as an exercise. (I highly
    suggest you do this, as performing a task by yourself is an excellent learning
    opportunity.)
  prefs: []
  type: TYPE_NORMAL
- en: For the associativity property, the sizable truth table
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | | | | | |A--|B-|C--|A-∧-B-|B--∧C--|(A-∧-B)-∧-C-|A-∧-(B-∧-C)-| |0
    |0 | 0 | 0 | 0 | 0 | 0 | | | | | | | | | |0 |0 | 1 | 0 | 0 | 0 | 0 | |0 |1 | 0
    | 0 | 0 | 0 | 0 | | | | | | | | | |0 |1 | 1 | 0 | 1 | 0 | 0 | |1 |0 | 0 | 0 |
    0 | 0 | 0 | | | | | | | | | |1 |0 | 1 | 0 | 0 | 0 | 0 | |1 |1 | 0 | 1 | 0 | 0
    | 0 | | | | | | | | | |1 |1 | 1 | 1 | 1 | 1 | 1 | | | ](img/file2092.png)'
  prefs: []
  type: TYPE_IMG
- en: provides a proof.
  prefs: []
  type: TYPE_NORMAL
- en: A few remarks are in order. First, we should read the truth table from left
    to right columns. Strictly speaking, we can omit the columns for A∧B and B ∧C.
    However, including them saves the mental gymnastics.
  prefs: []
  type: TYPE_NORMAL
- en: Second, because of the associativity, we can freely write A ∧B ∧C, as the order
    of operations is irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that our first theorem is a premise and a conclusion, connected
    by the implication connective. If we denote them by
  prefs: []
  type: TYPE_NORMAL
- en: '![P = “A, B, C are propositions,” Q = “ (A ∧ B )∧ C ≡ A ∧ (B ∧ C ).” ](img/file2093.png)'
  prefs: []
  type: TYPE_IMG
- en: then the first part of our theorem is just the proposition P →Q, one that we
    have proven to be true via laying out the truth table. This shows the immense
    power of the propositional calculus we are building here.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem [140](ch035.xhtml#x1-358004r140) has an analogue for disjunction. This
    is stated below for the sake of completeness, but the proof is left to you as
    an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 141\. (Properties of disjunction)
  prefs: []
  type: TYPE_NORMAL
- en: Let A, B, and C be arbitrary propositions. Then,
  prefs: []
  type: TYPE_NORMAL
- en: (a) (A ∨B) ∨C ≡A ∨ (B ∨C) (associativity)
  prefs: []
  type: TYPE_NORMAL
- en: (b) A ∨B ≡B ∨A (commutativity)
  prefs: []
  type: TYPE_NORMAL
- en: (c) A ∧ (B ∨C) ≡ (A ∧B) ∨ (A ∧C) (distributivity)
  prefs: []
  type: TYPE_NORMAL
- en: (d) A ∨A ≡A (idempotence)
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with arithmetic operations, connectives have order of precedence as
    well: ¬,∧,∨,→. This means that, for instance, (¬A) ∧B) ∨C can be written as ¬A
    ∧ (B ∨C).'
  prefs: []
  type: TYPE_NORMAL
- en: In our calculus of propositions, one of the most important rules is De Morgan’s
    laws, describing how conjunction and disjunction behave with respect to negation.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 142\. (De Morgan’s laws)
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be two arbitrary propositions. Then,
  prefs: []
  type: TYPE_NORMAL
- en: (a) ¬(A ∧B) ≡¬A ∨¬B
  prefs: []
  type: TYPE_NORMAL
- en: (b) ¬(A ∨B) ≡¬A ∧¬B
  prefs: []
  type: TYPE_NORMAL
- en: hold.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. As usual, we can prove De Morgan’s laws by laying out the two truth tables
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | | | | | |A |B | ¬A |¬B | A ∧B |¬(A ∧ B ) |¬A ∨ ¬B | |---|--|----|----|-------|----------|---------|
    | 0 |0 | 1 | 1 | 0 | 1 | 1 | | 0 |1 | 1 | 0 | 0 | 1 | 1 | | | | | | | | | | 1
    |0 | 0 | 1 | 0 | 1 | 1 | | 1 |1 | 0 | 0 | 1 | 0 | 0 | | | | | ](img/file2094.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | | | | | |A--|B-|-¬A-|¬B--|-A-∨B--|¬(A-∨-B-)-|¬A-∧-¬B--| | 0 |0 |
    1 | 1 | 0 | 1 | 1 | | | | | | | | | | 0 |1 | 1 | 0 | 1 | 0 | 0 | | 1 |0 | 0 |
    1 | 1 | 0 | 0 | | | | | | | | | | 1 |1 | 0 | 0 | 1 | 0 | 0 | | | ](img/file2095.png)'
  prefs: []
  type: TYPE_IMG
- en: that verify our claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'The propositional calculus we have established so far is the mathematical formalization
    of thinking. One thing is missing, though: deduction, or as Wikipedia puts it,
    “the mental process of drawing inferences in which the truth of their premises
    ensures the truth of their conclusion.” This is given via the famous rule of modus
    ponens.'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 143\. (Modus ponens)
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be two propositions. If A and A →B are true, then B is true as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. Let’s take a look at the truth table of → once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | |A--|B-|A--→-B--| | 0 |0 | 1 | | | | | | 0 |1 | 1 | | 1 |0 | 0 |
    | | | | | 1 |1 | 1 | | | ](img/file2096.png)'
  prefs: []
  type: TYPE_IMG
- en: By looking at its rows, we can see that when A is true and the implication A
    →B is true, B is true as well, as the principle of modus ponens indicates.
  prefs: []
  type: TYPE_NORMAL
- en: As modus ponens sounds extremely abstract, here is a concrete example. From
    common sense, we know that the implication “if it’s raining, then the sidewalk
    is wet” is true. If we observe from a roof window that it’s indeed raining, we
    can confidently conclude that the sidewalk is wet, even without looking at it.
  prefs: []
  type: TYPE_NORMAL
- en: In symbolic notation, we can write
  prefs: []
  type: TYPE_NORMAL
- en: A → B, A ⊢ B,
  prefs: []
  type: TYPE_NORMAL
- en: where the turnstile symbol ⊢ essentially reads as “proves.” Thus, the modus
    ponens says that A →B and A prove B.
  prefs: []
  type: TYPE_NORMAL
- en: Modus ponens is how we use our theorems. It is always in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Remark 22\. (Reversing the implication)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a great opportunity to point out one of the most frequent logical fallacies:
    reversing the implication. When debating about a given topic, participants often
    resort to the faulty argument'
  prefs: []
  type: TYPE_NORMAL
- en: A → B, B ⊢ A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this is not true. For instance, consider our favorite example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A = ”it’s raining outside,” B = ”the sidewalk is wet.” ](img/file2099.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, A →B holds, but B →A does not. There are other reasons for a wet sidewalk.
    For instance, someone accidentally spilled a barrel of water on it.
  prefs: []
  type: TYPE_NORMAL
- en: A.4 Variables and predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, mathematics is about propositions, implications, and their truth values.
    We have seen that we can formulate propositions and reason about pretty complicated
    expressions using our propositional calculus. However, the language we have built
    up so far is not suitable for propositions with variables.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, think about the sentence
  prefs: []
  type: TYPE_NORMAL
- en: '![x is a non- negative real number. ](img/file2100.png)'
  prefs: []
  type: TYPE_IMG
- en: Because the truth value depends on x, this is not a well-formed proposition.
  prefs: []
  type: TYPE_NORMAL
- en: Sentences with variables are called predicates, and we denote them by emphasizing
    the dependence on their variables; for instance,
  prefs: []
  type: TYPE_NORMAL
- en: 'P (x) : x ≥ 0,'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '![Q (x, y) : x + y is an even number. ](img/file2102.png)'
  prefs: []
  type: TYPE_IMG
- en: Each predicate has a domain from which its variables can be taken. You can think
    about a predicate P(x) as a function that maps its domain to the set {0,1}, representing
    its truth value. (Although, strictly speaking, we don’t have functions available
    as tools when defining the very foundation of our formal language. However, we
    are not philosophers or set theorists, so we don’t have to be concerned about
    such details.)
  prefs: []
  type: TYPE_NORMAL
- en: Predicates define truth sets, that is, subsets of the domain where the predicate
    is true. Formally, they are denoted by
  prefs: []
  type: TYPE_NORMAL
- en: '{*x* ∈ *D* : *P*(*x*)}, (A.1)'
  prefs: []
  type: TYPE_NORMAL
- en: where P(x) is a predicate with domain D.
  prefs: []
  type: TYPE_NORMAL
- en: Translated to English, ([A.1](ch035.xhtml#variables-and-predicates)) reads as
    “all elements x of D for which P(x) is true.”
  prefs: []
  type: TYPE_NORMAL
- en: Although we haven’t talked about sets before, truth sets probably seem familiar
    if you have a computer science background. For instance, if you have ever used
    the Python programming language, you have probably seen expressions like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: all the time. These are called comprehensions, and they are inspired by the
    so-called set-builder notation given by ([A.1](ch035.xhtml#variables-and-predicates)).
  prefs: []
  type: TYPE_NORMAL
- en: A.5 Existential and universal quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Predicates are a big step toward properly formalizing mathematical thinking,
    but we are not quite there yet. To give you an example from machine learning,
    let’s talk about finding the minima of loss functions (that is, training a model).
  prefs: []
  type: TYPE_NORMAL
- en: A point x is said to be the global minimum of a function f(x) if, for all other
    y in its domain D, f(x) ≤f(y) holds. For instance, the point x = 0 is a minima
    of the function f(x) = x².
  prefs: []
  type: TYPE_NORMAL
- en: How would you express this in our formal language? For one, we could say that
  prefs: []
  type: TYPE_NORMAL
- en: '![for all y ∈ D,f (x ) ≤ f(y) is true, ](img/file2103.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where we fix f(x) = x² and x = 0\. There are two parts of this sentence: for
    all y ∈D, and f(x) ≤f(y) is true. The second one is a predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![P (y) : f (x) ≤ f (y), ](img/file2104.png)'
  prefs: []
  type: TYPE_IMG
- en: where y ∈ℝ.
  prefs: []
  type: TYPE_NORMAL
- en: The second part seems new, as we have never seen the words “for all” in our
    formal language before. They express a kind of quantification about when the predicate
    P(y) is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematical logic, there are two quantifiers we need to be happy: the universal
    quantifier “for all” denoted by the symbol ∀, and the existential quantifier “there
    exists” denoted by ∃.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the sentence “all of my friends are mathematicians.” By
    defining the set F to be set of my friends and the predicate on this domain as
  prefs: []
  type: TYPE_NORMAL
- en: '![M (x) : x is a mathematician, ](img/file2105.png)'
  prefs: []
  type: TYPE_IMG
- en: we can formalize our sentence as
  prefs: []
  type: TYPE_NORMAL
- en: '![∀x ∈ F,M (x). ](img/file2106.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that the domain of the predicate M(x) is F. We could omit that, but
    it’s much more user-friendly this way.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, “I have at least one friend who is a mathematician” translates to
  prefs: []
  type: TYPE_NORMAL
- en: '![∃x ∈ F,M (x). ](img/file2107.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When there is a more complex proposition behind the quantifier, we mark its
    scope with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![∀x ∈ F,(A (x) → (B(x) ∧C (x))). ](img/file2108.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that as (∀x ∈F,M(x)) and (∃x ∈F,M(x)) have a single truth value, they are
    propositions, not predicates! Thus, quantifiers turn predicates into propositions.
    Just like any other propositions, logical connectives can be applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among all the operations, negation is the most interesting here. To see why,
    let’s consider the previous example: “all of my friends are mathematicians.” At
    first, you might say that its negation is “none of my friends are mathematicians,”
    but that is not correct. Think about it: I can have mathematician friends, as
    long as not all of them are mathematicians. Thus,'
  prefs: []
  type: TYPE_NORMAL
- en: '![¬(”all of my friends are mathematicians”) ≡ ”I have at least one non-mathematician
    friend.” ](img/file2109.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words (or should I say symbols), we have
  prefs: []
  type: TYPE_NORMAL
- en: '![¬(∀x ∈ F,M (x )) ≡ ∃x ∈ F,¬M (x). ](img/file2110.png)'
  prefs: []
  type: TYPE_IMG
- en: That is, roughly speaking, the negation of ∀ is ∃ and the negation of ∃ is ∀.
  prefs: []
  type: TYPE_NORMAL
- en: A.6 Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem 1\. Using truth tables, show that
  prefs: []
  type: TYPE_NORMAL
- en: (a) A ∨¬A is true,
  prefs: []
  type: TYPE_NORMAL
- en: (b) and A ∧¬A is false.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, A ∨¬A is a tautology, while A ∧¬A is a contradiction. (We call
    expressions that are always true tautologies, while expressions that are always
    false are contradictions.)
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2\. Define the exclusive or operation XOR, denoted by ⊕, by the truth
    table
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | |A-|B--|A-⊕-B--| |0 |0 | 0 | | | | | |0 |1 | 1 | | | | | |1 |0 |
    1 | |1 |1 | 0 | | | | | ](img/file2111.png)'
  prefs: []
  type: TYPE_IMG
- en: Show that
  prefs: []
  type: TYPE_NORMAL
- en: (a) A ⊕B ≡ (¬A ∧B) ∨ (A ∧¬B)
  prefs: []
  type: TYPE_NORMAL
- en: (b) and A ⊕B ≡ (¬A ∨¬B) ∧ (A ∨B)
  prefs: []
  type: TYPE_NORMAL
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
