- en: Appendix B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Structure of Mathematics
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve come a long way from the start: we’ve studied propositions, logical connectives,
    predicates, quantifiers, and all the formal logic. This was to be able to talk
    about mathematics. However, ultimately, we want to do mathematics.'
  prefs: []
  type: TYPE_NORMAL
- en: As the only exact science, mathematics is built on top of definitions, theorems,
    and proofs. We precisely define objects, formulate conjectures about them, then
    prove those with mathematically correct arguments. You can think of mathematics
    as a colossal building made of propositions, implications, and modus ponens. If
    one theorem fails, all others that build upon it fail too.
  prefs: []
  type: TYPE_NORMAL
- en: In other fields of science, the modus operandi is to hypothesize, experiment,
    and validate. However, experiments are not enough in mathematics. For instance,
    think about the famous Fermat numbers, that is, numbers of the form F[n] := 2^(2^n)
    + 1\. Fermat conjectured them all to be prime numbers, as F[0], F[1], F[2], F[3],
    and F[4] are primes.
  prefs: []
  type: TYPE_NORMAL
- en: Five affirmative “experiments” might have been enough to accept the hypothesis
    as true in certain fields of science. Not in mathematics. In 1732, Euler showed
    that F[5] = 4,294,967,297 is not a prime, as 4,294,967,297 = 641 × 6,700,417\.
    (Imagine calculating that in the 18th century, long before the age of computing.)
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve seen some definitions, theorems, and even proofs when talking
    about mathematical logic. It’s time to put them under the magnification glass
    and see what they are!
  prefs: []
  type: TYPE_NORMAL
- en: B.1 What is a definition?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ambiguity is the drawback of natural languages. How would you define, say, the
    concept of “hot”? Upon several attempts, you would soon discover that no two people
    have the same definition.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, there is no room for ambiguity. Every object and every property
    must be precisely defined. It’s best to look at a good example instead of philosophizing
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 103\. (Divisors)
  prefs: []
  type: TYPE_NORMAL
- en: Let b ∈ℤ be an integer. We say that a ∈ℤ is a divisor of b if there exists an
    integer k ∈ℤ such that b = ka.
  prefs: []
  type: TYPE_NORMAL
- en: The property “a is a divisor of b” is denoted by a∣b.
  prefs: []
  type: TYPE_NORMAL
- en: For example, 2∣10 and 5∣10, but 7 ∤ 10\. (Crossed symbols mean the negation
    of the said property.)
  prefs: []
  type: TYPE_NORMAL
- en: In terms of our formal language, the definition of “a is a divisor of b” can
    be written as
  prefs: []
  type: TYPE_NORMAL
- en: '*a* ∣ *b* : ∃ *k* ∈ ℤ, *b* = *k**a*. (B.1)'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t let the a∣b notation deceive you; this is a predicate in disguise. We
    could have denoted a∣b by
  prefs: []
  type: TYPE_NORMAL
- en: '![divisor(a,b) : ∃k ∈ ℤ, b = ka. ](img/file2112.png)'
  prefs: []
  type: TYPE_IMG
- en: Although every mathematical definition can be formalized, we’ll prefer our natural
    language because it is much easier to understand. (At least for humans. Not so
    much for computers.)
  prefs: []
  type: TYPE_NORMAL
- en: Like building blocks, definitions build on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: (If you have a sharp eye for details, you noticed that even Definition [103](ch036.xhtml#x1-364003r103)
    is built upon other concepts such as numbers, multiplication, and equality. We
    haven’t defined them precisely, just assumed they are there. Since our goal is
    not to rebuild mathematics from scratch, we’ll let this one slide.)
  prefs: []
  type: TYPE_NORMAL
- en: Again, it’s best to see an example here. Let’s see what even and odd numbers
    are!
  prefs: []
  type: TYPE_NORMAL
- en: Definition 104\. (Even and odd numbers)
  prefs: []
  type: TYPE_NORMAL
- en: Let n ∈ℤ be an integer. We say that n is even if 2∣n.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, we say that n is odd if 2 ∤ n. (The notation a ∤ b is the negation
    of the “a is a divisor of b” predicate.)
  prefs: []
  type: TYPE_NORMAL
- en: One more time, with our formal language. For an integer n ∈ℤ, the predicates
  prefs: []
  type: TYPE_NORMAL
- en: '![even(n) : 2 | n ](img/file2113.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![odd (n ) : 2 ∤ n ](img/file2114.png)'
  prefs: []
  type: TYPE_IMG
- en: express the same as Definition [104](ch036.xhtml#x1-364005r104).
  prefs: []
  type: TYPE_NORMAL
- en: These examples are not that exciting, so let’s see something more interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Definition 105\. (Prime numbers)
  prefs: []
  type: TYPE_NORMAL
- en: Let p ∈ℕ be a positive integer. We say that p is a prime number if
  prefs: []
  type: TYPE_NORMAL
- en: (a) p/span>1,
  prefs: []
  type: TYPE_NORMAL
- en: (b) and if a∣p, then a = 1 or a = p.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, primes have no integer divisors other than themselves. The first
    few primes are 2,3,5,7,11,13,17, and many more. Non-prime integers are called
    composite numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file2115.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure B.1: Definition of primality in predicate logic, decomposed into its
    parts'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of primality can be written as
  prefs: []
  type: TYPE_NORMAL
- en: 'P (p) : (p >1)∧ (∀a ∈ ℤ,(a | p → ((a = 1) ∨ (a = p)))).'
  prefs: []
  type: TYPE_NORMAL
- en: This might look complicated, but we can decompose it into parts, as shown by
    Figure [B.1](#).
  prefs: []
  type: TYPE_NORMAL
- en: Primes play an essential role in our everyday lives! For instance, many mainstream
    cryptographic methods use large primes to cipher and decipher messages. Without
    them, you wouldn’t be able to initiate financial transactions securely.
  prefs: []
  type: TYPE_NORMAL
- en: Their usefulness is guaranteed by their various properties, established in the
    form of theorems. We’ll see a few of them soon enough, but first, let’s talk about
    what theorems really are.
  prefs: []
  type: TYPE_NORMAL
- en: B.2 What is a theorem?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, a definition is essentially a predicate whose truth set consists of our
    objects of interest. The whole point of mathematics is to find true propositions
    involving those objects, most often in the form A →B. Consider the following theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 144\. (Existence of global minima for convex functions)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let ![f : [0,1] → ℝ ](img/file2117.png) be a function. If ![f ](img/file2118.png)
    is continuous, then there exists an ![x∗ ](img/file2119.png) such that ![f ](img/file2120.png)
    assumes its minimum at ![x∗ ](img/file2121.png) on ![[0,1] ](img/file2122.png).'
  prefs: []
  type: TYPE_NORMAL
- en: (That is, for all ![x ∈ [0,1] ](img/file2123.png), we have ![f(x∗) ≤ f(x) ](img/file2124.png).)
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you are unfamiliar with the concepts of continuity and minimum;
    it’s beside the point. The gist is that Theorem [144](ch036.xhtml#x1-365002r144)
    can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '![∀f ∈ F,(C (f ) → M (f)), ](img/file2125.png)'
  prefs: []
  type: TYPE_IMG
- en: where F denotes the set of all functions [0,1] →ℝ, and the predicates C(f) and
    M(f) are defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![ C (f ) : f is continuous on [0,1], ∗ ∗ M (f ) : ∃x ,∀x ∈ [0,1],f (x ) ≤
    f(x). ](img/file2126.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the structure of the theorem: “Let x ∈A. If B(x), then C(x).” With the
    first sentence, we are setting the domains of the predicates A(x) and B(x), and
    putting a universal quantifier in front of the conditional “if B(x), then C(x).”'
  prefs: []
  type: TYPE_NORMAL
- en: B.3 What is a proof?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand what theorems are, it’s time to look at proofs. We have
    just seen that theorems are true propositions. Proofs are deductions that establish
    the truth of a proposition. Let’s see an example instead of talking like a philosopher!
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof of Theorem [144](ch036.xhtml#x1-365002r144) is not within our reach
    yet, so let’s look at something much simpler: the sum of even numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 145\. (The sum of even numbers)
  prefs: []
  type: TYPE_NORMAL
- en: Let n,m ∈ℤ be two integers. If n and m are even, then n + m is even.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. Since n is even, 2∣n. According to Definition [103](ch036.xhtml#x1-364003r103),
    this means that there exists an integer k ∈ℤ such that n = 2k.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as m is also even, there exists an integer l ∈ ℤ such that m = 2l.
    Summing up the two, we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![n + m = 2k + 2l = 2(k + l), ](img/file2127.png)'
  prefs: []
  type: TYPE_IMG
- en: giving that n + m is indeed even.
  prefs: []
  type: TYPE_NORMAL
- en: If you read the above proof carefully, you might notice that it is a chain of
    implications and modus ponens. These two form the backbone of our deductive skills.
    What is proven is set in stone.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what proofs are is one of the biggest skill gaps in mathematics.
    Don’t worry if you don’t get it immediately; this is a deep concept. You’ll get
    used to proofs eventually.
  prefs: []
  type: TYPE_NORMAL
- en: B.4 Equivalences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The building blocks of mathematics are propositions of the form A →B; at least,
    this is what I emphasized throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: I was not precise. The proposition A →B translates to “if A, then B,” but sometimes,
    we know much more. Quite frequently, A and B have the same truth values. In natural
    language, we express this by saying “A if and only if B.” (Although this is much
    rarer than the simple conditional.)
  prefs: []
  type: TYPE_NORMAL
- en: In logic, we express this relation with the biconditional connective ↔︎, defined
    by
  prefs: []
  type: TYPE_NORMAL
- en: '![A ↔ B ≡ (A → B) ∧ (B → A ). ](img/file2128.png)'
  prefs: []
  type: TYPE_IMG
- en: Theorems of the “if and only if” type are called equivalences, and they play
    an essential role in mathematics. When proving an equivalence, we must show both
    A →B and B →A.
  prefs: []
  type: TYPE_NORMAL
- en: To see an example, let’s go back to elementary geometry. As you probably learned
    in high school, we can describe geometric objects on the plane with vectors that
    are represented by a tuple of two real numbers. This way, geometric properties
    can be translated into analytic ones, and we can often prove hard theorems by
    simple calculations.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let’s talk about orthogonality, one of the most important concepts
    in mathematics. Here is how orthogonality is defined for two planar vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 106\. (Orthogonality)
  prefs: []
  type: TYPE_NORMAL
- en: Let a and b be two nonzero vectors on the plane. We say that a and b are orthogonal
    if their enclosed angle is π∕2.
  prefs: []
  type: TYPE_NORMAL
- en: Orthogonality is denoted by the ⊥ symbol; that is, a ⊥b means that a and b are
    orthogonal.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we always assume that the enclosed angle is between
    0 and π. (An angle of π radians is 180 degrees, but we’ll always use radians.)
  prefs: []
  type: TYPE_NORMAL
- en: However, measuring the angle enclosed by two arbitrary vectors is not as easy
    as it sounds. We need a tractable formula, and this is where the dot product comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 107\. (Dot product of planar vectors)
  prefs: []
  type: TYPE_NORMAL
- en: Let a = (a[1],a[2]) and b = (b[1],b[2]) be two vectors on the plane. Their dot
    product a ⋅b is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![a ⋅b := |a||b|cosα, ](img/file2129.png)'
  prefs: []
  type: TYPE_IMG
- en: where α is the angle enclosed by the two vectors, and |⋅| denotes the magnitude
    of a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Dot products give an equivalent definition of orthogonality in the form of an
    “if and only if” theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 146\.
  prefs: []
  type: TYPE_NORMAL
- en: Let a = (a[1],a[2]) and b = (b[1],b[2]) be two nonzero vectors in the plane.
    Then, a and b are orthogonal if and only if a ⋅b = 0.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the proof of this equivalence!
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. We have to prove two implications:'
  prefs: []
  type: TYPE_NORMAL
- en: (a) a ⊥b ⇒a ⋅b = 0,
  prefs: []
  type: TYPE_NORMAL
- en: (b) a ⋅b = 0 ⇒a ⊥b.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with (a). If a ⊥ b, then their enclosed angle α equals to π∕2\.
    Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![ π- a⋅b = |a||b |cos2 = |a||b |0 = 0, ](img/file2132.png)'
  prefs: []
  type: TYPE_IMG
- en: which is what we needed to show.
  prefs: []
  type: TYPE_NORMAL
- en: To prove (b), we have to notice that since a and b are nonzero, their magnitudes
    jaj, jbj are also nonzero. Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![a ⋅b = |a ||b|cosα = 0 ](img/file2133.png)'
  prefs: []
  type: TYPE_IMG
- en: can only hold if cosα = 0\. In turn, this means that α = π∕2; that is, a ⊥b.
    (Recall that we assumed the enclosed angle α to be between 0 and π.)
  prefs: []
  type: TYPE_NORMAL
- en: So, we know all about what theorems and proofs are. But how do we find proofs
    in practice? Let’s see the essential techniques.
  prefs: []
  type: TYPE_NORMAL
- en: B.5 Proof techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no way around it: proving theorems is hard. Some took the smartest
    of minds decades, and some conjectures remain unresolved after a century. (That
    is, they are not proven nor disproven.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few basic yet powerful tools can get one push through the difficulties. In
    the following, we’ll look at the three most important ones: proof by induction,
    proof by contradiction, and the principle of contraposition.'
  prefs: []
  type: TYPE_NORMAL
- en: B.5.1 Proof by induction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you climb a set of stairs? Simple. You climb the first step, then climb
    the next one, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You might be surprised, but this is something we frequently use in mathematics
    all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illuminate this by an example.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 147\. (Sum of natural numbers)
  prefs: []
  type: TYPE_NORMAL
- en: Let n ∈ℕ be an arbitrary integer. Then,
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 2 + ⋯ + *n* = *n*(*n* + 1) 2 (B.2)
  prefs: []
  type: TYPE_NORMAL
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. For ![n = 1 ](img/file2136.png), the case is clear: the left-hand side
    of ([B.2](ch036.xhtml#x1-369002r147)) evaluates to 1, while the right-hand side
    is'
  prefs: []
  type: TYPE_NORMAL
- en: '![1(1-+-1) 2 = 1\. ](img/file2138.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, our proposition holds for n = 1, which is called the base case.
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the magic, that is, the induction step. Let’s assume that ([B.2](ch036.xhtml#x1-369002r147))
    holds for a given n; that is, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![1+ 2 + ⋅⋅⋅+ n = n(n-+-1). 2 ](img/file2139.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what’s called the induction hypothesis. Using this assumption, we are
    going to prove that ([B.2](ch036.xhtml#x1-369002r147)) holds for n+1 as well.
    In other words, our goal is to show that
  prefs: []
  type: TYPE_NORMAL
- en: '![ (n-+-1)(n-+-2) 1+ 2 + ⋅⋅⋅+ n+ (n + 1) = 2 . ](img/file2140.png)'
  prefs: []
  type: TYPE_IMG
- en: Due to our induction hypothesis, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![ [ ] 1 + 2+ ⋅⋅⋅+ n + (n + 1) = 1+ 2 + ⋅⋅⋅+ n + (n + 1) n(n + 1) = --------+
    (n + 1). 2 ](img/file2141.png)'
  prefs: []
  type: TYPE_IMG
- en: Continuing the calculation, we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![n(n + 1) n(n + 1) 2(n+ 1) --------+ (n + 1) = --------+ -------- 2 2 2 =
    n(n-+-1)+-2(n-+-1) 2 = (n-+-1)(n-+-2), 2 ](img/file2142.png)'
  prefs: []
  type: TYPE_IMG
- en: which is what we had to show.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up what happened, let’s denote the equation ([B.2](ch036.xhtml#x1-369002r147))
    by the predicate
  prefs: []
  type: TYPE_NORMAL
- en: '![S(n) : 1+ 2 + ⋅⋅⋅+ n = n(n-+-1). 2 ](img/file2143.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Proof by induction consists of two main steps. First, we establish that the
    base case S(1) is true. Then, we show that for arbitrary n, the implication S(n)
    →S(n + 1) holds. Starting from the induction step, this implies that S(n) is indeed
    true for all n: the chain of implications'
  prefs: []
  type: TYPE_NORMAL
- en: '![S (1) → S (2), S (2) → S (3), S (3) → S (4), ... ](img/file2144.png)'
  prefs: []
  type: TYPE_IMG
- en: combined with S(1) and the almighty modus ponens (Theorem [143](ch035.xhtml#x1-358009r143))
    yields the truth of S(n). We took the first step S(1), then proved that we can
    take the next step from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Induction is not simple to grasp, so here is another example. (It is slightly
    more complex than the previous one.) Follow through with the proof and see if
    you can identify the marks of induction.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 148\. (The fundamental theorem of number theory)
  prefs: []
  type: TYPE_NORMAL
- en: Let n ∈ℤ be an integer and suppose that n/span>1\. Then, n can be uniquely represented
    as the product of prime numbers; that is, there exists prime numbers p[1],p[2],…,p[l]
    and exponents k[1],k[2],…,k[l]/span>1 such that
  prefs: []
  type: TYPE_NORMAL
- en: '*n* = *p*[1]^(*k*[1]) *p*[2]^(*k*[2]) ⋯ *p*[*l*]^(*k*[*l*]). (B.3)'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this representation is unique.
  prefs: []
  type: TYPE_NORMAL
- en: For example, 24 = 2³3, and 24 cannot be written as a different product of primes.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of natural language masks it, but in essence, Theorem [148](ch036.xhtml#x1-369007r148)
    can be translated to the sentence
  prefs: []
  type: TYPE_NORMAL
- en: '![ [ k1 k2 kl ] ∀n ∈ ℤ (n >1) → (∃p1,...,pl,k1,...,kl ∈ ℤ,(∀i,pi is a prime
    )∧(n = p1 p2 ...pl )) . ](img/file2145.png)'
  prefs: []
  type: TYPE_IMG
- en: For simplicity, we’ll only prove the existence of the prime factorization, not
    the unicity.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (Existence.) For n = 2, the theorem is trivially true, as 2 is a prime
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let n/span>2 and suppose that ([B.3](ch036.xhtml#x1-369007r148)) is true
    for all integers m that are smaller or equal to n. (This is our induction hypothesis.)
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to show that ([B.3](ch036.xhtml#x1-369007r148)) also holds for n
    + 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two possibilities: either n + 1 is a prime or a composite number.
    If it is a prime, we are done, as n + 1 is by itself in the form ([B.3](ch036.xhtml#x1-369007r148)).
    Otherwise, if n + 1 is a composite number, we can find a divisor that is not 1
    or n + 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![n + 1 = ab ](img/file2146.png)'
  prefs: []
  type: TYPE_IMG
- en: for some a,b ∈ ℤ. Since a,b ≤ n, we can apply the induction hypothesis! Spelling
    it out, it means that we can write them as
  prefs: []
  type: TYPE_NORMAL
- en: '![a = pα1...pαl, 1 l b = qβ11...qβmm, ](img/file2147.png)'
  prefs: []
  type: TYPE_IMG
- en: where the p[i],q[i] are the primes and the α[i],β[i] are the exponents. Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '![n + 1 = ab α α β = p11...pll q11 ...qβmm , ](img/file2148.png)'
  prefs: []
  type: TYPE_IMG
- en: which is just ([B.3](ch036.xhtml#x1-369007r148)), with a bit more symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Induction is like a power tool in mathematics. It is extremely powerful, and
    when it is applicable, it’ll almost always do the job.
  prefs: []
  type: TYPE_NORMAL
- en: B.5.2 Proof by contradiction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it is easier to prove theorems by assuming that their conclusion
    is false, then deduce a contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it’s best to see a quick example. Let’s revisit our good old friends,
    the prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 149\.
  prefs: []
  type: TYPE_NORMAL
- en: There are infinitely many prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. Assume that there are finitely many prime numbers: p[1],p[2],…,p[n].'
  prefs: []
  type: TYPE_NORMAL
- en: Is the integer p[1]p[2]…p[n] + 1 a prime? If p[1],p[2],…,p[n] are all of the
    prime numbers, it is enough to check if
  prefs: []
  type: TYPE_NORMAL
- en: '![pi ∤ p1p2...pn + 1\. ](img/file2149.png)'
  prefs: []
  type: TYPE_IMG
- en: This holds indeed, as by definition, p[1]p[2]…p[n] + 1 = p[i]k + 1, where k
    is simply the product of the prime numbers other than p[i].
  prefs: []
  type: TYPE_NORMAL
- en: Since no p[i] is a divisor of p[1]p[2]…p[n] + 1, it must be a prime. We have
    found a new prime that is not on our list! This means that our assumption (that
    there are finitely many prime numbers) has led to a contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, there must be infinitely many prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a sharp eye, you probably noticed that the above example is not
    of the form A →B; it’s just a simple proposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A = ”there are in finitely many prime numbers.” ](img/file2150.png)'
  prefs: []
  type: TYPE_IMG
- en: In these cases, showing that ¬A is false yields the desired conclusion. However,
    this technique works for A →B -style propositions as well. (By the way, the existence
    part of Theorem [148](ch036.xhtml#x1-369007r148) can also be shown via contradiction;
    I’ll leave this for you as an exercise.)
  prefs: []
  type: TYPE_NORMAL
- en: B.5.3 Contraposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final technique we will study is contraposition, a clever method that puts
    a twist into the classic A →B-style thinking.
  prefs: []
  type: TYPE_NORMAL
- en: We should get to know the implication connective a bit better to see what it
    is. As it turns out, A →B can be written in terms of negation and disjunction.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 150\.
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B two propositions. Then,
  prefs: []
  type: TYPE_NORMAL
- en: '![A → B ≡ ¬A ∨ B. ](img/file2151.png)'
  prefs: []
  type: TYPE_IMG
- en: Proof. The truth table
  prefs: []
  type: TYPE_NORMAL
- en: '![| | | | | |A |B |¬A |¬A ∨ B | |--|---|----|--------| |0 |0 | 1 | 1 | | |
    | | | |0 |1 | 1 | 1 | |1 |0 | 0 | 0 | | | | | | |1 |1 | 0 | 1 | | | ](img/file2152.png)'
  prefs: []
  type: TYPE_IMG
- en: provides a proof.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this relevant? Simple. Take a look at the following corollary.
  prefs: []
  type: TYPE_NORMAL
- en: Corollary 4\. (Principle of contraposition)
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be two propositions. Then,
  prefs: []
  type: TYPE_NORMAL
- en: '![A → B ≡ ¬B → ¬A. ](img/file2153.png)'
  prefs: []
  type: TYPE_IMG
- en: Proof. Theorem [150](ch036.xhtml#x1-371003r150) implies that
  prefs: []
  type: TYPE_NORMAL
- en: '![A → B ≡ ¬A ∨ B ≡ B ∨ ¬A ≡ ¬B → ¬A, ](img/file2154.png)'
  prefs: []
  type: TYPE_IMG
- en: which is what we had to prove.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple proposition about integers to give you a mathematical example.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 151\.
  prefs: []
  type: TYPE_NORMAL
- en: Let ![n ∈ ℤ ](img/file2155.png) be an integer. If ![2 ∤ n ](img/file2156.png),
    then ![4 ∤ n ](img/file2157.png).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. We should prove this via contraposition. Thus, assume that 4∣n. This
    means that
  prefs: []
  type: TYPE_NORMAL
- en: '![n = 4k ](img/file2158.png)'
  prefs: []
  type: TYPE_IMG
- en: for some integer k ∈ℤ. However, this implies that
  prefs: []
  type: TYPE_NORMAL
- en: '![n = 2(2k), ](img/file2159.png)'
  prefs: []
  type: TYPE_IMG
- en: which shows that 2∣n. Due to the principle of contraposition, (4∣n) → (2∣n)
    is logically equivalent to (2 ∤ n) → (4 ∤ n), which is what we had to prove.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contraposition is not only useful in mathematics, it is a valuable thinking
    tool in general. Let’s consider our recurring proposition: “if it is raining outside,
    then the sidewalk is wet.” We know this to be true, but this also means that “if
    the sidewalk is not wet, then it is not raining” (because, otherwise, the sidewalk
    would be wet).'
  prefs: []
  type: TYPE_NORMAL
- en: You perform these types of arguments every day without even noticing it. Now
    you have a name for them and can start to apply this pattern consciously.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
