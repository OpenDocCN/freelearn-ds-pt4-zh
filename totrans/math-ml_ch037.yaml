- en: Appendix C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basics of Set Theory
  prefs: []
  type: TYPE_NORMAL
- en: In other words, general set theory is pretty trivial stuff really, but, if you
    want to be a mathematician, you need some and here it is; read it, absorb it,
    and forget it. — Paul R. Halmos
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although Paul Halmos said the above a long time ago, it has remained quite
    accurate. Except for one part: set theory is not only necessary for mathematicians,
    but for computer scientists, data scientists, and software engineers as well.'
  prefs: []
  type: TYPE_NORMAL
- en: You might have heard about or studied set theory before. It is hard to see why
    it is so essential for machine learning, but trust me, set theory is the very
    foundation of mathematics. Deep down, everything is a set or a function between
    sets. (As we saw in Chapter [9](ch017.xhtml#functions), even functions are defined
    as sets.)
  prefs: []
  type: TYPE_NORMAL
- en: Think about the relation of set theory and machine learning like grammar and
    poetry. To write beautiful poetry, one needs to be familiar with the rules of
    the language. For example, data points are represented as vectors in vector spaces,
    often constructed as the Cartesian product of sets. (Don’t worry if you are not
    familiar with Cartesian products, we’ll get there soon.) Or, to really understand
    probability theory, you need to be familiar with event spaces, which are systems
    of sets closed under certain operations.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are sets anyway?
  prefs: []
  type: TYPE_NORMAL
- en: C.1 What is a set?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the surface level, a set is just a collection of things. We define sets by
    enumerating their elements like
  prefs: []
  type: TYPE_NORMAL
- en: '![S = {red,green,♡}. ](img/file2160.png)'
  prefs: []
  type: TYPE_IMG
- en: Two sets are equal if they have the same elements. Given any element, we can
    always tell if it is a member of a given set or not. When every element of A is
    also an element of B, we say that A is a subset of B, or, in notation,
  prefs: []
  type: TYPE_NORMAL
- en: '![A ⊆ B. ](img/file2161.png)'
  prefs: []
  type: TYPE_IMG
- en: If A ⊆B and A≠B, we say that A is a proper subset of B and write A ⊂B. If we
    have a set, we can define subsets by specifying a property that all of its elements
    satisfy, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '![even numbers = {n ∈ ℤ : n%2 = 0}. ](img/file2162.png)'
  prefs: []
  type: TYPE_IMG
- en: '(The % denotes the modulo operator.) This latter method is called the set-builder
    notation, and if you are familiar with the Python programming language, you can
    see this inspired list comprehensions. There, one would write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can even describe sets as a collection of other sets, say, the set of all
    subsets of A. This is called the power set, a concept so essential that it deserves
    its own formal definition.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 108\. (Power sets)
  prefs: []
  type: TYPE_NORMAL
- en: Let A be an arbitrary set. The set defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![2A := {B : B ⊆ A}, ](img/file2163.png)'
  prefs: []
  type: TYPE_IMG
- en: containing all subsets of A, is called the power set of A.
  prefs: []
  type: TYPE_NORMAL
- en: Both ∅ and A are elements of the power set 2^A.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, defining sets as a collection of elements does not work. Without
    further conditions, it can lead to paradoxes, as the famous Russell paradox shows.
    (We’ll talk about this later in this chapter.) To avoid going down the rabbit
    hole of set theory, we accept that sets have some proper definition buried within
    a thousand-page-sized tome of mathematics. Instead of worrying about this, we
    focus on what we can do with sets.
  prefs: []
  type: TYPE_NORMAL
- en: C.2 Operations on sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Describing more complex sets with only these two methods (listing their members
    or using the set-builder notation) is extremely difficult. To make the job easier,
    we define operations on sets.
  prefs: []
  type: TYPE_NORMAL
- en: C.2.1 Union, intersection, difference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most basic operations are the union, intersection, and difference. You are
    probably familiar with these, as they are encountered frequently as early as high
    school. Even if you are familiar with them, check out the formal definition next.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 109\. (Set operations)
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be two sets. We define
  prefs: []
  type: TYPE_NORMAL
- en: '(a) their union by A ∪B := {x : x ∈A or x ∈B},'
  prefs: []
  type: TYPE_NORMAL
- en: '(b) their intersection by A ∩B := {x : x ∈A and x ∈B},'
  prefs: []
  type: TYPE_NORMAL
- en: '(c) and their difference by A ∖B := {x : x ∈A and x![∈∕](img/file2164.png)B}.'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily visualize these with Venn diagrams, as you can see below.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file2165.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.1: Set operations visualized in Venn diagrams'
  prefs: []
  type: TYPE_NORMAL
- en: We can express set operations in plain English as well. For example, A∪B means
    “A or B.” Similarly, A ∩B means “A and B,” while A ∖B is “A but not B.” When talking
    about probabilities, these will be useful for translating events to the language
    of set theory.
  prefs: []
  type: TYPE_NORMAL
- en: These set operations also have a lot of pleasant properties.
  prefs: []
  type: TYPE_NORMAL
- en: For example, they behave nicely with respect to parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 152\.
  prefs: []
  type: TYPE_NORMAL
- en: Let A, B, and C be three sets. The union operation is
  prefs: []
  type: TYPE_NORMAL
- en: (a) associative, that is, A ∪ (B ∪C) = (A ∪B) ∪C,
  prefs: []
  type: TYPE_NORMAL
- en: (b) commutative, that is, A ∪B = B ∪A.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the intersection operation is also associative and commutative. Finally,
  prefs: []
  type: TYPE_NORMAL
- en: (c) the union is distributive with respect to the intersection, that is, A∪(B∩
    C) = (A ∪B) ∩ (A ∪C),
  prefs: []
  type: TYPE_NORMAL
- en: (d) and the intersection is distributive with respect to the union, that is,
    A ∩ (B ∪C) = (A ∩B) ∪ (A ∩C).
  prefs: []
  type: TYPE_NORMAL
- en: Union and intersection can be defined for an arbitrary number of operands. That
    is, if A[1],A[2],…,A[n] are sets,
  prefs: []
  type: TYPE_NORMAL
- en: '![A1 ∪⋅⋅⋅∪ An := (A1 ∪ ⋅⋅⋅∪ An−1) ∪An, ](img/file2166.png)'
  prefs: []
  type: TYPE_IMG
- en: and similar for the intersection. Note that this is a recursive definition!
    Because of associativity, the order of parentheses doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: The associativity and commutativity might seem too abstract and trivial at the
    same time. However, this is not the case for all operations, so it is worth emphasizing
    to get used to the concepts. If you are curious, noncommutative operations are
    right under our noses. A simple example is string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: C.2.2 De Morgan’s laws
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the fundamental rules describes how set difference, union, and intersection
    behave together regarding set operations. These are called De Morgan’s laws.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 153\. (De Morgan’s laws)
  prefs: []
  type: TYPE_NORMAL
- en: Let A,B, and C be three sets. Then
  prefs: []
  type: TYPE_NORMAL
- en: (a) A ∖ (B ∪C) = (A ∖B) ∩ (A ∖C),
  prefs: []
  type: TYPE_NORMAL
- en: (b) A ∖ (B ∩C) = (A ∖B) ∪ (A ∖C).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. For simplicity, we are going to prove this using Venn diagrams. Although
    drawing a picture is not a ”proper” mathematical proof, this is not a problem.
    We are here to understand things, not to get hung up on philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the illustration.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file2167.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.2: De Morgan’s laws, illustrated on Venn diagrams'
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, you can easily see both (a) and (b).
  prefs: []
  type: TYPE_NORMAL
- en: Note that De Morgan’s laws can be generalized to cover any number of sets. So,
    for any Γ index set,
  prefs: []
  type: TYPE_NORMAL
- en: '![A ∖ (∩γ∈Γ B γ) = ∪ γ∈Γ (A ∖B γ), A ∖ (∪γ∈Γ B γ) = ∩ γ∈Γ (A ∖B γ). ](img/file2168.png)'
  prefs: []
  type: TYPE_IMG
- en: C.3 The Cartesian product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most fundamental ways to construct new sets is the Cartesian product.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 110\. (The Cartesian product)
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be two sets. Their Cartesian product A ×B is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![A × B := {(a,b) : a ∈ A and b ∈ B }. ](img/file2169.png)'
  prefs: []
  type: TYPE_IMG
- en: The elements of the product are called tuples. Note that this operation is not
    associative nor commutative!
  prefs: []
  type: TYPE_NORMAL
- en: To see this, consider that, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '![{1} × {2} ⁄= {2}× {1} ](img/file2170.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![({1} × {2})× {3} ⁄= {1} × ({2}× {3}). ](img/file2171.png)'
  prefs: []
  type: TYPE_IMG
- en: The Cartesian product for an arbitrary number of sets is defined with a recursive
    definition, just like we did with the union and intersection. So, if A[1],A[2],…,A[n]
    are sets, then
  prefs: []
  type: TYPE_NORMAL
- en: '![A1 × ⋅⋅⋅× An := (A1 × ⋅⋅⋅× An− 1)× An. ](img/file2172.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the elements are tuples of tuples of tuples of…, but to avoid writing
    an excessive number of parentheses, we can abbreviate it as (a[1],…,a[n]). When
    the operands are the same, we usually write A^n instead of A ×⋅⋅⋅×A.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common examples is the Cartesian plane, which you probably have
    seen before.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file2174.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.3: The Cartesian plane'
  prefs: []
  type: TYPE_NORMAL
- en: To give a machine-learning-related example, let’s take a look at how data is
    usually presented. We’ll focus on the famous Iris dataset ( [https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html](https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html)),
    which is a subset of ![ℝ4 ](img/file2175.png). In this dataset, the four axes
    represent sepal length, sepal width, petal length, and petal width.
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file2176.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure C.4: The sepal width, plotted against the sepal length in the Iris dataset.
    Source: scikit-learn documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the example demonstrates, Cartesian products are useful because they combine
    related information into a single mathematical structure. This is a recurring
    pattern in mathematics: building complex things from simpler building blocks and
    abstracting away the details by turning the result into yet another building block.
    (As one would do to create complex software as well.)'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve seen the pleasant side of sets. However, they have caused quite
    a headache for mathematicians upon their first attempts to formalize set theory.
    We are ready to see why.
  prefs: []
  type: TYPE_NORMAL
- en: C.4 The cardinality of sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to sets, “How many elements does a set have?” is a natural question
    to ask. What you might not expect is how deep of a rabbit hole such an innocent
    question plunges us into!
  prefs: []
  type: TYPE_NORMAL
- en: Soon, you’ll see why. The “size of a set” is formalized by the concept of cardinality,
    denoted by jAj; that is, putting the set A between the absolute value signs. Intuitively,
    jAj seems clear, but let me assure you, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the true mind-bending begins in mathematics. Sure, for finite
    sets like {4,6,42}, we can confidently claim that j{4,6,42}j = 3, but what about
    jℤj, jℚj, jℝj, or even jℝ²j ?
  prefs: []
  type: TYPE_NORMAL
- en: 'Check this: jℤj = jℚj, but jℤj≠jℝj, and jℝj = jℝ²j. In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: there are “as many” integers as rational numbers,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: but there are “more” real numbers than integers,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and there are “as many” points on the real line as on the plane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See, I told you that cardinality is where the crazy stuff starts. (The “as many”
    and “more” are in quotes because we haven’t defined them yet; at least, not in
    a mathematical sense.)
  prefs: []
  type: TYPE_NORMAL
- en: As with several concepts in mathematics, we won’t define cardinality directly.
    Instead, we’ll define how to compare the cardinalities of sets, and then anchor
    special sets that’ll serve as points of comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 111\. (Comparison of cardinality)
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be two arbitrary sets.
  prefs: []
  type: TYPE_NORMAL
- en: (a) We say that jAj = jBj if there exists a function from A to B that is bijective.
  prefs: []
  type: TYPE_NORMAL
- en: (b) We say that jAj ≤jBj if there exists a function from A to B that is injective.
  prefs: []
  type: TYPE_NORMAL
- en: (c) We say that jAj/span>jBj if there exists a function from A to B that is
    injective but not surjective.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s unpack this with a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1\. Let A = {1,2,3} and B = {−3.2,12.452,−5.82}. Then jAj = jBj, because
    f : A →B,'
  prefs: []
  type: TYPE_NORMAL
- en: '![f(1) = − 5.83, f(2) = − 3.2, f(3) = 12.452 ](img/file2177.png)'
  prefs: []
  type: TYPE_IMG
- en: is a bijection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2\. Let A = {0,1} and B = {2,3,4}. Then jAj/span>jBj, because f : A
    →B,'
  prefs: []
  type: TYPE_NORMAL
- en: '![f(0) = 2, f(1) = 3 ](img/file2178.png)'
  prefs: []
  type: TYPE_IMG
- en: is injective, but not surjective.
  prefs: []
  type: TYPE_NORMAL
- en: What about more interesting sets, like ℕ,ℤ,ℚ,ℝ? This is where things get weird.
  prefs: []
  type: TYPE_NORMAL
- en: The following result is so important that we state it as a theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 154\. (The set of natural numbers is infinite)
  prefs: []
  type: TYPE_NORMAL
- en: Let n ∈ℕ be any natural number, and define the set A = {1,2,…,n}. Then jAj/span>ℕ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof. The proof is simple, as it’s easy to see that the function f : A →ℕ,
    defined by f(a) = a is injective but not surjective.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, ℕ is not a finite set! The set of natural numbers is our first
    example of an infinite set, defining the notion of countable sets.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 112\. (Countable sets)
  prefs: []
  type: TYPE_NORMAL
- en: Let ![A ](img/file2179.png) be an arbitrary set. If ![|A | ≤ ℕ ](img/file2180.png),
    then ![A ](img/file2181.png) is called countable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can show that a set is countable by enumerating its elements, as every enumeration
    defines an injective mapping. For instance, ℤ is countable, as the function f
    : ℕ →ℤ defined by'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ||| 0 if n = 0, |{ f (n ) = k if n = 2k for some k, |||| ( − k if n =
    2k + 1 for some k ](img/file2182.png)'
  prefs: []
  type: TYPE_IMG
- en: is a bijection. In other words, the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '![0,1,− 1,2,− 2,3,− 3,... ](img/file2183.png)'
  prefs: []
  type: TYPE_IMG
- en: is an enumeration of ℤ. For more examples, see Chapter [10](ch018.xhtml#numbers-sequences-and-series).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding countability, there are two essential results: the union and the
    Cartesian product of countable sets are still countable.'
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 155\. (Union and Cartesian product of countable sets)
  prefs: []
  type: TYPE_NORMAL
- en: Let A[1],A[2],… be countable sets.
  prefs: []
  type: TYPE_NORMAL
- en: (a) A[1] ×A[2] is countable.
  prefs: []
  type: TYPE_NORMAL
- en: (b) ∪[n=1]^∞A[n] is countable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among infinite cardinalities, there are two that we frequently encounter: the
    countably infinite and the continuum. The countably infinite is the cardinality
    of the set of natural numbers, denoted by'
  prefs: []
  type: TYPE_NORMAL
- en: '![|ℤ| = ℵ0, ](img/file2184.png)'
  prefs: []
  type: TYPE_IMG
- en: where ℵ is the Hebrew letter aleph. On the other hand, the continuum is the
    cardinality of the set of real numbers, denoted by
  prefs: []
  type: TYPE_NORMAL
- en: '![|ℝ | = c. ](img/file2185.png)'
  prefs: []
  type: TYPE_IMG
- en: C.5 The Russell paradox (optional)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s return to a remark I made earlier: naively defining sets as collections
    of things is not going to cut it. In the following, we are going to see why. Prepare
    for some mind-twisting mathematics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a riddle. A barber is “one who shaves all those, and those only, who
    do not shave themselves.” Does the barber shave themself? There’s no good answer:
    either yes or no, the definition implies otherwise. This is known as the barber’s
    paradox. It’s more than a cute little story; it’s a paradox that shook the foundations
    of mathematics.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, sets can be made of sets. For instance, {ℕ,ℤ,ℝ} is a collection
    of the most commonly used number sets. We might as well define the set of all
    sets, which we’ll denote with Ω.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we can use the set-builder notation to describe the following collection
    of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![S := {A ∈ Ω : A ∕∈ A }. ](img/file2186.png)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, S is a collection of sets that are not elements of themselves.
    Although this is weird, it looks valid. We used the property “![A ∕∈ A ](img/file2187.png)”
    to filter the set of all sets. What is the problem?
  prefs: []
  type: TYPE_NORMAL
- en: For one, we can’t decide if S is an element of S or not. If S ∈S, then by the
    defining property, S![∕∈](img/file2188.png)S. On the other hand, if S![∕∈](img/file2189.png)S,
    then by the definition, S ∈S. This is definitely very weird.
  prefs: []
  type: TYPE_NORMAL
- en: We can diagnose the issue by decomposing the set-builder notation. In general
    terms, it can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '![x ∈ A : T (x), ](img/file2190.png)'
  prefs: []
  type: TYPE_IMG
- en: where A is some set and T(x) is a property, that is, a true or false statement
    about x.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the definition {A ∈ Ω : A![∈∕](img/file2191.png)A}, our abstract property
    is defined by'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( |{ true if A ∕∈ A, T(A ) := |( false otherwise. ](img/file2192.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is perfectly valid, so the problem must be in the other part: the set
    Ω. It turns out that the set of all sets is not a set. So, defining sets as a
    collection of things is not enough. Since sets are at the very foundation of mathematics,
    this discovery threw a giant monkey wrench into the machine around the late 19th-early
    20th century, and it took lots of years and brilliant minds to fix it.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, as machine learning practitioners, we don’t have to care about
    such low-level details as the axioms of set theory. For us, it is enough to know
    that a solid foundation exists somewhere. (Hopefully.)
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
