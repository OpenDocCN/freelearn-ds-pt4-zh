- en: Advanced Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have learnt the versatile usage of basic Matplotlib
    APIs to create and customize various plot types. In order to create more suitable
    visuals for our data, there are more advanced techniques to make more refined
    figures. In fact, we can leverage not only the native Matplotlib functionalities
    but also a number of third-party packages built on top of Matplotlib. They provide
    easy ways to create more advanced plots that are also aesthetically styled by
    default. We can then make use of Matplotlib techniques to refine our data plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we would further explore the advanced usage of Matplotlib.
    We would learn how to group multiple relevant plots into subplots in one figure,
    using non-linear scale axis scales, plotting images, and creating advanced plots
    with the help of some popular third-party packages. Here are the detailed list
    of topics we would cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing subplots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using non-linear axis scales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Pandas-Matplotlib plotting integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexbin plots on bivariate datasets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Seaborn to construct:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel density estimation plots for bivariate data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Heatmaps with and without hierarchical clustering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mpl_finance` to plot finance data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D plotting with `Axes3D`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Basemap and GeoPandas to visualize geographical data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing Subplots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In designing layouts of visual aids, it is often necessary to organize multiple
    relevant plots into panels in the same figure, such as when illustrating different
    aspects of the same dataset. Matplotlib provides a few ways to create figures
    with multiple subplots.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating a figure with plt.figure()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `plt.figure()` API is the API that is used to initiate a figure that serves
    as the base canvas. It takes in arguments that determines the number of figures
    and parameters such as size and background color of the plot image. It displays
    a new area as the canvas for plotting `axes` when called. We wouldn''t obtain
    any graphical output unless we add other plotting elements. If we were to call
    `plt.show()` at this point, we would see a Matplotlib `figure` object being returned,
    as shown in the following screen capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20e628d4-18e2-4959-8b51-be612a5c1160.png)'
  prefs: []
  type: TYPE_IMG
- en: When we are plotting simple figures that involve only a single plot, without
    the need for multiple panels, we can omit calling `plt.figure()`. If `plt.figure()` is
    not called or if no argument is supplied to `plt.figure()`, then a single figure
    is initiated by default, equivalent to `plt.figure(1)`. If the dimension ratio
    of a figure is crucial, we should adjust it by passing a tuple of `(width, height)` as
    the `figsize` argument here.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating subplots as axes with plt.subplot()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initiate the axes plot instances that actually frame each plot, we can use
    `plt.subplot()`. It takes three parameters: number of rows, number of columns,
    and plot number. When the total number of plots is less than 10, we can omit the
    delimiting commas in the input arguments. Here is a code snippet example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following figure. Note how the subplots are
    ordered from left to right, top to bottom. When adding actual plot elements, it
    is essential to place them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a8d73b4-9e93-4dc9-b41b-33b80268e61a.png)'
  prefs: []
  type: TYPE_IMG
- en: Also note that printing the type of one of the axes returns `<class 'matplotlib.axes._subplots.AxesSubplot'>`
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Adding subplots with plt.figure.add_subplot()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an `add_subplot()` function similar to `plt.subplot()` under `plt.figure()`
    that allows us to create additional subplots under the same figure. Similar to `plt.subplot()`,
    it takes the row number, column number, and plot number as input arguments and
    allows arguments without commas for fewer than 10 plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also initiate the first subplot using this function. This code is a
    quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an empty plot area enclosed by four spines containing the *x*
    axis and *y* axis, as shown below. Note that we must call the `add_subplot()` function
    under a `figure` but not by `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/737ac4e6-a17f-4f9c-9076-00981dc8809a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us further compare the differences between `fig.add_subplot()`. and  `plt.subplot()`.
    Here, we would be creating three empty subplots with different sizes and face
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first use try using `fig.add_subplot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We get three overlapping subplots on the same figure, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb143e39-1165-42ec-92a5-14be5611bee0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we replace `fig.add_subplot()` with `plt.subplot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the following image that the red `ax1` subplot cannot be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d671846-baab-4884-8ffe-0eae4a0f5458.png)'
  prefs: []
  type: TYPE_IMG
- en: If we have already plotted the first subplot using `plt.subplot()` and would
    like to create additional subplots, we can call the `plt.gcf()` function to retrieve
    the `figure` object and store it as a variable. Then, we can call `fig.add_subplot()`
    as shown in the example before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the following code is an alternative way to generate the three overlapping
    subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Initiating an array of subplots with plt.subplots()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need to create a larger number of subplots of the same size, it can
    be quite inefficient to generate them one by one with the `plt.subplot()` or `fig.add_subplot()`
    function. In this case, we can call `plt.subplots()` to generate an array of subplots
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: '`plt.subplots()` takes in the number of rows and columns as input parameters,
    and returns a `Figure` together with a grid of subplots stored in a NumPy array.
    When there is no input parameter, `plt.subplots()` is equivalent to `plt.figure()`
    plus `plt.subplot()` by default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet for demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the resultant screenshot , we can observe that `plt.subplots()` also returns
    the `Figure` and `AxesSubplot` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8efed31-c92c-4601-98be-2a1a6465223f.png)'
  prefs: []
  type: TYPE_IMG
- en: The next example illustrates a more useful case of  `plt.subplots()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we will create a figure of 3x4 subplots and label each in a nested
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can observe from this figure that the subplots are ordered in rows
    and then columns, as seen in the preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfa8130b-a90d-405b-9650-462c71a1921b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to supply only one input parameter to `plt.subplots()`,
    which will be interpreted as the specified number of plots vertically stacked
    in rows. As the  `plt.subplots()` function has essentially incorporated the `plt.figure()`
    function, we can also specify the figure dimensions by providing input to the
    `figsize` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the type of  `axarr` is `<class 'numpy.ndarray'>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code results in the following figure with two rows of subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c8472ca-408c-4f3b-a64d-5cab0b0bc860.png)'
  prefs: []
  type: TYPE_IMG
- en: Shared axes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `plt.subplots()`, we can specify that the subplots should share the
    *x* axis and/or *y* axis to avoid cluttering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the 3x4 subplots example earlier, suppose we turn on the shared
    axes option in `plt.subplots()` by supplying `sharex=True` and `sharey=True` as
    arguments, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now obtain the following figure. Compared to the preceding example, it looks
    neater with the subplot axis labels removed except for the leftmost and bottom
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bbd290b-2f28-4b58-a008-52a1d354593c.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the margin with plt.tight_layout()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we can adjust the alignment. We may want to adjust the margin between
    each subplot, or leave no margin instead of having rows and columns of discrete
    boxes. In this case, we can use the `plt.tight_layout()` function. By default,
    it fits all subplots into the figure area when no parameters are supplied. It
    takes the keyword arguments `pad`, `w_pad`, and `h_pad` to control the padding
    around subplots. Let''s look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We see from the following figure that the now there is no space between subplots,
    but there's some overlap of axis ticks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn how to adjust tick properties or to remove ticks in a later section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a308847c-9176-4fd1-b595-41a3bb6f6547.png)'
  prefs: []
  type: TYPE_IMG
- en: Aligning subplots of different dimensions with plt.subplot2grid()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `plt.subplots()` provides a handy way to create grids of same-sized subplots,
    at times we may need to combine subplots of different sizes in a group. This is
    when `plt.subplot2grid()` comes into use.
  prefs: []
  type: TYPE_NORMAL
- en: '`plt.subplot2grid()` takes in three to four parameters. The first tuple specifies
    the overall dimensions of the grid. The second tuple determines where in the grid
    the top left corner of a subplot starts. Finally we describe the subplot dimensions
    using the `rowspan` and `colspan` arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to showcase the usage of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the resultant plot. Notice how the subplots of different sizes
    are aligned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9971f73e-b74f-44e1-90d7-29782d2abb8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Drawing inset plots with fig.add_axes()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is not a must for subplots to align side by side. In some occasions, such
    as when zooming in or out, we can also embed subplots on top of the parent plot
    layer. This can be done by `fig.add_axes()`. To add a subplot, here is the basic
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `left`, `bottom`, `width`, and `height` parameters are specified relative
    to the parent figure in terms of `float`. Note that `fig.add_axes()` returns an
    axes object, so you may store it as a variable such as `ax = fig.add_axes([left,
    bottom, width, height])` for further adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a complete example where we try to plot the overview in a
    smaller embedded subplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out the result in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd328180-6a7d-461c-bb03-66dc7e0a5485.png)'
  prefs: []
  type: TYPE_IMG
- en: Adjusting subplot dimensions post hoc with plt.subplots_adjust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can adjust the dimensions of a subplot with `plt.subplots_adjust()`, which
    takes in any combinations of parameters—`left`, `right`, `top`, and `bottom`—each
    defined relative to the parent axes.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting axes and ticks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In data visualization, it is often not enough to only display the trend in a
    relative sense. An axis scale is essential to facilitate value estimation for
    proper interpretation. Ticks are markers on an axis that denote the scale for
    this purpose. Depending on the nature of data and figure layout, we often need
    to adjust the scale and tick spacing to provide enough information without clutter.
    In this section, we are going to introduce the customization methods.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing tick spacing with locators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two sets of ticks to mark coordinates on each axis: major and minor
    ticks. By default, Matplotlib tries to  automatically optimize the tick spacing
    and format based on the data input. Wherever manual adjustment is needed, it can
    be done through setting these four locators: `xmajorLocator`, `xminorLocator`,
    `ymajorLocator`, `yminorLocator` via the function `set_major_locator`, or `set_minor_locator`
    on the respective axis. The following is a usage example, where `ax` is an axes
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we list the common locators and their usage.
  prefs: []
  type: TYPE_NORMAL
- en: Removing ticks with NullLocator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When `NullLocator` is used, ticks are removed from view.
  prefs: []
  type: TYPE_NORMAL
- en: Locating ticks in multiples with MultipleLocator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name implies, `MultipleLocator` generates ticks in multiples of a user-specified
    base. For example, if we would like our ticks to mark integers instead of floats,
    we can initialize the base by `MultipleLocator(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Locators to display date and time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For time series plotting, Matplotlib provides a list of tick locators to serve
    as datetime markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MinuteLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HourLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DayLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeekdayLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonthLocator `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YearLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RRuleLocator`, which allows arbitrary date tick specification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutoDateLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultipleDateLocator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To plot time series, we can also use Pandas to specify the datetime format for
    data in the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Time series data can be resampled by aggregation methods such as  `mean()`, `sum()`,
    or a custom function.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing tick formats with formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tick formatters control the formats of tick labels. It is used similarly to tick
    locators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using a non-linear axis scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the distribution of our data, a linear scale may not be the best
    way to fit in all useful data points in a figure. In this case, we may need to
    modify the scale of the axes into a log or symmetric log scale. In Matplotlib,
    this can be done by `plt.xscale()` and `plt.yscale()` before defining the axes,
    or by `ax.set_xscale()` and `ax.set_yscale()` after an axis is defined.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to change the scale of the entire axis. To display a part of
    the axis in linear scale, we adjust the linear threshold with the argument `linthreshx`
    or `linthreshy`. To obtain a smooth continuous line, we can also mask the non-positive
    numbers with the argument `nonposx` or `nonposy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of the different axis scales. For
    a simpler illustration, we only change the scale in the `y` axis. Similar operations
    can be applied to the `x` axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare the results of each axis scale in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f251b6f4-a95a-42bc-9abd-6e3dd65e6920.png)'
  prefs: []
  type: TYPE_IMG
- en: More on Pandas-Matplotlib integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas provides the DataFrame data structure commonly used in handling multivariate
    data. When we usually use the Pandas package for data I/O, storage, and preprocessing,
    it also provides a number of native integrations with Matplotlib for quick visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these plots, we can call `df.plot(kind=plot_type)`, `df.plot.scatter()`,
    and so on. Here is a list of available plot types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`line`: Line plot (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bar`: Vertical bar plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`barh`: Horizontal bar plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hist`: Histogram'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`box`: Boxplot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kde`: **Kernel Density Estimation** (**KDE**) plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`density`: The same as `kde`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`area`: Area plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pie`: Pie plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created some of the simpler graphs in the previous chapters. Here, we
    will take the density plot as an example for discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Showing distribution with the KDE plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a histogram, the KDE plot is a method to visualize the shape of data
    distribution. It uses kernel smoothing to create smooth curves and is often combined
    with a histogram. It is useful in exploratory data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will compare the income in various age groups across
    different countries, with data obtained from surveys binned with different age
    groupings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for data curation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now draw the KDE plots for comparison. We have prepared a reusable function
    to plot the three pieces of data with less repetition in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can look at the results, which are from top to bottom for the US, the
    Netherlands, and Hong Kong, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4482080-2a6e-43fc-85d1-fa49f955b6fc.png)  ![](img/b4c0fe40-280e-4823-a56c-eb7af4e5b34a.png)![](img/bac62f69-6f70-4e25-b22f-8b3bfa51d3de.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, the figure is not a very accurate reflection of the original data,
    as extrapolation was involved before any tweaking (for instance, we do not have
    child labor data here, but the contours extend even to children below age **10**).
    Yet, we can observe a general difference in the pattern of income structures between
    ages **20** and **50** across the three economies, and to what extent the downloaded
    public data is comparable. We may then be able to suggest surveys with more useful
    groupings and perhaps to get more raw data points to suit our analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the density of bivariate data with hexbin plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scatter plot is a common method to show the distribution of data in a more raw
    form. But when data density goes over a threshold, it may not be the best visualization
    method as points can overlap and we lose information about the actual distribution.
  prefs: []
  type: TYPE_NORMAL
- en: A hexbin map is a way to improve the interpretation of data density, by showing
    the data density in an area by color intensity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to compare the visualization of the same dataset that aggregates
    in the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the scatter plot in `ax1`. We can see that many data points are overlapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/034ece3e-1b74-4f8b-bfe6-f1cba0a872d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As for the hexbin map in `ax2`, although not all discrete raw data points are
    shown, we can clearly see the variation of data distribution in the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03d572e0-8ea2-4e36-b963-bce115f3621e.png)'
  prefs: []
  type: TYPE_IMG
- en: Expanding plot types with Seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install the Seaborn package, we open the terminal or command prompt and call `pip3
    install --user seaborn`. For each use, we import the library by `import seaborn
    as sns`, where `sns` is a commonly used shorthand to save typing.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing multivariate data with a heatmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heatmap is a useful visualization method to illustrate multivariate data when
    there are many variables to compare, such as in a big data analysis. It is a plot
    that displays values in a color scale in a grid. It is among the most common plots
    utilized by bioinformaticians to display hundreds or thousands of gene expression
    values in one plot.
  prefs: []
  type: TYPE_NORMAL
- en: With Seaborn, drawing a heatmap is just one line away from importing the library.
    It is done by calling `sns.heatmap(df)`, where `df` is the Pandas DataFrame to
    be plotted. We can supply the `cmap` parameter to specify the color scale `("colormap")`
    to be used. You can revisit the previous chapter for more details on colormap
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a feel for heatmap, in the following example, we demonstrate the usage
    with the specification of the *7^(th)* and *8^(th)* generations of Intel Core
    CPUs, which involves dozens of models and four chosen metrics. Before looking
    at the plotting code, let''s look at the structure of the Pandas DataFrame that
    stores the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From the following screen capture of the output, we see that we simply put
    the labels as the index and different properties in each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6044ea05-9d53-466c-8f5c-c29f742f8544.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that there are 16 models that do not support boosting without the **Max
    Frequency** property value. It makes sense to consider the **Base Frequency**
    as the maximum for our purpose here. We will fill in the **NA** values with the
    `''Max Frequency''` by the corresponding `''Base Frequency''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s draw the heatmap with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple, isn''t it? Only one line of code actually draws the heatmap. This is
    also an example of how we can use basic Matplotlib code to adjust other fine details
    of the plot, such as figure dimensions and the `xticks` font size in this case.
    Let''s look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae986f5c-53a7-408d-b421-66246feee4d1.png)'
  prefs: []
  type: TYPE_IMG
- en: From the figure, even if we have absolutely no idea about these CPU models,
    we can easily infer something from the darker colors at the top among the i7 models.
    They are designed for higher performance with more core and cache space.
  prefs: []
  type: TYPE_NORMAL
- en: Showing hierarchy in multivariate data with clustermap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a heatmap illustration can be hard to interpret when there are too
    many alternating color bands. This is because our data may not be ordered in terms
    of similarity. In this case, we need to group more similar data together in order
    to see the structure.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, Seaborn offers the `clustermap` API, which is a combination
    of heatmap and dendrogram. A dendrogram is a tree-shaped graph that clusters more
    similar variables under the same branches/leaves. Drawing a dendrogram involves
    generally unsupervised hierarchical clustering, which is run in the background
    by default when we call the `clustermap()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Besides unsupervised clustering, if we have a priori knowledge of certain labels,
    we can also show it in colors with the `row_colors` keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we extend from the preceding heatmap example of CPU models, draw a clustered
    heatmap, and label the generation as row colors. Let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, calling the API is just as simple as the earlier heatmap, and we have
    generated the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/321092df-964b-47e8-8b69-3d92fb9116c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Other than being helpful in showing multiple properties of a larger number of
    samples, with some tweaking, clustermap can also be used in pairwise clustering
    to show the similarity among samples with all the available properties considered
    together.
  prefs: []
  type: TYPE_NORMAL
- en: To draw a pairwise clustering heatmap, we have to first calculate the correlation
    between samples from the various property values, convert the correlation matrix
    into a distance matrix, and then perform hierarchical clustering to generate linkage
    values for dendrogram plotting. We use the `scipy` package for this purpose. To
    understand more about linkage calculation methods, please refer to the SciPy documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will provide the user-defined function here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the pairwise clustering plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94272b55-7117-4e23-95cc-353f6b98d980.png)'
  prefs: []
  type: TYPE_IMG
- en: From both heatmaps, we can observe that, based on these four properties, the
    CPUs seem to be better clustered by the product line suffix such as **U**, **K**,
    and **Y** than by brand modifiers such as **i5** and **i7**. When we approach
    data, this is among the analytical skills where observation of the similarity
    within a large group is required.
  prefs: []
  type: TYPE_NORMAL
- en: Image plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In analyzing images, the first step is to convert colors into numerical values. Matplotlib
    provides APIs to read and show an image matrix of RGB values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quick code example of reading an image into a NumPy array
    with `plt.imread(''image_path'')`, and we show it with `plt.imshow(image_ndarray)`. Make
    sure that the Pillow package is installed so that more image types other than
    PNG can be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the original image displayed with the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87fc37f7-8b79-4806-9aae-2b4c81089c0c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After showing the original image, we will try to work with transforming the
    image by changing the color values in the image matrix. We will create a high-contrast
    image by setting the RGB values to either `0` or `255` (max) at the threshold
    of `160`. Here is how to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the result of the transformed image. By artificially increasing the
    contrast, we have created a pop art image!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75fb4efd-ebc6-4134-b4db-8daf801ff55d.png)'
  prefs: []
  type: TYPE_IMG
- en: To demonstrate a more practical use for the image processing feature of Matplotlib,
    we will demonstrate MNIST. MNIST is a famous dataset of handwritten digits. It
    is often used in tutorials of machine learning algorithms. Here, we will not go
    into details of machine learning but rather will try to recreate the scenario
    where we visually inspect the dataset during the exploratory data analysis stage.
  prefs: []
  type: TYPE_NORMAL
- en: We can download the entire MNIST dataset from the official site at [http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/). To
    ease our discussion and introduce useful package for Python machine learning,
    we load the data from Keras, which is a high-level API that facilitates neural
    network implementation. The MNIST dataset from the Keras package contains 70,000
    images, arranged in tuples of coordinates and corresponding labels to facilitate
    model training and testing when building neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first import the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is loaded only when `load_data()` is called. Because Keras is intended
    for training, the data is returned in tuples of training and testing datasets,
    each containing the actual image color values and labels, named `X` and `y` by
    convention here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When initially called, `load_data()` may take some time to download the MNIST
    dataset from the online database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the dimensions of the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally let''s take one of the images in the `X_train` set and plot it in black
    and white with `plt.imshow()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From the following figure, we can easily read seven with our bare eyes. In
    the case of solving real image recognition problems, we may sample some mis-called
    images and consider strategies to optimize our training algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a24cfbfa-a8f0-43db-bd90-800672d82eca.png)'
  prefs: []
  type: TYPE_IMG
- en: Financial plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations where more raw values per time point are needed to understand
    a trend for prediction. The candlestick plot is a commonly used visualization
    in technical analysis in finance to show a price trend, most often seen in the
    stock market.  To draw a candlestick plot, we can use the `candlestick_ohlc` API
    in the `mpl_finance` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`mpl_finance` can be downloaded from GitHub. After cloning the repository in
    the Python site-packages directory, call `python3 setup.py install` in the terminal
    to install it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`candlestick_ohlc()` takes the input of a Pandas DataFrame with five columns: `date`
    in floating-point numbers, `open`, `high`, `low`, and `close`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our tutorial, we use the cryptocurrency  market values as an example. Let''s
    again look at the data table we obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the how the table looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be107386-df27-4788-a10a-145b23e535c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s select the first cryptocurrency, Bitcoin, as our example. The following
    code selects the OHLC values in the month of December 2017 and sets the index
    as `date` in the datetime format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will draw the candlestick plot. Recall the techniques to set axis
    ticks to fine-tune time markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`mpl_finance` can be installed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can observe that the rapid rise of Bitcoin values in early December turns
    its direction in mid-December 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61517768-e7bb-4fd9-8122-23f2947ec253.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D plots with Axes3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have so far discussed plotting in two dimensions. In fact, there are numerous
    occasions where we may need 3D data visualizations. Examples include illustrating
    more complex mathematical functions, terrain features, fluid dynamics in physics,
    as well as just showing one more facet of our data.
  prefs: []
  type: TYPE_NORMAL
- en: In Matplotlib, it can done by `Axes3D` in the `mplot3d` library within `mpl_toolkits`.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to specify `projection='3d'` when defining an axes object after
    importing the library. Next, we just have to define the axes with `x`, `y`, and
    `z` coordinates. Supported plot types include scatter plot, line plot, bar plot,
    contour plots, wireframe plots, and surface plots with or without triangulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of drawing a 3D surface plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Matplotlib Axes3D is useful for plotting simple 3D plots with the usual Matplotlib
    syntax and appearance. For advanced scientific 3D plotting with Python demanding
    high rendering, it is recommended to use the Mayavi package. Here is the official
    website of the project for more details: [http://code.enthought.com/pages/mayavi-project.html](http://code.enthought.com/pages/mayavi-project.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following screenshot, we see that the color gradient also helps in
    portraying the shape of the 3D plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b62490-cdcf-4714-8a62-ca2c101ae8a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Geographical plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the power of Matplotlib with third-party packages, we will illustrate
    its usage in spatial analysis. Since the invention of satellites, a myriad of
    useful **Geographics Information System** (**GIS**) data has been generated to
    facilitate various analyses, from natural phenomena to human activities.
  prefs: []
  type: TYPE_NORMAL
- en: To utilize this data, there are common Python packages integrated with Matplotlib
    to show spatial data on a map, such as Basemap, GeoPandas, Cartopy, and Descartes.
    In this final section of the chapter, we will briefly introduce the usage of the
    first two packages.
  prefs: []
  type: TYPE_NORMAL
- en: Basemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basemap is among the most popular Matplotlib-based plotting toolkits to plot over
    world maps. It is a handy way to show any geographical location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Basemap, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Unpack in `$Python3_dir/site-packages/mpl_toolkits`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the Basemap installation directory: `cd $basemap_dir`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `geos` directory in the `Basemap` directory: `cd $basemap/geos-3.3.3`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the GEOS library via `./configure`, `make`, and `make install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install PyProj (refer to the following tip)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the Basemap installation directory and run `python3 setup.py install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the environment variable `` `PROJ_DIR=$pyproj_dir/lib/pyproj/data` ``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basemap requires PyProj as a dependency, where there are recurrent reports of
    installation failures. We recommend installing  from GitHub with prior installation
    of the Cython dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the PyProj GitHub repository from [https://github.com/jswhit/pyproj](https://github.com/jswhit/pyproj) into
    the Python site packages directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Cython dependency with `pip install --user cython`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the PyProj directory and install using `python3 setup.py install`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Windows users, it could be easier to install via Anaconda with the command
    prompt `conda install -c conda-forge geopandas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a brief introduction, we will show how to draw our beautiful Earth with
    shaded terrain with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the plot looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f15542ca-4594-4baf-b966-f2ac7abbf9b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides showing the earth as a sphere with orthogonal projection as shown in
    the preceding figure, we can also set `projection='cyl'` to use the Miller Cylindrical
    projection for a flat rectangular illustration.
  prefs: []
  type: TYPE_NORMAL
- en: Basemap provides plenty map drawing functions, such as drawing coastlines and
    plotting data over maps with hexbin or streamplot. Their details can be found
    in the official tutorials at [http://basemaptutorial.readthedocs.io](http://basemaptutorial.readthedocs.io).
    As in-depth geographical analysis is beyond the scope of this book, we will leave
    a more specific exploration of its usage as an exercise for interested readers.
  prefs: []
  type: TYPE_NORMAL
- en: GeoPandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GeoPandas is a geographical plotting package integrated with Matplotlib. It
    has comprehensive functionalities to read common GIS file formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use GeoPandas, we will import the library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the following example, we will explore the climate change data prepared by
    the World Bank Group.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have selected the projection of precipitation in 2080-2099 based on scenario
    B1: a convergent world with global population peaking in mid-century and then
    declining. The storyline describes economies becoming more service- and information-oriented,
    with the introduction of clean and resource-efficient technologies but without
    additional climate initiatives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As input, we have downloaded the shapefile (`.shp`), which is one of the standard
    formats used in geographical data analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look at the first few rows of the GeoPandas DataFrame. Note that the
    shape data is stored in the `geometry` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d7306f6-ad9c-45e7-bdcd-4da14d11b7c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will add borders to the world map to better identify the locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we inspect the GeoPandas DataFrame. The shape information is also stored
    in the `geometry` as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f45a74a-9b3a-4cb9-bc6e-e2166a2438b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The geometry data will be plotted as filled polygons. To draw the edges only,
    we will generate the geometry of borders by `GeoSeries.boundary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have obtained this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e6456a8-90b6-4080-8c12-d5816fdc3e37.png)'
  prefs: []
  type: TYPE_IMG
- en: The website also provides data for another scenario, A2, which describes a very
    heterogeneous world, with local identities preserved. How will the picture look?
    Will it look similar or strikingly different? Let's download the file to find
    out!
  prefs: []
  type: TYPE_NORMAL
- en: Again, GeoPandas provides many APIs for more advanced usage. Readers can refer
    to `http://geopandas.org/` for the full documentation or further details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We have come a long way in our advanced usage of Matplotlib.
    In this chapter, we learned how to draw and share axes between subplots, use a
    non-linear axis scale, adjust tick formatters and locators, plot images, create
    advanced plots with Seaborn, create a candlestick plot for financial data, draw
    simple 3D plots with Axes3D, and visualize geographic data with Basemap and GeoPandas.
  prefs: []
  type: TYPE_NORMAL
- en: You're all set to dig deeper into integrating these skills with your desired
    applications. In the next few chapters, we will be working with the different
    backends supported by Matplotlib. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
