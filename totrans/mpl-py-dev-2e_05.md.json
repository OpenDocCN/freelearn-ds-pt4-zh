["```py\n#Installing the gtk3 package\nbrew install gtk3\n#Installing PyGObject\nbrew install pygobject3\n```", "```py\nhandler_id = widget.connect(\"Event\", callback, data )\n```", "```py\n#In here, we import the GTK module in order to access GTK+3's classes and functions\n#We want to make sure we are importing GTK+3 and not any other version of the library\n#Therefore we require_version('Gtk','3.0')\nimport gi\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\n#This line uses the GTK+3 functions and creates an empty window\nwindow = Gtk.Window(title=\"Hello World!\")\n#We created a handler that connects window's delete event to ensure the application\n#is terminated if we click on the close button\nwindow.connect(\"destroy\",Gtk.main_quit)\n#Here we display the window\nwindow.show_all()\n#This tells the code to run the main loop until Gtk.main_quit is called\nGtk.main()\n```", "```py\npython3 first_gtk_example.py\n```", "```py\n#Again, here we import the GTK module\nimport gi\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\n#From here, we define our own class, namely TwoClicks.\n#This is a sub-class of Gtk.Window\nclass TwoClicks(Gtk.Window):\n\n    #Instantiation operation will creates an empty object\n    #Therefore, python3 uses __init__() to *construct* an object\n    #__init__() will be automatically invoked when the object is being created!\n    #You can call this the constructor in Python3\n    #Noted that *self* here indicates the reference of the object created from this class\n    #Anything starting with self.X refers to the local function or variables of the object itself!\n    def __init__(self):\n\n        #In here, we are essentially constructing a Gtk.Window object\n        #And parsing the information title=\"Hello world\" to the constructor of Gtk.Window\n        #Therefore, the window will have a title of \"Hello World\"\n        Gtk.Window.__init__(self, title=\"Hello World\")\n\n        #Since we have two click buttons, we created a horizontally oriented box container\n        #with 20 pixels placed in between children - the two click buttons\n        self.box = Gtk.Box(spacing=100)\n\n        #This assigns the box to become the child of the top-level window\n        self.add(self.box)\n\n        #Here we create the first button - click1, with the title \"Print once!\" on top of it\n        self.click1 = Gtk.Button(label=\"Print once!\")\n\n        #We assign a handler and connect the *Event* (clicked) with the *callback/function* (on_click1)\n        #Noted that, we are now calling the function of the object itself\n        #Therefore we are using *self.onclick1 \n        self.click1.connect(\"clicked\", self.on_click1)\n\n        #Gtk.Box.pack_start() has a directionality here, it positions widgets from left to right!\n        self.box.pack_start(self.click1, True, True, 0)\n\n        #The same applies to click 2, except that we connect it with a different function\n        #which prints Hello World 5 times!\n        self.click2 = Gtk.Button(label=\"Print 5 times!\")\n        self.click2.connect(\"clicked\", self.on_click2)\n        self.box.pack_start(self.click2, True, True, 0)\n\n    #Here defines a function on_click1 in the Class TwoClicks\n    #This function will be triggered when the button \"Print once!\" is clicked\n    def on_click1(self, widget):\n        print(\"Hello World\")\n\n    #Here defines a function on_click2 in the Class TwoClicks\n    #This function will be triggered when the button \"Print 5 times!\" is clicked\n    def on_click2(self, widget):\n        for i in range(0,5):\n            print(\"Hello World\")\n\n#Here we instantiate an object, namely window\nwindow = TwoClicks()\n#Here we want the window to be close when the user click on the close button\nwindow.connect(\"delete-event\", Gtk.main_quit)\n#Here we display the window!\nwindow.show_all()\n#This tells the code to run the main loop until Gtk.main_quit is called\nGtk.main()\n```", "```py\n#Same old, importing Gtk module, we are also importing some other stuff this time\n#such as numpy and the backends of matplotlib\nimport gi, numpy as np, matplotlib.cm as cm\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\n#From here, we are importing some essential backend tools from matplotlib\n#namely the NavigationToolbar2GTK3 and the FigureCanvasGTK3Agg\nfrom matplotlib.backends.backend_gtk3 import NavigationToolbar2GTK3 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n#Some numpy functions to create the polar plot\nfrom numpy import arange, pi, random, linspace\n\n#Here we define our own class MatplotlibEmbed\n#By simply instantiating this class through the __init__() function,\n#A polar plot will be drawn by using Matplotlib, and embedded to GTK3+ window\nclass MatplotlibEmbed(Gtk.Window):\n\n    #Instantiation\n    def __init__(self):\n        #Creating the Gtk Window\n        Gtk.Window.__init__(self, title=\"Embedding Matplotlib\")\n        #Setting the size of the GTK window as 400,400\n        self.set_default_size(400,400)\n\n        #Readers should find it familiar, as we are creating a matplotlib figure here with a dpi(resolution) 100\n        self.fig = Figure(figsize=(5,5), dpi=100)\n        #The axes element, here we indicate we are creating 1x1 grid and putting the subplot in the only cell\n        #Also we are creating a polar plot, therefore we set projection as 'polar\n        self.ax = self.fig.add_subplot(111, projection='polar')\n\n        #Here, we borrow one example shown in the matplotlib gtk3 cookbook\n        #and show a beautiful bar plot on a circular coordinate system\n        self.theta = linspace(0.0, 2 * pi, 30, endpoint=False)\n        self.radii = 10 * random.rand(30)\n        self.width = pi / 4 * random.rand(30)\n        self.bars = self.ax.bar(self.theta, self.radii, width=self.width, bottom=0.0)\n\n        #Here defines the color of the bar, as well as setting it to be transparent\n        for r, bar in zip(self.radii, self.bars):\n            bar.set_facecolor(cm.jet(r / 10.))\n            bar.set_alpha(0.5)\n        #Here we generate the figure\n        self.ax.plot()\n\n        #Here comes the magic, a Vbox is created\n        #VBox is a containder subclassed from Gtk.Box, and it organizes its child widgets into a single column\n        self.vbox = Gtk.VBox()\n        #After creating the Vbox, we have to add it to the window object itself!\n        self.add(self.vbox)\n\n        #Creating Canvas which store the matplotlib figure\n        self.canvas = FigureCanvas(self.fig)  # a Gtk.DrawingArea\n        # Add canvas to vbox\n        self.vbox.pack_start(self.canvas, True, True, 0)\n\n        # Creating toolbar, which enables the save function!\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        self.vbox.pack_start(self.toolbar, False, False, 0)\n\n#The code here should be self-explanatory by now! Or refer to earlier examples for in-depth explanation\nwindow = MatplotlibEmbed()\nwindow.connect(\"delete-event\", Gtk.main_quit)\nwindow.show_all()\nGtk.main()\n```", "```py\n#Same old, importing Gtk module, we are also importing some other stuff this time\n#such as numpy and the backends of matplotlib\nimport gi, numpy as np, matplotlib.cm as cm\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\n#From here, we are importing some essential backend tools from matplotlib\n#namely the NavigationToolbar2GTK3 and the FigureCanvasGTK3Agg\nfrom numpy import random\nfrom matplotlib.backends.backend_gtk3 import NavigationToolbar2GTK3 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\nfrom matplotlib.patches import Rectangle\n\n#Here we created a class named DrawPoints\nclass DrawPoints:\n\n    #Upon initiation, we create 4 randomized numpy array, those are for the coordinates, colors and size of dots\n    #on the scatter plot. After that we create a figure object, put in two subplots and create a canvas to store\n    #the figure.\n    def __init__(self):\n        #Namely we are creating 20 dots, therefore n = 20\n        self.n = 20\n        #X and Y coordinates\n        self.xrand = random.rand(1,self.n)*10\n        self.yrand = random.rand(1,self.n)*10\n        #Sizes\n        self.randsize = random.rand(1,self.n)*200\n        #Colors\n        self.randcolor = random.rand(self.n,3)\n\n        #Here creates the figure, with a size 10x10 and resolution of 80dpi\n        self.fig = Figure(figsize=(10,10), dpi=80)\n        #Stating that we are creating two plots side by side and adding \n        #self.ax as the first plot by add_subplot(121)\n        self.ax = self.fig.add_subplot(121)\n        #Adding the second subplot by stating add_subplot(122)\n        self.axzoom = self.fig.add_subplot(122)\n        #Create a canvas to store the figure object\n        self.canvas = FigureCanvas(self.fig)\n\n    #Here draw the scatterplot on the left\n    def draw(self):\n        #Here is the key - cla(), when we invoke the draw() function, we have to clear the\n        #figure and redraw it again\n        self.ax.cla()\n        #Setting the elements of the left subplot, in this case - grid\n        self.ax.grid(True)\n        #Set the maximum value of X and Y-axis in the left subplot\n        self.ax.set_xlim(0,10)\n        self.ax.set_ylim(0,10)\n        #Draw the scatter plot with the randomized numpy array that we created earlier in __init__(self)\n        self.ax.scatter(self.xrand, self.yrand, marker='o', s=self.randsize, c=self.randcolor, alpha=0.5)\n\n    #This zoom function is invoked by updatezoom() function outside of the class Drawpoints\n    #This function is responsible for things:\n    #1\\. Update X and Y coordinates based on the click\n    #2\\. invoke the draw() function to redraw the plot on the left, this is essential to update the position\n    # of the grey rectangle \n    #3\\. invoke the following drawzoom() function, which will \"Zoom-in\" the designated area by the grey rectangle\n    # and will redraw the subplot on the right based on the updated X & Y coordinates\n    #4\\. draw a transparent grey rectangle based on the mouse click on the left subplot\n    #5\\. Update the canvas\n    def zoom(self, x, y):\n        #Here updates the X & Y coordinates\n        self.x = x\n        self.y = y\n        #invoke the draw() function to update the subplot on the left\n        self.draw()\n        #invoke the drawzoom() function to update the subplot on the right\n        self.drawzoom()\n        #Draw the transparent grey rectangle at the subplot on the left\n        self.ax.add_patch(Rectangle((x - 1, y - 1), 2, 2, facecolor=\"grey\", alpha=0.2))\n        #Update the canvas\n        self.fig.canvas.draw()\n\n    #This drawzoom function is being called in the zoom function\n    #The idea is that, when the user picked a region (rectangle) to zoom, we need to redraw the zoomed panel,\n    #which is the subplot on the right\n    def drawzoom(self):\n        #Again, we use the cla() function to clear the figure, and getting ready for a redraw!\n        self.axzoom.cla()\n        #Setting the grid\n        self.axzoom.grid(True)\n        #Do not be confused! Remember that we invoke this function from zoom, therefore self.x and self.y\n        #are already updated in that function. In here, we are simply changing the X & Y-axis minimum and \n        #maximum value, and redraw the graph without changing any element!\n        self.axzoom.set_xlim(self.x-1, self.x+1)\n        self.axzoom.set_ylim(self.y-1, self.y+1)\n        #By changing the X & Y-axis minimum and maximum value, the dots that are out of range will automatically\n        #disappear!\n        self.axzoom.scatter(self.xrand, self.yrand, marker='o', s=self.randsize*5, c=self.randcolor, alpha=0.5)\n\ndef updatecursorposition(event):\n    '''When cursor inside plot, get position and print to statusbar'''\n    if event.inaxes:\n        x = event.xdata\n        y = event.ydata\n        statbar.push(1, (\"Coordinates:\" + \" x= \" + str(round(x,3)) + \"  y= \" + str(round(y,3))))\n\ndef updatezoom(event):\n    '''When mouse is right-clicked on the canvas get the coordiantes and send them to points.zoom'''\n    if event.button!=1: return\n    if (event.xdata is None): return\n    x,y = event.xdata, event.ydata\n    points.zoom(x,y)\n\n#Readers should be familiar with this now, here is the standard opening of the Gtk.Window()\nwindow = Gtk.Window()\nwindow.connect(\"delete-event\", Gtk.main_quit)\nwindow.set_default_size(800, 500)\nwindow.set_title('Interactive zoom')\n\n#Creating a vertical box, will have the canvas, toolbar and statbar being packed into it from top to bottom\nbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)\n#Adding the vertical box to the window\nwindow.add(box)\n\n#Instantiate the object points from the Class DrawPoints()\n#Remember that at this point, __init__() of DrawPoints() are invoked upon construction!\npoints = DrawPoints()\n#Invoke the draw() function in the object points\npoints.draw()\n\n#Packing the canvas now to the vertical box\nbox.pack_start(points.canvas, True, True, 0)\n\n#Creating and packing the toolbar to the vertical box\ntoolbar = NavigationToolbar(points.canvas, window)\nbox.pack_start(toolbar, False, True, 0)\n\n#Creating and packing the statbar to the vertical box\nstatbar = Gtk.Statusbar()\nbox.pack_start(statbar, False, True, 0)\n\n#Here is the magic that makes it happens, we are using mpl_connect to link the event and the canvas!\n#'motion_notify_event' is responsible for the mouse motion sensing and position updating\npoints.fig.canvas.mpl_connect('motion_notify_event', updatecursorposition)\n#'button_press_event' is slightly misleading, in fact it is referring to the mouse button being pressed, \n#instead of a GTK+3 button being pressed in this case\npoints.fig.canvas.mpl_connect('button_press_event', updatezoom)\n\nwindow.show_all()\nGtk.main()\n\n```", "```py\ngit clone git://git.gnome.org/glade\n```", "```py\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- Generated with glade 3.22.1 -->\n<interface>\n  <requires lib=\"gtk+\" version=\"3.22\"/>\n  <object class=\"GtkWindow\" id=\"window1\">\n    <property name=\"can_focus\">False</property>\n    <property name=\"default_width\">400</property>\n    <property name=\"default_height\">400</property>\n    <signal name=\"destroy\" handler=\"on_window1_destroy\" swapped=\"no\"/>\n    <child>\n      <object class=\"GtkScrolledWindow\" id=\"scrolledwindow1\">\n        <property name=\"visible\">True</property>\n        <property name=\"can_focus\">True</property>\n        <property name=\"shadow_type\">in</property>\n        <child>\n          <placeholder/>\n        </child>\n      </object>\n    </child>\n  </object>\n</interface>\n```", "```py\n#Same old, importing Gtk module, we are also importing some other stuff this time\n#such as numpy and the backends of matplotlib\nimport gi, numpy as np, matplotlib.cm as cm\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nfrom matplotlib.figure import Figure\nfrom numpy import arange, pi, random, linspace\nimport matplotlib.cm as cm\n#Possibly this rendering backend is broken currently\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas\n\n#New class, here is to invoke Gtk.main_quit() when the window is being destroyed\n#Necessary to quit the Gtk.main()\nclass Signals:\n    def on_window1_destroy(self, widget):\n        Gtk.main_quit()\n\nclass MatplotlibEmbed(Gtk.Window):\n\n    #Instantiation, we just need the canvas to store the figure!\n    def __init__(self):\n\n        #Readers should find it familiar, as we are creating a matplotlib figure here with a dpi(resolution) 100\n        self.fig = Figure(figsize=(5,5), dpi=100)\n        #The axes element, here we indicate we are creating 1x1 grid and putting the subplot in the only cell\n        #Also we are creating a polar plot, therefore we set projection as 'polar\n        self.ax = self.fig.add_subplot(111, projection='polar')\n\n        #Here, we borrow one example shown in the matplotlib gtk3 cookbook\n        #and show a beautiful bar plot on a circular coordinate system\n        self.theta = linspace(0.0, 2 * pi, 30, endpoint=False)\n        self.radii = 10 * random.rand(30)\n        self.width = pi / 4 * random.rand(30)\n        self.bars = self.ax.bar(self.theta, self.radii, width=self.width, bottom=0.0)\n\n        #Here defines the color of the bar, as well as setting it to be transparent\n        for r, bar in zip(self.radii, self.bars):\n            bar.set_facecolor(cm.jet(r / 10.))\n            bar.set_alpha(0.5)\n        #Here we generate the figure\n        self.ax.plot()\n\n        #Creating Canvas which store the matplotlib figure\n        self.canvas = FigureCanvas(self.fig)  # a Gtk.DrawingArea\n\n#Here is the magic, we create a GTKBuilder that reads textual description of a user interface\n#and instantiates the described objects\nbuilder = Gtk.Builder()\n#We ask the GTKBuilder to read the file and parse the information there\nbuilder.add_objects_from_file('/Users/aldrinyim/Dropbox/Matplotlib for Developer/Jupyter notebook/ch05/window1_glade.glade', ('window1', '') )\n#And we connect the terminating signals with Gtk.main_quit()\nbuilder.connect_signals(Signals())\n\n#We create the first object window1\nwindow1 = builder.get_object('window1')\n#We create the second object scrollwindow\nscrolledwindow1 = builder.get_object('scrolledwindow1')\n\n#Instantiate the object and start the drawing!\npolar_drawing = MatplotlibEmbed()\n#Add the canvas to the scrolledwindow1 object\nscrolledwindow1.add(polar_drawing.canvas)\n\n#Show all and keep the Gtk.main() active!\nwindow1.show_all()\nGtk.main()\n```"]