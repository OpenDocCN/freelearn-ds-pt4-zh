- en: Embedding Matplotlib in GTK+3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have worked on quite a few examples so far, and now have a good foundation
    from which to use Matplotlib to generate data plots and figures. While using Matplotlib
    alone is very handy in generating interactive figures, experimenting with datasets,
    and understanding substructures of data, there may be instances where we want
    an application to acquire, parse, and display our data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study examples on how to embed Matplotlib in applications
    through GTK+3.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up GTK+3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up GTK+3 is fairly simple and straightforward. There are quite a few
    ways to install GTK+3 depending on your OS version and environment.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage our readers refer to the link: [https://python-gtk-3-tutorial.readthedocs.io/en/latest/install.html](https://python-gtk-3-tutorial.readthedocs.io/en/latest/install.html)
    for the latest updates and information on installation.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the official website advises users to install
    GTK+3 through JHBuild. However, users have experienced a compatibility issue with
    JHBuild with the macOS El Capitan.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend macOS users to use the package manager `brew` to install GTK+3.
  prefs: []
  type: TYPE_NORMAL
- en: 'GTK+3 can be installed simply if you have `brew` installed in your macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For Linux systems such as Ubuntu, GTK+3 is installed by default. For sophisticated
    and advanced users who prefer a more customized approach to installing GTK+3,
    we encourage referring their website to obtain the most recently updated information.
  prefs: []
  type: TYPE_NORMAL
- en: We have observed that GTK+3 visualization is not as compatible with IPython
    Notebook. We encourage you to run the code on the Terminal for best results.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to GTK+3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before exploring the various examples and applications, let's first acquire
    a brief, high-level understanding of the GTK+3.
  prefs: []
  type: TYPE_NORMAL
- en: GTK+3 contains a set of graphical control elements (widgets) and is a highly
    usable, feature-rich toolkit used to develop graphical user interfaces. It has
    cross-platform compatibility and is relatively easy to use. GTK+3 is an object-oriented
    widget toolkit written in the C programming language. Therefore, when running GTK+3 in
    Python, we need a wrapper to call the functions in the GTK+3 library. In this
    case, PyGObject is a Python module that serves as the wrapper and saves us time
    by not having to learn two languages to plot our figures. PyGObject exclusively
    supports GTK+3 or later versions. If you prefer to use GTK+2 in your application,
    we recommend using PyGTK instead.
  prefs: []
  type: TYPE_NORMAL
- en: Together with the Glade GUI builder, they provide a very powerful application
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the GTK+3 signal system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GTK+3 is an event-driven toolkit, which means it is always dormant in a loop
    function and waiting (*listening*) for events to occur; then it passes control
    to the appropriate function. Examples of events are a click on a button, menu
    item activation, ticking a checkbox, and so forth. When widgets receive an event,
    they frequently emit one or more signals. That signal will then evoke functions
    that you have connected to, in this case known as **callbacks**. This passing
    of control is done using the concept of signals.
  prefs: []
  type: TYPE_NORMAL
- en: Although the terminology is almost identical, GTK+3 signals are not the same
    as Unix system signals and are not implemented using them.
  prefs: []
  type: TYPE_NORMAL
- en: When an *event* such as the press of a mouse button occurs, the appropriate
    signal is emitted by the click that received the widget. This is one of the most
    important parts of how GTK+3 works. There are signals that all widgets inherit,
    such as *destroy* and *delete-event*, and there are signals that are widget-specific,
    such as toggling on a toggle button. To make the signal framework functional,
    we need to set up a signal handler to catch those signals and call the appropriate
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a more abstract point of view, a generic example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`widget`, shown in this generic example, is an instance of a widget we created
    earlier. It can display widgets, buttons, toggles, or text data entry. Each widget
    has its own particular *event* that must occur for it to respond. If the widget
    is a button, and when there is an action such as a click, a signal is issued.
    The `callback` argument is the name of the callback function. The callback function
    will be executed when the *event* has occurred. Finally, the `data` argument includes
    any data that should be passed when the signal is generated; this is optional
    and can be left out if the *callback* function requires no argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our first sample of GTK+3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this code, readers can either copy and paste or it save the code into
    a file named `first_gtk_example.py` and run it in the Terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The readers should be able to create an empty 200x200 pixel window (by default
    when not specified otherwise), shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493616a6-4cd9-4193-810a-ea81267cca2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: To fully appreciate the usefulness of GTK3+, it is advisable that the code be
    written as a PyGObject.
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates a modified, slightly more complicated example
    of having two click buttons in one window, each performing different tasks!
  prefs: []
  type: TYPE_NORMAL
- en: 'Readers should install `cairocffi` through `pip3` before running the examples
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip3 install cairocffi`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cairocffi` library is a CFFI-based drop-in replacement for Pycairo, and
    is necessary in this case. Now let''s delve into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what you will get from the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae3098a5-3f23-45af-b106-f9d3590881e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on different buttons will result in obtaining different outcomes on
    the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: This example serves as an introduction to the **object-oriented programming**
    (**OOP**) style. OOP is fairly sophisticated for novice users, yet it is one of
    the best ways to arrange one's code, create modules, and make it more readable
    and usable for other programmers. Although novice users may not have noticed,
    we have already used a lot of OOP concepts in the first four chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'By understanding `init()` and `self`, we are now ready to delve into more advanced
    programming skills. So, let''s try some more advanced examples! What if we want
    to embed some of the plots we have made into GTK+3 windows? We do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we created a vertical box and put both the canvas (with the
    figure) and the toolbar in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7182defa-8f5b-48ed-a084-824a35763ff8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: It seems like it is fairly easy to incorporate Matplotlib figures right into
    GTK+3, doesn't it? If you have your own figure that you wish to plug it into the
    GTK+3 engine, simply expand on the *polar* plot example and then you can start
    playing with your own figure with this template!
  prefs: []
  type: TYPE_NORMAL
- en: One additional thing we did here is create a toolbar and put it at the bottom
    of the figure. Remember that we are using a VBox in organizing the widgets? V
    in this case stands for vertical, which organizes data from top to bottom. Therefore,
    when putting the toolbar after the canvas, we have such an ordering. The toolbar
    is a great place to modify and save your figures elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: So let's try a few more examples and see how we can create some interactive
    plots by combining GTK+3 and Matplotlib. One very important concept is event connections
    with Matplotlib through canvas; this can be achieved by calling the `mpl_connect()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: There are many good examples that can be found on the *Matplotlib Cookbook*
    online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through one such example that provides an interactive zoom-in function.
    Here is a preview of the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/435f4e70-5bc8-43c8-b69b-037481518c5c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: The window comprises two subplots; the plot on the left side is the big picture,
    while the plot on the right side is the zoomed-in version. The area chosen for
    enlargement is designated by the gray box on the left, and the gray box is movable
    along the click of your mouse. This may sound complicated but it can easily be
    accomplished by just a few lines of code. We would suggest readers first read
    the following code featuring the class `DrawPoints` and try to trace the logic
    starting from `window = Gtk.Window()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an in-depth explanation of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding example, event handling and picking are the
    elements that makes the interaction part much easier than we imagine. Therefore,
    it is important to have a quick review of the available event connections that
    are part of the `FigureCanvasBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event name** | **Class and description** |'
  prefs: []
  type: TYPE_TB
- en: '| `button_press_event` | **MouseEven****t:** Mouse button is pressed |'
  prefs: []
  type: TYPE_TB
- en: '| `button_release_event` | **MouseEvent**: Mouse button is released |'
  prefs: []
  type: TYPE_TB
- en: '| `scroll_event` | **MouseEvent**: Mouse scroll wheel is rolled |'
  prefs: []
  type: TYPE_TB
- en: '| `motion_notify_event` | **MouseEvent:** Mouse motion |'
  prefs: []
  type: TYPE_TB
- en: '| `draw_event` | **DrawEvent**: Canvas draw |'
  prefs: []
  type: TYPE_TB
- en: '| `key_press_event` | **KeyEvent:** Key is pressed |'
  prefs: []
  type: TYPE_TB
- en: '| `key_release_event` | **KeyEvent:** Key is released |'
  prefs: []
  type: TYPE_TB
- en: '| `pick_event` | **PickEvent:** An object in the canvas is selected |'
  prefs: []
  type: TYPE_TB
- en: '| `resize_event` | **ResizeEvent:** Figure canvas is resized |'
  prefs: []
  type: TYPE_TB
- en: '| `figure_enter_event` | **LocationEvent:** Mouse enters a new figure |'
  prefs: []
  type: TYPE_TB
- en: '| `figure_leave_event` | **LocationEvent:** Mouse leaves a figure |'
  prefs: []
  type: TYPE_TB
- en: '| `axes_enter_event` | **LocationEvent:** Mouse enters a new axis |'
  prefs: []
  type: TYPE_TB
- en: '| `axes_leave_event` | **LocationEvent:** Mouse leaves an axis |'
  prefs: []
  type: TYPE_TB
- en: Installing Glade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Glade is very straightforward; you can either obtain the source
    file from its web page, or simply use Git to obtain the latest version of source
    code. Here is the command for obtaining Glade through Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Designing the GUI using Glade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Designing the GUI using Glade is straightforward. Just start the Glade program
    and you will see this interface (from macOS, or something similar if using another
    OS):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44defb87-3489-41e2-b548-8f4065c1da2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explore the Glade interface. There are four main buttons that we
    will be using primarily in Glade; **Toplevels**, **Containers**, **Control**, and **Display**.
    The preceding screenshot shows that `GtkWindow` is listed in `Toplevels`, which
    serves as the basic unit for construction. Let''s click on `GtkWindow` and see
    the resulting action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69fd8b1c-76b5-4c31-aa33-f3ba79dcbcc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: 'Now a GtkWindow is being constructed and nothing is inside. Let''s set the
    size of this GtkWindow to: 400x400\. This can be achieved by setting the default
    width and height as 400 in the lower section of the right panel. The right panel
    is currently illustrating the **General** properties of this GtkWindow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we used vertical boxes a lot in the previous examples? Let''s
    add a vertical box to the GtkWindow! This can be achieved by clicking on **Containers** and
    choosing GtkBox, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d4d5098-80b6-4b3b-8625-a29bcf3520aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing GtkBox, click on the GtkWindow in the middle panel and a GtkBox
    will be created as a sub-module or a sub-window of the GtkWindow. This can be
    confirmed by checking the left panel as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f42ac166-7752-4787-bde8-08c29974d75f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8
  prefs: []
  type: TYPE_NORMAL
- en: 'GtkBox is below GtkWindow and indented on the left panel. Since we are picking
    vertical box, the *orientation* in **General** is *vertical*. One can even specify
    the spacing and number of items that will be included in the GtkBox. Let''s add
    a menu bar onto the top vertical box. This can be done as shown in *Figure 9*.
    In Containers, pick GtkMenubar and click on the top vertical box. It will fit
    in a menu bar with the following options: File, Edit, View, and Help.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6a0395-6a49-42a7-bc87-e02fe7ac1645.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9
  prefs: []
  type: TYPE_NORMAL
- en: As one can imagine, we can easily design our favorite GUI with the use of Glade.
    We can import a label with a customized size as shown in *Figure 10*. And there
    are many more options that we can choose to customize our GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bf02ba5-db87-4d58-b760-84402d510b43.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10
  prefs: []
  type: TYPE_NORMAL
- en: Designing the most effective GUI through Glade is beyond the scope and purview
    of this book, so we will not go any further into the more advanced options in
    Glade.
  prefs: []
  type: TYPE_NORMAL
- en: However, we would like to expand on one of the examples that we have worked
    on previously, and show that it takes just a few lines of code to incorporate
    a Glade-based GUI into our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we will use the class-based polar plot example. First of all, we design
    the most basic `GtkWindow` with a size of 400x400 (that's all!) from Glade and
    save it as a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is very simple and self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Readers may understand that we just created a `GtkWindow` with a size of 400x400
    plus a child as `GtkScrolledWindow`. This can be completed in a few clicks in
    Glade.
  prefs: []
  type: TYPE_NORMAL
- en: And what we have to do now is use `Gtk.Builder()` to read the Glade file; everything
    will be constructed automatically. This actually saves us from defining all the
    elements of the vertical box!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates how we can use Glade to quickly generate a frame
    and execute it effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57c12f40-5eea-489d-8b6f-a089be59efa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, through this example readers would appreciate the power of Glade
    in enabling programmers to draw a GUI instead of abstracting it in code. This
    is particularly useful when the GUI gets complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have worked through examples on embedding Matplotlib figures
    inside a simple GTK+3 window, adding the Matplotlib navigation toolbar, plotting
    data in an interactive framework, and using Glade to design a GUI. We have kept
    the examples simple to highlight the important parts, but we encourage readers
    to explore further possibilities. GTK+3 is not the only GUI library that can be
    used. In the coming chapters, we'll see how to use two other important libraries!
  prefs: []
  type: TYPE_NORMAL
