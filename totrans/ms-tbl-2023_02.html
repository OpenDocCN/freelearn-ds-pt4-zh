<html><head></head><body>
<section epub:type="chapter">&#13;
<section id="ch02lvl1sec08">&#13;
<div class="epub-source">&#13;
<h1 class="chapterTitle">Getting Your Data Ready</h1>&#13;
<div class="Basic-Text-Frame">&#13;
    <p class="normal">Have you ever asked yourself whether your data is clean enough to be analyzed? It’s likely that everyone who works with data has, which is why this chapter is dedicated to getting your data ready for analysis, otherwise known as data cleaning.</p>&#13;
    <p class="normal">The first part of this chapter is theory-oriented and does not include exercises. A careful reading of this information is encouraged since it provides a foundation for greater insight. The latter portion of the chapter provides various exercises specifically focused on data preparation.</p>&#13;
    <p class="normal">Now let’s dive into this fascinating topic with the goal of enriching our understanding and becoming ever-better data stewards.</p>&#13;
    <p class="normal">In this chapter, we will discuss the following topics:</p>&#13;
    <ul><li class="bulletList">Understanding Hyper</li>&#13;
      <li class="bulletList">Focusing on data preparation</li>&#13;
      <li class="bulletList">Surveying data</li>&#13;
      <li class="bulletList">Cleaning messy data</li>&#13;
    </ul><p class="normal">Since Tableau Desktop 10.5 has been on the market for some time, you may already have heard of Hyper. Regardless of whether you have or not, continue reading for a primer on this feature!</p>&#13;
    </div>&#13;
</div>&#13;
</section>&#13;
<section id="ch02lvl1sec09">&#13;
<div class="epub-source">&#13;
<h1 class="heading-1">Understanding Hyper</h1>&#13;
<div class="Basic-Text-Frame">&#13;
    <p class="normal">In this section, we will explore Tableau’s data-handling engine, and how it enables structured yet organic <a/>data mining processes in enterprises. Since the release of Tableau 10.5, we can make use of Hyper, a high-performing database, allowing us to query source data faster than ever before. Hyper is usually not well understood, even by advanced developers, because it’s not an overt part of day-to-day activities; however, if you want to truly grasp how to prepare data for Tableau, this understanding is crucial.</p>&#13;
    <p class="normal">Hyper originally started as a research project at the University of Munich in 2008. In 2016, it was acquired by Tableau and appointed as the dedicated data engine group of Tableau, maintaining its base and employees in Munich. Initially in Tableau 10.5, Hyper replaced the earlier data-handling engine only for extracts. It is still true that live connections are not touched by Hyper, but Tableau Prep Builder now runs on the Hyper engine too, with more use cases to follow. As stated on <a href="http://tableau.com" target="_blank"><span class="url">tableau.com</span></a>, “<em class="italic">Hyper can slice and dice massive volumes of data in seconds, you will see up to 5X faster query speed and up to 3X faster extract creation speed</em>.” And if you still can’t get enough, there is always the option to use Hyper through API calls in your preferred programming language: <a href="https://help.tableau.com/current/api/hyper_api/en-us/docs/hyper_api_reference.html" target="_blank"><span class="url">https://help.tableau.com/current/api/hyper_api/en-us/docs/hyper_api_reference.html</span></a>.</p>&#13;
    <p class="normal">But what makes Hyper so fast? Let’s have a look under the hood!</p>&#13;
    <h2 class="heading-2">The Tableau data-handling engine</h2>&#13;
    <p class="normal">The vision shared by the founders of Hyper was to create a high-performing, next-generation database—one system, one state, no trade-offs, and no delays. And it worked—today, Hyper <a/>can serve general database <a/>purposes, data ingestion, and analytics at the same time.</p>&#13;
    <p class="normal">Memory prices have decreased exponentially. The same goes for CPUs; transistor counts increased according to Moore’s law, while other features stagnated. Memory is cheap but processing still needs to be improved.</p>&#13;
    <p class="normal">Moore’s Law is the observation made by Intel co-founder Gordon Moore that the number of transistors on a chip doubles every two years while the costs are halved. Information <a/>on Moore’s Law can be found on Investopedia at <a href="https://www.investopedia.com/terms/m/mooreslaw.asp" target="_blank"><span class="url">https://www.investopedia.com/terms/m/mooreslaw.asp</span></a>.</p>&#13;
    <p class="normal">While experimenting with Hyper, the founders measured that handwritten C code is faster than any existing database engine, so they came up with the idea to transform Tableau queries into C code and optimize it simultaneously, all behind the scenes, so the Tableau user won’t notice it. This translation and optimization come at a cost; traditional database engines can start executing code immediately. Tableau needs to first translate queries into code, optimize that code, then compile it into machine code, after which it can be executed. The big question is, is it still faster? As proven by many tests on Tableau Public and other workbooks, the answer is yes!</p>&#13;
    <p class="normal">Furthermore, if there is a query estimated to be faster if executed without the compilation to machine code, Tableau <a/>has its own <strong class="keyWord">virtual machine</strong> (<strong class="keyWord">VM</strong>) on which the query will <a/>be executed right away. And next to this, Hyper can utilize 99% of available CPU computing power, whereas other parallel <a/>processes can only utilize 29% of available CPU compute. This is due to the unique and innovative technique of morsel-driven parallelization.</p>&#13;
    <p class="normal">For those <a/>of you that want to know more about morsel-driven parallelization, a paper, which later on served as a baseline for the Hyper engine, can be found at <a href="https://15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf" target="_blank"><span class="url">https://15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf</span></a>.</p>&#13;
    <p class="normal">If you want <a/>to know more about the Hyper engine, I highly recommend the following video at <a href="https://youtu.be/h2av4CX0k6s" target="_blank"><span class="url">https://youtu.be/h2av4CX0k6s</span></a>.</p>&#13;
    <p class="normal">Hyper parallelizes <a/>three steps of traditional data <a/>warehousing operations:</p>&#13;
    <ul><li class="bulletList">Transactions <a/>and <strong class="keyWord">Continuous Data Ingestion</strong> (<strong class="keyWord">Online Transaction Processing</strong>, or <strong class="keyWord">OLTP</strong>)</li>&#13;
      <li class="bulletList"><strong class="keyWord">Analytics</strong> (<strong class="keyWord">Online Analytical Processing</strong>, or <strong class="keyWord">OLAP</strong>)</li>&#13;
      <li class="bulletList"><strong class="keyWord">Beyond Relational</strong> (<strong class="keyWord">Online Beyond Relational Processing</strong>, or <strong class="keyWord">OBRP</strong>)</li>&#13;
    </ul><p class="normal">Executing those <a/>steps simultaneously makes Hyper more efficient and more performant, as opposed to traditional systems where those three steps are separated and executed one after the other.</p>&#13;
    <p class="normal">To sum up, Hyper is a highly specialized database engine that allows us as users to get the best out of our queries. If you recall, in <em class="chapterRef">Chapter 1</em>, <em class="italic">Reviewing the Basics</em>, we already saw that every change on a sheet or dashboard, including drag and drop pills, filters, and calculated fields, among others, is translated into a query. Those queries are pretty much SQL lookalikes; however, in Tableau we call the querying engine VizQL.</p>&#13;
    <p class="normal">VizQL, another <a/>hidden gem on your Tableau Desktop, is responsible for visualizing data in a chart format and is fully executed in memory. The <a/>advantage is that no additional space on the database side is required here. VizQL is generated when a user places a field on a shelf. VizQL is then <a/>translated into SQL, MDX, or <strong class="keyWord">Tableau Query Language</strong> (<strong class="keyWord">TQL</strong>) and passed to the backend data source with a driver.</p>&#13;
    <h2 class="heading-2">Hyper takeaways</h2>&#13;
    <p class="normal">This overview of the Tableau data-handling engine demonstrates a flexible approach to interfacing with data. Knowledge of the data-handling engine can reduce data preparation <a/>and data modeling efforts, thus helping us streamline the overall data mining life cycle. Don’t worry too much about data types and data that can be calculated based on the fields you have in your database. Tableau can do all the work for you in this respect. In the next section, we will discuss what you should consider from a data source perspective.</p>&#13;
    </div>&#13;
</div>&#13;
</section>&#13;
<section id="ch02lvl1sec10">&#13;
<div class="epub-source">&#13;
<h1 class="heading-1">Focusing on data preparation</h1>&#13;
<div class="Basic-Text-Frame">&#13;
    <p class="normal">Tableau can be used effectively with various data preparation phases. Unfortunately, a single chapter <a/>is not sufficient to thoroughly explore how Tableau can be used in each phase. Indeed, such a thorough exploration may be worthy of an entire book! Our focus, therefore, will be directed to ward data preparation, since that phase has historically accounted for up to 60% of the data mining effort. Our goal will be to learn how Tableau can be used to streamline that effort.</p>&#13;
    <h2 class="heading-2">Surveying data</h2>&#13;
    <p class="normal">Tableau can be a very effective tool for simply surveying data. Sometimes in the survey process, you may <a/>discover ways to clean the data or populate incomplete data based on existing fields. Sometimes, regretfully, there are simply not enough pieces of the puzzle to put together an entire dataset. In such cases, Tableau can be useful to communicate exactly what the gaps are, and this, in turn, may incentivize the organization to more fully populate the underlying data.</p>&#13;
    <p class="normal">In this exercise, we will explore how to use Tableau to quickly discover the percentage of null values for each field in a dataset. Next, we’ll explore how data might be extrapolated from existing fields to fill in the gaps.</p>&#13;
    <h3 class="heading-3">Establishing null values</h3>&#13;
    <p class="normal">The following <a/>are the steps to survey the data:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="1">If you haven’t done so just yet, navigate to <a href="https://public.tableau.com/profile/marleen.meier" target="_blank"><span class="url">https://public.tableau.com/profile/marleen.meier</span></a> to locate and download the workbook associated with this chapter.</li>&#13;
      <li class="numberedList">Navigate to the worksheet entitled <code class="inlineCode">Surveying</code> <code class="inlineCode">&amp;</code> <code class="inlineCode">Exploring</code><strong class="bold-italic" style="font-style: italic;"> </strong><code class="inlineCode">Data</code> and select <code class="inlineCode">Happiness Report </code>data source.</li>&#13;
      <li class="numberedList">Drag <strong class="screenText">Region</strong> and <strong class="screenText">Country</strong> to the <strong class="screenText">Rows</strong> shelf. Observe that in some cases the <strong class="screenText">Region</strong> field has <strong class="screenText">Null</strong> values for some countries:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_01.png" alt=""/></figure><p class="packt_figref">Figure 2.1: Null regions</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="4">Right-click and <strong class="screenText">Edit</strong> the parameter entitled <code class="inlineCode">Select Field</code>. Note that the <strong class="screenText">Data Type</strong> is set to <strong class="screenText">Integer</strong> and we can observe a list that contains an entry for each field name in the dataset:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_02.png" alt="Graphical user interface&#13;&#10;&#13;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.2: Editing a parameter</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="5">In the <strong class="keyWord">Data</strong> pane, right-click on the parameter we just created and select <strong class="keyWord">Show Parameter </strong>Control.</li>&#13;
      <li class="numberedList">Create a <a/>calculated field entitled <code class="inlineCode">% Populated</code> and write the following calculation:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">SUM</span>([Number <span class="hljs-keyword">of</span> Records]) <span class="hljs-operator">/</span> TOTAL(<span class="hljs-built_in">SUM</span>([Number <span class="hljs-keyword">of</span> Records]))&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">In the <strong class="screenText">Data</strong> pane, right-click on <strong class="screenText">% Populated</strong> and select <strong class="screenText">Default Properties</strong> | <strong class="screenText">Number Format…</strong>:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_03.png" alt="Graphical user interface, application&#13;&#10;&#13;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.3: Adjusting default properties</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="8">In the resulting dialog box, choose <strong class="keyWord">Percentage</strong>.</li>&#13;
      <li class="numberedList">Create a calculated field entitled <code class="inlineCode">Null &amp; Populated</code> and add the following code. Note that the complete case statement is fairly lengthy but also repetitive.&#13;
    <div class="note">&#13;
      <p class="normal">In cases requiring a lengthy but repetitive calculation, consider using Excel to more quickly and accurately write the code. By using Excel’s <code class="inlineCode">CONCATENATE</code> function, you may be able to save time and avoid typos.</p>&#13;
    </div>&#13;
    <p class="normal">In the <a/>following code block, the code lines represent only a percentage of the total but should be sufficient to enable you to produce the whole block:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">CASE</span> [<span class="hljs-keyword">Select</span> Field]&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Country]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Region]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'</span><span class="hljs-string">Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Economy (GDP <span class="hljs-keyword">per</span> Capita)]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Family]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">5</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Freedom]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">6</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Happiness Rank]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">7</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Happiness Score]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">8</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Health (Life Expectancy)]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">9</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Standard Error]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
<span class="hljs-keyword">END</span>&#13;
</code></pre></li>&#13;
    </ol><ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="10">Remove <strong class="keyWord">Region</strong> and <strong class="keyWord">Country</strong> from the <strong class="keyWord">Rows</strong> shelf.</li>&#13;
      <li class="numberedList">Place <strong class="screenText">Null &amp; Populated</strong> on the <strong class="screenText">Rows</strong> and <strong class="screenText">Color</strong> shelves and <strong class="screenText">% Populated</strong> on the <strong class="screenText">Columns</strong> and <strong class="screenText">Label</strong> shelves:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_04.png" alt=""/></figure><p class="packt_figref">Figure 2.4: Populated values</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="12">Change the colors to red for <strong class="screenText">Null Values</strong> and green for <strong class="screenText">Populated Values</strong> if desired. You can do so by clicking on <strong class="screenText">Color</strong> in the <strong class="screenText">Marks</strong> card and <strong class="screenText">Edit Colors</strong>.</li>&#13;
      <li class="numberedList">Click on <a/>the arrow in the upper-right corner of the <strong class="screenText">Select Field</strong> parameter on your sheet and select <strong class="screenText">Single Value List</strong>.</li>&#13;
      <li class="numberedList">Select various choices in the <strong class="screenText">Select Field</strong> parameter and note that some fields have a high percentage of null values. For example, in the following diagram, <strong class="screenText">32.98%</strong> of records do not have a value for <strong class="screenText">Region</strong>:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_05.png" alt="A picture containing graphical user interface&#13;&#10;&#13;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.5: Comparing null and populated values</p>&#13;
    <p class="normal">Building on this exercise, let’s explore how we might clean and extrapolate data from existing data using the same dataset.</p>&#13;
    <h3 class="heading-3">Extrapolating data</h3>&#13;
    <p class="normal">This exercise will expand on the previous exercise by cleaning existing data and populating <a/>some of the missing data from known information. We will assume that we know which country belongs to which region. We’ll use that knowledge to fix errors in the <code class="inlineCode">Region</code> field and also to fill in the gaps using Tableau:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="1">Starting from where the previous exercise ended, create a calculated field entitled <code class="inlineCode">Region Extrapolated</code> with the following code block:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">CASE</span> [Country]&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Afghanistan'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Southern Asia'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Albania'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Central and Eastern Europe'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'</span><span class="hljs-string">Algeria'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Middle East and Northern Africa'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Angola'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Sub-Saharan Africa'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Argentina'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'</span><span class="hljs-string">Latin America and Caribbean'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Armenia'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Central and Eastern Europe'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Australia'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Australia and New Zealand'</span>&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'</span><span class="hljs-string">Austria'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Western Europe'</span>&#13;
<span class="hljs-operator">//</span>complete the <span class="hljs-keyword">case</span> statement <span class="hljs-keyword">with</span> the remaining fields <span class="hljs-keyword">in</span> the data <span class="hljs-keyword">set</span>&#13;
<span class="hljs-keyword">END</span>&#13;
</code></pre>&#13;
      &#13;
    <div class="note">&#13;
      <p class="normal">As an alternative to a <code class="inlineCode">CASE</code> statement, you could use an <code class="inlineCode">IF</code> statement like:</p>&#13;
      <pre class="programlisting gen"><code class="hljs">If [Country] <span class="hljs-operator">=</span> <span class="hljs-string">'Afghanistan'</span> <span class="hljs-keyword">then</span> <span class="hljs-string">'Southern Asia'</span> &#13;
ELSEIF [Country] <span class="hljs-operator">=</span> <span class="hljs-string">'Albania'</span> <span class="hljs-keyword">then</span> …&#13;
<span class="hljs-keyword">END</span>&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">To speed up the tedious creation of a long calculated field, you could download the data to an Excel file and create the calculated field by concatenating the separate parts, as shown here:</p>&#13;
    <figure class="mediaobject"><img src="../images/B18435_02_06.png" alt="Graphical user interface, text, application&#13;&#10;&#13;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.6: Compiling a calculation in Excel</p>&#13;
    <p class="normal">You can <a/>then copy them from Excel into Tableau. However, for this exercise, I have created a backup field called <code class="inlineCode">Backup</code>, which can be found in the Tableau workbook associated with this chapter, which contains the full calculation needed for the <code class="inlineCode">Region Extrapolated</code> field. Use this at your convenience. The <strong class="keyWord">Solutions</strong> dashboard also contains all of the countries. You can therefore copy the <code class="inlineCode">Region Extrapolated</code> field from that file too.</p></li>&#13;
    </ol><ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="2">Add a <strong class="keyWord">Region Extrapolated</strong> option to the <strong class="keyWord">Select Field</strong> parameter:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_07.png" alt=""/></figure><p class="packt_figref">Figure 2.7: Adding Region Extrapolated to the parameter</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="3">Add the <a/>following code to the <code class="inlineCode">Null &amp; Populated</code> calculated field:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">WHEN</span> <span class="hljs-number">10</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Region Extrapolated]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Note that the <strong class="screenText">Region Extrapolated</strong> field is now fully populated:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_08.png" alt=""/></figure><p class="packt_figref">Figure 2.8: Fully populated Region Extrapolated field</p>&#13;
    <p class="normal">Now let’s consider some of the specifics from the previous exercises.</p>&#13;
    <p class="normal">Let’s look at the following code block.</p>&#13;
    <p class="normal">Note that the complete <code class="inlineCode">CASE</code> statement is several lines long. The following is a representative portion:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">CASE</span> [<span class="hljs-operator">%</span> Populated]&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> IF ISNULL ([Country]) <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Null Values'</span> <span class="hljs-keyword">ELSE</span>&#13;
<span class="hljs-string">'Populated Values'</span> <span class="hljs-keyword">END</span>&#13;
...&#13;
</code></pre>&#13;
    <p class="normal">This case statement is a row-level calculation that considers each field in the dataset and determines which rows are populated and which are not. For example, in the representative <a/>line of the preceding code, every row of the <code class="inlineCode">Country</code> field is evaluated for nulls. The reason for this is that a calculated field will add a new column to the existing data—only in Tableau, not in the data source itself—and every row will get a value. These values can be N/A or null values.</p>&#13;
    <p class="normal">The following code is the equivalent of the quick table calculation <code class="inlineCode">Percent of Total</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">SUM</span>([Number <span class="hljs-keyword">of</span> Records]) <span class="hljs-operator">/</span> TOTAL(<span class="hljs-built_in">SUM</span>([Number <span class="hljs-keyword">of</span> Records]))&#13;
</code></pre>&#13;
    <p class="normal">In conjunction with the <code class="inlineCode">Null &amp; Populated</code> calculated field, it allows us to see what percentage of our fields are actually populated with values.</p>&#13;
    <p class="normal">It’s a good idea to get into the habit of writing table calculations from scratch, even if an equivalent quick table calculation is available. This will help you more clearly understand the table calculations.</p>&#13;
    <p class="normal">The following CASE statement is an example of how you might use one or more fields to extrapolate what another field should be:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">CASE</span> [Country]&#13;
<span class="hljs-keyword">WHEN</span> <span class="hljs-string">'Afghanistan'</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">'Southern Asia'</span>&#13;
... <span class="hljs-keyword">END</span>&#13;
</code></pre>&#13;
    <p class="normal">For example, the <code class="inlineCode">Region</code> field in the dataset had a large percentage of null values, and even the existing data had errors. Based on our knowledge of the business (that is, which country belongs to which region), we were able to use the <code class="inlineCode">Country</code> field to achieve 100% population of the dataset with accurate information.</p>&#13;
    <p class="normal">Nulls are a part of almost every extensive real dataset. Understanding how many nulls are present in each field can be vital to ensuring that you provide accurate business intelligence. It may be acceptable to tolerate some null values when the final results will not be <a/>substantially impacted, but too many nulls may invalidate results. However, as demonstrated here, in some cases, one or more fields can be used to extrapolate the values that should be entered into an underpopulated or erroneously populated field.</p>&#13;
    <p class="normal">As demonstrated in this section, Tableau gives you the ability to effectively communicate to your data team which values are missing, which are erroneous, and how possible workarounds can be invaluable to the overall data mining effort. Next, we will look into data that is a bit messier and not in a nice column format. Don’t worry, Tableau has us covered.</p>&#13;
    <h2 class="heading-2">Cleaning messy data</h2>&#13;
    <p class="normal">The United States <a/>government provides helpful documentation <a/>for various bureaucratic processes. For example, the <strong class="keyWord">Department of Health and Human Services</strong> (<strong class="keyWord">HSS</strong>) provides lists of ICD-9 codes, otherwise known as International Statistical Classification of Diseases and Related Health Problems codes. Unfortunately, these codes are not always in easily accessible formats.</p>&#13;
    <p class="normal">As an example, let’s <a/>consider an actual HHS document known as R756OTN, which can be found at <a href="https://www.cms.gov/Regulations-and-Guidance/Guidance/Transmittals/downloads/R756OTN.pdf" target="_blank"><span class="url">https://www.cms.gov/Regulations-and-Guidance/Guidance/Transmittals/downloads/R756OTN.pdf</span></a>.</p>&#13;
    <h3 class="heading-3">Cleaning the data</h3>&#13;
    <p class="normal">Navigate to the <code class="inlineCode">Cleaning the Data</code> worksheet in the workbook accompanying this chapter and execute the following steps:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="1">Within the <strong class="screenText">Data</strong> pane, select the <strong class="screenText">R756OTN Raw</strong> data source: </li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_09.png" alt="Graphical user interface, text, application&#13;&#10;&#13;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.9: Selecting the raw file</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="2">Drag <strong class="screenText">Diagnosis</strong> to <a/>the <strong class="screenText">Rows</strong> shelf and choose <strong class="screenText">Add all members</strong>. Click on the <strong class="keyWord">AZ</strong> sign to sort the <strong class="keyWord">Diagnosis</strong> column. Note the junk data that occurs in some rows:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_10.png" alt=""/></figure><p class="packt_figref">Figure 2.10: Adding Diagnosis to Rows</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="3">Create a <a/>calculated field named <code class="inlineCode">DX</code> with the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code">SPLIT([Diagnosis], " ", <span class="hljs-number">1</span>)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Create a calculated field named <code class="inlineCode">Null Hunting</code> with the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">INT</span>(MID([DX],<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">In the <strong class="screenText">Data</strong> pane, drag <code class="inlineCode">Null Hunting</code> from <strong class="screenText">Measures</strong> to <strong class="screenText">Dimensions</strong>.</li>&#13;
      <li class="numberedList">Drag <strong class="keyWord">Diagnosis</strong>, <strong class="keyWord">DX</strong>, and <strong class="keyWord">Null Hunting</strong> to the <strong class="keyWord">Rows</strong> shelf. Observe that <strong class="keyWord">Null</strong> is returned when the second character in the <strong class="keyWord">Diagnosis</strong> field is not numeric:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_11.png" alt=""/></figure><p class="packt_figref">Figure 2.11: Ordering fields on Rows</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="7">Create a <a/>calculated field named <code class="inlineCode">Exclude from ICD codes</code> containing the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code">ISNULL([<span class="hljs-keyword">Null</span> Hunting])&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Clear the sheet of all fields, as demonstrated in <em class="chapterRef">Chapter 1</em>, <em class="italic">Reviewing the Basics</em>, and set the <strong class="keyWord">Marks</strong> card to <strong class="keyWord">Shape</strong>.</li>&#13;
      <li class="numberedList">Place <strong class="screenText">Exclude from ICD Codes</strong> on the <strong class="screenText">Color</strong>, and <strong class="screenText">Shape</strong> shelves, and then place <strong class="screenText">DX</strong> on the <strong class="screenText">Rows</strong> shelf. Observe the rows labeled as <strong class="screenText">True</strong>:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_12.png" alt=""/></figure><p class="packt_figref">Figure 2.12: Excluding junk data</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="10">In order <a/>to exclude the junk data (that is, those rows where <code class="inlineCode">Exclude from ICD Codes</code> equates to <code class="inlineCode">True</code>), place <code class="inlineCode">Exclude from ICD Codes</code> on the <strong class="keyWord">Filter</strong> shelf and deselect <strong class="screenText">True</strong>.</li>&#13;
      <li class="numberedList">Create a calculated field named <code class="inlineCode">Diagnosis Text</code> containing the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code">REPLACE([Diagnosis],[DX] <span class="hljs-operator">+</span> "","")&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Place <strong class="screenText">Diagnosis Text</strong> on the <strong class="screenText">Rows</strong> shelf after <strong class="screenText">DX</strong>. Also, remove <strong class="screenText">Exclude from ICD Codes</strong> from the <strong class="screenText">Rows</strong> shelf and the <strong class="screenText">Marks </strong>card, and set the mark type to <strong class="screenText">Automatic</strong>:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_13.png" alt=""/></figure><p class="packt_figref">Figure 2.13: Observing the cleaned data</p>&#13;
    <p class="normal">Now that <a/>we’ve completed the exercise, let’s take a moment to consider the code we have used:</p>&#13;
    <ul><li class="bulletList">The <code class="inlineCode">SPLIT</code> function was introduced in Tableau 9.0:&#13;
        <pre class="programlisting code"><code class="hljs-code">SPLIT([Diagnosis], " ", <span class="hljs-number">1</span>)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">As described in Tableau’s help documentation about the function, the function does the following:</li>&#13;
    </ul><p class="normal"><em class="italic">Returns a substring from a string, as determined by the delimiter extracting the characters from the beginning or end of the string</em>.</p>&#13;
    <ul><li class="bulletList">This function can also be called directly in the <strong class="keyWord">Data Source</strong> tab when clicking on a column header and selecting <strong class="keyWord">Split</strong>. To extract characters from the end of the string, the token number (that is, the number at the end of the function) must be negative.</li>&#13;
      <li class="bulletList">Consider the following code, which we used to create the <code class="inlineCode">Null Hunting</code> field:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">INT</span>(MID([DX],<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">The use of <code class="inlineCode">MID</code> is quite straightforward and much the same as the corresponding function in Excel. The use of <code class="inlineCode">INT</code> in this case, however, may be confusing. Casting an alpha character with an <code class="inlineCode">INT</code> function will result in Tableau returning <code class="inlineCode">Null</code>. This satisfactorily fulfills our purpose, since we simply need to discover those rows not starting with an integer by locating the nulls.</li>&#13;
    </ul><ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="1"><code class="inlineCode">ISNULL</code> is a Boolean function that simply returns <code class="inlineCode">TRUE</code> in the case of <code class="inlineCode">Null</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code">ISNULL([<span class="hljs-keyword">Null</span> Hunting])&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">The <code class="inlineCode">REPLACE</code> function was used while creating the <code class="inlineCode">Diagnosis Text</code> field:&#13;
        <pre class="programlisting code"><code class="hljs-code">REPLACE([Diagnosis],[DX] <span class="hljs-operator">+</span> "","")&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">This calculated field uses the ICD-9 codes isolated in <code class="inlineCode">DX</code> to remove those same codes from the <code class="inlineCode">Diagnosis</code> field and thus provides a fairly clean description. Note the phrase <em class="italic">fairly clean</em>. The rows that were removed were initially associated with longer descriptions that thus included a carriage return. The resulting additional rows are what we removed in this exercise. Therefore, the longer descriptions are truncated in this solution using the <code class="inlineCode">replace</code> calculation.</li>&#13;
    </ol><p class="normal">The final output <a/>for this exercise could be to export the data from Tableau as an additional source of data. This data could then be used by Tableau and other tools for future reporting needs. For example, the <code class="inlineCode">DX</code> field could be useful in data blending.</p>&#13;
    <p class="normal">Does Tableau offer a better approach that might solve the issue of truncated data associated with the preceding solution? Yes! Let’s turn our attention to the next exercise, where we will consider regular expression functions.</p>&#13;
    <h3 class="heading-3">Extracting data</h3>&#13;
    <p class="normal">Although, as shown in the previous exercise, <em class="italic">Cleaning the data</em>, the <code class="inlineCode">SPLIT</code> function can be useful for cleaning <a/>clean data, regular expression functions are far more powerful, representing a broadening of the scope from Tableau’s traditional focus on visualization and analytics to also include data cleaning capabilities.</p>&#13;
    <p class="normal">Let’s look at an example that requires us to deal with some pretty messy data in Tableau. Our objective will be to extract phone numbers.</p>&#13;
    <p class="normal">The following are the steps:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="1">If you have not already done so, please download the workbook from <a href="https://public.tableau.com/profile/marleen.meier" target="_blank"><span class="url">https://public.tableau.com/profile/marleen.meier</span></a> and open it in Tableau.</li>&#13;
      <li class="numberedList">Select the <code class="inlineCode">Extracting the Data</code> tab.</li>&#13;
      <li class="numberedList">In the <strong class="screenText">Data</strong> pane, select the <strong class="screenText">String of Data</strong> data source and drag the <strong class="screenText">String of Data</strong> field to <a/>the <strong class="screenText">Rows</strong> shelf. Observe the challenges associated with extracting the phone numbers:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_14.png" alt=""/></figure><p class="packt_figref">Figure 2.14: Extracting data from a messy data format</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="4">Access the underlying data by clicking the <strong class="screenText">View data</strong> button and copying several rows:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_15.png" alt=""/></figure><p class="packt_figref">Figure 2.15: Accessing underlying data</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="5">Navigate to <a href="http://regexpal.com/" target="_blank"><span class="url">http://regexpal.com/</span></a> and <a/>paste the data into the pane labeled <strong class="screenText">Test String</strong>—that is, the second pane:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_16.png" alt="Graphical user interface, text, application, email&#13;&#10;&#13;&#10;Description automatically generated"/></figure><p class="packt_figref">Figure 2.16: Regexpal</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;"><li class="numberedList" value="6">In the <a/>first pane (the one labeled <strong class="keyWord">Regular Expression</strong>), type the following:&#13;
        <pre class="programlisting code"><code class="hljs-code">\([<span class="hljs-number">0-9</span>]{<span class="hljs-number">3</span>}\)<span class="hljs-operator">-</span>[<span class="hljs-number">0-9</span>]{<span class="hljs-number">3</span>}<span class="hljs-operator">-</span>[<span class="hljs-number">0-9</span>]{<span class="hljs-number">4</span>}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Return to Tableau and create a calculated field called <code class="inlineCode">Phone Number</code> with the following code block. Note the regular expression nested in the calculated field:&#13;
        <pre class="programlisting code"><code class="hljs-code">REGEXP_EXTRACT([String <span class="hljs-keyword">of</span> Data (String <span class="hljs-keyword">of</span> Data)],<span class="hljs-string">'(\([0-9]{3}\)-[0-9]{3}-[0-9]{4})'</span>)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Place <strong class="keyWord">Phone Number</strong> on the <strong class="keyWord">Rows</strong> shelf, and observe the result:</li>&#13;
    </ol><figure class="mediaobject"><img src="../images/B18435_02_17.png" alt="Text&#13;&#10;&#13;&#10;Description automatically generated with medium confidence"/></figure><p class="packt_figref">Figure 2.17: Extracting data final view</p>&#13;
    <p class="normal">Now let’s <a/>consider some of the specifics from the preceding exercise in more detail:</p>&#13;
    <ul><li class="bulletList">Consider the following code block:&#13;
        <pre class="programlisting code"><code class="hljs-code">REGEXP_EXTRACT([String <span class="hljs-keyword">of</span> Data],<span class="hljs-string">'()'</span>)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">The expression pattern is purposely excluded here as it will be covered in detail later. The ‘<code class="inlineCode">()</code>' code acts as a placeholder for the expression pattern. The <code class="inlineCode">REGEXP_EXTRACT</code> function used in this example is described in Tableau’s help documentation as follows:</li>&#13;
    </ul><p class="normal"><em class="italic">Returns a substring of the given string that matches the capturing group within the regular expression pattern.</em></p>&#13;
    <ul><li class="bulletList">Note that as of the time of writing, the Tableau documentation does not communicate how to ensure that the pattern input section of the function is properly delimited. For this example, be sure to include ‘<code class="inlineCode">()</code>' around the pattern input section to avoid a null output.</li>&#13;
      <li class="bulletList">Nesting within a calculated field that is itself nested within a <code class="inlineCode">VizQL</code> query can affect performance (if there are too many levels of nesting/aggregation).</li>&#13;
      <li class="bulletList">There are numerous regular expression websites that allow you to enter your own code and help you out, so to speak, by providing immediate feedback <a/>based on sample data that you provide. <a href="http://regexpal.com/" target="_blank"><span class="url">http://regexpal.com/</span></a> is only one of those sites, so search as desired to find one that meets your needs!</li>&#13;
      <li class="bulletList">Now, consider the expression:&#13;
        <pre class="programlisting code"><code class="hljs-code">\([<span class="hljs-number">0-9</span>]{<span class="hljs-number">3</span>}\)<span class="hljs-operator">-</span>[<span class="hljs-number">0-9</span>]{<span class="hljs-number">3</span>}<span class="hljs-operator">-</span>[<span class="hljs-number">0-9</span>]{<span class="hljs-number">4</span>}&#13;
</code></pre>&#13;
      </li>&#13;
    </ul><p class="normal">In this context, the <code class="inlineCode">\</code> indicates that the next character should not be treated as special but as literal. For our example, we are literally looking for an open parenthesis. <code class="inlineCode">[0-9]</code> simply declares that we are looking for one or more digits. Alternatively, consider <code class="inlineCode">\d</code> to achieve the same results. The <code class="inlineCode">{3}</code> designates that we are looking for three consecutive digits.</p>&#13;
    <p class="normal">As with the opening parenthesis at the beginning of the pattern, the <code class="inlineCode">\</code> character designates the closing parentheses as a literal. The <code class="inlineCode">-</code> is a literal that specifically looks for a hyphen. The rest of the expression pattern should be decipherable based on the preceding information.</p>&#13;
    <p class="normal">After reviewing <a/>this exercise, you may be curious about how to return just the email address. According to <a href="http://www.regular-expressions.info/email.html" target="_blank"><span class="url">http://www.regular-expressions.info/email.html</span></a>, the regular expression for email addresses adhering to the RFC 5322 standard is as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">(?:[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span><span class="hljs-operator">!</span>#$<span class="hljs-operator">%&amp;</span><span class="hljs-string">'*+/=?^_'{|}~-]+(?:\.[a-z0-9!#$%&amp;'</span><span class="hljs-operator">*+/=</span>?<span class="hljs-operator">^</span>_'{<span class="hljs-operator">|</span>}<span class="hljs-operator">~-</span>&#13;
]<span class="hljs-operator">+</span>)<span class="hljs-operator">*|</span>"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-&#13;
\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span>](?:[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span><span class="hljs-operator">-</span>&#13;
]<span class="hljs-operator">*</span>[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span>])?\.)<span class="hljs-operator">+</span>[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span>](?:[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span><span class="hljs-operator">-</span>]<span class="hljs-operator">*</span>[a<span class="hljs-operator">-</span>&#13;
z0<span class="hljs-number">-9</span>])?<span class="hljs-operator">|</span>\[(?:(?:<span class="hljs-number">25</span>[<span class="hljs-number">0-5</span>]<span class="hljs-operator">|</span><span class="hljs-number">2</span>[<span class="hljs-number">0-4</span>][<span class="hljs-number">0-9</span>]<span class="hljs-operator">|</span>[<span class="hljs-number">01</span>]?[<span class="hljs-number">0-9</span>][<span class="hljs-number">0-9</span>]?)\.){<span class="hljs-number">3</span>}(?:<span class="hljs-number">25</span>[<span class="hljs-number">0</span><span class="hljs-operator">-</span>&#13;
<span class="hljs-number">5</span>]<span class="hljs-operator">|</span><span class="hljs-number">2</span>[<span class="hljs-number">0-4</span>][<span class="hljs-number">0-9</span>]<span class="hljs-operator">|</span>[<span class="hljs-number">01</span>]?[<span class="hljs-number">0-9</span>][<span class="hljs-number">0-9</span>]?<span class="hljs-operator">|</span>[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span><span class="hljs-operator">-</span>]<span class="hljs-operator">*</span>[a<span class="hljs-operator">-</span>z0<span class="hljs-number">-9</span>]:(?:[\x01<span class="hljs-operator">-</span>&#13;
\x08\x0b\x0c\x0e<span class="hljs-operator">-</span>\x1f\x21<span class="hljs-operator">-</span>\x5a\x53<span class="hljs-operator">-</span>\x7f]<span class="hljs-operator">|</span>\\[\x01<span class="hljs-operator">-</span>\x09\x0b\x0c\x0e<span class="hljs-operator">-</span>&#13;
\x7f])<span class="hljs-operator">+</span>)\])&#13;
</code></pre>&#13;
    <p class="normal">Emails do not always adhere to RFC 5322 standards, so additional work may be required to truly clean email address data.</p>&#13;
    <p class="normal">Although I won’t attempt a detailed explanation of this code, you can read all about it at <a href="http://www.regular-expressions.info/email.html" target="_blank"><span class="url">http://www.regular-expressions.info/email.html</span></a>, which is a great resource for learning more about regular expressions. Also, YouTube has several helpful regular expression tutorials.</p>&#13;
    <p class="normal">The final output <a/>for this exercise should probably be <a/>used to enhance existing source data. <strong class="keyWord">Data dumps</strong> such as this example do not belong in data warehouses; however, even important and necessary data can be hidden in such dumps, and Tableau can be effectively used to extract it.</p>&#13;
    </div>&#13;
</div>&#13;
</section>&#13;
<section id="ch02lvl1sec11">&#13;
<div class="epub-source">&#13;
<h1 class="heading-1">Summary</h1>&#13;
<div class="Basic-Text-Frame">&#13;
    <p class="normal">We began this chapter with a discussion of the Tableau data-handling engine. This illustrated the flexibility Tableau provides in working with data. The data-handling engine is important to understand in order to ensure that your data mining efforts are intelligently focused. Otherwise, your effort may be wasted on activities not relevant to Tableau.</p>&#13;
    <p class="normal">Next, we focused on data preparation. We considered using Tableau to survey and also clean data. The data cleaning capabilities represented by the regular expression functions are particularly intriguing and are worth further investigation.</p>&#13;
    <p class="normal">Having completed our first data-centric discussion, we’ll continue with <em class="chapterRef">Chapter 3</em>, <em class="italic">Using</em> <em class="italic">Tableau Prep Builder</em>, looking at one of the newer features Tableau has brought to the market. Tableau Prep Builder is a dedicated data pre-processing interface that is able to greatly reduce the amount of time you need for pre-processing. We’ll take a look at cleaning, merging, filtering, joins, and the other functionality Tableau Prep Builder has to offer.</p>&#13;
    <h2 class="heading-1">Learn more on Discord</h2>&#13;
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>&#13;
    <p class="normal"><a href="https://packt.link/tableau" target="_blank"><span class="url">https://packt.link/tableau</span></a></p>&#13;
    <p class="normal"><img src="../images/QR_Code2044012316175764640.png" alt=""/></p>&#13;
  </div>&#13;
&#13;
&#13;
</div>&#13;
</section>&#13;
</section>&#13;
</body></html>