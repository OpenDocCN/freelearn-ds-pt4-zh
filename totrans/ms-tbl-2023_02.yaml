- en: Getting Your Data Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever asked yourself whether your data is clean enough to be analyzed?
    It’s likely that everyone who works with data has, which is why this chapter is
    dedicated to getting your data ready for analysis, otherwise known as data cleaning.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this chapter is theory-oriented and does not include exercises.
    A careful reading of this information is encouraged since it provides a foundation
    for greater insight. The latter portion of the chapter provides various exercises
    specifically focused on data preparation.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dive into this fascinating topic with the goal of enriching our understanding
    and becoming ever-better data stewards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Hyper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focusing on data preparation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surveying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning messy data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Tableau Desktop 10.5 has been on the market for some time, you may already
    have heard of Hyper. Regardless of whether you have or not, continue reading for
    a primer on this feature!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Hyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore Tableau’s data-handling engine, and how it
    enables structured yet organic data mining processes in enterprises. Since the
    release of Tableau 10.5, we can make use of Hyper, a high-performing database,
    allowing us to query source data faster than ever before. Hyper is usually not
    well understood, even by advanced developers, because it’s not an overt part of
    day-to-day activities; however, if you want to truly grasp how to prepare data
    for Tableau, this understanding is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyper originally started as a research project at the University of Munich
    in 2008\. In 2016, it was acquired by Tableau and appointed as the dedicated data
    engine group of Tableau, maintaining its base and employees in Munich. Initially
    in Tableau 10.5, Hyper replaced the earlier data-handling engine only for extracts.
    It is still true that live connections are not touched by Hyper, but Tableau Prep
    Builder now runs on the Hyper engine too, with more use cases to follow. As stated
    on [tableau.com](http://tableau.com), “*Hyper can slice and dice massive volumes
    of data in seconds, you will see up to 5X faster query speed and up to 3X faster
    extract creation speed*.” And if you still can’t get enough, there is always the
    option to use Hyper through API calls in your preferred programming language:
    [https://help.tableau.com/current/api/hyper_api/en-us/docs/hyper_api_reference.html](https://help.tableau.com/current/api/hyper_api/en-us/docs/hyper_api_reference.html).'
  prefs: []
  type: TYPE_NORMAL
- en: But what makes Hyper so fast? Let’s have a look under the hood!
  prefs: []
  type: TYPE_NORMAL
- en: The Tableau data-handling engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vision shared by the founders of Hyper was to create a high-performing,
    next-generation database—one system, one state, no trade-offs, and no delays.
    And it worked—today, Hyper can serve general database purposes, data ingestion,
    and analytics at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Memory prices have decreased exponentially. The same goes for CPUs; transistor
    counts increased according to Moore’s law, while other features stagnated. Memory
    is cheap but processing still needs to be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Moore’s Law is the observation made by Intel co-founder Gordon Moore that the
    number of transistors on a chip doubles every two years while the costs are halved.
    Information on Moore’s Law can be found on Investopedia at [https://www.investopedia.com/terms/m/mooreslaw.asp](https://www.investopedia.com/terms/m/mooreslaw.asp).
  prefs: []
  type: TYPE_NORMAL
- en: While experimenting with Hyper, the founders measured that handwritten C code
    is faster than any existing database engine, so they came up with the idea to
    transform Tableau queries into C code and optimize it simultaneously, all behind
    the scenes, so the Tableau user won’t notice it. This translation and optimization
    come at a cost; traditional database engines can start executing code immediately.
    Tableau needs to first translate queries into code, optimize that code, then compile
    it into machine code, after which it can be executed. The big question is, is
    it still faster? As proven by many tests on Tableau Public and other workbooks,
    the answer is yes!
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if there is a query estimated to be faster if executed without
    the compilation to machine code, Tableau has its own **virtual machine** (**VM**)
    on which the query will be executed right away. And next to this, Hyper can utilize
    99% of available CPU computing power, whereas other parallel processes can only
    utilize 29% of available CPU compute. This is due to the unique and innovative
    technique of morsel-driven parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you that want to know more about morsel-driven parallelization,
    a paper, which later on served as a baseline for the Hyper engine, can be found
    at [https://15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf](https://15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more about the Hyper engine, I highly recommend the following
    video at [https://youtu.be/h2av4CX0k6s](https://youtu.be/h2av4CX0k6s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyper parallelizes three steps of traditional data warehousing operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and **Continuous Data Ingestion** (**Online Transaction Processing**,
    or **OLTP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics** (**Online Analytical Processing**, or **OLAP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beyond Relational** (**Online Beyond Relational Processing**, or **OBRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing those steps simultaneously makes Hyper more efficient and more performant,
    as opposed to traditional systems where those three steps are separated and executed
    one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, Hyper is a highly specialized database engine that allows us as users
    to get the best out of our queries. If you recall, in *Chapter 1*, *Reviewing
    the Basics*, we already saw that every change on a sheet or dashboard, including
    drag and drop pills, filters, and calculated fields, among others, is translated
    into a query. Those queries are pretty much SQL lookalikes; however, in Tableau
    we call the querying engine VizQL.
  prefs: []
  type: TYPE_NORMAL
- en: VizQL, another hidden gem on your Tableau Desktop, is responsible for visualizing
    data in a chart format and is fully executed in memory. The advantage is that
    no additional space on the database side is required here. VizQL is generated
    when a user places a field on a shelf. VizQL is then translated into SQL, MDX,
    or **Tableau Query Language** (**TQL**) and passed to the backend data source
    with a driver.
  prefs: []
  type: TYPE_NORMAL
- en: Hyper takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This overview of the Tableau data-handling engine demonstrates a flexible approach
    to interfacing with data. Knowledge of the data-handling engine can reduce data
    preparation and data modeling efforts, thus helping us streamline the overall
    data mining life cycle. Don’t worry too much about data types and data that can
    be calculated based on the fields you have in your database. Tableau can do all
    the work for you in this respect. In the next section, we will discuss what you
    should consider from a data source perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on data preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tableau can be used effectively with various data preparation phases. Unfortunately,
    a single chapter is not sufficient to thoroughly explore how Tableau can be used
    in each phase. Indeed, such a thorough exploration may be worthy of an entire
    book! Our focus, therefore, will be directed to ward data preparation, since that
    phase has historically accounted for up to 60% of the data mining effort. Our
    goal will be to learn how Tableau can be used to streamline that effort.
  prefs: []
  type: TYPE_NORMAL
- en: Surveying data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tableau can be a very effective tool for simply surveying data. Sometimes in
    the survey process, you may discover ways to clean the data or populate incomplete
    data based on existing fields. Sometimes, regretfully, there are simply not enough
    pieces of the puzzle to put together an entire dataset. In such cases, Tableau
    can be useful to communicate exactly what the gaps are, and this, in turn, may
    incentivize the organization to more fully populate the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will explore how to use Tableau to quickly discover the
    percentage of null values for each field in a dataset. Next, we’ll explore how
    data might be extrapolated from existing fields to fill in the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing null values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the steps to survey the data:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t done so just yet, navigate to [https://public.tableau.com/profile/marleen.meier](https://public.tableau.com/profile/marleen.meier)
    to locate and download the workbook associated with this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the worksheet entitled `Surveying` `&` `Exploring``Data` and select
    `Happiness Report` data source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag **Region** and **Country** to the **Rows** shelf. Observe that in some
    cases the **Region** field has **Null** values for some countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Null regions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click and **Edit** the parameter entitled `Select Field`. Note that the
    **Data Type** is set to **Integer** and we can observe a list that contains an
    entry for each field name in the dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_02_02.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.2: Editing a parameter'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Data** pane, right-click on the parameter we just created and select
    **Show Parameter** Control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a calculated field entitled `% Populated` and write the following calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Data** pane, right-click on **% Populated** and select **Default Properties**
    | **Number Format…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_02_03.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Adjusting default properties'
  prefs: []
  type: TYPE_NORMAL
- en: In the resulting dialog box, choose **Percentage**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a calculated field entitled `Null & Populated` and add the following
    code. Note that the complete case statement is fairly lengthy but also repetitive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In cases requiring a lengthy but repetitive calculation, consider using Excel
    to more quickly and accurately write the code. By using Excel’s `CONCATENATE`
    function, you may be able to save time and avoid typos.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the following code block, the code lines represent only a percentage of
    the total but should be sufficient to enable you to produce the whole block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove **Region** and **Country** from the **Rows** shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place **Null & Populated** on the **Rows** and **Color** shelves and **% Populated**
    on the **Columns** and **Label** shelves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Populated values'
  prefs: []
  type: TYPE_NORMAL
- en: Change the colors to red for **Null Values** and green for **Populated Values**
    if desired. You can do so by clicking on **Color** in the **Marks** card and **Edit
    Colors**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the arrow in the upper-right corner of the **Select Field** parameter
    on your sheet and select **Single Value List**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select various choices in the **Select Field** parameter and note that some
    fields have a high percentage of null values. For example, in the following diagram,
    **32.98%** of records do not have a value for **Region**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing graphical user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_02_05.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: Comparing null and populated values'
  prefs: []
  type: TYPE_NORMAL
- en: Building on this exercise, let’s explore how we might clean and extrapolate
    data from existing data using the same dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Extrapolating data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise will expand on the previous exercise by cleaning existing data
    and populating some of the missing data from known information. We will assume
    that we know which country belongs to which region. We’ll use that knowledge to
    fix errors in the `Region` field and also to fill in the gaps using Tableau:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from where the previous exercise ended, create a calculated field
    entitled `Region Extrapolated` with the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As an alternative to a `CASE` statement, you could use an `IF` statement like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To speed up the tedious creation of a long calculated field, you could download
    the data to an Excel file and create the calculated field by concatenating the
    separate parts, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_02_06.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.6: Compiling a calculation in Excel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can then copy them from Excel into Tableau. However, for this exercise,
    I have created a backup field called `Backup`, which can be found in the Tableau
    workbook associated with this chapter, which contains the full calculation needed
    for the `Region Extrapolated` field. Use this at your convenience. The **Solutions**
    dashboard also contains all of the countries. You can therefore copy the `Region
    Extrapolated` field from that file too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a **Region Extrapolated** option to the **Select Field** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Adding Region Extrapolated to the parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Null & Populated` calculated field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the **Region Extrapolated** field is now fully populated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Fully populated Region Extrapolated field'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s consider some of the specifics from the previous exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the following code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the complete `CASE` statement is several lines long. The following
    is a representative portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This case statement is a row-level calculation that considers each field in
    the dataset and determines which rows are populated and which are not. For example,
    in the representative line of the preceding code, every row of the `Country` field
    is evaluated for nulls. The reason for this is that a calculated field will add
    a new column to the existing data—only in Tableau, not in the data source itself—and
    every row will get a value. These values can be N/A or null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the equivalent of the quick table calculation `Percent
    of Total`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In conjunction with the `Null & Populated` calculated field, it allows us to
    see what percentage of our fields are actually populated with values.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to get into the habit of writing table calculations from scratch,
    even if an equivalent quick table calculation is available. This will help you
    more clearly understand the table calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following CASE statement is an example of how you might use one or more
    fields to extrapolate what another field should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For example, the `Region` field in the dataset had a large percentage of null
    values, and even the existing data had errors. Based on our knowledge of the business
    (that is, which country belongs to which region), we were able to use the `Country`
    field to achieve 100% population of the dataset with accurate information.
  prefs: []
  type: TYPE_NORMAL
- en: Nulls are a part of almost every extensive real dataset. Understanding how many
    nulls are present in each field can be vital to ensuring that you provide accurate
    business intelligence. It may be acceptable to tolerate some null values when
    the final results will not be substantially impacted, but too many nulls may invalidate
    results. However, as demonstrated here, in some cases, one or more fields can
    be used to extrapolate the values that should be entered into an underpopulated
    or erroneously populated field.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated in this section, Tableau gives you the ability to effectively
    communicate to your data team which values are missing, which are erroneous, and
    how possible workarounds can be invaluable to the overall data mining effort.
    Next, we will look into data that is a bit messier and not in a nice column format.
    Don’t worry, Tableau has us covered.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning messy data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The United States government provides helpful documentation for various bureaucratic
    processes. For example, the **Department of Health and Human Services** (**HSS**)
    provides lists of ICD-9 codes, otherwise known as International Statistical Classification
    of Diseases and Related Health Problems codes. Unfortunately, these codes are
    not always in easily accessible formats.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s consider an actual HHS document known as R756OTN, which
    can be found at [https://www.cms.gov/Regulations-and-Guidance/Guidance/Transmittals/downloads/R756OTN.pdf](https://www.cms.gov/Regulations-and-Guidance/Guidance/Transmittals/downloads/R756OTN.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigate to the `Cleaning the Data` worksheet in the workbook accompanying
    this chapter and execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **Data** pane, select the **R756OTN Raw** data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_02_09.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: Selecting the raw file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag **Diagnosis** to the **Rows** shelf and choose **Add all members**. Click
    on the **AZ** sign to sort the **Diagnosis** column. Note the junk data that occurs
    in some rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Adding Diagnosis to Rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a calculated field named `DX` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a calculated field named `Null Hunting` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **Data** pane, drag `Null Hunting` from **Measures** to **Dimensions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag **Diagnosis**, **DX**, and **Null Hunting** to the **Rows** shelf. Observe
    that **Null** is returned when the second character in the **Diagnosis** field
    is not numeric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Ordering fields on Rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a calculated field named `Exclude from ICD codes` containing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Clear the sheet of all fields, as demonstrated in *Chapter 1*, *Reviewing the
    Basics*, and set the **Marks** card to **Shape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place **Exclude from ICD Codes** on the **Color**, and **Shape** shelves, and
    then place **DX** on the **Rows** shelf. Observe the rows labeled as **True**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Excluding junk data'
  prefs: []
  type: TYPE_NORMAL
- en: In order to exclude the junk data (that is, those rows where `Exclude from ICD
    Codes` equates to `True`), place `Exclude from ICD Codes` on the **Filter** shelf
    and deselect **True**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a calculated field named `Diagnosis Text` containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place **Diagnosis Text** on the **Rows** shelf after **DX**. Also, remove **Exclude
    from ICD Codes** from the **Rows** shelf and the **Marks** card, and set the mark
    type to **Automatic**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Observing the cleaned data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve completed the exercise, let’s take a moment to consider the
    code we have used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SPLIT` function was introduced in Tableau 9.0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As described in Tableau’s help documentation about the function, the function
    does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Returns a substring from a string, as determined by the delimiter extracting
    the characters from the beginning or end of the string*.'
  prefs: []
  type: TYPE_NORMAL
- en: This function can also be called directly in the **Data Source** tab when clicking
    on a column header and selecting **Split**. To extract characters from the end
    of the string, the token number (that is, the number at the end of the function)
    must be negative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code, which we used to create the `Null Hunting` field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The use of `MID` is quite straightforward and much the same as the corresponding
    function in Excel. The use of `INT` in this case, however, may be confusing. Casting
    an alpha character with an `INT` function will result in Tableau returning `Null`.
    This satisfactorily fulfills our purpose, since we simply need to discover those
    rows not starting with an integer by locating the nulls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISNULL` is a Boolean function that simply returns `TRUE` in the case of `Null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `REPLACE` function was used while creating the `Diagnosis Text` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This calculated field uses the ICD-9 codes isolated in `DX` to remove those
    same codes from the `Diagnosis` field and thus provides a fairly clean description.
    Note the phrase *fairly clean*. The rows that were removed were initially associated
    with longer descriptions that thus included a carriage return. The resulting additional
    rows are what we removed in this exercise. Therefore, the longer descriptions
    are truncated in this solution using the `replace` calculation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final output for this exercise could be to export the data from Tableau
    as an additional source of data. This data could then be used by Tableau and other
    tools for future reporting needs. For example, the `DX` field could be useful
    in data blending.
  prefs: []
  type: TYPE_NORMAL
- en: Does Tableau offer a better approach that might solve the issue of truncated
    data associated with the preceding solution? Yes! Let’s turn our attention to
    the next exercise, where we will consider regular expression functions.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although, as shown in the previous exercise, *Cleaning the data*, the `SPLIT`
    function can be useful for cleaning clean data, regular expression functions are
    far more powerful, representing a broadening of the scope from Tableau’s traditional
    focus on visualization and analytics to also include data cleaning capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example that requires us to deal with some pretty messy data
    in Tableau. Our objective will be to extract phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already done so, please download the workbook from [https://public.tableau.com/profile/marleen.meier](https://public.tableau.com/profile/marleen.meier)
    and open it in Tableau.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Extracting the Data` tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Data** pane, select the **String of Data** data source and drag the
    **String of Data** field to the **Rows** shelf. Observe the challenges associated
    with extracting the phone numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Extracting data from a messy data format'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the underlying data by clicking the **View data** button and copying
    several rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_02_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Accessing underlying data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to [http://regexpal.com/](http://regexpal.com/) and paste the data
    into the pane labeled **Test String**—that is, the second pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_02_16.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16: Regexpal'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first pane (the one labeled **Regular Expression**), type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return to Tableau and create a calculated field called `Phone Number` with
    the following code block. Note the regular expression nested in the calculated
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place **Phone Number** on the **Rows** shelf, and observe the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated with medium confidence](img/B18435_02_17.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.17: Extracting data final view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider some of the specifics from the preceding exercise in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expression pattern is purposely excluded here as it will be covered in
    detail later. The ‘`()`'' code acts as a placeholder for the expression pattern.
    The `REGEXP_EXTRACT` function used in this example is described in Tableau’s help
    documentation as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Returns a substring of the given string that matches the capturing group within
    the regular expression pattern.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that as of the time of writing, the Tableau documentation does not communicate
    how to ensure that the pattern input section of the function is properly delimited.
    For this example, be sure to include ‘`()`' around the pattern input section to
    avoid a null output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting within a calculated field that is itself nested within a `VizQL` query
    can affect performance (if there are too many levels of nesting/aggregation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous regular expression websites that allow you to enter your
    own code and help you out, so to speak, by providing immediate feedback based
    on sample data that you provide. [http://regexpal.com/](http://regexpal.com/)
    is only one of those sites, so search as desired to find one that meets your needs!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, consider the expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this context, the `\` indicates that the next character should not be treated
    as special but as literal. For our example, we are literally looking for an open
    parenthesis. `[0-9]` simply declares that we are looking for one or more digits.
    Alternatively, consider `\d` to achieve the same results. The `{3}` designates
    that we are looking for three consecutive digits.
  prefs: []
  type: TYPE_NORMAL
- en: As with the opening parenthesis at the beginning of the pattern, the `\` character
    designates the closing parentheses as a literal. The `-` is a literal that specifically
    looks for a hyphen. The rest of the expression pattern should be decipherable
    based on the preceding information.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reviewing this exercise, you may be curious about how to return just
    the email address. According to [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html),
    the regular expression for email addresses adhering to the RFC 5322 standard is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Emails do not always adhere to RFC 5322 standards, so additional work may be
    required to truly clean email address data.
  prefs: []
  type: TYPE_NORMAL
- en: Although I won’t attempt a detailed explanation of this code, you can read all
    about it at [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html),
    which is a great resource for learning more about regular expressions. Also, YouTube
    has several helpful regular expression tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: The final output for this exercise should probably be used to enhance existing
    source data. **Data dumps** such as this example do not belong in data warehouses;
    however, even important and necessary data can be hidden in such dumps, and Tableau
    can be effectively used to extract it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter with a discussion of the Tableau data-handling engine.
    This illustrated the flexibility Tableau provides in working with data. The data-handling
    engine is important to understand in order to ensure that your data mining efforts
    are intelligently focused. Otherwise, your effort may be wasted on activities
    not relevant to Tableau.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we focused on data preparation. We considered using Tableau to survey
    and also clean data. The data cleaning capabilities represented by the regular
    expression functions are particularly intriguing and are worth further investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed our first data-centric discussion, we’ll continue with *Chapter
    3*, *Using* *Tableau Prep Builder*, looking at one of the newer features Tableau
    has brought to the market. Tableau Prep Builder is a dedicated data pre-processing
    interface that is able to greatly reduce the amount of time you need for pre-processing.
    We’ll take a look at cleaning, merging, filtering, joins, and the other functionality
    Tableau Prep Builder has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/tableau](https://packt.link/tableau)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2044012316175764640.png)'
  prefs: []
  type: TYPE_IMG
