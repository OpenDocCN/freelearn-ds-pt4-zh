- en: Improving Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once people are familiar with Tableau’s functionality, they soon run into another
    type of issue: performance. You might all have experienced staring at the screen
    while reading *Loading Data* or *Executing Query*. But don’t worry, we’ve got
    you! If designed accordingly, Tableau dashboards can perform very well, even with
    large amounts of data.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will address various aspects of performance with the intent of
    empowering you with techniques to create workbooks that load quickly and respond
    snappily to end user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the performance-recording dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware and on-the-fly techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with extracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using filters wisely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other ways to improve performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are many topics we have to cover with regard to performance
    improvement. Therefore, let’s not lose any time and dive right in. Our first topic
    will be performance recording, which is the first thing you should look at when
    experiencing a drop in performance because it helps you identify the source of
    all the slowness.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the performance-recording dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tableau includes a performance-recording feature as part of the installation
    package and it ships as a dashboard named `PerformanceRecording.twb`. The dashboard
    gives the Tableau author an easy way to understand and troubleshoot performance
    problems. The following exercises and associated discussion points will review
    various aspects of the performance-recording dashboard, including how to generate
    it, how to use it to improve performance, and how it’s constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://public.tableau.com/profile/marleen.meier](https://public.tableau.com/profile/marleen.meier)
    to locate and download the workbook associated with this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `Types of Events` worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Help** | **Settings and Performance** | **Start Performance Recording**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F5* on Windows or *Command* + *R* on macOS to refresh the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Help** | **Settings and Performance** | **Stop Performance Recording**.
    A new dashboard will open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Performance summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main parts to be looked at:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A) Performance Summary** shows the amount of time the dashboard needed to
    execute all the steps that happened between *step 3* (start performance recording)
    and *step 5* (stop performance recording). The slider can be used to filter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**B) Timeline** shows which step happened when and how long it took.'
  prefs: []
  type: TYPE_NORMAL
- en: '**C)** The steps are also color-coded and can be found in the **Events** bar
    chart as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '**D) Query** will only show details when clicking on any event in (**B**) or
    (**C**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Events** timeline slider in (**A**) to the far left to show all events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within **Events Sorted by Time** (**C**), click on any green bar entitled **Executing
    Query**. Note that the **Query** section is now populated by the VizQL belonging
    to the highlighted bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Events'
  prefs: []
  type: TYPE_NORMAL
- en: To see the query in its entirety, navigate to the **Query** worksheet and set
    the fit to **Entire View** (by **Query**, Tableau is referring to a VizQL query).
    Note that an especially long query may not be recorded in its entirety. In order
    to see every line of such a query, reference the log files located in **My Tableau
    Repository**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps were intended to provide you with an initial look at what
    the performance-recording dashboard can be used for. I usually use it to check
    whether a particular query took significantly longer than others. I then look
    at the query on the **Query** tab and check which part is affected by reading
    the fields used, try to change it, and then run the performance dashboard again
    to see how things change. Now, let’s look at some more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you access the **Events** worksheet from the performance-recording dashboard,
    you will see the different events. We will now discuss those events and their
    impact on performance in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event type** | **Performance considerations** |'
  prefs: []
  type: TYPE_TB
- en: '| Connecting to Data Source | Poor performance when connecting to the data
    source could indicate network latency or database issues, or even outdated drivers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Generating Extract | Aggregating data and hiding unused columns before you
    extract can increase performance because it will decrease the total column and
    row count, respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| Compile Query | Compile Query performance problems could indicate database
    issues. |'
  prefs: []
  type: TYPE_TB
- en: '| Executing Query | If a query takes too long, you can improve performance
    by filtering data you don’t need or hiding fields you don’t use. Refer to the
    *Using filters wisely* section in this chapter for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| Sorting Data | Performance issues related to sorting issues may indicate
    too many marks in the view. This sorting issue can also be caused by table calculations
    that depend on sorting data in the view. |'
  prefs: []
  type: TYPE_TB
- en: '| Geocoding | Geocoding performance issues may indicate too many marks in the
    view, internet latency issues, poor hardware, or a poor graphics card. |'
  prefs: []
  type: TYPE_TB
- en: '| Blending Data | Blending Data performance may be improved by reducing the
    amount of underlying data or by filtering. |'
  prefs: []
  type: TYPE_TB
- en: '| Computing Table Calculations | Since table calculations are typically performed
    locally, complex calculations may tax the end user’s computer. |'
  prefs: []
  type: TYPE_TB
- en: '| Computing Totals | The Computing Totals performance may be improved by reducing
    the amount of underlying data or by filtering. |'
  prefs: []
  type: TYPE_TB
- en: '| Computing Layout | Computing Layout performance issues may be indicative
    of a dashboard with too many worksheets or elements such as images. |'
  prefs: []
  type: TYPE_TB
- en: After this overview, which you can always come back to, we will dive a little
    deeper and research what happens when performance recording is activated. Note
    that the following assumes that the author is working on Tableau Desktop and not
    Tableau Server. In *Chapter 14*, *Exploring Tableau Server and Tableau Cloud*,
    we will cover performance recording on Tableau Server.
  prefs: []
  type: TYPE_NORMAL
- en: When recording performance, Tableau initially creates a file in `My Tableau
    Repository\Logs`, named `performance_[timestamp].tab`. Additionally, there is
    a file named `PerformanceRecording_new.twb` located in the Tableau program directory,
    for example, `C:\Program Files\Tableau\Tableau.[version]\Performance`. That file
    is automatically opened once the recording stops, thereby allowing the author
    to peruse the results.
  prefs: []
  type: TYPE_NORMAL
- en: We just learned how we can record performance metrics and use the dashboard
    that ships with Tableau Desktop and Tableau Server (if enabled by admin) on said
    topic. In the next sections, we will guide you step by step through the different
    options that you can consider to improve the overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware and on-the-fly techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Tableau Desktop does not need a lot in terms of hardware, it still
    happens that company desktops or laptops are underpowered, especially if you are
    a so-called business user who does not require programming tools or lots of processing
    power in your day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this section, we will discuss the technical requirements. As
    per [www.tableau.com](http://www.tableau.com), the latest technical requirements
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Windows** | Microsoft Windows 8/8.1, Windows 10 (x64), Windows 11 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2 GB memory |'
  prefs: []
  type: TYPE_TB
- en: '|  | 1.5 GB minimum free disk space |'
  prefs: []
  type: TYPE_TB
- en: '|  | CPUs must support SSE4.2 and POPCNT instruction sets |'
  prefs: []
  type: TYPE_TB
- en: '| **Mac** | macOS Catalina 10.15, macOS Big Sur 11.4+, macOS Monterey 12.6+
    (for Tableau 2022.3+), and macOS Ventura (for Tableau 2022.3+) |'
  prefs: []
  type: TYPE_TB
- en: '|  | Intel processors or Apple Silicon processors (using Rosetta) |'
  prefs: []
  type: TYPE_TB
- en: '|  | 1.5 GB minimum free disk space |'
  prefs: []
  type: TYPE_TB
- en: Now that we have our basics straight, let us take a look at a feature that can
    slow down your performance unwillingly and how to solve it. Our first on-the-fly
    technique is called auto updates.
  prefs: []
  type: TYPE_NORMAL
- en: Auto updates can be accessed either via the icon located on the toolbar, via
    **Worksheet** | **Auto Updates**, or by using the shortcut key *F10* on Windows
    or *Option* + *Command* + *0* on Mac. Auto updates give the author the option
    of pausing/resuming auto updates for the worksheet and/or for filters and can
    come in very handy if you want to make multiple changes to your layout but want
    to avoid Tableau loading after every change because every load means a new query
    is sent to your underlying data source and has to be processed, which will cost
    processing power. You can simply pause the update, make your changes, and then
    run the update once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following exercise demonstrates how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the workbook associated with this chapter and navigate to the `Auto Updates`
    worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Data** pane, select the `Superstore` dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place **State** on the **Rows** shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deselect **Auto Update Worksheet** via the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Auto Update Worksheet'
  prefs: []
  type: TYPE_NORMAL
- en: Place **City** on the **Rows** shelf to the right of **State**. Note that the
    view does not update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **Auto Update Worksheet** via the toolbar. The view now updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **State** on the **Rows** shelf and select **Show Filter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **City** on the **Rows** shelf and select **Show Filter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **City** filter, click the drop-down menu and select **Multiple Values**
    **(****list****)** and **Only Relevant Values**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Only Relevant Values'
  prefs: []
  type: TYPE_NORMAL
- en: Deselect **Auto Update Filters** as shown in *Figure 13.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **State** filter, select only **Alabama**. Note that the **City** filterdoes
    not update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **Auto Update Filters** via the toolbar. The **City** filter now updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auto updates can be very helpful. The author may pause auto updates, make multiple
    changes, and then resume auto updates, thereby saving time and increasing performance
    indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, cascading filters such as **Only Relevant Values** or **All
    Values in Context** may not populate when using the pause button or auto updates
    as they are reliant on a query being passed first.
  prefs: []
  type: TYPE_NORMAL
- en: The Run Update feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Run Update** icon to the right of the pause/resume auto updates option
    is meant to refresh once, while the user can keep the disabled **Auto Update**
    feature in place. The following brief example should help clarify this option:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the **previous** worksheet called `Auto Updates` and name the duplicate
    `Run Updates`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pause all updates by clicking on the **Pause Auto Updates** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select several states at random in the **State** filter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run Update** icon as shown in *Figure 13.5* and select either
    **Update Filters** or **Update Worksheet**. The shortcut key for running an update
    is *F9* on Windows. The shortcut on macOS is *Shift* + *Command* + *0*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Running an update'
  prefs: []
  type: TYPE_NORMAL
- en: Select several more states at random in the **State** filter. Note that auto
    updating is still paused.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To repeat, **Run Update** allows the Tableau author to intermittently refresh
    the view while keeping auto updates paused. The two update features that we just
    discussed will make your life as a dashboard developer easier by being able to
    make multiple changes before loading and hence waiting for the refreshed data,
    but if you want to tackle performance issues at their core, you need some more
    tools to hand. The following section will introduce extracts, a really good feature
    for speeding up calculations and rendering in general.
  prefs: []
  type: TYPE_NORMAL
- en: Small extracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although extracts will be discussed in more detail in the *Working with extracts*
    section, it seems fitting to mention extracts in the context of performance considerations
    while authoring. Even under optimal conditions, working with large data sources
    can be slow. If constant access to the entire dataset while authoring is not necessary,
    consider creating a small, local extract. Author as much of the workbook as possible
    and then, when all the underlying data is truly needed, point to the original
    data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show a brief example of this technique in action:'
  prefs: []
  type: TYPE_NORMAL
- en: In the workbook associated with this chapter, navigate to the `Small Local Extract`
    worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Data** | **New Data Source** to choose a desired data source. This
    exercise assumes `Superstore.xls`, which installs with Tableau, but you can take
    any dataset you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag any field to the **Text** shelf. In my example, I used `Number` `of` `Records`**,**
    which is a calculated field containing solely the number 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the data source (for me: `Superstore`) and select **Extract
    Data…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Extracting data'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the **Extract Data…** dialog box, select **Top**, your data
    source, and choose **1000**. In the following figure, **Orders** has been chosen,
    which is one of the two parts of the superstore join:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Top rows'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Extract** button and note that number of records now displays `1000`
    rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Data** pane, right-click on **Superstore** and deselect **Use Extract**.
    Note that **Number of Records** has reverted to its original value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By creating a small, local extract, the Tableau author alleviates two performance
    inhibitors: network latency and dataset size.'
  prefs: []
  type: TYPE_NORMAL
- en: This section gave you the knowledge of how to reduce your dataset temporarily
    and the option to get back to the original size, both without leaving the Tableau
    interface. This is a great way to speed up your dashboard-building process and
    avoid long waits. In the next section, we will talk about how to connect to data
    sources to achieve the best possible performance.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the beauties of Tableau is the ease with which you can connect to many
    different data sources in various ways. As mentioned earlier in this book, there
    are many connectors defined in Tableau for interfacing with a variety of data
    sources. Furthermore, this flexibility extends beyond simply connecting to single
    tables or files.
  prefs: []
  type: TYPE_NORMAL
- en: Although Tableau makes it easy to connect to various data sources, it should
    be stressed that Tableau is not an **Extract, Transform, and Load** (**ETL**)
    tool. If complex joins and complex data blending are required to generate useful
    results, it may be advisable to perform ETL work outside of Tableau, for example,
    in Tableau Prep Builder (see *Chapter 3*, *Using Tableau Prep Builder*, for more
    information on this service). ETL work will ideally lead to better data modeling
    and thus easier authoring and quicker performance in Tableau.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four ways in which Tableau connects to data are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tableau may connect to a single table. This is ideal as it allows the most functionality
    and easiest troubleshooting while enabling Tableau to send the simplest queries
    and thus perform optimally. However, it is not always possible to connect to a
    single table and, although ideal, it is not reasonable to have such a strict limitation.
    The relationship between data sources and reporting tools is constantly changing.
    A reporting tool that is inflexible in the way it can connect to data will likely
    not be successful, no matter how elegant and beautiful the end results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option is relationships, a newer, more flexible way to combine two
    or more datasets. The level of detail will be defined per worksheet rather than
    in the **Data Source** tab, which makes this feature very powerful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third way in which Tableau may connect to data is via joining. One table
    may not supply all the necessary data, but by joining two or more tables, all
    the needed data may be accessible. As the joins become more and more complex,
    performance may be impacted, and troubleshooting may become difficult. Fortunately,
    Tableau can assume referential integrity and thus work quite efficiently with
    even complex joins. More information can be found here: [https://help.tableau.com/current/pro/desktop/en-us/joins_xbd_perf.htm](https://help.tableau.com/current/pro/desktop/en-us/joins_xbd_perf.htm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Tableau may utilize data blending. Data blending often performs admirably,
    provided no more than one of the blended data sources is large and dimensions
    that are used for blending have relatively few members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships should be chosen over joining and joining should be chosen instead
    of blending whenever possible. When blending multiple, large data sources, performance
    can be seriously impacted. The problem is further compounded when blending on
    high-cardinality dimensions. Also, data blending limits some functionality, such
    as the ability to use dimensions, row-level calculations, or LOD expressions,
    from a secondary data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are exceptions, two of which are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, data blending is advantageous (and usually necessary) when there is no
    common key shared between two tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, in some instances, cross-joining will not work, and a data blend is
    required. For example, use data blending when you work with two datasets that
    have different granularities and relationships are not possible or when a cross-database
    join is not possible (for example, to cubes or extract-only connections), or when
    you have big datasets for which a blend will improve performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More info can be found here: [https://help.tableau.com/current/pro/desktop/en-us/multiple_connections.htm](https://help.tableau.com/current/pro/desktop/en-us/multiple_connections.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, consider as a guideline that data blending should normally
    be avoided if a joining option exists.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Learning about Joins, Blends, and Data Structures*, provides
    detailed information about joining and blending. For the purposes of this chapter,
    joining and blending discussions will be limited to performance considerations.'
  prefs: []
  type: TYPE_NORMAL
- en: Working efficiently with large data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will cover some basics of database tuning and ways to work efficiently
    with large data sources. Since the topic is more focused on data sources than
    on Tableau, no exercises are included.
  prefs: []
  type: TYPE_NORMAL
- en: If you are connecting to large data sources and are experiencing performance
    problems, a conversation with a **database administrator** (**DBA**) may be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Clear communication coupled with a small amount of database work could dramatically
    improve performance. The conversation should include database-tuning points, such
    as explicitly defining primary and foreign keys, defining columns as *not null*,
    and indexing. Each point will be discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Defining primary and foreign keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Primary and foreign keys are essential for joining tables. A primary key is
    composed of one or more columns in a table. The primary key should be unique for
    every row. Joining on a non-unique, row-level key may lead to erroneous results,
    as explored in *Chapter 4*, *Learning about Joins, Blends, and Data Structures*.
    Explicitly defining primary keys in the database helps to ensure that each key
    value is unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Database keys'
  prefs: []
  type: TYPE_NORMAL
- en: A foreign key is composed of one or more columns in a table that uniquely identify
    rows in another table. This unique identification occurs as a result of the foreign
    key in one table referencing the primary key in another table. Explicitly defining
    foreign keys in the database enables Tableau to bypass many integrity checks,
    thereby improving performance.
  prefs: []
  type: TYPE_NORMAL
- en: Defining columns as NOT NULL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tableau has published multiple white papers on performance improvement tips
    and tricks ([https://help.tableau.com/current/pro/desktop/en-us/performance_tips.htm](https://help.tableau.com/current/pro/desktop/en-us/performance_tips.htm))
    that state that programmers and Tableau Desktop do not like `NULL` data. Define
    each column in your tables with an explicit `NOT NULL` if possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, database admins debate when it is and isn’t appropriate to define
    columns as `NOT NULL`; however, two things are clear:'
  prefs: []
  type: TYPE_NORMAL
- en: A primary or foreign key should be defined as `NOT NULL`. This is self-evident
    since primary and foreign keys must be unique by definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, any column that is to be indexed should be defined as `NOT NULL` since,
    otherwise, an index may be unusable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing is discussed more fully in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider the following two questions regarding indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an index?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should be indexed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first of our two questions may be easily answered by a DBA but is likely
    uncharted waters for the average Tableau author. So, to clarify, an index is a
    copy of selected columns in a database table that has been optimized for efficient
    searching. Since these copied columns include pointers to the original columns,
    they can be accessed to quickly find given rows and return the required data.
  prefs: []
  type: TYPE_NORMAL
- en: A small example may prove helpful. According to the Boeing Company, the 787
    Dreamliner has about 2.3 million parts. Imagine a table that lists all these parts
    in the **Part_Name** column. Your task is to search this column for every part
    starting with the “fuse” string. On a non-indexed column, this would require the
    examination of every row of data in the database. Such a search could be quite
    slow. Fortunately, indexes can be used to reduce the number of rows searched,
    thus making the process much faster. One type of structured data used for indexing
    is B-tree. A B-tree data structure is sorted. Thus, when accessing an index using
    a B-tree data structure to search for all parts starting with *fuse*, not every
    row has to be considered. Instead, the database can skip straight to *fs* and
    quickly return the desired rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s move on to the second question on indexing. What should be indexed?
    This question can be answered succinctly: ideally, all columns used for joining
    or filtering should be indexed in the data source.'
  prefs: []
  type: TYPE_NORMAL
- en: Although there are some basic performance considerations for creating more efficient
    joins in Tableau (for example, avoid an outer join when a left join will suffice),
    join performance is largely determined outside of Tableau. Therefore, it is typically
    more important to index columns used in joins than those used for filtering.
  prefs: []
  type: TYPE_NORMAL
- en: To continue with our discussion of manipulating data sources, the next section
    will cover how Tableau can be used to create summarized datasets through extracting.
  prefs: []
  type: TYPE_NORMAL
- en: Working with extracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will discuss what a Tableau data extract is as well as how to efficiently
    construct an extract. A colleague of mine recently consulted with a relatively
    small mobile phone service provider. Even though the company was small, the volume
    could be in excess of 1,000,000 calls per day. Management at the company insisted
    on the ability to interface with detailed visualizations of individual calls in
    Tableau workbooks. The performance of the workbooks was, understandably, a problem.
    Was such low-level detail necessary? Might less detail and snappier workbooks
    have led to better business decisions?
  prefs: []
  type: TYPE_NORMAL
- en: In order to balance business needs with practical performance requirements,
    businesses often need to ascertain what level of detail is genuinely helpful for
    reporting. Often, detailed granularity is not necessary. When such is the case,
    a summary table may provide sufficient business insight while enabling quick performance.
    In the case of the mobile phone service provider, a daily snapshot of call volumes
    may have sufficed. Even an hourly snapshot would have greatly reduced the table
    size and improved Tableau’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: To address this common business need, an extract is a proprietary compressed
    data source created by Tableau Desktop. Since its release, the file extension
    for an extract has changed from `.tde` to the `.hyper` format. Thus, the new format
    makes use of the Hyper engine, which was discussed in *Chapter 1*, *Reviewing
    the Basics*. An extract can be stored locally and accessed by Tableau to render
    visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following points that make an extract file an excellent choice
    for improved performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracts can be quickly generated at an aggregate level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts are a columnar store, which records as sequences of columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases typically store data using a **Row Store** methodology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, note that **Row Store** is excellent for returning
    individual rows, whereas **Column Store** is much better for returning aggregated
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Table** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Instrument | Store | Price |'
  prefs: []
  type: TYPE_TB
- en: '| Row 1 | Selmer Trumpet | North | $3,500 |'
  prefs: []
  type: TYPE_TB
- en: '| Row 2 | Conn French Horn | East | $4,500 |'
  prefs: []
  type: TYPE_TB
- en: '| Row 3 | Getzen Trombone | South | $2,500 |'
  prefs: []
  type: TYPE_TB
- en: '| Row 4 | Miraphone Tuba | West | $9,000 |'
  prefs: []
  type: TYPE_TB
- en: 'Here is a **Row Store** table in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Row 1** | Selmer Trumpet |'
  prefs: []
  type: TYPE_TB
- en: '|  | North |'
  prefs: []
  type: TYPE_TB
- en: '|  | $3,500 |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 2** | Conn French Horn |'
  prefs: []
  type: TYPE_TB
- en: '|  | East |'
  prefs: []
  type: TYPE_TB
- en: '|  | $4,500 |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 3** | Getzen Trombone |'
  prefs: []
  type: TYPE_TB
- en: '|  | South |'
  prefs: []
  type: TYPE_TB
- en: '|  | $2,500 |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 4** | Miraphone Tuba |'
  prefs: []
  type: TYPE_TB
- en: '|  | West |'
  prefs: []
  type: TYPE_TB
- en: '|  | $9,000 |'
  prefs: []
  type: TYPE_TB
- en: 'Here is a **Column Store** table in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instrument** | Selmer Trumpet |'
  prefs: []
  type: TYPE_TB
- en: '|  | Conn French Horn |'
  prefs: []
  type: TYPE_TB
- en: '|  | Getzen Trombone |'
  prefs: []
  type: TYPE_TB
- en: '|  | Miraphone Tuba |'
  prefs: []
  type: TYPE_TB
- en: '| Store | North |'
  prefs: []
  type: TYPE_TB
- en: '|  | East |'
  prefs: []
  type: TYPE_TB
- en: '|  | South |'
  prefs: []
  type: TYPE_TB
- en: '|  | West |'
  prefs: []
  type: TYPE_TB
- en: '| Price | $3,500 |'
  prefs: []
  type: TYPE_TB
- en: '|  | $4,500 |'
  prefs: []
  type: TYPE_TB
- en: '|  | $2,500 |'
  prefs: []
  type: TYPE_TB
- en: '|  | $9,000 |'
  prefs: []
  type: TYPE_TB
- en: I hope you could see that in a **Column Store** table, each *n* row of a certain
    attribute makes up for the first row. For example, the first row of `Instrument`,
    the first row of `Store`, and the first row of `Price` all relate to one entry,
    whereas in a **Row Store** table, all rows that belong to the same entry are in
    consecutive order.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up what we have learned so far in this section, extracts use compression
    techniques to reduce file size while maintaining performance and utilize RAM and
    hard drive space for optimal performance. Neither of those two things happens
    when using a live connection to a database—therefore, extracts can improve the
    performance of your dashboard whenever the database can’t.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing an extract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will discuss extracts from a performance aspect. Other aspects
    of extracts, such as scheduling and incremental refreshes, will not be considered
    here, but you can find more information here: [https://help.tableau.com/current/pro/desktop/en-us/extracting_refresh.htm](https://help.tableau.com/current/pro/desktop/en-us/extracting_refresh.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the *Small extracts* section earlier, an extract is created
    via **Data** | **[Data Source]** | **Extract Data**. From the resulting dialog
    box, we can take the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter the extract as needed**: Sometimes, an extract that precisely reflects
    a data source is warranted, but often filtering various fields will still populate
    the extract with the required data while shrinking the size and improving performance.
    To add a filter, simply click **Add...** to access a dialog box identical to the
    **Filter** dialog box used within a worksheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregate to the level of granularity represented in the view**: Aggregation
    not only reduces the file size but can also be helpful from a security standpoint.
    Without aggregation, an extract is constructed using row-level data. Therefore,
    the Tableau author should note that if the extract is built without choosing to
    aggregate, any sensitive row-level data is accessible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce the number of rows**: As shown in the *Small extracts* section, reducing
    the number of rows can allow the author to create a small, local extract for quick
    workbook building, after which the original data source can be accessed for complete
    analysis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Reducing rows'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hide all unused fields**: This option excludes all columns that are not used
    in the workbook from the extract. This can significantly reduce the extract size
    and increase performance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18435_13_11.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.11: Hiding fields'
  prefs: []
  type: TYPE_NORMAL
- en: By taking these four measures, your performance should improve immediately.
    Feel free to test it yourself by using the performance-recording tool and creating
    different extracts of the same data source. Using aggregation and performance-recording
    actions will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following exercise will use two aggregates from a single data source, one
    at the **State** level and the other at the **City** level. These aggregated data
    sources will be used to create two worksheets. Each of these worksheets will be
    placed on a dashboard along with a third worksheet with row-level information.
    Finally, filter actions will be created to tie the three worksheets together.
    The purpose of the exercise is to demonstrate how small extracts might be used
    in conjunction with a larger dataset to create a more performant dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the workbook associated with this chapter and navigate to the `State Agg`
    worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Data** pane, select the `State Agg` data source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a filled map using state by placing **State** on the **Detail** shelf
    and selecting **Filled Map** from the **Marks** card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `State Agg` data source and select **Extract Data**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that Tableau displays an error stating that it cannot find the referenced
    file. You can either point to the instance of `Superstore` that ships with Tableau
    or you can use the instance provided via the GitHub link: [https://github.com/PacktPublishing/Mastering-Tableau-2023-Fourth-Edition/tree/main](https://github.com/PacktPublishing/Mastering-Tableau-2023-Fourth-Edition/tree/main).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After connecting to the data source, Tableau will display the **Extract Data**
    dialog box. Within the dialog box, select **Aggregate data for visible** **dimensions**
    and **All rows**. Click the **Hide All Unused Fields** button and then click on
    **Extract**:![](img/B18435_13_12.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.12: Extracting data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the resulting extract only contains **State**. Also note that the
    data has been aggregated so that no underlying data is available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the `City Agg` worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Data** pane, select the `City Agg` data source. Note that this data
    source has already been extracted and so only contains **State**, **City**, and
    **Sales**. Also note that the data has been aggregated so that no underlying data
    is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place **City** on the **Rows** shelf, **Sales** on the **Text** shelf, and **State**
    on the **Detail** shelf. Don’t forget to include **State** even though it does
    not display on the view. It must be used so that the dashboard created at the
    end of the exercise works correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `Row Detail` worksheet and select the `Superstore` dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a crosstab view that displays **Customer Name**, **Order ID**, **Row
    ID**, **Profit**, and **Sales**. One quick way to create this view is to double-click
    on each field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `Agg Dash` dashboard and place each of the three worksheets
    on the dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a blend relationship between **City** and **State** from the **Superstore**
    and **City Agg** data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Blend'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following action via **Dashboard** | **Actions** | **Add Action**
    | **Filter**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Adding City to Detail action'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following action via **Dashboard** | **Actions** | **Add Action**
    | **Filter**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Adding State to City action'
  prefs: []
  type: TYPE_NORMAL
- en: After creating these two actions, in the dashboard, click on the **State** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the **City** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on a blank portion of the `City Agg` worksheet to exclude all values on
    **Row Detail**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on a blank portion of the `State Agg` worksheet to exclude all values
    on **City Agg**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Format the dashboard as desired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18435_13_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: Action on dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having completed this exercise, note that the resulting dashboard is performant
    for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user first opens the dashboard, only **State Agg** displays. This is
    performant for two reasons. First, displaying a single worksheet as opposed to
    every worksheet when opening the dashboard causes fewer initial queries and less
    rendering. Second, accessing a small extract is quicker than accessing a larger
    data source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `City Agg` worksheet is also accessing a small extract, when the user
    clicks on a state, the **City Agg** worksheet will appear quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on **City**, a call is made to the data source that only
    includes the information for that city. A relatively small amount of data is pulled,
    and performance should be good for even larger datasets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another aspect of good performance practice, apart from using aggregate extracts,
    should be considered for this exercise. The dashboard contains no quick filters.
    Often, using quick filters on a dashboard is unnecessary. If the worksheets on
    the dashboard can be used to filter, those worksheets can essentially do double
    duty. That is to say, worksheets can provide valuable analysis while simultaneously
    acting as filters for other worksheets on the dashboard. This represents a performance
    improvement over using quick filters since adding quick filters would cause additional
    queries to be sent to the underlying data source.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding dashboard, each worksheet references a different data source.
    Therefore, you may ask, how are the action filters able to function across the
    different data sources? The answer can be found in the filter action dialog box.
    As shown in *Figure 13.14* and *Figure 13.15*, **All** fields are considered **Target
    Filters**. Tableau simply matches any fields of the same name across each data
    source. Extracts can be optimized for even better performance results. We’ll cover
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing extracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optimization accelerates performance by materializing calculated fields when
    possible. This means that Tableau generates values for calculated fields in the
    extract so that those values can be looked up instead of calculated. If you were
    to use table calculations, Tableau would have to calculate the values each time
    you change the view.
  prefs: []
  type: TYPE_NORMAL
- en: Note that not all calculated fields are materialized. Fields that are not materialized
    include table calculations, changeable or unstable functions, such as `NOW()`
    and `TODAY()`, and calculated fields using parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an extract is first created, it is automatically optimized. In other words,
    calculated fields are automatically materialized when possible. However, over
    the course of time, calculated fields may be altered that will cause the extract
    to drop materialized fields. At such times, open **Data** | **[Data Source]**
    | **Extract** and click on **Compute** **Calculations Now** in order to regenerate
    the materialized fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: Computing calculations'
  prefs: []
  type: TYPE_NORMAL
- en: If an extract is set to refresh on Tableau Server, the extract is automatically
    optimized for each refresh.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you make use of parameters in your dashboard, check whether you
    can eliminate those and use calculations instead to improve performance. Also,
    split calculations if they can’t be materialized as a whole. Put the part that
    can be materialized in one calculated field and the non-materialized part in another.
    If parts of the calculation can be calculated within the extract creation, you
    will gain performance.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using extracts has now been discussed in great detail, so let’s
    move on and see how we can make the most out of filters.
  prefs: []
  type: TYPE_NORMAL
- en: Using filters wisely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filters generally improve performance in Tableau. For example, when using a
    dimension filter to view only the West region, a query is passed to the underlying
    data source, resulting in information being returned for just that region. By
    reducing the amount of data returned, performance improves. This is because less
    data means reduced network bandwidth load, reduced database processing requirements,
    and reduced processing requirements for the local computer.
  prefs: []
  type: TYPE_NORMAL
- en: Filters can also negatively impact Tableau’s performance. For example, using
    **only relevant values** causes additional queries to be sent to the underlying
    data source, thereby slowing down the response time. Also, creating quick filters
    from high-cardinality dimensions can impair performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tableau’s filters are executed in a specific order, so keep this in mind when
    using them. The following flowchart, along with a link to an hour-long presentation,
    may help you grasp the concept fully: [https://help.tableau.com/current/pro/desktop/en-us/order_of_operations.htm](https://help.tableau.com/current/pro/desktop/en-us/order_of_operations.htm):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: Filtering the order of operations'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section follows, step by step, the order of operations. By
    the end of it, you will know which filters to use in which situation so as to
    achieve the best performance for your dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Extract filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extract filters remove data from the extracted data source. Simply put, the
    data isn’t there. Thus, performance is enhanced by reducing the overall amount
    of data. Performance may also be improved since extracted data uses Tableau’s
    proprietary columnar dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, extracts are always flattened, which will have performance advantages
    over connecting to datasets using joins. To create an extract filter, begin by
    selecting **Data** | **[Data Source]** | **Extract Data**. In the resulting dialog
    box, choose to add a filter.
  prefs: []
  type: TYPE_NORMAL
- en: Data source filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data source filters are applied throughout the workbook. For example, if you
    create a data source filter that removes all members of the **Country** dimension
    except the USA, the **Country** dimension will only include the USA for all worksheets
    in the workbook.
  prefs: []
  type: TYPE_NORMAL
- en: Data source filters improve performance in the same way as dimension and measure
    filters; that is, data source filters cause Tableau to generate a query to the
    underlying data source, which will limit the data that is returned. Less returned
    data generally results in quicker processing and rendering. A further advantage
    that data source filters offer is ease of authoring. For example, if the Tableau
    author knows in advance that an entire workbook is going to be USA-centric, creating
    a data source filter saves you the trouble of applying a dimension filter to every
    worksheet in the workbook using that data source.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that data source filters occur quite early in the process flow. All
    calculations (including calculations using fixed LOD expressions that are rendered
    before dimension and measure filters are triggered) respect data source filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a data source filter, click the **Data Source** tab located in the
    bottom-left corner of **Tableau Desktop**. Then, click on the **Add** link located
    in the top-right corner of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: Adding filters'
  prefs: []
  type: TYPE_NORMAL
- en: Context filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A context filter is created simply by right-clicking on a field in the **Filter**
    shelf and selecting **Add to Context**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: Context filters'
  prefs: []
  type: TYPE_NORMAL
- en: Dimension and measure filters are independent. Each filter queries the data
    source independently and returns results. A context filter, on the other hand,
    will force dimension and measure filters to depend on it. This behavior can be
    helpful (and necessary) for getting the right answer in some circumstances. For
    instance, if a Tableau author accesses the **Superstore** dataset and uses a filter
    on **Product Names** to return the top-10 selling product names in a single category,
    it will be necessary for **Category** to be defined as a context filter. Otherwise,
    the **Product Names** filter will return the top 10 overall. Because of this,
    context filters improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Dimension and measure filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dimension and measure filters can improve performance. Since either a dimension
    filter or a measure filter will cause Tableau to generate a query to the underlying
    data source, which will limit the data that is returned, performance is improved.
    Simply put, the smaller the returned dataset, the better the performance.
  prefs: []
  type: TYPE_NORMAL
- en: However, dimension and measure filters can degrade performance. Since Tableau
    not only generates queries to the underlying data source in order to display visualizations
    but also generates queries to display filters, more displayed filters will slow
    performance. Furthermore, displayed filters on high-cardinality dimensions can
    inhibit performance. (A dimension with many members is referred to as having high
    cardinality.) Consider the example of a filter that displays every customer in
    a dataset. Performance for such a filter might be slow because every customer
    in the underlying dataset must be located and returned, and then Tableau has to
    render and display each of these customers in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using two or more dimension or measure filters on a view, a relevant filter
    may be used to limit the choices that display. For example, if a view includes
    a filter for city and postal code, the latter might be set to show **Only Relevant
    Values**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: Only Relevant Values'
  prefs: []
  type: TYPE_NORMAL
- en: This is advantageous to the end user in that it adjusts the number of postal
    codes that display to reflect only those pertinent to the cities selected in the
    first filter. However, using relative filters will cause additional queries to
    be sent to the data source and thus may degrade performance.
  prefs: []
  type: TYPE_NORMAL
- en: Table calculation filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using table calculations as filters does not have the same corresponding performance
    enhancements as dimension or measure filters. As discussed above, dimension and
    measure filters reduce the returned dataset, while table calculation filters do
    not. In the Tableau process flow, table calculations are not rendered until after
    the data is returned from the data source. This means that table calculations
    cannot be used to generate queries to limit returned data. Or, to put it another
    way, table calculation filters cause all data related to a given dimension or
    measure to be returned, after which Tableau executes the filter on the returned
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the workbook associated with this chapter and navigate to the `Late Filter`
    worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Data** pane, select the `Superstore` data source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a calculated field named `Cust Name Tbl Calc` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place **Customer Name** on the **Rows** shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place **Cust Name Tbl Calc** on the **Filters** shelf and constrain to show
    only **Aaron Bergman**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place **Sales** on the **Text** shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **Sales** and select **Quick Table Calculation** | **Rank**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, the entire list of customers is returned to Tableau, after
    which Tableau deploys the filter. Essentially, using **Cust Name Tbl Calc** as
    a filter merely hides the underlying data. This is useful because the rank returned
    for **Aaron Bergman** is correct. Merely filtering on **Customer Name** would
    return a rank of **1** for **Aaron Bergman**. Unfortunately, the correct results
    come with a performance hit. Running the performance recorder on this exercise
    will show that the table calculation negatively impacts performance.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, with the advent of LOD calculations, using table calculations as
    filters is often not necessary. LODs are calculated fields that include or exclude
    data independent of the current view. For more information, please refer to *Chapter
    5*, *Introducing Table Calculations*.
  prefs: []
  type: TYPE_NORMAL
- en: Using actions instead of filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to improve performance might be to use actions instead of filters.
    You can develop a dashboard that shows a high-level overview first and goes into
    detail only once the user selects something. The mechanics are similar to the
    ones we showed in the *Aggregation* section; however, aggregation happens per
    worksheet and not on the data source itself. By selecting a mark in the high-level
    overview, an action will be triggered. The user can dive deeper into details,
    but the level of detail will only be increased step by step. Hence, less data
    has to be loaded at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very nice presentation regarding this topic can be found at [https://youtu.be/veLlZ1btoms](https://youtu.be/veLlZ1btoms).
    Or if you are interested in learning more about the Hot-Warm-Cold method, feel
    free to read this article: [https://gemshare.org/2019/08/16/hot-warm-cold-data-architecture-best-practices/](https://gemshare.org/2019/08/16/hot-warm-cold-data-architecture-best-practices/).'
  prefs: []
  type: TYPE_NORMAL
- en: The next topic we will be discussing involves calculations. How can we write
    a calculation in the most efficient and performant way?
  prefs: []
  type: TYPE_NORMAL
- en: Efficient calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calculations may be constructed differently and yet accomplish the same thing.
    Look, for instance, at the following example, which shows that an `IF` statement
    can be replaced by simpler code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scenario I** | **Scenario II** |'
  prefs: []
  type: TYPE_TB
- en: '| Create a calculated ﬁeld with the following code:`IF SUM (Profit) > 0 THEN
    ''Profitable'' ELSE ''Unprofitable'' END`Place the calculated ﬁeld on the **Color**
    shelf. | Create a calculated ﬁeld with the following code:`SUM (Profit) > 0`Place
    the calculated ﬁeld on the **Color** shelf.Right-click on **True** and **False**
    in the resulting legend and rename **Proﬁtable** and **Unproﬁtable**. |'
  prefs: []
  type: TYPE_TB
- en: Since either of these scenarios will return the desired results, which should
    be used? The deciding factor is performance. This section will explore what to
    do and what to avoid when creating calculated fields in order to maximize performance.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing code values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calculations that use Boolean values or numbers are more performant than those
    that use dates. Calculations that use dates, in turn, are more performant than
    those using strings. This is not only true of Tableau, but also in computer science
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this information, **Scenario II** listed in the preceding table is
    more performant than **Scenario I**. **Scenario I** causes Tableau to create a
    query that requires the data source engine to handle strings for reporting profitability,
    whereas **Scenario II** sends only 1s and 0s to determine profitability. The third
    step for **Scenario II** (that is, aliasing **True** and **False** to **Profitable**
    and **Unprofitable**) is merely a labeling change that happens after the aggregate
    dataset is returned from the data source, which is quick and easy for Tableau.
  prefs: []
  type: TYPE_NORMAL
- en: Level-of-detail calculations or table calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some instances, a **level-of-detail** (**LOD**) calculation might be faster
    than a table calculation and vice versa. If you are not sure, try both to see
    which one performs better. You can, of course, run a performance recording too.
    Also, if they’re not really needed, use neither. Refer to the following diagram,
    which explains when to choose which:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: Choosing a calculation type'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram, along with more advice about selecting a calculation type, can
    be accessed at [https://www.tableau.com/about/blog/2016/4/guide-choosing-right-calculation-your-question-53667](https://www.tableau.com/about/blog/2016/4/guide-choosing-right-calculation-your-question-53667).
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to improve performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To conclude this chapter, let’s consider a few other possibilities for improving
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid overcrowding a dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, end users want to see everything at once on a dashboard. Although this
    may be perceived as beneficial, it often is not. Consider the inclusion of a large
    crosstab on a dashboard. Does scrolling through pages of details add to the analytical
    value of the dashboard? Perhaps the answer is “no.” Furthermore, an excess of
    information on a dashboard may obscure important insights. Diplomatically arguing
    for leaner dashboards may lead to better decision making as well as better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing dashboard sizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dashboards can be set to an exact size or to **Range** or **Automatic**. Exact
    size results in quicker performance because once Tableau Server has rendered a
    view for one end user, that render stays in the cache and can be reused for the
    next end user that accesses that dashboard. **Automatic** and **Range**, on the
    other hand, cause Tableau Server to attempt to determine the resolution size used
    by each end user and render the dashboard accordingly. This means that Tableau
    Server does not use the instance of the dashboard stored in the cache for the
    next end user. This, in turn, impacts performance.
  prefs: []
  type: TYPE_NORMAL
- en: Use Tableau Prep Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This has been mentioned before but is very relevant, therefore I will repeat:
    **If complex joins and complex data blending are required to generate useful results,
    it may be advisable to perform ETL work outside of Tableau**, for example, in
    Tableau Prep Builder (see *Chapter 3*, *Using Tableau Prep Builder*, for more
    information on this service). ETL work will ideally lead to better data modeling,
    aggregated data, or data that contains additional columns already that you would
    otherwise have to create in Tableau Desktop, and thus using Prep Builder leads
    to easier authoring and quicker performance in Tableau.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an end user is expecting near-instantaneous performance, then, of course,
    anything less is disappointing. Explaining in advance that a complicated, detail-oriented
    dashboard may not be performant can help in at least two ways. First, upon explaining
    the likely performance problems, a compromise may be reached that results in the
    creation of a less complicated dashboard that still delivers valuable information.
    Second, if it is absolutely necessary for the dashboard to be complicated and
    detail-oriented, at least the end user has been warned that patience may be needed
    when interfacing it.
  prefs: []
  type: TYPE_NORMAL
- en: Workbook Optimizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, for the lazy ones among us – or one might say – efficient ones, Tableau
    released a fantastic feature not that long ago: the Workbook Optimizer. It checks
    your workbook based on a set of rules and will respond with three types of categories:
    take action, needs review, and passed. Thus, it completes performance checks using
    the well-known RAG (red-amber-green) or traffic light system for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, rules include: calculation length, calculation using
    multiple data sources, dashboard size not fixed, filter uses conditional logic,
    filter uses “only relevant values,” live data connections, multiple connections
    in a data source, nested calculations, non-materialized calculations, number of
    data sources, number of filters, number of layout containers, number of LOD calculations,
    number of views in a dashboard, number of workbook sheets, unused data sources,
    unused fields, uses data blending, uses date calculations, and uses grouping.
    I am sure, however, there are more rules to come and it will become increasingly
    easy to have a high-performing dashboard. You can access the Workbook Optimizer
    feature by selecting **Server** | **Run Optimizer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: Run Optimizer'
  prefs: []
  type: TYPE_NORMAL
- en: You will then be able to drill down per category and see where your dashboard
    needs improvement. For most of the rules, some human intervention is required
    but for some, a click of a button is sufficient, like in *Figure 13.24*. Observe
    the icons below the rule – the wrench indicates that Tableau can fix this for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.24: Unused fields'
  prefs: []
  type: TYPE_NORMAL
- en: For each rule, Tableau also provides a **Learn More** hyperlink that will redirect
    you to one of the Tableau help pages with further explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18435_13_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.25: Number of data sources'
  prefs: []
  type: TYPE_NORMAL
- en: Isn’t this feature amazing?! From now on, always make sure to use the **Run
    Optimizer** button!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter with a discussion of the performance-recording dashboard.
    This was important because many of the subsequent exercises utilized the performance-recording
    dashboard to examine underlying queries. Next, we discussed hardware and on-the-fly
    techniques, where the intent was to communicate hardware considerations for good
    Tableau performance and, in the absence of optimal hardware, techniques for squeezing
    the best possible performance out of any computer.
  prefs: []
  type: TYPE_NORMAL
- en: Then we covered working with data sources, including joining, blending, and
    efficiently working with data sources. This was followed by a discussion on generating
    and using extracts as efficiently as possible. By focusing on data sources for
    these three sections, we learned best practices and what to avoid when working
    with either remote datasets or extracts. The next sections explored performance
    implications for various types of filters and calculations. Lastly, we looked
    at additional performance considerations, where we explored a few more thoughts
    regarding dashboard performance as well as setting expectations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention to Tableau Server. Tableau Server
    is a dense topic worthy of its own book; therefore, our exploration will be truncated
    to only focus on Tableau Server from the Tableau Desktop author’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/tableau](https://packt.link/tableau)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2044012316175764640.png)'
  prefs: []
  type: TYPE_IMG
