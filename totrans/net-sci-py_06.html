<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer092" class="IMG---Figure">
			<h1 id="_idParaDest-154" class="chapter-number"><a id="_idTextAnchor228"/>6</h1>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor229"/>Graph Construction and Cleaning</h1>
			<p>We have covered quite a lot of ground up to this point. In the previous chapters, we introduced NLP, network science, and social network analysis, and we learned how to convert raw text into network data. We even visualized a few of these networks. I hope that seeing text converted into a visualized network had the same impact on you as it did on me. The first time I attempted this, I used the book of Genesis, from the Bible, and being able to convert text from thousands of years ago into an actual interactive network took my <span class="No-Break">breath away.</span></p>
			<p>In the previous two chapters, we learned a few different ways to collect text data from websites and social networks on the internet and to use that text data to create networks. The good news is that I don’t need to show you more ways to scrape text. You have enough options, and you should be able to use this knowledge as a foundation for other kinds <span class="No-Break">of scraping.</span></p>
			<p>The bad news is that it is time to get to everybody’s “favorite” topic: cleaning data! In all honesty, this is my favorite part of working with network data. Cleaning takes work, but it’s pretty simple. This is a good time to throw on some music, make a hot beverage, relax, and hunt for little problems <span class="No-Break">to fix.</span></p>
			<p>To make this chapter especially fun, we will be using the social network from <em class="italic">Alice’s Adventures in Wonderland</em>. I have created this network using the process described in previous chapters. As we have gone over the steps a few times now, I’m going to skip explaining how to convert text into entities, entities into network data, and network data into graphs. The raw network data has been pushed to my GitHub, and we’ll use that for <span class="No-Break">this chapter.</span></p>
			<p>We will be covering the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Creating a graph from an <span class="No-Break">edge list</span></li>
				<li><span class="No-Break">Listing nodes</span></li>
				<li><span class="No-Break">Removing nodes</span></li>
				<li>Quick <span class="No-Break">visual inspection</span></li>
				<li><span class="No-Break">Renaming nodes</span></li>
				<li><span class="No-Break">Removing edges</span></li>
				<li>Persisting <span class="No-Break">the network</span></li>
				<li>Simulating <span class="No-Break">an attack</span></li>
			</ul>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor230"/>Technical requirements</h1>
			<p>In this chapter, we will be using the NetworkX and pandas Python libraries. We will also import an NLTK tokenizer. By now, all of these libraries should be installed, so they should be ready for <span class="No-Break">your use.</span></p>
			<p>All the code for this chapter is available in this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Network-Science-with-Python"><span class="No-Break">https://github.com/PacktPublishing/Network-Science-with-Python</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor231"/>Creating a graph from an edge list</h1>
			<p>We are <a id="_idIndexMarker421"/>going to be using this file as our original edge list: <a href="https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv">https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv</a>. Let’s take <span class="No-Break">a look:</span></p>
			<ol>
				<li>Before we can create our graph, we must import the two libraries we will be working with: <strong class="source-inline">pandas</strong> and <strong class="source-inline">networkx</strong>. We use <strong class="source-inline">pandas</strong> to read the edge list into a DataFrame, and we pass that DataFrame to <strong class="source-inline">networkx</strong> to create a graph. You can import both <span class="No-Break">like so:</span><pre class="source-code">
import pandas as pd</pre><pre class="source-code">
import networkx as nx</pre></li>
				<li>With the libraries imported, let’s use pandas to read the CSV file into a DataFrame and then display it, as shown in the following <span class="No-Break">code block:</span><pre class="source-code">
data = 'https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv'</pre><pre class="source-code">
network_df = pd.read_csv(data)</pre><pre class="source-code">
network_df.head()</pre></li>
			</ol>
			<p>If you run this in a Jupyter notebook, you should see the <span class="No-Break">following DataFrame:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B17105_06_001.jpg" alt="Figure 6.1 – pandas DataFrame of the Alice in Wonderland edgelist" width="330" height="310"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – pandas DataFrame of the Alice in Wonderland edge list</p>
			<p>Before we<a id="_idIndexMarker422"/> move on, I want to say that if you can represent any two things as having a relationship, you can use that as network data. In our DataFrame, the source and target entities are people, places, and organizations, as we configured in our <strong class="bold">Named-Entity Recognition</strong> (<strong class="bold">NER</strong>) work, but you could also make networks of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Ingredients <span class="No-Break">and dishes</span></li>
				<li>Students <span class="No-Break">and teachers</span></li>
				<li>Planets and <span class="No-Break">star systems</span></li>
			</ul>
			<p>I could go on and on forever. Realizing just how prevalent networks are around us and then seeing them in everything: that’s the precursor to unlocking the power of network analysis. This is about understanding the relationships between things. I am interested in literature and security, and most of my network analysis has to do with the overlap between human language and security. You may have other interests, so you will find more use in other types of networks. Try to take from this book and use it to inspire you toward new ways of researching topics <span class="No-Break">of interest.</span></p>
			<p>Now that that’s out of the way, we have our edge list DataFrame, so let’s convert this into a graph. In its simplest form, this is as easy as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
G = nx.from_pandas_edgelist(network_df)</pre>
			<p>Really? That’s it? Yes, that’s it. When I first learned that it was this easy to go from a <strong class="source-inline">pandas</strong> DataFrame to a usable graph, I was instantly hooked. It’s this easy. But it is this easy for <a id="_idIndexMarker423"/>a <span class="No-Break">few reasons:</span></p>
			<ul>
				<li>First, this <strong class="source-inline">networkx</strong> function expects <strong class="bold">source</strong> and <strong class="bold">target</strong> columns in the DataFrame. As our <strong class="source-inline">.csv</strong> file came with those columns, we didn’t need to rename any columns or specify to the function which columns were our sources <span class="No-Break">and targets.</span></li>
				<li>Second, we aren’t specifying what kind of graph to use, so <strong class="source-inline">networkx</strong> defaults to <strong class="source-inline">nx.Graph()</strong>. This is the simplest form of graph, allowing only a single edge between nodes, and not <span class="No-Break">including directionality.</span></li>
			</ul>
			<p>In a notebook, if we were to inspect <strong class="source-inline">G</strong>, we would see <span class="No-Break">the following:</span></p>
			<pre class="source-code">
G
&lt;networkx.classes.graph.Graph at 0x255e00fd5c8&gt;</pre>
			<p>This verifies that we are working with the default graph type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Graph</strong></span><span class="No-Break">.</span></p>
			<p>There are several ways to load network data into <strong class="source-inline">networkx</strong>, but I prefer to use edge list. At their simplest, edge lists are tabular data with two fields: <em class="italic">source</em> and <em class="italic">target</em>. Because of this simplicity, they can easily be stored as raw text or in databases. You don’t need a fancy graph database to store an <span class="No-Break">edge list.</span></p>
			<p>Others prefer to use an adjacency matrix when working with network data. Adjacency matrices cannot be stored easily in a database, nor do they scale out well. Use whatever you prefer, but edge lists are very easy to work with, so I recommend learning to use, create, and <span class="No-Break">store them<a id="_idTextAnchor232"/>.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor233"/>Types of graphs</h2>
			<p>NetworkX offers four <a id="_idIndexMarker424"/>different types <span class="No-Break">of graphs:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Graph</strong></span></li>
				<li><span class="No-Break"><strong class="bold">DiGraph</strong></span></li>
				<li><span class="No-Break"><strong class="bold">MultiGraph</strong></span></li>
				<li><span class="No-Break"><strong class="bold">MultiDiGraph</strong></span></li>
			</ul>
			<p>You can learn more about them here: <a href="https://networkx.org/documentation/stable/reference/classes/">https://networkx.org/documentation/stable/reference/classes/</a>. I will give a short overview and my thoughts on each type of graph as to when it <span class="No-Break">is usefu<a id="_idTextAnchor234"/>l.</span></p>
			<h3>Graph</h3>
			<p><strong class="bold">Graph</strong> is the<a id="_idIndexMarker425"/> default and simplest form of a graph that NetworkX provides. In a simple graph, nodes can have only a single edge between them and another node. If your edge list contains multiple edges between a source and a target, it’ll be reduced to a single edge. This isn’t always a bad thing. There are approaches to reduce the complexity of networks, and one approach is to aggregate the data – for instance, counting the number of edges that exist between two nodes and keeping that value as a weighted count, rather than the edge list being <span class="No-Break">the following:</span></p>
			<p><span class="No-Break"><em class="italic">source, target</em></span></p>
			<p>Instead, it would be <span class="No-Break">like so:</span></p>
			<p><em class="italic">source, </em><span class="No-Break"><em class="italic">target, edge_count</em></span></p>
			<p>In that form, a graph still works well, because multiple edges have been reduced to a single edge, and the number of edges that existed has been reduced to a count. This is a very good way of simplifying network data while keeping all of <span class="No-Break">the information.</span></p>
			<p>For most of my work, a graph works fine. If I’ve decided against a default graph, it’s because I needed directionality, so I chose a <span class="No-Break"><strong class="source-inline">DiGraph</strong></span><span class="No-Break"> instead.</span></p>
			<p>Creating a default graph network can be done with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
G = nx.from_pandas_edgelist(network_<a id="_idTextAnchor235"/>df)</pre>
			<h3>DiGraph</h3>
			<p>A <strong class="source-inline">DiGraph</strong> is<a id="_idIndexMarker426"/> similar <a id="_idIndexMarker427"/>to a graph, with the main difference being that it is directed. DiGraph stands for <strong class="bold">directed graph</strong>. Just as with a graph, each node can only have one edge between itself and another node. Most of what I said about aggregation still applies, but you may need to handle self-loops if you run <span class="No-Break">into them.</span></p>
			<p>These are very useful when you need to understand the directionality and flow of information. It isn’t always enough to know that a relationship exists between two things. It is often most important to understand the directionality of the influence, and how <span class="No-Break">information spreads.</span></p>
			<p>For instance, let’s say we have four people named Sarah, Chris, Mark, and John. Sarah <a id="_idIndexMarker428"/>writes <a id="_idIndexMarker429"/>a lot and shares her ideas with her friend Chris. Chris is a bit of an influencer and shares information that he receives from Sarah (and others) with his following, which includes Mark and John. In this situation, the data flows <span class="No-Break">like this:</span></p>
			<p><em class="italic">Sarah -&gt; Chris -&gt; (Mark </em><span class="No-Break"><em class="italic">and John)</em></span></p>
			<p>In this data flow, Sarah is an important person, because she is the originator of a brand-new piece <span class="No-Break">of information.</span></p>
			<p>Chris is also an important person because information flows through him to many other people. We will learn about how to capture this kind of importance in a later chapter, when we discuss <span class="No-Break">betweenness centrality.</span></p>
			<p>Finally, Mark and John are the receivers of <span class="No-Break">this information.</span></p>
			<p>If this were not a directed graph, we could not visibly tell who created the information or who was the final receiver of the information. This directionality allows us to go to the origins and also follow the <span class="No-Break">information flow.</span></p>
			<p>Directed graphs are also useful in mapping out production data flows that take place on servers and databases in production. When processes are mapped out this way, if something stops working, you can step backward until you discover what is broken. Using this approach, I have been able to troubleshoot problems in minutes that previously <span class="No-Break">took days.</span></p>
			<p>Creating a directed graph is as simple <span class="No-Break">as this:</span></p>
			<pre class="source-code">
G = nx.from_pandas_edgelist(network_df, create_using=nx.DiGraph)</pre>
			<p>If you inspect <strong class="source-inline">G</strong>, you should see <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">&lt;networkx.classes.digraph.DiGraph at 0x255e0<a id="_idTextAnchor236"/>0fcb08&gt;</strong></pre>
			<h3>MultiGraph</h3>
			<p>A <strong class="source-inline">MultiGraph</strong> can <a id="_idIndexMarker430"/>have <a id="_idIndexMarker431"/>multiple edges between any two nodes. A MultiGraph does not retain any context of directionality. To be truthful, I don’t use <strong class="source-inline">MultiGraphs</strong>. I prefer to aggregate the multiple edges down to a count and use either Graph or <strong class="source-inline">DiGraph.</strong> However, if you want to create a MultiGraph, you can do so with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
G = nx.from_pandas_edgelist(network_df, create_using = nx.MultiGraph)</pre>
			<p>If you<a id="_idIndexMarker432"/> inspect <strong class="source-inline">G</strong>, you<a id="_idIndexMarker433"/> will <span class="No-Break">see this:</span></p>
			<pre class="source-code">
<strong class="bold">&lt;networkx.classes.multigraph.MultiGraph at 0x2<a id="_idTextAnchor237"/>55db7afa88&gt;</strong></pre>
			<h3>MultiDiGraph</h3>
			<p>A <strong class="source-inline">MultiDiGraph</strong> can <a id="_idIndexMarker434"/>have multiple edges between any two nodes, and <a id="_idIndexMarker435"/>these graphs also convey the directionality of each edge. I do not use <strong class="source-inline">MultiDiGraphs</strong> as I prefer to aggregate multiple edges down to a count and then use either Graph or <strong class="source-inline">DiGraph.</strong> If you want to create a <strong class="source-inline">MultiDiGraph,</strong> you can do so with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
G = nx.from_pandas_edgelist(network_df, create_using = nx.MultiDiGraph)</pre>
			<p>If you inspect <strong class="source-inline">G</strong>, you should see <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">&lt;networkx.classes.multidigraph.MultiDiGraph at 0<a id="_idTextAnchor238"/>x255e0105688&gt;</strong></pre>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor239"/>Summarizing graphs</h2>
			<p>To make<a id="_idIndexMarker436"/> sure we’ve got everything down, let’s go back over <span class="No-Break">these graphs:</span></p>
			<ol>
				<li value="1">Let’s recreate our graph using a <span class="No-Break">default graph:</span><pre class="source-code">
G = nx.from_pandas_edgelist(network_df)</pre></li>
			</ol>
			<p>Great. We’ve loaded all of that data into <strong class="source-inline">G</strong>. This is a tiny network, so it loads instantly in a Jupyter notebook, and I imagine it will load quickly for you as well. With how fast of an operation that is, I’m often left wanting more, like, “That’s it? I did all that work to create all of that data, and that’s it?” <span class="No-Break">Well, yes.</span></p>
			<ol>
				<li value="2">However, there is one function that is useful for getting a quick overview of <span class="No-Break">a graph:</span><pre class="source-code">
print(nx.info(G))</pre></li>
			</ol>
			<p>If we run that, we’ll <span class="No-Break">see this:</span></p>
			<pre class="source-code">
<strong class="bold">Graph with 68 nodes and 68 edges</strong></pre>
			<p>Neat. This is a tiny, simple network. With so few nodes and edges, this should visualize<a id="_idIndexMarker437"/> nicely enough to assist <span class="No-Break">with cleanup.</span></p>
			<p>There are other ways to quickly inspect a graph, but this is the simplest way. Now, let’s look at the cleanup; we’ll learn more about analyzing networks in <a id="_idTextAnchor240"/><span class="No-Break">later chapters.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor241"/>Listing nodes</h1>
			<p>The <a id="_idIndexMarker438"/>first thing I tend to do after constructing a network from text is to list the nodes that have been added to the network. This allows me to take a quick peek at the node names so that I can gauge the amount of cleanup I will need to do to remove and rename nodes. During our entity extraction, we had the opportunity to clean the entity output. The entity data is used to create the network data that is used to create the graph itself, so there are multiple steps during which cleanup and optimization are possible, and the more that you do upstream, the less that you have to <span class="No-Break">do later.</span></p>
			<p>However, it is still important to take a look at the node names, to identify any strangeness that still managed to find a way into <span class="No-Break">the network:</span></p>
			<ol>
				<li value="1">The simplest way to get a node list is to run the following <span class="No-Break"><strong class="source-inline">networkx</strong></span><span class="No-Break"> command:</span><pre class="source-code">
G.nodes</pre></li>
			</ol>
			<p>This will give you <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">NodeView</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
NodeView(('Rabbit', 'Alice', 'Longitude', 'New Zealand', "Ma'am", 'Australia', 'Fender', 'Ada', 'Mabel', 'Paris', 'Rome', 'London', 'Improve', 'Nile', 'William the Conqueror', 'Mouse', 'Lory', 'Eaglet', 'Northumbria', 'Edwin', 'Morcar', 'Stigand', 'Mercia', 'Canterbury', 'â\x80\x98it', 'William', 'Edgar Atheling', "â\x80\x98I'll", 'Said', 'Crab', 'Dinah', 'the White Rabbit', 'Bill', 'The Rabbit Sends', 'Mary Ann', 'Pat', 'Caterpillar', 'CHAPTER V.', 'William_', 'Pigeon', 'Fish-Footman', 'Duchess', 'Cheshire', 'Hare', 'Dormouse', 'Hatter', 'Time', 'Tillie', 'Elsie', 'Lacie', 'Treacle', 'Kings', 'Queens', 'Cat', 'Cheshire Cat', 'Somebody', 'Mystery', 'Seaography', 'Lobster Quadrille', 'France', 'England', 'â\x80\x98Keep', 'garden_.', 'Hm', 'Soup', 'Beautiful', 'Gryphon', 'Lizard'))</pre>
			<ol>
				<li value="2">That’s readable, but<a id="_idIndexMarker439"/> it could be a little easier on the eyes. This function will clean it up <span class="No-Break">a bit:</span><pre class="source-code">
def show_nodes(G):</pre><pre class="source-code">
    nodes = sorted(list(G.nodes()))</pre><pre class="source-code">
    return ', '.join(nodes)</pre></li>
			</ol>
			<p>This can be run <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
show_nodes(G)</pre>
			<p>This outputs a cleaner <span class="No-Break">node list:</span></p>
			<pre class="source-code">
"Ada, Alice, Australia, Beautiful, Bill, CHAPTER V., Canterbury, Cat, Caterpillar, Cheshire, Cheshire Cat, Crab, Dinah, Dormouse, Duchess, Eaglet, Edgar Atheling, Edwin, Elsie, England, Fender, Fish-Footman, France, Gryphon, Hare, Hatter, Hm, Improve, Kings, Lacie, Lizard, Lobster Quadrille, London, Longitude, Lory, Ma'am, Mabel, Mary Ann, Mercia, Morcar, Mouse, Mystery, New Zealand, Nile, Northumbria, Paris, Pat, Pigeon, Queens, Rabbit, Rome, Said, Seaography, Somebody, Soup, Stigand, The Rabbit Sends, Tillie, Time, Treacle, William, William the Conqueror, William_, garden_., the White Rabbit, â\x80\x98I'll, â\x80\x98Keep, â\x80\x98it"</pre>
			<p>We now have a clean list of nodes that exist in the <em class="italic">Alice’s Adventures in Wonderland</em> social network. Immediately, my eyes are drawn to the last three nodes. These don’t even look like names. We’re going to remove them. I can also see that <strong class="source-inline">CHAPTER V.</strong>, <strong class="source-inline">Soup</strong>, and a few other non-entity nodes were added. This is a common problem when using NLP for Part-of-Speech Tagging (<strong class="source-inline">pos_tagging</strong>) or <strong class="bold">NER</strong>. Both<a id="_idIndexMarker440"/> of these approaches frequently make mistakes on words where the first letter of a word <span class="No-Break">is capitalized.</span></p>
			<p>We have some <a id="_idIndexMarker441"/>work to do. We will remove the nodes that were added by mistake, and we will rename a few of the nodes so that they reference the <span class="No-Break"><em class="italic">White Rabbit</em></span><span class="No-Break">.</span></p>
			<p>When inspecting graphs, I list nodes, not edges. You can list edges with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
G.edges</pre>
			<p>This will give you an <strong class="source-inline">EdgeView</strong>, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
EdgeView([('Rabbit', 'Alice'), ('Rabbit', 'Mary Ann'), ('Rabbit', 'Pat'), ('Rabbit', 'Dinah'), ('Alice', 'Longitude'), ('Alice', 'Fender'), ('Alice', 'Mabel'), ('Alice', 'William the Conqueror'), ('Alice', 'Mouse'), ('Alice', 'Lory'), ('Alice', 'Mary Ann'), ('Alice', 'Dinah'), ('Alice', 'Bill'), ('Alice', 'Caterpillar'), ('Alice', 'Pigeon'), ('Alice', 'Fish-Footman'), ('Alice', 'Duchess'), ('Alice', 'Hare'), ('Alice', 'Dormouse'), ('Alice', 'Hatter'), ('Alice', 'Kings'), ('Alice', 'Cat'), ('Alice', 'Cheshire Cat'), ('Alice', 'Somebody'), ('Alice', 'Lobster Quadrille'), ('Alice', 'â\x80\x98Keep'), ('Alice', 'garden_.'), ('Alice', 'Hm'), ('Alice', 'Soup'), ('Alice', 'the White Rabbit'), ('New Zealand', "Ma'am"), ('New Zealand', 'Australia'), ('Ada', 'Mabel'), ('Paris', 'Rome'), ('Paris', 'London'), ('Improve', 'Nile'), ('Mouse', 'â\x80\x98it'), ('Mouse', 'William'), ('Lory', 'Eaglet'), ('Lory', 'Crab'), ('Lory', 'Dinah'), ('Northumbria', 'Edwin'), ('Northumbria', 'Morcar'), ('Morcar', 'Stigand'), ('Morcar', 'Mercia'), ('Morcar', 'Canterbury'), ('William', 'Edgar Atheling'), ("â\x80\x98I'll", 'Said'), ('the White Rabbit', 'Bill'), ('the White Rabbit', 'The Rabbit Sends'), ('Caterpillar', 'CHAPTER V.'), ('Caterpillar', 'William_'), ('Duchess', 'Cheshire'), ('Duchess', 'Cat'), ('Duchess', 'Lizard'), ('Hare', 'Hatter'), ('Hare', 'Lizard'), ('Dormouse', 'Hatter'), ('Dormouse', 'Tillie'), ('Dormouse', 'Elsie'), ('Dormouse', 'Lacie'), ('Dormouse', 'Treacle'), ('Hatter', 'Time'), ('Kings', 'Queens'), ('Mystery', 'Seaography'), ('France', 'England'), ('Soup', 'Beautiful'), ('Soup', 'Gryphon')])</pre>
			<p>I don’t typically <a id="_idIndexMarker442"/>list edges, because when I remove or rename nodes, the edges will be corrected. Edges to nodes that have been removed will be removed as well. Edges to nodes that have been renamed will be connected to the renamed node. <strong class="source-inline">EdgeView</strong> is also more confusing to <span class="No-Break">look at.</span></p>
			<p>With our clean nodelist, here is our plan <span class="No-Break">of attack:</span></p>
			<ol>
				<li value="1">Remove the <span class="No-Break">bad nodes.</span></li>
				<li>Rename the <em class="italic">White </em><span class="No-Break"><em class="italic">Rabbit</em></span><span class="No-Break"> nodes.</span></li>
				<li>Add any missing nodes that I am <span class="No-Break">aware of.</span></li>
				<li>Add any missing edges that I <span class="No-Break">can identify.</span></li>
			</ol>
			<p>Let’s proceed with the f<a id="_idTextAnchor242"/>irst of <span class="No-Break">those steps.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor243"/>Removing nodes</h1>
			<p>The <a id="_idIndexMarker443"/>next thing we will do is remove nodes that have made it into the network by mistake, usually as a result of false positives from <strong class="source-inline">pos_tagging</strong> or <strong class="source-inline">NER</strong>. You may see me refer to these nodes as “bad” nodes. I could as easily refer to them as “unwanted” nodes, but the point is that these are nodes that do not belong and should be removed. For simplicity, I call them <span class="No-Break">bad nodes.</span></p>
			<p>One reason to remove nodes is to clean a network so that it closely matches reality or the reality described in a piece of text. However, removing nodes can also be useful, for simulating an attack. We could, for instance, remove key characters from the <em class="italic">Alice in Wonderland</em> social network, to simulate what the outcome would be if the Queen of Hearts had gotten her wish of executing several characters. We will do that in <span class="No-Break">this chapter.</span></p>
			<p>Simulating an attack is also useful for bolstering defenses. If a node is a single point of failure and if its removal would be catastrophic to a network, you can potentially add nodes in certain positions so that if the critical node were removed, the network would remain intact, and information flow would <span class="No-Break">be undisrupted:</span></p>
			<ul>
				<li>In <strong class="source-inline">networkx</strong>, there are two different ways to remove nodes: one at a time, or several at once. You can remove a single node <span class="No-Break">like this:</span><pre class="source-code">
G.remove_node('â\x80\x98it')</pre></li>
				<li>You can remove several nodes at once <span class="No-Break">like this:</span><pre class="source-code">
drop_nodes = ['Beautiful', 'CHAPTER V.', 'Hm', 'Improve', 'Longitude', 'Ma\'am', 'Mystery', 'Said', 'Seaography', 'Somebody', 'Soup', 'Time', 'garden_.', 'â\x80\x98I\'ll', 'â\x80\x98Keep']</pre><pre class="source-code">
G.remove_nodes_from(drop_nodes)</pre></li>
			</ul>
			<p>I prefer the second approach because it can also be used to remove a single node if the <strong class="source-inline">drop_nodes</strong> variable only contains a single node name. You can simply keep expanding <strong class="source-inline">drop_nodes</strong> until you have all bad entities listed, and then you can keep refreshing the list <a id="_idIndexMarker444"/>of remaining nodes. Now that we’ve removed some nodes, let’s see which <span class="No-Break">entities remain:</span></p>
			<pre class="source-code">
show_nodes(G)
'Ada, Alice, Australia, Bill, Canterbury, Cat, Caterpillar, Cheshire, Cheshire Cat, Crab, Dinah, Dormouse, Duchess, Eaglet, Edgar Atheling, Edwin, Elsie, England, Fender, Fish-Footman, France, Gryphon, Hare, Hatter, Kings, Lacie, Lizard, Lobster Quadrille, London, Lory, Mabel, Mary Ann, Mercia, Morcar, Mouse, New Zealand, Nile, Northumbria, Paris, Pat, Pigeon, 
Queens, Rabbit, Rome, Stigand, The Rabbit Sends, Tillie, Treacle, William, William the Conqueror, William_, the White Rabbit'</pre>
			<p>This is already looking much cleaner. Next, we will further clean the network by renaming and combining certain nodes, especially the nodes relate<a id="_idTextAnchor244"/>d to the <span class="No-Break"><em class="italic">White Rabbit</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor245"/>Quick visual inspection</h1>
			<p>Before <a id="_idIndexMarker445"/>moving on to more cleaning, let’s do a quick visual inspection of the network. We will reuse the <strong class="source-inline">draw_graph</strong> function we have been using throughout <span class="No-Break">this book:</span></p>
			<pre class="source-code">
draw_graph(G, show_names=True, node_size=5, edge_width=1)</pre>
			<p>This outputs the <span class="No-Break">following network:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B17105_06_002.jpg" alt="Figure 6.2 – Quick visual inspection network" width="1545" height="1051"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Quick visual inspection network</p>
			<p>OK, what do we see? I can see that<a id="_idIndexMarker446"/> there is one large cluster of connected entities. This is the primary component of the Alice in <span class="No-Break">Wonderland network.</span></p>
			<p>What else do we see? <strong class="bold">Alice</strong> is the most central node in the primary component. That makes sense, as she is the main character in the story. Thinking about the main characters, I see many names that I know, such as <strong class="bold">Dormouse</strong>, <strong class="bold">Cheshire Cat</strong>, and <strong class="bold">White Rabbit</strong>. What is interesting to me, though, is that not only are they shown but I can also begin to see which characters are most important to the story based on the number of entities connected to them. However, I also see that the Queen and King of Hearts are missing, which is disappointing. NER failed to recognize them as entities. From what I have seen, NER struggles with fantasy and ancient names, due to it being trained on more realistic data. It would struggle less with real names. We will manually add several members of the queen’s court, including the king <span class="No-Break">and queen.</span></p>
			<p>I can also see a few strange nodes that seem to be part of the story but they aren’t connected to the primary component. Why is <strong class="bold">Gryphon</strong> disconnected from everything? Who does <strong class="bold">Gryphon</strong> know? We should look for those relationships in the story text. We will manually add <span class="No-Break">the edges.</span></p>
			<p>Finally, I see nodes that have to do with places on Earth, such as <strong class="bold">Nile</strong>, <strong class="bold">France</strong>, <strong class="bold">England</strong>, <strong class="bold">New Zealand</strong>, and <strong class="bold">Australia</strong>. We could keep these, as they are technically a part of the story, but I’m going to remove them so that we can focus more on the social network of character relationships that exist in Wonderland. We will <span class="No-Break">remove these.</span></p>
			<p>Let’s start<a id="_idIndexMarker447"/> by removing the <span class="No-Break">non-Wonderland nodes:</span></p>
			<pre class="source-code">
drop_nodes = ['New Zealand', 'Australia', 'France', 'England', 'London', 'Paris', 'Rome', 'Nile', 'William_', 'Treacle', 'Fender', 'Canterbury', 'Edwin', 'Mercia', 'Morcar', 'Northumbria', 'Stigand']
G.remove_nodes_from(drop_nodes)</pre>
			<p>Now, let’s visualize the <span class="No-Break">network again:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B17105_06_003.jpg" alt="Figure 6.3 – Quick visual inspection network (cleaned)" width="1508" height="1070"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Quick visual inspection network (cleaned)</p>
			<p>That looks a lot better. We still have <strong class="bold">Gryphon</strong> floating around like an island, but we’ll take<a id="_idIndexMarker448"/> care of that soon. Still, where in the world is the Queen of Hearts? I wrote a helper function to help with <span class="No-Break">that investigation:</span></p>
			<pre class="source-code">
from nltk.tokenize import sent_tokenize
def search_text(text, search_string):
    sentences = sent_tokenize(text)
    for sentence in sentences:
        if search_string in sentence.lower():
            print(sentence)
            print()</pre>
			<p>With this function, we can pass in any text and any search string, and it’ll print out any sentences that contain the search string. This will help us find entities and relationships that NER failed to find. I am using NLTK’s sentence tokenizer rather than spaCy because this is faster and easier to get the results I need right now. Sometimes, NLTK is the faster and simpler approach, but not in <span class="No-Break">this case.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To run the following code, you will need to load the <strong class="source-inline">text</strong> variable using one of the approaches from <a href="B17105_04.xhtml#_idTextAnchor158"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> or <a href="B17105_05.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. We have shown multiple approaches to loading text for Alice <span class="No-Break">in Wonderland.</span></p>
			<p>Let’s look for text related to <span class="No-Break">the queen:</span></p>
			<pre class="source-code">
search_text(text, 'queen')</pre>
			<p>Here are some of <span class="No-Break">the results:</span></p>
			<pre class="source-code">
An invitation from the  Queen to play croquet.""
The Frog-Footman repeated, in the same solemn  tone, only changing the order of the words a little, "From the Queen.
"I must go and get ready to play  croquet with the Queen,"" and she hurried out of the room.
"Do you play croquet with the  Queen to-day?""
"We  quarrelled last March just before _he_ went mad, you know "" (pointing  with his tea spoon at the March Hare,) " it was at the great concert  given by the Queen of Hearts, and I had to sing    âTwinkle, twinkle, little bat!
"Well, I'd hardly finished the first verse,"" said the Hatter, "when the  Queen jumped up and bawled out, âHe's murdering the time!
The Queen's Croquet-Ground      A large rose-tree stood near the entrance of the garden: the roses  growing on it were white, but there were three gardeners at it, busily  painting them red.
"I heard the Queen say only  yesterday you deserved to be beheaded!""</pre>
			<p>Running <a id="_idIndexMarker449"/>this function will give many more results than this – these are just a few. But we can already see that <strong class="source-inline">Queen of Hearts</strong> knows <strong class="source-inline">Frog-Footman</strong>, and that <strong class="source-inline">Frog-Footman</strong> is in our network, so we should add <strong class="source-inline">Queen of Hearts</strong> and other missing characters and place an edge between the characters<a id="_idTextAnchor246"/> that they <span class="No-Break">interact with.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor247"/>Adding nodes</h1>
			<p>We<a id="_idIndexMarker450"/> need to add nodes that are missing. As <em class="italic">Alice in Wonderland</em> is a fantasy story, and NER models tend to be trained with more modern and realistic text, the NER struggled to identify some important entities, including the Queen of Hearts. There are a few <span class="No-Break">lessons here:</span></p>
			<ul>
				<li>First, don’t blindly trust models, ever. The data that they were trained on will have an impact on what they do and don’t do <span class="No-Break">very well.</span></li>
				<li>Second, domain knowledge is very important. If I did not know the story of Alice in Wonderland, I might not even have noticed that the royalty <span class="No-Break">was missing.</span></li>
				<li>Finally, even with flaws, NER and these approaches will do <em class="italic">most</em> of the work in converting text into networks, but your domain knowledge and critical thinking will lead to the <span class="No-Break">best results.</span></li>
			</ul>
			<p>Just as <a id="_idIndexMarker451"/>with removing nodes, <strong class="source-inline">networkx</strong> has two methods for adding nodes: one at a time, or several <span class="No-Break">at once:</span></p>
			<ul>
				<li>We can add just <strong class="source-inline">'Queen </strong><span class="No-Break"><strong class="source-inline">of Hearts'</strong></span><span class="No-Break">:</span><pre class="source-code">
G.add_node('Queen of Hearts')</pre></li>
				<li>Alternatively, we could add the missing nodes all <span class="No-Break">at once:</span><pre class="source-code">
add_nodes = ['Queen of Hearts', 'Frog-Footman', 'March Hare', 'Mad Hatter', 'Card Gardener #1', 'Card Gardener #2', 'Card Gardener #3', 'King of Hearts', 'Knave of Hearts', 'Mock Turtle']</pre><pre class="source-code">
G.add_nodes_from(add_nodes)</pre></li>
			</ul>
			<p>Again, I prefer the bulk approach, as I can just keep extending the <strong class="source-inline">add_nodes</strong> list until I am satisfied with the results. If we visualize the network now, these added nodes will appear as islands, because we have not created edges between them and <span class="No-Break">other nodes:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B17105_06_004.jpg" alt="Figure 6.4 – Network with missing nodes added" width="1588" height="1056"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Network with missing nodes added</p>
			<p>This looks <a id="_idIndexMarker452"/>good. Next, let<a id="_idTextAnchor248"/>’s add those <span class="No-Break">missing edges.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor249"/>Adding edges</h2>
			<p>We <a id="_idIndexMarker453"/>used the <strong class="source-inline">search_text</strong> function to identify not only the missing characters but also the missing relationships between those characters. The approach taken was <span class="No-Break">as follows:</span></p>
			<ol>
				<li value="1">Figure out who the Queen of Hearts knows; take notes as these are <span class="No-Break">missing edges.</span></li>
				<li>Add the Queen of Hearts and any other <span class="No-Break">missing nodes.</span></li>
				<li>Figure out who each missing character knows; take notes as these are <span class="No-Break">missing edges.</span></li>
			</ol>
			<p>This involved doing a bunch of lookups with the <strong class="source-inline">search_text</strong> function and then keeping track of relationships as comments in my Jupyter notebook. In the end, it looked <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B17105_06_005.jpg" alt="Figure 6.5 – Identified missing edges" width="612" height="1030"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Identified missing edges</p>
			<p>These are<a id="_idIndexMarker454"/> identified edges that we need to add. We are likely missing some, but this is enough for <span class="No-Break">our purposes:</span></p>
			<ul>
				<li>We can add an edge, one at <span class="No-Break">a time:</span><pre class="source-code">
G.add_edge('Frog-Footman', 'Queen of Hearts')</pre></li>
				<li>Alternatively, we can add several at once. I prefer the bulk approach, again. To do the bulk approach, we will use a list of tuples to describe <span class="No-Break">the edges:</span><pre class="source-code">
add_edges = [('Alice', 'Mock Turtle'), ('King of Hearts', 'Alice'), ('King of Hearts', 'Card Gardener #1'),</pre><pre class="source-code">
             ('King of Hearts', 'Card Gardener #2'), ('King of Hearts', 'Card Gardener #3'),</pre><pre class="source-code">
             ('King of Hearts', 'Dormouse'), ('King of Hearts', 'Frog-Footman'), ('King of Hearts', 'Kings'),</pre><pre class="source-code">
             ('King of Hearts', 'Lizard'), ('King of Hearts', 'Mad Hatter'), ('King of Hearts', 'March Hare'),</pre><pre class="source-code">
             ('King of Hearts', 'Mock Turtle'), ('King of Hearts', 'Queen of Hearts'), ('King of Hearts', 'Queens'),</pre><pre class="source-code">
             ('King of Hearts', 'White Rabbit'), ('Knave of Hearts', 'King of Hearts'),</pre><pre class="source-code">
             ('Knave of Hearts', 'Queen of Hearts'),</pre><pre class="source-code">
             ('Queen of Hearts', 'Alice'), ('Queen of Hearts', 'Card Gardener #1'),</pre><pre class="source-code">
             ('Queen of Hearts', 'Card Gardener #2'), ('Queen of Hearts', 'Card Gardener #3'),</pre><pre class="source-code">
             ('Queen of Hearts', 'Dormouse'), ('Queen of Hearts', 'Frog-Footman'), ('Queen of Hearts', 'Kings'),</pre><pre class="source-code">
             ('Queen of Hearts', 'Lizard'), ('Queen of Hearts', 'Mad Hatter'), ('Queen of Hearts', 'March Hare'),</pre><pre class="source-code">
             ('Queen of Hearts', 'Mock Turtle'), ('Queen of Hearts', 'Queens'), ('Queen of Hearts', 'White Rabbit')]</pre><pre class="source-code">
G.add_edges_from(add_edges)</pre></li>
			</ul>
			<p>How does<a id="_idIndexMarker455"/> our network <span class="No-Break">look now?</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B17105_06_006.jpg" alt="Figure 6.6 – Network with missing edges added" width="1620" height="1056"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Network with missing edges added</p>
			<p>This is looking a lot better, and we now have the queen’s court in place. However, Gryphon is still an island, so let’s do a lookup to see what relationship or relationships <span class="No-Break">are missing:</span></p>
			<pre class="source-code">
search_text(text, 'gryphon')</pre>
			<p>This gives us some text to look at, and I used that to identify missing edges. Let’s <span class="No-Break">add them:</span></p>
			<pre class="source-code">
add_edges = [('Gryphon', 'Alice'), ('Gryphon', 'Queen of Hearts'), ('Gryphon', 'Mock Turtle')]
G.add_edges_from(add_edges)</pre>
			<p>Now, let’s visualize the network one <span class="No-Break">more time:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B17105_06_007.jpg" alt="Figure 6.7 – Network with missing edges added (final)" width="1526" height="1065"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Network with missing edges added (final)</p>
			<p>Ah! It’s<a id="_idIndexMarker456"/> such a wonderful feeling when a disconnected network is finally connected and all islands/isolates are taken care of. This is clean and readable. We have successfully removed junk nodes, added missing nodes, and connected the missing nodes to nodes that they should share a<a id="_idTextAnchor250"/>n edge with! We can <span class="No-Break">move on!</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor251"/>Renaming nodes</h1>
			<p>This <a id="_idIndexMarker457"/>network looks good enough that we might be tempted to just call it a day on our cleaning efforts. However, there is a bit more that we need to do, especially for the White Rabbit, but also for a few other characters. I can see three nodes having to do with the <span class="No-Break">White Rabbit:</span></p>
			<ul>
				<li><strong class="source-inline">the </strong><span class="No-Break"><strong class="source-inline">White Rabbit</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Rabbit</strong></span></li>
				<li><strong class="source-inline">The </strong><span class="No-Break"><strong class="source-inline">Rabbit Sends</strong></span></li>
			</ul>
			<p>If we rename all three of these nodes <strong class="source-inline">White Rabbit</strong>, then they will be combined into a single node, and their edges will also be correctly connected. There are a few other nodes that should be renamed as well. Here is how to <span class="No-Break">rename nodes:</span></p>
			<pre class="source-code">
relabel_mapping = {'Cheshire':'Cheshire Cat', 'Hatter':'Mad Hatter', 'Rabbit':'White Rabbit','William':'Father William', 'the White Rabbit':'White Rabbit', 'The Rabbit Sends':'White Rabbit', 'Bill':'Lizard Bill', 'Lizard':'Lizard Bill', 'Cat':'Cheshire Cat', 'Hare':'March Hare'}
G = nx.relabel_nodes(G, relabel_mapping)</pre>
			<p>We<a id="_idIndexMarker458"/> pass in a Python dictionary containing nodes and what we want them relabeled as. For instance, we are changing <strong class="source-inline">Cheshire</strong> to <strong class="source-inline">Cheshire Cat</strong>, and <strong class="source-inline">Hatter</strong> to <span class="No-Break"><strong class="source-inline">Mad Hatter</strong></span><span class="No-Break">.</span></p>
			<p>How do our nodes <span class="No-Break">look now?</span></p>
			<pre class="source-code">
show_nodes(G)
'Ada, Alice, Card Gardener #1, Card Gardener #2, Card Gardener #3, Caterpillar, Cheshire Cat, Crab, Dinah, Dormouse, Duchess, Eaglet, Edgar Atheling, Elsie, Father William, Fish-Footman, Frog-Footman, Gryphon, King of Hearts, Kings, Knave of Hearts, Lacie, Lizard Bill, Lobster Quadrille, Lory, Mabel, Mad Hatter, March Hare, Mary Ann, Mock Turtle, Mouse, Pat, Pigeon, Queen of Hearts, Queens, Tillie, White Rabbit, William the Conqueror'</pre>
			<p>Nice. That looks perfect. How does our network <span class="No-Break">look, visually?</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B17105_06_008.jpg" alt="Figure 6.8 – Network with renamed nodes" width="1526" height="1064"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Network with renamed nodes</p>
			<p>Perfect. <strong class="bold">White Rabbit</strong> has been<a id="_idIndexMarker459"/> placed correctly, and the node color and placement show it as a central character, right next to <strong class="bold">Alice</strong>, and not far from <strong class="bold">Queen<a id="_idTextAnchor252"/> of Hearts</strong> and <strong class="bold">King </strong><span class="No-Break"><strong class="bold">of Hearts</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor253"/>Removing edges</h1>
			<p>There will likely<a id="_idIndexMarker460"/> be times when you will need to remove edges. This can be useful, not just for cleaning networks but also for simulating attacks, or <a id="_idIndexMarker461"/>for identifying cliques and communities. For instance, I often use what is called <strong class="bold">minimum cuts</strong> or <strong class="bold">minimum edge cuts</strong> to find the fewest number of edges that will split a network into two pieces. I use this for community detection, and also to spot emerging trends on <span class="No-Break">social media.</span></p>
			<p>With the <em class="italic">Alice in Wonderland</em> network, there are no edges that we need to remove, so I will first show you how to remove some edges, and then I’ll show you how to put <span class="No-Break">them back:</span></p>
			<ul>
				<li>You can remove edges one at <span class="No-Break">a time:</span><pre class="source-code">
G.remove_edge(<strong class="source-inline">'Dormouse'</strong>, 'Tillie')</pre></li>
				<li>Alternatively, you can remove several at <span class="No-Break">a time:</span><pre class="source-code">
drop_edges = [('Dormouse', 'Tillie'), ('Dormouse', 'Elsie'), ('Dormouse', 'Lacie')]</pre><pre class="source-code">
G.remove_edges_from(drop_edges)</pre></li>
			</ul>
			<p>How <a id="_idIndexMarker462"/>does this look <span class="No-Break">when visualized?</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B17105_06_009.jpg" alt="Figure 6.9 – Network with edges removed" width="1524" height="1086"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Network with edges removed</p>
			<p>This looks exactly as it should. If we had removed the nodes for <strong class="bold">Elsie</strong>, <strong class="bold">Tillie</strong>, and <strong class="bold">Lacie</strong> instead of their edges, then the nodes as well as the edges would have been removed. Instead, we have removed the edges, which is a bit like cutting a piece of string. The three nodes are now islands, isolates, connected <span class="No-Break">to nothing.</span></p>
			<p>Let’s put <span class="No-Break">them back:</span></p>
			<pre class="source-code">
add_edges = [('Dormouse', 'Elsie'), ('Dormouse', 'Lacie'), ('Dormouse', 'Tillie')]
G.add_edges_from(add_edges)</pre>
			<p>How does<a id="_idIndexMarker463"/> the network <span class="No-Break">look now?</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17105_06_010.jpg" alt="Figure 6.10 – Network with edges added" width="1596" height="1074"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Network with edges added</p>
			<p>Perfect. <strong class="bold">Elsie</strong>, <strong class="bold">Tillie</strong>, and <strong class="bold">Lacie</strong> are right back where they should be, connected to <strong class="bold">Dormouse</strong>. With that, I think this n<a id="_idTextAnchor254"/>etwork is perfect for <span class="No-Break">our uses.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor255"/>Persisting the network</h1>
			<p>I want to <a id="_idIndexMarker464"/>persist this network so that we can use it in later chapters without having to go through all of this work again. We will use this network quite a lot in <span class="No-Break">this book:</span></p>
			<pre class="source-code">
outfile = r'C:\blah\blah\blah\networks\alice\edgelist_alice_cleaned.csv'
final_network_df = nx.to_pandas_edgelist(G)
final_network_df.to_csv(outfile, header=True, index=False)</pre>
			<p>I’m using Microsoft Windows. Your<a id="_idTextAnchor256"/> outfile path may <span class="No-Break">look different.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor257"/>Simulating an attack</h1>
			<p>We <a id="_idIndexMarker465"/>already did an end-to-end workflow of converting a rough network edge list into a network, cleaning the network, and then persisting the cleaned network’s edge list, so for the remainder of this chapter, let’s do <span class="No-Break">a simulation.</span></p>
			<p>In most networks, some nodes serve as key hubs. These nodes reveal themselves if you look for the number of degrees (edges) that a node has, or by checking PageRank or various centrality metrics for nodes. We will use these approaches in a later chapter to identify important notes. For now, we have domain knowledge that we can use. Those of us who know this story can likely name by heart several of the important protagonists of the story: Alice, Mad Hatter, Cheshire Cat, and so on. And those of us who are familiar with the story are also likely very aware of the Queen of Hearts repeatedly shouting “OFF WITH <span class="No-Break">THEIR HEADS!”</span></p>
			<p>In a network, if you remove the most connected and important nodes, what often happens looks a lot like the scene in <em class="italic">Star Wars</em>, where the Death Star explodes. All at once, many nodes are transformed into isolates, their edges destroyed along with the central node that was removed. This is catastrophic to a network, and the information flow is disrupted. Can you imagine the real-world impact of what happens when key nodes are removed from a network? Your internet goes down. Your power goes out. Supply chains are disrupted. Grocery stores are not stocked, and on and on and on. Understanding networks and simulating disruption can give ideas on how to bolster the supply chain and information flow. That is the point of <span class="No-Break">this exercise.</span></p>
			<p>But we are going to have fun. We are just going to give the Queen of Hearts one huge win. We are going to let her execute four of the main characters in the story and see <span class="No-Break">what happens:</span></p>
			<ol>
				<li value="1">First, let’s <span class="No-Break">execute them:</span><pre class="source-code">
drop_nodes = ['Alice', 'Dormouse', 'White Rabbit', 'Mad Hatter']</pre><pre class="source-code">
G.remove_nodes_from(drop_nodes)</pre></li>
			</ol>
			<p>We decided that the Queen of Hearts has successfully executed <strong class="source-inline">Alice</strong>, <strong class="source-inline">Dormouse</strong>, <strong class="source-inline">White Rabbit</strong>, and <strong class="source-inline">Mad Hatter</strong>. It would have been a terrible story if this had happened, but we’re going to play it out. I am choosing these four because I know that they are key characters in the story. Their removal from the network should shatter it, which is what I want <span class="No-Break">to demonstrate.</span></p>
			<ol>
				<li value="2">After<a id="_idIndexMarker466"/> removing just four of the key nodes in this network, what does the rest of the network look like? What are <span class="No-Break">the consequences?</span></li>
			</ol>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B17105_06_011.jpg" alt="Figure 6.11 – Shattered Alice network" width="1544" height="1060"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Shattered Alice network</p>
			<p>Disaster. We can see several nodes that were made into isolates. We still have one primary component in the center, and we have two other smaller components with two to four nodes. But in general, the network has been shattered, and the information flow has been disrupted. New relationships will need to be built. New hierarchies will need to be established. The queen’s court has become dominant, just by removing <span class="No-Break">four nodes.</span></p>
			<ol>
				<li value="3">Let’s look<a id="_idIndexMarker467"/> closer at the <span class="No-Break">primary component:</span><pre class="source-code">
components = list(nx.connected_components(G))</pre><pre class="source-code">
main_component = components[4]</pre><pre class="source-code">
G_sub = G.subgraph(main_component)</pre><pre class="source-code">
draw_graph(G_sub, show_names=True, node_size=4, edge_width = 0.5)</pre></li>
			</ol>
			<p>There are a few things to understand in this code. First, <strong class="source-inline">nx.connected_components(G)</strong> has converted the graph into a list of connected components. One of the components will be the primary component, but it is not necessarily the first one on the list. After some investigation, we will find that the fourth component was the primary component, so let’s set that as <strong class="source-inline">main_component</strong> and then visualize the subgraph of that component. This is what <span class="No-Break">we see:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B17105_06_012.jpg" alt="Figure 6.12 – Queen’s court subgraph" width="1600" height="1068"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Queen’s court subgraph</p>
			<p>The queen’s court is intact and contains characters who were unfortunate enough to be trapped in<a id="_idIndexMarker468"/> the network before the <span class="No-Break">executions happen<a id="_idTextAnchor258"/>ed.</span></p>
			<p>And that’s it for <span class="No-Break">this chapter!</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor259"/>Summary</h1>
			<p>In this chapter, we took raw data, performed a series of steps to clean the network, and even carried out a very simple <span class="No-Break">attack simulation.</span></p>
			<p>I hope that at this point, looking at and working with networks is starting to feel more natural. The more that I work with networks, the more that I see them in everything, and they affect my understanding of the world. We are using a fantasy story for this chapter because it is of a manageable size to explain the construction, cleaning, and some simple analysis. As you learn more about networks, you will likely find that real-world networks are usually much messier, more complicated, and larger. I hope that this simple network will give you the tools and practice you need to eventually chase much more <span class="No-Break">ambitious problems.</span></p>
			<p>In the next chapter, we’re going to have a lot of fun. Our next chapter is about analyzing whole networks. You will learn all kinds of useful things, such as how to identify the most influential nodes in a network. From here on out, we will do a lot of network analysis <span class="No-Break">and visualization.</span></p>
		</div>
	</div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer093" class="Content">
			<h1 id="_idParaDest-170"><a id="_idTextAnchor260"/>Part 3: Network Science and Social Network Analysis</h1>
			<p>In these chapters, we learn how to analyze networks and hunt for insights. We begin with a discussion on whole network analysis and gradually zoom in to the node level, to investigate egocentric networks. We then look for communities and subgroups that exist in networks. Finally, we conclude the book by showing how graph data can be useful for supervised and unsupervised <span class="No-Break">machine learning.</span></p>
			<p>This section includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B17105_07.xhtml#_idTextAnchor261"><em class="italic">Chapter 7</em></a><em class="italic">, Whole Network Analysis </em></li>
				<li><a href="B17105_08.xhtml#_idTextAnchor313"><em class="italic">Chapter 8</em></a><em class="italic">, Egocentric Network Analysis </em></li>
				<li><a href="B17105_09.xhtml#_idTextAnchor364"><em class="italic">Chapter 9</em></a><em class="italic">, Community Detection</em></li>
				<li><a href="B17105_10.xhtml#_idTextAnchor394"><em class="italic">Chapter 10</em></a><em class="italic">, Supervised Machine Learning on Network Data</em></li>
				<li><a href="B17105_11.xhtml#_idTextAnchor432"><em class="italic">Chapter 11</em></a><em class="italic">, Unsupervised Machine Learning on Network Data</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer094">
			</div>
		</div>
		<div>
			<div id="_idContainer095">
			</div>
		</div>
	</div>
</div>
</body></html>