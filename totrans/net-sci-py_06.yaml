- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph Construction and Cleaning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered quite a lot of ground up to this point. In the previous chapters,
    we introduced NLP, network science, and social network analysis, and we learned
    how to convert raw text into network data. We even visualized a few of these networks.
    I hope that seeing text converted into a visualized network had the same impact
    on you as it did on me. The first time I attempted this, I used the book of Genesis,
    from the Bible, and being able to convert text from thousands of years ago into
    an actual interactive network took my breath away.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two chapters, we learned a few different ways to collect text
    data from websites and social networks on the internet and to use that text data
    to create networks. The good news is that I don’t need to show you more ways to
    scrape text. You have enough options, and you should be able to use this knowledge
    as a foundation for other kinds of scraping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bad news is that it is time to get to everybody’s “favorite” topic: cleaning
    data! In all honesty, this is my favorite part of working with network data. Cleaning
    takes work, but it’s pretty simple. This is a good time to throw on some music,
    make a hot beverage, relax, and hunt for little problems to fix.'
  prefs: []
  type: TYPE_NORMAL
- en: To make this chapter especially fun, we will be using the social network from
    *Alice’s Adventures in Wonderland*. I have created this network using the process
    described in previous chapters. As we have gone over the steps a few times now,
    I’m going to skip explaining how to convert text into entities, entities into
    network data, and network data into graphs. The raw network data has been pushed
    to my GitHub, and we’ll use that for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graph from an edge list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick visual inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating an attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using the NetworkX and pandas Python libraries.
    We will also import an NLTK tokenizer. By now, all of these libraries should be
    installed, so they should be ready for your use.
  prefs: []
  type: TYPE_NORMAL
- en: All the code for this chapter is available in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Science-with-Python](https://github.com/PacktPublishing/Network-Science-with-Python).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graph from an edge list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to be using this file as our original edge list: [https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv](https://raw.githubusercontent.com/itsgorain/datasets/main/networks/alice/edgelist_alice_original.csv).
    Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can create our graph, we must import the two libraries we will be
    working with: `pandas` and `networkx`. We use `pandas` to read the edge list into
    a DataFrame, and we pass that DataFrame to `networkx` to create a graph. You can
    import both like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the libraries imported, let’s use pandas to read the CSV file into a DataFrame
    and then display it, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run this in a Jupyter notebook, you should see the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – pandas DataFrame of the Alice in Wonderland edgelist](img/B17105_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – pandas DataFrame of the Alice in Wonderland edge list
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, I want to say that if you can represent any two things as
    having a relationship, you can use that as network data. In our DataFrame, the
    source and target entities are people, places, and organizations, as we configured
    in our **Named-Entity Recognition** (**NER**) work, but you could also make networks
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ingredients and dishes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Students and teachers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planets and star systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I could go on and on forever. Realizing just how prevalent networks are around
    us and then seeing them in everything: that’s the precursor to unlocking the power
    of network analysis. This is about understanding the relationships between things.
    I am interested in literature and security, and most of my network analysis has
    to do with the overlap between human language and security. You may have other
    interests, so you will find more use in other types of networks. Try to take from
    this book and use it to inspire you toward new ways of researching topics of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that that’s out of the way, we have our edge list DataFrame, so let’s convert
    this into a graph. In its simplest form, this is as easy as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Really? That’s it? Yes, that’s it. When I first learned that it was this easy
    to go from a `pandas` DataFrame to a usable graph, I was instantly hooked. It’s
    this easy. But it is this easy for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First, this `networkx` function expects `.csv` file came with those columns,
    we didn’t need to rename any columns or specify to the function which columns
    were our sources and targets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we aren’t specifying what kind of graph to use, so `networkx` defaults
    to `nx.Graph()`. This is the simplest form of graph, allowing only a single edge
    between nodes, and not including directionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a notebook, if we were to inspect `G`, we would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This verifies that we are working with the default graph type of `Graph`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to load network data into `networkx`, but I prefer to
    use edge list. At their simplest, edge lists are tabular data with two fields:
    *source* and *target*. Because of this simplicity, they can easily be stored as
    raw text or in databases. You don’t need a fancy graph database to store an edge
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: Others prefer to use an adjacency matrix when working with network data. Adjacency
    matrices cannot be stored easily in a database, nor do they scale out well. Use
    whatever you prefer, but edge lists are very easy to work with, so I recommend
    learning to use, create, and store them.
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NetworkX offers four different types of graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DiGraph**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MultiGraph**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MultiDiGraph**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about them here: [https://networkx.org/documentation/stable/reference/classes/](https://networkx.org/documentation/stable/reference/classes/).
    I will give a short overview and my thoughts on each type of graph as to when
    it is useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Graph** is the default and simplest form of a graph that NetworkX provides.
    In a simple graph, nodes can have only a single edge between them and another
    node. If your edge list contains multiple edges between a source and a target,
    it’ll be reduced to a single edge. This isn’t always a bad thing. There are approaches
    to reduce the complexity of networks, and one approach is to aggregate the data
    – for instance, counting the number of edges that exist between two nodes and
    keeping that value as a weighted count, rather than the edge list being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*source, target*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it would be like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '*source,* *target, edge_count*'
  prefs: []
  type: TYPE_NORMAL
- en: In that form, a graph still works well, because multiple edges have been reduced
    to a single edge, and the number of edges that existed has been reduced to a count.
    This is a very good way of simplifying network data while keeping all of the information.
  prefs: []
  type: TYPE_NORMAL
- en: For most of my work, a graph works fine. If I’ve decided against a default graph,
    it’s because I needed directionality, so I chose a `DiGraph` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a default graph network can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: DiGraph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `DiGraph` is similar to a graph, with the main difference being that it is
    directed. DiGraph stands for **directed graph**. Just as with a graph, each node
    can only have one edge between itself and another node. Most of what I said about
    aggregation still applies, but you may need to handle self-loops if you run into
    them.
  prefs: []
  type: TYPE_NORMAL
- en: These are very useful when you need to understand the directionality and flow
    of information. It isn’t always enough to know that a relationship exists between
    two things. It is often most important to understand the directionality of the
    influence, and how information spreads.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s say we have four people named Sarah, Chris, Mark, and John.
    Sarah writes a lot and shares her ideas with her friend Chris. Chris is a bit
    of an influencer and shares information that he receives from Sarah (and others)
    with his following, which includes Mark and John. In this situation, the data
    flows like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sarah -> Chris -> (Mark* *and John)*'
  prefs: []
  type: TYPE_NORMAL
- en: In this data flow, Sarah is an important person, because she is the originator
    of a brand-new piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: Chris is also an important person because information flows through him to many
    other people. We will learn about how to capture this kind of importance in a
    later chapter, when we discuss betweenness centrality.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Mark and John are the receivers of this information.
  prefs: []
  type: TYPE_NORMAL
- en: If this were not a directed graph, we could not visibly tell who created the
    information or who was the final receiver of the information. This directionality
    allows us to go to the origins and also follow the information flow.
  prefs: []
  type: TYPE_NORMAL
- en: Directed graphs are also useful in mapping out production data flows that take
    place on servers and databases in production. When processes are mapped out this
    way, if something stops working, you can step backward until you discover what
    is broken. Using this approach, I have been able to troubleshoot problems in minutes
    that previously took days.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a directed graph is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect `G`, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: MultiGraph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `MultiGraph` can have multiple edges between any two nodes. A MultiGraph
    does not retain any context of directionality. To be truthful, I don’t use `MultiGraphs`.
    I prefer to aggregate the multiple edges down to a count and use either Graph
    or `DiGraph.` However, if you want to create a MultiGraph, you can do so with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect `G`, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: MultiDiGraph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `MultiDiGraph` can have multiple edges between any two nodes, and these graphs
    also convey the directionality of each edge. I do not use `MultiDiGraphs` as I
    prefer to aggregate multiple edges down to a count and then use either Graph or
    `DiGraph.` If you want to create a `MultiDiGraph,` you can do so with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect `G`, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summarizing graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure we’ve got everything down, let’s go back over these graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s recreate our graph using a default graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great. We’ve loaded all of that data into `G`. This is a tiny network, so it
    loads instantly in a Jupyter notebook, and I imagine it will load quickly for
    you as well. With how fast of an operation that is, I’m often left wanting more,
    like, “That’s it? I did all that work to create all of that data, and that’s it?”
    Well, yes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one function that is useful for getting a quick overview
    of a graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run that, we’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Neat. This is a tiny, simple network. With so few nodes and edges, this should
    visualize nicely enough to assist with cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to quickly inspect a graph, but this is the simplest way.
    Now, let’s look at the cleanup; we’ll learn more about analyzing networks in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Listing nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing I tend to do after constructing a network from text is to list
    the nodes that have been added to the network. This allows me to take a quick
    peek at the node names so that I can gauge the amount of cleanup I will need to
    do to remove and rename nodes. During our entity extraction, we had the opportunity
    to clean the entity output. The entity data is used to create the network data
    that is used to create the graph itself, so there are multiple steps during which
    cleanup and optimization are possible, and the more that you do upstream, the
    less that you have to do later.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is still important to take a look at the node names, to identify
    any strangeness that still managed to find a way into the network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to get a node list is to run the following `networkx` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give you a `NodeView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s readable, but it could be a little easier on the eyes. This function
    will clean it up a bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can be run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs a cleaner node list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We now have a clean list of nodes that exist in the *Alice’s Adventures in Wonderland*
    social network. Immediately, my eyes are drawn to the last three nodes. These
    don’t even look like names. We’re going to remove them. I can also see that `CHAPTER
    V.`, `Soup`, and a few other non-entity nodes were added. This is a common problem
    when using NLP for Part-of-Speech Tagging (`pos_tagging`) or **NER**. Both of
    these approaches frequently make mistakes on words where the first letter of a
    word is capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: We have some work to do. We will remove the nodes that were added by mistake,
    and we will rename a few of the nodes so that they reference the *White Rabbit*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When inspecting graphs, I list nodes, not edges. You can list edges with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you an `EdgeView`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I don’t typically list edges, because when I remove or rename nodes, the edges
    will be corrected. Edges to nodes that have been removed will be removed as well.
    Edges to nodes that have been renamed will be connected to the renamed node. `EdgeView`
    is also more confusing to look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our clean nodelist, here is our plan of attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the bad nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the *White* *Rabbit* nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add any missing nodes that I am aware of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add any missing edges that I can identify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s proceed with the first of those steps.
  prefs: []
  type: TYPE_NORMAL
- en: Removing nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing we will do is remove nodes that have made it into the network
    by mistake, usually as a result of false positives from `pos_tagging` or `NER`.
    You may see me refer to these nodes as “bad” nodes. I could as easily refer to
    them as “unwanted” nodes, but the point is that these are nodes that do not belong
    and should be removed. For simplicity, I call them bad nodes.
  prefs: []
  type: TYPE_NORMAL
- en: One reason to remove nodes is to clean a network so that it closely matches
    reality or the reality described in a piece of text. However, removing nodes can
    also be useful, for simulating an attack. We could, for instance, remove key characters
    from the *Alice in Wonderland* social network, to simulate what the outcome would
    be if the Queen of Hearts had gotten her wish of executing several characters.
    We will do that in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simulating an attack is also useful for bolstering defenses. If a node is a
    single point of failure and if its removal would be catastrophic to a network,
    you can potentially add nodes in certain positions so that if the critical node
    were removed, the network would remain intact, and information flow would be undisrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `networkx`, there are two different ways to remove nodes: one at a time,
    or several at once. You can remove a single node like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can remove several nodes at once like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I prefer the second approach because it can also be used to remove a single
    node if the `drop_nodes` variable only contains a single node name. You can simply
    keep expanding `drop_nodes` until you have all bad entities listed, and then you
    can keep refreshing the list of remaining nodes. Now that we’ve removed some nodes,
    let’s see which entities remain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is already looking much cleaner. Next, we will further clean the network
    by renaming and combining certain nodes, especially the nodes related to the *White
    Rabbit*.
  prefs: []
  type: TYPE_NORMAL
- en: Quick visual inspection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on to more cleaning, let’s do a quick visual inspection of the
    network. We will reuse the `draw_graph` function we have been using throughout
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Quick visual inspection network](img/B17105_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Quick visual inspection network
  prefs: []
  type: TYPE_NORMAL
- en: OK, what do we see? I can see that there is one large cluster of connected entities.
    This is the primary component of the Alice in Wonderland network.
  prefs: []
  type: TYPE_NORMAL
- en: What else do we see? **Alice** is the most central node in the primary component.
    That makes sense, as she is the main character in the story. Thinking about the
    main characters, I see many names that I know, such as **Dormouse**, **Cheshire
    Cat**, and **White Rabbit**. What is interesting to me, though, is that not only
    are they shown but I can also begin to see which characters are most important
    to the story based on the number of entities connected to them. However, I also
    see that the Queen and King of Hearts are missing, which is disappointing. NER
    failed to recognize them as entities. From what I have seen, NER struggles with
    fantasy and ancient names, due to it being trained on more realistic data. It
    would struggle less with real names. We will manually add several members of the
    queen’s court, including the king and queen.
  prefs: []
  type: TYPE_NORMAL
- en: I can also see a few strange nodes that seem to be part of the story but they
    aren’t connected to the primary component. Why is **Gryphon** disconnected from
    everything? Who does **Gryphon** know? We should look for those relationships
    in the story text. We will manually add the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I see nodes that have to do with places on Earth, such as **Nile**,
    **France**, **England**, **New Zealand**, and **Australia**. We could keep these,
    as they are technically a part of the story, but I’m going to remove them so that
    we can focus more on the social network of character relationships that exist
    in Wonderland. We will remove these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by removing the non-Wonderland nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s visualize the network again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Quick visual inspection network (cleaned)](img/B17105_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Quick visual inspection network (cleaned)
  prefs: []
  type: TYPE_NORMAL
- en: 'That looks a lot better. We still have **Gryphon** floating around like an
    island, but we’ll take care of that soon. Still, where in the world is the Queen
    of Hearts? I wrote a helper function to help with that investigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this function, we can pass in any text and any search string, and it’ll
    print out any sentences that contain the search string. This will help us find
    entities and relationships that NER failed to find. I am using NLTK’s sentence
    tokenizer rather than spaCy because this is faster and easier to get the results
    I need right now. Sometimes, NLTK is the faster and simpler approach, but not
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To run the following code, you will need to load the `text` variable using one
    of the approaches from [*Chapter 4*](B17105_04.xhtml#_idTextAnchor158) or [*Chapter
    5*](B17105_05.xhtml#_idTextAnchor179). We have shown multiple approaches to loading
    text for Alice in Wonderland.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look for text related to the queen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Running this function will give many more results than this – these are just
    a few. But we can already see that `Queen of Hearts` knows `Frog-Footman`, and
    that `Frog-Footman` is in our network, so we should add `Queen of Hearts` and
    other missing characters and place an edge between the characters that they interact
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Adding nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add nodes that are missing. As *Alice in Wonderland* is a fantasy
    story, and NER models tend to be trained with more modern and realistic text,
    the NER struggled to identify some important entities, including the Queen of
    Hearts. There are a few lessons here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, don’t blindly trust models, ever. The data that they were trained on
    will have an impact on what they do and don’t do very well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, domain knowledge is very important. If I did not know the story of Alice
    in Wonderland, I might not even have noticed that the royalty was missing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, even with flaws, NER and these approaches will do *most* of the work
    in converting text into networks, but your domain knowledge and critical thinking
    will lead to the best results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just as with removing nodes, `networkx` has two methods for adding nodes: one
    at a time, or several at once:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add just `''Queen` `of Hearts''`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we could add the missing nodes all at once:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, I prefer the bulk approach, as I can just keep extending the `add_nodes`
    list until I am satisfied with the results. If we visualize the network now, these
    added nodes will appear as islands, because we have not created edges between
    them and other nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Network with missing nodes added](img/B17105_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Network with missing nodes added
  prefs: []
  type: TYPE_NORMAL
- en: This looks good. Next, let’s add those missing edges.
  prefs: []
  type: TYPE_NORMAL
- en: Adding edges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used the `search_text` function to identify not only the missing characters
    but also the missing relationships between those characters. The approach taken
    was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure out who the Queen of Hearts knows; take notes as these are missing edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Queen of Hearts and any other missing nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure out who each missing character knows; take notes as these are missing
    edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This involved doing a bunch of lookups with the `search_text` function and
    then keeping track of relationships as comments in my Jupyter notebook. In the
    end, it looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Identified missing edges](img/B17105_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Identified missing edges
  prefs: []
  type: TYPE_NORMAL
- en: 'These are identified edges that we need to add. We are likely missing some,
    but this is enough for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add an edge, one at a time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can add several at once. I prefer the bulk approach, again.
    To do the bulk approach, we will use a list of tuples to describe the edges:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How does our network look now?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Network with missing edges added](img/B17105_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Network with missing edges added
  prefs: []
  type: TYPE_NORMAL
- en: 'This is looking a lot better, and we now have the queen’s court in place. However,
    Gryphon is still an island, so let’s do a lookup to see what relationship or relationships
    are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us some text to look at, and I used that to identify missing edges.
    Let’s add them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s visualize the network one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Network with missing edges added (final)](img/B17105_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Network with missing edges added (final)
  prefs: []
  type: TYPE_NORMAL
- en: Ah! It’s such a wonderful feeling when a disconnected network is finally connected
    and all islands/isolates are taken care of. This is clean and readable. We have
    successfully removed junk nodes, added missing nodes, and connected the missing
    nodes to nodes that they should share an edge with! We can move on!
  prefs: []
  type: TYPE_NORMAL
- en: Renaming nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This network looks good enough that we might be tempted to just call it a day
    on our cleaning efforts. However, there is a bit more that we need to do, especially
    for the White Rabbit, but also for a few other characters. I can see three nodes
    having to do with the White Rabbit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`the` `White Rabbit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rabbit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`The` `Rabbit Sends`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we rename all three of these nodes `White Rabbit`, then they will be combined
    into a single node, and their edges will also be correctly connected. There are
    a few other nodes that should be renamed as well. Here is how to rename nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We pass in a Python dictionary containing nodes and what we want them relabeled
    as. For instance, we are changing `Cheshire` to `Cheshire Cat`, and `Hatter` to
    `Mad Hatter`.
  prefs: []
  type: TYPE_NORMAL
- en: How do our nodes look now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Nice. That looks perfect. How does our network look, visually?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Network with renamed nodes](img/B17105_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Network with renamed nodes
  prefs: []
  type: TYPE_NORMAL
- en: Perfect. **White Rabbit** has been placed correctly, and the node color and
    placement show it as a central character, right next to **Alice**, and not far
    from **Queen of Hearts** and **King** **of Hearts**.
  prefs: []
  type: TYPE_NORMAL
- en: Removing edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will likely be times when you will need to remove edges. This can be useful,
    not just for cleaning networks but also for simulating attacks, or for identifying
    cliques and communities. For instance, I often use what is called **minimum cuts**
    or **minimum edge cuts** to find the fewest number of edges that will split a
    network into two pieces. I use this for community detection, and also to spot
    emerging trends on social media.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the *Alice in Wonderland* network, there are no edges that we need to
    remove, so I will first show you how to remove some edges, and then I’ll show
    you how to put them back:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove edges one at a time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can remove several at a time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How does this look when visualized?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Network with edges removed](img/B17105_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Network with edges removed
  prefs: []
  type: TYPE_NORMAL
- en: This looks exactly as it should. If we had removed the nodes for **Elsie**,
    **Tillie**, and **Lacie** instead of their edges, then the nodes as well as the
    edges would have been removed. Instead, we have removed the edges, which is a
    bit like cutting a piece of string. The three nodes are now islands, isolates,
    connected to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put them back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How does the network look now?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Network with edges added](img/B17105_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Network with edges added
  prefs: []
  type: TYPE_NORMAL
- en: Perfect. **Elsie**, **Tillie**, and **Lacie** are right back where they should
    be, connected to **Dormouse**. With that, I think this network is perfect for
    our uses.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I want to persist this network so that we can use it in later chapters without
    having to go through all of this work again. We will use this network quite a
    lot in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: I’m using Microsoft Windows. Your outfile path may look different.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating an attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already did an end-to-end workflow of converting a rough network edge list
    into a network, cleaning the network, and then persisting the cleaned network’s
    edge list, so for the remainder of this chapter, let’s do a simulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most networks, some nodes serve as key hubs. These nodes reveal themselves
    if you look for the number of degrees (edges) that a node has, or by checking
    PageRank or various centrality metrics for nodes. We will use these approaches
    in a later chapter to identify important notes. For now, we have domain knowledge
    that we can use. Those of us who know this story can likely name by heart several
    of the important protagonists of the story: Alice, Mad Hatter, Cheshire Cat, and
    so on. And those of us who are familiar with the story are also likely very aware
    of the Queen of Hearts repeatedly shouting “OFF WITH THEIR HEADS!”'
  prefs: []
  type: TYPE_NORMAL
- en: In a network, if you remove the most connected and important nodes, what often
    happens looks a lot like the scene in *Star Wars*, where the Death Star explodes.
    All at once, many nodes are transformed into isolates, their edges destroyed along
    with the central node that was removed. This is catastrophic to a network, and
    the information flow is disrupted. Can you imagine the real-world impact of what
    happens when key nodes are removed from a network? Your internet goes down. Your
    power goes out. Supply chains are disrupted. Grocery stores are not stocked, and
    on and on and on. Understanding networks and simulating disruption can give ideas
    on how to bolster the supply chain and information flow. That is the point of
    this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we are going to have fun. We are just going to give the Queen of Hearts
    one huge win. We are going to let her execute four of the main characters in the
    story and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s execute them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We decided that the Queen of Hearts has successfully executed `Alice`, `Dormouse`,
    `White Rabbit`, and `Mad Hatter`. It would have been a terrible story if this
    had happened, but we’re going to play it out. I am choosing these four because
    I know that they are key characters in the story. Their removal from the network
    should shatter it, which is what I want to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: After removing just four of the key nodes in this network, what does the rest
    of the network look like? What are the consequences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Shattered Alice network](img/B17105_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Shattered Alice network
  prefs: []
  type: TYPE_NORMAL
- en: Disaster. We can see several nodes that were made into isolates. We still have
    one primary component in the center, and we have two other smaller components
    with two to four nodes. But in general, the network has been shattered, and the
    information flow has been disrupted. New relationships will need to be built.
    New hierarchies will need to be established. The queen’s court has become dominant,
    just by removing four nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look closer at the primary component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are a few things to understand in this code. First, `nx.connected_components(G)`
    has converted the graph into a list of connected components. One of the components
    will be the primary component, but it is not necessarily the first one on the
    list. After some investigation, we will find that the fourth component was the
    primary component, so let’s set that as `main_component` and then visualize the
    subgraph of that component. This is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Queen’s court subgraph](img/B17105_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Queen’s court subgraph
  prefs: []
  type: TYPE_NORMAL
- en: The queen’s court is intact and contains characters who were unfortunate enough
    to be trapped in the network before the executions happened.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it for this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took raw data, performed a series of steps to clean the
    network, and even carried out a very simple attack simulation.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that at this point, looking at and working with networks is starting
    to feel more natural. The more that I work with networks, the more that I see
    them in everything, and they affect my understanding of the world. We are using
    a fantasy story for this chapter because it is of a manageable size to explain
    the construction, cleaning, and some simple analysis. As you learn more about
    networks, you will likely find that real-world networks are usually much messier,
    more complicated, and larger. I hope that this simple network will give you the
    tools and practice you need to eventually chase much more ambitious problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to have a lot of fun. Our next chapter is about
    analyzing whole networks. You will learn all kinds of useful things, such as how
    to identify the most influential nodes in a network. From here on out, we will
    do a lot of network analysis and visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Network Science and Social Network Analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In these chapters, we learn how to analyze networks and hunt for insights. We
    begin with a discussion on whole network analysis and gradually zoom in to the
    node level, to investigate egocentric networks. We then look for communities and
    subgroups that exist in networks. Finally, we conclude the book by showing how
    graph data can be useful for supervised and unsupervised machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17105_07.xhtml#_idTextAnchor261)*, Whole Network Analysis*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17105_08.xhtml#_idTextAnchor313)*, Egocentric Network Analysis*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17105_09.xhtml#_idTextAnchor364)*, Community Detection*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17105_10.xhtml#_idTextAnchor394)*, Supervised Machine Learning
    on Network Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B17105_11.xhtml#_idTextAnchor432)*, Unsupervised Machine Learning
    on Network Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
