- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whole Network Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we spent a lot of time covering how networks can be constructed
    using text and how cleanup can be done on networks. In this chapter, we are moving
    on to **whole network analysis**. For the sake of simplicity, I will call it **WNA**.
    WNA is done to get the lay of the land, to understand the denseness of a network,
    which nodes are most important in various ways, which communities exist, and so
    forth. I’m going to cover material that I have found useful, which is a bit different
    from what is found in most **social network analysis** (**SNA**) or network science
    books. I do applied network science every day, and my goal is to showcase some
    of the options that are available to allow readers to very quickly get started
    in network analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Network science and SNA are both very rich topics, and if you find any section
    of this chapter especially interesting, I encourage you to do your own research
    to learn more. Throughout this book, I will reference certain sections of NetworkX
    documentation. Be aware that there are many additional non-covered capabilities
    on those reference pages, and it can be insightful to learn about lesser-used
    functions, what they do, and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX’s online documentation shares links to journal articles, so there is
    plenty to read and learn.
  prefs: []
  type: TYPE_NORMAL
- en: As you read this chapter, I want you to consider the problems that you work
    on and try to find ways that you can use what I am describing in your own work.
    Once you begin working with networks, you will see that they are everywhere, and
    once you learn how to analyze and manipulate them, then a world of opportunity
    opens up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating baseline WNA questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WNA in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing centralities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing subgraphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating connected components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding network layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the Python libraries NetworkX and pandas.
    Both of these libraries should be installed by now, so they should be ready for
    your use. If they are not installed, you can install Python libraries with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, to install NetworkX, you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 4*](B17105_04.xhtml#_idTextAnchor158), we also introduced a `draw_graph()`
    function that uses both NetworkX and `Scikit-Network`. You will need that code
    anytime that we do network visualization. Keep it handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all of the code in this chapter in the GitHub repository: [https://github.com/PacktPublishing/Network-Science-with-Python](https://github.com/PacktPublishing/Network-Science-with-Python).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating baseline WNA questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I often jot down questions that I have before doing any kind of analysis. This
    sets the context of what I am looking for and sets up a framework for me to pursue
    those answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In doing any kind of WNA, I am interested in finding answers to each of these
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How big is the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How complex is the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the network visually look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the most important nodes in the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there islands, or just one big continent?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What communities can be found in the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What bridges exist in the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do the layers of the network reveal?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions give me a start that I can use as a task list for running through
    network analysis. This allows me to have a disciplined approach when doing network
    analysis, and not just chase my own curiosity. Networks are noisy and chaotic,
    and this scaffolding gives me something to use to stay focused.
  prefs: []
  type: TYPE_NORMAL
- en: Revised SNA questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will be using a K-pop social network. You can learn more
    about this network data in [*Chapter 2*](B17105_02.xhtml#_idTextAnchor048).
  prefs: []
  type: TYPE_NORMAL
- en: My goal is to understand the shape of the network and how information flows
    between individuals and communities. I also want to be able to explore different
    levels of the network, as if I am peeling an onion. The core is often especially
    interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is a social network, I have additional questions beyond the previous
    baseline questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How big is the social network? What does this mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How complex and interconnected is the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the network visually look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who are the most important people and organizations in the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there just one giant cluster in the network, or are there isolated pockets
    of people?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What communities can be found in the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What bridges exist in the network?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do the layers of the network reveal?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social network analysis revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17105_02.xhtml#_idTextAnchor048), *Network Analysis*, I described
    the definition, origins, and uses of network science and SNA. Although these are
    two independent fields of study, there is so much overlap that I consider the
    social network to be a set of techniques that should be rolled up into network
    science. This is because SNA can make great use of network science tools and techniques,
    and network science can be made a lot more interesting by applying it to social
    networks. I personally do not distinguish between the two.
  prefs: []
  type: TYPE_NORMAL
- en: What *is* social network analysis? In my view, it is a different perspective
    on network analysis, from a social angle. Network science has to do with how networks
    are constructed, the properties of networks, and how networks evolve over time.
    In social network analysis, we are interested in getting a bit more personal.
    We want to know *who* the important people and organizations are that exist in
    a network, which individuals serve as bridges between communities, and which communities
    exist and why they exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**Content analysis** is where the marriage of NLP and network science is most
    important. NLP allows for the extraction of entities (people, places, and organizations)
    and predicts the sentiment of classifying text. Network science and SNA allow
    for understanding much more about the relationships that exist in these networks.
    So, with NLP and network analysis, you have both content context as well as relationship
    context. This is a powerful synergy, where *1 + 1 =* *3*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are not going to be doing any NLP. I will explain some capabilities
    of network science and SNA. So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: WNA in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the previous chapter, in NetworkX, you are able to construct
    networks as either undirected, directed, multi-, or multi-directed graphs. In
    this chapter, we’re going to use an undirected graph, as I want to show how certain
    functionality can be used to understand networks. Just know this: what I am about
    to show has different implications if you use one of the other types of networks.
    You also have more options to explore when you use directed networks, such as
    investigating `in_degrees` and `out_degrees`, not just degrees in general.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data and creating networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is construct our graph. We cannot analyze what
    we do not have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read the K-pop edge list from my GitHub like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previewing the pandas DataFrame, we can see that there are columns for `'source'`
    and `'target'`. This is exactly what NetworkX is looking for to build a graph.
    If you had wanted to name the graph columns differently, NetworkX would have allowed
    you to specify your own source and target columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the shape of the edge list, we can see that there are 1,286 edges
    in the edge list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember, an edge is a relationship between one node and another, or between
    one node and itself, which is known as a **self-loop**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our pandas edge list ready, we can use it to construct our
    undirected graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s inspect `G` to make sure that it is an undirected NetworkX graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This looks perfect, so we are ready to begin our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Network size and complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we are going to investigate is the network’s size, shape, and
    overall complexity. Let me define what I mean by that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network size**: The number of nodes and the number of edges that exist in
    a network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network complexity**: The amount of clustering and density present in the
    network. Clustering is the number of possible triangles that actually exist in
    a network, and density similarly refers to how interconnected the nodes in a network
    are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NetworkX makes it very easy to find the number of nodes and edges that exist
    in a network. You can simply use `nx.info(G)`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our network has 1,163 nodes and 1,237 edges. To put that into plain English,
    our K-pop social network consists of 1,163 people and organizations, and among
    those 1,163 people and organizations, there are 1,237 identified interactions.
    As this is Twitter data, an interaction, in this case, means that the two accounts
    were mentioned in the same tweet, meaning that they are related in some way. Going
    back to the importance of NLP and content analysis, we can use these identified
    relationships to further dig into what types of relationships these actually are.
    Are they collaborative relationships? Were they arguing? Did they write a research
    paper together? SNA will not give us that answer. We need content analysis to
    get to those. But this chapter is on network analysis, so let’s continue.
  prefs: []
  type: TYPE_NORMAL
- en: Is this a dense network? Internet social networks tend to be sparse, not dense,
    unless you are analyzing a tight-knit group of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the clustering and density of the network look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s check average clustering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Clustering gives us a result of about `0.007`, which indicates that this is
    a sparse network. If clustering had returned a result of `1.000`, then that would
    indicate that every node is connected with every other node in the network. From
    an SNA context, that would mean that every person and organization in the network
    knows and interacts with each other. In K-pop, this is certainly not the case.
    Not all musicians know their fans. Not all fans are friends with their favorite
    idols.
  prefs: []
  type: TYPE_NORMAL
- en: What does `density` look like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Density gives us a result of about `0.002`, which further validates the sparsity
    of this network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s not move on just yet. I want to make sure these concepts are understood.
    Let’s construct a fully connected graph – a “complete” graph – with 20 nodes and
    repeat the steps from the preceding paragraphs. NetworkX has some handy functions
    for generating graphs, and we will use `nx.complete_graph` for this demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build the graph!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, let’s investigate the size of the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great. We have a network with 20 nodes, and those 20 nodes have 190 edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is this actually a fully connected network, though? If it is, then we should
    get `1.0` for both clustering and density:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perfect. That’s exactly what we expected. But what does this network look like?
    Let’s use the same function we’ve been using throughout this book to draw the
    visualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will draw our network without any node labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Complete graph](img/B17105_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Complete graph
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the network visualization, every node links with every other
    node. This is a fully connected network. Our K-pop network is a sparsely connected
    network, so the visualization will look very different.
  prefs: []
  type: TYPE_NORMAL
- en: Network visualization and thoughts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know what a fully connected network looks like, and we know that the K-pop
    social network is sparsely connected, but what does that actually look like? Let’s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will create a network visualization with nodes and edges, but without labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – K-pop network](img/B17105_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – K-pop network
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice is that even with only a thousand nodes, this still takes
    a few seconds to render, and it’s impossible to pull any real insights out of
    the network. We can see a bunch of small dots, and we can see a bunch of lines
    from those small dots to other small dots. We can also notice that there is a
    core to the network and that the sparsity of the network increases the further
    we go toward the outskirts of the network. The idea of network layers will be
    explored later in this chapter. The point is that there’s very little we can do
    with this visualization other than consider that it looks cool. At least we can
    visualize it, and in the later section of this chapter, I will explain how we
    can “peel the onion” to understand the various layers in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'But just to show something now, here is a very quick way to remove every node
    that only has a single edge, which is most of the network. If you do this, you
    can very quickly denoise a network. This is a huge time saver, as my previous
    approach for doing the exact same thing was to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify every node with a single edge, using a list comprehension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove it from the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This one line of code removes the need for any of that. `K_core` converts the
    `G` graph into another graph that only contains nodes with two or more edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Easy. How does the network look now?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – K-pop network simplified](img/B17105_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – K-pop network simplified
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you can see that this one single step quickly brought out the structure
    of the network that exists underneath all of those nodes that only have a single
    edge. There are several ways to simplify a network, and I use this method frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Important nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have an understanding of the general shape of the network, but we are
    interested in knowing who the most important people and organizations are. In
    network science, there is such a thing as **centrality scores** that give an indication
    of the importance of nodes in a network based on where they are placed and how
    information flows. NetworkX offers dozens of different centrality measures. You
    can learn about them at [https://networkx.org/documentation/stable/reference/algorithms/centrality.html](https://networkx.org/documentation/stable/reference/algorithms/centrality.html).
  prefs: []
  type: TYPE_NORMAL
- en: I will introduce a few of the centralities that I frequently use, but these
    are not necessarily the most important ones. Each centrality is useful for uncovering
    different contexts. The founders of Google also created their own centrality,
    famously known as **PageRank**. PageRank is a go-to centrality for many data professionals,
    but it may not be enough. To be thorough, you should understand the importance
    of nodes based both on how they are connected as well as how information moves.
    Let’s explore a few different ways of gauging the importance of nodes in a network.
  prefs: []
  type: TYPE_NORMAL
- en: Degrees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to judge the importance of somebody or something in a network
    is based on the number of connections between it and other nodes. Thinking about
    popular social networks such as Twitter or Facebook, influencers are often very
    well-connected, and we are suspicious of accounts that have very few connections.
    We are taking that concept and attempting to pull this insight from our network
    via code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a network, an entity (person, place, organization, and so on) in a network
    is called a node, and a relationship between one node and another is called an
    edge. We can count the number of edges each node has by investigating the degree
    counts of nodes in a network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a Python dictionary of nodes and their degree count. If we throw
    this dictionary into a pandas DataFrame, we can sort it and visualize the degree
    counts easily:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s load it into a pandas DataFrame and sort by degrees in descending
    order (high to low):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will show a DataFrame of Twitter accounts and their degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – pandas DataFrame of node degrees](img/B17105_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – pandas DataFrame of node degrees
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a horizontal bar chart for some quick insights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will visualize Twitter account connections by degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Horizontal bar chart of Twitter accounts by degrees](img/B17105_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Horizontal bar chart of Twitter accounts by degrees
  prefs: []
  type: TYPE_NORMAL
- en: One thing that stands out is that the number of degrees very quickly drops off,
    even when comparing the 20 most connected nodes. There is a significant drop-off
    even after the most connected node. The most connected node in the network belongs
    to singer/songwriter/actor Byun Baek-hyun – better known as Baekhyun – from the
    group Exo. That’s interesting. Why is he so connected? Are people connecting to
    him, or does he connect to other people? Each insight tends to draw out more questions
    that can be explored. Write them down, prioritize by value, and then you can use
    those questions for deeper analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Degree centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Degree centrality** is similar to judging importance based on the number
    of degrees a node has. Degree centrality is the fraction of nodes in a network
    that a node is connected to. The more degrees a node has, the higher the fraction
    of nodes they will be connected to, so degrees and degree centrality can really
    be used interchangeably:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the degree centrality of every node in the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use this to create another pandas DataFrame, sorted by degree centrality
    in descending order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will show a dataframe of Twitter accounts and their degree centralities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – pandas DataFrame of nodes'' degree centrality](img/B17105_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – pandas DataFrame of nodes' degree centrality
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can visualize this as a horizontal bar chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will draw a horizontal bar chart of Twitter accounts by degree centrality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Horizontal bar chart of Twitter accounts by degree centrality](img/B17105_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Horizontal bar chart of Twitter accounts by degree centrality
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the bar charts for degrees and degree centrality look identical
    other than the value? This is why I say that they can be used interchangeably.
    The use of degrees will likely be easier to explain and defend.
  prefs: []
  type: TYPE_NORMAL
- en: Betweenness centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Betweenness centrality** has to do with how information flows through a network.
    If a node is positioned between two other nodes, then information from either
    of those two nodes must be passed through the node that sits between them. Information
    flows through the node that is sitting in the middle. That node can be seen as
    a bottleneck, or a place of advantage. It can give a strategic advantage to have
    the information that others need.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, though, nodes with high betweenness centrality are situated between
    many nodes, not just two. This is often seen in a start network, where a core
    node is connected to dozens of other nodes or more. Consider an influencer on
    social media. That person may be connected to 22 million followers, but those
    followers likely do not know each other. They certainly know the influencer (or
    are an inauthentic bot). That influencer is a central node, and betweenness centrality
    will indicate that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we see how to calculate betweenness centrality, please note that betweenness
    centrality is very time-consuming to calculate for large or dense networks. If
    your network is large or dense and is causing betweenness centrality to be so
    slow as to no longer be useful, consider using another centrality to calculate
    importance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the betweenness centrality of every node in the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use this to create another pandas DataFrame, sorted by betweenness centrality
    in descending order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will show a dataframe of Twitter accounts and their betweenness centralities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – pandas DataFrame of nodes'' betweenness centrality](img/B17105_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – pandas DataFrame of nodes' betweenness centrality
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can visualize this as a horizontal bar chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will draw a horizontal bar chart of Twitter accounts by betweenness centrality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Horizontal bar chart of Twitter accounts by betweenness centrality](img/B17105_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Horizontal bar chart of Twitter accounts by betweenness centrality
  prefs: []
  type: TYPE_NORMAL
- en: Take note that the bar chart looks very different from the charts for degrees
    and degree centrality. Also note that `@youtube`, `@spotifykr`, and `@kchartsmaster`
    are the nodes with the highest betweenness centrality. This is likely because
    artists and others reference YouTube, Spotify, and KChartsMaster in their tweets.
    These nodes sit between nodes and other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Closeness centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Closeness centrality** has to do with the closeness of nodes to other nodes,
    and that has to do with something known as the **shortest path**, which is computationally
    expensive (and slow) to compute for a large or dense network. As a result, closeness
    centrality may be even slower than betweenness centrality. If getting results
    from closeness centrality is too slow, due to the size and density of your own
    networks, you can choose another centrality for importance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortest path will be explored in another chapter but has to do with the
    number of hops or handshakes it takes to get from one node to another node. This
    is a very slow operation, as there are many calculations at play:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the closeness centrality of every node in the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use this to create another pandas DataFrame, sorted by closeness centrality
    in descending order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will show a dataframe of Twitter accounts and their closeness centralities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – pandas DataFrame of nodes'' closeness centrality](img/B17105_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – pandas DataFrame of nodes' closeness centrality
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can visualize this as a horizontal bar chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will draw a horizontal bar chart of Twitter accounts by closeness centrality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Horizontal bar chart of Twitter accounts by closeness centrality](img/B17105_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Horizontal bar chart of Twitter accounts by closeness centrality
  prefs: []
  type: TYPE_NORMAL
- en: Take note that the results look different than every other centrality we have
    looked at. `@blackpink` is in the top spot, followed by `@youtube`, `@kchartsmaster`,
    and `@spotifykr`. BLACKPINK is a well-known K-pop group, and they are well-connected
    in the K-pop network, allowing them reach and influence. Other K-pop artists may
    want to investigate what it is that BLACKPINK is doing that puts them in a strategically
    advantageous network position.
  prefs: []
  type: TYPE_NORMAL
- en: PageRank
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, PageRank is the algorithm behind Google Search. The creators of Google
    wrote about it in 1999 in this paper: [http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf](http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf).
    If you have ever googled anything, the results that are returned to you are partially
    due to PageRank, though the search has likely evolved significantly since 1999.'
  prefs: []
  type: TYPE_NORMAL
- en: The PageRank mathematical formula considers the number of inbound and outbound
    degrees of not only a node in question but of the linking nodes as well. It is
    because of this that **Search Engine Optimization** (**SEO**) has become a thing,
    as it became known that to get top Google positioning, a website should have as
    many inbound links as possible while also linking to other sources of information.
    For more information on the mathematics behind PageRank, check the PDF from Stanford
    University.
  prefs: []
  type: TYPE_NORMAL
- en: 'PageRank is a very fast algorithm, suitable for large and small networks, and
    very useful as an *importance* metric. Many graph solutions provide PageRank capabilities
    in their tools, and many people treat PageRank as their preferred centrality.
    Personally, I believe that you should know several centralities, where they are
    useful, and what their limitations are. PageRank is useful even for large and
    dense networks, so I recommend that it be included anytime you are doing any centrality
    analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the PageRank score of every node in the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use this to create another pandas DataFrame, sorted by PageRank in descending
    order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will show a dataframe of Twitter accounts and their PageRank scores.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – pandas DataFrame of nodes'' PageRank scores](img/B17105_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – pandas DataFrame of nodes' PageRank scores
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can visualize this as a horizontal bar chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will draw a horizontal bar chart of Twitter accounts by PageRank.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Horizontal bar chart of Twitter accounts by page rank](img/B17105_07_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Horizontal bar chart of Twitter accounts by page rank
  prefs: []
  type: TYPE_NORMAL
- en: These results actually look very similar to the bar chart from degrees and degree
    centrality. Once again, Baekhyun from Exo is in the top position.
  prefs: []
  type: TYPE_NORMAL
- en: Edge centralities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before concluding this section on centralities, I want to point out that you
    are not limited to centralities for nodes. There are also centralities for edges.
    For instance, **edge betweenness centrality** can be used to identify the edge
    that sits between the most nodes. If you were to snip the edge that sits between
    most nodes, often the network would be split into two large pieces, called **connected
    components**. This can actually be useful for identifying communities or emerging
    trends. We will explore that more in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing centralities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a feel for how the different centralities differ, or to use multiple
    different centralities together (for instance, if building an ML classifier and
    wanting to use graph metrics), it can be useful to combine the different centralities
    together into a single pandas DataFrame. You can easily do so with the pandas
    `concat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This will combine all of our centrality and PageRank DataFrames into one unified
    DataFrame. This will make it easier for us to compare different types of centralities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – pandas DataFrame of combined importance metrics](img/B17105_07_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – pandas DataFrame of combined importance metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that if you rank by the different types of centralities, some
    have very similar results, and others are very different. I’ll leave you with
    this: there is no single centrality to rule them all. They are different, and
    they should be used in different situations. If you are mapping out information
    flow, then betweenness centrality is very useful, so long as the network is of
    a manageable size. If you just want to see which nodes in a network are most connected,
    this is easiest to do by just investigating degrees. If you want to understand
    which nodes are situated closest to every other node, try closeness centrality.
    And if you want one algorithm that does a pretty good job at identifying important
    nodes and is performant even on large networks, try PageRank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This will show a DataFrame of Twitter accounts and combined network centralities
    and PageRank scores.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – pandas DataFrame of combined importance metrics sorted by PageRank](img/B17105_07_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – pandas DataFrame of combined importance metrics sorted by PageRank
  prefs: []
  type: TYPE_NORMAL
- en: Just know that even PageRank and betweenness centrality can give very different
    results, so you should learn several different ways of determining importance
    and know what you are trying to do. These are very unfamiliar for beginners, but
    don’t be afraid. Jump in and learn. The documentation and linked journals on NetworkX’s
    documentation will be enough to help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: Centralities are probably the most unusual section of this chapter if you are
    just getting started with social network analysis and network science. From this
    point on in the chapter, concepts should be less unusual.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing subgraphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, in network analysis, we will want to see just a portion of the network,
    and how nodes in that portion link to each other. For instance, if I have a list
    of 100 web domains of interest or social media accounts, then it may be useful
    to create a subgraph of the whole graph for analysis and visualization.
  prefs: []
  type: TYPE_NORMAL
- en: For the analysis of a subgraph, everything in this chapter is still applicable.
    You can use centralities on subgraphs to identify important nodes in a community,
    for instance. You can also use community detection algorithms to identify communities
    that exist in a subgraph when the communities are unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualizing subgraphs is also useful when you want to remove most of the noise
    in a network and investigate how certain nodes interact. Visualizing a subgraph
    is identical to how we visualize whole networks, ego graphs, and temporal graphs.
    But creating subgraphs takes a tiny bit of work. First, we need to identify the
    nodes of interest, then we need to construct a subgraph containing only those
    nodes, and finally, we will visualize the subgraph:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s choose the 100 nodes from the network that have the highest
    PageRank scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That was easy. I’m only showing a few of the nodes, as this scrolls down the
    screen quite a way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I can construct a subgraph, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, I can visualize it, the same way I would visualize any other network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, I have left off the node names, but I could have just as easily
    added them. I felt it would make a cleaner visualization for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Subgraph visualization of the top 100 K-pop Twitter accounts
    by PageRank](img/B17105_07_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Subgraph visualization of the top 100 K-pop Twitter accounts by
    PageRank
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. There’s really not a lot to know about subgraph creation, other than
    that it is doable and how to do it. It is a simple process, once you know how.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating islands and continents – connected components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a look at the subgraph visualization, you may notice that there
    is one large cluster of nodes, a few small islands of nodes (two or more edges),
    and several isolates (nodes with no edges). This is common in many networks. Very
    often, there is one giant supercluster, several medium-sized islands, and so many
    isolates.
  prefs: []
  type: TYPE_NORMAL
- en: This presents challenges. When some people are new to network analysis, they
    will often visualize the network and use PageRank to identify important nodes.
    That is not nearly enough, for anything. There are so many different ways to cut
    the noise from networks so that you can extract insights, and I will show you
    several throughout the course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: But one very simple way to cut through the noise is to identify the continents
    and islands that exist in a network, create subgraphs using them, and then analyze
    and visualize those subgraphs.
  prefs: []
  type: TYPE_NORMAL
- en: These *continents* and *islands* are formally called **connected components**.
    A connected component is a network structure where each node is connected to at
    least one other node. NetworkX actually allows for isolates to exist in their
    own connected components, which is strange to me, as isolates are not connected
    to anything other than possibly themselves (self-loops exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding all of the connected components that exist in a network is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m doing two things here: first, I load all connected components of our `G`
    graph into a Python list, and then I count the number of components that exist.
    There are 15 in the K-pop network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, but which of these 15 are continents, and which are islands? Using a
    simple loop, we can count the number of nodes that exist in each connected component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a list of connected components and the number of nodes that
    are part of the connected component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Perfect. Notice that one of the components has 909 nodes. This is an example
    of one of those large continents that can exist in a network. Also, notice the
    components that have 80 and 129 nodes. This is significantly fewer than the number
    of nodes in the largest connected component, but it is still a significant number
    of nodes. I consider these as islands. Finally, notice that there are several
    other components that have between 2 and 10 nodes. These are like tiny islands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these connected components can be analyzed and visualized as a subgraph.
    For this exercise, to simplify visualization, I’ll create a helper function to
    extend my main `draw_graph` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try this out. Let’s visualize a random component, component 13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: How does it render?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Subgraph visualization of connected component #13](img/B17105_07_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17 – Subgraph visualization of connected component #13'
  prefs: []
  type: TYPE_NORMAL
- en: 'That looks good. We have successfully visualized a single component from the
    overall network. Let’s visualize the largest component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.18 – Subgraph visualization of connected component #0](img/B17105_07_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18 – Subgraph visualization of connected component #0'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we are back to a giant, messy ball of yarn. We did successfully
    visualize it, though, and we can massively simplify it by removing all nodes with
    a single edge, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Connected components are a bit unusual, like centralities, but if you think
    of them as islands and continents that exist in a network, that really takes away
    a lot of the mystique. In summary, in a network, there are usually several connected
    components, and I consider them to be continents, islands, or isolates. In most
    networks, there is usually at least one large continent, several islands, and
    zero to many isolates. The number of isolates depends on how the graph was constructed.
    Using our NER approach from previous chapters, there are no isolates.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some more things we can do with connected components in [*Chapter
    9*](B17105_09.xhtml#_idTextAnchor364).
  prefs: []
  type: TYPE_NORMAL
- en: Communities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Community detection algorithms are very useful in various forms of network analysis.
    In WNA, they can be used to identify communities that exist in the whole network.
    When applied to egocentric networks (ego graphs), they can reveal communities
    and cliques that exist around a single node, and in temporal networks, they can
    be used to watch communities evolve over time.
  prefs: []
  type: TYPE_NORMAL
- en: Community detection is common in SNA because communities of people exist in
    large populations, and it can be useful to identify those communities. There are
    various approaches to community detection, and there is quite a lot of information
    available on the internet for how community detection algorithms work. This book
    is about applied network science, so I am just going to demonstrate one, called
    the **Louvain algorithm**. Like centralities, there is no “best” algorithm. I
    have been in conversations where somebody pointed out a fringe algorithm that
    they were convinced was better, and I have been in conversations where people
    preferred Louvain.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Louvain algorithm here: [https://python-louvain.readthedocs.io/en/latest/](https://python-louvain.readthedocs.io/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Louvain algorithm does not come with NetworkX. You will need to install
    it, which is as simple as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, you can import the library for use with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To save a lot of time and skip right past the math, the Louvain algorithm identifies
    various partitions (communities) that nodes are a part of. Visualizing these partitions
    is a bit trickier than our usual network visualizations, as `scikit-network` does
    not offer a lot of flexibility for coloring nodes. To save time, I’m going to
    return to my older network visualization practices and use NetworkX for visualization.
    Here is the code for drawing our graph and coloring the communities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the visualization function, we need to first identify partitions,
    and then we need to visualize the network. Let’s do both of these together. I
    am using `resolution=2` after some tuning, as the community placement looks optimal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How does it look?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Visualization of community partitions](img/B17105_07_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Visualization of community partitions
  prefs: []
  type: TYPE_NORMAL
- en: 'These images are messy but mesmerizing, to me. I can visually see easily distinguishable
    communities that I never noticed before. But what are they? What nodes are part
    of each community? It is simple to convert this partition list into a pandas DataFrame,
    and we can use that to identify communities, count the number of nodes that exist
    in each community, identify which community a node falls into, and visualize the
    individual communities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a pandas DataFrame from the partition list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How does it look now?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – pandas DataFrame of community partitions](img/B17105_07_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – pandas DataFrame of community partitions
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks good. We can see that it is already sorted by partition number,
    which I am calling `community`. Now that this is in a pandas DataFrame, it is
    simple to count the number of nodes that belong to each community:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give us a list of communities (the lefthand number) and a count of
    nodes that are part of the community (the righthand number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: We can easily see which communities have the most nodes. We should analyze and
    visualize these using subgraphs, as explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we identify the nodes that exist in each community, though? Let’s just
    do this in pandas. Here is a simple helper function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use that function as it is, but I would prefer to take those `community`
    nodes, create a subgraph, and visualize it. Here is a helper function to do all
    of that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s try one out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.21 – Subgraph visualization of community #1](img/B17105_07_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21 – Subgraph visualization of community #1'
  prefs: []
  type: TYPE_NORMAL
- en: After running that, I can see this visualization. If you see something different,
    don’t worry. When working with networks, things such as connected components and
    community numbers do not always end up in the same place on a subsequent run.
  prefs: []
  type: TYPE_NORMAL
- en: Very cool. This feels very similar to visualizing connected components, but
    communities are not necessarily islands or continents. Several communities can
    be found in large connected components, for instance. The algorithm looks for
    boundaries that separate groups of nodes, and then it labels communities accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with networks, and especially if you are interested in identifying
    communities of people that exist in social networks, you will want to learn as
    much as you can about how to identify cliques and communities. Try different algorithms.
    I have chosen Louvain because it is fast and reliable, even on massive networks.
  prefs: []
  type: TYPE_NORMAL
- en: Bridges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simple terms, bridges are nodes that sit between two different communities.
    These are typically easy to visually identify in small social networks, as there
    will be what looks like one or a few rubber bands or strengths that, if snipped,
    would allow the two groups to split apart. Just as a bridge allows people to traverse
    across the water from one piece of land to another, bridges in networks allow
    information to spread from one community to another. As a human, being a bridge
    is a powerful position to be in, as information and resources must flow through
    you to reach the other side.
  prefs: []
  type: TYPE_NORMAL
- en: In a complex network, bridges are more difficult to see visually, but they often
    exist, sitting between two communities. Our K-Pop network is pretty complex, so
    networks are less visible than they might be in a smaller social network, but
    they are there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find bridges in a network like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a very long list of bridges, and I’m only showing a few of the rows,
    but we can use this along with pandas to identify the most important bridges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One side effect of removing bridge nodes is that it can be similar to removing
    highly central notes – the network will shatter into a large group of isolates
    and a few smaller connected components. Let’s take the 10 bridge nodes with the
    most edges and remove them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After doing this, our network will likely look like a star has gone supernova,
    with debris flying out into space. Let’s take a look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should draw a network without node labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Network visualization with top bridges cut](img/B17105_07_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Network visualization with top bridges cut
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there is still one densely connected component in the center
    of the network, a few tiny connected components consisting of a few nodes, and
    many individual isolates. Cutting bridges is not always so devastating. In other
    networks I have worked on, there’s been a core nucleus consisting of two communities
    with a few nodes sitting between the two communities as bridges. When removing
    those bridges, the network core communities just split apart. There were few or
    no isolates.
  prefs: []
  type: TYPE_NORMAL
- en: There are reasons for identifying bridges. In a social network, these are nodes
    that information must flow through in order to reach communities on the other
    side. If you wanted to strategically place yourself in one of these networks,
    it would be wise to understand what the bridge is doing and then mimic what they
    have done, making connections with the people on each side. This can be a shortcut
    to power.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if your goal was to disable a network, identifying and removing important
    bridges would cease the information flow from one community to another. It would
    be highly disruptive. This can be useful for disrupting dark networks (of crime,
    hate, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: These are useful insights that can be extracted from networks, and they aren’t
    as identifiable without network analysis. Identifying bridges and having a plan
    for what to do with them can provide a strategic advantage. You can use them to
    gain power, you can use them to disrupt, or you can use them to pull network communities
    apart for cleaner analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding layers with k_core and k_corona
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Networks can be thought of as like onions, and they are often visualized similarly,
    with isolates drawn on the outside, nodes with a single edge rendered after that,
    then nodes with two edges, and on and on and on until the core of the network
    is reached. NetworkX allows two functions for peeling the onion, so to say: **k_core**
    and **k_corona**.'
  prefs: []
  type: TYPE_NORMAL
- en: k_core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NetworkX’s `k_core` function allows us to easily reduce a network to only nodes
    that have `k` or more edges, with “`k`” being a number between 0 and the maximum
    number of edges that any node has in a network. As a result, you get the “core”
    of a network that contains `k` or more edges. If you were to do `k_core(G, 2)`,
    then this would return a graph containing nodes that have two or more edges, removing
    isolates and nodes with a single degree in one easy step.
  prefs: []
  type: TYPE_NORMAL
- en: That single step of denoising a network may not seem like a big deal, but doing
    this with list comprehensions or loops requires more steps, more thought, and
    more troubleshooting. This single step easily does the cleanup. As such, `k_core(G,
    2)` is common in my code when I am most interested in the shape of the network
    that exists after removing isolates and single-edge nodes.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, here is what our full K-pop network looks like when it is rendered.
    It is very difficult to see anything, as the single-edge nodes have turned the
    network visualization into a messy ball of yarn.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Whole network visualization](img/B17105_07_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Whole network visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can easily remove all nodes that have fewer than two edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: How does the network look now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: This should draw our `G_core` network with node labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Whole network visualization with k_core and k=2](img/B17105_07_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – Whole network visualization with k_core and k=2
  prefs: []
  type: TYPE_NORMAL
- en: It should be obvious that this is much easier to interpret.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about `k_core` was one of the most important moments for me as I learned
    how to analyze graphs and social networks. I used to denoise networks the less
    straightforward way, identifying nodes with fewer than two degrees, adding them
    to a list, and then removing them from a network. This single function has saved
    me so much time.
  prefs: []
  type: TYPE_NORMAL
- en: k_corona
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as `k_core` allows us to extract the core of a network, `k_corona` allows
    us to investigate each layer of a network. `k_corona` is not about finding the
    core. It is about investigating what is happening in each layer of the network.
    For instance, if we only wanted to see nodes that have zero or one edges, we could
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'This would render as a bunch of isolates, and there will also likely be a few
    nodes that have one edge between them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s visualize the results of `k_corona(G, 1)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should render a network visualization of all nodes that have one or fewer
    edges. Nodes without any edges are called isolates and will appear as dots.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Visualization of k_corona k=1 layer](img/B17105_07_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – Visualization of k_corona k=1 layer
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are lots of isolates. Can you identify the few nodes that
    have a single edge between them? I can’t. It’s like reading that book, Where’s
    Waldo? So, how do we identify the nodes in this layer that have an edge between
    them? How do we remove all of the nodes that have less than one edge? Think for
    a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s right, we’ll use `k_core` for the cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we visualize this, we can see that there are five connected components, each
    containing two nodes, and each node has a single edge between it and another node
    that exists in that connected component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: This will draw the `G_corona` network, with isolates removed, and with node
    labels showing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Visualization of k_corona k=1 layer, simplified](img/B17105_07_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – Visualization of k_corona k=1 layer, simplified
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there an easy way to extract these nodes, so that we can use them for further
    analysis? Yes, easily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show us a list of all of the nodes in `corona_nodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the second layer of the network look like, the layer where each node
    has two degrees? Are the nodes on this layer connected to each other? Let’s create
    and render this visualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will render a network visualization of all nodes with two or fewer edges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Visualization of k_corona k=2 layer](img/B17105_07_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – Visualization of k_corona k=2 layer
  prefs: []
  type: TYPE_NORMAL
- en: It looks very similar to `k_corona` of layer one, but we can more easily see
    that a few nodes are connected to other nodes. We can also see that there are
    drastically fewer isolates in this layer. We could redo the `k_core` step for
    cleanup, but I think you get the point.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I don’t use `k_corona` all that often. I have little interest in
    peeling networks, layer by layer, but the option is there, and maybe it can be
    more useful to you than it is to me. However, I use `k_core` practically every
    time I do anything with networks, for denoising a network, and for investigating
    the nucleus or nuclei that exist at the core of social networks. I recommend that
    you learn about both, but you may possibly have much more use for `k_core` than
    for `k_corona`. Still, `k_corona` opens up some interesting doors for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge yourself!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before concluding this chapter, I want to bring a challenge forward to you.
    You have learned how to create networks using text, what an edge list looks like
    and how to build one in pandas, how to create a network, and how to clean a network,
    and now you have an introduction to whole network analysis. You now have every
    tool required to start your journey into network analysis. I will explain how
    to do much more in later chapters, but you have all the tools you need to get
    started and get hooked on network analysis.
  prefs: []
  type: TYPE_NORMAL
- en: I want to challenge you to think about your own data, about the data you work
    with, about the social networks you play on, about the work networks you collaborate
    in, and more. I want you to consider how you could take these living networks,
    describe them in an edge list (it’s just source and target columns), render a
    network visualization, and analyze the networks. You have the tools to do this,
    and networks are all around us. I recommend that when you are learning to investigate
    social networks and various networks, you use data that is actually interesting
    to you. You don’t need to find a dataset online. You can easily create one yourself,
    or you can scrape social media, as we explored in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: I challenge you to stop at this chapter and play around for a while. Get lost
    in networks. Reread previous chapters in this book. Explore. Get weird. Have fun.
    This is my favorite way to learn. I take great enjoyment in building my own datasets
    and analyzing the things that I am most interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone a long way in this chapter. This chapter could be a book on its
    own, but my goal was to give a fast-paced tour of the things that you can do with
    networks. As I stated in the beginning, this will not be a math book. I want to
    unlock new capabilities and opportunities for you, and I feel that this chapter
    and this book can do this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered a lot of ground: explaining whole network analysis,
    describing questions that can help with an analysis, and spending a lot of time
    actually doing network analysis. We looked at the network as a whole, but we also
    looked at node centralities, connected components, and layers.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about egocentric network analysis.
    We call these **ego networks**, to be concise. In that chapter, we will zoom in
    on nodes of interest, to understand the communities and nodes that exist around
    them. You can think of egocentric network analysis as zooming in.
  prefs: []
  type: TYPE_NORMAL
