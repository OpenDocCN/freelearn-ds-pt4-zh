- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Community Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we covered whole network analysis and egocentric network
    analysis. The former was useful for understanding the complete makeup of a complex
    network. The latter was useful for investigating the people and relationships
    that exist around an “ego” node. However, there’s a missing layer that we have
    not yet discussed. Between whole networks and egos, communities exist. We are
    people, and we are part of a global population of humans that exist on this planet,
    but we are each also part of individual communities. For instance, we work in
    companies and as part of individual teams. Many of us have social interests, and
    we know people from participating in activities. There are layers to life, and
    we can use algorithms to identify the various communities that exist in a network,
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing community detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with community detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring connected components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Louvain method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using label propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Girvan-Newman algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other approaches to community detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will mostly be using the NetworkX and pandas Python libraries.
    These libraries should be installed by now, so they should be ready for your use.
    If they are not installed, you can install the Python libraries with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, to install NetworkX, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 4*](B17105_04.xhtml#_idTextAnchor158), we also introduced a `draw_graph()`
    function that uses both NetworkX and Scikit-Network. You will need that code any
    time that we do network visualization. You will need it for this chapter, and
    most of the chapters in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For community detection, we will also be using `python-louvain`. You can install
    it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can import it like this, which you will see later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is understandable if you’re confused by the installation and import commands
    for `python-louvain`. The library name does not match the import library name.
    It’s a useful library for community detection, so let’s accept this as an oddity
    and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing community detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Community detection is about identifying the various communities or groups that
    exist in a network. This is useful in social network analysis, as humans interact
    with others as part of our various communities, but these approaches are not limited
    to studying humans.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use these approaches to investigate any kinds of nodes that interact
    closely with other nodes, whether those nodes are animals, hashtags, websites,
    or any kind of nodes in a network. Pause for a moment and think about what we
    are doing. Community detection is a clear, concise, and appropriate name for what
    we are doing. We are zooming in on communities that exist in a network. What communities
    would you be interested in exploring and understanding, and why?
  prefs: []
  type: TYPE_NORMAL
- en: There are many good use cases for this. You can use it to understand the sentiment
    communities share about your product. You can use this to understand a threat
    landscape. You can use this to understand how ideas move and transform between
    different groups of people. Be creative here. There are probably more uses for
    this than you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore this in the context of human life, but you
    should not feel limited to only using this for social network analysis. This is
    very useful in social network analysis, but it is also useful in analyzing most
    network data, not just social network data. For instance, this can be useful in
    both cybersecurity (malware analysis) and computational humanities, or in understanding
    how ideas move between groups and evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least three different approaches to doing community detection,
    with the most frequently researched including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node closeness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network splitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What I am calling *node connectivity* has to do with whether nodes are part
    of the same connected component or not. If two nodes are not part of the same
    connected component, then they are part of a completely different social group,
    not part of the same community.
  prefs: []
  type: TYPE_NORMAL
- en: Node closeness has to do with the distance between two nodes, even if they are
    part of the same connected component. For instance, two people might work together
    in the same large organization, but if they are more than two handshakes away
    from one another, they may not be part of the same community. It would take several
    rounds of introductions for them to ever meet each other. Consider how many people
    would you have to go through to be introduced to your favorite celebrity. How
    many people would you need to be introduced to?
  prefs: []
  type: TYPE_NORMAL
- en: Network splitting has to do with literally cutting a network into pieces by
    either removing nodes or edges. The preferred approach that I will explain is
    cuts on edges, but I have done something similar by removing nodes, and I've done
    this a few times in this book, shattering networks into pieces by removing central
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: I do not believe that we are at the end of discovery for community detection.
    I hope that reading through this chapter will give you some ideas for new approaches
    to identifying the various communities that exist in networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with community detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start, we need a network to use. Let’s use NetworkX’s *Les Miserables*
    graph that we used in the previous chapter since it held several separate communities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the network is simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all it takes to load the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `weight` attribute that I do not want to include in the network
    because we don’t need edge weights for this simple demonstration. So, I’m going
    to drop it and rebuild the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In those two steps, we converted the *Les Miserables* graph into a `pandas`
    edge list, and we kept only the `source` and `target` fields, effectively dropping
    the `weight` field. Let’s see how many nodes and edges exist in the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a tiny network. Does this network contain isolates and islands, or is
    it just one large connected component? Let’s check.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add the `draw_graph` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s visualize the network in its entirety:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Les Miserables graph](img/B17105_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Les Miserables graph
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, we should be able to see that there are no isolates (nodes without
    edges), there are several nodes with a single edge, there are several clusters
    of nodes that are very close to each other (communities), and there are a few
    critically important nodes. If those critically important nodes were removed,
    the network would shatter to pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in a little, using `k_core`, and only show nodes that have two or
    more edges. Let’s also not display labels so that we can get a sense of the overall
    shape of the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Les Miserables graph, k_core with K=2, unlabeled](img/B17105_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Les Miserables graph, k_core with K=2, unlabeled
  prefs: []
  type: TYPE_NORMAL
- en: The communities should be a little clearer now. Look for parts of the graphs
    where the nodes are close together and where there are more edges/lines present.
    How many communities do you see? Four of them really stand out to me, but there
    are smaller groups scattered around, and there is also likely a community in the
    center of the network.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to begin our attempts at community detection.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring connected components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first attempt at understanding the various communities and structures that
    exist in a network is often to analyze the connected components. As we discussed
    in *w*, connected components are structures in networks where all nodes have a
    connection to another node in the same component.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw previously, connected components can be useful for finding smaller
    connected components. Those can be thought of as communities as they are detached
    from the primary component and overall network, but the largest connected component
    is not typically a single community. It is usually made up of several communities,
    and it can usually be split into individual communities.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Les Miserables* network, there is only one connected component. There
    are no islands or isolates. There is just one single component. That makes sense,
    as these are the characters from a piece of literature, and it wouldn’t make much
    sense for characters in a book to just spend all day talking to themselves. However,
    that takes away a bit of the usefulness of inspecting connected components for
    this graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way around that! As I mentioned previously, if we remove a few critically
    important nodes from a network, that network tends to shatter into pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remove five very important characters from the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In these two lines, we built a second graph called `G_copy`, and then we removed
    five key nodes. Let’s visualize the network again!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Shattered Les Miserables network](img/B17105_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Shattered Les Miserables network
  prefs: []
  type: TYPE_NORMAL
- en: Great. That’s much closer to how many real-world networks look. There’s still
    one primary connected component (continent), there are three smaller connected
    components (islands), and there are six isolate nodes. Calling these islands and
    continents is my own thing. There is no threshold for deciding that an island
    is a continent. It is just that most networks contain one super-component (continent),
    lots and lots of isolate nodes, and several connected components (islands). This
    helps me, but do with it what you like.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to keep in mind is that what we just did could be used as a
    step in community detection. Removing a few key nodes can break a network apart,
    pulling out the smaller communities that exist. Those critically important nodes
    held one or more communities together as part of the larger structure. Removing
    the important nodes allowed the communities to drift apart. We did this by removing
    important nodes, which is not usually ideal. However, other actual approaches
    to community detection work similarly, by removing edges rather than nodes.
  prefs: []
  type: TYPE_NORMAL
- en: How many connected components are left after shattering the network?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: NetworkX says that there are `10`, but isolates are not connected to anything
    other than possibly themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remove them before looking into connected components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It looks like there are four connected components.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are so few of them, let’s inspect each one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Component 0 subgraph of the shattered Les Miserables network](img/B17105_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Component 0 subgraph of the shattered Les Miserables network
  prefs: []
  type: TYPE_NORMAL
- en: Very interesting! The first connected component is almost a star network, with
    all nodes connecting to one central character, **Myriel**. However, if you look
    at the top left, you should see that two characters also share a link. That relationship
    could be worth investigating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the next component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Component 1 subgraph of the shattered Les Miserables network](img/B17105_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Component 1 subgraph of the shattered Les Miserables network
  prefs: []
  type: TYPE_NORMAL
- en: This is even more interesting. This is what I am calling the primary component.
    It’s the largest connected component in the shattered network. However, as I said,
    connected components are not ideal for identifying communities. Look slightly
    left of the center in the network – we should see two clusters of nodes, two separate
    communities. There’s also at least one other community on the right. If two edges
    or nodes were removed, the community on the right would split off from the network.
    Onward!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s keep shattering the community:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Component 2 subgraph of the shattered Les Miserables network](img/B17105_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Component 2 subgraph of the shattered Les Miserables network
  prefs: []
  type: TYPE_NORMAL
- en: This is a strongly connected component. Each node has a connection to the other
    nodes in this network. If one node were removed, this network would remain intact.
    From a network perspective, each node is as important or central as each other
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the final component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Component 3 subgraph of the shattered Les Miserables network](img/B17105_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Component 3 subgraph of the shattered Les Miserables network
  prefs: []
  type: TYPE_NORMAL
- en: This is another densely connected network. Each node is equally important or
    central. If one node were to be removed, this network would remain intact.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we were able to find three communities by looking at the connected
    components, but connected components did not draw out the communities that exist
    in the larger primary component. If we wanted to draw those out, we’d have to
    remove other important nodes and then repeat our analysis. Throwing away nodes
    is one way to lose information, so I do not recommend that approach, but it can
    be useful for quick ad hoc analysis.
  prefs: []
  type: TYPE_NORMAL
- en: I do not consider investigating connected components to be community detection,
    but communities can be found while investigating connected components. I consider
    this one of the first steps that should be done during any network analysis, and
    the insights gained are valuable, but it’s not sensitive enough for community
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: If your network contained no super-cluster of a connected component, then connected
    components would be pretty adequate for community detection. However, you would
    have to treat the super-cluster as one community, and in reality, the cluster
    contains many communities. The connected component approach becomes less useful
    with larger networks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to more suitable methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Louvain method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Louvain method** is certainly my favorite for community detection, for
    a few reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, this algorithm can be used on very large networks of millions of nodes
    and it will be effective and fast. Other approaches that we will explore in this
    chapter will not work on large networks and will not be as fast, so we get effectiveness
    and speed with this algorithm that we can’t find anywhere else. As such, it is
    my go-to algorithm for community detection, and I save the others as options to
    consider.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it is possible to tune the `resolution` parameter to find the best partitions
    for community detection, giving flexibility when the default results are not optimal.
    With the other algorithms, you do not have this flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, with the Louvain method, we have a fast algorithm that is effective
    at community detection in massive networks, and we can optimize the algorithm
    for better results. I recommend dabbling in community detection by starting with
    the Louvain method, and then picking up these other approaches as you learn. It’s
    good to know that there are options.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creators of the Louvain method were able to use their algorithm on a network
    of hundreds of millions of nodes and more than a billion edges, making this approach
    suitable for very large networks. You can read more about the Louvain method at
    [https://arxiv.org/pdf/0803.0476.pdf](https://arxiv.org/pdf/0803.0476.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works through a series of passes, where each pass contains two
    phases. The first phase assigns different communities to each node in the network.
    Initially, each node has a different community assigned to it. Then, each neighbor
    is evaluated and nodes are assigned to communities. The first step concludes when
    no more improvements can be made. In the second phase, a new network is built,
    with nodes being the communities discovered in the first step. Then, the results
    of the first phase can be repeated. The two steps are iterated until optimal communities
    are found.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simplified description of how the algorithm works. I recommend reading
    the research paper in its entirety to get a feel for how the algorithm works.
  prefs: []
  type: TYPE_NORMAL
- en: The Louvain method in action!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used the Louvain method briefly in [*Chapter 3*](B17105_03.xhtml#_idTextAnchor080),
    so if you paid attention, this code should look familiar. The Louvain method has
    been included in more recent versions of NetworkX, so if you have the latest version
    of NetworkX, you will not need to use the `community` Python library, but your
    code will be different. For consistency, I will use the “community” library approach:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s import the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is some code that will help us draw Louvain partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s use the `best_partition` function to identify the optimal partition
    using the Louvain method. During my testing, I found `resolution=1` to be ideal,
    but with other networks, you should experiment with this parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates a visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Louvain method community detection of the Les Miserables network](img/B17105_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Louvain method community detection of the Les Miserables network
  prefs: []
  type: TYPE_NORMAL
- en: The helper function in *step 2* will color nodes by the communities that they
    belong to. What is important is that the separate communities have been detected,
    and each community of nodes is identified with a different color. Each node belongs
    to a different partition, and those partitions are the communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what is inside the `partition` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To save space, I cut out some of the nodes and partitions. Each node has an
    associated partition number, and that’s the community that it belongs to. If you
    wanted to get a list of nodes that belong to an individual community, you could
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: So, why is this exciting? What’s so cool about the Louvain method? Well, for
    one thing, it can scale to massive networks, allowing for research into the largest
    networks, such as the internet. Second, it’s fast, which means it is practical.
    There is not a lot of point to an algorithm that is so slow as to only be useful
    on tiny networks. Louvain is practical with massive networks. This algorithm is
    fast and efficient, and the results are very good. This is one algorithm for community
    detection that you will want in your tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at label propagation as another option for community detection.
  prefs: []
  type: TYPE_NORMAL
- en: Using label propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Label propagation is another fast approach for identifying communities that
    exist in a network. In my experience, the results haven’t been as good as with
    the Louvain method, but this is another tool that can be explored as part of community
    detection. You can read about label propagation at [https://arxiv.org/pdf/0709.2938.pdf](https://arxiv.org/pdf/0709.2938.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an iterative approach. Each node is initialized with a unique label,
    and during each iteration of the algorithm, each node adopts the label that most
    of its neighbors have. For instance, if the **David** node had seven neighbor
    nodes, and four out of seven neighbors were **label 1** with the other three were
    **label 0**, then the **David** node would pick up **label 1**. During each step
    of the process, each node picks up the majority label, and the process concludes
    by grouping nodes with the same labels together as communities.
  prefs: []
  type: TYPE_NORMAL
- en: Label propagation in action!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This algorithm can be imported directly from NetworkX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have imported the algorithm, all you have to do is pass it to your
    graph, and you will get back a list of communities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this out using our Les Miserables graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line passes our graph to the label propagation algorithm and writes the
    results to a `community` variable. On a network this small, this algorithm is
    zippy-fast, taking a fraction of a second to identify communities. I prefer to
    convert these results into a list, to extract the community nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do just that, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In that last line, we inspected the first community, community 0\. Visualizing
    these communities is simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract them as subgraphs and then use the same `draw_graph` function
    we have used throughout this book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What can we see from the output?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Label propagation community detection of the Les Miserables
    network, community 1](img/B17105_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Label propagation community detection of the Les Miserables network,
    community 1
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty good, but not quite as good as the results from the Louvain
    method. It was fast but not quite as precise as I’d wanted. For instance, looking
    to the left of **Valjean**, there is a tight community of densely connected nodes.
    That should be its own community, not part of this larger group. This algorithm
    isn’t perfect, but no algorithm is. However, this algorithm is fast and can scale
    to large networks, so it is another option for large-scale community detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a couple more communities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Label propagation community detection of the Les Miserables
    network, community 2](img/B17105_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Label propagation community detection of the Les Miserables network,
    community 2
  prefs: []
  type: TYPE_NORMAL
- en: This community looks about perfect. It’s not uncommon to have a few additional
    nodes other than those found in the most densely connected parts of a community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Label propagation community detection of the Les Miserables
    network, community 3](img/B17105_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Label propagation community detection of the Les Miserables network,
    community 3
  prefs: []
  type: TYPE_NORMAL
- en: This community looks great as well. Overall, this algorithm works well and is
    fast. Also, the setup is easier and faster than with the Louvain method, as all
    you have to do is import the algorithm, pass it a graph, and then visualize the
    results. In terms of ease of use, this algorithm is the easiest that I’ve seen.
    The results look good, and communities have quickly been identified.
  prefs: []
  type: TYPE_NORMAL
- en: But being fast and easy to use is not enough. Louvain is more accurate and is
    fast and easy to use. Still, this can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Girvan-Newman algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we noticed that the *Les Miserables* network
    consisted of a single large connected component and that there were no isolates
    or smaller “islands” of communities apart from the large connected component.
    To show how connected components could be useful for identifying communities,
    we shattered the network by removing a few key nodes.
  prefs: []
  type: TYPE_NORMAL
- en: That approach is not typically ideal. While there is information in both nodes
    (people, places, things) and edges (relationships), in my experience, it is typically
    preferable to throw away edges than to throw away nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach than what we did previously would be to identify the least
    number of edges that could be cut that would result in a split network. We could
    do this by looking for the edges that the greatest number of shortest paths pass
    through – that is, the edges with the highest `edge_betweenness_centrality`.
  prefs: []
  type: TYPE_NORMAL
- en: That is precisely what the **Girvan-Newman** **algorithm** does.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Girvan-Newman algorithm identifies communities by cutting the least number
    of edges possible, which results in splitting a network into two pieces. You can
    read more about their approach here: [https://www.pnas.org/doi/full/10.1073/pnas.122653799](https://www.pnas.org/doi/full/10.1073/pnas.122653799).'
  prefs: []
  type: TYPE_NORMAL
- en: Many times, when I’m looking at networks, I see several nodes on two different
    sides connected by a few edges. It almost looks like a few rubber bands are holding
    the two groups together. If you snip the rubber bands, the two communities should
    fly apart, similar to how networks shatter into pieces when key nodes are removed.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, this is more surgically precise than removing nodes. There is less
    loss of valuable information. Sure, losing information on certain relationships
    is a drawback, but all of the nodes remain intact.
  prefs: []
  type: TYPE_NORMAL
- en: Through a series of iterations, the Girvan-Newman algorithm identifies edges
    with the highest `edge_betweenness_centrality` scores and removes them, splitting
    a network into two pieces. Then, the process begins again. If not repeated enough,
    communities are too large. If repeated too many times, communities end up being
    a single node. So, there will be some experimentation when using this algorithm
    to find the ideal number of cuts.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is all about cutting. The downside of this algorithm is that
    it is not fast. Calculating `edge_betweenness_centrality` is much more computationally
    expensive than the computations being done for the Louvain method or label propagation.
    As a result, this algorithm ceases to be useful very quickly, as it becomes much
    too slow to be practical.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your network is small enough, this is a very cool algorithm to explore
    for community detection. It’s also intuitive and easy to explain to others.
  prefs: []
  type: TYPE_NORMAL
- en: Girvan-Newman algorithm in action!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s try this out with our *Les Miserables* graph. The graph is small enough
    that this algorithm should be able to split it into communities pretty quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to pass the graph to the algorithm as a parameter. When we do
    this, the algorithm will return the results of each iteration of splits, which
    we can investigate by converting the results into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What was the maximum number of iterations that the algorithm could do before
    each community consisted of a single node? Let’s see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Neat! We have `76` iterations of splits kept in a Python list. I recommend that
    you investigate the various levels of splits and find the one that looks best
    for your needs. It could be very early in the process, in the first 10 splits,
    or it might be a bit later. This part requires some analysis, further making this
    a bit of a hands-on algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, just to push forward, let’s pretend that we found that the tenth iteration
    of splits yielded the best results. Let’s set the tenth iteration results as our
    final group of communities, and then visualize the communities as we did with
    the Louvain method and label propagation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re keeping the tenth iteration results and dropping everything else. If we
    didn’t want to throw away the results, we could have used a different variable
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what these communities look like so that we can compare them against
    the other algorithms we discussed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Girvan-Newman community detection of the Les Miserables network,
    community 0](img/B17105_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Girvan-Newman community detection of the Les Miserables network,
    community 0
  prefs: []
  type: TYPE_NORMAL
- en: This subgraph should look familiar! We saw exactly this when we shattered the
    network by nodes and then visualized connected components. This algorithm split
    the network using edges and managed to find the same community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see another community:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This produces the following network visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Girvan-Newman community detection of the Les Miserables network,
    community 1](img/B17105_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Girvan-Newman community detection of the Les Miserables network,
    community 1
  prefs: []
  type: TYPE_NORMAL
- en: This also looks very good. It’s not uncommon for communities to have a densely
    connected group, as well as some less connected nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'And another community:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Girvan-Newman community detection of the Les Miserables network,
    community 2](img/B17105_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Girvan-Newman community detection of the Les Miserables network,
    community 2
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the last community. We have a densely connected group of
    nodes and two nodes with a single edge. This looks great.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see community 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Community 3 looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Girvan-Newman community detection of the Les Miserables network,
    community 3](img/B17105_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Girvan-Newman community detection of the Les Miserables network,
    community 3
  prefs: []
  type: TYPE_NORMAL
- en: This should look familiar as well. Label propagation found the same community
    but Girvan-Newman removed one additional node.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the next one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see the following network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Girvan-Newman community detection of the Les Miserables network,
    community 4](img/B17105_09_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Girvan-Newman community detection of the Les Miserables network,
    community 4
  prefs: []
  type: TYPE_NORMAL
- en: While this may be less visually appealing to look at, this impresses me more
    than the other network visualizations. This is a less obvious community, found
    only by cutting edges with the highest `edge_betweenness_centrality` scores. There
    is a slightly more connected group of nodes in the center, surrounded by nodes
    with a single edge each on the outskirts.
  prefs: []
  type: TYPE_NORMAL
- en: The Girvan-Newman algorithm can give really good and clean results. The only
    downside is its speed. Calculating `edge_betweenness_centrality` and shortest_paths
    is time-consuming, so this algorithm is much slower than the others that we discussed,
    but it can be very useful if your network is not too large.
  prefs: []
  type: TYPE_NORMAL
- en: Other approaches to community detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of these algorithms that we have explored were ideas that people had on
    how to identify communities in networks, either based on nearness to other nodes
    or found by cutting edges. However, these are not the only approaches. I came
    up with an approach before learning about the Girvan-Newman algorithm that cut
    nodes rather than edges. However, when I learned about the Girvan-Newman approach,
    I found that to be more ideal and gave up on my implementation. But that makes
    me think, what other approaches might there be for identifying communities in
    networks?
  prefs: []
  type: TYPE_NORMAL
- en: As you learn more and become more comfortable working with networks, try to
    discover other ways of identifying communities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through several different approaches to community detection.
    Each had its pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that connected components can be useful for identifying communities,
    but only if the network consists of more than just one single primary component.
    To use connected components to identify communities, there need to be some smaller
    connected components split off. It’s very important to use connected components
    at the beginning of your network analysis to get an understanding of the overall
    structure of your network, but it is less than ideal as a standalone tool for
    identifying communities.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we used the Louvain method. This algorithm is extremely fast and can be
    useful in networks where there are hundreds of millions of nodes and billions
    of edges. If your network is very large, this is a useful first approach for community
    detection. The algorithm is fast, and the results are clean. There is also a parameter
    you can experiment with to get optimal partitions.
  prefs: []
  type: TYPE_NORMAL
- en: We then used label propagation to identify communities. On the *Les Miserables*
    network, the algorithm took a fraction of a second to identify communities. Overall,
    the results looked good, but it did seem to struggle with splitting out a dense
    cluster of nodes from a larger community. However, every other community looked
    good. This algorithm is fast and should scale to large networks, but I have never
    heard of this being used on a network with millions of nodes. It is worth experimenting
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the Girvan-Newman algorithm, which is an algorithm that finds
    communities by performing several rounds of cuts on edges with the highest `edge_betweenness_centrality`
    scores. The results were very clean. The downside of this algorithm is that it
    is very slow and does not scale well to large networks. However, if your network
    is small, then this is a very useful algorithm for community detection.
  prefs: []
  type: TYPE_NORMAL
- en: This has been a fun chapter to write. Community detection is one of the most
    interesting areas of network analysis, for me. It’s one thing to analyze networks
    as a whole or explore ego networks, but being able to identify and extract communities
    is another skill that sits somewhere between whole network analysis and egocentric
    network analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we’re going to go into the wilderness and explore
    how we can use network science and machine learning together! The first chapter
    will be on supervised machine learning, while the final chapter will be on unsupervised
    machine learning. We only have a few more chapters to go! Hang in there!
  prefs: []
  type: TYPE_NORMAL
