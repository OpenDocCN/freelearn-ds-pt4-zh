<html><head></head><body>
<div id="_idContainer020" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-44"><a id="_idTextAnchor086" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor087" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-45" class="calibre6"><a id="_idTextAnchor088" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.2.1">The Five Steps of Data Science</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">This chapter will dive into the five core steps involved in the data science process, with examples every step of the way. </span><span class="kobospan" id="kobo.3.2">These five steps include defining a real problem, collecting and preprocessing the data, exploring and analyzing the data, drawing conclusions, and communicating </span><span><span class="kobospan" id="kobo.4.1">results effectively.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">We will also delve into the important topics of data exploration and data visualization. </span><span class="kobospan" id="kobo.5.2">Data exploration involves examining the characteristics and patterns in your data to better understand it, while data visualization involves using graphs, charts, and other visual aids to represent and communicate your data </span><span><span class="kobospan" id="kobo.6.1">and findings.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">By the end of this chapter, you will have a solid understanding of the data science process and how to apply it to solve real-world problems. </span><span class="kobospan" id="kobo.7.2">So, let’s </span><span><span class="kobospan" id="kobo.8.1">get started!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">We will also cover the following topics in </span><span><span class="kobospan" id="kobo.10.1">this chapter:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.11.1">An introduction to what data science </span><span><span class="kobospan" id="kobo.12.1">really is</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.13.1">Exploring </span><span><span class="kobospan" id="kobo.14.1">data effectively</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.15.1">Exploration tips for all levels </span><span><span class="kobospan" id="kobo.16.1">of data</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.17.1">Using </span><strong class="source-inline1"><span class="kobospan" id="kobo.18.1">pandas</span></strong><span class="kobospan" id="kobo.19.1"> to manipulate and </span><span><span class="kobospan" id="kobo.20.1">optimize data</span></span></li>
</ul>
<h1 id="_idParaDest-46" class="calibre6"><a id="_idTextAnchor089" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.21.1">Introduction to data science</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.22.1">A question I’ve gotten </span><a id="_idIndexMarker109" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.23.1">at least once a month for the past decade is </span><em class="italic"><span class="kobospan" id="kobo.24.1">What’s the difference between data science and data analytics?</span></em><span class="kobospan" id="kobo.25.1"> One could argue that there is no difference between the two; others will argue that there are hundreds of differences! </span><span class="kobospan" id="kobo.25.2">I believe that, regardless of how many differences there are between the two terms, the </span><span><span class="kobospan" id="kobo.26.1">following applies:</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.27.1">Data science follows a structured, step-by-step process that, when followed, preserves the integrity of the results and leads to a deeper understanding of the data and the environment the data </span></em><span><em class="italic"><span class="kobospan" id="kobo.28.1">comes from.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.29.1">As with any other scientific endeavor, this process must be adhered to, or else the analysis and the results are in danger of scrutiny. </span><span class="kobospan" id="kobo.29.2">On a simpler level, following a strict process can make it much easier for any data scientist, hobbyist, or professional to obtain results faster than if they were exploring data with no </span><span><span class="kobospan" id="kobo.30.1">clear vision.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">While these steps are a guiding lesson for amateur analysts, they also provide the foundation for all data scientists, even those in the highest levels of business and academia. </span><span class="kobospan" id="kobo.31.2">Every data</span><a id="_idIndexMarker110" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.32.1"> scientist recognizes the value of these steps and follows them in some way </span><span><span class="kobospan" id="kobo.33.1">or another.</span></span></p>
<h2 id="_idParaDest-47" class="calibre7"><a id="_idTextAnchor090" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.34.1">Overview of the five steps</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">The process of data </span><a id="_idIndexMarker111" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.36.1">science involves a series of steps that are essential for effectively extracting insights and knowledge from data. </span><span class="kobospan" id="kobo.36.2">These steps are presented </span><span><span class="kobospan" id="kobo.37.1">as follows:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.38.1">Asking an interesting question</span></strong><span class="kobospan" id="kobo.39.1">: The first step in any data science project is to identify a question or challenge that you want to address with your analysis. </span><span class="kobospan" id="kobo.39.2">This involves finding a topic that is relevant, important, and that can be addressed </span><span><span class="kobospan" id="kobo.40.1">with data.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.41.1">Obtaining the data</span></strong><span class="kobospan" id="kobo.42.1">: Once you have identified your question, the next step is to collect the data that you will need to answer it. </span><span class="kobospan" id="kobo.42.2">This can involve sourcing data from a variety of sources, such as databases, online platforms, or through data scraping or data </span><span><span class="kobospan" id="kobo.43.1">collection methods.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.44.1">Exploring the data</span></strong><span class="kobospan" id="kobo.45.1">: After you have collected your data, the next step is to explore it and get a better understanding of its characteristics and patterns. </span><span class="kobospan" id="kobo.45.2">This might involve examining summary statistics, visualizing the data, or applying </span><a id="_idIndexMarker112" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.46.1">statistical or </span><strong class="bold"><span class="kobospan" id="kobo.47.1">machine learning</span></strong><span class="kobospan" id="kobo.48.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.49.1">ML</span></strong><span class="kobospan" id="kobo.50.1">) techniques to identify trends </span><span><span class="kobospan" id="kobo.51.1">or relationships.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.52.1">Modeling the data</span></strong><span class="kobospan" id="kobo.53.1">: Once you have explored your data, the next step is to build models that can be used to make predictions or inform decision-making. </span><span class="kobospan" id="kobo.53.2">This might involve applying ML algorithms, building statistical models, or using other techniques to find patterns in </span><span><span class="kobospan" id="kobo.54.1">the data.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.55.1">Communicating and visualizing the results</span></strong><span class="kobospan" id="kobo.56.1">: Finally, it’s important to communicate your findings to others in a clear and effective way. </span><span class="kobospan" id="kobo.56.2">This might involve creating reports, presentations, or visualizations that help to explain your results and </span><span><span class="kobospan" id="kobo.57.1">their implications.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">By following these five essential steps, you can effectively use data science to solve real-world problems and extract valuable insights </span><span><span class="kobospan" id="kobo.59.1">from data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.60.1">It’s important to note that different data scientists may have different approaches to the data science process, and the steps outlined previously are just one way of organizing the process. </span><span class="kobospan" id="kobo.60.2">Some data scientists might group the steps differently or include additional steps such as feature engineering or </span><span><span class="kobospan" id="kobo.61.1">model evaluation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.62.1">Despite these differences, most data scientists agree that the steps listed previously are essential to the data science process. </span><span class="kobospan" id="kobo.62.2">Whether they are organized in this specific way or not, these</span><a id="_idIndexMarker113" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.63.1"> steps are all crucial for effectively using data to solve problems and extract valuable insights. </span><span class="kobospan" id="kobo.63.2">Let’s dive into these steps one </span><span><span class="kobospan" id="kobo.64.1">by one.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.65.1">Asking an interesting question</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.66.1">This is probably my</span><a id="_idIndexMarker114" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.67.1"> favorite step. </span><span class="kobospan" id="kobo.67.2">Asking an interesting and relevant question is the first and perhaps most important step in the data science process. </span><span class="kobospan" id="kobo.67.3">It sets the direction and focus of your analysis and determines the data and resources that you will need to collect </span><span><span class="kobospan" id="kobo.68.1">and analyze.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.69.1">As an entrepreneur, you are likely accustomed to constantly asking questions and seeking answers. </span><span class="kobospan" id="kobo.69.2">This step can be approached like a brainstorming session, where you write down questions and ideas regardless of whether or not you think data exists to answer them. </span><span class="kobospan" id="kobo.69.3">This helps to avoid bias and allows you to consider a wide range </span><span><span class="kobospan" id="kobo.70.1">of possibilities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.71.1">It’s important to be specific and narrow in your focus when asking your question. </span><span class="kobospan" id="kobo.71.2">This will help you to effectively address the problem and extract valuable insights from your data. </span><span class="kobospan" id="kobo.71.3">It’s also important to consider the scope and feasibility of your question, as well as the resources and data that you will need to </span><span><span class="kobospan" id="kobo.72.1">answer it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">By asking an interesting and relevant question, you can set the foundation for a successful data science project and begin the journey of extracting valuable insights </span><span><span class="kobospan" id="kobo.74.1">from </span><a id="_idTextAnchor091" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor092" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor093" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.75.1">data.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.76.1">Obtaining the data</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.77.1">Obtaining the data is </span><a id="_idIndexMarker115" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.78.1">a crucial step in the data science process. </span><span class="kobospan" id="kobo.78.2">It involves sourcing and collecting the data that you will need to answer the question or solve the problem you have identified. </span><span class="kobospan" id="kobo.78.3">The data can come from a variety of sources, including databases, online platforms, research studies, or data scraping or data </span><span><span class="kobospan" id="kobo.79.1">collection methods.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.80.1">This step can be very creative as you will need to think creatively about where to find the data that is most relevant to your question. </span><span class="kobospan" id="kobo.80.2">You may need to explore different sources and platforms, and you may need to use a variety of data collection methods to gather the data </span><span><span class="kobospan" id="kobo.81.1">you need.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.82.1">It’s important to be mindful of the quality of the data you are collecting, as well as any potential biases or limitations that may be present in the data. </span><span class="kobospan" id="kobo.82.2">It’s also important to consider ethical and legal considerations, such as obtaining proper consent and protecting sensitive or </span><span><span class="kobospan" id="kobo.83.1">confidential data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">Once you have collected your data, it’s essential to clean and preprocess it so that it is in a usable format. </span><span class="kobospan" id="kobo.84.2">This can involve removing missing or inaccurate data, formatting the data in a way that makes it easier to work with, and ensuring that the data is consistent </span><span><span class="kobospan" id="kobo.85.1">and accurate.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.86.1">By effectively collecting and preprocessing your data, you can set the stage for a successful data science project and be well prepared to move on to the next steps of exploring and analyzing </span><span><span class="kobospan" id="kobo.87.1">the</span><a id="_idTextAnchor094" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.88.1"> data.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.89.1">Exploring the data</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">Exploring the data is </span><a id="_idIndexMarker116" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.91.1">an essential step in the data science process as it involves examining the characteristics and patterns in your data to gain a better understanding of it. </span><span class="kobospan" id="kobo.91.2">This step is crucial for identifying trends, relationships, and insights that can inform your analysis and answer your </span><span><span class="kobospan" id="kobo.92.1">research question.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.93.1">There are many different ways to explore data, including visualizing it using graphs, charts, and plots, as well as applying statistical and ML techniques to identify patterns and relationships. </span><span class="kobospan" id="kobo.93.2">It’s important to be mindful of the types of data you are working with, as different types of data may require different approaches </span><span><span class="kobospan" id="kobo.94.1">to exploration.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">This step can be time-consuming as it may involve spending several hours learning about the domain and using code or other tools to manipulate and explore the data. </span><span class="kobospan" id="kobo.95.2">By the time this step is completed, the analyst should have a good understanding of the potential insights that the data might contain and be able to form hypotheses about what the data might be trying to </span><span><span class="kobospan" id="kobo.96.1">tell them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.97.1">Exploring the data is a crucial step in the data science process as it helps to inform the direction of your analysis and guide your choice of modeling and analysis techniques. </span><span class="kobospan" id="kobo.97.2">It’s important</span><a id="_idIndexMarker117" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.98.1"> to be thorough and meticulous in this step as the insights you gain can have significant implications for your results </span><span><span class="kobospan" id="kobo.99.1">and conclusions.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.100.1">Modeling the data</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">Modeling the data is an</span><a id="_idIndexMarker118" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.102.1"> important step in the data science process as it involves using statistical and ML techniques to build models that can be used to make predictions or inform decision-making. </span><span class="kobospan" id="kobo.102.2">This step can be complex as it involves fitting and choosing the appropriate models for your data and objectives, as well as implementing mathematical validation metrics to quantify the effectiveness of </span><span><span class="kobospan" id="kobo.103.1">the models.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.104.1">Many different types of models can be used in data science, including linear regression models, logistic regression models, decision tree models, and </span><strong class="bold"><span class="kobospan" id="kobo.105.1">neural network</span></strong><span class="kobospan" id="kobo.106.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.107.1">NN</span></strong><span class="kobospan" id="kobo.108.1">) models, to</span><a id="_idIndexMarker119" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.109.1"> name a few. </span><span class="kobospan" id="kobo.109.2">It’s important to choose the model that is most appropriate for your data and the question you are trying </span><span><span class="kobospan" id="kobo.110.1">to answer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.111.1">Once you have chosen your model, you will need to fit it to your data. </span><span class="kobospan" id="kobo.111.2">This involves using statistical or ML algorithms to find the parameters that best fit the patterns in your data. </span><span class="kobospan" id="kobo.111.3">You will also need to evaluate the performance of your model using validation metrics such as accuracy, precision, and recall. </span><span class="kobospan" id="kobo.111.4">These metrics can help you to understand the effectiveness of your model and identify any areas </span><span><span class="kobospan" id="kobo.112.1">for improvement.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">By effectively modeling your data, you can gain insights and make informed decisions based on your analysis. </span><span class="kobospan" id="kobo.113.2">It’s important to carefully consider the choices you make at this step, as the quality of your model can greatly affect the accuracy and usefulness of </span><span><span class="kobospan" id="kobo.114.1">you</span><a id="_idTextAnchor095" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor096" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.115.1">r results.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.116.1">Communicating and visualizing the results</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">This is arguably </span><a id="_idIndexMarker120" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.118.1">the most important step. </span><span class="kobospan" id="kobo.118.2">Communicating and visualizing results involves effectively sharing your findings and insights with others. </span><span class="kobospan" id="kobo.118.3">This step can be challenging as it requires you to clearly and concisely convey your results in a way that is understandable and digestible to </span><span><span class="kobospan" id="kobo.119.1">your audience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">There are many different ways to communicate and visualize your results, including creating reports, presentations, and visualizations such as graphs, charts, and plots. </span><span class="kobospan" id="kobo.120.2">It’s important to choose the method that is most appropriate for your audience and the message you are trying </span><span><span class="kobospan" id="kobo.121.1">to convey.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.122.1">It’s also important to consider the impact of your results and the implications of your findings. </span><span class="kobospan" id="kobo.122.2">This can involve discussing the limitations of your analysis, the implications of your results, and any recommendations or next steps that may </span><span><span class="kobospan" id="kobo.123.1">be warranted.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.124.1">In this book, we will focus mainly on </span><em class="italic"><span class="kobospan" id="kobo.125.1">steps 3</span></em><span class="kobospan" id="kobo.126.1">, </span><em class="italic"><span class="kobospan" id="kobo.127.1">4</span></em><span class="kobospan" id="kobo.128.1">, and </span><em class="italic"><span class="kobospan" id="kobo.129.1">5</span></em><span class="kobospan" id="kobo.130.1"> of the data science process, which involve exploring and analyzing the data, modeling the data, and communicating and visualizing the results. </span><span class="kobospan" id="kobo.130.2">While the first two steps of asking an interesting question and obtaining the data are also essential to the process, we will only touch upon these steps briefly and focus mainly on the more scientific aspects of the process. </span><span class="kobospan" id="kobo.130.3">By focusing on these steps, we aim to provide interesting questions and datasets that can be used to explore and </span><span><span class="kobospan" id="kobo.131.1">analyze data.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.132.1">Why are we skipping steps 1 and 2 in this book?</span></p>
<p class="callout"><span class="kobospan" id="kobo.133.1">While the first two steps are undoubtedly imperative to the process, they generally precede statistical and programmatic systems. </span><span class="kobospan" id="kobo.133.2">Later in this book, we will touch upon the different ways to obtain data; however, to focus on the more scientific aspects of the process, we will begin with exploration </span><span><span class="kobospan" id="kobo.134.1">right away.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.135.1">Let’s focus on the third step a bit more – exploring</span><a id="_idTextAnchor097" class="pcalibre calibre4 pcalibre1"/> <span><span class="kobospan" id="kobo.136.1">our data.</span></span></p>
<h1 id="_idParaDest-48" class="calibre6"><a id="_idTextAnchor098" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.137.1">Exploring the data</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">The process of</span><a id="_idIndexMarker121" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.139.1"> exploring data is not always straightforward and can involve a variety of approaches and techniques. </span><span class="kobospan" id="kobo.139.2">Some common tasks that are involved in data exploration include recognizing different types of data, transforming data types, and using code to systematically improve the quality of the entire dataset. </span><span class="kobospan" id="kobo.139.3">These tasks can be accomplished using tools such as the </span><strong class="source-inline"><span class="kobospan" id="kobo.140.1">pandas</span></strong><span class="kobospan" id="kobo.141.1"> Python package, which is commonly used for data manipulation </span><span><span class="kobospan" id="kobo.142.1">and analysis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.143.1">There are a few basic questions that you should consider when exploring a new dataset. </span><span class="kobospan" id="kobo.143.2">These questions can help you to get a sense of the data and guide your analysis. </span><span class="kobospan" id="kobo.143.3">The three basic questions are </span><span><span class="kobospan" id="kobo.144.1">presented here:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.145.1">What are the types of data that are present in </span><span><span class="kobospan" id="kobo.146.1">the dataset?</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.147.1">What are the characteristics and patterns of </span><span><span class="kobospan" id="kobo.148.1">the data?</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.149.1">How is the data organized, and what transformations might be necessary to make it </span><span><span class="kobospan" id="kobo.150.1">more usable?</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.151.1">By answering these </span><a id="_idIndexMarker122" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.152.1">questions and exploring your data thoroughly, you can gain a deeper understanding of the data and be well prepared to move on to the next steps of modeling and analyzi</span><a id="_idTextAnchor099" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.153.1">ng </span><span><span class="kobospan" id="kobo.154.1">the data.</span></span></p>
<h2 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor100" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.155.1">Guiding questions for data exploration</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.156.1">When given a new </span><a id="_idIndexMarker123" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.157.1">dataset, whether it is familiar to you or not, it is important to use the following questions as guidelines for your </span><span><span class="kobospan" id="kobo.158.1">preliminary analysis:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.159.1">Is the data structured or not?</span></strong><span class="kobospan" id="kobo.160.1">: We are checking whether or not the data is presented in a row/column structure. </span><span class="kobospan" id="kobo.160.2">For the most part, data will be presented in a structured fashion. </span><span class="kobospan" id="kobo.160.3">In this book, over 90% of our examples will begin with structured data. </span><span class="kobospan" id="kobo.160.4">Nevertheless, this is the most basic question that we can answer before diving any deeper into our analysis. </span><span class="kobospan" id="kobo.160.5">A general rule of thumb is that if we have unstructured data, we want to transform it into a row/column structure. </span><span class="kobospan" id="kobo.160.6">For example, earlier in this book, we looked at ways to transform text into a row/column structure by counting the number </span><span><span class="kobospan" id="kobo.161.1">of words/phrases.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.162.1">What does each row represent?</span></strong><span class="kobospan" id="kobo.163.1">: Once we have an answer to how the data is organized and are looking at a nice row/column-based dataset, we should identify what each row actually represents. </span><span class="kobospan" id="kobo.163.2">This step is usually very quick and can help put things into perspective much </span><span><span class="kobospan" id="kobo.164.1">more quickly.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.165.1">What does each column represent?</span></strong><span class="kobospan" id="kobo.166.1">: We should identify each column by the level of data, whether or not it is quantitative/qualitative, and so on. </span><span class="kobospan" id="kobo.166.2">This categorization might change as our analysis progresses, but it is important to begin this step as early </span><span><span class="kobospan" id="kobo.167.1">as possible.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.168.1">Are there any missing data points?</span></strong><span class="kobospan" id="kobo.169.1">: Data isn’t perfect. </span><span class="kobospan" id="kobo.169.2">Sometimes, we might be missing data because of human or mechanical error. </span><span class="kobospan" id="kobo.169.3">When this happens, we, as data scientists, must make decisions about how to deal with </span><span><span class="kobospan" id="kobo.170.1">these discrepancies.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.171.1">Do we need to perform any transformations on the columns?</span></strong><span class="kobospan" id="kobo.172.1">: Depending on the level/type of data in each column, we might need to perform certain types of transformation. </span><span class="kobospan" id="kobo.172.2">For example, generally speaking, for the sake of statistical modeling and ML, we would like each column to be numerical, so would </span><a id="_idIndexMarker124" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.173.1">use Python to make </span><span><span class="kobospan" id="kobo.174.1">any transformations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.175.1">All the while, we are asking ourselves the overall question </span><em class="italic"><span class="kobospan" id="kobo.176.1">What can we infer from the preliminary inferential statistics?</span></em><span class="kobospan" id="kobo.177.1"> We want to be able to understand our data better than when we first </span><span><span class="kobospan" id="kobo.178.1">found it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.179.1">Enough talk; let’s see a </span><span><span class="kobospan" id="kobo.180.1">han</span><a id="_idTextAnchor101" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.181.1">ds-on example.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.182.1">Dataset 1 – Yelp</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.183.1">The first </span><a id="_idIndexMarker125" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.184.1">dataset we </span><a id="_idIndexMarker126" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.185.1">will look at is a public dataset made available by the restaurant review site </span><em class="italic"><span class="kobospan" id="kobo.186.1">Yelp</span></em><span class="kobospan" id="kobo.187.1">. </span><span class="kobospan" id="kobo.187.2">All </span><strong class="bold"><span class="kobospan" id="kobo.188.1">personally identifiable information</span></strong><span class="kobospan" id="kobo.189.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.190.1">PII</span></strong><span class="kobospan" id="kobo.191.1">) has </span><a id="_idIndexMarker127" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.192.1">been removed. </span><span class="kobospan" id="kobo.192.2">I am purposefully not giving much information because part of our goal is to ascertain elements about this data for ourselves. </span><span class="kobospan" id="kobo.192.3">If I told you more, where would be the fun </span><span><span class="kobospan" id="kobo.193.1">in that?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.194.1">Let’s say we were just given this data. </span><span class="kobospan" id="kobo.194.2">The first thing we have to do is read it in, as </span><span><span class="kobospan" id="kobo.195.1">shown here:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.196.1">
import pandas as pd
yelp_raw_data = pd.read_csv("yelp.csv")
yelp_raw_data.head()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.197.1">Here’s a quick recap of what the preceding </span><span><span class="kobospan" id="kobo.198.1">code does:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.199.1">It imports the </span><strong class="source-inline1"><span class="kobospan" id="kobo.200.1">pandas</span></strong><span class="kobospan" id="kobo.201.1"> package and nicknames </span><span><span class="kobospan" id="kobo.202.1">it </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.203.1">pd</span></strong></span><span><span class="kobospan" id="kobo.204.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.205.1">It reads in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.206.1">.csv</span></strong><span class="kobospan" id="kobo.207.1"> file from the web and calls </span><span><span class="kobospan" id="kobo.208.1">it </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.209.1">yelp_raw_data/</span></strong></span><span><span class="kobospan" id="kobo.210.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.211.1">It looks at the head of the data (just the first </span><span><span class="kobospan" id="kobo.212.1">few rows).</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.213.1">We get the</span><a id="_idIndexMarker128" class="pcalibre calibre4 pcalibre1"/> <span><span class="kobospan" id="kobo.214.1">following</span></span><span><a id="_idIndexMarker129" class="pcalibre calibre4 pcalibre1"/></span><span><span class="kobospan" id="kobo.215.1"> output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer015">
<span class="kobospan" id="kobo.216.1"><img alt="Figure 3.1 – The first five rows (the head) of the pandas DataFrame of our Yelp dataset reveals a mix of data levels, including nominal (for example, text, business_id) and ordinal (cool, useful, and funny)" src="image/B19488_03_01.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.217.1">Figure 3.1 – The first five rows (the head) of the pandas DataFrame of our Yelp dataset reveals a mix of data levels, including nominal (for example, text, business_id) and ordinal (cool, useful, and funny)</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">From here, we can begin to ask some key questions. </span><span class="kobospan" id="kobo.218.2">Let’s start with this one: </span><em class="italic"><span class="kobospan" id="kobo.219.1">Is the data structured or not?</span></em><span class="kobospan" id="kobo.220.1"> Because we have a nice row/column structure, we can conclude that this data seems to </span><span><span class="kobospan" id="kobo.221.1">be structured.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.222.1">So, then, the next logical question would be </span><em class="italic"><span class="kobospan" id="kobo.223.1">What does each row represent?</span></em><span class="kobospan" id="kobo.224.1"> It seems pretty obvious that each row represents a user giving a review of a business. </span><span class="kobospan" id="kobo.224.2">The next thing we should do is examine each row and label it by the type of data it contains. </span><span class="kobospan" id="kobo.224.3">At this point, we can also use Python to figure out just how big our dataset is. </span><span class="kobospan" id="kobo.224.4">We can use the shape quality of a DataFrame to find this out, </span><span><span class="kobospan" id="kobo.225.1">as shown:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.226.1">
yelp_raw_data.shape
# (10000,10)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.227.1">It tells us that this dataset has </span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">10000</span></strong><span class="kobospan" id="kobo.229.1"> rows and </span><strong class="source-inline"><span class="kobospan" id="kobo.230.1">10</span></strong><span class="kobospan" id="kobo.231.1"> columns. </span><span class="kobospan" id="kobo.231.2">Another way to say this is that this dataset has 10,000 observations and </span><span><span class="kobospan" id="kobo.232.1">10 characteristics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.233.1">OK—so, then, the next question: </span><em class="italic"><span class="kobospan" id="kobo.234.1">What does </span></em><span class="kobospan" id="kobo.235.1">each column represent? </span><span class="kobospan" id="kobo.235.2">(Note that we have 10 columns.) Let’s have a look at </span><span><span class="kobospan" id="kobo.236.1">the answers:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.237.1">business_id</span></strong><span class="kobospan" id="kobo.238.1">: This is likely to be a unique identifier for the business the review is for. </span><span class="kobospan" id="kobo.238.2">This would be at the </span><strong class="bold"><span class="kobospan" id="kobo.239.1">nominal level</span></strong><span class="kobospan" id="kobo.240.1"> because there is no natural order to </span><span><span class="kobospan" id="kobo.241.1">this identifier.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.242.1">date</span></strong><span class="kobospan" id="kobo.243.1">: This is probably the date on which the review was posted. </span><span class="kobospan" id="kobo.243.2">Note that it seems to be only specific to the day, month, and year. </span><span class="kobospan" id="kobo.243.3">Even though time is usually considered continuous, this column would likely be considered discrete and at the </span><strong class="bold"><span class="kobospan" id="kobo.244.1">ordinal level</span></strong><span class="kobospan" id="kobo.245.1"> because of the natural order that </span><span><span class="kobospan" id="kobo.246.1">dates have.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.247.1">review_id</span></strong><span class="kobospan" id="kobo.248.1">: This is likely to be a unique identifier for the review that each post represents. </span><span class="kobospan" id="kobo.248.2">This </span><a id="_idIndexMarker130" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.249.1">would</span><a id="_idIndexMarker131" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.250.1"> be at the nominal level because, again, there is no natural order to </span><span><span class="kobospan" id="kobo.251.1">this identifier.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.252.1">stars</span></strong><span class="kobospan" id="kobo.253.1">: From a quick look (don’t worry; we will perform some further analysis soon), we can see that this is an ordered column that represents what the reviewer gave the restaurant as a final score. </span><span class="kobospan" id="kobo.253.2">This is ordered and qualitative, so is at the </span><span><span class="kobospan" id="kobo.254.1">ordinal level.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.255.1">text</span></strong><span class="kobospan" id="kobo.256.1">: This is probably the raw text that each reviewer wrote. </span><span class="kobospan" id="kobo.256.2">As with most text, we place this at the </span><span><span class="kobospan" id="kobo.257.1">nominal level.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.258.1">type</span></strong><span class="kobospan" id="kobo.259.1">: In the first five rows, all we see is the word </span><strong class="source-inline1"><span class="kobospan" id="kobo.260.1">review</span></strong><span class="kobospan" id="kobo.261.1">. </span><span class="kobospan" id="kobo.261.2">This might be a column that identifies that each row is a review, implying that there might be another type of row other than a review. </span><span class="kobospan" id="kobo.261.3">We will take a look at this later. </span><span class="kobospan" id="kobo.261.4">We place this at the </span><span><span class="kobospan" id="kobo.262.1">nominal level.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">user_id</span></strong><span class="kobospan" id="kobo.264.1">: This is likely to be a unique identifier for the user who is writing the review. </span><span class="kobospan" id="kobo.264.2">Just as with the other unique identifiers, we place this data at the </span><span><span class="kobospan" id="kobo.265.1">nominal level.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.266.1">Our next question is </span><em class="italic"><span class="kobospan" id="kobo.267.1">Are there any missing data points?</span></em><span class="kobospan" id="kobo.268.1"> Perform an </span><strong class="source-inline"><span class="kobospan" id="kobo.269.1">isnull</span></strong><span class="kobospan" id="kobo.270.1"> operation. </span><span class="kobospan" id="kobo.270.2">For example, if your DataFrame is called </span><strong class="source-inline"><span class="kobospan" id="kobo.271.1">awesome_dataframe</span></strong><span class="kobospan" id="kobo.272.1">, then try the </span><strong class="source-inline"><span class="kobospan" id="kobo.273.1">awesome_dataframe.isnull().sum()</span></strong><span class="kobospan" id="kobo.274.1"> Python command, which will show the number of missing values in </span><span><span class="kobospan" id="kobo.275.1">each column.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.276.1">Our question after that would be </span><em class="italic"><span class="kobospan" id="kobo.277.1">Do we need to perform any transformations on the columns?</span></em><span class="kobospan" id="kobo.278.1"> At this point, we are looking for a few things. </span><span class="kobospan" id="kobo.278.2">For example, will we need to change the scale of some of the quantitative data, or do we need to create dummy variables for the qualitative variables? </span><span class="kobospan" id="kobo.278.3">As this dataset only has qualitative columns, we can</span><a id="_idIndexMarker132" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.279.1"> only </span><a id="_idIndexMarker133" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.280.1">focus on transformations at the ordinal and </span><span><span class="kobospan" id="kobo.281.1">nominal scales.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.282.1">Before starting, let’s go over some quick terminology for </span><strong class="source-inline"><span class="kobospan" id="kobo.283.1">pandas</span></strong><span class="kobospan" id="kobo.284.1">, the Python da</span><a id="_idTextAnchor102" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.285.1">ta </span><span><span class="kobospan" id="kobo.286.1">exploration module.</span></span></p>
<h2 id="_idParaDest-50" class="calibre7"><a id="_idTextAnchor103" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.287.1">DataFrames</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.288.1">When we read in a </span><a id="_idIndexMarker134" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.289.1">dataset, </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">pandas</span></strong><span class="kobospan" id="kobo.291.1"> creates a custom object </span><a id="_idIndexMarker135" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.292.1">called </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">DataFrame</span></strong><span class="kobospan" id="kobo.294.1">. </span><span class="kobospan" id="kobo.294.2">Think of this as the Python version of a spreadsheet (but way better). </span><span class="kobospan" id="kobo.294.3">In this case, the </span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">yelp_raw_data</span></strong><span class="kobospan" id="kobo.296.1"> variable is </span><span><span class="kobospan" id="kobo.297.1">a DataFrame.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.298.1">To check whether this is true in Python, type in the </span><span><span class="kobospan" id="kobo.299.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.300.1">
type(yelp_raw_data)
# pandas.core.frame.DataFrame</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.301.1">DataFrames are two-dimensional in nature, meaning that they are organized in a row/column structure just as spreadsheets are. </span><span class="kobospan" id="kobo.301.2">The main benefit of using DataFrames over, say, spreadsheet software is that a DataFrame can handle much larger data than most common spreadsheet software. </span><span class="kobospan" id="kobo.301.3">If you are familiar with the R language, you might recognize the word DataFrame. </span><span class="kobospan" id="kobo.301.4">This is because the name was actually borrowed from </span><span><span class="kobospan" id="kobo.302.1">the language!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.303.1">As most of the data that we will deal with is structured, DataFrames are likely to be the most used object in </span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">pandas</span></strong><span class="kobospan" id="kobo.305.1">, second on</span><a id="_idTextAnchor104" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.306.1">ly to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">Series</span></strong></span><span><span class="kobospan" id="kobo.308.1"> object.</span></span></p>
<h2 id="_idParaDest-51" class="calibre7"><a id="_idTextAnchor105" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.309.1">Series</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.310.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">Series</span></strong><span class="kobospan" id="kobo.312.1"> object is simply </span><a id="_idIndexMarker136" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.313.1">a DataFrame, but only with one </span><a id="_idIndexMarker137" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.314.1">dimension. </span><span class="kobospan" id="kobo.314.2">Essentially, it is a list of data points. </span><span class="kobospan" id="kobo.314.3">Each column of a DataFrame is considered to be a </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">Series</span></strong><span class="kobospan" id="kobo.316.1"> object. </span><span class="kobospan" id="kobo.316.2">Let’s check this—the first thing we need to do is grab a single column from our DataFrame; we generally use what is </span><a id="_idIndexMarker138" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.317.1">known as </span><strong class="bold"><span class="kobospan" id="kobo.318.1">bracket notation</span></strong><span class="kobospan" id="kobo.319.1">. </span><span class="kobospan" id="kobo.319.2">The following is </span><span><span class="kobospan" id="kobo.320.1">an example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.321.1">
yelp_raw_data['business_id'] # grabs a single column of the Dataframe</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">We will list the first and last few rows, </span><span><span class="kobospan" id="kobo.323.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.324.1">
9yKzy9PApeiPPOUJEtnvkg
ZRJwVLyzEJq1VAihDhYiow
6oRAC4uyJCsJl1X0WZpVSA
_1QQZuf4zZOyFCvXc0o6Vg
6ozycU1RpktNG2-1BroVtw
-yxfBYGB6SEqszmxJxd97A
6zp713qNhx8d9KCJJnrw1xA</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">Let’s use the </span><strong class="source-inline"><span class="kobospan" id="kobo.326.1">type</span></strong><span class="kobospan" id="kobo.327.1"> function to check that this column is a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.328.1">Series</span></strong></span><span><span class="kobospan" id="kobo.329.1"> object:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.330.1">
type(yelp_raw_data['business_id'])
# pandas.core.series.Series</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.331.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.332.1">pandas</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.333.1">Series</span></strong><span class="kobospan" id="kobo.334.1"> object will come up time and time again as it is a c</span><a id="_idTextAnchor106" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.335.1">ore component </span><span><span class="kobospan" id="kobo.336.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.337.1">DataFrame</span></strong></span><span><span class="kobospan" id="kobo.338.1">.</span></span></p>
<h2 id="_idParaDest-52" class="calibre7"><a id="_idTextAnchor107" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.339.1">Exploration tips for qualitative data</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.340.1">Using these two </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">pandas</span></strong><span class="kobospan" id="kobo.342.1"> objects, let’s </span><a id="_idIndexMarker139" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.343.1">start performing some preliminary data exploration. </span><span class="kobospan" id="kobo.343.2">For qualitative data, we will specifically look at the</span><a id="_idTextAnchor108" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.344.1"> nominal and </span><span><span class="kobospan" id="kobo.345.1">ordinal levels.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.346.1">Nominal-level columns</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.347.1">As we are at the </span><a id="_idIndexMarker140" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.348.1">nominal level, let’s recall that at this level, data is qualitative and is described purely by name. </span><span class="kobospan" id="kobo.348.2">In this dataset, this refers to </span><strong class="source-inline"><span class="kobospan" id="kobo.349.1">business_id</span></strong><span class="kobospan" id="kobo.350.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.351.1">review_id</span></strong><span class="kobospan" id="kobo.352.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.353.1">text</span></strong><span class="kobospan" id="kobo.354.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.355.1">type</span></strong><span class="kobospan" id="kobo.356.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">user_id</span></strong><span class="kobospan" id="kobo.358.1">. </span><span class="kobospan" id="kobo.358.2">Let’s use </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">pandas</span></strong><span class="kobospan" id="kobo.360.1"> in order to dive a bit deeper, as </span><span><span class="kobospan" id="kobo.361.1">shown here:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.362.1">
yelp_raw_data['business_id'].describe()
  # count
10000
  # unique
4174
  #
top
ntN85eu27C04nwyPa8IHtw
  #
freq
37</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.364.1">describe</span></strong><span class="kobospan" id="kobo.365.1"> function will give us some quick stats about the column whose name we enter into the quotation marks. </span><span class="kobospan" id="kobo.365.2">Note how </span><strong class="source-inline"><span class="kobospan" id="kobo.366.1">pandas</span></strong><span class="kobospan" id="kobo.367.1"> automatically recognized that </span><strong class="source-inline"><span class="kobospan" id="kobo.368.1">business_id</span></strong><span class="kobospan" id="kobo.369.1"> was a qualitative column and gave us stats that make sense. </span><span class="kobospan" id="kobo.369.2">When </span><strong class="source-inline"><span class="kobospan" id="kobo.370.1">describe</span></strong><span class="kobospan" id="kobo.371.1"> is called on a qualitative column, we will always get the following </span><span><span class="kobospan" id="kobo.372.1">four items:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.373.1">count</span></strong><span class="kobospan" id="kobo.374.1">: How many values are </span><span><span class="kobospan" id="kobo.375.1">filled in</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.376.1">unique</span></strong><span class="kobospan" id="kobo.377.1">: How </span><a id="_idIndexMarker141" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.378.1">many unique values are </span><span><span class="kobospan" id="kobo.379.1">filled in</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.380.1">top</span></strong><span class="kobospan" id="kobo.381.1">: The name of the most common item in </span><span><span class="kobospan" id="kobo.382.1">the dataset</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.383.1">freq</span></strong><span class="kobospan" id="kobo.384.1">: How often the most common item appears in </span><span><span class="kobospan" id="kobo.385.1">the dataset</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.386.1">At the nominal level, we are usually looking for a few things that would signal </span><span><span class="kobospan" id="kobo.387.1">a transformation:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.388.1">Do we have a reasonable number (usually under 20) of </span><span><span class="kobospan" id="kobo.389.1">unique items?</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.390.1">Is this </span><span><span class="kobospan" id="kobo.391.1">column text?</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.392.1">Is this column unique across </span><span><span class="kobospan" id="kobo.393.1">all rows?</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.394.1">So, for the </span><strong class="source-inline"><span class="kobospan" id="kobo.395.1">business_id</span></strong><span class="kobospan" id="kobo.396.1"> column, we have a count of 10,000. </span><span class="kobospan" id="kobo.396.2">Don’t be fooled, though! </span><span class="kobospan" id="kobo.396.3">This does not mean that we have 10,000 businesses being reviewed here. </span><span class="kobospan" id="kobo.396.4">It just means that of the 10,000 rows of reviews, the </span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">business_id</span></strong><span class="kobospan" id="kobo.398.1"> column is filled in all 10,000 times. </span><span class="kobospan" id="kobo.398.2">The next qualifier, </span><strong class="source-inline"><span class="kobospan" id="kobo.399.1">unique</span></strong><span class="kobospan" id="kobo.400.1">, tells us that we have 4,174 unique businesses being reviewed in this dataset. </span><span class="kobospan" id="kobo.400.2">The most reviewed business is the </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">JokKtdXU7zXHcr20Lrk29A</span></strong><span class="kobospan" id="kobo.402.1"> business, which was reviewed </span><span><span class="kobospan" id="kobo.403.1">37 times:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.404.1">If we run the following code snippet, we will see that we have a totally unique column called </span><strong class="source-inline"><span class="kobospan" id="kobo.405.1">review_id</span></strong><span class="kobospan" id="kobo.406.1"> which is a unique identifier for </span><span><span class="kobospan" id="kobo.407.1">each review.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.408.1">
yelp_raw_data['review_id'].describe()
# count                            10000
# unique                           10000
#          Top                     M3jTv5NIipi_N4mgmZiIEg
#          Freq                    1</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.409.1">We have a </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">count</span></strong><span class="kobospan" id="kobo.411.1"> of </span><strong class="source-inline"><span class="kobospan" id="kobo.412.1">10000</span></strong><span class="kobospan" id="kobo.413.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">unique</span></strong><span class="kobospan" id="kobo.415.1"> of </span><strong class="source-inline"><span class="kobospan" id="kobo.416.1">10000</span></strong><span class="kobospan" id="kobo.417.1">. </span><span class="kobospan" id="kobo.417.2">Think for a second—does this make sense? </span><span class="kobospan" id="kobo.417.3">Think </span><a id="_idIndexMarker142" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.418.1">about what each row represents and what this </span><span><span class="kobospan" id="kobo.419.1">column represents.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.420.1">(Insert Jeopardy theme </span></em><span><em class="italic"><span class="kobospan" id="kobo.421.1">song here.)</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.422.1">Of course it does! </span><span class="kobospan" id="kobo.422.2">Each row of this dataset is supposed to represent a single, unique review of a business, and this column is meant to serve as a unique identifier for a review. </span><span class="kobospan" id="kobo.422.3">So, it makes sense that the </span><strong class="source-inline"><span class="kobospan" id="kobo.423.1">review_id</span></strong><span class="kobospan" id="kobo.424.1"> column has </span><strong class="source-inline"><span class="kobospan" id="kobo.425.1">10000</span></strong><span class="kobospan" id="kobo.426.1"> unique items in it. </span><span class="kobospan" id="kobo.426.2">So, why is </span><strong class="source-inline"><span class="kobospan" id="kobo.427.1">eTa5KD-LTgQv6UT1Zmijmw</span></strong><span class="kobospan" id="kobo.428.1"> the </span><em class="italic"><span class="kobospan" id="kobo.429.1">most common</span></em><span class="kobospan" id="kobo.430.1"> review? </span><span class="kobospan" id="kobo.430.2">This is just a random choice from </span><strong class="source-inline"><span class="kobospan" id="kobo.431.1">10000</span></strong><span class="kobospan" id="kobo.432.1"> and </span><span><span class="kobospan" id="kobo.433.1">means nothing:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.434.1">
yelp_raw_data['text'].describe()
count        10000
unique       9998
top          This review is for the chain in general. </span><span class="kobospan1" id="kobo.434.2">The l...
</span><span class="kobospan1" id="kobo.434.3">freq         2</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.435.1">This column, which represents the actual text people wrote, is interesting. </span><span class="kobospan" id="kobo.435.2">We would imagine that this should also be similar to </span><strong class="source-inline"><span class="kobospan" id="kobo.436.1">review_id</span></strong><span class="kobospan" id="kobo.437.1"> in that each one should contain unique text because it would be weird if two people wrote exactly the same thing, but we have two reviews with the exact same text! </span><span class="kobospan" id="kobo.437.2">Let’s take a second to learn about DataFrame filtering </span><a id="_idIndexMarker143" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.438.1">to examine </span><span><span class="kobospan" id="kobo.439.1">this further.</span></span><a id="_idTextAnchor109" class="pcalibre calibre4 pcalibre1"/></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.440.1">Filtering in pandas</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.441.1">Let’s talk a bit about </span><a id="_idIndexMarker144" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.442.1">how filtering works. </span><span class="kobospan" id="kobo.442.2">Filtering </span><a id="_idIndexMarker145" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.443.1">rows based on certain criteria is quite easy in </span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">pandas</span></strong><span class="kobospan" id="kobo.445.1">. </span><span class="kobospan" id="kobo.445.2">In a DataFrame, if we wish to filter out rows based on some search criteria, we will need to go row by row and check whether or not a row satisfies that particular condition; </span><strong class="source-inline"><span class="kobospan" id="kobo.446.1">pandas</span></strong><span class="kobospan" id="kobo.447.1"> handles this by passing in a </span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">Series</span></strong><span class="kobospan" id="kobo.449.1"> object of </span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">True</span></strong><span class="kobospan" id="kobo.451.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">False</span></strong></span><span><span class="kobospan" id="kobo.453.1"> (Booleans).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.454.1">We literally pass into the DataFrame a list of </span><strong class="source-inline"><span class="kobospan" id="kobo.455.1">True</span></strong><span class="kobospan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">False</span></strong><span class="kobospan" id="kobo.458.1"> data that mean </span><span><span class="kobospan" id="kobo.459.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.460.1">True</span></strong><span class="kobospan" id="kobo.461.1">: This row satisfies </span><span><span class="kobospan" id="kobo.462.1">the condition</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">False</span></strong><span class="kobospan" id="kobo.464.1">: This row does not satisfy </span><span><span class="kobospan" id="kobo.465.1">the condition</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.466.1">So, first, let’s make the conditions. </span><span class="kobospan" id="kobo.466.2">In the following lines of code, I will grab the text that </span><span><span class="kobospan" id="kobo.467.1">occurs twice:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.468.1">
yelp_raw_data['text'].describe()['top']</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.469.1">Here is a snippet of </span><span><span class="kobospan" id="kobo.470.1">the text:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.471.1">
"This review is for the chain in general. </span><span class="kobospan1" id="kobo.471.2">The location we went to is new so it isn't in Yelp yet. </span><span class="kobospan1" id="kobo.471.3">Once it is I will put this review there as well......."</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.472.1">Right off the bat, we can guess that this might actually be one person who went to review two businesses that belong to the same chain and wrote the exact same review. </span><span class="kobospan" id="kobo.472.2">However, this is just a guess </span><span><span class="kobospan" id="kobo.473.1">right now.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.474.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.475.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.476.1">duplicate_text</span></strong><span class="kobospan" id="kobo.477.1"> variable is of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">string</span></strong></span><span><span class="kobospan" id="kobo.479.1"> type.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.480.1">Now that we have this text, let’s use some magic to create that </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">Series</span></strong><span class="kobospan" id="kobo.482.1"> object of </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">True</span></strong> <span><span class="kobospan" id="kobo.484.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.485.1">False</span></strong></span><span><span class="kobospan" id="kobo.486.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.487.1">
duplicate_text = yelp_raw_data['text'].describe()['top']
text_is_the_duplicate = yelp_raw_data['text'] == duplicate_text</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.488.1">Right away, you might be confused. </span><span class="kobospan" id="kobo.488.2">What we have done here is take the </span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">text</span></strong><span class="kobospan" id="kobo.490.1"> column of the DataFrame and compare it to the </span><strong class="source-inline"><span class="kobospan" id="kobo.491.1">duplicate_text string</span></strong><span class="kobospan" id="kobo.492.1">. </span><span class="kobospan" id="kobo.492.2">This is strange because we seem to be comparing a list of </span><strong class="source-inline"><span class="kobospan" id="kobo.493.1">10,000</span></strong><span class="kobospan" id="kobo.494.1"> elements to a single string. </span><span class="kobospan" id="kobo.494.2">Of course, the answer should be a straight </span><span><span class="kobospan" id="kobo.495.1">false, right?</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.496.1">Series</span></strong><span class="kobospan" id="kobo.497.1"> has a very interesting feature in that if you compare the series to an object, it will return another series of Booleans of the same length where each </span><strong class="source-inline"><span class="kobospan" id="kobo.498.1">True</span></strong><span class="kobospan" id="kobo.499.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.500.1">False</span></strong><span class="kobospan" id="kobo.501.1"> instance is the answer to the question </span><em class="italic"><span class="kobospan" id="kobo.502.1">Is this element the same as the element you are comparing it to?</span></em> <span><span class="kobospan" id="kobo.503.1">Very handy!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">This next code block shows us a preview of the contents of this </span><span><span class="kobospan" id="kobo.505.1">new Series.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.506.1">
type(text_is_the_duplicate) # it is a Series of Trues and Falses
text_is_the_duplicate.head() # shows a few Falses out of the Series</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.507.1">In Python, we can add and subtract </span><strong class="source-inline"><span class="kobospan" id="kobo.508.1">True</span></strong><span class="kobospan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.510.1">False</span></strong><span class="kobospan" id="kobo.511.1"> as if they were </span><strong class="source-inline"><span class="kobospan" id="kobo.512.1">1</span></strong><span class="kobospan" id="kobo.513.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.514.1">0</span></strong><span class="kobospan" id="kobo.515.1">, respectively—for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.516.1">True + False – True + False + True == 1</span></strong><span class="kobospan" id="kobo.517.1">. </span><span class="kobospan" id="kobo.517.2">So, we can verify</span><a id="_idIndexMarker146" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.518.1"> that this </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">Series</span></strong><span class="kobospan" id="kobo.520.1"> object is </span><a id="_idIndexMarker147" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.521.1">correct by adding up all of the values. </span><span class="kobospan" id="kobo.521.2">As only two of these rows should contain the duplicate text, the sum of the </span><strong class="source-inline"><span class="kobospan" id="kobo.522.1">Series</span></strong><span class="kobospan" id="kobo.523.1"> object should only be </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">2</span></strong><span class="kobospan" id="kobo.525.1">, which it is! </span><span class="kobospan" id="kobo.525.2">This is shown </span><span><span class="kobospan" id="kobo.526.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.527.1">
sum(text_is_the_duplicate) # == 2</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.528.1">Now that we have our series of Booleans, we can pass them directly into our DataFrame, using bracket notation, and get our filtered rows, </span><span><span class="kobospan" id="kobo.529.1">as illustrated:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.530.1">
filtered_dataframe = yelp_raw_data[text_is_the_duplicate] # the filtered Dataframe</span></pre>
<div class="calibre2">
<div class="img---figure" id="_idContainer016">
<span class="kobospan" id="kobo.531.1"><img alt="Figure 3.2 – Representing two rows with duplicate text, stars, and survey scores" src="image/B19488_03_02.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.532.1">Figure 3.2 – Representing two rows with duplicate text, stars, and survey scores</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.533.1">Data is hardly ever perfect, and a common thing to check for when dealing with raw text is the amount of duplicate fields. </span><span class="kobospan" id="kobo.533.2">In this figure, we can see that there are two rows with duplicate text, stars, and survey scores. </span><span class="kobospan" id="kobo.533.3">This is likely written by the same person given to two locations of </span><span><span class="kobospan" id="kobo.534.1">a chain.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">It seems that our suspicions were correct, and one person, on the same day, gave the exact same review to two different </span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">business IDs</span></strong><span class="kobospan" id="kobo.537.1"> column, presumably a part of the same chain. </span><span class="kobospan" id="kobo.537.2">Let’s keep moving along to the rest of </span><span><span class="kobospan" id="kobo.538.1">our columns:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.539.1">
# count               10000
# unique              1
#          top        Review
#          freq       10000
yelp_raw_data['type'].describe()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.540.1">Remember this column? </span><span class="kobospan" id="kobo.540.2">Turns out they are all the exact same type, </span><span><span class="kobospan" id="kobo.541.1">namely </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">review</span></strong></span><span><span class="kobospan" id="kobo.543.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.544.1">
yelp_raw_data['user_id'].describe()
# count               10000
# unique              6403
#          top        fczQCSmaWF78toLEmb0Zsw
#          freq       38</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.545.1">Similar to the </span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">business_id</span></strong><span class="kobospan" id="kobo.547.1"> column, all 10,000 values are filled in with 6,403 unique users </span><a id="_idIndexMarker148" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.548.1">and </span><a id="_idIndexMarker149" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.549.1">one user reviewing </span><span><span class="kobospan" id="kobo.550.1">38 times!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.551.1">In this example, we won’t have to perform </span><span><span class="kobospan" id="kobo.552.1">any transformations</span><a id="_idTextAnchor110" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.553.1">.</span></span></p>
<h3 class="calibre8"><span class="kobospan" id="kobo.554.1">Ordinal-level columns</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.555.1">As far as ordinal </span><a id="_idIndexMarker150" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.556.1">columns go, we are looking at </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">date</span></strong><span class="kobospan" id="kobo.558.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">stars</span></strong><span class="kobospan" id="kobo.560.1">. </span><span class="kobospan" id="kobo.560.2">For each of these columns, let’s look at what the </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">describe</span></strong><span class="kobospan" id="kobo.562.1"> method </span><span><span class="kobospan" id="kobo.563.1">brings back:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.564.1">
yelp_raw_data['stars'].describe()
# count     10000.000000
# mean      3.777500
# std       1.214636
# min       1.000000
# 25%       3.000000
# 50%       4.000000
# 75%       5.000000
# max       5.000000</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.565.1">Woah! </span><span class="kobospan" id="kobo.565.2">Even though this column is ordinal, the </span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">describe</span></strong><span class="kobospan" id="kobo.567.1"> method returns stats that we might expect for a quantitative column. </span><span class="kobospan" id="kobo.567.2">This is because the software saw a bunch of numbers and just assumed that we wanted stats such as the mean or the min and max. </span><span class="kobospan" id="kobo.567.3">This is not a </span><a id="_idIndexMarker151" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.568.1">problem. </span><span class="kobospan" id="kobo.568.2">Let’s use a method called </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">value_counts</span></strong><span class="kobospan" id="kobo.570.1"> to see the count distribution, </span><span><span class="kobospan" id="kobo.571.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.572.1">
yelp_raw_data['stars'].value_counts()
# 4             3526
# 5             3337
# 3             1461
#       2       927
#       1       749</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.573.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.574.1">value_counts</span></strong><span class="kobospan" id="kobo.575.1"> method will return the distribution of values for any column. </span><span class="kobospan" id="kobo.575.2">In this case, we see that the star rating </span><strong class="source-inline"><span class="kobospan" id="kobo.576.1">4</span></strong><span class="kobospan" id="kobo.577.1"> is the most common, with </span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">3526</span></strong><span class="kobospan" id="kobo.579.1"> values, followed closely by rating </span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">5</span></strong><span class="kobospan" id="kobo.581.1">. </span><span class="kobospan" id="kobo.581.2">We can also plot this data to get a nice visual. </span><span class="kobospan" id="kobo.581.3">First, let’s sort by star rating, and then use the prebuilt </span><strong class="source-inline"><span class="kobospan" id="kobo.582.1">plot</span></strong><span class="kobospan" id="kobo.583.1"> method to make a </span><span><span class="kobospan" id="kobo.584.1">bar chart:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.585.1">
import datetime
dates = yelp_raw_data['stars'].value_counts()
dates.sort_values
dates.plot(kind='bar')</span></pre>
<div class="calibre2">
<div class="img---figure" id="_idContainer017">
<span class="kobospan" id="kobo.586.1"><img alt="Figure 3.3 – A distribution of the star ratings given reveals that most  people are giving 4 or 5 stars, with the most common star rating being 4" src="image/B19488_03_03.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.587.1">Figure 3.3 – A distribution of the star ratings given reveals that most  people are giving 4 or 5 stars, with the most common star rating being 4</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.588.1">From this graph, we can conclude that people are definitely more likely to give good star ratings over</span><a id="_idIndexMarker152" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.589.1"> bad ones! </span><span class="kobospan" id="kobo.589.2">We can follow this procedure for the </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">date</span></strong><span class="kobospan" id="kobo.591.1"> column. </span><span class="kobospan" id="kobo.591.2">I will leave you to try it on your own. </span><span class="kobospan" id="kobo.591.3">For now, let’s look at a </span><span><span class="kobospan" id="kobo.592.1">new dataset.</span></span></p>
<h3 class="calibre8"><a id="_idTextAnchor111" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.593.1">Dataset 2 – Titanic</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.595.1">Titanic</span></strong><span class="kobospan" id="kobo.596.1"> dataset is one</span><a id="_idIndexMarker153" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.597.1"> of those “rites of passage” datasets</span><a id="_idIndexMarker154" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.598.1"> in data science. </span><span class="kobospan" id="kobo.598.2">Everyone, at some point, has seen this dataset in some tutorial or book. </span><span class="kobospan" id="kobo.598.3">It contains a sample of people who were on the Titanic when it struck an iceberg in 1912. </span><span class="kobospan" id="kobo.598.4">I give you my word that, going forward, we will be using much more interesting datasets, but trust me, it’s easier to start off with a dataset such as this one and Yelp to warm up the data </span><span><span class="kobospan" id="kobo.599.1">science muscles.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.600.1">Let’s go ahead and import our new dataset and output the first five rows using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">head</span></strong></span><span><span class="kobospan" id="kobo.602.1"> method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.603.1">
titanic = pd.read_csv('short_titanic.csv')
titanic.head()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.604.1">This table represents the DataFrame for the </span><strong class="source-inline"><span class="kobospan" id="kobo.605.1">short_titanic.csv</span></strong><span class="kobospan" id="kobo.606.1"> dataset. </span><span class="kobospan" id="kobo.606.2">This data is definitely organized in a row/column structure, as is most spreadsheet data. </span><span class="kobospan" id="kobo.606.3">Let’s take a quick peek at </span><span><span class="kobospan" id="kobo.607.1">its size:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.608.1">
titanic.shape
# (891, 5)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.609.1">We have </span><strong class="source-inline"><span class="kobospan" id="kobo.610.1">891</span></strong><span class="kobospan" id="kobo.611.1"> rows and </span><strong class="source-inline"><span class="kobospan" id="kobo.612.1">5</span></strong><span class="kobospan" id="kobo.613.1"> columns. </span><span class="kobospan" id="kobo.613.2">Each row seems to represent a single passenger on the ship, and as far as columns are concerned, the following list tells us what </span><span><span class="kobospan" id="kobo.614.1">they indicate:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">Survived</span></strong><span class="kobospan" id="kobo.616.1">: This is a binary variable that indicates whether or not the passenger survived the accident (</span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">1</span></strong><span class="kobospan" id="kobo.618.1"> if they survived, </span><strong class="source-inline1"><span class="kobospan" id="kobo.619.1">0</span></strong><span class="kobospan" id="kobo.620.1"> if they died). </span><span class="kobospan" id="kobo.620.2">This is likely to be at the nominal level because there are only </span><span><span class="kobospan" id="kobo.621.1">two options.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.622.1">Pclass</span></strong><span class="kobospan" id="kobo.623.1">: This is the class that the passenger was traveling in (</span><strong class="source-inline1"><span class="kobospan" id="kobo.624.1">3</span></strong><span class="kobospan" id="kobo.625.1"> for third class, and so on). </span><span class="kobospan" id="kobo.625.2">This is at the </span><span><span class="kobospan" id="kobo.626.1">ordinal level.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.627.1">Name</span></strong><span class="kobospan" id="kobo.628.1">: This is the name of the passenger, and it is definitely at the </span><span><span class="kobospan" id="kobo.629.1">nominal level.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.630.1">Sex</span></strong><span class="kobospan" id="kobo.631.1">: This indicates the gender of the passenger. </span><span class="kobospan" id="kobo.631.2">It is at the </span><span><span class="kobospan" id="kobo.632.1">nominal level.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.633.1">Age</span></strong><span class="kobospan" id="kobo.634.1">: This one is a bit tricky. </span><span class="kobospan" id="kobo.634.2">Arguably, you may place age at either a qualitative or quantitative level; however, I think that age belongs to a quantitative state, and thus, to the </span><span><span class="kobospan" id="kobo.635.1">ratio level.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">As far as</span><a id="_idIndexMarker155" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.637.1"> transformations </span><a id="_idIndexMarker156" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.638.1">are concerned, usually, we want all columns to be numerical, regardless of their qualitative state. </span><span class="kobospan" id="kobo.638.2">This means that </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">Name</span></strong><span class="kobospan" id="kobo.640.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">Sex</span></strong><span class="kobospan" id="kobo.642.1"> will have to be converted into numerical columns somehow. </span><span class="kobospan" id="kobo.642.2">For </span><strong class="source-inline"><span class="kobospan" id="kobo.643.1">Sex</span></strong><span class="kobospan" id="kobo.644.1">, we can change the column to hold 1 if the passenger was female and 0 if they were male. </span><span class="kobospan" id="kobo.644.2">Let’s use </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">pandas</span></strong><span class="kobospan" id="kobo.646.1"> to make the change. </span><span class="kobospan" id="kobo.646.2">We will have to import another Python module, called </span><strong class="source-inline"><span class="kobospan" id="kobo.647.1">numpy</span></strong><span class="kobospan" id="kobo.648.1"> or numerical Python, </span><span><span class="kobospan" id="kobo.649.1">as illustrated:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.650.1">
import numpy as np
titanic['Sex'] = np.where(titanic['Sex']=='female', 1, 0)</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.651.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">np.where</span></strong><span class="kobospan" id="kobo.653.1"> method takes in three things, </span><span><span class="kobospan" id="kobo.654.1">as follows:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.655.1">A list of Booleans (</span><strong class="source-inline1"><span class="kobospan" id="kobo.656.1">True</span></strong> <span><span class="kobospan" id="kobo.657.1">or </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.658.1">False</span></strong></span><span><span class="kobospan" id="kobo.659.1">)</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.660.1">A </span><span><span class="kobospan" id="kobo.661.1">new value</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.662.1">A </span><span><span class="kobospan" id="kobo.663.1">backup value</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.664.1">The method will replace all </span><strong class="source-inline"><span class="kobospan" id="kobo.665.1">True</span></strong><span class="kobospan" id="kobo.666.1"> instances with the first value (in this case, 1) and the </span><strong class="source-inline"><span class="kobospan" id="kobo.667.1">False</span></strong><span class="kobospan" id="kobo.668.1"> instances with the second value (in this case, 0), leaving us with a new numerical column that represents the same thing as the original </span><span><strong class="source-inline"><span class="kobospan" id="kobo.669.1">Sex</span></strong></span><span><span class="kobospan" id="kobo.670.1"> column:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.671.1">
titanic['Sex']
# 0         0
# 1         1
# 2         1
# 3         1
# 4         0
# 5         0
# 6         0
# 7         0</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.672.1">Let’s use a shortcut </span><a id="_idIndexMarker157" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.673.1">and</span><a id="_idIndexMarker158" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.674.1"> describe all the columns at once so that we can get a bird’s-eye view of what our data looks like and how it is roughly shaped. </span><span class="kobospan" id="kobo.674.2">The code to do this is shown in this </span><span><span class="kobospan" id="kobo.675.1">code snippet:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.676.1">
titanic.describe()</span></pre>
<div class="calibre2">
<div class="img---figure" id="_idContainer018">
<span class="kobospan" id="kobo.677.1"><img alt="Figure 3.4 – Descriptive statistics of our Titanic dataset’s numerically formatted columns " src="image/B19488_03_04.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.678.1">Figure 3.4 – Descriptive statistics of our Titanic dataset’s numerically formatted columns </span></p>
<p class="calibre3"><span class="kobospan" id="kobo.679.1">Reveal that these features have pretty different ranges and means. </span><span class="kobospan" id="kobo.679.2">Note that just because the column is “numerical” doesn’t mean it is quantitative. </span><span class="kobospan" id="kobo.679.3">Pclass would generally be recommended as qualitative even though it is shown here </span><span><span class="kobospan" id="kobo.680.1">as integers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.681.1">This table lists descriptive statistics of the Titanic dataset. </span><span class="kobospan" id="kobo.681.2">Note how our qualitative columns are being</span><a id="_idIndexMarker159" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.682.1"> treated</span><a id="_idIndexMarker160" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.683.1"> as quantitative; however, I’m looking for something irrelevant to the data type. </span><span class="kobospan" id="kobo.683.2">Note the </span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">count</span></strong><span class="kobospan" id="kobo.685.1"> row: </span><strong class="source-inline"><span class="kobospan" id="kobo.686.1">Survived</span></strong><span class="kobospan" id="kobo.687.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.688.1">Pclass</span></strong><span class="kobospan" id="kobo.689.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.690.1">Sex</span></strong><span class="kobospan" id="kobo.691.1"> all have </span><strong class="source-inline"><span class="kobospan" id="kobo.692.1">891</span></strong><span class="kobospan" id="kobo.693.1"> values (the number of rows), but </span><strong class="source-inline"><span class="kobospan" id="kobo.694.1">Age</span></strong><span class="kobospan" id="kobo.695.1"> only has </span><strong class="source-inline"><span class="kobospan" id="kobo.696.1">714</span></strong><span class="kobospan" id="kobo.697.1"> values. </span><span class="kobospan" id="kobo.697.2">Some are missing! </span><span class="kobospan" id="kobo.697.3">To double-verify, let’s use the </span><strong class="source-inline"><span class="kobospan" id="kobo.698.1">pandas</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.699.1">isnull</span></strong><span class="kobospan" id="kobo.700.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.701.1">sum functions</span></strong><span class="kobospan" id="kobo.702.1">, </span><span><span class="kobospan" id="kobo.703.1">as shown:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.704.1">
titanic.isnull().sum()
Survived     0
Pclass       0
Name         0
Sex          0
Age          0</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.705.1">This will show us the number of missing values in each column. </span><span class="kobospan" id="kobo.705.2">So, </span><strong class="source-inline"><span class="kobospan" id="kobo.706.1">Age</span></strong><span class="kobospan" id="kobo.707.1"> is the only column with missing values to </span><span><span class="kobospan" id="kobo.708.1">deal with.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.709.1">When dealing with missing values, you usually have the following </span><span><span class="kobospan" id="kobo.710.1">two options:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.711.1">Drop the row with the </span><span><span class="kobospan" id="kobo.712.1">missing value</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.713.1">Try to fill </span><span><span class="kobospan" id="kobo.714.1">it in</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.715.1">Dropping the row is the easy choice; however, you run the risk of losing valuable data! </span><span class="kobospan" id="kobo.715.2">For example, in this case, we have 177 missing age values (891-714), which is nearly 20% of the data. </span><span class="kobospan" id="kobo.715.3">To fill in the data, we could either go back to the history books, find each person one by one, and fill in their age, or we could fill in the age with a </span><span><span class="kobospan" id="kobo.716.1">placeholder value.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.717.1">Let’s fill in each missing value of the </span><strong class="source-inline"><span class="kobospan" id="kobo.718.1">Age</span></strong><span class="kobospan" id="kobo.719.1"> column with the overall average age of the people in the dataset. </span><span class="kobospan" id="kobo.719.2">For this, we will use two new methods, called </span><strong class="source-inline"><span class="kobospan" id="kobo.720.1">mean</span></strong><span class="kobospan" id="kobo.721.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.722.1">fillna</span></strong><span class="kobospan" id="kobo.723.1">. </span><span class="kobospan" id="kobo.723.2">We use </span><strong class="source-inline"><span class="kobospan" id="kobo.724.1">isnull</span></strong><span class="kobospan" id="kobo.725.1"> to tell us which values are </span><strong class="source-inline"><span class="kobospan" id="kobo.726.1">null</span></strong><span class="kobospan" id="kobo.727.1"> and the </span><strong class="source-inline"><span class="kobospan" id="kobo.728.1">mean</span></strong><span class="kobospan" id="kobo.729.1"> function to give us the average</span><a id="_idIndexMarker161" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.730.1"> value </span><a id="_idIndexMarker162" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.731.1">of the </span><strong class="source-inline"><span class="kobospan" id="kobo.732.1">Age</span></strong><span class="kobospan" id="kobo.733.1"> column. </span><span class="kobospan" id="kobo.733.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.734.1">fillna</span></strong><span class="kobospan" id="kobo.735.1"> method is a </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">pandas</span></strong><span class="kobospan" id="kobo.737.1"> method that replaces null values with a </span><span><span class="kobospan" id="kobo.738.1">given value:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.739.1">
print sum(titanic['Age'].isnull()) # == 177 missing values average_age = titanic['Age'].mean() # get the average age
titanic['Age'].fillna(average_age, inplace = True) #use the fillna method to remove null values
print sum(titanic['Age'].isnull()) # == 0 missing values</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.740.1">We’re done! </span><span class="kobospan" id="kobo.740.2">We have replaced each value with </span><strong class="source-inline"><span class="kobospan" id="kobo.741.1">26.69</span></strong><span class="kobospan" id="kobo.742.1">, the average age in the dataset. </span><span class="kobospan" id="kobo.742.2">The following code now confirms that no null </span><span><span class="kobospan" id="kobo.743.1">values exist:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.744.1">
titanic.isnull().sum()
Survived       0
Pclass         0
Name           0
Sex            0
Age            0</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.745.1">Great! </span><span class="kobospan" id="kobo.745.2">Nothing is missing, and we did not have to remove any rows. </span><span class="kobospan" id="kobo.745.3">Let’s check back in with our data by looking at </span><span><strong class="source-inline"><span class="kobospan" id="kobo.746.1">head</span></strong></span><span><span class="kobospan" id="kobo.747.1"> again:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.748.1">
titanic.head()</span></pre>
<div class="calibre2">
<div class="img---figure" id="_idContainer019">
<span class="kobospan" id="kobo.749.1"><img alt="Figure 3.5 – The first five rows of our Titanic dataset" src="image/B19488_03_05.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.750.1">Figure 3.5 – The first five rows of our Titanic dataset</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.751.1">At this point, we could start getting a bit more complicated with our questions—for example, </span><em class="italic"><span class="kobospan" id="kobo.752.1">What is the average age for a female or a male?</span></em><span class="kobospan" id="kobo.753.1"> To answer this, we can filter by each gender and take the mean age; </span><strong class="source-inline"><span class="kobospan" id="kobo.754.1">pandas</span></strong><span class="kobospan" id="kobo.755.1"> has a built-in function for this, called </span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">groupby</span></strong><span class="kobospan" id="kobo.757.1">, as </span><span><span class="kobospan" id="kobo.758.1">illustrated here:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.759.1">
titanic.groupby('Sex')['Age'].mean()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.760.1">This means the following: group the data by the </span><strong class="source-inline"><span class="kobospan" id="kobo.761.1">Sex</span></strong><span class="kobospan" id="kobo.762.1"> column, and then give me the mean age for each group. </span><span class="kobospan" id="kobo.762.2">This gives us the </span><span><span class="kobospan" id="kobo.763.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.764.1">
Sex
0    30.505824
1    28.216730</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.765.1">We will ask more of</span><a id="_idIndexMarker163" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.766.1"> these </span><a id="_idIndexMarker164" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.767.1">difficult and complex questions and will be able to answer them with Python </span><span><span class="kobospan" id="kobo.768.1">and statistics.</span></span><a id="_idTextAnchor112" class="pcalibre calibre4 pcalibre1"/></p>
<h1 id="_idParaDest-53" class="calibre6"><a id="_idTextAnchor113" class="pcalibre calibre4 pcalibre1"/><span class="kobospan" id="kobo.769.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.770.1">Exploring the data is only one of the essential steps in the data science process, and it is something that we will continue to do throughout this book as we work with different datasets. </span><span class="kobospan" id="kobo.770.2">By following the steps of data exploration, we can transform, break down, and standardize our data to prepare it for modeling </span><span><span class="kobospan" id="kobo.771.1">and analysis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.772.1">Our five steps serve as a standard practice for data scientists and can be applied to any dataset that requires analysis. </span><span class="kobospan" id="kobo.772.2">While they are only guidelines, they provide a framework for exploring and understanding new data, and they can help us to identify trends, relationships, and insights that can inform </span><span><span class="kobospan" id="kobo.773.1">our analysis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.774.1">As we progress in this book, we will delve into the use of statistical, probabilistic, and ML models to analyze and make predictions from data. </span><span class="kobospan" id="kobo.774.2">Before we can fully delve into these more complex models, however, it is important to review some of the basic mathematics that underlie these techniques. </span><span class="kobospan" id="kobo.774.3">In the next chapter, we will cover some of the math that is necessary to perform some of the more complicated operations in modeling. </span><span class="kobospan" id="kobo.774.4">Don’t worry—the math required for this process is minimal, and we will go through it step by step to ensure that you have a solid foundation. </span><span class="kobospan" id="kobo.774.5">By understanding the underlying math, we can better understand the models and techniques that we will be using, and we can more effectively apply them to our </span><span><span class="kobospan" id="kobo.775.1">data analysis</span></span></p>
</div>
</body></html>