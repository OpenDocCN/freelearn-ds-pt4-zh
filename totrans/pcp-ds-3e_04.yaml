- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Mathematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we delve deeper into the realm of data science, it is essential to understand
    the basic mathematical principles and concepts that are fundamental to the field.
    While math may often be perceived as intimidating, my goal is to make this learning
    experience as engaging and enjoyable as possible. In this chapter, we will cover
    key topics such as basic symbols and terminology, logarithms, and exponents, set
    theory, calculus, and matrix (linear) algebra. Additionally, we will explore other
    fields of mathematics and their applications in data science and other scientific
    endeavors, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic symbols/terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logarithms/exponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix (linear) algebra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to remember that, as discussed previously, mathematics is one
    of the three crucial components of data science. The concepts presented in this
    chapter will not only be useful in later chapters but also in understanding probabilistic
    and statistical models. These are fundamental building blocks for anyone aspiring
    to become a data scientist, and as such, should be thoroughly understood.
  prefs: []
  type: TYPE_NORMAL
- en: As a math teacher, it is my duty to educate and enlighten my students on the
    undeniable importance of mathematics in our daily lives. From the simplest tasks,
    such as watering plants and feeding pets, to more complex endeavors, mathematical
    principles and concepts are constantly at play. Even though these calculations
    and predictions may not always be done consciously, they are still being made
    by the human brain. It is my goal to help my students understand and appreciate
    the fundamental role that math plays in our daily lives and to realize the innate
    mathematical abilities that reside within us all.
  prefs: []
  type: TYPE_NORMAL
- en: Basic symbols and terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will review the mathematical concepts of vectors,
    matrices, arithmetic symbols, and linear algebra, as well as some more subtle
    notations used by data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **vector** is defined as an object with both magnitude and direction. This
    definition, however, is a bit complicated. For our purpose, a vector is simply
    a one-dimensional array representing a series of numbers. Put another way, a vector
    is a list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is generally represented using an arrow or bold font, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover><mi>o</mi><mi>r</mi><mi mathvariant="script">x</mi></mrow></mrow></math>](img/1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Vectors are broken into components, which are individual members of the vector.
    We use index notations to denote the element that we are referring to, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>I</mi><mi>f</mi><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>6</mn></mtd></mtr><mtr><mtd><mn>8</mn></mtd></mtr></mtable></mfenced><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><msub><mi
    mathvariant="script">x</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/2.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In math, we generally refer to the first element as index 1, as opposed to computer
    science, where we generally refer to the first element as index 0\. It is important
    to remember which index system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can represent arrays in many ways. We could simply use a Python
    list to represent the preceding array: *x = [3, 6, 8]*. However, it is better
    to use the `numpy` array type to represent arrays, as shown here, because it gives
    us much more utility when performing vector operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of the Python representation, vectors give us a simple way of storing
    *multiple dimensions* of a single data point/observation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we measure the average satisfaction rating (0-100) of employees in three
    departments of a company as being *57* for HR, *89* for engineering, and *94*
    for management, we can represent this as a vector with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>X</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi mathvariant="script">x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi
    mathvariant="script">x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><msub><mi mathvariant="script">x</mi><mn>3</mn></msub></mtd></mtr></mtable></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>57</mn></mtd></mtr><mtr><mtd><mn>89</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3.png)'
  prefs: []
  type: TYPE_IMG
- en: This vector holds three different bits of information about our data. This is
    the perfect use of a vector in data science.
  prefs: []
  type: TYPE_NORMAL
- en: You can also think of a vector as being the theoretical generalization of the
    pandas `Series` object. So, naturally, we need something to represent the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: We can extend our notion of an array to move beyond a single dimension and represent
    data in multiple dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **matrix** is a two-dimensional representation of arrays of numbers. **Matrices**
    (plural of matrix) have two main characteristics that we need to be aware of.
    The dimension of a matrix, denoted by *n x m* (*n by m*), tells us that the matrix
    has *n* rows and *m* columns. Matrices are generally denoted by a capital, bold-faced
    letter, such as *X*. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>3</mn><mn>4</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>8</mn><mn>55</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>9</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a *3 x 2 (3 by 2)* matrix because it has three rows and two columns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If a matrix has the same number of rows and columns, it is called a **square
    matrix**.
  prefs: []
  type: TYPE_NORMAL
- en: The matrix is our generalization of the pandas DataFrame. It is arguably one
    of the most important mathematical objects in our toolkit. It is used to hold
    organized information – in our case, data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting our previous example, let’s say we have three offices in different
    locations, each with the same three departments: HR, engineering, and management.
    We could make three different vectors, each holding a different office’s satisfaction
    scores, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="normal">x</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>57</mn></mtd></mtr><mtr><mtd><mn>89</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced><mo>,</mo><mi
    mathvariant="normal">y</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>67</mn></mtd></mtr><mtr><mtd><mn>87</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced><mo>,</mo><mi
    mathvariant="normal">z</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>65</mn></mtd></mtr><mtr><mtd><mn>98</mn></mtd></mtr><mtr><mtd><mn>60</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/5.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this is not only cumbersome but also unscalable. What if you have 100
    different offices? In this case, you would need to have 100 different one-dimensional
    arrays to hold this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where a matrix alleviates this problem. Let’s make a matrix where each
    row represents a different department and each column represents a different office,
    as shown in *Table 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Office 1 | Office 2 | Office 3 |'
  prefs: []
  type: TYPE_TB
- en: '| HR | 57 | 67 | 65 |'
  prefs: []
  type: TYPE_TB
- en: '| Engineering | 89 | 87 | 98 |'
  prefs: []
  type: TYPE_TB
- en: '| Management | 94 | 84 | 60 |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Some sample data we want to model as a matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much more natural. Now, let’s strip away the labels; we’ll be left
    with a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>X</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>57</mn><mn>67</mn><mn>65</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>89</mn><mn>87</mn><mn>98</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>94</mn><mn>94</mn><mn>60</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/6.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a list of quick exercises you can do to understand matrices
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: If we added a fourth office, would we need a new row or column?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would the dimension of the matrix be after we added the fourth office?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we eliminate the management department from the original X matrix, what would
    the dimension of the new matrix be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the general formula to find out the number of elements in the matrix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the answers:'
  prefs: []
  type: TYPE_NORMAL
- en: Column
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3 x 4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 x 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*n × m* (*n* being the number of rows and *m* being the number of columns)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s move on to arithmetic symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will go over some symbols associated with basic arithmetic
    that appear in most, if not all, data science tutorials and books.
  prefs: []
  type: TYPE_NORMAL
- en: Summation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The uppercase sigma, ∑, symbol is a universal symbol for addition. Whatever
    is to the right of the sigma symbol is usually something iterable, meaning that
    we can go over it one by one (for example, a vector).
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s create the representation of a vector, X=[1,2,3,4,5].
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the sum of the content, we can use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mo>∑</mo><msub><mi>x</mi><mi
    mathvariant="normal">i</mi></msub><mo>=</mo><mn>15</mn></mrow></mrow></math>](img/7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, we can use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi
    mathvariant="normal">#</mi><mo>=</mo><mo>=</mo><mn>15</mn></mrow></mrow></mrow></math>](img/8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, the formula for calculating the mean of a series of numbers is
    quite common. If we have a vector (*x*) of length *n*, the mean of the vector
    can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>=</mo><mn>1</mn><mo>/</mo><mi>n</mi><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>15</mn></mrow></mrow></math>](img/9.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that we will add up each element of *x*, denoted by *xi*, and then
    multiply the sum by *1/n*, otherwise known as dividing by *n* (the length of the
    vector).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can use the following formula to get the mean of the array, *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>/</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi
    mathvariant="normal">#</mi><mo>=</mo><mo>=</mo><mn>3</mn></mrow></mrow></mrow></math>](img/10.png)'
  prefs: []
  type: TYPE_IMG
- en: Dot product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dot product is an operator such as addition and multiplication. It is used
    to combine two vectors, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mfrac><mn>3</mn><mn>7</mn></mfrac></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mn>9</mn><mn>5</mn></mfrac></mfenced><mo>=</mo><mn>3</mn><mi
    mathvariant="normal">*</mi><mn>9</mn><mo>+</mo><mn>7</mn><mi mathvariant="normal">*</mi><mn>5</mn><mo>=</mo><mn>62</mn></mrow></mrow></math>](img/11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What does this mean? Let’s say we have a vector that represents a customer’s
    sentiments toward three genres of movies: comedy, romance, and action.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using a dot product, note that an answer is a single number, known as a
    **scalar**.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a scale of 1 to 5, a customer loves comedies, hates romantic movies, and
    is fine with action movies. We might represent this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/12.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *5* denotes their love for comedies, *1* denotes their hatred of romantic
    movies, and *3* denotes the customer’s indifference toward action movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s assume that we have two new movies, one of which is a romantic comedy
    and the other is a funny action movie. The movies would have their own vector
    of qualities, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>m</mi><mn>1</mn><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mi>m</mi><mn>2</mn><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/13.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *m1* is our romantic comedy and *m2* is our funny action movie.
  prefs: []
  type: TYPE_NORMAL
- en: To make a recommendation, we must apply the dot product between the customer’s
    preferences for each movie. The higher value will win and, therefore, will be
    recommended to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compute the recommendation score for each movie. For movie 1, we want
    to compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can think of this problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – How to interpret a dot product](img/B19488_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – How to interpret a dot product
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer we obtain is *28*, but what does this number mean? On what scale
    is it? Well, the best score anyone can ever get is when all values are *5*, making
    the outcome as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>=</mo><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup><mo>=</mo><mn>75</mn></mrow></mrow></math>](img/15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The lowest possible score is when all values are *1*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we must think about *28* on a scale from *3* to *75*. The number 28 is
    closer to 3 than it is to 75\. Let’s try this for movie 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>=</mo><mo>(</mo><mn>5</mn><mi
    mathvariant="normal">*</mi><mn>5</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>1</mn><mi
    mathvariant="normal">*</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>3</mn><mi
    mathvariant="normal">*</mi><mn>5</mn><mo>)</mo><mo>=</mo><mn>41</mn></mrow></mrow></mrow></math>](img/17.png)'
  prefs: []
  type: TYPE_IMG
- en: This is higher than 28! So, between movie 1 and movie 2, we would recommend
    movie 2 to our user. This is, in essence, how most movie prediction engines work.
    They build a customer profile, which is represented as a vector. They then take
    a vector representation of each movie they have to offer, combine them with the
    customer profile (perhaps with a dot product), and make recommendations from there.
    Of course, most companies must do this on a much larger scale, which is where
    a particular field of mathematics, called **linear algebra**, can be very useful;
    we will look at it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Logarithms/exponents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **exponent** tells you how many times you have to multiply a number by itself,
    as illustrated in *Figures 4.3* and *4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The exponent tells you how many times to multiply a number by
    itself](img/B19488_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The exponent tells you how many times to multiply a number by itself
  prefs: []
  type: TYPE_NORMAL
- en: 'A **logarithm** is a number that answers the question “What exponent gets me
    from the base to this other number?” This can be denoted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The exponent from Figure 4.3 written in logarithm form](img/B19488_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The exponent from Figure 4.3 written in logarithm form
  prefs: []
  type: TYPE_NORMAL
- en: If these two concepts seem similar, then you are correct! Exponents and logarithms
    are heavily related. In fact, the words exponent and logarithm mean the same thing!
    A logarithm is an exponent. The preceding two equations are two versions of the
    same thing. The basic idea is that 2 times 2 times 2 times 2 is 16.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.5* depicts how we can use both versions to say the same thing.
    Note how I use arrows to move from the log formula to the exponent formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Logarithms and exponents are the same!](img/B19488_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Logarithms and exponents are the same!
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>31</mn></msub><mn>81</mn><mo>=</mo><mn>4</mn><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><msup><mn>3</mn><mn>4</mn></msup><mo>=</mo><mn>81</mn></mrow></mrow></math>](img/18.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>5</mn></msub><mn>125</mn><mo>=</mo><mn>3</mn><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><msup><mn>5</mn><mn>3</mn></msup><mo>=</mo><mn>125</mn></mrow></mrow></math>](img/19.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: 'Let’s rewrite the first equation to note something interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>3</mn></msub><mn>81</mn><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s replace 81 with the equivalent statement, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:math>](img/21.png),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>5</mn></msub><mn>125</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/22.png)'
  prefs: []
  type: TYPE_IMG
- en: Something interesting to note is that the 3s seem to *cancel out*. This is very
    important when dealing with numbers that are more difficult to work with than
    3s and 4s.
  prefs: []
  type: TYPE_NORMAL
- en: Exponents and logarithms are most important when dealing with growth. More often
    than not, if a quantity is growing (or declining in growth), an exponent/logarithm
    can help model this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the number *e* is around `2.718` and has many practical applications.
    A very common application is interest calculation for saving. Suppose you have
    $5,000 deposited in a bank with continuously compounded interest at the rate of
    3%. In this case, you can use the following formula to model the growth of your
    deposit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">A</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi
    mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:math>](img/23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this formula, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A* denotes the final amount'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P* denotes the principal investment (**5000**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*e* denotes a constant (**2.718**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r* denotes the rate of growth (**.03**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t* denotes the time (in years)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When will our investment double? How long would I have to have my money in
    this investment to achieve 100% growth? We can write this in mathematical form,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>10,000</mml:mn><mml:msup><mml:mrow><mml:mo>=</mml:mo><mml:mn>5,000</mml:mn><mml:mi
    mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi
    mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:math>](img/24.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>2</mn><mo>=</mo><msup><mi
    mathvariant="normal">e</mi><mrow><mo>.</mo><mn>03</mn><mi mathvariant="normal">t</mi></mrow></msup><mo>(</mo><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">y</mi><mn>5,000</mn><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">b</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mo>)</mo></mrow></mrow></mrow></math>](img/25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we have a variable in the exponent that we want to solve. When
    this happens, we can use the logarithm notation to figure it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The conversion from exponent form to logarithm form](img/B19488_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The conversion from exponent form to logarithm form
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi>t</mml:mi></mml:math>](img/26.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take the logarithm of a number with a base of *e*, it is called a **natural
    logarithm**. We can rewrite the logarithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi
    mathvariant="normal">t</mml:mi></mml:math>](img/27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using a calculator (or Python), we’ll find that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>069</mml:mn></mml:math>](img/28.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>0.69</mn><mo>−</mo><mo>.</mo><mn>03</mn><mi>t</mi></mrow></mrow></math>](img/29.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">t</mml:mi><mml:mo>=</mml:mo><mml:mn>2.31</mml:mn></mml:math>](img/30.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that it would take *2.31* years to double our money.
  prefs: []
  type: TYPE_NORMAL
- en: Set theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set theory involves mathematical operations at the set level. It is sometimes
    thought of as a basic fundamental group of theorems that governs the rest of mathematics.
    For our purpose, we’ll use set theory to manipulate groups of elements.
  prefs: []
  type: TYPE_NORMAL
- en: A **set** is a collection of distinct objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it! A set can be thought of as a list in Python but with no repeat objects.
    There is even a set of objects in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, curly braces, `{ }`, can denote a set or a dictionary. Remember
    that a dictionary in Python is a set of key-value pairs. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: They share this notation because they share a quality in that sets cannot have
    duplicate elements, just as dictionaries cannot have duplicate keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **magnitude** of a set is the number of elements in the set and is represented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>|</mo><mo>=</mo><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">A</mi></mrow></mrow></mrow></math>](img/31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get the magnitude of a set in Python using the `len` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The concept of an empty set exists and is denoted by **{}**. This null set is
    said to have a magnitude of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to denote that an element is within a set, we can use the epsilon
    notation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>2</mn><mo>∈</mo><mo>{</mo><mn>1,2</mn><mo>,</mo><mn>3</mn><mo>}</mo></mrow></mrow></mrow></math>](img/32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This notation means that the element, `2`, exists in the set of *1*, *2*, and
    *3*. If one set is entirely inside another set, we say that it is a **subset**
    of its larger counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>A</mi><mo>=</mo><mo>{</mo><mn>1,5</mn><mo>,</mo><mn>6</mn><mo>}</mo><mo>,</mo><mi>B</mi><mo>=</mo><mo>{</mo><mn>1,5</mn><mo>,</mo><mn>6,7</mn><mo>,</mo><mn>8</mn><mo>}</mo></mrow></mrow></mrow></math>](img/33.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow></mrow></math>](img/34.png)'
  prefs: []
  type: TYPE_IMG
- en: (*A is a subset of B because every element in A is also* *in B.*)
  prefs: []
  type: TYPE_NORMAL
- en: So, *A* is a subset of *B* and *B* is called the **superset** of *A*. If *A*
    is a subset of *B* but *A* does not equal *B* (meaning that there is at least
    one element in *B* that is not in *A*), then *A* is called a **proper subset**
    of *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of even numbers is a subset of all integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every set is a subset, but not a proper subset, of itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of all tweets is a superset of English tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In data science, we use sets (and lists) to represent a list of objects and,
    often, to generalize the behavior of consumers. It is common to reduce a customer
    to a set of characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are a marketing firm trying to predict where a person wants
    to shop for clothes. We are given a set of clothing brands the user has previously
    visited, and our goal is to predict a new store that they would also enjoy. Suppose
    a specific user has previously shopped at the following stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `user1` has previously shopped at `Target`, `Banana Republic`, and `Old
    Navy`. Let’s also look at a different user, called `user2`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we are wondering how similar these users are. With the limited information
    we have, one way to define similarity is to see how many stores there are that
    they both shop at. This is called an **intersection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intersection of two sets is a set whose elements appear in both sets. It
    is denoted using the ∩ symbol, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>}</mo></mrow></mrow></mrow></math>](img/35.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>}</mo></mrow></mrow></mrow></math>](img/36.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>|</mo><mo>=</mo><mn>1</mn></mrow></mrow></mrow></math>](img/37.png)'
  prefs: []
  type: TYPE_IMG
- en: The intersection of the two users is just one store. So, right away, that doesn’t
    seem great. However, each user only has three elements in their set, so having
    1/3 does not seem as bad. Suppose we are curious about how many stores are represented
    between the two of them; this is called a **union**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The union of two sets is a set whose elements appear in either set. It is denoted
    using the ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∪</mml:mo></mml:math>](img/38.png)
    symbol, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∪</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>,</mo><mi>T</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>,</mo><mi>O</mi><mi>l</mi><mi>d</mi><mi>N</mi><mi>a</mi><mi>v</mi><mi>y</mi><mo>,</mo><mi>G</mi><mi>a</mi><mi>p</mi><mo>,</mo><mi>K</mi><mi>o</mi><mi>h</mi><mi>l</mi><mo>′</mo><mi>s</mi><mo>}</mo></mrow></mrow></mrow></math>](img/39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When looking at the similarities between `user1` and `user2`, we should use
    a combination of the `user1` and `user2` have one element in common out of a total
    of five distinct elements between them. So, we can define the similarity between
    the two users as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mn>1</mn><mo>∩</mo><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mn>2</mn><mo>|</mo></mrow><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mn>1</mn><mo>∪</mo><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mn>2</mn><mo>|</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac><mo>=</mo><mo>.</mo><mn>2</mn></mrow></mrow></math>](img/40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This has a name in set theory: the **Jaccard measure**. In general, for the
    *A* and *B* sets, the Jaccard measure (Jaccard similarity) between the two sets
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>∩</mo><mi mathvariant="normal">B</mi><mo>|</mo></mrow><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>∪</mo><mi mathvariant="normal">B</mi><mo>|</mo></mrow></mfrac></mrow></mrow></mrow></math>](img/41.png)'
  prefs: []
  type: TYPE_IMG
- en: It can also be defined as the magnitude of the intersection of the two sets
    divided by the magnitude of the union of the two sets.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a way to quantify similarities between elements represented with
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, the Jaccard measure is a number between `0` and `1`, such that
    when the number is closer to `0`, people are more dissimilar, and when the measure
    is closer to `1`, people are considered similar to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think about the definition, then it makes sense. Take a look at the measure
    once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi
    mathvariant="normal">N</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">y</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">m</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">U</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">y</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">d</mi></mrow></mfrac></mrow></mrow></mrow></math>](img/42.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the numerator represents the number of stores that the users have in common
    (in the sense that they like shopping there), while the denominator represents
    the unique number of stores that they like put together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent this in Python using some simple code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Set theory becomes highly prevalent when we enter the world of probability and
    also when dealing with high-dimensional data. We can use sets to represent real-world
    events taking place, and probability becomes set theory with vocabulary on top
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve already seen, a movie recommendation engine utilizes several mathematical
    concepts to provide accurate and personalized recommendations to users. However,
    in a scenario where a vast collection of 10,000 movies is available for recommendation,
    computational efficiency becomes a crucial factor. Linear algebra, an area of
    mathematics that deals with matrices and vectors, provides the necessary tools
    to perform these calculations efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra focuses on analyzing and manipulating matrices and vectors to
    extract useful information and apply it in practical situations. As we proceed,
    it is important to have a solid understanding of the basic principles of linear
    algebra. Therefore, we will be reviewing several key rules of linear algebra before
    delving further into the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like numbers, we can multiply matrices together. Multiplying matrices is, in
    essence, a mass-produced way of taking several dot products at once. Let’s, for
    example, try to multiply the following matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>8</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>7</mn><mn>8</mn></mrow></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mrow><mn>3</mn><mn>4</mn></mrow><mrow><mn>2</mn><mn>5</mn></mrow></mfrac></mfenced></mrow></mrow></math>](img/43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to consider a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike numbers, the multiplication of matrices is not *commutative*, meaning
    that the order in which you multiply matrices matters a great deal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To multiply matrices, their dimensions must match up. This means that the first
    matrix must have the same number of columns as the second matrix has rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remember this, write out the dimensions of the matrices. In this case, we
    have a *3 x 2* matrix times a *2 x 2* matrix. You can multiply matrices together
    if the second number in the first-dimension pair is the same as the first number
    in the second-dimension pair. The resulting matrix will always have dimensions
    equal to the outer numbers in the dimension pairs (the ones you did not circle).
    In this case, the resulting matrix will have a dimension of *3* *x 2*.
  prefs: []
  type: TYPE_NORMAL
- en: How to multiply matrices together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To multiply matrices, there is a simple procedure we can follow. Essentially,
    we are performing a bunch of dot products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our earlier sample problem, which was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>8</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>7</mn><mn>8</mn></mrow></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mrow><mn>3</mn><mn>4</mn></mrow><mrow><mn>2</mn><mn>5</mn></mrow></mfrac></mfenced></mrow></mrow></math>](img/43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that our resulting matrix will have a dimension of *3 x 2*. So, we
    know it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><msub><mi mathvariant="normal">m</mi><mn>11</mn></msub><msub><mi
    mathvariant="normal">m</mi><mn>12</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi
    mathvariant="normal">m</mi><mn>21</mn></msub><msub><mi mathvariant="normal">m</mi><mn>22</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi
    mathvariant="normal">m</mi><mn>31</mn></msub><msub><mi mathvariant="normal">m</mi><mn>32</mn></msub></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/45.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that each element of the matrix is indexed using a double index. The first
    number represents the row, while the second number represents the column. So,
    the *m*32 element is the element in the third row of the second column. Each element
    is the result of a dot product between rows and columns of the original matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *mxy* element is the result of the dot product of the *xth* row of the
    first matrix and the *yth* column of the second matrix. Let’s solve a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>.</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>13</mml:mn></mml:math>](img/46.png)'
  prefs: []
  type: TYPE_IMG
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>.</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>29</mml:mn></mml:math>](img/47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We eventually get a resulting matrix that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>13</mn><mn>29</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>31</mn><mn>60</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>37</mn><mn>68</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice! Let’s go back to the movie recommendation example. Recall the user’s
    movie genre preferences of comedy, romance, and action, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>U</mi><mo>=</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>s</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/49.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, suppose we have 10,000 movies, all with a rating for these three categories.
    To make a recommendation, we need to take the dot product of the preference vector
    with each of the 10,000 movies. We can use matrix multiplication to represent
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing them all out, let’s express them using the matrix notation.
    We already have *U*, defined here as the user’s preference vector (it can also
    be thought of as a *3 x 1* matrix), but we also need a movie matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>M</mi><mo>=</mo><mi>m</mi><mi>o</mi><mi>v</mi><mi>i</mi><mi>e</mi><mi>s</mi><mo>=</mo><mn>3</mn><mi>x</mi><mn>10,000</mn></mrow></mrow></math>](img/50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have two matrices; one is *3 x 1* and the other is *3 x 10,000*. We
    can’t multiply these matrices as they are because the dimensions do not work out.
    We will have to change *U* a bit. To do this, we can take the *transpose* of the
    matrix (turning all rows into columns and all columns into rows). This will switch
    the dimensions around:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><msup><mi>U</mi><mi
    mathvariant="normal">T</mi></msup><mo>=</mo><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">U</mi><mo>=</mo><mo>(</mo><mn>5</mn><mn>1</mn><mn>3</mn><mo>)</mo></mrow></mrow></mrow></math>](img/51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, now, we have two matrices that can be multiplied together. Let’s visualize
    what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>(</mo><mn>5</mn><mn>1</mn><mn>3</mn><mo>)</mo><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>4</mn><mn>5</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr><mtr><mtd><mrow><mn>1</mn><mn>4</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr><mtr><mtd><mrow><mn>51</mn><mi>x</mi><mn>13</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr></mtable></mfenced><mn>3</mn><mi>x</mi><mn>1,000</mn></mrow></mrow></mrow></math>](img/52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting matrix will be a *1 x 1,000* matrix (a vector) of 10,000 predictions
    for each movie. Let’s try this out in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `numpy` array function to create our matrices. We will have
    both a `user_pref` matrix and a `movies` matrix to represent our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check our dimensions, we can use the `numpy shape` variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks out. Last but not least, let’s use the matrix multiplication method
    of `numpy` (called dot) to perform the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result is an array of integers that represents the recommendations for each
    movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick extension of this, let’s run some code that predicts across more
    than 10,000 movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It took only a bit longer than 4 seconds to run through 100 million movies using
    matrix multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at some basic mathematical principles that will
    become very important as we progress through this book. Between logarithms/exponents,
    matrix algebra, and proportionality, mathematics has a big role not just in analyzing
    data but in many aspects of our lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coming chapters will take a much deeper dive into two big areas of mathematics:
    probability and statistics. Our goal will be to define and interpret the smallest
    and biggest theorems in these two giant fields of mathematics.'
  prefs: []
  type: TYPE_NORMAL
- en: It is in these next few chapters that everything will start to come together.
    So far in this book, we have looked at math examples, data exploration guidelines,
    and basic insights into types of data. It is time to begin to tie all of these
    concepts together.
  prefs: []
  type: TYPE_NORMAL
