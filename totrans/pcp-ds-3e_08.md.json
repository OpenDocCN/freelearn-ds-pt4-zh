["```py\nimport numpy as np\nimport pandas as pd\nfrom scipy import stats\nfrom scipy.stats import poisson\nnp.random.seed(1234)\n# represents 3000 people who take about a 60 minute break\nlong_breaks = stats.poisson.rvs(mu=60, size=3000)\n```", "```py\npd.Series(long_breaks).hist()\n```", "```py\n# represents 6000 people who take about a 15 minute break\nshort_breaks = stats.poisson.rvs(mu=15, size=6000)\npd.Series(short_breaks).hist()\n```", "```py\nbreaks = np.concatenate((long_breaks, short_breaks))\n# put the two arrays together to get our \"population\" of 9000 people\n```", "```py\npd.Series(breaks).hist()\n```", "```py\nbreaks.mean()\n# 29.99 minutes is our parameter.\n```", "```py\nsample_breaks = np.random.choice(a = breaks, size=100)\n# taking a sample of 100 employees\n```", "```py\nbreaks.mean() - sample_breaks.mean()\n# difference between means is 0.699 minutes, not bad!\n```", "```py\nemployee_races = ([\"white\"]*2000) + ([\"black\"]*1000) +\\\n([\"hispanic\"]*1000) + ([\"asian\"]*3000) +\\\n([\"other\"]*3000)\n```", "```py\nimport random\ndemo_sample = random.sample(employee_races, 1000) # Sample 1000 value\nfor race in set(demo_sample):print( race + \" proportion estimate:\" )\nprint( demo_sample.count(race)/1000\\. )\n```", "```py\nhispanic proportion estimate:\n0.103\nwhite proportion estimate:\n0.192\nother proportion estimate:\n0.288\nblack proportion estimate:\n0.1\nasian proportion estimate:\n0.317\n```", "```py\npd.DataFrame(breaks).hist(bins=50,range=(5,100))\n```", "```py\npoint_estimates = []\nfor x in range(500): # Generate 500 samples\n# take a sample of 100 points\nsample = np.random.choice(a=breaks, size=100)\n# add the sample mean to our list of point estimates\npoint_estimates.append( sample.mean() )\n# look at the distribution of our sample means\npd.DataFrame(point_estimates).hist()\n```", "```py\nbreaks.mean() - np.array(point_estimates).mean()\n# .042 minutes difference\n```", "```py\nimport math\nsample_size = 100\n# the size of the sample we wish to take\nsample = np.random.choice(a= breaks, size = sample_size)\na sample of sample_size taken from the 9,000 breaks population from before\nsample_mean = sample.mean()\n# the sample mean of the break lengths sample\n         sample_stdev = sample.std()\n# sample standard deviation\nsigma = sample_stdev/math.sqrt(sample_size)\n# population standard deviation estimate\nstats.t.interval(confidence = 0.95, # Confidence level 95%\ndf= sample_size - 1, # Degrees of freedom\nloc = sample_mean, # Sample mean\nscale = sigma) # Standard deviation\n# (24.28, 33.14)\n```", "```py\n# function to make confidence interval\ndef makeConfidenceInterval():\nsample_size = 100\nsample = np.random.choice(a= breaks, size = sample_size)\nsample_mean = sample.mean()  # sample mean\nsample_stdev = sample.std()\n# sample standard deviation\nsigma = sample_stdev/math.sqrt(sample_size)\n# population Standard deviation estimate\nreturn stats.t.interval(confidence = 0.95, df= sample_size - 1, loc = sample_mean, scale = sigma)\n```", "```py\nbreaks_mean = breaks.mean()\ntimes_in_interval = 0\nn = 10_000\nfor i in range(n):\n    interval = makeConfidenceInterval()\n    if breaks_mean >= interval[0] and breaks_mean <= interval[1]:  # if 29.99 falls in the interval\n        times_in_interval += 1\nprint(times_in_interval / n)\n# 0.9465\n```", "```py\nfor confidence in (.5, .8, .85, .9, .95, .99):\nconfidence_interval = stats.t.interval(confidence = confidence, df= sample_size - 1, loc = sample_mean, scale = sigma)\nlength_of_interval = round(confidence_interval[1] - confidence_interval[0], 2)\n# the length of the confidence interval\nprint( \"confidence {0} has a interval of size {1}\".format(confidence, length_of_interval))\nconfidence 0.5 has a interval of size 2.95\nconfidence 0.8 has a interval of size 5.63\nconfidence 0.85 has a interval of size 6.33\nconfidence 0.9 has a interval of size 7.24\nconfidence 0.95 has a interval of size 8.65\nconfidence 0.99 has a interval of size 11.45\n```", "```py\nlong_breaks_in_engineering = stats.poisson.rvs(loc=10, mu=55, size=100)\nshort_breaks_in_engineering = stats.poisson.rvs(loc=10, mu=15, size=300)\nengineering_breaks = np.concatenate((long_breaks_in_engineering, short_breaks_in_engineering))\nprint(breaks.mean())\n# 29.99\nprint(engineering_breaks.mean())\n# 34.825\n```", "```py\nt_statistic, p_value = stats.ttest_1samp(a= engineering_breaks, popmean= breaks.mean())\n```", "```py\nt_statistic == -5.742\np_value == .00000018\n```", "```py\n    observed = [102, 178, 186, 34]\n    ```", "```py\n    expected = [156, 165.5, 147, 31.5]\n    ```", "```py\n    chi_squared, p_value = stats.chisquare(f_obs= observed, f_exp= expected)\n    ```", "```py\n    chi_squared, p_value\n    ```", "```py\n    #(30.1817679275599, 1.26374310311106e-06)\n    ```", "```py\nobserved = np.array([[134, 54],[110, 48]])\n# built a 2x2 matrix as seen in the table above\nchi_squared, p_value, degrees_of_freedom, matrix = stats.chi2_contingency(observed= observed)\nchi_squared, p_value\n# (0.04762692369491045, 0.82724528704422262)\n```"]