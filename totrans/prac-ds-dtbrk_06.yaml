- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Model Versioning and Webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we delved deep into the capabilities of **Databricks
    AutoML**, exploring its various components in detail. We gained a comprehensive
    understanding of how data science practitioners can harness the power of transparent
    “glass box” AutoML to kickstart their machine learning solutions seamlessly, especially
    when tackling complex business challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we put AutoML into action by automating the selection of a candidate
    model for our **Bank Customer Churn** prediction classification problem. To facilitate
    this process, we seamlessly integrated the robust MLflow features into our workflow.
    This integration allowed us to meticulously track every aspect of our model’s
    training, providing us with invaluable insights into its performance and enabling
    us to make data-driven decisions. Our journey also took us to the MLflow tracking
    server, where we logged and monitored the entire training process, ensuring that
    our Bank Customer Churn prediction project was executed with precision and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into the next steps on how we can take a model
    from the **MLflow tracking server** and utilize the integrated **MLflow Model
    Registry** to manage the model life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for the Model Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering your candidate model to the Model Registry and managing access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the ML model life cycle using the Model Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the **Webhooks** support in the Model Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s go through the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: All the previous notebooks, already executed as described
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Slack workspace where you have webhooks enabled for a channel ([https://api.slack.com/messaging/webhooks](https://api.slack.com/messaging/webhooks))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the need for the Model Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional software engineering, the concept of a central code repository
    is well established and mature. However, in the realm of data science, the idea
    of a centralized model repository is still evolving. While it’s not accurate to
    say that no central repository for models exists – there are indeed other tools
    and platforms that offer similar functionalities – the challenges in model management
    are unique and often more complex.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Databricks’ integrated MLflow Model Registry shines, particularly
    in fostering collaboration among data science teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of the Model Registry include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized discovery**: The Model Registry serves as a centralized hub where
    models from various data science teams are registered. Each registered model has
    a lineage that traces back to the original run and the notebook version in which
    the model was trained, making it easier for teams to collaborate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Life cycle management**: Databricks provides both UI and API options for
    managing the life cycle of your models, streamlining the process of promoting
    a model from one stage to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing and deployment**: The Model Registry allows you to deploy
    different versions of a model to various stages. You can also attach notes and
    perform tests on these models in an automated fashion, ensuring that only the
    most robust models make it to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control**: Robust permissioning features govern who can access, modify,
    or deploy a registered model, thereby ensuring that only authorized individuals
    can interact with your models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s take a look at how you can register a model in the Model Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Registering your candidate model to the Model Registry and managing access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can either use the UI to register a candidate model to the integrated Model
    Registry or use the MLflow Model Registry API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the UI option first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first navigate to the MLflow experiment created by our AutoML execution.
    We can navigate here by clicking on the **Experiments** tab in the left navigation
    bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – How to access the Experiments page](img/B17875_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – How to access the Experiments page
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we select our experiment from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The experiment listed in the integrated MLflow tracking server
    created by AutoML](img/B17875_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The experiment listed in the integrated MLflow tracking server
    created by AutoML
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have access to all the runs that were executed as part of our AutoML
    execution. Here, we can sort the runs in the UI to get the best F1 score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Various models and runs associated with the AutoML experiment
    sorted by F1 score](img/B17875_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Various models and runs associated with the AutoML experiment sorted
    by F1 score
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we select the model that is listed as the first option in the list. In
    my case, this is the `sklearn` model based on LightGBM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – How to look at and access the logged model for the best run](img/B17875_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – How to look at and access the logged model for the best run
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will end up at the MLflow **Run** page for this specific model. This
    page must be looking familiar to you as, when you scroll down, you will see the
    artifacts, metrics, and hyperparameters all logged automatically as part of our
    run (we covered this in previous chapters):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The different artifacts automatically logged by AutoML for each
    experiment run](img/B17875_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The different artifacts automatically logged by AutoML for each
    experiment run
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right side, you will see a button with the caption **Register Model**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – How to register a candidate model to the Model Registry 1](img/B17875_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – How to register a candidate model to the Model Registry 1
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the MLflow Model Registry for the first time, you can select
    `Churn Prediction Bank`. Then, hit **Register**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – How to register a candidate model to the Model Registry 2](img/B17875_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – How to register a candidate model to the Model Registry 2
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your model is registered in the Model Registry and should be
    visible if you access the **Models** page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the **Models** page by clicking on the **Models** icon in the
    left-hand navigation tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – How to access the Model Registry](img/B17875_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – How to access the Model Registry
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply select the **Churn Prediction Bank** model from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The registered candidate model in the Model Registry](img/B17875_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The registered candidate model in the Model Registry
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of things to observe here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version says **Version 1**. This is because we created a new model
    entry in the registry. If we select an existing model from the dropdown in *Step
    9*, then the version will say **Version 2** and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon clicking on **Version 1**, you will be taken to the details page of this
    version of the model and see that **Source Run** is listed as **lightgbm**, which
    is the same run that generated our best model. Also, the input and output schemas
    are inherited from the model signature in the source run automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also set tags and add a description for your model in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The details of the registered version of the candidate model
    in the Model Registry](img/B17875_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The details of the registered version of the candidate model in
    the Model Registry
  prefs: []
  type: TYPE_NORMAL
- en: By default, the stage is set to **None**. You can manage permissioning around
    who has permission to request transitioning your model from one stage to another
    using the built-in access controls.
  prefs: []
  type: TYPE_NORMAL
- en: You can set permissions at the user or group level by clicking on the **Permissions**
    tab on the page we interacted with in *Step 8*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – How to add governance around model access 1](img/B17875_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – How to add governance around model access 1
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the workspace admins and the original creator of the model have
    the **Can** **Manage** permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – How to add governance around model access 2](img/B17875_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – How to add governance around model access 2
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify giving access or control over the model’s life cycle by
    stage. In Databricks MLflow’s Model Registry, each model version can be classified
    into one of three distinct life cycle stages: **Staging**, **Production**, or
    **Archived**. Notably, it is possible to have multiple model versions coexist
    within the same life cycle stage. This is particularly beneficial for scenarios
    such as A/B testing where parallel evaluation of different model versions is essential.
    However, this feature could present a challenge for organizations in managing
    and differentiating between multiple models at the same life cycle stage.'
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, MLflow offers a tagging mechanism. Tags can be applied
    to model versions to offer additional metadata, making it easier to identify,
    filter, and manage models within the same stage. If there are multiple model versions
    in the same stage, then by default, the most recent version of the model is loaded.
    However, it’s crucial to specify which model version you intend to load, particularly
    when multiple versions exist within the same stage. In [*Chapter 7*](B17875_07.xhtml#_idTextAnchor108),
    *Model Deployment Approaches*, we will delve deeper into various methods for deploying
    these staged models effectively. The user interface allows you to modify the stage
    of a model version, as illustrated in the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Various options for model stage transition](img/B17875_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Various options for model stage transition
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Request transition to**, then **Staging**. This action will send
    a notification to the owner of the model that we have requested it to be reviewed
    and requested its transition to staging. In our case, we will get this notification
    as we own the model ourselves. We can also add comments to our model transition
    request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Transitioning a model to staging](img/B17875_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Transitioning a model to staging
  prefs: []
  type: TYPE_NORMAL
- en: 'As the owner of the model, we can then read all the comments on the model and
    have the option to approve, reject, or cancel the request. On clicking **Approve**,
    our model is now transitioned into the **Staging** stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – The documentation history and the ability to approve a model
    transition request](img/B17875_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – The documentation history and the ability to approve a model transition
    request
  prefs: []
  type: TYPE_NORMAL
- en: All the aforementioned actions through the UI can be performed using the MLflow
    Python API when you want to create automated workflows for model training and
    deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at how you can programmatically register the model into the integrated
    Model Registry and then transition to staging. Go to the notebook associated with
    `Chapter 06` and open it in the Databricks workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third code cell, we programmatically retrieve the most recently modified
    experiment. The goal is to extract the best-performing model from this experiment
    based on our chosen evaluation metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fifth cell, we first initialize some parameters such as our existing
    username, `experiment_name`, which is the experiment’s name that’s associated
    with our AutoML, and the `registry_model_name`, which will be the model’s name
    in the Model Registry. In the earlier section, we already registered our candidate
    models using the UI in the registry under the name `MlflowClient` library imported
    from the `mlflow.tracking` package to access the best model based on `run_id`
    associated with the best model run from our MLflow tracking server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To register the model associated with the best model training run, we need
    to provide the model URI (the path to the model in our tracking server) as input
    to the MLflow registry `register_model` API. The other parameter we need to pass
    is the model’s name under which we want the new version of the model retrieved
    from the model tracking server to register. Since, for the sake of simplicity,
    we are keeping the name the same as the model name we defined in the UI, the new
    model will be registered as **version 2** in the Model Registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `MLflowClient` object to update the description or set
    tags related to a model in the registry. In `Command 9` of the notebook, we demonstrate
    how you can use the `MLflowClient` object to call the `update_registered_model`
    and `update_model_version` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Command 11` of the notebook, we demonstrate how you can use the `transition_model_stage`
    method using the `MLflowClient` object to transition the latest model version
    to the `Staging` stage. You can also archive the earlier model as we transition
    the new model to `Staging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now explore how to leverage the webhook events provided by the MLflow
    Model Registry to automate notifications. This will alert us whenever specific
    events related to models registered in the MLflow registry occur.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the webhooks support in the Model Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A webhook allows users to create custom callbacks to enable communication between
    web applications. Webhooks allow a system to push data into another system automatically
    when some event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, this could apply if you want to automatically trigger a notification
    on Slack when you detect a new transition request for a model in MLflow, or if
    you want to trigger a new model build when there is a new code commit in your
    version control branch.
  prefs: []
  type: TYPE_NORMAL
- en: MLflow webhooks provide capabilities for end users to automatically listen to
    any events related to the Model Registry and trigger actions. The webhooks can
    be integrated with messaging systems such as Slack to send notifications or trigger
    CI/CD pipelines for automatically testing and deploying ML models.
  prefs: []
  type: TYPE_NORMAL
- en: You can use webhooks using the Python client or Databricks REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of webhooks that are supported by the MLflow
    Model Registry based on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Webhooks with HTTP endpoints**: These are used when we want to send trigger
    events to an HTTP endpoint such as Slack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webhooks for Databricks Jobs**: These are specifically used for sending trigger
    events to Databricks Jobs. This type of webhook is particularly useful for initiating
    automated tests on models that have been newly promoted to staging or production
    environments as part of your CI/CD process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure summarizes the workflow involving registering a model
    to the MLflow Model Registry, and how you can utilize MLflow webhooks to kick
    off Slack notifications and Databricks jobs to apply tags/comments or automate
    tests on the newly deployed model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – A typical workflow for model management using webhooks](img/B17875_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – A typical workflow for model management using webhooks
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Courtesy of Databricks
  prefs: []
  type: TYPE_NORMAL
- en: Once a model stage transition request is filed, the HTTP webhook can be used
    to notify the user/group of users who can review the request and *approve* it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set webhooks for a specific model or for all the models that are
    registered in a particular registry.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about the various supported webhook events at [https://docs.databricks.com/en/mlflow/model-registry-webhooks.html#webhook-events](https://docs.databricks.com/en/mlflow/model-registry-webhooks.html#webhook-events).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code example provided with this chapter, we are specifically using the
    following two events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODEL_VERSION_CREATED`: A new model version was created for the associated
    model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRANSITION_REQUEST_CREATED`: A user requested a model version’s stage to be
    transitioned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate how you can establish automated alerting for model transitions
    via Slack, you must first secure a Slack webhook URL. The following steps guide
    you through the creation of a Slack app and subsequently allow you to set up an
    incoming webhook. For an exhaustive guide on this subject, please refer to the
    official Slack API documentation on webhooks at [https://api.slack.com/messaging/webhooks](https://api.slack.com/messaging/webhooks).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re actively running the code from the `Chapter 06` notebook, ensure that
    you have your Slack webhook URL at hand before proceeding to execute `Command
    16`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One thing to remember here is that the REST endpoints we are going to hit for
    creating a new registry webhook, deleting webhooks, listing webhooks, and more
    are only available on Databricks and not on the open source MLflow. You can read
    more about the Databricks REST API specification for MLflow at [https://docs.databricks.com/dev-tools/api/latest/mlflow.html#operation/get-registered-model](https://docs.databricks.com/dev-tools/api/latest/mlflow.html#operation/get-registered-model).
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed with our review of the notebook located in the `Chapter 06` folder.
    We'll now delve into the details of utilizing webhooks to automatically send notifications
    to a Slack channel when specific events occur within the model registry concerning
    your registered model
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Command 15`, we specified a code block that provides utility functions
    to interact with MLflow’s REST API. It initializes an MLflow client and fetches
    host and token credentials for authentication. The `mlflow_call_endpoint` function
    is designed to make HTTP calls to a specified MLflow API endpoint using either
    `GET` or other HTTP methods. It accepts an API endpoint, an HTTP method, and an
    optional JSON payload as arguments, and returns a JSON response as a dictionary.
    The script also handles exceptions, printing an error message if the API call
    fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Command 16`, assign the value of the `slack_webhook` variable to the webhook
    link for your Slack channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute `Command 17` and `Command 18`. This will register new webhooks for
    the model we registered for our **Customer Prediction Bank** problem. We will
    be notified when a new model version is created or a transition request has been
    made for a model version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `http_url_spec` parameter is where you provide the URL for the HTTP webhook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, after this point, if you go back to your model UI or request transitioning
    a model to a new stage, you will get notified in Slack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Automated notification received on Slack channel using Slack
    webhook](img/B17875_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Automated notification received on Slack channel using Slack webhook
  prefs: []
  type: TYPE_NORMAL
- en: The notebook also demonstrates other REST API calls that can help you manage
    the webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just seen an example of how you can use webhooks for HTTP endpoints. Similarly,
    we can set up a job registry webhook. This can be used to trigger certain Databricks
    jobs you may have for testing a model or retraining a model version.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parameters that you need to provide in job registry webhooks
    that are different from the HTTP registry webhooks: `job_spec` and `workspace_url`.
    You can kick off jobs in a workspace that is different from the one in the Model
    Registry. If you don’t define `workspace_url`, then by default, the job specification
    will be used to trigger a Databricks job in the same workspace as the Model Registry.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how you can utilize the Databricks Model Registry
    to manage ML model versioning and life cycles. We also learned how you can manage
    ML model versioning using the MLflow Model Registry and transition models from
    one stage to another while managing access control. We then learned how you can
    use MLflow-supported webhook callbacks to set up automated Slack notifications
    to track changes around models in your Model Registry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will cover various model deployment approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some links to further your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Databricks, *Databricks* *AutoML*: [https://docs.databricks.com/applications/machine-learning/automl.html#databricks-automl](https://docs.databricks.com/applications/machine-learning/automl.html#databricks-automl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Databricks, *Job registry webhook example* *workflow*: [https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html#job-registry-webhook-example-workflow](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html#job-registry-webhook-example-workflow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slack, *Sending messages using incoming* *Webhooks*: [https://api.slack.com/messaging/webhooks#enable_webhook](https://api.slack.com/messaging/webhooks#enable_webhook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
