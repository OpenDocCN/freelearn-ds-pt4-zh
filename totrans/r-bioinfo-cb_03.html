<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Searching Genes and Proteins for Domains and Motifs</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The sequences of genes, proteins, and entire genomes hold clues to their function. Repeated subsequences or sequences with a strong similarity to each other can be clues to things such as evolutionary conservation or functional relatedness. As such, sequence analysis for motifs and domains are core techniques in bioinformatics. Bioconductor contains many useful packages for analyzing genes, proteins, and genomes. In this chapter, you will learn how to use Bioconductor to analyze sequences for features of functional interest, such as</span> <span>de novo</span> <span>DNA motifs and known domains from widely used databases. You'll learn about some packages for kernel-based machine learning to find protein sequence features. You will also learn some large-scale alignment techniques for very many, or very long sequences. You will use Bioconductor and other statistical learning packages.</span></p>
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Finding DNA motifs with universalmotif</li>
<li>Finding protein domains using PFAM and bio3d</li>
<li>Finding InterPro domains</li>
<li>Performing multiple alignments of genes or proteins</li>
<li>Aligning genomic length sequences with DECIPHER</li>
<li>Machine learning for novel feature detection in proteins</li>
<li>3D structure protein alignment with bio3d</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample data you'll need is available from this book's GitHub repository: <a href="https://github.com/danmaclean/R_Bioinformatics_Cookbook">https://github.com/danmaclean/R_Bioinformatics_Cookbook</a><a href="https://github.com/danmaclean/R_Bioinformatics_Cookbook">.</a> If you want to use the code examples as they are written, then you will need to make sure that this data is in a sub-directory of whatever your working directory is.</p>
<p>The following are the R packages that you'll need. Most of these will install with<span> </span><kbd>install.packages()</kbd><em>; </em>others are a little more complicated:</p>
<ul>
<li><kbd>ape</kbd></li>
<li> <kbd>Bioconductor</kbd>:
<ul>
<li><kbd>Biostrings</kbd></li>
<li><kbd>biomaRt</kbd></li>
<li><kbd>DECIPHER</kbd></li>
<li><kbd>EnsDb.Rnorvegicus.v79</kbd></li>
<li><kbd>kebabs</kbd></li>
<li><kbd>msa</kbd></li>
<li><kbd>org.At.tair.db</kbd></li>
<li><kbd>org.Eck12.db</kbd></li>
<li><kbd>org.Hs.eg.db</kbd></li>
<li><kbd>PFAM.db</kbd></li>
<li><kbd>universalmotif</kbd></li>
</ul>
</li>
<li><kbd>bio3d</kbd></li>
<li><kbd>dplyr</kbd></li>
<li><kbd>e1071</kbd></li>
<li>seqinr</li>
</ul>
<p>Bioconductor is huge and has its own installation manager. You can install it with the following code:<a href="https://www.bioconductor.org/install/"/></p>
<pre>if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")
BiocManager::install()</pre>
<div class="packt_infobox"><span> </span><span>Further information is available at</span><span> </span><span><a href="https://www.bioconductor.org/install/">https://www.bioconductor.org/install/</a>.</span></div>
<p>Normally, in R, a user will load a library and use the functions directly by name. This is great in interactive sessions but it can cause confusion when many packages are loaded. To clarify which package and function I'm using at a given moment, I will occasionally use the<span> </span><kbd>packageName::functionName()</kbd> convention. </p>
<p class="mce-root"/>
<div class="packt_infobox"><span>Sometimes, in the middle of a recipe, I'll interrupt the code so you can see some intermediate output or the structure of an object it's important to understand. Whenever that happens, you'll see a code block where each line begins with ## double hash symbols. Consider the command that follows:</span>
<pre>letters[1:5]</pre>
This will give us output as follows – note that the output lines are prefixed with <kbd>##</kbd>:
<pre class="mce-root">## a b c d e</pre>
Some of the packages that we want to use in this chapter rely on third-party software that must be installed separately. A great way of installing and managing bioinformatics software on any of Windows, Linux, or macOS is the conda package manager in conjunction with the bioconda package channel. You can install lots of software with some simple commands. To install both, start out by reading the current instructions at <a href="https://bioconda.github.io/">https://bioconda.github.io/</a>. </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding DNA motifs with universalmotif</h1>
                </header>
            
            <article>
                
<p class="mce-root">A very common task when working with DNA sequences is finding instances of motifs—a short defined sequence—in a longer sequence. These could represent protein—DNA binding sites, such as transcription factor binding sites in a gene promoter or an enhanced region. There are two start points for this analysis: either you have a database of motifs that you wish to use to scan target DNA sequences and extract wherever the motif occurs or you have just the sequences of interest and you want to find out whether there are any repeating motifs in there. We'll look at ways of doing both of these things in this recipe. We'll use the <kbd>universalmotif</kbd> package in both cases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">For this recipe, we need the <kbd>datasets/ch3/simple_motif.txt</kbd> and <kbd>datasets/ch3/promoters.fa</kbd> files, a simple matrix describing a simple motif in a <strong>Position Specific Weight Matrix</strong> (<strong>PSWM</strong>) format (see <em>Appendix</em> for a brief description), and a set of sequences from upstream of transcriptional start sites.</p>
<p class="mce-root"/>
<p class="mce-root">This recipe also requires a working copy of <kbd>MEME</kbd> on your system. <kbd>MEME</kbd> is a program for finding statistically overrepresented sequence motifs in sets of sequences. When used on promoter or upstream gene regions, these motifs can represent transcription factor-binding sites. The web page for <kbd>MEME</kbd> is at <a href="http://alternate.meme-suite.org/">http://alternate.meme-suite.org/</a> and if you have conda installed, you can install it with <kbd>conda install -c bioconda meme</kbd>. The <kbd>MEME</kbd> package isn't available for Windows systems. If you wish to run it on Windows, then you should look at running it under Cygwin—a Linux emulation layer (<a href="https://www.cygwin.com/">https://www.cygwin.com/</a>). You may need to install a new version of R under Cygwin as well. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Finding DNA motifs with <kbd>universalmotif</kbd> can be done using the following steps:</p>
<ol>
<li class="mce-root">First, load the libraries and a motif of interest:</li>
</ol>
<pre style="padding-left: 60px">library(universalmotif)<br/>library(Biostrings)<br/><br/>motif &lt;- read_matrix(file.path(getwd(), "datasets", "ch3","simple_motif.txt"))</pre>
<ol start="2">
<li>Then, load in sequences to scan with the motif:</li>
</ol>
<pre style="padding-left: 60px">sequences &lt;- readDNAStringSet(file.path(getwd(), "datasets", "ch3", "promoters.fa"))</pre>
<ol start="3">
<li>Perform a scan of the sequences:</li>
</ol>
<pre style="padding-left: 60px">motif_hits &lt;- scan_sequences(motif, sequences = sequences)<br/>motif_hits</pre>
<div class="mce-root packt_infobox">Note that <kbd>motif_hits</kbd> contains information about the position of the motif in each of the target sequences.</div>
<ol start="4">
<li>Calculate whether the motif is enriched in the sequences:</li>
</ol>
<pre style="padding-left: 60px">motif_info &lt;- enrich_motifs(motif, sequences, shuffle.k = 3, verbose = 0, progress = FALSE, RC = TRUE)<br/>motif_info</pre>
<div class="packt_infobox">Note that motif info contains information about statistical enrichment in a set of sequences.</div>
<div>
<ol start="5">
<li>Run <kbd>MEME</kbd> to find novel motifs:</li>
</ol>
<pre style="padding-left: 60px">meme_path = "/Users/macleand/miniconda2/bin/meme"<br/>meme_run &lt;- run_meme(sequences, bin = meme_path, output = "meme_out", overwrite.dir = TRUE)<br/>motifs &lt;- read_meme("meme_out/meme.txt")<br/>view_motifs(motifs)</pre></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This is really neat code! In just a few lines, we were able to complete a whole analysis. We began by loading in a matrix description of a motif and some sequences we hope to find the promoter in—this happened in steps 1 and 2 and we got a <kbd>universalmotif</kbd> object and a <kbd>DNAStringSet</kbd> object to work with. The real work happens next, in steps 3 and 4. The <kbd>scan_sequences()</kbd> <span>function </span>searches each of the sequences and reports where it finds motifs—check out the <kbd>motif_hits</kbd> <span>object </span>to see where they are.</p>
<p>This will result in the following output:</p>
<pre>##               motif  sequence start stop  score max.score score.pct 
## 1   YTTTYTTTTTYTTTY AT4G28150    73   87  7.531  22.45824  33.53335 
## 2   YTTTYTTTTTYTTTY AT4G28150    75   89 10.949  22.45824  48.75270</pre>
<p>When it comes to working out whether a motif is significant, the <kbd>enrich_motifs()</kbd> function in the <kbd>universalmotifs</kbd> package does this work for us in step 4 and will result in the following output:</p>
<pre>##             motif total.seq.hits num.seqs.hit num.seqs.total
## 1 YTTTYTTTTTYTTTY            916           50             50
##   total.bkg.hits num.bkg.hit num.bkg.total   Pval.hits   Qval.hits
## 1            265          48            50 4.75389e-85 4.75389e-85
##     Eval.hits
## 1 9.50778e-85</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It searches the sequences to find likely instances of motifs and counts them, performing Fisher's exact test to compare the frequencies of motifs in our set of sequences with their frequencies in an automatically generated background set. The final <kbd>motif_info</kbd> <span>output </span>contains a report of the <em>p</em> value. To find novel motifs, we run the external software <strong>MEME</strong> in step 5. The <kbd>run_meme()</kbd> function needs to know where the <strong>MEME</strong> package is on your system, so we define that in the <kbd>meme_path</kbd> variable.</p>
<div class="packt_infobox">Note that the value for <kbd>meme_path</kbd> on your system will be different than the value mentioned here—that's an example on my system.</div>
<p>We pass that information to the function, along with the <kbd>DNAStringSet</kbd> object containing our sequences. The function also needs an output directory to write <kbd>MEME</kbd> results to, since it doesn't return anything useful to R. The <kbd>run_meme()</kbd> function executes <kbd>MEME</kbd> in the background and once the run is finished, we can load in the results from the <kbd>meme.txt</kbd> file using the <kbd>read_meme()</kbd> function with a filename. It returns a <kbd>universalmotif</kbd> object. Finally, here, we quickly inspect the <kbd>motifs</kbd> object with the <kbd>view_motifs()</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-565 image-border" src="Images/51fa1536-9437-4b38-b990-908f51de364f.png" style="width:38.25em;height:27.50em;" width="655" height="471"/></p>
<p><span>This gives us a pretty visualization of the motifs found.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Loading in motifs from pre-existing databases such as JASPAR and TRANSFAC is very easy with <kbd>universalmotif</kbd> as there are straightforward replacements for the <kbd>read_matrix()</kbd> function. Look at the following functions <span>to load in motifs from various formats:</span> <kbd>read_cisbp()</kbd>, <kbd>read_homer()</kbd>, <kbd>read_jaspar()</kbd>, <kbd>read_matrix()</kbd>, <kbd>read_meme()</kbd>, <kbd>read_motifs()</kbd>, and <kbd>read_uniprobe()</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding protein domains with PFAM and bio3d</h1>
                </header>
            
            <article>
                
<p>Discovering the function of a protein sequence is a key task. We can <span><span>do </span></span>this in many ways, including by conducting whole sequence similarity searches against databases of known proteins using tools such as BLAST. If we want more informative and granular information, we can instead look for individual functional domains within a sequence. Databases such as <kbd>Pfam</kbd> and tools such as <kbd>hmmer</kbd> make this possible. <kbd>Pfam</kbd> encodes protein domains as profile Hidden Markov Models, which <kbd>hmmer</kbd> uses to scan sequences and report any likely occurrences of the domains. Often, genome annotation projects will carry out the searches for us, meaning that finding the <kbd>Pfam</kbd> domains in our sequence is a question of searching a database. Bioconductor does a great job of packaging up the data in these databases in particular packages—usually suffixed with <strong><kbd>.db</kbd></strong>. In this recipe, we'll look at how to work out whether a package contains Pfam domain information, how to extract it for specific genes of interest, and an alternative method for running a Pfam search yourself if there isn't any pre-existing information.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<div>
<p>For this example, we need some Bioconductor <kbd>Annotationdbi</kbd> database packages—specifically, <kbd>org.Hs.eg.db</kbd>, <kbd>org.EcK12.eg.db</kbd>, and <kbd>and org.At.tair.db</kbd>.</p>
<p>You'll also need the <kbd>bio3d</kbd> package, which—at the time of writing—only connects to the Pfam server if you use the development version. You can install this version from BitBucket with the <kbd>devtools</kbd> package:</p>
<pre>install.packages("devtools")
library(devtools)
install_bitbucket("Grantlab/bio3d", subdir = "ver_devel/bio3d/")</pre></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Finding protein domains with <kbd>PFAM.db</kbd> and <kbd>bio3d</kbd> can be done using the following steps:</p>
<ol>
<li>Load the database package and inspect the types of keys in the database:</li>
</ol>
<pre style="padding-left: 60px" class="r">library(org.Hs.eg.db)<br/>keytypes(org.Hs.eg.db)</pre>
<div class="packt_tip">Note the <kbd>ENSEMBL</kbd> key in this output—we can use this to query the database.</div>
<ol start="2">
<li class="r">Get a vector of keys using the <kbd>keys()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">k &lt;- head(keys(org.Hs.eg.db, keytype = "ENSEMBL"), n = 3 )</pre>
<ol start="3">
<li>Query the database:</li>
</ol>
<pre style="padding-left: 60px" class="r">result &lt;- select(org.Hs.eg.db, keys = k, keytype="ENSEMBL", columns = c("PFAM"))<br/>result</pre>
<ol start="4">
<li>Load the <kbd>PFAM</kbd> database to extract descriptions:</li>
</ol>
<pre style="padding-left: 60px" class="r">library(PFAM.db)
descriptions &lt;- PFAMDE</pre>
<ol start="5">
<li>Get all keys from the <kbd>PFAM</kbd> database:</li>
</ol>
<pre style="padding-left: 60px">all_ids &lt;- mappedkeys(descriptions)</pre>
<ol start="6">
<li>Get all descriptions for the <kbd>PFAM</kbd> IDs:</li>
</ol>
<pre style="padding-left: 60px" class="r">id_description_mapping &lt;- as.data.frame(descriptions[all_ids])</pre>
<ol start="7">
<li>Join the descriptions to <kbd>PFAM</kbd>:</li>
</ol>
<pre style="padding-left: 60px">dplyr::left_join(result, id_description_mapping, by = c("PFAM" = "ac") )</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The key to this approach is finding out whether the database we're using actually carries the PFAM domain information. That's what we do in step 1—we use the <kbd>keytypes()</kbd> function to list the search keys available. PFAM can be seen in the results. Once we've verified that we can use this database for the information we want, we can follow a fairly standard procedure:</p>
<ol>
<li>Get a list of keys to query with—such as gene names. Here, we pull them from the database directly, but they could come from anywhere. This will result in the following output:</li>
</ol>
<pre style="padding-left: 60px">##  [1] "ACCNUM"       "ALIAS"        "ENSEMBL"      "ENSEMBLPROT" 
##  [5] "ENSEMBLTRANS" "ENTREZID"     "ENZYME"       "EVIDENCE"    
##  [9] "EVIDENCEALL"  "GENENAME"     "GO"           "GOALL"       
## [13] "IPI"          "MAP"          "OMIM"         "ONTOLOGY"    
## [17] "ONTOLOGYALL"  "PATH"         "PFAM"         "PMID"        
## [21] "PROSITE"      "REFSEQ"       "SYMBOL"       "UCSCKG"     
## [25] "UNIGENE"      "UNIPROT"</pre>
<ol start="2">
<li>Query the database with the <kbd>select()</kbd> function, which pulls data for the provided keys. The <kbd>columns</kbd> argument tells it which data to pull. The expression here is going to get PFAM IDs for our genes of interest.</li>
<li>Make a list of all PFAM IDs and descriptions. We load the <kbd>PFAM.db</kbd> package and use the <kbd>PFAMDE</kbd> object it provides to get a mapping between IDs and descriptions. This will result in the following output. Note that because we're pulling data from an external database, changes in that database could be reflected here:</li>
</ol>
<pre style="padding-left: 60px">##           ENSEMBL    PFAM
## 1 ENSG00000121410 PF13895
## 2 ENSG00000175899 PF01835
## 3 ENSG00000175899 PF07678
## 4 ENSG00000175899 PF10569
## 5 ENSG00000175899 PF07703
## 6 ENSG00000175899 PF07677
## 7 ENSG00000175899 PF00207
## 8 ENSG00000256069    &lt;NA&gt;</pre>
<ol start="4">
<li>We can then get the actual descriptions in an object with the <kbd>mappedkeys()</kbd> function.</li>
<li>Next, we extract and convert the descriptions of the <kbd>all_ids</kbd> object to a data frame.</li>
</ol>
<ol start="6">
<li>And finally, we join the descriptions of the PFAM domains to the PFAM IDs we got earlier, using the columns with common data—<kbd>PFAM</kbd> and <kbd>ac</kbd>. This will result in the following output:</li>
</ol>
<pre style="padding-left: 60px">##           ENSEMBL    PFAM                                       de
## 1 ENSG00000121410 PF13895                    Immunoglobulin domain
## 2 ENSG00000175899 PF01835                               MG2 domain
## 3 ENSG00000175899 PF07678               A-macroglobulin TED domain
## 4 ENSG00000175899 PF10569                                     &lt;NA&gt;
## 5 ENSG00000175899 PF07703 Alpha-2-macroglobulin bait region domain
## 6 ENSG00000175899 PF07677  A-macroglobulin receptor binding domain
## 7 ENSG00000175899 PF00207             Alpha-2-macroglobulin family
## 8 ENSG00000256069    &lt;NA&gt;                                     &lt;NA&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>I mentioned that the key to the recipe—in particular, the join in step 6—was to make sure the database contained the right keys, specifically PFAM, to proceed. Depending on the organism and database, the PFAM annotation may not exist. Here's how to check whether it does exist in the database you're interested in with two example databases, <kbd>org.At.tair.db</kbd> and <kbd>org.Eck12.eg.db</kbd>, an Arabidopsis database:</p>
<pre>library(org.At.tair.db)<br/>columns(org.At.tair.db)</pre>
<p>and an E.coli database:</p>
<pre>library(org.EcK12.eg.db)<br/>columns(org.EcK12.eg.db)</pre>
<p class="mce-root"/>
<p>Simply use the <kbd>columns()</kbd> function to report the data columns in the database. If PFAM shows up, you can follow the procedure. If it doesn't show up, then as an alternative procedure, it is possible to run PFAM and make the annotations yourself. The following code takes your input protein sequences and runs a PFAM search on the server at EBI using the <kbd>bio3d</kbd> function, <kbd>hmmer()</kbd>. The returned object contains the PFAM output in a dataframe in the <kbd>hit.tbl</kbd> slot:</p>
<pre>sequence &lt;- read.fasta(file.path(getwd(), "datasets", "ch3", "ecoli_hsp.fa") )
# run pfamseq on protein
result &lt;- hmmer(sequence, type="hmmscan", db="pfam")
result$hit.tbl</pre>
<p>This will result in the following output:</p>
<pre>##   name        acc bias dcl desc  evalue flags hindex ndom nincluded
## 1 GrpE PF01025.19  3.3 272 GrpE 1.4e-46     3   8846    1         1
##   nregions nreported    pvalue score taxid     pdb.id bitscore mlog.evalue
## 1        1         1 -115.4076 158.2     0 PF01025.19    158.2    105.5824</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding InterPro domains</h1>
                </header>
            
            <article>
                
<p>InterPro is a database of predictive models, or signatures, provided by multiple protein databases. InterPro aggregates information from multiple sources to reduce redundancy in annotations and aid interpretability. In this recipe, we'll extend the approach we used for just PFAM domains and look at getting annotations of InterPro domains on sequences of interest. We'll start with Ensembl core databases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll need the <kbd>ensembldb</kbd>, <kbd>Ensdb.Rnorvegicus.v79</kbd>, and <kbd>biomaRt</kbd> <span>Bioconductor packages.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Finding InterPro protein domains can be done using the following steps:</p>
<ol>
<li>Load the libraries and double-check whether our database package carries the protein data we need:</li>
</ol>
<pre style="padding-left: 60px" class="r">library(ensembldb)<br/>library(EnsDb.Rnorvegicus.v79)
hasProteinData(EnsDb.Rnorvegicus.v79)</pre>
<ol start="2">
<li class="r">
<p>Build a list of genes to query with—note the <kbd>keytype</kbd> I need here is <kbd>GENEID</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px" class="r">e &lt;- EnsDb.Rnorvegicus.v79<br/>k &lt;- head(keys(e, keytype = "GENEID"), n = 3 )</pre>
<ol start="3">
<li class="r">Use the <kbd>select()</kbd> function to pull the relevant data:</li>
</ol>
<pre style="padding-left: 60px" class="r">select(e, keys = GeneIdFilter(k),<br/>       columns = c("TXBIOTYPE", "UNIPROTID", "PROTEINID","INTERPROACCESSION"))</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The code is a database lookup on, specifically, the Rattus norvegicus Ensembl Database through the relevant package. The process is similar to that for PFAM domain searches:</p>
<ol>
<li>We use the <kbd>EnsemblDB</kbd> package-specific <kbd>hasProteinData()</kbd> function to check whether the database has the information we need. If the output is<span> </span><kbd>TRUE</kbd><span>, we're good:</span></li>
</ol>
<pre style="padding-left: 90px">## [1] TRUE</pre>
<ol start="2">
<li>We again build a list of genes of interest—here, I pull the list from the database, but these IDs can come from anywhere.</li>
<li>Finally, we search the database with the genes of interest as a key. Note that we need the <kbd>GeneIdFilter()</kbd> function wrapper and the <kbd>columns</kbd> argument to select which data we want to return.  This will result in a data frame with the following information:</li>
</ol>
<pre style="padding-left: 90px">##         TXBIOTYPE UNIPROTID          PROTEINID INTERPROACCESSION  GENEID
## 1  protein_coding    Q32KJ7 ENSRNOP00000052495         IPR017850  ENSRNOG00000000001
## 2  protein_coding    Q32KJ7 ENSRNOP00000052495         IPR000917  ENSRNOG00000000001
## 3  protein_coding    C9E895 ENSRNOP00000000008         IPR015424  ENSRNOG00000000007</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The approach we used in this recipe works well for Ensembl core databases, but there are other non-Ensembl core databases that we might want to search; for that, there is biomaRt. biomaRt allows us to define connections to other databases we may know of. Many of these databases expose an API we can use to query them. To do this, load the <kbd>biomaRt</kbd> library and use the <kbd>useMart()</kbd> function to define a connection to the appropriate host and dataset. Then, use the <kbd>getBM()</kbd> function with the connection and the columns and gene IDs to query with. You'll get the search results for InterPro back if your query is <kbd>interpro</kbd>. The following example does a search for two <em>Arabidopsis</em> genes at <kbd>plants.ensembl.org</kbd>:</p>
<pre class="r">library(biomaRt)
biomart_athal &lt;- useMart(biomart = "plants_mart", host = "plants.ensembl.org", dataset = "athaliana_eg_gene")<br/>getBM( c("tair_locus", "interpro"), filters=c("tair_locus"), values = c("AT5G40950", "AT2G40510"), mart = biomart_athal)</pre>
<p class="r">This returns the following output:</p>
<pre>##   tair_locus  interpro
## 1  AT2G40510 IPR000892
## 2  AT2G40510 IPR038551
## 3  AT5G40950 IPR001684
## 4  AT5G40950 IPR018261</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also...</h1>
                </header>
            
            <article>
                
<p>If you're having trouble working out the names of marts and columns, try the <kbd>listMarts()</kbd> and <kbd>listDatasets()</kbd> <span>functions </span>from <strong>bioMart</strong>, which will provide lists of currently available marts and the data they contain.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performing multiple alignments of genes or proteins</h1>
                </header>
            
            <article>
                
<p>The alignment of sequences as a task prior to building phylogenetic trees or as an end in itself to determine conserved and divergent regions is a mainstay in bioinformatics analysis and is amply covered in R and Bioconductor with the <strong>ape</strong> and <strong>DECIPHER</strong> packages. We'll look at the extremely straightforward procedures for going from sequence to alignment in this recipe.</p>
<div class="packt_infobox">Note that there are different techniques for different sequence lengths. In this first recipe, we'll look at how to align some Kbp-length sequences such as those that represent genes and proteins. </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe needs the <kbd>msa</kbd> package. This is a pretty hefty package and includes external software: Clustal, Clustal Omega, and Muscle. The <kbd>ape</kbd> and <kbd>seqinR</kbd> <span>packages </span>are also needed. As a test dataset, we'll use some haemoglobin protein sequences stored in the book's data and code repository at <kbd>datasets/ch3/hglobin.fa</kbd>. You'll need PDFLatex on your system too. You can find installation information here: <a href="https://www.latex-project.org/get/">https://www.latex-project.org/get/</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Performing multiple alignments of genes or proteins can be done using the following steps:</p>
<ol>
<li>Load in the libraries and sequences:</li>
</ol>
<pre style="padding-left: 60px">library(msa)
seqs &lt;- readAAStringSet(file.path(getwd(), "datasets", "ch3", "hglobin.fa"))
seqs</pre>
<ol start="2">
<li>Perform the multiple sequence alignment:</li>
</ol>
<pre style="padding-left: 60px">alignment &lt;- msa(seqs, method = "ClustalOmega")<br/>alignment</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">This returns an alignment object as follows:</p>
<pre style="padding-left: 60px">## ClustalOmega 1.2.0 
## 
## Call:
##    msa(seqs, method = "ClustalOmega")
## 
## MsaAAMultipleAlignment with 3 rows and 142 columns
##     aln                                               names
## [1] MVLSPADKTNVKAAWGKVGAHAG...PAVHASLDKFLASVSTVLTSKYR HBA_HUMAN
## [2] MVLSGEDKSNIKAAWGKIGGHGA...PAVHASLDKFLASVSTVLTSKYR HBA_MOUSE
## [3] MSLTRTERTIILSLWSKISTQAD...ADAHAAWDKFLSIVSGVLTEKYR HBAZ_CAPHI
## Con MVLS??DKTNIKAAWGKIG?HA?...PAVHASLDKFLASVSTVLTSKYR Consensus</pre>
<ol start="3">
<li>View the result using the following code:</li>
</ol>
<pre style="padding-left: 60px">msaPrettyPrint(alignment, output="pdf", showNames="left",
showLogo="none", askForOverwrite=FALSE, verbose=FALSE, file="whole_align.pdf")</pre>
<ol start="4">
<li>View a zoomed-in region using the following code:</li>
</ol>
<pre style="padding-left: 60px">msaPrettyPrint(alignment, c(10,30), output="pdf", showNames="left",
file = "zoomed_align.pdf", showLogo="top", askForOverwrite=FALSE, verbose=FALSE)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The recipe here is short and sweet—performing an MSA with <kbd>msa</kbd> is very straightforward. In step 1, we loaded the packages and sequences using the common <kbd>readAAStringSet()</kbd> function to give us <kbd>seqs</kbd>—an <kbd>AAStringSet</kbd> object, which we can inspect and get the following output:</p>
<pre>## A AAStringSet instance of length 3
##     width seq                                          names               
## [1]   142 MVLSPADKTNVKAAWGKVGAH...HASLDKFLASVSTVLTSKYR HBA_HUMAN
## [2]   142 MVLSGEDKSNIKAAWGKIGGH...HASLDKFLASVSTVLTSKYR HBA_MOUSE
## [3]   142 MSLTRTERTIILSLWSKISTQ...HAAWDKFLSIVSGVLTEKYR HBAZ_CAPHI</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Next, in <em>Step 2</em>, the <kbd>msa()</kbd> function is passed the <kbd>seqs</kbd> object and the name of an alignment method. Here, we use <kbd>ClustalOmega</kbd> (you can choose <kbd>ClustalOmega</kbd>, <kbd>ClustalW</kbd>, or <kbd>Muscle</kbd>). The method parameter specifies the name of the external program that is used to run the actual alignment. The aligner runs and you get an <kbd>MsaMultipleAlignment</kbd> object back—this is a container for the aligned sequences and it looks as follows:</p>
<pre>## ClustalOmega 1.2.0 
## 
## Call:
##    msa(seqs, method = "ClustalOmega")
## 
## MsaAAMultipleAlignment with 3 rows and 142 columns
##     aln                                               names
## [1] MVLSPADKTNVKAAWGKVGAHAG...PAVHASLDKFLASVSTVLTSKYR HBA_HUMAN
## [2] MVLSGEDKSNIKAAWGKIGGHGA...PAVHASLDKFLASVSTVLTSKYR HBA_MOUSE
## [3] MSLTRTERTIILSLWSKISTQAD...ADAHAAWDKFLSIVSGVLTEKYR HBAZ_CAPHI
## Con MVLS??DKTNIKAAWGKIG?HA?...PAVHASLDKFLASVSTVLTSKYR Consensus</pre>
<p class="CDPAlignLeft CDPAlign">In step 3, we write a visualization of the alignment to a PDF file using the <kbd>msaPrettyPrint()</kbd> function. The function takes many arguments that describe the layout of the alignment picture. The visualization must be written to a file; it can't be sent to an interactive session plot window like a normal plot object. The file the picture ends up in is specified with the file argument. The picture looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-566 image-border" src="Images/87df59f6-0c9c-4679-86cd-cf6bfafe0215.png" style="width:134.92em;height:28.00em;" width="1619" height="336"/></p>
<p class="CDPAlignLeft CDPAlign"><span>In step 4, we use the second positional argument to restrict the view to between positions 10 and 30 using the start - end</span> <kbd>c(10,30)</kbd><span> vector. We get the following picture:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-567 image-border" src="Images/448f1f85-e5d0-4ab9-9217-1990dd4cd25f.png" style="width:33.00em;height:17.92em;" width="502" height="273"/></p>
<p>Unfortunately, because the picture-making process uses Latex in the background, we cannot coerce the picture into a more helpful format than PDF or have it render like other plot objects. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>A tree visualization of sequence similarity is often useful at this stage. We can generate one of these with the <kbd>ape</kbd> and <kbd>seqinr</kbd> packages. We can convert our alignment object to a <kbd>seqinr distance</kbd> object that describes the sequence distances, and from that, use <kbd>ape</kbd> to create a simple neighbour-joining tree that we can plot:</p>
<pre>library(ape)<br/>library(seqinr)<br/>alignment_seqinr &lt;- msaConvert(alignment, type="seqinr::alignment")<br/>distances &lt;- seqinr::dist.alignment(alignment_seqinr, "identity")<br/>tree &lt;- ape::nj(distances)<br/>plot(tree, main="Phylogenetic Tree of HBA Sequences")</pre>
<p>This will give the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-568 image-border" src="Images/38084986-a3b9-421d-8bab-349b315c6e23.png" style="width:29.42em;height:21.00em;" width="558" height="398"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Aligning genomic length sequences with DECIPHER</h1>
                </header>
            
            <article>
                
<p>Aligning sequences longer than genes and proteins, such as contigs from assembly projects, chromosomes, or whole genomes is a tricky task and one for which we need different techniques than those for short sequences. The longer sequences get, the harder they are to align. Long alignments are especially costly in terms of the computational time taken, since the algorithms that are effective on short sequences take up exponentially more time with increasing sequence length. Performing longer alignments generally starts with finding short anchor alignments and working the alignment out from there. We typically end up with blocks of synteny—regions that match well between the different genome alignments. </p>
<p>In this recipe, we'll look at the <kbd>DECIPHER</kbd> package for genome length alignments. We'll use some chloroplast genomes—small organelle genomes of about 150 Kbp in length that are pretty well conserved as our sequences of interest.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Make sure that you have the <kbd>DECIPHER</kbd> package installed. We'll use the <kbd>datasets/ch3/plastid_genomes.fa</kbd> file as an example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Aligning genomic length sequence with <kbd>DECIPHER</kbd> can be done using the following steps:</p>
<ol>
<li>Load in the libraries and genome sequences:</li>
</ol>
<pre style="padding-left: 60px">library(DECIPHER)<br/>long_seqs &lt;- readDNAStringSet(file.path(getwd(), "datasets", "ch3", "plastid_genomes.fa"))
long_seqs</pre>
<ol start="2">
<li>Prepare the sequences in a local database:</li>
</ol>
<pre style="padding-left: 60px" class="r">Seqs2DB(long_seqs, "XStringSet", "long_db", names(long_seqs))</pre>
<ol start="3">
<li>Find the blocks of <kbd>synteny</kbd>:</li>
</ol>
<pre style="padding-left: 60px">synteny &lt;- FindSynteny("long_db")<br/>pairs(synteny)</pre>
<p style="padding-left: 60px">This will create a dotplot of syntenic blocks.</p>
<ol start="4">
<li>Plot the <kbd>syntenic</kbd> blocks:</li>
</ol>
<pre style="padding-left: 60px">plot(synteny)</pre>
<ol start="5">
<li>Now, make an actual alignment:</li>
</ol>
<pre style="padding-left: 60px" class="r">alignment &lt;- AlignSynteny(synteny, "long_db")</pre>
<ol start="6">
<li>And save the pairwise alignments one-by-one:</li>
</ol>
<pre style="padding-left: 60px">blocks &lt;- unlist(alignment[[1]])
writeXStringSet(blocks, "genome_blocks_out.fa")</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The DECIPHER package is very powerful and, as such, there's a little bit of setup to do before we can move on to the meat of the analysis. In step 1, we load the libraries and the sequence into <kbd>long_seqs</kbd>, a <strong>DNAStringSet</strong> object; but in step 2, we build a further on-disk SQLite database for the subsequent steps. This is done with the <kbd>Seqs2DB()</kbd> function, which takes <kbd>long_seqs</kbd>, an input type (<strong>XStringSet</strong>—the parent class of <strong>DNAStringSet)</strong>, a name for the database (<kbd>long_db</kbd>), and a vector of sequence names, which we pull with the <kbd>names()</kbd> function. Once we've got the database built, we can use it in the following workflow:</p>
<ol>
<li>Find syntenic blocks in a database with the <kbd>FindSynteny()</kbd> function. This will result in the following output:</li>
</ol>
<p> </p>
<pre style="padding-left: 60px">## A DNAStringSet instance of length 5
##      width seq                                         names               
## [1] 130584 GGCATAAGCTATCTTCCCAA...GATTCAAACATAAAAGTCCT NC_018523.1 Sacch...
## [2] 161592 ATGGGCGAACGACGGGAATT...AGAAAAAAAAATAGGAGTAA NC_022431.1 Ascle...
## [3] 117672 ATGAGTACAACTCGAAAGTC...GATTTCATCCACAAACGAAC NC_022259.1 Nanno...
## [4] 154731 TTATCCATTTGTAGATGGAA...TATACACTAAGACAAAAGTC NC_022417.1 Cocos...
## [5] 156618 GGGCGAACGACGGGAATTGA...TTTTGTAGCGAATCCGTTAT NC_022459.1 Camel...</pre>
<ol start="2">
<li>Use the syntenic blocks to seed and perform an actual alignment with the <kbd>AlignSynteny()</kbd> function.</li>
</ol>
<p>These things are done in steps 3 and 5. <kbd>FindSynteny()</kbd> needs the name of the database; <kbd>AlignSynteny()</kbd> needs the <kbd>synteny</kbd> object and the database name. </p>
<p>Finally, we can output the results. The <kbd>pairs()</kbd> function with the <kbd>synteny</kbd> object <span>will create a dotplot of syntenic </span>blocks<span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-569 image-border" src="Images/6e4c485b-06c7-40f7-be51-3da141db2acf.png" style="width:54.17em;height:38.08em;" width="650" height="457"/></p>
<p class="mce-root"/>
<p class="CDPAlignLeft CDPAlign"><span>The</span> <kbd>plot()</kbd> <span>function with the</span> <kbd>synteny</kbd> <span>object creates a helpful heatmap as a plot of the position of syntenic blocks relative to the first genome. Regions of identical colors across the genomes indicate regions of syntenic sequences:</span><span><br/></span></p>
<p class="CDPAlignCenter CDPAlign"><span><img class="aligncenter size-full wp-image-570 image-border" src="Images/ec419285-0479-4751-b51d-53ebd60b3363.png" style="width:54.83em;height:34.17em;" width="658" height="410"/></span></p>
<p>The last step, step 6, is the slightly fiddly save process. The <kbd>alignment</kbd> object is an R list in which each member represents an alignment—itself a list. By extracting and then using <kbd>unlist()</kbd> on each of the returned elements, you have an object (<kbd>blocks</kbd>) that can be saved as a typical FASTA alignment with <kbd>writeXStringSet()</kbd>. Remember that you'll need to do this for every member of the <kbd>blocks</kbd> object separately.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Machine learning for novel feature detection in proteins</h1>
                </header>
            
            <article>
                
<p>Sometimes, we'll have a list of protein sequences that have come from some analysis or experiment that are in some way biologically related—for example, they may all bind the same target—and we will want to determine the parts of those proteins that are responsible for the action. Domain and motif finding, as we've done in the preceding recipes, can be helpful, but only if we've seen the domains before or the sequence is particularly well conserved or statistically over-represented. A different approach is to try machine learning in which we build a model that can classify our proteins of interest accurately and then use the properties of the model to show us which parts of the proteins result in the classification. We'll take that approach in this recipe; specifically, we'll train a <strong>support vector machine</strong> (<strong>SVM</strong>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we need the <kbd>kebabs </kbd>and <kbd>Biostrings</kbd>, <kbd>e1071</kbd> and <kbd>readr</kbd> libraries, and two input data files. Machine learning works best with many training examples but they take time to run, so we have a rather small input of 170 <em>E.coli</em> proteins for which, according to the <kbd>STRING</kbd> database (<a href="https://string-db.org/">https://string-db.org/</a>), there is experimental evidence for interacting with the <em>pfo</em> <span>protein</span>. These are the positive training examples. We also need negative training examples—these are another 170 <em>E.coli</em> proteins for which there is no evidence of interaction with <em>pfo,</em> which have been selected at random. All the protein sequences are in the <kbd>datasets/ch3/ecoli_proteins.fa</kbd> file. Accompanying this file is a text file of the class of each protein. <kbd>datasets/ch3/ecoli_protein_classes.txt</kbd> is a single-column text file that describes the class of each protein—a "1" for positive <em>pfo</em> interaction, and a "-1" for negative <em>pfo</em> interaction. The row index in the class file matches the protein index in the sequence file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Machine learning for novel feature detection in proteins can be done using the following steps:</p>
<ol>
<li>Load the libraries and input files:</li>
</ol>
<pre style="padding-left: 60px">library(kebabs)<br/>library(Biostrings) <br/>seqs &lt;- readAAStringSet(file.path(getwd(),<span> </span>"datasets",<span> </span>"ch3",<span> </span>"ecoli_proteins.fa")) <br/>classes &lt;- readr::read_csv(file.path(getwd(),<span> </span>"datasets",<span> </span>"ch3",<span> </span>"ecoli_protein_classes.txt"), col_names =<span> </span>TRUE)<br/>classes &lt;- classes$class</pre>
<ol start="2">
<li>Divide the data into a training and test set:</li>
</ol>
<pre style="padding-left: 60px">num_seqs &lt;- length(seqs) <br/>training_proportion &lt;-<span> </span>0.75<span> <br/></span>training_set_indices &lt;- sample(1:num_seqs, training_proportion * num_seqs) <br/>test_set_indices &lt;- c(1:num_seqs)[-training_set_indices]</pre>
<ol start="3">
<li>Build the model with the training set:</li>
</ol>
<pre style="padding-left: 60px">kernel &lt;- gappyPairKernel(k=1, m=3) <br/>model &lt;- kbsvm(x=seqs[training_set_indices], y=classes[training_set_indices], kernel=kernel, pkg="e1071", svm="C-svc", cost=15)</pre>
<ol start="4">
<li>Use the model to predict the classes of the test set:</li>
</ol>
<pre style="padding-left: 60px">predictions &lt;- predict(model, seqs[test_set_indices]) <br/>evaluatePrediction(predictions, classes[test_set_indices], allLabels=c(1,-1) )</pre>
<p style="padding-left: 60px">This will give the following output:</p>
<pre style="padding-left: 60px">##     1 -1
## 1  36 23
## -1 10 19
## 
## Accuracy:              62.500% (55 of 88)
## Balanced accuracy:     61.749% (36 of 46 and 19 of 42)
## Matthews CC:            0.250
## 
## Sensitivity:           78.261% (36 of 46)
## Specificity:           45.238% (19 of 42)
## Precision:             61.017% (36 of 59)</pre>
<ol start="5">
<li>Examine the prediction profile of a sequence:</li>
</ol>
<pre style="padding-left: 60px">seq_to_test &lt;- seqs[[1]][1:10]<br/>seq_to_test</pre>
<p style="padding-left: 60px">This gives the following output:</p>
<pre style="padding-left: 60px">## 10-letter "AAString" instance ## seq: MSFDIAKYPT</pre>
<p class="mce-root"/>
<ol start="6">
<li>Then, plot <kbd>prediction_profile</kbd> using the following code:</li>
</ol>
<pre style="padding-left: 60px">prediction_profile &lt;-getPredictionProfile(seq_to_test, kernel, featureWeights(model), modelOffset(model) ) plot(prediction_profile)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The first step here is straightforward: we load in the sequences we're interested in and the classes they belong to. Because we're loading the <kbd>ecoli_protein_classes.txt</kbd> file into a <strong>dataframe</strong>, when we need a simple vector, we use the <kbd>$</kbd> subset operator to extract the <kbd>classes</kbd> column from the dataframe. Doing so returns that single column in the vector object we need. After this, the workflow is straightforward:</p>
<ol>
<li>Decide how much of the data should be training and how much should be test: Here, in step 1, we choose 75% of the data as the training set when we create the <kbd>training_proportion</kbd> <span>variable</span>. This is used in conjunction with <kbd>num_seqs</kbd> in the <kbd>sample()</kbd> function to randomly choose indices of the sequences to put into the training set. The<kbd>training_set_indices</kbd> <span>variable </span>contains integers that we will use to subset data on later. Initially, we make a complementary list of indices, <kbd>test_set_indices</kbd>, by using the square bracket, <kbd>[]</kbd>, subset notation and the negation operator, <kbd>-</kbd>. Basically, this construct is an idiomatic way of creating a vector that contains every index <em>not</em> in <kbd>training_set_indices</kbd>. </li>
<li>Construct and train the Support Vector Machine model: In step 2, we build our classifying model. First, we choose a kernel that maps the input data into a matrix space that the Support Vector Machine can learn from. Here, it's from the <kbd>gappyPairKernel()</kbd> function—note that there are lots of kernel types; this one is pretty well suited to sequence data. We pass<kbd>kernel</kbd> along to the <kbd>kbsvm()</kbd> function along with the <kbd>training_set_indices</kbd> subset of sequences in <kbd>seqs</kbd> as the <kbd>x</kbd> parameter, and the <kbd>training_set_indices</kbd> subset of classes as the <kbd>y</kbd> parameter. Other arguments in this function determine the exact model type and package and training parameters. There are lots of options for these and they can have a strong effect on the efficacy of the final model. It's well worth reading up and doing some scientific experimentation on what works best for your particular data. The final model is saved in the <kbd>model</kbd> variable.</li>
</ol>
<ol start="3">
<li>Test the model on unseen data: Now we have a model, we get to use it to predict classes of unseen proteins. This stage will tell us how good the model is. In step 3, we use the <kbd>predict()</kbd> function with the model and the sequences we didn't use to train (the ones in <kbd>test_set_indices</kbd>) and get a prediction object back. Running the predictions through the <kbd>evaluatePrediction()</kbd> function along with the real classes from the classes vector and also a vector of all possible class labels using the <kbd>allLabels</kbd> argument returns a summary of the accuracy and other metrics of the model. We have 62% accuracy in the model here, which is only okay; it's better than random. But we have a rather small dataset and the model isn't optimized; with more work, it could be better. Note that if you run the code, you may get different answers. Since the selection of training set sequences is random, the models might do slightly worse or better depending on the exact input data.</li>
<li>Estimate the prediction profile of a sequence: To actually find the regions that are important in classification, and presumably in the function of the protein, we use the <kbd>getPredictionProfile()</kbd> <span>function </span>on a sequence. We do this in step 4 on a small 10 AA fragment extracted from the first sequence using list, double-bracket indexing to get the first sequence and single-bracket indexing to get a range; for example, <kbd>seqs[[1]][1:10]</kbd>. We do this simply for the clarity of the visualization in the last step. You can use whole sequences just as well. The <kbd>getPredictionProfile()</kbd> function needs the <kbd>kernel</kbd> and <kbd>model</kbd> objects to function. This will give the following output:</li>
</ol>
<pre style="padding-left: 60px">##     1 -1
## 1  36 23
## -1 10 19
## 
## Accuracy:              62.500% (55 of 88)
## Balanced accuracy:     61.749% (36 of 46 and 19 of 42)
## Matthews CC:            0.250
## 
## Sensitivity:           78.261% (36 of 46)
## Specificity:           45.238% (19 of 42)
## Precision:             61.017% (36 of 59)</pre>
<ol start="5">
<li>Finally, we can <kbd>plot()</kbd> the prediction profile: The profile shows the contribution of each amino acid to the overall decision and adds to the interpretability of the learning results. Here, the fourth residue, <strong>D</strong>, makes a strong contribution to the decision made <span>for </span>this protein. By examining this across many sequences, the patterns contributing to the decision can be elucidated. It's worth noting that you may get a slightly different picture to the one that follows—because of random processes in the algorithms—and its something you should build into your analyses: make sure that any apparent differences aren't due to random choices made in the running of the code. The strongest contribution should still come from "D" in this example:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-572 image-border" src="Images/2867de45-fb07-4dc4-a939-602caf4c417e.png" style="width:33.17em;height:19.08em;" width="649" height="374"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">3D structure protein alignment with bio3d</h1>
                </header>
            
            <article>
                
<p>Three-dimensional structural alignments between two molecular models can reveal structural properties that are common or unique to either of the proteins. These can suggest evolutionary or functional commonalities. In this recipe, we'll look at how to get an alignment of two protein sequences in three dimensions and view them in 3D-rendering software.  </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this section, we need at least two external pieces of software—PyMOL and MUSCLE—a 3D structure-rendering program and a sequence aligner.</p>
<p class="mce-root"/>
<p>MUSCLE can be installed with conda as follows:</p>
<pre><span>conda install -c bioconda muscle </span></pre>
<p>A version of MUSCLE is installed with the <kbd>msa</kbd> package, and bio3d can be referred to that installation instead. We'll use the <strong>msa</strong> version in this recipe.</p>
<p>PyMOL is absolutely necessary for visualization and can be installed with conda as follows:</p>
<pre><span>conda install -c schrodinger pymol</span></pre>
<p><span>To find the install path for this software, use <kbd>which pymol</kbd>.</span></p>
<p><span>Beyond these, you'll need two files containing structures of human and fruit fly thioredoxins to work with: <kbd>datasets/ch3/1xwc.pdb</kbd> and <kbd>datasets/ch3/3trx.pdb</kbd>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>3D structure protein alignment with bio3d can be done using the following steps:</p>
<ol>
<li>Load the library and the PDB structure files:</li>
</ol>
<pre style="padding-left: 60px">library(bio3d)<br/>a &lt;- read.pdb(file.path(getwd(), "datasets", "ch3" ,"1xwc.pdb"))<br/>b &lt;- read.pdb(file.path(getwd(), "datasets", "ch3", "3trx.pdb"))</pre>
<ol start="2">
<li>Then, carry out the alignment of the structures:</li>
</ol>
<pre style="padding-left: 60px">pdbs &lt;- pdbaln(list("1xwc"=a,"3trx"=b), fit=TRUE, exefile="msa")</pre>
<ol start="3">
<li>Launch and render the alignment in PyMOL:</li>
</ol>
<pre style="padding-left: 60px">pymol_path = <span>"/Users/macleand/miniconda2/bin/pymol"<br/></span>pymol(pdbs, exefile = pymol_path, type = "launch", as="cartoon")</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As ever, the first steps are to load the library then the input data. Here, in step 1, we load two separate PDB files with the <kbd>read.pdb()</kbd> function. In step 2, we do the alignment with the <kbd>pdbaln()</kbd> function. All the PDB objects we want to align are first put into a <strong>list</strong> object with the appropriate name. The <kbd>fit</kbd> argument is set to <kbd>TRUE</kbd> to carry out the superposition of the structures based on all the aligned sequences (the superposition being carried out is sequence-based).</p>
<p>The <kbd>exefile</kbd> argument tells <kbd>pdbaln()</kbd> where to carry out the sequence-based alignment portion, as done here; a value of <kbd>"msa"</kbd> uses the aligners in the <strong>msa</strong> package, but you can use a path to an alternative executable, or replace <kbd>exefile</kbd> with your valid email address using the <kbd>web.args="your.email@something.org"</kbd> form to carry out the alignment over the web at EBI.</p>
<p>Once we have an alignment object in <kbd>pdbs</kbd>, we can visualize it in PyMOL. We set the path to PyMOL in the <kbd>pymol_path</kbd> variable and pass that to the <kbd>pymol()</kbd> function along with the type set to <kbd>"launch"</kbd>, which will create an interactive PyMOL session. Alternatively, omitting <kbd>type</kbd> will result in a PyMOL script being written that you can use later. PyMol should show the picture that follows. <span>The screengrab shows the rendering of the two aligned proteins: the human version in red and the fly version in yellow:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-573 image-border" src="Images/1e6e656a-6628-4a81-acf7-c5ce4fa6debd.png" style="width:100.00em;height:80.25em;" width="1200" height="963"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's More...</h1>
                </header>
            
            <article>
                
<p>The <kbd>pdbaln()</kbd> function works well for structures of similar length. For structures with less equal PDBs, you can try the <kbd>struct.aln()</kbd> function.</p>


            </article>

            
        </section>
    </div>



  </body></html>