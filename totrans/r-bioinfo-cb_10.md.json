["```py\nif (!requireNamespace(\"BiocManager\"))\n    install.packages(\"BiocManager\")\n```", "```py\nBiocManager::install(\"package_name\")\n```", "```py\nlibrary(broom)\nmodel <- lm(mpg ~ cyl + qsec, data = mtcars)\ntidy(model) \naugment(model)\nglance(model)\n```", "```py\nt_test_result <- t.test(x = rnorm(20), y = rnorm(20) )\ntidy(t_test_result)\n```", "```py\nanova_result <- aov(Petal.Length ~ Species, data = iris)\ntidy(anova_result)\npost_hoc <- TukeyHSD(anova_result)\ntidy(post_hoc)\n```", "```py\nlibrary(biobroom)\nlibrary(Biobase)\nload(file.path(getwd(), \"datasets\", \"ch1\", \"modencodefly_eset.RData\") ) \ntidy(modencodefly.eset, addPheno = TRUE)\n```", "```py\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(magrittr)\nlibrary(ggplot2)\n\nnested_mt <- nest(mtcars, -cyl)\n```", "```py\nnested_mt_list_cols <- nested_mt %>% mutate(\n model = map(data, ~ lm(mpg ~ wt, data = .x))\n)\n```", "```py\nnested_mt_list_cols <- nested_mt_list_cols %>% mutate(\n tidy_model = map(model, tidy)\n)\n```", "```py\nunnest(nested_mt_list_cols, tidy_model)\n```", "```py\nmodels_df <- nest(mtcars, -cyl) %>%\n mutate(\n model = map(data, ~ lm(mpg ~ wt, data = .x)),\n tidy_model = map(model, tidy)\n ) %>%\n unnest(tidy_model)\n```", "```py\n A tibble: 3 x 2\n## cyl   data \n## <dbl> <list> \n## 1 6   <tibble [7 × 10]> \n## 2 4   <tibble [11 × 10]>\n## 3 8   <tibble [14 × 10]>\n```", "```py\n##  cyl   data              model \n##  <dbl> <list> <list>\n## 1 6   <tibble [7 × 10]>  <lm> \n## 2 4   <tibble [11 × 10]> <lm> \n## 3 8   <tibble [14 × 10]> <lm>\n```", "```py\n##  cyl   data              model  tidy_model \n## <dbl> <list>            <list>  <list> \n## 1 6   <tibble [7 × 10]>  <lm>   <tibble [2 × 5]>\n## 2 4   <tibble [11 × 10]> <lm>   <tibble [2 × 5]>\n## 3 8   <tibble [14 × 10]> <lm>   <tibble [2 × 5]>\n```", "```py\nreturn_single_value <- function(x){\n sum(x) \n}\niris %>% mutate(\n result = return_single_value(Petal.Length)\n)\n```", "```py\nreturn_length_values <- function(x){\n paste0(\"result_\", 1:length(x))\n}\niris %>% mutate(\n result = return_length_values(Petal.Length)\n)\n```", "```py\nreturn_three_values <- function(x){\n c(\"A\", \"b\", \"C\")\n}\niris %>% mutate(\n result = return_three_values(Petal.Length)\n)\n```", "```py\nrep_until <- function(x){\n rep(c(\"A\", \"b\", \"C\"), length.out = length(x))\n}\niris %>% mutate(\n result = rep_until(Petal.Length)\n)\n```", "```py\n## Sepal.Length Sepal.Width Petal.Length Petal.Width Species result \n## 1 5.1 3.5 1.4 0.2 setosa 563.7 \n## 2 4.9 3.0 1.4 0.2 setosa 563.7 \n## 3 4.7 3.2 1.3 0.2 setosa 563.7 \n## 4 4.6 3.1 1.5 0.2 setosa 563.7\n```", "```py\n## Sepal.Length Sepal.Width Petal.Length Petal.Width Species result \n## 1 5.1 3.5 1.4 0.2 setosa result_1 \n## 2 4.9 3.0 1.4 0.2 setosa result_2 \n## 3 4.7 3.2 1.3 0.2 setosa result_3 \n## 4 4.6 3.1 1.5 0.2 setosa result_4\n```", "```py\n## Sepal.Length Sepal.Width Petal.Length Petal.Width Species result \n## 1 5.1 3.5 1.4 0.2 setosa A \n## 2 4.9 3.0 1.4 0.2 setosa b \n## 3 4.7 3.2 1.3 0.2 setosa C \n## 4 4.6 3.1 1.5 0.2 setosa A \n## 5 5.0 3.6 1.4 0.2 setosa b\n```", "```py\nsetClass(\"BarcodedSummarizedExperiment\",\n   contains = \"SummarizedExperiment\",\n   slots = c(barcode_id = \"character\", barcode_sequence = \"character\")\n )\n```", "```py\nBarcodedSummarizedExperiment <- function(assays, rowRanges, colData, barcode_id, barcode_sequence){\n   new(\"BarcodedSummarizedExperiment\", \n       SummarizedExperiment(assays=assays, rowRanges=rowRanges, colData=colData),\n       barcode_id = barcode_id,\n       barcode_sequence = barcode_sequence\n   )\n}\n```", "```py\nsetGeneric(\"barcode_id\", function(x) standardGeneric(\"barcode_id\"))\nsetMethod(\"barcode_id\", \"BarcodedSummarizedExperiment\", function(x) x@barcode_id )\n```", "```py\nnrows <- 200\nncols <- 6\ncounts <- matrix(runif(nrows * ncols, 1, 1e4), nrows)\nassays <- list(counts = counts)\nrowRanges <- GRanges(    rep(c(\"chr1\", \"chr2\"), c(50, 150)),\n                         IRanges(floor(runif(200, 1e5, 1e6)), width=100),\n                         strand=sample(c(\"+\", \"-\"), 200, TRUE),\n                         feature_id=sprintf(\"ID%03d\", 1:200)\n)\ncolData <- DataFrame(\n                Treatment=rep(c(\"ChIP\", \"Input\"), 3),\n                row.names=LETTERS[1:6]\n)\n\nmy_new_barcoded_experiment <- BarcodedSummarizedExperiment(\n        assays = assays, \n        rowRanges = rowRanges, \n        colData = colData, \n        barcode_id = letters[1:6], \n        barcode_sequence = c(\"AT\", \"GC\", \"TA\", \"CG\",\"GA\", \"TC\") \n)\n```", "```py\nbarcode_id(my_new_barcoded_experiment)\n```", "```py\n---\ntitle: \"R Markdown Report\"\nauthor: \"R Bioinformatics Cookbook\"\ndate: \"`r format(Sys.time(), '%d %B, %Y')`\"\noutput:\n html_document:\n df_print: paged\n bookdown::html_document2:\n fig_caption: yes\n keep_md: yes\n toc: yes\n---\n```", "```py\nWe can include text and create code blocks, the code gets executed and the result passed in\n\n```", "```py\n```", "```py\n## We can format text using Markdown\nWe can create many text formats including *italics* and **bold**,\nWe can make lists \n 1\\. First item\n 2\\. Second item\n```", "```py\nThe whole document acts as a single R session - so variables created in earlier blocks can still be used later.\nPlots are presented within the document. Options for blocks can be set in the header\n\n```", "```py\n```", "```py` ```", "```py` is code to be interpreted. Options for the block go inside the curly brackets—here, `{r}` means this should be an R code block (some other languages are supported too). The code in this block is run in a new R session, its output captured; and inserted immediately after the code block.\n\nIn *Step 3*, we create some plaintext with the `Markdown` tags. `##` gives us a line with a second-level heading, the `**starred**` text gives us different formatting options, and we can also create lists. Valid `Markdown` is interpreted and the reformatted text is passed into the eventual document.\n\nIn *Step 4*, we start with some more plaintext and follow with a new code block. The options for the code block are set in the curly brackets again—here, we set a width for figures in the plot. Note that the code in this block refers to variables created in an earlier block. Although the document creates a new R session without access to variables already in the usual console, the document itself is a single session so blocks can access earlier block's variables, allowing the code and text to be mixed up at whatever resolution the author requires. Finally, the resulting figure is inserted into the document just like code. \n\n# Making use of the apply family of functions\n\nProgramming in R can sometimes seem a bit tricky; the control flow and looping structures it has, are a bit more basic than in other languages. As many R functions are vectorized, the language actually has some features and functions; that mean we don't need to take the same low-level approach we may have learned in Python or other places. Instead, base R provides the `apply` functions to do the job of common looping tasks. These functions all have a loop inside them, meaning we don't need to specify the loop manually. In this recipe, we'll look at using some `apply` family functions with common data structures to loop over them and get a result. The common thread in all of the `apply` functions is that we have an input data structure that we're going to iterate over and some code (often wrapped in a function definition) that we're going to apply to each item of the structure.\n\n# Getting ready\n\nWe will only need base R functions and data for this recipe, so you are good to go!\n\n# How to do it...\n\nMaking use of the `apply` family of functions can be done using the following steps:\n\n1.  Create a matrix and use `apply` to work on it:\n\n```", "```py\n\n2.  Use `lapply` over the vector:\n\n```", "```py\n\n3.  Use `lapply` and `sapply` over the list:\n\n```", "```py\n\n4.  Use `lapply` over a dataframe:\n\n```", "```py\n\n# How it works...\n\n*Step 1* begins with the creation of a 10 x 10 matrix, with rows holding the same number and columns running from 1 to 10\\. Inspecting it makes it clear, as partly shown in the following output:\n\n```", "```py\n\nWe then use `apply()`: the first argument is the object to loop over, the second is the direction to loop in (or margin, 1 = rows, and 2 = columns), and the third is the code to apply. Here, it's the name of a built-in function, but it could be a custom one. Note it's the margin argument that affects the amount of data that is taken each time. Contrast the two `apply()` calls:\n\n```", "```py\n\nClearly, `margin = 1` is taking each row at a time, whereas `margin = 2` is taking the columns. In any case, `apply()` returns a vector of results, meaning the results must be of the same type each time. It is not the same shape as the input data.\n\nWith *Step 2*, we move onto using `lapply()`, which can loop over many types of data structures, but always returns a list with one member for each iteration. Because it's a list, each member can be of a different type. We start by creating a simple vector containing the integers 1 to 3 and a custom function that just creates a vector of random numbers of a given length. Then, we use `lapply()` to apply that function over the vector; the first argument to `lapply()` is the thing to iterate over, and the second is the code to apply. Note that the current value of the vector we're looping over is passed automatically to the called function as the argument. Inspecting the resulting list, we see the following:\n\n```", "```py\n\nWe get a list of one random number, then two, then three, reflecting the change in the original vector.\n\nIn *Step 3*, we see the difference between `lapply()` and `sapply()` when running over the same object. Recall `lapply()` always returns a list but `sapply()` can return a vector (`s` can be thought of as standing for *simplify*). We create a simple summary function to ensure we only get a single value back and `sapply()` can be used. Inspecting the results, we see the following:\n\n```", "```py\n\nFinally, in *Step 4*, we use `lapply()` over a dataframe, namely, the built-in `iris` data. By default, it applies to columns on a dataframe, applying the `mean()` function to each one in turn. Note the last two arguments (`trim` and `na.rm`) are not arguments for `lapply()`, though, it does look like it. In all of these functions, the arguments after the vector to iterate over and the code (in other words, argument positions 1 and 2) are all passed to the code being run—here, our `mean()` function. The column names of the dataframe are used as the member names for the list. You may recall that one of the columns in `iris` is categorical, so `mean()` doesn't make much sense. Inspect the result to see what `lapply()` has done in this case:\n\n```", "```py\n\nIt has returned `NA`. Also, it has generated a warning but not failed. This can be a source of bugs in later analyses.\n\nWith a simple list like this, we can also use `unlist()` to get a vector of the results:\n\n```"]