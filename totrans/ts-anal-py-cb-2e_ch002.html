<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Time Series Analysis with Python Cookbook, 2E - Second Edition</title>
<link rel="stylesheet" type="text/css" href="../override_v1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/><link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section id="getting-started-with-time-series-analysis" class="level1 pkt" data-number="2">
<h1 data-number="2">1 Getting Started with Time Series Analysis</h1>
<section id="join-our-book-community-on-discord" class="level2" data-number="2.1">
<h2 data-number="2.1">Join our book community on Discord</h2>
<p>
<img style="width:15rem" src="../media/file0.png" width="200" height="200"/>
</p>
<p><a href="https://packt.link/zmkOY">https://packt.link/zmkOY</a></p>
<p>When embarking on a journey to learn coding in <strong>Python</strong>, you will often find yourself following instructions to install packages and import libraries, followed by a flow of a code-along stream. Yet an often-neglected part of any data analysis or data science process is ensuring that the right development environment is in place. Therefore, it is critical to have the proper foundation from the beginning to avoid any future hassles, such as an overcluttered implementation or package conflicts and dependency crisis. Having the right environment setup will serve you in the long run when you complete your project, ensuring you are ready to package your deliverable in a reproducible and production-ready manner.</p>
<p>Such a topic may not be as fun and may feel administratively heavy as opposed to diving into the core topic or the project at hand. But it is this foundation that differentiates a seasoned developer from the pack. Like any project, whether it is a <strong>machine learning</strong> project, a <strong>data visualization</strong> project, or a <strong>data integration</strong> project, it all starts with planning and ensuring all the required pieces are in place before you even <strong>begin</strong> with the core development.</p>
<p>In this chapter, you will learn how to set up a <strong>Python virtual environment</strong>, and we will introduce you to two common approaches for doing so. The steps will cover commonly used environment and package management tools. This chapter is designed to be hands-on so that you avoid too much jargon and can dive into creating your virtual environments in an iterative and fun way.</p>
<p>As we progress throughout this book, there will be several new Python libraries that you will need to install specific to <strong>time series analysis</strong>, <strong>time series visualization</strong>, <strong>machine learning</strong>, and <strong>deep learning</strong> on time series data. It is advised that you don't skip this chapter, regardless of the temptation to do so, as it will help you establish the proper foundation for any code development that follows. By the end of this chapter, you will have mastered the necessary skills to create and manage your Python virtual environments using either <strong>conda</strong> or <strong>venv</strong>.</p>
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Development environment setup</li>
<li>Installing Python libraries</li>
<li>Installing JupyterLab and JupyterLab extensions</li>
</ul>
</section>
<section id="technical-requirements" class="level2" data-number="2.2">
<h2 data-number="2.2">Technical requirements</h2>
<p>In this chapter, you will be primarily using the command line. For macOS and Linux, this will be the default Terminal (<code>bash</code> or <code>zsh</code>), while on a Windows OS, you will use the <strong>Anaconda Prompt</strong>, which comes as part of the Anaconda or Miniconda installation. Installing Anaconda or Miniconda will be discussed in the following <em>Getting ready</em> section.</p>
<p>We will use <strong>Visual Studio Code</strong> for the IDE, which is available for free at <a href="https://code.visualstudio.com">https://code.visualstudio.com</a>. It supports Linux, Windows, and macOS.</p>
<p>Other valid alternative options that will allow you to follow along include the following:</p>
<ul>
<li><strong>Sublime Text</strong> at https://www.sublimetext.com</li>
<li><strong>Spyder</strong> at <a href="https://www.spyder-ide.org">https://www.spyder-ide.org</a></li>
<li><strong>PyCharm Community Edition</strong> at <a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></li>
<li><strong>Jupyter Notebook at</strong> <a href="https://jupyter.org">https://jupyter.org</a></li>
</ul>
<p>The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook">https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook</a></p>
</section>
<section id="development-environment-setup" class="level2" data-number="2.3">
<h2 data-number="2.3">Development environment setup</h2>
<p>As we dive into the various recipes provided in this book, you will be creating different Python virtual environments to install all your dependencies without impacting other Python projects.</p>
<p>You can think of a virtual environment as isolated buckets or folders, each with a Python interpreter and associated libraries. The following diagram illustrates the concept behind isolated, self-contained virtual environments, each with a different Python interpreter and different versions of packages and libraries installed:</p>
<figure>
<img src="../media/file1.jpg" alt="Figure 1.1: An example of three different Python virtual environments, one for each Python project" width="821" height="331"/><figcaption aria-hidden="true">Figure 1.1: An example of three different Python virtual environments, one for each Python project</figcaption>
</figure>
<p>If you installed Anaconda then these environments are typically stored and contained in separate folders inside the <code>envs</code> subfolder within the main Anaconda (or Miniconda) folder installation. As an example, on macOS, you can find the <code>envs</code> folder under <code>Users/&lt;yourusername&gt;/opt/anaconda3/envs/</code>. On Windows OS, it may look more like <code>C:\Users\&lt;yourusername&gt;\anaconda3\envs</code>. If you installed Miniconda, then the <code>main</code> folder will be <code>miniconda3</code> instead of <code>anaconda3</code>.</p>
<p>Each environment (folder) contains a <strong>Python interpreter</strong>, as specified during the creation of the environment, such as a Python 2.7.18 or Python 3.9 interpreter.</p>
<p>Generally speaking, upgrading your Python version or packages can lead to many undesired side effects if testing is not part of your strategy. A common practice is to replicate your current Python environment to perform the desired upgrades for testing purposes before deciding whether to move forward with the upgrades. This is the value that environment managers (<code>conda</code> or <code>venv</code>) and package managers (<code>conda</code> or <code>pip</code>) bring to your development and production deployment process.</p>
<section id="getting-ready" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1">Getting ready</h3>
<p>In this section, it is assumed that you have the latest Python version installed by doing one of the following:</p>
<ul>
<li>The recommended approach is to install through a Python distribution such as <strong>Anaconda</strong> (<a href="https://www.anaconda.com/products/distribution">https://www.anaconda.com/products/distribution</a>), which comes preloaded with all the essential packages and supports Windows, Linux, and macOS (including M1 support as of version 2022.05). Alternatively, you can install <strong>Miniconda</strong> (<a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a>) or <strong>Miniforge</strong> (<a href="https://github.com/conda-forge/miniforge">https://github.com/conda-forge/miniforge</a>).</li>
<li>Download an installer directly from the official Python site <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</li>
<li>If you are familiar with <strong>Docker</strong>, you can download the official Python image. You can visit Docker Hub to determine the desired image to pull <a href="https://hub.docker.com/_/python">https://hub.docker.com/_/python</a>. Similarly, <strong>Anaconda</strong> and <strong>Miniconda</strong> can be used with Docker by following the official instructions here : <a href="https://docs.anaconda.com/anaconda/user-guide/tasks/docker/">https://docs.anaconda.com/anaconda/user-guide/tasks/docker/</a></li>
</ul>
<p>At the time of writing, the latest Python version that's available is Python 3.11.3.</p>
<blockquote>
<p>LATEST PYTHON VERSION SUPPORTED IN ANACONDA</p>
<blockquote>
<p>The latest version of Anaconda, 2023.03, released on April 2023. By default, Anaconda will implement Python 3.10.9 as the base interpreter. In addition, you can create a Python virtual environment with Python version 3.11.3 using <code>conda create</code>, which you will see later in this recipe.</p>
</blockquote>
</blockquote>
<p>The simplest and most efficient way to get you up and running quickly and smoothly is to go with a Python distribution such as <em>Anaconda</em> or <em>Miniconda</em>. I would even go further and recommend that you go with Anaconda if you are a beginner.</p>
<p>If you are a macOS or Linux user, once you have Anaconda installed, you are pretty much all set for using your default Terminal. To verify the installation, open your Terminal and type the following:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda info</code></pre>
</div>
<p>The following screenshot shows the standard output when running <code>conda info</code>, which outlines information regarding the installed <code>conda</code> environment. You should be interested in the listed versions for both <code>conda</code> and Python:</p>
<figure>
<img src="../media/file2.png" alt="Figure 1.2 – Verifying Conda's installation on Linux (Ubuntu) using the Terminal" width="1175" height="626"/><figcaption aria-hidden="true">Figure 1.2 – Verifying Conda's installation on Linux (Ubuntu) using the Terminal</figcaption>
</figure>
<p>If you installed Anaconda on a Windows OS, you need to use the Anaconda Prompt. To launch it, you can type Anaconda in the Windows search bar and select one of the Anaconda Prompts listed (<strong>Anaconda Prompt</strong> or <strong>Anaconda PowerShell Prompt</strong>). Once <strong>Anaconda Prompt</strong> has been launched, you can run the <code>conda</code> <code>info</code> command.</p>
<figure>
<img src="../media/file3.png" alt="Figure 1.3: Verifying Conda's installation on Windows using the Anaconda Prompt" width="1017" height="600"/><figcaption aria-hidden="true">Figure 1.3: Verifying Conda's installation on Windows using the Anaconda Prompt</figcaption>
</figure>
</section>
<section id="how-to-do-it" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2">How to do it…</h3>
<p>In this recipe, I will cover two popular environment management tools. If you have Anaconda, Miniconda, or Miniforge installed, then <code>conda</code> should be your preferred choice since it provides both <em>package dependency management</em> and <em>environment management</em> for Python (and supports many other languages). On the other hand, the other option is using <code>venv</code>, which is a built-in Python module that provides <em>environment management</em> and requires no additional installation.</p>
<p>Both <code>conda</code> and <code>venv</code> allow you to create multiple virtual environments for your Python projects that may require different Python interpreters (for example, 3.4, 3.8, or 3.9) or different Python packages. In addition, you can create a sandbox virtual environment to experiment with new packages to understand how they work without affecting your base Python installation.</p>
<p>Creating a separate virtual environment for each project is a best practice taken by many developers and data science practitioners. Following this recommendation will serve you well in the long run, helping you avoid common issues when installing packages, such as package dependency conflicts.</p>
<section id="using-conda" class="level4" data-number="2.3.2.1">
<h4 data-number="2.3.2.1">Using Conda</h4>
<p>Start by opening your terminal (Anaconda Prompt for Windows):</p>
<ol>
<li>First, let's ensure that you have the latest <code>conda</code> version. This can be done by using the following command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>$ conda update conda</code></pre>
</div>
<p>The preceding code will update the conda package manager. This is helpful if you are using an existing installation. This way, you make sure you have the latest version.</p>
<ol>
<li>If you have Anaconda installed, then you can update to the latest version using the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda update anaconda</code></pre>
</div>
<ol>
<li>You will now create a new virtual environment named <code>py310</code> with a specific Python version, which in this case, is Python 3.10:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda create -n py310 python=3.10</code></pre>
</div>
<p>Here, <code>-n</code> is a shortcut for <code>--name</code>.</p>
<ol>
<li><code>conda</code> may identify additional packages that need to be downloaded and installed. You may be prompted on whether you want to proceed or not. Type <code>y</code> and then hit <em>Enter</em> to proceed.</li>
<li>You could have skipped the confirmation message in the preceding step by adding the <code>-y</code> option. Use this if you are confident in what you are doing and do not require the confirmation message, allowing <code>conda</code> to proceed immediately without prompting you for a response. You can update your command by adding the <code>-y</code> or <code>--yes</code> option, as shown in the following code:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda create -n py10 python=3.10 -y</code></pre>
</div>
<ol>
<li>Once the setup is complete, you will be ready to <em>activate</em> the new environment. Activating a Python environment means that our <strong>$PATH</strong> environment variable will be updated to point to the specified Python interpreter from the virtual environment (folder). You can confirm this using the <strong>echo</strong> command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ echo $PATH
&gt; /Users/tarekatwan/opt/anaconda3/bin:/Users/tarekatwan/opt/anaconda3/condabin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code></pre>
</div>
<p>The preceding code works on Linux and macOS. If you are using the Windows Anaconda Prompt you can use <code>echo %path%</code>. On the Anaconda PowerShell Prompt you can use <code>echo $env:path</code>.</p>
<p>Here, we can see that our <code>$PATH</code> variable is pointing to our base <code>conda</code> environment and not our newly created virtual environment.</p>
<ol>
<li>Now, activate your new <code>py310</code> environment and test the <code>$PATH</code> environment variable again. You will notice that it is now pointing to the <code>envs</code> folder – more specifically, the <code>py310/bin</code> subfolder:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate py39
$ echo $PATH
&gt; /Users/tarekatwan/opt/anaconda3/envs/py310/bin:/Users/tarekatwan/opt/anaconda3/condabin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code></pre>
</div>
<ol>
<li>Another way to confirm that our new virtual environment is the active environment is by running the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda info –envs</code></pre>
</div>
<p>The preceding command will list all the <code>conda</code> environments that have been created. Notice that <code>py310</code> is listed with an <code>*</code>, indicating it is the active environment. The following screenshot shows that we have four virtual environments and that <code>py310</code> is currently the active one:</p>
<figure>
<img src="../media/file4.png" alt="Figure 1.4: List of all Python virtual environments that have been created using conda in MacOS" width="520" height="147"/><figcaption aria-hidden="true">Figure 1.4: List of all Python virtual environments that have been created using conda in MacOS</figcaption>
</figure>
<ol>
<li>Once you activate a specific environment, any package you install will only be available in that isolated environment. For example, let's install the pandas library and specify which version to install in the <code>py310</code> environment. At the time of writing, pandas 2.0.1 is the latest version:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda install pandas=2.0.1</code></pre>
</div>
<p>Notice that <code>conda</code> will prompt you again for confirmation to let you know what additional package will be downloaded and installed. Here, conda is checking for all the dependencies that pandas 2.0.1 needs and is installing them for you. You can also skip this confirmation step by adding the <code>-y</code> or <code>--yes</code> option at the end of the statement.</p>
<p>The message will also point out the environment location where the installation will occur. The following is an example of a prompted message for installing pandas 2.0.1:</p>
<figure>
<img src="../media/file5.png" alt="Figure 1.5: Conda's confirmation prompt listing all the packages" width="1060" height="1049"/><figcaption aria-hidden="true">Figure 1.5: Conda's confirmation prompt listing all the packages</figcaption>
</figure>
<blockquote>
<p>If you get <code>PackagesNotFoundError</code> you may need to add the conda-forge channel to install the latest version of pandas (for example 2.0.1). You can accomplish this using the following command:</p>
<blockquote>
<p>$ conda config --add channels conda-forge</p>
</blockquote>
<blockquote>
<p>Conda-Forge provides builds for different platforms and architectures and will automatically pick the appropriate build for your platform and architecture.</p>
</blockquote>
<blockquote>
<p>As an example, if you want to specify a conda-forge build for MacOS ARM then you can specify the build as shown in the following:</p>
</blockquote>
<blockquote>
<p>$ conda config --add channels conda-forge/osx-arm64</p>
</blockquote>
</blockquote>
<ol>
<li>Once you press <em>y</em> and hit <em>Enter</em>, <code>conda</code> will begin downloading and installing these packages.</li>
<li>Once you are done working in the current <code>py310</code> environment, you can <code>deactivate</code> and return to the base Python as shown in the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda deactivate</code></pre>
</div>
<ol>
<li>If you no longer need the py310 environment and wish to delete it, you can do so with the <code>env remove</code> command. The command will completely delete the environment and all the installed libraries. In other words, it will delete (remove) the entire folder for that environment:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda env remove -n py310</code></pre>
</div>
</section>
<section id="using-venv" class="level4" data-number="2.3.2.2">
<h4 data-number="2.3.2.2">Using venv</h4>
<p>Once Python 3x has been installed, you get access to the built-in <code>venv</code> module, which allows you to create virtual environments (similar to <code>conda</code>). Notice that when using <code>venv</code>, you will need to provide a <em>path</em> to where you want the virtual environment (folder) to be created. If one isn't provided, it will be created in the current directory where you are running the command from. In the following code, we will create the virtual environment in the <code>Desktop</code> directory.</p>
<p>Follow these steps to create a new environment, install a package, and then delete the environment using <code>venv</code>:</p>
<ol>
<li>First, decide where you want to place the new virtual environment and specify the path. In this example, I have navigated to <code>Desktop</code> and ran the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ cd Desktop
$ python -m venv py310</code></pre>
</div>
<p>The preceding code will create a new py310 folder in the <code>Desktop</code> directory. The <code>py310</code> folder contains several subdirectories, the Python interpreter, standard libraries, and other supporting files. The folder structure is similar to how <code>conda</code> creates its environment folders in the <code>envs</code> directory.</p>
<ol>
<li>Let's activate the py310 environment and examine the $PATH environment variable to verify that it is active. The following script is for Linux and macOS (bash or zsh) and assumes you are running the command from the Desktop directory:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ source py310/bin/activate
$ echo $ PATH
&gt; /Users/tarekatwan/Desktop/py310/bin:/Users/tarekatwan/opt/anaconda3/bin:/Users/tarekatwan/opt/anaconda3/condabin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</code></pre>
</div>
<p>Here, we can see that the <code>py310</code> environment has been activated.</p>
<p>On Windows using Anaconda PowerShell Prompt, there is no <code>bin</code> subfolder, so you will need to run the command using the following syntax, again assuming you are running the command from the <code>Desktop</code> directory:</p>
<div class="C0-SHConPACKT">
<pre><code>$ .py310\Scripts\activate</code></pre>
</div>
<p>There are two activate files under the Scripts folders: <code>activate.bat</code> and <code>Activate.ps1</code> where the latter is to be used with Anaconda PowerShell Prompt instead of the Anaconda Windows Command Prompt. Generally, in PowerShell If you omit the file extension the right script will be executed. It is better though that you specify the proper file extension, for example specifying <code>Activate.ps1</code>, as shown in the following:</p>
<div class="C0-SHConPACKT">
<pre><code>.\py310\Scripts\Activate.ps1</code></pre>
</div>
<ol>
<li>Now, let's check which version has been installed by using the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ python --version
&gt; Python 3.10.10</code></pre>
</div>
<ol>
<li>Once you are done developing using the <strong>py310</strong> environment, you can deactivate it to return to the base Python environment using the <strong>deactivate</strong> command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ deactivate</code></pre>
</div>
<ol>
<li>If you no longer need the <code>py310</code> environment and wish to remove it, just delete the entire <code>py310</code> folder and that's it.</li>
</ol>
</section>
</section>
<section id="how-it-works" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3">How it works…</h3>
<p>Once a virtual environment is activated, you can validate the location of the active Python interpreter to confirm that you are using the right one. Earlier, you saw how the <code>$PATH</code> environment variable changes once you activate a virtual environment. You can achieve similar results using the <code>which</code> command in Linux and macOS, the <code>Get-Command</code> in Windows PowerShell, or the <code>where</code> command in Windows Command Prompt.</p>
<p>The following is an example on macOS or Linux:</p>
<div class="C0-SHConPACKT">
<pre><code>$ which python
&gt; /Users/tarekatwan/opt/anaconda3/envs/py310/bin/python</code></pre>
</div>
<p>The following is an example on Windows OS (PowerShell):</p>
<div class="C0-SHConPACKT">
<pre><code>$ where.exe python</code></pre>
</div>
<p>An alternative to where is the Get-Command as shown in the following:</p>
<div class="C0-SHConPACKT">
<pre><code>$ Get-Command python</code></pre>
</div>
<p>The commands will output the path to the active Python interpreter. The output of the preceding statements will show a different path, depending on whether the active environment was created with <code>conda</code> or <code>venv</code>. When activating a <code>conda</code> virtual environment, it will be inside the <code>envs</code> folder, as shown in the following on a MacOS:</p>
<p><code>/Users/tarekatwan/opt/anaconda3/envs/py310/bin/python</code></p>
<p>When activating a <code>venv</code> virtual environment, the path will be the same path that you provided when it was created, as shown here on a MacOS:</p>
<p><code>/Users/tarekatwan/Desktop/py310/bin/python</code></p>
<p>Any additional packages or libraries that you install after you have <em>activated</em> a virtual environment will be isolated from other environments and reside in the environment's folder structure.</p>
<p>If we compare the folder structures of both <code>venv</code> and <code>conda</code>, you can see similarities, as shown in the following screenshot:</p>
<figure>
<img src="../media/file6.png" alt="Figure 1.6: Comparing folder structures using conda and venv" width="738" height="574"/><figcaption aria-hidden="true">Figure 1.6: Comparing folder structures using conda and venv</figcaption>
</figure>
<p>Recall that when using <code>conda</code>, all environments will default to the <code>/envs/</code> location inside the <code>anaconda3/</code> or <code>minconda3/</code> directory. When using <code>venv</code>, you need to provide a path to specify where to create the directory or project; otherwise, it will default to the current directory that you used to run the command. Similarly, you can specify a different path using <code>conda</code> with the option <code>-p</code> or <code>--prefix</code>. Note that when using <code>venv</code>, you cannot specify the Python version since it relies on the active or base Python version being used to run the command. This is in contrast to <code>conda</code>, which allows you to specify a different Python version regardless of the <strong>base</strong> Python version installed. For example, the current Python version for the base environment is 3.10, and you can still create a 3.11.x environment using the following:</p>
<div class="C0-SHConPACKT">
<pre><code>conda create -n py311 python=3.11 -y</code></pre>
</div>
<p>The preceding code will create a new <code>py311</code> environment with Python 3.11.3.</p>
<p>Another advantage of <code>conda</code>, is that it provides two features: a <em>package and dependency manager</em> and a <em>virtual environment manager</em>. This means we can use the same <code>conda</code> environment to create additional environments using <code>conda create</code>, and install packages using <code>conda install &lt;package name&gt;</code>, which you will use in the next recipe, <em>Installing Python libraries</em>.</p>
<p>Keep in mind that when using <code>venv</code>, it is <em>only</em> a virtual environment manager, and you will still need to rely on <code>pip</code> as a package manager to install packages; for example, <code>pip install &lt;package name&gt;</code>.</p>
<p>Additionally, when using <code>conda</code> to install packages, it will check for any conflicts and will prompt you for any recommendations, including the need to upgrade, downgrade, or install additional package dependencies.</p>
<p>Lastly, an added benefit of using <code>conda</code> is that you can create environments for other languages and not just Python. This includes Julia, R, Lua, Scala, Java, and more.</p>
</section>
<section id="theres-more" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4">There's more…</h3>
<p>In the preceding examples, you were able to create Python virtual environments from scratch using either <code>conda </code>or<code> venv</code>. The virtual environments you created may not contain the desired packages yet, so you will need to specifically install such packages for your project. You will explore how you can install packages in the upcoming recipe “<em>Installing Python Libraries</em>”.</p>
<p>There are other ways to create your virtual environment in <code>conda</code> that we will discuss here.</p>
<section id="creating-a-virtual-environment-using-a-yaml-file" class="level4" data-number="2.3.4.1">
<h4 data-number="2.3.4.1">Creating a virtual environment using a YAML file</h4>
<p>You can create a virtual environment from a <strong>YAML</strong> file. This option gives greater control in defining many aspects of the environment, including all the packages that should be installed all in one step.</p>
<p>You can create a YAML file in VSCode. Here is an example of a YAML file (<code>env.yml</code>) that creates a <code>conda</code> environment labeled <code>tscookbook</code> using Python 3.10:</p>
<div class="C0-SHCodePACKT">
<pre><code># A YAML for creating a conda environment
# file: env.yml
# example creating an environment named tscookbook
name: tscookbook
channels:
  - conda-forge
  - defaults
dependencies:
  - python=3.10
  - pip
  # Data Analysis
  - statsmodels
  - scipy
  - pandas
  - numpy
  - tqdm
  # Plotting
  - matplotlib
  - seaborn
  # Machine learning
  - scikit-learn
  - jupyterlab</code></pre>
</div>
<p>To create your virtual environment using the <code>env.yml</code> file, you can use <code>conda env create </code>with the <strong></strong> <code>-f</code> or <code>--file</code> option like so:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda env create -f env.yml</code></pre>
</div>
<p>Once this process is completed, you can activate the environment:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate tscookbook</code></pre>
</div>
<p>You can also bootstrap your YAML file from an existing environment. This is very useful if you want to share your environment configurations with others or create a backup for later use. The following three commands will achieve the same results of exporting the <code>py310</code> conda environment to a YAML file named <code>env.yml</code>, using slightly different syntax options:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda env export -n py310 &gt; env.yml
$ conda env export -n py310 -f env.yml
$ conda env export –name py310 –file env.yml</code></pre>
</div>
<p>This will generate the <code>env.yml</code> file for you in the current directory.</p>
</section>
<section id="cloning-a-virtual-environment-from-another-environment" class="level4" data-number="2.3.4.2">
<h4 data-number="2.3.4.2">Cloning a virtual environment from another environment</h4>
<p>This is a great feature if you want to experiment with new packages or upgrade existing packages, but you do not want to risk breaking the existing code in your current project. Using the –clone option you can create a copy or a clone of your environment in one step. This achieves the same results as the previous examples of using <code>conda env export</code> to create a YAML file of an existing environment and then creating a new environment based on that YAML file. The following example will clone the <code>py310</code> conda environment to a new environment named <code>py310_clone</code>:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda create --name py310_clone --clone py310</code></pre>
</div>
</section>
</section>
<section id="see-also" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5">See also</h3>
<p>It is worth mentioning that Anaconda comes with another tool <strong>called anaconda-project</strong> to package your <code>conda</code> project artifacts and create a YAML file for reproducibility. This is ideal for creating, sharing, and ensuring reproducibility of your data science projects. Think of this as an alternative approach to developing your YAML manually. For more information, please reference the official GitHub repository here: <a href="https://github.com/Anaconda-Platform/anaconda-project">https://github.com/Anaconda-Platform/anaconda-project</a>.</p>
<p>For a list of arguments, you can type the following in your terminal:</p>
<div class="C0-SHConPACKT">
<pre><code>$ anaconda-project --help</code></pre>
</div>
<p>If you are using a machine that does not allow you to install any software or you are using an older machine with limited capacity or performance, then do not worry. There are other options so that you can follow the recipes in this book with hands-on practice.</p>
<p>Some alternative options that you can explore are as follows:</p>
<ul>
<li><strong>Google Colab</strong> a cloud-based platform to write and run Python code in notebooks that already have some of the most popular data science packages preinstalled, including <code>pandas</code>, <code>statsmodels</code>, <code>scikit-learn</code>, and <code>TensorFlow</code>. Colab allows you to install additional packages from within the notebook using <code>pip install</code>. A great feature of Colab is that you get the option to configure your notebook so that you can use a CPU, GPU, or TPU for free. You can explore Colab by going to <a href="https://colab.research.google.com/">https://colab.research.google.com/</a>.</li>
<li><strong>Kaggle Notebooks</strong>, similar to Colab, comprises hosted Jupyter notebooks with many of the most popular data science packages already preinstalled. It also allows you to <code>pip install</code> any additional packages that are required. For more information, please refer to <a href="https://www.kaggle.com/docs/notebooks">https://www.kaggle.com/docs/notebooks</a></li>
<li><strong>Replit</strong> offers a free, in-browser IDE that supports more than 50+ languages, including Python. All you need to do is create an account and create your new <code>replit</code> space by visiting <a href="https://replit.com/">https://replit.com/</a></li>
<li><strong>Binder</strong> an online open-source platform that allows you to turn a Git repository into a collection of interactive notebooks. You can explore Binder by visiting <a href="https://mybinder.org">https://mybinder.org</a></li>
<li><strong>Deepnote</strong>, similar to Colab, is an online platform to write, run, and collaborate on Python notebooks and offers a free plan which you can check out here <a href="https://deepnote.com">https://deepnote.com</a></li>
</ul>
</section>
</section>
<section id="installing-python-libraries" class="level2" data-number="2.4">
<h2 data-number="2.4">Installing Python libraries</h2>
<p>In the preceding recipe, you were introduced to the YAML environment configuration file, which allows you to create a Python virtual environment and all the necessary packages in one step using one line of code:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda env create -f env.yml</code></pre>
</div>
<p>Throughout this book, you will need to install several Python libraries to follow the recipes. There are several methods for installing Python libraries, which you will explore in this recipe.</p>
<section id="getting-ready-1" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1">Getting ready</h3>
<p>You will create and use different files in this recipe, including a <code>requirements.txt</code>, <code>environment_history.yml</code>, and other files. These files are available to download from the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook/tree/main/code/Ch1">https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook/tree/main/code/Ch1</a></p>
<p>In this chapter, you will become familiar with how to generate your <code>requirements.txt</code> file, as well as installing libraries in general.</p>
</section>
<section id="how-to-do-it-1" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2">How to do it…</h3>
<p>The easiest way to install a collection of libraries at once is by using a <code>requirements.txt</code> file.</p>
<p>In a nutshell, the <code>requirements.txt</code> file lists the Python libraries and their associated versions that you want to install. You can create your <code>requirements.txt</code> file manually or export it from an existing Python environment.</p>
<blockquote>
<p>The file does not need to be named <code>requirements.txt</code>, it is more of a naming convention and a very common one embraced by the Python community. Some tools, such as PyCharm, will autodetect the <code>requirements.txt</code> file if is placed in the root project directory.</p>
</blockquote>
<section id="using-conda-1" class="level4" data-number="2.4.2.1">
<h4 data-number="2.4.2.1">Using conda</h4>
<p>With <code>conda</code>, you have different options for installing our packages in bulk. You can either create a new environment and install all the packages listed in a <code>requirements.txt</code> file at once (using the <code>conda</code> <code>create</code> statement), or you can install the Python packages to an existing environment using the <code>requirements.txt</code> file (using the <code>conda install</code> statement):</p>
<ul>
<li><strong>Option 1</strong>: Create a new <code>conda</code> environment and install the libraries in one step. For example, you can create a new environment for each chapter and use the associated <code>requirements.txt</code> file. The following example will create a new environment named <code>ch1 </code>and install all the packages listed in the requirements.txt file:</li>
</ul>
<div class="C0-SHConPACKT">
<pre><code>$ conda create --name ch1 -f requirements.txt</code></pre>
</div>
<ul>
<li><strong>Option 2</strong>: Install the necessary libraries to an existing <code>conda</code> environment. In this example, you have an existing <code>timeseries</code> environment, which you will need to activate first and then install the libraries from the <code>requirements.txt</code> file:</li>
</ul>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate timeseries
$ conda install -f requirements.txt</code></pre>
</div>
</section>
<section id="using-venv-and-pip" class="level4" data-number="2.4.2.2">
<h4 data-number="2.4.2.2">Using venv and pip</h4>
<p>Since <code>venv</code> is just an environment manager, you will need to use <code>pip</code> as your package manager tool. You will start by using <code>venv</code> to create a new environment, and then use <code>pip</code> to install the packages:</p>
<ul>
<li>On <strong>MacOS/Linux</strong>: Create and then activate the <code>venv</code> environment before you install the packages:</li>
</ul>
<div class="C0-SHConPACKT">
<pre><code>$ python -m venv Desktopn/timeseries
$ source Desktop/timeseries/bin/activate
$ pip install -r requirements.txt</code></pre>
</div>
<ul>
<li>On <strong>Windows</strong>: Create and activate the <code>venv</code> environment and then install the packages:</li>
</ul>
<div class="C0-SHConPACKT">
<pre><code>$ python -m venv .\Desktop\timeseries
$ .\Desktop\timeseries\Scripts\activate
$ pip install -r requirements.txt</code></pre>
</div>
<p>Notice that in the preceding code for Windows, the <code>activate</code> file extension was not specified (either <code>.bat</code> or <code>.ps1</code>). This is valid and will work on either Windows Prompt or PowerShell.</p>
</section>
</section>
<section id="how-it-works-1" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3">How it works…</h3>
<p>In the preceding code, the <code>requirements.txt</code> file was provided so that you can install the necessary libraries.</p>
<p>But how can you generate your <code>requirements.txt</code> file?</p>
<p>There are two approaches to creating the <code>requirements.txt</code> file. Let's take a look at both.</p>
<section id="creating-the-file-manually" class="level4" data-number="2.4.3.1">
<h4 data-number="2.4.3.1">Creating the file manually</h4>
<p>Since it is a simple file format, you can create the file using any text editor, such as VSCode, and list the packages you want to install. If you do not specify the package version, then the latest version that's available will be considered for installation. See the following example for the <code>simple.txt</code> file:</p>
<div class="C0-SHCodePACKT">
<pre><code>pandas==1.4.2
matplotlib</code></pre>
</div>
<p>First, let's test out <code>venv</code> and <code>pip</code>. Run the following script (I am running this on a Mac):</p>
<div class="C0-SHConPACKT">
<pre><code>$ python -m venv ch1
$ source ch1/bin/activate
$ pip install -r simple.txt
$ pip list
Package         Version
--------------- -------
cycler          0.11.0
fonttools       4.33.3
kiwisolver      1.4.2
matplotlib      3.5.2
numpy           1.22.4
packaging       21.3
pandas          1.4.2
Pillow          9.1.1
pip             22.0.4
pyparsing       3.0.9
python-dateutil 2.8.2
pytz            2022.1
setuptools      58.1.0
six             1.16.0
$ deactivate</code></pre>
</div>
<p>What are those additional packages? These are based on the dependencies in <code>pandas</code> and <code>matplotlib</code> that <code>pip</code> identified and installed for us.</p>
<p>Now, let's use the same <code>simple.txt</code> file but using <code>conda</code> this time:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda create -n ch1  --file simple.txt python=3.10</code></pre>
</div>
<p>Once the installation is completed, you can activate the environment and list the packages that were installed:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate ch1
$ conda list</code></pre>
</div>
<p>You may notice that the list is pretty large. More packages are installed compared to the <code>pip</code> approach. You can get a count of the libraries that have been installed using the following command:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda list | wc -l
&gt; 54</code></pre>
</div>
<p>There are a few things to keep in mind here:</p>
<ul>
<li><code>conda</code> installs packages from the Anaconda repository, as well as from the Anaconda cloud.</li>
<li><code>pip</code> installs packages from <strong>Python Package Index (PyPI)</strong> repository.</li>
<li><code>conda</code> does a very thorough analysis of all the packages it plans to download and does a better job when it comes to version conflicts than <code>pip</code>.</li>
</ul>
</section>
<section id="bootstrapping-a-file" class="level4" data-number="2.4.3.2">
<h4 data-number="2.4.3.2">Bootstrapping a file</h4>
<p>The second option is to generate the <code>requirements.txt</code> file from an existing environment. This is very useful when you are recreating environments for future use or when sharing your list of packages and dependencies with others, to ensure reproducibility and consistency. Say you worked on a project and installed specific libraries and you want to ensure that when you share your code, other users can install the same libraries. This is where generating the <code>requirements.txt</code> file comes in handy. Similarly, the option to export the YAML environment configuration file was demonstrated earlier.</p>
<p>Let's see how this can be done in both <code>pip</code> and <code>conda</code>. Keep in mind that both methods will export the list of packages that are already installed and their current versions.</p>
<section id="venv-and-pip-freeze" class="level5" data-number="2.4.3.2.1">
<h5 data-number="2.4.3.2.1">venv and pip freeze</h5>
<p><code>pip freeze</code> allows you to export all pip-installed libraries in your environment. First, activate the <code>ch1</code> environment you created earlier with <code>venv</code>, then export the list of packages to a <code>requirements.txt</code> file. The following example is on macOS using the Terminal:</p>
<div class="C0-SHConPACKT">
<pre><code>$ source ch1/bin/activate
$ pip freeze &gt; requirements.txt
$ cat requirements.txt
&gt;&gt;&gt;
cycler==0.11.0
fonttools==4.33.3
kiwisolver==1.4.2
matplotlib==3.5.2
numpy==1.22.4
...</code></pre>
</div>
<p>Once done, you can run the <code>deactivate</code> command.</p>
</section>
<section id="conda" class="level5" data-number="2.4.3.2.2">
<h5 data-number="2.4.3.2.2">Conda</h5>
<p>Let's activate the environment we created earlier with <code>conda</code> (the <code>ch1</code> environment) and export the list of packages:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate ch1
$ conda list -e &gt; conda_requirements.txt
$ cat conda_requirements.txt
&gt;&gt;&gt;
# This file may be used to create an environment using:
# $ conda create --name &lt;env&gt; --file &lt;this file&gt;
# platform: osx-64
blas=1.0=mkl
bottleneck=1.3.4=py39h67323c0_0
brotli=1.0.9=hb1e8313_2
ca-certificates=2022.4.26=hecd8cb5_0
certifi=2022.5.18.1=py39hecd8cb5_0
cycler=0.11.0=pyhd3eb1b0_0
...</code></pre>
</div>
</section>
</section>
</section>
<section id="theres-more-1" class="level3" data-number="2.4.4">
<h3 data-number="2.4.4">There's more…</h3>
<p>When you exported the list of packages installed with <code>conda</code>, the <code>conda_requirements.txt</code> file contained a large list of packages. If you want to export only the packages that you explicitly installed (without the additional packages that conda added), then you can use the <code>conda env export</code> command with the <code>--from-history</code> flag:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate ch1
$ conda env export --from-history &gt; env.yml
$ cat env.yml
&gt;&gt;&gt;
name: ch1
channels:
  - defaults
dependencies:
  - matplotlib
  - pandas==1.2.0
prefix: /Users/tarek.atwan/opt/anaconda3/envs/ch1</code></pre>
</div>
<p>Note that you do not have to activate that environment first, as we have been doing so far. Instead, you can add the <code>-n</code> or <code>--name</code> option to specify the name of the environment. Otherwise, it will default to the currently active environment. This is what the modified script would look like:</p>
<div class="C0-SHConPACKT">
<pre><code>conda env export -n ch1 --from-history &gt; env.yml</code></pre>
</div>
</section>
<section id="see-also-1" class="level3" data-number="2.4.5">
<h3 data-number="2.4.5">See also</h3>
<ul>
<li>To find a list of all the available packages from Anaconda, you can visit <a href="https://docs.anaconda.com/anaconda/packages/pkg-docs/">https://docs.anaconda.com/anaconda/packages/pkg-docs/</a>.</li>
<li>To search for packages in the PyPI repository, you can visit <a href="https://pypi.org/">https://pypi.org/</a>.</li>
</ul>
</section>
</section>
<section id="installing-jupyterlab-and-jupyterlab-extensions" class="level2" data-number="2.5">
<h2 data-number="2.5">Installing JupyterLab and JupyterLab extensions</h2>
<p>Throughout this book, you can follow along using your favorite Python IDE (for example, PyCharm or Spyder) or text editor (for example, Visual Studio Code, Atom, or Sublime). There is another option based on the concept of notebooks that allows interactive learning through a web interface. More specifically, <strong>Jupyter Notebook</strong> or <strong>Jupyter Lab</strong> are the preferred methods for learning, experimenting, and following along with the recipes in this book. Interestingly, the name Jupyter is derived from the three programming languages: Julia, Python, and R. Alternatively, you can use Google's Colab, or Kaggle Notebooks. For more information, refer to the <em>See also</em> section from the <em>Development environment setup</em> recipe of this chapter. If you are not familiar with Jupyter Notebooks, you can get more information here: <a href="https://jupyter.org/">https://jupyter.org/</a>.</p>
<p>In this recipe, you will install Jupyter Notebook, JupyterLab, and additional JupyterLab extensions.</p>
<p>Additionally, you will learn how to install individual packages as opposed to the bulk approach we tackled in earlier recipes.</p>
<blockquote>
<p>USING CONDA IN FUTURE EXAMPLES</p>
<blockquote>
<p>Moving forward, when a new environment is created, the code will be written using <strong>conda</strong>. The previous recipes already covered the two different approaches to creating virtual environments (<strong>venv</strong> versus <strong>conda</strong>) and installing packages (<strong>pip</strong> versus <strong>conda</strong>), which should allow you to proceed with whichever choice you prefer.</p>
</blockquote>
</blockquote>
<section id="getting-ready-2" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1">Getting ready</h3>
<p>We will create a new environment and install the main packages needed for this chapter, primarily pandas:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda create -n timeseries python=3.9 pandas -y</code></pre>
</div>
<p>This code creates a new Python 3.9 environment named <code>timeseries</code>. The last portion of the statement lists the individual packages that you will be installing. If the list of packages is large, you should use a <code>requirements.txt</code> file instead. If there are a handful of packages, then they can be listed individually separated by spaces, as follows:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda create -n timeseries python=3.9 pandas matplotlib statsmodels -y</code></pre>
</div>
<p>Once the environment has been created and the packages have been installed, go ahead and activate it:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda activate timeseries</code></pre>
</div>
</section>
<section id="how-to-do-it-2" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2">How to do it…</h3>
<p>Now that we have created our environment and activated it, let's install Jupyter:</p>
<ol>
<li>Now that we have activated our environment, we can simply use <code>conda</code> <code>install</code> to install any additional packages that were not included in <code>conda create</code>:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ conda install jupyter -y</code></pre>
</div>
<ol>
<li>You can launch your JupyterLab instance by typing the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ jupyter lab</code></pre>
</div>
<p>Notice that this runs a local web server and launches the JupyterLab interface on your default browser, pointing to <code>localhost:8888/lab</code>. The following screenshot shows a similar screen that you would see in your terminal once you've typed in the preceding code:</p>
<figure>
<img src="../media/file7.jpg" alt="Figure 1.6: Launching JupyterLab will run a local web server" width="1380" height="399"/><figcaption aria-hidden="true">Figure 1.6: Launching JupyterLab will run a local web server</figcaption>
</figure>
<ol>
<li><p>To terminate the web server, press <em>Ctrl</em> + <em>C</em> twice on your terminal or click <strong>Shut Down</strong> from the <strong>File</strong> menu in the Jupyter GUI, as shown in the following screenshot:</p>
<figure>
<img src="../media/file8.jpg" alt="Figure 1.7: Shutting down the JupyterLab web server" width="741" height="649"/><figcaption aria-hidden="true">Figure 1.7: Shutting down the JupyterLab web server</figcaption>
</figure></li>
<li>Now, you can safely close your browser.</li>
<li>Notice that in the preceding example, when JupyterLab was initiated, it launched on your default browser. If you wish to use a different browser, you can update the code like so:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ jupyter lab --browser=chrome</code></pre>
</div>
<p>In this example, I am specifying that I want it to launch on Chrome as opposed to Safari, which is the default on my machine. You can change the value to your preferred browser, such as Firefox, Opera, Chrome, and so on.</p>
<p>In Windows OS, if the preceding code did not launch Chrome automatically, you will need to register the browser type using <code>webbrowser.register()</code>. To do so, first generate the Jupyter Lab configuration file using the following command:</p>
<div class="C0-SHConPACKT">
<pre><code>jupyter-lab --generate-config</code></pre>
</div>
<p>Open the <code>jupyter_lab_config.py</code> file and add the following on the top:</p>
<div class="C0-SHCodePACKT">
<pre><code>import webbrowser
webbrowser.register('chrome', None, webbrowser.GenericBrowser('C:\Program Files (x86)\Google\Chrome\Application\chrome.exe'))</code></pre>
</div>
<p>Save and close the file. You can rerun <code>jupyter lab --browser=chrome</code> and this should launch the Chrome browser.</p>
<ol>
<li>If you do not want the system to launch the browser automatically, you can do this with the following code:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ jupyter lab --no-browser</code></pre>
</div>
<p>The web server will start, and you can open any of your preferred browsers manually and just point it to <code>http://localhost:8888</code>.</p>
<p>If you are asked for a token, you can copy and paste the URL with the token as displayed in the Terminal, which looks like this:</p>
<div class="C0-SHCodePACKT">
<pre><code>To access the server, open this file in a browser:
        file:///Users/tarek.atwan/Library/Jupyter/runtime/jpserver-44086-open.html
    Or copy and paste one of these URLs:
        http://localhost:8888/lab?token=5c3857b9612aecd3
c34e9a40e5eac4509a6ccdbc8a765576
     or http://127.0.0.1:8888/lab?token=5c3857b9612aecd3
c34e9a40e5eac4509a6ccdbc8a765576</code></pre>
</div>
<ol>
<li>Lastly, if the default <code>port 8888</code> is in use or you wish to change the port, then you can add <code>-p</code> and specify the port number you desire, as shown in the following example. Here, I am instructing the web server to use <code>port 8890</code>:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ jupyter lab --browser=chrome --port 8890</code></pre>
</div>
<p>This will launch Chrome at <code>localhost:8890/lab</code>.</p>
<p>Notice that when JupyterLab launches, you only see one kernel in the <strong>Notebooks</strong>/<strong>Console</strong> sections. This is the base Python kernel. The expectation was to see two kernels reflecting the two environments we have: the base and the <code>timeseries</code> virtual environment. Let's check how many virtual environments we have with this command:</p>
<ol>
<li><p>The following screenshot shows the JupyterLab interface, with only one kernel. This belongs to the base environment:</p>
<figure>
<img src="../media/file9.jpg" alt="Figure 1.8: JupyterLab interface showing only one kernel, which belongs to the base environment" width="674" height="605"/><figcaption aria-hidden="true">Figure 1.8: JupyterLab interface showing only one kernel, which belongs to the base environment</figcaption>
</figure></li>
<li>The following screenshot shows the two Python environments:</li>
</ol>
<figure>
<img src="../media/file10.jpg" alt="Figure 1.9: Showing two Python environments" width="1482" height="224"/><figcaption aria-hidden="true">Figure 1.9: Showing two Python environments</figcaption>
</figure>
<p>We can see that the timeseries virtual environment is the active one.I</p>
<ol>
<li>You will need to install a Jupyter kernel for the new <code>timeseries</code> environment. First, shut down the web server (though it will still work even if you did not). Assuming you are still in the active <code>timeseries</code> Python environment, just type the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ python -m ipykernel install --user  --name timeseries --display-name "Time Series"
&gt; Installed kernelspec timeseries in /Users/tarek.atwan/Library/Jupyter/kernels/timeseries</code></pre>
</div>
<ol>
<li>We can check the number of kernels available for Jupyter using the following command:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ jupyter kernelspec list</code></pre>
</div>
<p>The following screenshot shows the <code>kernelspec</code> files that were created and their location:</p>
<figure>
<img src="../media/file11.jpg" alt="Figure 1.10: List of kernels available for Jupyter" width="1650" height="157"/><figcaption aria-hidden="true">Figure 1.10: List of kernels available for Jupyter</figcaption>
</figure>
<p>These act as pointers that connect the GUI to the appropriate environment to execute our Python code.</p>
<ol>
<li>Now, you can launch your JupyterLab again and notice the changes:</li>
</ol>
<div class="C0-SHConPACKT">
<pre><code>$ jupyter lab</code></pre>
</div>
<p>The following screen will appear once it has been launched:</p>
<figure>
<img src="../media/file12.jpg" alt="Figure 1.11: Notice now our Time Series kernel is available in JupyterLab" width="700" height="597"/><figcaption aria-hidden="true">Figure 1.11: Notice now our Time Series kernel is available in JupyterLab</figcaption>
</figure>
</section>
<section id="how-it-works-2" class="level3" data-number="2.5.3">
<h3 data-number="2.5.3">How it works…</h3>
<p>When you created the new <code>timeseries</code> environment and installed your desired packages using <code>conda install</code>, it created a new subfolder inside the <code>envs</code> folder to isolate the environment and packages installed from other environments, including the base environment. When executing the <code>jupyter notebook</code> or<code> jupyter lab</code> command from the base environment, it will need to read from a <code>kernelspec</code> file (JSON) to map to the available kernels in order to make them available. The <code>kernelspec</code> file can be created using <code>ipykernel</code>, like so:</p>
<div class="C0-SHConPACKT">
<pre><code>python -m ipykernel install --user  --name timeseries --display-name "Time Series"</code></pre>
</div>
<p>Here, <code>--name</code> refers to the environment name and <code>--display-name</code> refers to the display name in the Jupyter GUI, which can be anything you want. Now, any libraries that you install inside the <code>timeseries</code> environment can be accessed from Jupyter through the kernel (again, think of it as a mapping between the Jupyter GUI and the backend Python environment).</p>
</section>
<section id="theres-more-2" class="level3" data-number="2.5.4">
<h3 data-number="2.5.4">There's more…</h3>
<p>JupyterLab allows you to install several useful extensions. Some of these extensions are created and managed by Jupyter, while others are created by the community.</p>
<p>You can manage JupyterLab extensions in two ways: through the command line using <code>jupyter labextension install &lt;someExtension&gt;</code> or through the GUI using <strong>Extension Manager</strong>. The following screenshot shows what the Jupyter Extension Manager UI looks like:</p>
<figure>
<img src="../media/file13.jpg" alt="Figure 1.12: Clicking the extension manager icon in JupyterLab" width="685" height="429"/><figcaption aria-hidden="true">Figure 1.12: Clicking the extension manager icon in JupyterLab</figcaption>
</figure>
<p>Once you click <strong>Enable</strong>, you will see a list of available Jupyter extensions. To install an extension, just click on the <strong>Install</strong> button.</p>
<p>Some packages will require Node.js and <code>npm</code> to be installed first and you will see a warning similar to the following:</p>
<figure>
<img src="../media/file14.jpg" alt="Figure 1.13: Extension Installation Error when Node.js and npm are required" width="968" height="162"/><figcaption aria-hidden="true">Figure 1.13: Extension Installation Error when Node.js and npm are required</figcaption>
</figure>
<p>You can download and install Node.js directly from <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>.</p>
<p>Alternatively, you can use <code>conda</code> to install Node.js by using the following command:</p>
<div class="C0-SHConPACKT">
<pre><code>$ conda install -c conda-forge nodejs</code></pre>
</div>
</section>
<section id="see-also-2" class="level3" data-number="2.5.5">
<h3 data-number="2.5.5">See also</h3>
<ul>
<li>To learn more about JupyterLab extensions, please refer to the official documentation here: <a href="https://jupyterlab.readthedocs.io/en/stable/user/extensions.html">https://jupyterlab.readthedocs.io/en/stable/user/extensions.html</a>.</li>
<li>If you want to learn more about how JupyterLab extensions are created with example demos, please refer to the official GitHub repository here: <a href="https://github.com/jupyterlab/extension-examples">https://github.com/jupyterlab/extension-examples</a>.</li>
<li>In <em>step 9</em>, we manually installed the <code>kernelspec</code> files, which created the mapping between Jupyter and our <code>conda</code> environment. This process can be automated using <code>nb_conda</code>. For more information on the <code>nb_conda</code> project, please refer to the official GitHub repository here: <a href="https://github.com/Anaconda-Platform/nb_conda">https://github.com/Anaconda-Platform/nb_conda</a>.</li>
</ul>
</section>
</section>
</section>
</div>
</div>
</body>
</html>