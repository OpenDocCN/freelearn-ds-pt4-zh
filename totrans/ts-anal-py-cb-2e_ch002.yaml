- en: 1 Getting Started with Time Series Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
  prefs: []
  type: TYPE_NORMAL
- en: When embarking on a journey to learn coding in **Python**, you will often find
    yourself following instructions to install packages and import libraries, followed
    by a flow of a code-along stream. Yet an often-neglected part of any data analysis
    or data science process is ensuring that the right development environment is
    in place. Therefore, it is critical to have the proper foundation from the beginning
    to avoid any future hassles, such as an overcluttered implementation or package
    conflicts and dependency crisis. Having the right environment setup will serve
    you in the long run when you complete your project, ensuring you are ready to
    package your deliverable in a reproducible and production-ready manner.
  prefs: []
  type: TYPE_NORMAL
- en: Such a topic may not be as fun and may feel administratively heavy as opposed
    to diving into the core topic or the project at hand. But it is this foundation
    that differentiates a seasoned developer from the pack. Like any project, whether
    it is a **machine learning** project, a **data visualization** project, or a **data
    integration** project, it all starts with planning and ensuring all the required
    pieces are in place before you even **begin** with the core development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to set up a **Python virtual environment**,
    and we will introduce you to two common approaches for doing so. The steps will
    cover commonly used environment and package management tools. This chapter is
    designed to be hands-on so that you avoid too much jargon and can dive into creating
    your virtual environments in an iterative and fun way.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress throughout this book, there will be several new Python libraries
    that you will need to install specific to **time series analysis**, **time series
    visualization**, **machine learning**, and **deep learning** on time series data.
    It is advised that you don't skip this chapter, regardless of the temptation to
    do so, as it will help you establish the proper foundation for any code development
    that follows. By the end of this chapter, you will have mastered the necessary
    skills to create and manage your Python virtual environments using either **conda**
    or **venv**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Development environment setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Python libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing JupyterLab and JupyterLab extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you will be primarily using the command line. For macOS and
    Linux, this will be the default Terminal (`bash` or `zsh`), while on a Windows
    OS, you will use the **Anaconda Prompt**, which comes as part of the Anaconda
    or Miniconda installation. Installing Anaconda or Miniconda will be discussed
    in the following *Getting ready* section.
  prefs: []
  type: TYPE_NORMAL
- en: We will use **Visual Studio Code** for the IDE, which is available for free
    at [https://code.visualstudio.com](https://code.visualstudio.com). It supports
    Linux, Windows, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other valid alternative options that will allow you to follow along include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sublime Text** at https://www.sublimetext.com'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spyder** at [https://www.spyder-ide.org](https://www.spyder-ide.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyCharm Community Edition** at [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jupyter Notebook at** [https://jupyter.org](https://jupyter.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook)
  prefs: []
  type: TYPE_NORMAL
- en: Development environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we dive into the various recipes provided in this book, you will be creating
    different Python virtual environments to install all your dependencies without
    impacting other Python projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of a virtual environment as isolated buckets or folders, each
    with a Python interpreter and associated libraries. The following diagram illustrates
    the concept behind isolated, self-contained virtual environments, each with a
    different Python interpreter and different versions of packages and libraries
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: An example of three different Python virtual environments, one
    for each Python project](img/file1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: An example of three different Python virtual environments, one
    for each Python project'
  prefs: []
  type: TYPE_NORMAL
- en: If you installed Anaconda then these environments are typically stored and contained
    in separate folders inside the `envs` subfolder within the main Anaconda (or Miniconda)
    folder installation. As an example, on macOS, you can find the `envs` folder under
    `Users/<yourusername>/opt/anaconda3/envs/`. On Windows OS, it may look more like
    `C:\Users\<yourusername>\anaconda3\envs`. If you installed Miniconda, then the
    `main` folder will be `miniconda3` instead of `anaconda3`.
  prefs: []
  type: TYPE_NORMAL
- en: Each environment (folder) contains a **Python interpreter**, as specified during
    the creation of the environment, such as a Python 2.7.18 or Python 3.9 interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, upgrading your Python version or packages can lead to many
    undesired side effects if testing is not part of your strategy. A common practice
    is to replicate your current Python environment to perform the desired upgrades
    for testing purposes before deciding whether to move forward with the upgrades.
    This is the value that environment managers (`conda` or `venv`) and package managers
    (`conda` or `pip`) bring to your development and production deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, it is assumed that you have the latest Python version installed
    by doing one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach is to install through a Python distribution such as
    **Anaconda** ([https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution)),
    which comes preloaded with all the essential packages and supports Windows, Linux,
    and macOS (including M1 support as of version 2022.05). Alternatively, you can
    install **Miniconda** ([https://docs.conda.io/en/latest/miniconda.html](https://docs.conda.io/en/latest/miniconda.html))
    or **Miniforge** ([https://github.com/conda-forge/miniforge](https://github.com/conda-forge/miniforge)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download an installer directly from the official Python site [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are familiar with **Docker**, you can download the official Python image.
    You can visit Docker Hub to determine the desired image to pull [https://hub.docker.com/_/python](https://hub.docker.com/_/python).
    Similarly, **Anaconda** and **Miniconda** can be used with Docker by following
    the official instructions here : [https://docs.anaconda.com/anaconda/user-guide/tasks/docker/](https://docs.anaconda.com/anaconda/user-guide/tasks/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, the latest Python version that's available is Python
    3.11.3.
  prefs: []
  type: TYPE_NORMAL
- en: LATEST PYTHON VERSION SUPPORTED IN ANACONDA
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The latest version of Anaconda, 2023.03, released on April 2023\. By default,
    Anaconda will implement Python 3.10.9 as the base interpreter. In addition, you
    can create a Python virtual environment with Python version 3.11.3 using `conda
    create`, which you will see later in this recipe.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The simplest and most efficient way to get you up and running quickly and smoothly
    is to go with a Python distribution such as *Anaconda* or *Miniconda*. I would
    even go further and recommend that you go with Anaconda if you are a beginner.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a macOS or Linux user, once you have Anaconda installed, you are
    pretty much all set for using your default Terminal. To verify the installation,
    open your Terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the standard output when running `conda info`,
    which outlines information regarding the installed `conda` environment. You should
    be interested in the listed versions for both `conda` and Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Verifying Conda''s installation on Linux (Ubuntu) using the
    Terminal](img/file2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Verifying Conda's installation on Linux (Ubuntu) using the Terminal
  prefs: []
  type: TYPE_NORMAL
- en: If you installed Anaconda on a Windows OS, you need to use the Anaconda Prompt.
    To launch it, you can type Anaconda in the Windows search bar and select one of
    the Anaconda Prompts listed (**Anaconda Prompt** or **Anaconda PowerShell Prompt**).
    Once **Anaconda Prompt** has been launched, you can run the `conda` `info` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Verifying Conda''s installation on Windows using the Anaconda
    Prompt](img/file3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Verifying Conda''s installation on Windows using the Anaconda Prompt'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, I will cover two popular environment management tools. If you
    have Anaconda, Miniconda, or Miniforge installed, then `conda` should be your
    preferred choice since it provides both *package dependency management* and *environment
    management* for Python (and supports many other languages). On the other hand,
    the other option is using `venv`, which is a built-in Python module that provides
    *environment management* and requires no additional installation.
  prefs: []
  type: TYPE_NORMAL
- en: Both `conda` and `venv` allow you to create multiple virtual environments for
    your Python projects that may require different Python interpreters (for example,
    3.4, 3.8, or 3.9) or different Python packages. In addition, you can create a
    sandbox virtual environment to experiment with new packages to understand how
    they work without affecting your base Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a separate virtual environment for each project is a best practice
    taken by many developers and data science practitioners. Following this recommendation
    will serve you well in the long run, helping you avoid common issues when installing
    packages, such as package dependency conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Using Conda
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start by opening your terminal (Anaconda Prompt for Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s ensure that you have the latest `conda` version. This can be
    done by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will update the conda package manager. This is helpful if
    you are using an existing installation. This way, you make sure you have the latest
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Anaconda installed, then you can update to the latest version using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now create a new virtual environment named `py310` with a specific
    Python version, which in this case, is Python 3.10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `-n` is a shortcut for `--name`.
  prefs: []
  type: TYPE_NORMAL
- en: '`conda` may identify additional packages that need to be downloaded and installed.
    You may be prompted on whether you want to proceed or not. Type `y` and then hit
    *Enter* to proceed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could have skipped the confirmation message in the preceding step by adding
    the `-y` option. Use this if you are confident in what you are doing and do not
    require the confirmation message, allowing `conda` to proceed immediately without
    prompting you for a response. You can update your command by adding the `-y` or
    `--yes` option, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the setup is complete, you will be ready to *activate* the new environment.
    Activating a Python environment means that our **$PATH** environment variable
    will be updated to point to the specified Python interpreter from the virtual
    environment (folder). You can confirm this using the **echo** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works on Linux and macOS. If you are using the Windows Anaconda
    Prompt you can use `echo %path%`. On the Anaconda PowerShell Prompt you can use
    `echo $env:path`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that our `$PATH` variable is pointing to our base `conda` environment
    and not our newly created virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, activate your new `py310` environment and test the `$PATH` environment
    variable again. You will notice that it is now pointing to the `envs` folder –
    more specifically, the `py310/bin` subfolder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to confirm that our new virtual environment is the active environment
    is by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will list all the `conda` environments that have been
    created. Notice that `py310` is listed with an `*`, indicating it is the active
    environment. The following screenshot shows that we have four virtual environments
    and that `py310` is currently the active one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: List of all Python virtual environments that have been created
    using conda in MacOS](img/file4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: List of all Python virtual environments that have been created
    using conda in MacOS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you activate a specific environment, any package you install will only
    be available in that isolated environment. For example, let''s install the pandas
    library and specify which version to install in the `py310` environment. At the
    time of writing, pandas 2.0.1 is the latest version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `conda` will prompt you again for confirmation to let you know what
    additional package will be downloaded and installed. Here, conda is checking for
    all the dependencies that pandas 2.0.1 needs and is installing them for you. You
    can also skip this confirmation step by adding the `-y` or `--yes` option at the
    end of the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message will also point out the environment location where the installation
    will occur. The following is an example of a prompted message for installing pandas
    2.0.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Conda''s confirmation prompt listing all the packages](img/file5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Conda''s confirmation prompt listing all the packages'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get `PackagesNotFoundError` you may need to add the conda-forge channel
    to install the latest version of pandas (for example 2.0.1). You can accomplish
    this using the following command:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $ conda config --add channels conda-forge
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conda-Forge provides builds for different platforms and architectures and will
    automatically pick the appropriate build for your platform and architecture.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As an example, if you want to specify a conda-forge build for MacOS ARM then
    you can specify the build as shown in the following:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $ conda config --add channels conda-forge/osx-arm64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once you press *y* and hit *Enter*, `conda` will begin downloading and installing
    these packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are done working in the current `py310` environment, you can `deactivate`
    and return to the base Python as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you no longer need the py310 environment and wish to delete it, you can
    do so with the `env remove` command. The command will completely delete the environment
    and all the installed libraries. In other words, it will delete (remove) the entire
    folder for that environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using venv
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once Python 3x has been installed, you get access to the built-in `venv` module,
    which allows you to create virtual environments (similar to `conda`). Notice that
    when using `venv`, you will need to provide a *path* to where you want the virtual
    environment (folder) to be created. If one isn't provided, it will be created
    in the current directory where you are running the command from. In the following
    code, we will create the virtual environment in the `Desktop` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a new environment, install a package, and then
    delete the environment using `venv`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, decide where you want to place the new virtual environment and specify
    the path. In this example, I have navigated to `Desktop` and ran the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a new py310 folder in the `Desktop` directory.
    The `py310` folder contains several subdirectories, the Python interpreter, standard
    libraries, and other supporting files. The folder structure is similar to how
    `conda` creates its environment folders in the `envs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s activate the py310 environment and examine the $PATH environment variable
    to verify that it is active. The following script is for Linux and macOS (bash
    or zsh) and assumes you are running the command from the Desktop directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `py310` environment has been activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows using Anaconda PowerShell Prompt, there is no `bin` subfolder, so
    you will need to run the command using the following syntax, again assuming you
    are running the command from the `Desktop` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two activate files under the Scripts folders: `activate.bat` and
    `Activate.ps1` where the latter is to be used with Anaconda PowerShell Prompt
    instead of the Anaconda Windows Command Prompt. Generally, in PowerShell If you
    omit the file extension the right script will be executed. It is better though
    that you specify the proper file extension, for example specifying `Activate.ps1`,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check which version has been installed by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done developing using the **py310** environment, you can deactivate
    it to return to the base Python environment using the **deactivate** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you no longer need the `py310` environment and wish to remove it, just delete
    the entire `py310` folder and that's it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a virtual environment is activated, you can validate the location of the
    active Python interpreter to confirm that you are using the right one. Earlier,
    you saw how the `$PATH` environment variable changes once you activate a virtual
    environment. You can achieve similar results using the `which` command in Linux
    and macOS, the `Get-Command` in Windows PowerShell, or the `where` command in
    Windows Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example on macOS or Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example on Windows OS (PowerShell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative to where is the Get-Command as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands will output the path to the active Python interpreter. The output
    of the preceding statements will show a different path, depending on whether the
    active environment was created with `conda` or `venv`. When activating a `conda`
    virtual environment, it will be inside the `envs` folder, as shown in the following
    on a MacOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Users/tarekatwan/opt/anaconda3/envs/py310/bin/python`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When activating a `venv` virtual environment, the path will be the same path
    that you provided when it was created, as shown here on a MacOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Users/tarekatwan/Desktop/py310/bin/python`'
  prefs: []
  type: TYPE_NORMAL
- en: Any additional packages or libraries that you install after you have *activated*
    a virtual environment will be isolated from other environments and reside in the
    environment's folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compare the folder structures of both `venv` and `conda`, you can see
    similarities, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Comparing folder structures using conda and venv](img/file6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Comparing folder structures using conda and venv'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that when using `conda`, all environments will default to the `/envs/`
    location inside the `anaconda3/` or `minconda3/` directory. When using `venv`,
    you need to provide a path to specify where to create the directory or project;
    otherwise, it will default to the current directory that you used to run the command.
    Similarly, you can specify a different path using `conda` with the option `-p`
    or `--prefix`. Note that when using `venv`, you cannot specify the Python version
    since it relies on the active or base Python version being used to run the command.
    This is in contrast to `conda`, which allows you to specify a different Python
    version regardless of the **base** Python version installed. For example, the
    current Python version for the base environment is 3.10, and you can still create
    a 3.11.x environment using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a new `py311` environment with Python 3.11.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage of `conda`, is that it provides two features: a *package
    and dependency manager* and a *virtual environment manager*. This means we can
    use the same `conda` environment to create additional environments using `conda
    create`, and install packages using `conda install <package name>`, which you
    will use in the next recipe, *Installing Python libraries*.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when using `venv`, it is *only* a virtual environment manager,
    and you will still need to rely on `pip` as a package manager to install packages;
    for example, `pip install <package name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when using `conda` to install packages, it will check for any
    conflicts and will prompt you for any recommendations, including the need to upgrade,
    downgrade, or install additional package dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, an added benefit of using `conda` is that you can create environments
    for other languages and not just Python. This includes Julia, R, Lua, Scala, Java,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding examples, you were able to create Python virtual environments
    from scratch using either `conda` or `venv`. The virtual environments you created
    may not contain the desired packages yet, so you will need to specifically install
    such packages for your project. You will explore how you can install packages
    in the upcoming recipe “*Installing Python Libraries*”.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to create your virtual environment in `conda` that we will
    discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment using a YAML file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can create a virtual environment from a **YAML** file. This option gives
    greater control in defining many aspects of the environment, including all the
    packages that should be installed all in one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a YAML file in VSCode. Here is an example of a YAML file (`env.yml`)
    that creates a `conda` environment labeled `tscookbook` using Python 3.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To create your virtual environment using the `env.yml` file, you can use `conda
    env create` with the `-f` or `--file` option like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this process is completed, you can activate the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also bootstrap your YAML file from an existing environment. This is
    very useful if you want to share your environment configurations with others or
    create a backup for later use. The following three commands will achieve the same
    results of exporting the `py310` conda environment to a YAML file named `env.yml`,
    using slightly different syntax options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the `env.yml` file for you in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a virtual environment from another environment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a great feature if you want to experiment with new packages or upgrade
    existing packages, but you do not want to risk breaking the existing code in your
    current project. Using the –clone option you can create a copy or a clone of your
    environment in one step. This achieves the same results as the previous examples
    of using `conda env export` to create a YAML file of an existing environment and
    then creating a new environment based on that YAML file. The following example
    will clone the `py310` conda environment to a new environment named `py310_clone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is worth mentioning that Anaconda comes with another tool **called anaconda-project**
    to package your `conda` project artifacts and create a YAML file for reproducibility.
    This is ideal for creating, sharing, and ensuring reproducibility of your data
    science projects. Think of this as an alternative approach to developing your
    YAML manually. For more information, please reference the official GitHub repository
    here: [https://github.com/Anaconda-Platform/anaconda-project](https://github.com/Anaconda-Platform/anaconda-project).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of arguments, you can type the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you are using a machine that does not allow you to install any software or
    you are using an older machine with limited capacity or performance, then do not
    worry. There are other options so that you can follow the recipes in this book
    with hands-on practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some alternative options that you can explore are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Colab** a cloud-based platform to write and run Python code in notebooks
    that already have some of the most popular data science packages preinstalled,
    including `pandas`, `statsmodels`, `scikit-learn`, and `TensorFlow`. Colab allows
    you to install additional packages from within the notebook using `pip install`.
    A great feature of Colab is that you get the option to configure your notebook
    so that you can use a CPU, GPU, or TPU for free. You can explore Colab by going
    to [https://colab.research.google.com/](https://colab.research.google.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kaggle Notebooks**, similar to Colab, comprises hosted Jupyter notebooks
    with many of the most popular data science packages already preinstalled. It also
    allows you to `pip install` any additional packages that are required. For more
    information, please refer to [https://www.kaggle.com/docs/notebooks](https://www.kaggle.com/docs/notebooks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replit** offers a free, in-browser IDE that supports more than 50+ languages,
    including Python. All you need to do is create an account and create your new
    `replit` space by visiting [https://replit.com/](https://replit.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binder** an online open-source platform that allows you to turn a Git repository
    into a collection of interactive notebooks. You can explore Binder by visiting
    [https://mybinder.org](https://mybinder.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deepnote**, similar to Colab, is an online platform to write, run, and collaborate
    on Python notebooks and offers a free plan which you can check out here [https://deepnote.com](https://deepnote.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Python libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding recipe, you were introduced to the YAML environment configuration
    file, which allows you to create a Python virtual environment and all the necessary
    packages in one step using one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this book, you will need to install several Python libraries to follow
    the recipes. There are several methods for installing Python libraries, which
    you will explore in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will create and use different files in this recipe, including a `requirements.txt`,
    `environment_history.yml`, and other files. These files are available to download
    from the GitHub repository for this book: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook/tree/main/code/Ch1](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook/tree/main/code/Ch1)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will become familiar with how to generate your `requirements.txt`
    file, as well as installing libraries in general.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to install a collection of libraries at once is by using a `requirements.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the `requirements.txt` file lists the Python libraries and their
    associated versions that you want to install. You can create your `requirements.txt`
    file manually or export it from an existing Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: The file does not need to be named `requirements.txt`, it is more of a naming
    convention and a very common one embraced by the Python community. Some tools,
    such as PyCharm, will autodetect the `requirements.txt` file if is placed in the
    root project directory.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using conda
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With `conda`, you have different options for installing our packages in bulk.
    You can either create a new environment and install all the packages listed in
    a `requirements.txt` file at once (using the `conda` `create` statement), or you
    can install the Python packages to an existing environment using the `requirements.txt`
    file (using the `conda install` statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: Create a new `conda` environment and install the libraries in
    one step. For example, you can create a new environment for each chapter and use
    the associated `requirements.txt` file. The following example will create a new
    environment named `ch1` and install all the packages listed in the requirements.txt
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 2**: Install the necessary libraries to an existing `conda` environment.
    In this example, you have an existing `timeseries` environment, which you will
    need to activate first and then install the libraries from the `requirements.txt`
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using venv and pip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since `venv` is just an environment manager, you will need to use `pip` as
    your package manager tool. You will start by using `venv` to create a new environment,
    and then use `pip` to install the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On **MacOS/Linux**: Create and then activate the `venv` environment before
    you install the packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On **Windows**: Create and activate the `venv` environment and then install
    the packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding code for Windows, the `activate` file extension
    was not specified (either `.bat` or `.ps1`). This is valid and will work on either
    Windows Prompt or PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code, the `requirements.txt` file was provided so that you
    can install the necessary libraries.
  prefs: []
  type: TYPE_NORMAL
- en: But how can you generate your `requirements.txt` file?
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches to creating the `requirements.txt` file. Let's take
    a look at both.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the file manually
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since it is a simple file format, you can create the file using any text editor,
    such as VSCode, and list the packages you want to install. If you do not specify
    the package version, then the latest version that''s available will be considered
    for installation. See the following example for the `simple.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s test out `venv` and `pip`. Run the following script (I am running
    this on a Mac):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What are those additional packages? These are based on the dependencies in `pandas`
    and `matplotlib` that `pip` identified and installed for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the same `simple.txt` file but using `conda` this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is completed, you can activate the environment and list
    the packages that were installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that the list is pretty large. More packages are installed compared
    to the `pip` approach. You can get a count of the libraries that have been installed
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to keep in mind here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conda` installs packages from the Anaconda repository, as well as from the
    Anaconda cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip` installs packages from **Python Package Index (PyPI)** repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conda` does a very thorough analysis of all the packages it plans to download
    and does a better job when it comes to version conflicts than `pip`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping a file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second option is to generate the `requirements.txt` file from an existing
    environment. This is very useful when you are recreating environments for future
    use or when sharing your list of packages and dependencies with others, to ensure
    reproducibility and consistency. Say you worked on a project and installed specific
    libraries and you want to ensure that when you share your code, other users can
    install the same libraries. This is where generating the `requirements.txt` file
    comes in handy. Similarly, the option to export the YAML environment configuration
    file was demonstrated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this can be done in both `pip` and `conda`. Keep in mind that
    both methods will export the list of packages that are already installed and their
    current versions.
  prefs: []
  type: TYPE_NORMAL
- en: venv and pip freeze
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`pip freeze` allows you to export all pip-installed libraries in your environment.
    First, activate the `ch1` environment you created earlier with `venv`, then export
    the list of packages to a `requirements.txt` file. The following example is on
    macOS using the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once done, you can run the `deactivate` command.
  prefs: []
  type: TYPE_NORMAL
- en: Conda
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let''s activate the environment we created earlier with `conda` (the `ch1`
    environment) and export the list of packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you exported the list of packages installed with `conda`, the `conda_requirements.txt`
    file contained a large list of packages. If you want to export only the packages
    that you explicitly installed (without the additional packages that conda added),
    then you can use the `conda env export` command with the `--from-history` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you do not have to activate that environment first, as we have been
    doing so far. Instead, you can add the `-n` or `--name` option to specify the
    name of the environment. Otherwise, it will default to the currently active environment.
    This is what the modified script would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find a list of all the available packages from Anaconda, you can visit [https://docs.anaconda.com/anaconda/packages/pkg-docs/](https://docs.anaconda.com/anaconda/packages/pkg-docs/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To search for packages in the PyPI repository, you can visit [https://pypi.org/](https://pypi.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing JupyterLab and JupyterLab extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this book, you can follow along using your favorite Python IDE (for
    example, PyCharm or Spyder) or text editor (for example, Visual Studio Code, Atom,
    or Sublime). There is another option based on the concept of notebooks that allows
    interactive learning through a web interface. More specifically, **Jupyter Notebook**
    or **Jupyter Lab** are the preferred methods for learning, experimenting, and
    following along with the recipes in this book. Interestingly, the name Jupyter
    is derived from the three programming languages: Julia, Python, and R. Alternatively,
    you can use Google''s Colab, or Kaggle Notebooks. For more information, refer
    to the *See also* section from the *Development environment setup* recipe of this
    chapter. If you are not familiar with Jupyter Notebooks, you can get more information
    here: [https://jupyter.org/](https://jupyter.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will install Jupyter Notebook, JupyterLab, and additional
    JupyterLab extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will learn how to install individual packages as opposed to
    the bulk approach we tackled in earlier recipes.
  prefs: []
  type: TYPE_NORMAL
- en: USING CONDA IN FUTURE EXAMPLES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moving forward, when a new environment is created, the code will be written
    using **conda**. The previous recipes already covered the two different approaches
    to creating virtual environments (**venv** versus **conda**) and installing packages
    (**pip** versus **conda**), which should allow you to proceed with whichever choice
    you prefer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a new environment and install the main packages needed for this
    chapter, primarily pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a new Python 3.9 environment named `timeseries`. The last
    portion of the statement lists the individual packages that you will be installing.
    If the list of packages is large, you should use a `requirements.txt` file instead.
    If there are a handful of packages, then they can be listed individually separated
    by spaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the environment has been created and the packages have been installed,
    go ahead and activate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have created our environment and activated it, let''s install Jupyter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have activated our environment, we can simply use `conda` `install`
    to install any additional packages that were not included in `conda create`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can launch your JupyterLab instance by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this runs a local web server and launches the JupyterLab interface
    on your default browser, pointing to `localhost:8888/lab`. The following screenshot
    shows a similar screen that you would see in your terminal once you''ve typed
    in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Launching JupyterLab will run a local web server](img/file7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Launching JupyterLab will run a local web server'
  prefs: []
  type: TYPE_NORMAL
- en: 'To terminate the web server, press *Ctrl* + *C* twice on your terminal or click
    **Shut Down** from the **File** menu in the Jupyter GUI, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.7: Shutting down the JupyterLab web server](img/file8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.7: Shutting down the JupyterLab web server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can safely close your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that in the preceding example, when JupyterLab was initiated, it launched
    on your default browser. If you wish to use a different browser, you can update
    the code like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I am specifying that I want it to launch on Chrome as opposed
    to Safari, which is the default on my machine. You can change the value to your
    preferred browser, such as Firefox, Opera, Chrome, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows OS, if the preceding code did not launch Chrome automatically, you
    will need to register the browser type using `webbrowser.register()`. To do so,
    first generate the Jupyter Lab configuration file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `jupyter_lab_config.py` file and add the following on the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Save and close the file. You can rerun `jupyter lab --browser=chrome` and this
    should launch the Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want the system to launch the browser automatically, you can
    do this with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The web server will start, and you can open any of your preferred browsers manually
    and just point it to `http://localhost:8888`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are asked for a token, you can copy and paste the URL with the token
    as displayed in the Terminal, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, if the default `port 8888` is in use or you wish to change the port,
    then you can add `-p` and specify the port number you desire, as shown in the
    following example. Here, I am instructing the web server to use `port 8890`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will launch Chrome at `localhost:8890/lab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when JupyterLab launches, you only see one kernel in the **Notebooks**/**Console**
    sections. This is the base Python kernel. The expectation was to see two kernels
    reflecting the two environments we have: the base and the `timeseries` virtual
    environment. Let''s check how many virtual environments we have with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the JupyterLab interface, with only one kernel.
    This belongs to the base environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.8: JupyterLab interface showing only one kernel, which belongs to
    the base environment](img/file9.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.8: JupyterLab interface showing only one kernel, which belongs to
    the base environment'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows the two Python environments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9: Showing two Python environments](img/file10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Showing two Python environments'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the timeseries virtual environment is the active one.I
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to install a Jupyter kernel for the new `timeseries` environment.
    First, shut down the web server (though it will still work even if you did not).
    Assuming you are still in the active `timeseries` Python environment, just type
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the number of kernels available for Jupyter using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `kernelspec` files that were created and
    their location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: List of kernels available for Jupyter](img/file11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: List of kernels available for Jupyter'
  prefs: []
  type: TYPE_NORMAL
- en: These act as pointers that connect the GUI to the appropriate environment to
    execute our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can launch your JupyterLab again and notice the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screen will appear once it has been launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: Notice now our Time Series kernel is available in JupyterLab](img/file12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Notice now our Time Series kernel is available in JupyterLab'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you created the new `timeseries` environment and installed your desired
    packages using `conda install`, it created a new subfolder inside the `envs` folder
    to isolate the environment and packages installed from other environments, including
    the base environment. When executing the `jupyter notebook` or `jupyter lab` command
    from the base environment, it will need to read from a `kernelspec` file (JSON)
    to map to the available kernels in order to make them available. The `kernelspec`
    file can be created using `ipykernel`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, `--name` refers to the environment name and `--display-name` refers to
    the display name in the Jupyter GUI, which can be anything you want. Now, any
    libraries that you install inside the `timeseries` environment can be accessed
    from Jupyter through the kernel (again, think of it as a mapping between the Jupyter
    GUI and the backend Python environment).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JupyterLab allows you to install several useful extensions. Some of these extensions
    are created and managed by Jupyter, while others are created by the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage JupyterLab extensions in two ways: through the command line
    using `jupyter labextension install <someExtension>` or through the GUI using
    **Extension Manager**. The following screenshot shows what the Jupyter Extension
    Manager UI looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Clicking the extension manager icon in JupyterLab](img/file13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Clicking the extension manager icon in JupyterLab'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click **Enable**, you will see a list of available Jupyter extensions.
    To install an extension, just click on the **Install** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some packages will require Node.js and `npm` to be installed first and you
    will see a warning similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Extension Installation Error when Node.js and npm are required](img/file14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Extension Installation Error when Node.js and npm are required'
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install Node.js directly from [https://nodejs.org/en/](https://nodejs.org/en/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `conda` to install Node.js by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about JupyterLab extensions, please refer to the official documentation
    here: [https://jupyterlab.readthedocs.io/en/stable/user/extensions.html](https://jupyterlab.readthedocs.io/en/stable/user/extensions.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to learn more about how JupyterLab extensions are created with
    example demos, please refer to the official GitHub repository here: [https://github.com/jupyterlab/extension-examples](https://github.com/jupyterlab/extension-examples).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *step 9*, we manually installed the `kernelspec` files, which created the
    mapping between Jupyter and our `conda` environment. This process can be automated
    using `nb_conda`. For more information on the `nb_conda` project, please refer
    to the official GitHub repository here: [https://github.com/Anaconda-Platform/nb_conda](https://github.com/Anaconda-Platform/nb_conda).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
