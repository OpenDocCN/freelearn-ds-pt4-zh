<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Time Series Analysis with Python Cookbook, 2E - Second Edition</title>
<link rel="stylesheet" type="text/css" href="../override_v1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/><link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section id="working-with-date-and-time-in-python" class="level1 pkt" data-number="7">
<h1 data-number="7">6 Working with Date and Time in Python</h1>
<section id="join-our-book-community-on-discord-5" class="level2" data-number="7.1">
<h2 data-number="7.1">Join our book community on Discord</h2>
<p>
<img style="width:15rem" src="../media/file0.png" width="200" height="200"/>
</p>
<p><a href="https://packt.link/zmkOY">https://packt.link/zmkOY</a></p>
<p>At the core of time-series data is <strong>time</strong>. <strong>Time-series data</strong> is a sequence of observations or data points captured in successive order and at regular time intervals. In the context of a pandas DataFrame, time-series data has an ordered index of type <code>DatetimeIndex</code>, as you have seen in earlier chapters. The <strong>DatetimeIndex</strong> offers an easy and efficient slicing, indexing, and time-based grouping of data.</p>
<p>Being familiar with manipulating date and time in time-series data is an essential component of time series analysis and modeling. In this chapter, you will find recipes for common scenarios when working with date and time in time-series data.</p>
<p>Python has several built-in modules for working with date and time, such as the <code>datetime</code>, <code>time</code>, <code>calendar</code>, and <code>zoneinfo</code> modules. Additionally, there are other popular libraries in Python that further extend the capability to work with and manipulate date and time, such as <code>dateutil</code>, <code>pytz</code>, and <code>arrow</code>, to name a few.</p>
<p>You will be introduced to the <code>datetime</code> module in this chapter but you will then transition to using <strong>pandas</strong> for enhanced and more complex date and time manipulation, and for generating time-series DataFrames with a sequence of <code>DatetimeIndex</code>. In addition, the <code>pandas</code> library contains several date-specific and time-specific classes that inherit from the aforementioned Python modules. In other words, you will not need to import additional date/time Python libraries.</p>
<p>You will be introduced to pandas classes such as <code>Timestamp</code>, <code>Timedelta</code>, <code>Period</code>, and <code>DateOffset</code>. You will notice similarities between the functionality – for example, the pandas <code>Timestamp</code> class is equivalent to Python's <code>Datetime</code> class and can be interchangeable in most scenarios. Similarly, <code>pandas.Timedelta</code> is equivalent to Python's <code>datetime.timedelta</code> object. The <code>pandas</code> library offers a more straightforward, intuitive, and powerful interface to handle most of your date and time manipulation needs without importing additional modules. When using pandas, you will appreciate having a library that contains everything you need to work with time-series data and can easily handle many challenging tasks.</p>
<p>Here is the list of the recipes that we will cover in this chapter:</p>
<ul>
<li>Working with <code>DatetimeIndex</code></li>
<li>Providing a format argument to <code>DateTime</code></li>
<li>Working with Unix epoch timestamps</li>
<li>Working with time deltas</li>
<li>Converting <code>DateTime</code> with time zone information</li>
<li>Working with date offsets</li>
<li>Working with custom business days</li>
</ul>
<p>In a real-world scenario, you may not use all or any of these techniques. Still, it is critical to be aware of the options when facing a particular scenario that requires certain adjustments or formatting of dates.</p>
</section>
<section id="technical-requirements-5" class="level2" data-number="7.2">
<h2 data-number="7.2">Technical requirements</h2>
<p>In this chapter and going forward, we will extensively use pandas 2.1.3 (released on November 10, 2023. This applies to all the recipes in this chapter.</p>
<p>Load these libraries in advance, since you will be using them throughout the chapter:</p>
<div class="C0-SHCodePACKT">
<pre><code>import pandas as pd
import numpy as np
import datetime as dt</code></pre>
</div>
<p>You will use <code>dt</code>, <code>np</code>, and <code>pd</code> aliases going forward.</p>
<p>You can download the Jupyter notebooks from the GitHub repository at <a href="https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6">https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6</a> to follow along.</p>
</section>
<section id="working-with-datetimeindex" class="level2" data-number="7.3">
<h2 data-number="7.3">Working with DatetimeIndex</h2>
<p>The <code>pandas</code> library has many options and features to simplify tedious tasks when working with time-series data, dates, and time.</p>
<p>When working with time-series data in Python, it is common to load into a pandas DataFrame with an index of type <code>DatetimeIndex</code>. As an index, the <code>DatetimeIndex</code> class extends pandas DataFrame capabilities to work more efficiently and intelligently with time-series data. This was demonstrated numerous times in <em>Chapter 2</em>, <em>Reading Time Series Data from Files</em>, and <em>Chapter 3</em>, <em>Reading Time Series Data from Databases</em>.</p>
<p>By the end of this recipe, you will appreciate pandas' rich set of date functionality to handle almost any representation of date/time in your data. Additionally, you will learn how to use different functions in pandas to convert date-like objects to a DatetimeIndex.</p>
<section id="how-to-do-it-20" class="level3" data-number="7.3.1">
<h3 data-number="7.3.1">How to do it…</h3>
<p>In this recipe, you will explore Python's <code>datetime</code> module and learn about the <code>Timestamp</code> and <code>DatetimeIndex</code> classes and the relationship between them.</p>
<ol>
<li>To understand the relationship between Python's <code>datetime.datetime</code> class and pandas' <code>Timestamp</code> and <code>DatetimeIndex</code> classes, you will create three different <code>datetime</code> objects representing the date <code>2021, 1, 1</code>. You will then compare these objects to gain a better understanding:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>dt1 = dt.datetime(2021,1,1)
dt2 = pd.Timestamp('2021-1-1')
dt3 = pd.to_datetime('2021-1-1')</code></pre>
</div>
<p>Inspect the datetime representation:</p>
<div class="C1-CodePACKT">
<pre><code>print(dt1)
print(dt2)
print(dt3)
&gt;&gt;
2021-01-01 00:00:00
2021-01-01 00:00:00
2021-01-01 00:00:00</code></pre>
</div>
<p>Inspect their data types:</p>
<div class="C1-CodePACKT">
<pre><code>print(type(dt1))
print(type(dt2))
print(type(dt3))
&gt;&gt;
&lt;class 'datetime.datetime'&gt;
&lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt;
&lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt;</code></pre>
</div>
<p>And finally, let's see how they compare:</p>
<div class="C1-SHCodePACKT">
<pre><code>dt1 == dt2 == dt3
&gt;&gt; True
isinstance(dt2, dt.datetime)
&gt;&gt; True   
isinstance(dt2, pd.Timestamp)
&gt;&gt; True
isinstance(dt1, pd.Timestamp)
&gt;&gt; False</code></pre>
</div>
<p>You can see from the preceding code that pandas' <code>Timestamp</code> object is equivalent to Python's <code>Datetime</code> object:</p>
<div class="C1-CodePACKT">
<pre><code>issubclass(pd.Timestamp, dt.datetime)
&gt;&gt; True</code></pre>
</div>
<p>Note that <code>dt2</code> is an instance of <code>pandas.Timestamp</code> class, and the <code>Timestamp</code> class is a subclass of Python's <code>dt.datetime</code> class (but not vice versa).</p>
<ol>
<li>When you used the <code>pandas.to_datetime()</code> function, it returned a <code>Timestamp</code> object. Now, use <code>pandas.to_datetime()</code> on a list and examine the outcome:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>dates = ['2021-1-1', '2021-1-2']
pd_dates = pd.to_datetime(dates)
print(pd_dates)
print(type(pd_dates))
&gt;&gt;
DatetimeIndex(['2021-01-01', '2021-01-02'], dtype='datetime64[ns]', freq=None)
&lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt;</code></pre>
</div>
<p>Interestingly, the output is now of type <code>DatetimeIndex</code> created using the same <code>pandas.to_datetime()</code> function that you used earlier. Previously, when using the same function on an individual object, the result was of type <code>Timestamp</code>, but when applied on a list, it produced a sequence of type <code>DatetimeIndex</code>. You will perform one more task to make things clearer.</p>
<p>Print out the first item (slice) from the <code>pd_dates</code> variable:</p>
<div class="C1-CodePACKT">
<pre><code>print(pd_dates[0])
print(type(pd_dates[0]))
&gt;&gt;
2021-01-01 00:00:00
&lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt;</code></pre>
</div>
<p>From the preceding output, you can infer a relationship between the two classes: <code>DatetimeIndex</code> and <code>Timestamp</code>. A DatetimeIndex is a sequence (list) of <code>Timestamp</code> objects.</p>
<ol>
<li>Now that you know how to create a <code>DatetimeIndex</code> using the <code>pandas.to_datetime()</code> function, let's further expand on this and see what else you can do with the function. For example, you will see how simple it is to convert different <code>datetime</code> representations, including strings, integers, lists, pandas series, or other <code>datetime</code> objects, into a <code>DatetimeIndex</code>.</li>
</ol>
<p>Let's create a <code>dates</code> list:</p>
<div class="C1-CodePACKT">
<pre><code>dates = ['2021-01-01',
         '2/1/2021',
         '03-01-2021',
         'April 1, 2021',
         '20210501',
          np.datetime64('2021-07-01'), # numpy datetime64
          datetime.datetime(2021, 8, 1), # python datetime
          pd.Timestamp(2021,9,1) # pandas Timestamp
          ]</code></pre>
</div>
<p>Parse the list using <code>pandas.to_datetime()</code>:</p>
<div class="C1-CodePACKT">
<pre><code>parsed_dates = pd.to_datetime(
                 dates,
                 infer_datetime_format=True,
                 errors='coerce'
                 )
print(parsed_dates)
&gt;&gt;
DatetimeIndex(['2021-01-01', '2021-02-01', '2021-03-01', '2021-04-01', '2021-05-01', '2021-07-01', '2021-08-01', '2021-09-01'],
              dtype='datetime64[ns]', freq=None)</code></pre>
</div>
<p>Notice how the <code>to_datetime()</code> function properly parsed the entire list of different string representations and date types such as Python's <code>Datetime</code> and NumPy's <code>datetime64</code>. Similarly, you could have used the <code>DatetimeIndex</code> constructor directly, as follows:</p>
<div class="C1-CodePACKT">
<pre><code>pd.DatetimeIndex(dates)</code></pre>
</div>
<p>This would produce similar results.</p>
<ol>
<li>The <code>DatetimeIndex</code> object gives access to many useful properties and methods to extract additional date and time properties. As an example, you can extract <code>day_name</code>, <code>month</code>, <code>year</code>, <code>days_in_month</code>, <code>quarter</code>, <code>is_quarter_start</code>, <code>is_leap_year</code>, <code>is_month_start</code>, <code>is_month_end</code>, and <code>is_year_start</code>. The following code shows how this can be done:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>print(f'Name of Day : {parsed_dates.day_name()}')
print(f'Month : {parsed_dates.month}')
print(f'Month Name: {parsed_dates.month_name()}')
print(f'Year : {parsed_dates.year}')
print(f'Days in Month : {parsed_dates.days_in_month}')
print(f'Quarter {parsed_dates.quarter}')
print(f'Is Quarter Start : {parsed_dates.is_quarter_start}')
print(f'Days in Month: {parsed_dates.days_in_month}')
print(f'Is Leap Year : {parsed_dates.is_leap_year}')
print(f'Is Month Start : {parsed_dates.is_month_start}')
print(f'Is Month End : {parsed_dates.is_month_end}')
print(f'Is Year Start : {parsed_dates.is_year_start}')</code></pre>
</div>
<p>The preceding code produces the following results:</p>
<div class="C1-CodePACKT">
<pre><code>Name of Day : Index(['Friday', 'Monday', 'Monday', 'Thursday', 'Saturday', 'Thursday',
       'Sunday', 'Wednesday'],
      dtype='object')
Month : Index([1, 2, 3, 4, 5, 7, 8, 9], dtype='int32')
Month Name: Index(['January', 'February', 'March', 'April', 'May', 'July', 'August',
       'September'],
      dtype='object')
Year : Index([2021, 2021, 2021, 2021, 2021, 2021, 2021, 2021], dtype='int32')
Days in Month : Index([31, 28, 31, 30, 31, 31, 31, 30], dtype='int32')
Quarter Index([1, 1, 1, 2, 2, 3, 3, 3], dtype='int32')
Is Quarter Start : [ True False False  True False  True False False]
Days in Month: Index([31, 28, 31, 30, 31, 31, 31, 30], dtype='int32')
Is Leap Year : [False False False False False False False False]
Is Month Start : [ True  True  True  True  True  True  True  True]
Is Month End : [False False False False False False False False]
Is Year Start : [ True False False False False False False False]</code></pre>
</div>
<p>These properties and methods will be very useful when transforming your time-series datasets for analysis.</p>
</section>
<section id="how-it-works-19" class="level3" data-number="7.3.2">
<h3 data-number="7.3.2">How it works…</h3>
<p>The, <code>pandas.to_datetime()</code> is a powerful function that can intelligently parse different date representations from strings. As you saw in <em>step 4</em> in the previous <em>How to do it…</em> section, the string examples, such as <code>'2021-01-01'</code>, <code>'2/1/2021'</code>, <code>'03-01-2021'</code>, <code>'April 1, 2021'</code>, and <code>'20210501'</code>, were parsed correctly. Other date representations such as <code>'April 1, 2021'</code> and '<code>1 April 2021'</code>, can be parsed using the <code>to_datetime()</code> function as well, and I'll leave it to you to explore additional examples that come to mind.</p>
<p>The <code>to_datetime</code> function contains the <code>errors</code> parameter. In the following example, you specify <code>errors='coerce'</code> which instructs pandas to set any value it could not parse as <code>NaT</code> indicating a missing value. You will learn more about <code>NaT</code> in the Performing data quality checks recipe in <em>Chapter 7</em>, <em>Handling Missing Data</em>.</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.to_datetime(
                 dates,
                 infer_datetime_format=True,
                 errors='coerce'
                 )</code></pre>
</div>
<p>In pandas, there are different representations to indicate missing values – <code>np.NaN</code> represents missing numeric values (<strong>Not a Number</strong>), while <code>pd.NaT</code> represents missing <code>datetime</code> values (<strong>Not a Time</strong>). Finally, pandas' <code>pd.NA</code> is used to represent missing scalar values (<strong>Not Available</strong>).</p>
<p>The <code>errors</code> parameter in <code>to_datetime</code> can take one of the three valid string options:</p>
<ul>
<li><code>raise</code>, which means it will raise an exception (<code>error out</code>).</li>
<li><code>coerce</code> will not cause it to raise an exception. Instead, it will just replace <code>pd.NaT</code>, indicating a missing datetime value.</li>
<li><code>ignore</code> will also not cause it to raise an exception. Instead, it will just pass in the original value.</li>
</ul>
<p>Here is an example using the <code>ignore</code> value:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.to_datetime(['something 2021', 'Jan 1, 2021'],
               errors='ignore')
&gt;&gt; Index(['something 2021', 'Jan 1, 2021'], dtype='object')</code></pre>
</div>
<p>When the errors parameter is set to <code>'ignore'</code>, pandas will not raise an error if it stumbles upon a date representation it cannot parse. Instead, the input value is passed as-is. For example, notice from the preceding output that the <code>to_datetime</code> function returned an <code>Index</code> type and not a <code>DatetimeIndex</code>. Further, the items in the Index sequence are of dtype <code>object</code> (and not <code>datetime64</code>). In pandas, the object dtype represents strings or mixed types.</p>
<p>Additionally, you explored how you an extract additional datetime properties using built-in properties and methods such as:</p>
<ul>
<li><strong>day_name():</strong> Returns the name of the day of the week (e.g., Monday, Tuesday).</li>
<li><strong>month</strong>: Provides the month component of the date as an integer (1 through 12).</li>
<li><strong>month_name():</strong> Returns the full name of the month (e.g., January, February).</li>
<li>year: Retrieves the year component of the date as an integer.</li>
<li><strong>days_in_month</strong>: Gives the number of days in the month for the given date.</li>
<li>quarter: Indicates the quarter of the year for the date (1 through 4).</li>
<li><strong>is_quarter_start</strong>: Boolean value indicating whether the date is the first day of a quarter (True or False).</li>
<li><strong>is_leap_year</strong>: Boolean value indicating whether the year of the date is a leap year (True or False).</li>
<li><strong>is_month_start</strong>: Boolean value indicating whether the date is the first day of its month (True or False).</li>
<li><strong>is_month_end</strong>: Boolean value indicating whether the date is the last day of its month (True or False).</li>
<li><strong>is_year_start</strong>: Boolean value indicating whether the date is the first day of its year (True or False).</li>
</ul>
</section>
<section id="theres-more-19" class="level3" data-number="7.3.3">
<h3 data-number="7.3.3">There’s more…</h3>
<p>An alternate way to generate a <code>DatetimeIndex</code> is with the <code>pandas.date_range()</code> function. The following code provides a starting date and the number of periods to generate and specifies a daily frequency with <code>D</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(start=‘2021-01-01’, periods=3, freq=‘D’)
&gt;&gt;
DatetimeIndex([‘2021-01-01’, ‘2021-01-02’, ‘2021-01-03’], dtype=‘datetime64[ns]’, freq=‘D’)</code></pre>
</div>
<p><code>pandas.date_range()</code> requires at least three of the four parameters to be provided – <code>start</code>, <code>end</code>, <code>periods</code>, and <code>freq</code>. If you do not provide enough information, you will get a <code>ValueError</code> exception with the following message:</p>
<div class="C0-SHCodePACKT">
<pre><code>ValueError: Of the four parameters: start, end, periods, and freq, exactly three must be specified</code></pre>
</div>
<p>Let’s explore the different parameter combinations required to use the <code>date_range</code> function. In the first example, provide a start date, end date, and specify a daily frequency. The function will always return a range of equally spaced time points:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(start=‘2021-01-01’,
               end=‘2021-01-03’,
               freq=‘D’)
&gt;&gt;
DatetimeIndex([‘2021-01-01’, ‘2021-01-02’, ‘2021-01-03’], dtype=‘datetime64[ns]’, freq=‘D’)</code></pre>
</div>
<p>In the second example, provide a start date and an end date, but instead of frequency, provide a number of periods. Remember that the function will always return a range of equally spaced time points:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(start=‘2021-01-01’,
               end=‘2021-01-03’,
               periods=2)
&gt;&gt;
DatetimeIndex([‘2021-01-01’, ‘2021-01-03’], dtype=‘datetime64[ns]’, freq=None)
pd.date_range(start=‘2021-01-01’,
               end=‘2021-01-03’,
               periods=4)
&gt;&gt;
DatetimeIndex([‘2021-01-01 00:00:00’, ‘2021-01-01 16:00:00’,
               ’2021-01-02 08:00:00’, ‘2021-01-03 00:00:00’],
              dtype=‘datetime64[ns]’, freq=None)</code></pre>
</div>
<p>In the following example, provide an end date and the number of periods returned, and indicate a daily frequency:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(end=‘2021-01-01’, periods=3, freq=‘D’)
DatetimeIndex([‘2020-12-30’, ‘2020-12-31’, ‘2021-01-01’], dtype=‘datetime64[ns]’, freq=‘D’)</code></pre>
</div>
<p>Note, the <code>pd.date_range()</code> function can work with a minimum of two parameters if the information is sufficient to generate equally spaced time points and infer the missing parameters. Here is an example of providing start and end dates only:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(start=‘2021-01-01’,
               end=‘2021-01-03’)
&gt;&gt;
DatetimeIndex([‘2021-01-01’, ‘2021-01-02’, ‘2021-01-03’], dtype=‘datetime64[ns]’, freq=‘D’)</code></pre>
</div>
<p>Notice that pandas was able to construct the date sequence using the start and end dates and default to daily frequency. Here is another example:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(start=‘2021-01-01’,
               periods=3)
&gt;&gt;
DatetimeIndex([‘2021-01-01’, ‘2021-01-02’, ‘2021-01-03’], dtype=‘datetime64[ns]’, freq=‘D’)</code></pre>
</div>
<p>With <code>start</code> and <code>periods</code>, pandas has enough information to construct the date sequence and default to daily frequency.</p>
<p>Now, here is an example that lacks enough information on how to generate the sequence and will cause pandas to throw an error:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.date_range(start=‘2021-01-01’,
               freq=‘D’)
&gt;&gt;
ValueError: Of the four parameters: start, end, periods, and freq, exactly three must be specified</code></pre>
</div>
<p>Note that with just a start date and frequency, pandas does not have enough information to construct the date sequence. Therefore, adding either <code>periods</code> or the <code>end</code> date will be sufficient.</p>
<p>Let’s put everything we have learned from generating a DatetimeIndex to extracting datatime properties. In the following example you will use date_range() function to create a DataFrame with one Date column. You will then create additional columns using the different properites and methods:</p>
<div class="C0-SHCodePACKT">
<pre><code>df = pd.DataFrame(pd.date_range(start=‘2021-01-01’,
               periods=5), columns=[‘Date’])
df[‘days_in_month’] = df[‘Date’].dt.days_in_month
df[‘day_name’] = df[‘Date’].dt.day_name()
df[‘month’] = df[‘Date’].dt.month
df[‘month_name’] = df[‘Date’].dt.month_name()
df[‘year’] = df[‘Date’].dt.year
df[‘days_in_month’] = df[‘Date’].dt.days_in_month
df[‘quarter’] = df[‘Date’].dt.quarter
df[‘is_quarter_start’] = df[‘Date’].dt.is_quarter_start
df[‘days_in_month’] = df[‘Date’].dt.days_in_month
df[‘is_leap_year’] = df[‘Date’].dt.is_leap_year
df[‘is_month_start’] = df[‘Date’].dt.is_month_start
df[‘is_month_end’] = df[‘Date’].dt.is_month_end
df[‘is_year_start’] = df[‘Date’].dt.is_year_start
df</code></pre>
</div>
<p>The preceding code should produce the following DataFrame</p>
<figure>
<img src="../media/file43.png" alt="Figure 6.1 A Time Series DataFrame with 5 rows and 12 columns" width="2188" height="342"/><figcaption aria-hidden="true">Figure 6.1 A Time Series DataFrame with 5 rows and 12 columns</figcaption>
</figure>
<blockquote>
<p>THE <code>Series.dt</code> ACCESSOR</p>
<blockquote>
<p>Notice the use of <code>.dt</code> accessor in the previous code example when working with a pandas <strong>Series</strong> of <em>datetime</em> object. The <code>.dt</code> accessor in pandas is a property used for accessing a wide range of datetime properties of a Series. In the previous example, you used <code>.dt</code> to access the datetime properties of the <code>df[‘Date’]</code> Series.</p>
</blockquote>
</blockquote>
</section>
<section id="see-also-21" class="level3" data-number="7.3.4">
<h3 data-number="7.3.4">See also</h3>
<p>To learn more about pandas' <code>to_datetime()</code> function and the <code>DatetimeIndex</code> class, please check out these resources:</p>
<ul>
<li><code>pandas.DatetimeIndex</code> documentation: <a href="https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html">https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html</a></li>
<li><code>pandas.to_datetime</code> documentation: <a href="https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html">https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html</a></li>
</ul>
</section>
</section>
<section id="providing-a-format-argument-to-datetime" class="level2" data-number="7.4">
<h2 data-number="7.4">Providing a format argument to DateTime</h2>
<p>When working with datasets extracted from different data sources, you may encounter date columns stored in string format, whether from files or databases. In the previous recipe, <em>Working with DatetimeIndex</em>, you explored the <code>pandas.to_datetime()</code> function that can parse various date formats with minimal input. However, you will want more granular control to ensure that the date is parsed correctly. For example, you will now be introduced to the <code>strptime</code> and <code>strftime</code> methods and see how you can specify formatting in <code>pandas.to_datetime()</code> to handle different date formats.</p>
<p>In this recipe, you will learn how to parse strings that represent dates to a <code>datetime</code> or <code>date</code> object (an instance of the class <code>datetime.datetime</code> or <code>datetime.date</code>).</p>
<section id="how-to-do-it-21" class="level3" data-number="7.4.1">
<h3 data-number="7.4.1">How to do it…</h3>
<p>Python's <code>datetime</code> module contains the <code>strptime()</code> method to create <code>datetime</code> or <code>date</code> from a string that contains a date. You will first explore how you can do this in Python and then extend this to pandas:</p>
<ol>
<li>Let's explore a few examples, parsing strings to <code>datetime</code> objects using <code>datetime.strptime</code>. You will parse four different representations of <code>January 1, 2022</code> that will produce the same output – <code>datetime.datetime(2022, 1, 1, 0, 0)</code>:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>dt.datetime.strptime('1/1/2022', '%m/%d/%Y')
dt.datetime.strptime('1 January, 2022', '%d %B, %Y')
dt.datetime.strptime('1-Jan-2022', '%d-%b-%Y')
dt.datetime.strptime('Saturday, January 1, 2022', '%A, %B %d, %Y')
&gt;&gt;
datetime.datetime(2022, 1, 1, 0, 0)</code></pre>
</div>
<p>Note that the output is a <code>datetime</code> object, representing the year, month, day, hour, and minute. You can specify only the date representation, as follows:</p>
<div class="C1-CodePACKT">
<pre><code>dt.datetime.strptime('1/1/2022', '%m/%d/%Y').date()
&gt;&gt;
datetime.date(2022, 1, 1)</code></pre>
</div>
<p>Now, you will have a <code>date</code> object instead of <code>datetime</code>. You can get the readable version of <code>datetime</code> using the <code>print()</code> function:</p>
<div class="C1-CodePACKT">
<pre><code>dt_1 = dt.datetime.strptime('1/1/2022', '%m/%d/%Y')
print(dt_1)
&gt;&gt;
2022-01-01 00:00:00</code></pre>
</div>
<ol>
<li>Now, let's compare what you did using the <code>datetime.strptime</code> method using <code>pandas.to_datetime</code> method:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>pd.to_datetime('1/1/2022', format='%m/%d/%Y')
pd.to_datetime('1 January, 2022', format='%d %B, %Y')
pd.to_datetime('1-Jan-2022', format='%d-%b-%Y')
pd.to_datetime('Saturday, January 1, 2022', format='%A, %B %d, %Y')
&gt;&gt;
Timestamp('2022-01-01 00:00:00')</code></pre>
</div>
<p>Similarly, you can get the string (readable) representation of the <code>Timestamp</code> object using the <code>print()</code> function:</p>
<div class="C1-CodePACKT">
<pre><code>dt_2 = pd.to_datetime('1/1/2022', format='%m/%d/%Y')
print(dt_2)
&gt;&gt;
2022-01-01 00:00:00</code></pre>
</div>
<ol>
<li>There is an advantage in using <code>pandas.to_datetime()</code> over Python's <code>datetime</code> module. The <code>to_datetime()</code> function can parse a variety of date representations, including string date formats with minimal input or specifications. The following code explains this concept; note that the <code>format</code> is omitted:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>pd.to_datetime('Saturday, January 1, 2022')
pd.to_datetime('1-Jan-2022')
&gt;&gt;
Timestamp('2022-01-01 00:00:00')</code></pre>
</div>
<p>Note that unlike <code>datetime</code>, which requires integer values or to use the <code>strptime</code> method for parsing strings, the <code>pandas.to_datetime()</code> function can intelligently parse different date representations without specifying a format (this is true in most cases).</p>
</section>
<section id="how-it-works-20" class="level3" data-number="7.4.2">
<h3 data-number="7.4.2">How it works…</h3>
<p>In this recipe, you used Python's <code>datetime.datetime</code> and <code>pandas.to_datetime</code> methods to parse dates in string formats. When using <code>datetime</code>, you had to use the <code>dt.datetime.strptime()</code> function to specify the date format representation in the string using format codes (example <code>%d</code>, <code>%B</code>, and <code>%Y</code>).</p>
<p>For example, in <code>datetime.strptime('1 January, 2022', '%d %B, %Y')</code>, you provided the <code>%d</code>, <code>%B</code>, and <code>%Y</code> format codes in the exact order and spacing to represent the formatting provided in the string. Let's break this down:</p>
<figure>
<img src="../media/file44.jpg" alt="Figure 6.2 – Understanding the format" width="302" height="134"/><figcaption aria-hidden="true">Figure 6.2 – Understanding the format</figcaption>
</figure>
<ul>
<li><code>%d</code> indicates that the first value is a zero-padded digit representing the day of the month, followed by a space to display spacing between the digit and the next object.</li>
<li><code>%B</code> is used to indicate that the second value represents the month's full name. Note that this was followed by a comma (<code>,</code>) to describe the exact format in the string, for example <code>"January,"</code>. Therefore, it is crucial to match the format in the strings you are parsing to include any commas, hyphens, backslashes, spaces, or whichever separator characters are used.</li>
<li>To adhere to the string format, there is a space after the comma (<code>,</code>), followed by <code>%Y</code> to reflect the last value represents a four-digit year.</li>
</ul>
<blockquote>
<p>FORMAT DIRECTIVES</p>
<blockquote>
<p>Remember that you always use the percent sign (<code>%</code>) followed by the format code (a letter with or without a negative sign). This is called a formatting directive. For example, lower case <code>y</code>, as in <code>%y</code>, represents the year <code>22</code> without the century, while uppercase <code>y</code>, as in <code>%Y</code>, represents the year <code>2022</code> with the century. Here is a list of common Python directives that can be used in the <code>strptime()</code> function<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes">: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes</a>.</p>
</blockquote>
</blockquote>
<p>Recall that you used <code>pandas.to_datetime()</code> to parse the same string objects as with <code>dt.datetime.strptime()</code>. The biggest difference is that the pandas function can accurately parse the strings without explicitly providing an argument to the format parameter. That is one of many advantages of using pandas for time-series analysis, especially when handling complex date and <code>datetime</code> scenarios.</p>
</section>
<section id="theres-more-20" class="level3" data-number="7.4.3">
<h3 data-number="7.4.3">There's more…</h3>
<p>Now you know how to use <code>pandas.to_datetime()</code> to parse string objects to <code>datetime</code>. So, let's see how you can apply this knowledge to transform a DataFrame column that contains date information in string format to a <code>datetime</code> data type.</p>
<p>In the following code, you will create a small DataFrame:</p>
<div class="C0-SHCodePACKT">
<pre><code>df = pd.DataFrame(
        {'Date': ['January 1, 2022', 'January 2, 2022', 'January 3, 2022'],
         'Sales': [23000, 19020, 21000]}
            )
df
&gt;&gt;
Date  Sales
0     January 1, 2022   23000
1     January 2, 2022   19020
2     January 3, 2022   21000
df.info()
&gt;&gt;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 3 entries, 0 to 2
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   Date    3 non-null      object
 1   Sales   3 non-null      int64
dtypes: int64(1), object(1)
memory usage: 176.0+ bytes</code></pre>
</div>
<p>To update the DataFrame to include a DatetimeIndex, you will parse the <code>Date</code> column to <code>datetime</code> and then assign it as an index to the DataFrame:</p>
<div class="C0-SHCodePACKT">
<pre><code>df['Date'] = pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)
df.info()
&gt;&gt;
&lt;class 'pandas.core.frame.DataFrame'&gt;
DatetimeIndex: 3 entries, 2022-01-01 to 2022-01-03
Data columns (total 1 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   Sales   3 non-null      int64
dtypes: int64(1)
memory usage: 48.0 bytes</code></pre>
</div>
<p>Note how the index is now of the <code>DatetimeIndex</code> type, and there is only one column in the DataFrame (<code>Sales</code>), since <code>Date</code> is now an index.</p>
</section>
<section id="see-also-22" class="level3" data-number="7.4.4">
<h3 data-number="7.4.4">See also</h3>
<p>To learn more about <code>pandas.to_datetime</code>, please visit the official documentation page here:<a href="https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html">https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html</a>.</p>
</section>
</section>
<section id="working-with-unix-epoch-timestamps" class="level2" data-number="7.5">
<h2 data-number="7.5">Working with Unix epoch timestamps</h2>
<p><strong>Epoch timestamps</strong>, sometimes referred to as <strong>Unix time</strong> or <strong>POSIX time</strong>, are a common way to store <code>datetime</code> in an <strong>integer</strong> <strong>format</strong>. This integer represents the number of seconds elapsed from a reference point, and in the case of a Unix-based timestamp, the reference point is <strong>January 1, 1970</strong>, at midnight (<strong>00:00:00 UTC</strong>). This arbitrary date and time represent the baseline, starting at <code>0</code>. So, we just increment in seconds for every second beyond that time.</p>
<p>Many databases, applications, and systems store dates and times in numeric format, making it mathematically easier to work with, convert, increment, decrement, and so on. Note that in the case of the <strong>Unix epoch</strong>, it is based on <strong>UTC</strong>, which stands for <strong>Universal Time Coordinated</strong>. Using UTC is a clear choice when building applications used globally, making it easier to store dates and timestamps in a standardized format. This makes it easier to work with dates and times without worrying about daylight saving or different time zones around the globe. UTC is the standard international time used in aviation systems, weather forecast systems, the International Space Station, and so on.</p>
<p>You will, at some point, encounter Unix epoch timestamps, and to make more sense of the data, you will need to convert it to a human-readable format. This is what will be covered in this recipe. Again, you will explore the ease of using pandas' built-in functions to work with Unix epoch timestamps.</p>
<section id="how-to-do-it-22" class="level3" data-number="7.5.1">
<h3 data-number="7.5.1">How to do it…</h3>
<p>Before we start converting the Unix time to a human-readable <code>datetime</code> object, which is the easy part, let's first gain some intuition about the idea of storing dates and time as a numeric object (a floating-point number):</p>
<ol>
<li>You will use time from the <code>time</code> module (part of Python) to request the current time in seconds. This will be the time in seconds since the epoch, which for Unix systems starts from January 1, 1970, at 00:00:00 UTC:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>import time
epoch_time = time.time()
print(epoch_time)
print(type(epoch_time))
&gt;&gt;
1700596942.589581
&lt;class 'float'&gt;</code></pre>
</div>
<ol>
<li>Now, copy the numeric value you have and visit <a href="https://www.epoch101.com">https://www.epoch101.com</a>. The website should display your current epoch time. If you scroll down, you can paste the number and convert it to a human-readable format. Make sure that you click on <strong>seconds</strong>, as shown in the following figure:</li>
</ol>
<figure>
<img src="../media/file45.png" alt="Figure 6.3: Converting a Unix timestamp to a human-readable format in both GMT and local time" width="1119" height="410"/><figcaption aria-hidden="true">Figure 6.3: Converting a Unix timestamp to a human-readable format in both GMT and local time</figcaption>
</figure>
<p>Note, the GMT format was given as <code>Tue, 21 Nov 2023 20:02:22 GMT</code> and my local format as <code>Wed Nov 22 2023, 00:02:22 GMT+0400 (Gulf Standard Time)</code>.</p>
<ol>
<li>Let's see how pandas converts the epoch timestamp. The convenience here is that you will be using the same <code>pandas.to_datetime()</code> function that you should be familiar with by now, as you have used it in the previous two recipes from this chapter. This is one of the many conveniences you get when using pandas. For example, in the following code, you will use <code>pandas.to_datetime()</code> to parse the Unix epoch <code>1700596942.589581</code>:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>import pandas as pd
t = pd.to_datetime(1700596942.589581, unit='s')
print(t)
&gt;&gt;
2023-11-21 20:02:22.589581056</code></pre>
</div>
<p>Note the need to specify units as seconds. The output is similar to that in <em>Figure 6.3</em> for the GMT format.</p>
<ol>
<li>If you want <code>datetime</code> to be time-zone aware – for example, the US/Pacific time zone – you can use <code>tz_localize('US/Pacific')</code>. To get a more accurate conversion though, it is better to do it in two steps:
<ol>
<li>Convert the time zone-naive object to UTC using <code>tz_localize('UTC')</code>.</li>
<li>Then, convert it to the desired time zone using <code>tz_convert()</code>.</li>
</ol></li>
</ol>
<p>The following code shows how this is done to convert to the Pacific time zone:</p>
<div class="C1-CodePACKT">
<pre><code>t.tz_localize('UTC').tz_convert('US/Pacific')
&gt;&gt;
Timestamp(2023-11-21 12:02:22.589581056-0800', tz='US/Pacific')</code></pre>
</div>
<ol>
<li>Let's put all of this together. You will convert a DataFrame that contains a <code>datetime</code> column in Unix epoch format to a human-readable format. You will start by creating a new DataFrame with Unix epoch timestamps:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df = pd.DataFrame(
        {'unix_epoch': [1641110340,  1641196740, 1641283140, 1641369540],
                'Sales': [23000, 19020, 21000, 17030]}
                )
df
&gt;&gt;
      unix_epoch  Sales
0     1641110340  23000
1     1641196740  19020
2     1641283140  21000
3     1641369540  17030</code></pre>
</div>
<ol>
<li>Create a new column, call it <code>Date</code> by parsing the <code>unix_epoch</code> column into a <code>datetime</code> (which defaults to GMT), then localize the output to UTC, and convert to a local time zone. Finally, set the <code>Date</code> column as the index:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['Date'] = pd.to_datetime(df['unix_epoch'], unit='s')
df['Date'] = df['Date'].dt.tz_localize('UTC').dt.tz_convert('US/Pacific')
df.set_index('Date', inplace=True)
df
&gt;&gt;                            unix_epoch  Sales
Date       
2022-01-01 23:59:00-08:00     1641110340  23000
2022-01-02 23:59:00-08:00     1641196740  19020
2022-01-03 23:59:00-08:00     1641283140  21000
2022-01-04 23:59:00-08:00     1641369540  17030</code></pre>
</div>
<p>Note that since the <code>Date</code> column was of the <code>datetime</code> type (not <code>DatetimeIndex</code>), you had to use the <code>Series.dt</code> accessor to tap into the built-in methods and attributes for the <code>datetime</code> objects. In the last step, you converted <code>datetime</code> to a <code>DatetimeIndex</code> object (a DataFrame index). If you recall from the <em>Working with DatetimeIndex</em> recipe of this chapter, a <code>DatetimeIndex</code> object can access any of the <code>datetime</code> methods and attributes without using the <code>dt</code> accessor.</p>
<ol>
<li>If you do not need the time in your index (<code>DatetimeIndex</code>), given your data is daily and there is no use case for using time, then you can request just the date, as shown in the following code:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df.index.date
&gt;&gt;
array([datetime.date(2022, 1, 1), datetime.date(2022, 1, 2), datetime.date(2022, 1, 3), datetime.date(2022, 1, 4)], dtype=object)</code></pre>
</div>
<p>Note that the output displays the date without time.</p>
</section>
<section id="how-it-works-21" class="level3" data-number="7.5.2">
<h3 data-number="7.5.2">How it works…</h3>
<p>Understanding Unix Epoch time is more relevant as one engages in technical fields where precise and standardized time representation is critical.</p>
<p>So far, you have used <code>pandas.to_datetime()</code> to parse dates in string format to a <code>datetime</code> object by leveraging the format attribute (see the <em>Providing a format argument to DateTime</em> recipe). In this recipe, you used the same function, but instead of providing a value to format, you passed a value to the unit parameter, as in <code>unit='s' </code>.</p>
<p>The <code>unit</code> parameter tells pandas which unit to use when calculating the difference from the epoch start. In this case, the request was in seconds. However, there is another critical parameter that you do not need to adjust (in most cases), which is the <code>origin</code> parameter. For example, the default value is <code>origin='unix'</code>, which indicates that the calculation should be based on the Unix (or POSIX) time set to <code>01-01-1970 00:00:00 UTC</code>.</p>
<p>This is what the actual code looks like:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.to_datetime(1635220133.855169, unit='s', origin='unix')
&gt;&gt;
Timestamp('2021-10-26 03:48:53.855169024')</code></pre>
</div>
<p>You can modify the <code>origin</code> to use a different reference date to calculate the datetime value. In the following example, the <code>unit</code> is specified to be in days and the origin is set at <code>January 1, 2023</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.to_datetime(45, unit='D', origin='2023-1-1')
&gt;&gt;
Timestamp('2023-02-15 00:00:00')</code></pre>
</div>
</section>
<section id="theres-more-21" class="level3" data-number="7.5.3">
<h3 data-number="7.5.3">There's more…</h3>
<p>If you would like to store your <code>datetime</code> value in Unix epoch, you can do this by subtracting <code>1970-01-01</code> and then floor-divide by a unit of <code>1</code> second. Python uses <code>/</code> as the division operator, <code>//</code> as the floor division operator to return the floored quotient, and <code>%</code> as the modulus operator to return the remainder from a division.</p>
<p>Start by creating a new pandas DataFrame:</p>
<div class="C0-SHCodePACKT">
<pre><code>df = pd.DataFrame(
        {'Date': pd.date_range('01-01-2022', periods=5),
        'order' : range(5)}
                 )
df
&gt;&gt;
      Date        order
0     2022-01-01    0
1     2022-01-02    1
2     2022-01-03    2
3     2022-01-04    3
4     2022-01-05    4</code></pre>
</div>
<p>You can then perform the transformation, as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>df['Unix Time'] = (df['Date'] -  pd.Timestamp("1970-01-01")) // pd.Timedelta("1s")
df
&gt;&gt;
      Date        order Unix Time
0     2022-01-01    0       1640995200
1     2022-01-02    1       1641081600
2     2022-01-03    2       1641168000
3     2022-01-04    3       1641254400
4     2022-01-05    4       1641340800</code></pre>
</div>
<p>You have now generated your Unix epochs. There are different ways to achieve similar results. The preceding example is the recommended approach from pandas, which you can read more about here: <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch.">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch.</a></p>
<p>You will learn more about <code>Timedelta</code> <a href="ch007.xhtml">in the next recipe.</a></p>
</section>
<section id="see-also-23" class="level3" data-number="7.5.4">
<h3 data-number="7.5.4">See also</h3>
<p>To learn more about <code>pandas.to_datetime</code>, please visit the official documentation page here: <a href="https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html">https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html</a>.</p>
</section>
</section>
<section id="working-with-time-deltas" class="level2" data-number="7.6">
<h2 data-number="7.6">Working with time deltas</h2>
<p>When working with time-series data, you may need to perform some calculations on your <code>datetime</code> columns, such as adding or subtracting. Examples can include adding 30 days to purchase <code>datetime</code> to determine when the return policy expires for a product or when a warranty ends. For example, the <code>Timedelta</code> class makes it possible to derive new <code>datetime</code> objects by adding or subtracting at different ranges or increments, such as seconds, daily, and weekly. This includes time zone-aware calculations.</p>
<p>In this recipe, you will explore two practical approaches in pandas to capture date/time differences – the <code>pandas.Timedelta</code> class and the <code>pandas.to_timedelta</code> function.</p>
<section id="how-to-do-it-23" class="level3" data-number="7.6.1">
<h3 data-number="7.6.1">How to do it…</h3>
<p>In this recipe, you will work with hypothetical sales data for a retail store. You will generate the sales DataFrame, which will contain items purchased from the store and the purchase date. You will then explore different scenarios using the <code>Timedelta</code> class and the <code>to_timedelta()</code> function:</p>
<ol>
<li>Start by importing the <code>pandas</code> library and creating a DataFrame with two columns, <code>item</code> and <code>purchase_dt</code>, which will be standardized to UTC:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df = pd.DataFrame(
        {      
        'item': ['item1', 'item2', 'item3', 'item4', 'item5', 'item6'],
        'purchase_dt': pd.date_range('2021-01-01', periods=6, freq='D', tz='UTC')
        }
)
df</code></pre>
</div>
<p>The preceding code should output a DataFrame with six rows (<code>items</code>) and two columns (<code>item</code> and <code>purchase_dt</code>):</p>
<figure>
<img src="../media/file46.jpg" alt="Figure 6.4: The DataFrame with the item purchased and purchase datetime (UTC) data" width="244" height="195"/><figcaption aria-hidden="true">Figure 6.4: The DataFrame with the item purchased and purchase datetime (UTC) data</figcaption>
</figure>
<ol>
<li>Add another <code>datetime</code> column to represent the expiration date, which is 30 days from the purchase date:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['expiration_dt'] = df['purchase_dt'] + pd.Timedelta(days=30)
df</code></pre>
</div>
<p>The preceding code should add a third column (<code>expiration_dt</code>) to the DataFrame, which is set at 30 days from the date of purchase:</p>
<figure>
<img src="../media/file47.jpg" alt="Figure 6.5: The updated DataFrame with a third column reflecting the expiration date" width="429" height="193"/><figcaption aria-hidden="true">Figure 6.5: The updated DataFrame with a third column reflecting the expiration date</figcaption>
</figure>
<ol>
<li>Now, assume you are asked to create a special extended date for return, and this one is set at 35 days, 12 hours, and 30 minutes from the purchase date:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['extended_dt'] = df['purchase_dt'] +\
                pd.Timedelta('35 days 12 hours 30 minutes')
df</code></pre>
</div>
<p>The preceding code should add a fourth column (<code>extended_dt</code>) to the DataFrame, reflecting the new datetime, based on the additional 35 days, 12 hours, and 30 minutes:</p>
<figure>
<img src="../media/file48.jpg" alt="Figure 6.6: The updated DataFrame with a fourth datetime column reflecting the extended date" width="602" height="192"/><figcaption aria-hidden="true">Figure 6.6: The updated DataFrame with a fourth datetime column reflecting the extended date</figcaption>
</figure>
<ol>
<li>Assume that you are asked to convert the time zone from UTC to the local time zone of the retailer store's headquarters, which is set in Los Angeles:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df.iloc[:,1:] = df.iloc[: ,1:].apply(
            lambda x: x.dt.tz_convert('US/Pacific')
                )
df</code></pre>
</div>
<p>After converting from UTC to the US/Pacific time zone (Los Angeles), you are overwriting the <code>datetime</code> columns (<code>purchased_dt</code>, <code>expiration_dt</code>, and <code>extended_dt</code>). The DataFrame structure should remain the same – six rows and four columns – but now the data looks different, as shown in the following screenshot:</p>
<figure>
<img src="../media/file49.jpg" alt="Figure 6.7: The updated DataFrame where all datetime columns are in Los Angeles (US/Pacific)" width="591" height="186"/><figcaption aria-hidden="true">Figure 6.7: The updated DataFrame where all datetime columns are in Los Angeles (US/Pacific)</figcaption>
</figure>
<ol>
<li>Finally, you can calculate the delta between the extended and original expiration dates. Since they are both <code>datetime</code> data types, you can achieve this with a simple subtraction between the two columns:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['exp_ext_diff'] = (
         df['extended_dt'] - df['expiration_dt']
        )
df</code></pre>
</div>
<p>Your final DataFrame should now have a fifth column that captures the difference between the extended date and the expiration date:</p>
<figure>
<img src="../media/file50.jpg" alt="Figure 6.8: The updated DataFrame with a fifth column" width="692" height="193"/><figcaption aria-hidden="true">Figure 6.8: The updated DataFrame with a fifth column</figcaption>
</figure>
<p>These types of transformations and calculations are simplified without needing any additional libraries, thanks to pandas' built-in capabilities to work with time-series data and <code>datetime</code> overall.</p>
</section>
<section id="how-it-works-22" class="level3" data-number="7.6.2">
<h3 data-number="7.6.2">How it works…</h3>
<p>Time deltas can be handy for capturing the difference between two date or time objects. In pandas, the <code>pandas.Timedelta</code> class is equivalent to Python's <code>datetime.timedelta</code> class and behaves very similarly. However, the advantage of pandas is that it includes a wide range of classes and functions for working with time-series data. These built-in functions within pandas, in general, are simpler and more efficient when working with DataFrames. Let's try this quick experiment to demonstrate how pandas' <code>Timedelta</code> class is a subclass of Python's <code>timedelta</code> class:</p>
<div class="C0-SHCodePACKT">
<pre><code>import datetime as dt
import pandas as pd
pd.Timedelta(days=1) == dt.timedelta(days=1)
&gt;&gt; True</code></pre>
</div>
<p>Let's validate that <code>pandas.Timedelta</code> is an instance of <code>datetime.timedelta</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>issubclass(pd.Timedelta, dt.timedelta)
&gt;&gt; True
dt_1 = pd.Timedelta(days=1)
dt_2 = dt.timedelta(days=1)
isinstance(dt_1, dt.timedelta)
&gt;&gt; True
isinstance(dt_1, pd.Timedelta)
&gt;&gt; True</code></pre>
</div>
<p>Python's <code>datetime.timedelta</code> class accepts integer values for these parameters – <code>days</code>, <code>seconds</code>, <code>microseconds</code>, <code>milliseconds</code>, <code>minutes</code>, <code>hours</code>, and <code>weeks</code>. On the other hand, <code>pandas.Timedelta</code> takes both integers and strings, as demonstrated in the following snippet:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.Timedelta(days=1, hours=12, minutes=55)
&gt;&gt; Timedelta('1 days 12:55:00')
pd.Timedelta('1 day 12 hours 55 minutes')
&gt;&gt; Timedelta('1 days 12:55:00')
pd.Timedelta('1D 12H 55T')
&gt;&gt; Timedelta('1 days 12:55:00')</code></pre>
</div>
<p>Once you have defined your <code>Timedelta</code> object, you can use it to make calculations on <code>date</code>, <code>time</code>, or <code>datetime</code> objects:</p>
<div class="C0-SHCodePACKT">
<pre><code>week_td = pd.Timedelta('1W')
pd.to_datetime('1 JAN 2022') + week_td
&gt;&gt; Timestamp('2022-01-08 00:00:00')</code></pre>
</div>
<p>In the preceding example, <code>week_td</code> represents a 1-week <code>Timedelta</code> object, which can be added (or subtracted) from <code>datetime</code> to get the difference. By adding <code>week_td</code>, you are incrementing by 1 week. What if you want to add 2 weeks? You can use multiplication as well:</p>
<div class="C0-SHCodePACKT">
<pre><code>pd.to_datetime('1 JAN 2022') + 2*week_td
&gt;&gt; Timestamp('2022-01-15 00:00:00')</code></pre>
</div>
</section>
<section id="theres-more-22" class="level3" data-number="7.6.3">
<h3 data-number="7.6.3">There's more…</h3>
<p>Using <code>pd.Timedelta</code> is straightforward and makes working with large time-series DataFrames efficient without importing additional libraries, as it is built into pandas.</p>
<p>In the previous <em>How to do it...</em> section, you created a DataFrame and added additional columns based on the <code>timedelta</code> calculations. You can also add the <code>timedelta</code> object into a DataFrame and reference it by its column. Finally, let's see how this works.</p>
<p>First, let's construct the same DataFrame used earlier:</p>
<div class="C0-SHCodePACKT">
<pre><code>import pandas as pd
df = pd.DataFrame(
        {      
        'item': ['item1', 'item2', 'item3', 'item4', 'item5', 'item6'],
        'purchase_dt': pd.date_range('2021-01-01', periods=6, freq='D', tz='UTC')
        }
)</code></pre>
</div>
<p>This should produce a DataFrame shown in <em>Figure 6.4</em>. Now, you will add a new column that contains the <code>Timedelta</code> object (1 week) and then use that column to add and subtract from the <code>purchased_dt</code> column:</p>
<div class="C0-SHCodePACKT">
<pre><code>df['1 week'] = pd.Timedelta('1W')
df['1_week_more'] = df['purchase_dt'] + df['1 week']
df['1_week_less'] = df['purchase_dt'] - df['1 week']
df</code></pre>
</div>
<p>The preceding code should produce a DataFrame with three additional columns. The <code>1 week</code> column holds the <code>Timedelta</code>, object and because of that, you can reference the column to calculate any time differences you need:</p>
<figure>
<img src="../media/file51.jpg" alt="Figure 6.9: The updated DataFrame with three additional columns" width="655" height="194"/><figcaption aria-hidden="true">Figure 6.9: The updated DataFrame with three additional columns</figcaption>
</figure>
<p>Let's check the data types for each column in the DataFrame:</p>
<div class="C0-SHCodePACKT">
<pre><code>df.info()
&gt;&gt;
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 5 columns):
 #   Column       Non-Null Count  Dtype             
---  ------       --------------  -----             
 0   item         6 non-null      object            
 1   purchase_dt  6 non-null      datetime64[ns, UTC]
 2   1 week       6 non-null      timedelta64[ns]   
 3   1_week_more  6 non-null      datetime64[ns, UTC]
 4   1_week_less  6 non-null      datetime64[ns, UTC]
dtypes: datetime64[ns, UTC](3), object(1), timedelta64[ns](1)
memory usage: 368.0+ bytes</code></pre>
</div>
<p>Note that the <code>1 week</code> column is a particular data type, <code>timedelta64</code> (our <code>Timedelta</code> object), which allows you to make arithmetic operations on the <code>date</code>, <code>time</code>, and <code>datetime</code> columns in your DataFrame.</p>
<p>In the <em>Working with DatetimeIndex</em> recipe, you explored the <code>pandas.date_range()</code> function to generate a DataFrame with <code>DatetimeIndex</code>. The function returns a range of equally spaced time points based on the start, end, period and frequency parameters.</p>
<p>Similarly, you have an option to generate <code>TimdedeltaIndex</code> with a fixed frequency using the <code>pandas.timedelta_range()</code> function, which takes similar parameters as the <code>pandas.date_range()</code> function. Here is a quick example:</p>
<div class="C0-SHCodePACKT">
<pre><code>df = pd.DataFrame(
        {      
        'item': ['item1', 'item2', 'item3', 'item4', 'item5'],
        'purchase_dt': pd.date_range('2021-01-01', periods=5, freq='D', tz='UTC'),
        'time_deltas': pd.timedelta_range('1W 2 days 6 hours', periods=5)
        }
)
df</code></pre>
</div>
<p>The output is as follows:</p>
<figure>
<img src="../media/file52.jpg" alt="Figure 6.10: A DataFrame with a Timedelta column" width="365" height="159"/><figcaption aria-hidden="true">Figure 6.10: A DataFrame with a Timedelta column</figcaption>
</figure>
</section>
<section id="see-also-24" class="level3" data-number="7.6.4">
<h3 data-number="7.6.4">See also</h3>
<ul>
<li>To learn more about the <code>pandas.timedelta_range()</code> function, please refer to the official documentation here: <a href="https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html">https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html</a>.</li>
<li>To learn more about the <code>pandas.Timedelta</code> class, please visit the official documentation here: <a href="https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html">https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html</a>.</li>
</ul>
</section>
</section>
<section id="converting-datetime-with-time-zone-information" class="level2" data-number="7.7">
<h2 data-number="7.7">Converting DateTime with time zone information</h2>
<p>When working with time-series data that requires attention to different time zones, things can get out of hand and become more complicated. For example, when developing data pipelines, building a data warehouse, or integrating data between systems, dealing with time zones requires attention and consensus amongst the different stakeholders in the project. For example, in Python, there are several libraries and modules dedicated to working with time zone conversion; these include <code>pytz</code>, <code>dateutil</code>, and <code>zoneinfo</code>, to name a few.</p>
<p>Let's discuss an inspiring example regarding time zones within time-series data. It is common for large companies that span their products and services across continents to include data from different places around the globe. For example, it would be hard to make data-driven business decisions if we neglect time zones. Let's say you want to determine whether most customers come to your e-commerce site in the morning or evening, and whether shoppers browse during the day and then make a purchase in the evening after work. For this analysis, you need to be aware of time zone differences and their interpretation on an international scale.</p>
<section id="how-to-do-it-24" class="level3" data-number="7.7.1">
<h3 data-number="7.7.1">How to do it…</h3>
<p>In this recipe, you will work with a hypothetical scenario – a small dataset that you will generate to represent website visits at different time intervals from various locations worldwide. The data will be standardized to UTC, and you will work with time-zone conversions.</p>
<ol>
<li>You will start by importing the <code>pandas</code> library and creating the time-series DataFrame:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df = pd.DataFrame(
        {      
        'Location': ['Los Angeles',
                     'New York',
                     'Berlin',
                     'New Delhi',
                     'Moscow',
                     'Tokyo',
                     'Dubai'],
        'tz': ['US/Pacific',
               'US/Eastern',
               'Europe/Berlin',
               'Asia/Kolkata',
               'Europe/Moscow',
               'Asia/Tokyo',
               'Asia/Dubai'],
        'visit_dt': pd.date_range(start='22:00',periods=7, freq='45min'),
        }).set_index('visit_dt')
df</code></pre>
</div>
<p>This will produce a DataFrame where <code>visit_dt</code> is the index of the <code>DatetimeIndex</code> type and two columns, <code>Location</code> and <code>tz</code>, indicate the time zone:</p>
<figure>
<img src="../media/file53.png" alt="Figure 6.11: The DataFrame with visit_dt in UTC as an index" width="373" height="262"/><figcaption aria-hidden="true">Figure 6.11: The DataFrame with visit_dt in UTC as an index</figcaption>
</figure>
<ol>
<li>Assume that you need to convert this DataFrame to be in the same time zone as the company's headquarters in Tokyo. You can do this easily using <code>DataFrame.tz_convert()</code> against the DataFrame, but you will get a <code>TypeError</code> exception if you do this. That is because your time-series DataFrame is not time zone-aware. So, you need to localize it first using <code>tz_localize() </code>to make it time-zone aware. In this case, you will localize it to UTC:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df = df.tz_localize('UTC')</code></pre>
</div>
<ol>
<li>You will now convert the DataFrame to the headquarters' time zone (<code>Tokyo</code>):</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df_hq = df.tz_convert('Asia/Tokyo')
df_hq</code></pre>
</div>
<p>The DataFrame index, <code>visit_dt</code>, will be converted to the new time zone:</p>
<figure>
<img src="../media/file54.png" alt="Figure 6.12: The DataFrame index converted to the headquarters' time zone (Tokyo)" width="415" height="261"/><figcaption aria-hidden="true">Figure 6.12: The DataFrame index converted to the headquarters' time zone (Tokyo)</figcaption>
</figure>
<p>Note that you were able to access the <code>tz_localize()</code> and <code>tz_convert()</code> methods because the DataFrame had an index of type <code>DatetimeIndex</code>. If that was not the case, you would get a <code>TypeError</code> exception with the following message:</p>
<div class="C1-SHCodePACKT">
<pre><code>TypeError: index is not a valid DatetimeIndex or PeriodIndex</code></pre>
</div>
<ol>
<li>Now, you will localize each row to the appropriate time zone. You will add a new column reflecting the time zone, based on the location of the user that accessed the website. You will leverage the <code>tz</code> column to accomplish this:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['local_dt'] = df.index
df['local_dt'] = df.apply(lambda x: pd.Timestamp.tz_convert(x['local_dt'], x['tz']), axis=1)
df</code></pre>
</div>
<p>This should produce a new column, <code>local_dt</code>, which is based on the UTC datetime from <code>visit_dt</code> and converted based on the time zone provided in the <code>tz</code> column:</p>
<figure>
<img src="../media/file55.png" alt="Figure 6.13: The updated DataFrame with local_dt based on a localized time zone for each visit" width="594" height="256"/><figcaption aria-hidden="true">Figure 6.13: The updated DataFrame with local_dt based on a localized time zone for each visit</figcaption>
</figure>
<p>You may wonder, what if you did not have a <code>tz</code> column? Where would you find the right <code>tz</code> string? Well, these are called <strong>Time Zone</strong> (<strong>TZ</strong>) database names. These are standard names, and you can find a subset of these in the Python documentation, or for a more comprehensive list, you can visit this link: <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p>
</section>
<section id="how-it-works-23" class="level3" data-number="7.7.2">
<h3 data-number="7.7.2">How it works…</h3>
<p>Converting a time-series DataFrame from one time zone to another was achieved using <code>DataFrame.tz_convert()</code>, providing it with a time-zone string argument such as <code>US/Pacific</code>. There are a few assumptions when using <code>DataFrame.tz_convert()</code> that you need to keep in mind:</p>
<ul>
<li>The DataFrame should have an index of the <code>DatetimeIndex</code> type.</li>
<li><code>DatetimeIndex</code> needs to be time zone-aware.</li>
</ul>
<p>You used the <code>DataFrame.tz_localize()</code> function to make the index time zone aware. It is a good practice to standardize on <em>UTC</em> if you are dealing with different time zones and daylight saving, since UTC is always consistent and never changes (regardless of where you are or if daylight saving time is applied or not). Once in UTC, converting to other time zones is very straightforward.</p>
<p>We first localized the data in the previous steps and then converted it to a different time zone in two steps. You can also do this in one step by chaining the two methods, as shown in the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>df.tz_localize('UTC').tz_convert('Asia/Tokyo')</code></pre>
</div>
<p>If your index is already time zone-aware, then using <code>tz_localize()</code> will produce a <code>TypeError</code> exception with the following message:</p>
<div class="C0-SHCodePACKT">
<pre><code>TypeError: Already tz-aware, use tz_convert to convert</code></pre>
</div>
<p>This indicates that you do not need to localize it again. Instead, just convert it to another time zone.</p>
</section>
<section id="theres-more-23" class="level3" data-number="7.7.3">
<h3 data-number="7.7.3">There's more…</h3>
<p>Looking at the DataFrame in <em>Figure 6.12</em>, it is hard to tell immediately whether the time was in the morning (AM) or evening (PM). You can format <code>datetime</code> using <code>strftime</code> (which we discussed in the <em>Providing a format argument to DateTime</em> recipe).</p>
<p>You will construct the same DataFrame, localize it to UTC, then convert it to the headquarters' time zone, and apply the new format:</p>
<div class="C0-SHCodePACKT">
<pre><code>df = pd.DataFrame(
        {      
        'Location': ['Los Angeles',
                     'New York',
                     'Berlin',
                     'New Delhi',
                     'Moscow',
                     'Tokyo',
                     'Dubai'],
        'tz': ['US/Pacific',
               'US/Eastern',
               'Europe/Berlin',
               'Asia/Kolkata',
               'Europe/Moscow',
               'Asia/Tokyo',
               'Asia/Dubai'],
        'visit_dt': pd.date_range(start='22:00',periods=7, freq='45min'),
        }).set_index('visit_dt').tz_localize('UTC').tz_convert('Asia/Tokyo')</code></pre>
</div>
<p>We have combined the steps, and this should produce a DataFrame similar to the one in <em>Figure 6.12</em>.</p>
<p>Now, you can update the formatting to use the pattern – <code>YYYY-MM-DD HH:MM AM/PM</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>df.index = df.index.strftime('%Y-%m-%d %H:%M %p')
df</code></pre>
</div>
<p>The index will be updated from a format/layout perspective. However, it is still time zone-aware, based on Tokyo's time zone, and the index is still <code>DatetimeIndex</code>. The only change is to the <code>datetime</code> layout:</p>
<figure>
<img src="../media/file56.png" alt="Figure 6.14 – The updated DataFrame index, formatted based on the date format string provided" width="366" height="265"/><figcaption aria-hidden="true">Figure 6.14 – The updated DataFrame index, formatted based on the date format string provided</figcaption>
</figure>
<p>I am sure you will agree that this is easier to present to users to determine whether the visit was AM or PM quickly.</p>
</section>
<section id="see-also-25" class="level3" data-number="7.7.4">
<h3 data-number="7.7.4">See also</h3>
<p>To learn more about <code>tz_convert</code> you can read the official documentation at <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html and https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.tz_convert.html</a>.</p>
</section>
</section>
<section id="working-with-date-offsets" class="level2" data-number="7.8">
<h2 data-number="7.8">Working with date offsets</h2>
<p>When working with time series, it is critical that you learn more about the data you are working with and how it relates to the problem you are attempting to solve. For example, when working with manufacturing or sales data, you cannot assume that an organization's working day is Monday to Friday or whether it uses the standard calendar year or fiscal year. You should also consider understanding any holiday schedule, annual shutdowns, and other matters related to the business operation.</p>
<p>This is where offsets can be handy. They can help transform your dates into something more meaningful and relatable to a business. They can also help correct data entries that may not be logical.</p>
<p>We will work through a hypothetical example in this recipe and see how to leverage pandas offsets.</p>
<section id="how-to-do-it-25" class="level3" data-number="7.8.1">
<h3 data-number="7.8.1">How to do it…</h3>
<p>In this recipe, you will generate a time-series DataFrame to represent some daily logs of production quantity. The company, a US-based firm, would like to analyze data to better understand production capacity for future forecasting:</p>
<ol>
<li>Start by importing the <code>pandas</code> library and then generate our DataFrame:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>np.random.seed(10)
df = pd.DataFrame(
        {      
        'purchase_dt': pd.date_range('2021-01-01', periods=6, freq='D'),
        'production' : np.random.randint(4, 20, 6)
        }).set_index('purchase_dt')
df
&gt;&gt;
             production
purchase_dt           
2021-01-01           13
2021-01-02           17
2021-01-03            8
2021-01-04           19
2021-01-05            4
2021-01-06            5</code></pre>
</div>
<ol>
<li>Let's add the name of the days:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['day'] = df.index.day_name()
df
&gt;&gt;
             production        day
purchase_dt                      
2021-01-01           13     Friday
2021-01-02           17   Saturday
2021-01-03            8     Sunday
2021-01-04           19     Monday
2021-01-05            4    Tuesday
2021-01-06            5  Wednesday</code></pre>
</div>
<p>When working with any data, always understand the business context behind it. Without domain knowledge or business context, it would be difficult to determine whether a data point is acceptable or not. In this scenario, the company was described as a US-based firm, and thus, working days are Monday to Friday. If there is data on a Saturday or Sunday (the weekend), you should not make assumptions without validating with the business. You should confirm whether there was any exception made for production on those specific weekend dates. Also, realize that January 1 was a holiday. After investigation, it was confirmed that production did occur due to an emergency exception. The business executives do not want to account for weekend or holiday work in the forecast. In other words, it was a one-time non-occurring event that they do not want to model or build a hypothesis on.</p>
<ol>
<li>The firm asks you to push the weekend/holiday production numbers to the next business day instead. Here, you will use <code>pandas.offsets.BDay()</code>, which represents business days:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['BusinessDay'] = df.index + pd.offsets.BDay(0)
df['BDay Name'] = df['BusinessDay'].dt.day_name()
df
&gt;&gt;
             production        day BusinessDay  BDay Name
purchase_dt                                          
2021-01-01           13     Friday  2021-01-01     Friday
2021-01-02           17   Saturday  2021-01-04     Monday
2021-01-03            8     Sunday  2021-01-04     Monday
2021-01-04           19     Monday  2021-01-04     Monday
2021-01-05            4    Tuesday  2021-01-05    Tuesday
2021-01-06            5  Wednesday  2021-01-06  Wednesday</code></pre>
</div>
<p>Because Saturday and Sunday were weekends, their production numbers were pushed to the next business day, Monday, January 4.</p>
<ol>
<li>Let's perform a summary aggregation that adds production numbers by business days to understand the impact of this change better:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df.groupby(['BusinessDay', 'BDay Name']).sum()
&gt;&gt;
                       production
BusinessDay BDay Name           
2021-01-01  Friday             137
2021-01-04  Monday             44
2021-01-05  Tuesday             4
2021-01-06  Wednesday           5</code></pre>
</div>
<p>Now, Monday shows to be the most productive day for that week, given it was the first business day after the holiday and a long weekend.</p>
<ol>
<li>Finally, the business has made another request – they would like to track production monthly (<code>MonthEnd</code>) and quarterly (<code>QuarterEnd</code>). You can use <code>pandas.offsets</code> again to add two new columns:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['QuarterEnd'] = df.index + pd.offsets.QuarterEnd(0)
df['MonthEnd'] = df.index + pd.offsets.MonthEnd(0)
df['BusinessDay'] = df.index + pd.offsets.BDay(0)
&gt;&gt;
             production QuarterEnd   MonthEnd BusinessDay
purchase_dt                                         
2021-01-01           13 2021-03-31 2021-01-31  2021-01-01
2021-01-02           17 2021-03-31 2021-01-31  2021-01-04
2021-01-03            8 2021-03-31 2021-01-31  2021-01-04
2021-01-04           19 2021-03-31 2021-01-31  2021-01-04
2021-01-05            4 2021-03-31 2021-01-31  2021-01-05
2021-01-06            5 2021-03-31 2021-01-31  2021-01-06</code></pre>
</div>
<p>Now, you have a DataFrame that should satisfy most of the reporting requirements of the business.</p>
</section>
<section id="how-it-works-24" class="level3" data-number="7.8.2">
<h3 data-number="7.8.2">How it works…</h3>
<p>Using date offsets made it possible to increment, decrement, and transform your dates to a new date range following specific rules. There are several offsets provided by pandas, each with its own rules, which can be applied to your dataset. Here is a list of the common offsets available in pandas:</p>
<ul>
<li><code>BusinessDay</code> or <code>Bday</code></li>
<li><code>MonthEnd</code></li>
<li><code>BusinessMonthEnd</code> or <code>BmonthEnd</code></li>
<li><code>CustomBusinessDay</code> or <code>Cday</code></li>
<li><code>QuarterEnd</code></li>
<li><code>FY253Quarter</code></li>
</ul>
<p>For a more comprehensive list and their descriptions, you can visit the documentation here: <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects</a>.</p>
<p>Applying an offset in pandas is as simple as doing an addition or subtraction, as shown in the following example:</p>
<div class="C0-SHCodePACKT">
<pre><code>df.index + pd.offsets.BDay()
df.index - pd.offsets.BDay()</code></pre>
</div>
</section>
<section id="theres-more-24" class="level3" data-number="7.8.3">
<h3 data-number="7.8.3">There's more…</h3>
<p>Following our example, you may have noticed when using the <code>BusinessDay</code> (<code>BDay</code>) offset that it did not account for the New Year's Day holiday (January 1). So, what can be done to account for both the New Year's Day holiday and weekends?</p>
<p>To accomplish this, pandas provides two approaches to handle standard holidays. The first method is by defining a custom holiday. The second approach (when suitable) uses an existing holiday offset.</p>
<p>Let's start with an existing offset. For this example, dealing with New Year, you can use the <code>USFederalHolidayCalendar</code> class, which has standard holidays such as New Year, Christmas, and other holidays specific to the United States. So, let's see how this works.</p>
<p>First, generate a new DataFrame and import the needed library and classes:</p>
<div class="C0-SHCodePACKT">
<pre><code>import pandas as pd
from pandas.tseries.holiday import (
    USFederalHolidayCalendar
)
df = pd.DataFrame(
        {      
        'purchase_dt': pd.date_range('2021-01-01', periods=6, freq='D'),
        'production' : np.random.randint(4, 20, 6)
        }).set_index('purchase_dt')</code></pre>
</div>
<p><code>USFederalHolidayCalendar</code> has some holiday rules that you can check using the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>USFederalHolidayCalendar.rules
&gt;&gt;
[Holiday: New Years Day (month=1, day=1, observance=&lt;function nearest_workday at 0x7fedf3ec1a60&gt;),
 Holiday: Martin Luther King Jr. Day (month=1, day=1, offset=&lt;DateOffset: weekday=MO(+3)&gt;),
 Holiday: Presidents Day (month=2, day=1, offset=&lt;DateOffset: weekday=MO(+3)&gt;),
 Holiday: Memorial Day (month=5, day=31, offset=&lt;DateOffset: weekday=MO(-1)&gt;),
 Holiday: July 4th (month=7, day=4, observance=&lt;function nearest_workday at 0x7fedf3ec1a60&gt;),
 Holiday: Labor Day (month=9, day=1, offset=&lt;DateOffset: weekday=MO(+1)&gt;),
 Holiday: Columbus Day (month=10, day=1, offset=&lt;DateOffset: weekday=MO(+2)&gt;),
 Holiday: Veterans Day (month=11, day=11, observance=&lt;function nearest_workday at 0x7fedf3ec1a60&gt;),
 Holiday: Thanksgiving (month=11, day=1, offset=&lt;DateOffset: weekday=TH(+4)&gt;),
 Holiday: Christmas (month=12, day=25, observance=&lt;function nearest_workday at 0x7fedf3ec1a60&gt;)]</code></pre>
</div>
<p>To apply these rules, you will use the <code>CustomerBusinessDay</code> or <code>CDay</code> offset:</p>
<div class="C0-SHCodePACKT">
<pre><code>df['USFederalHolidays'] = df.index + pd.offsets.CDay(calendar=USFederalHolidayCalendar())
df</code></pre>
</div>
<p>The output is as follows:</p>
<figure>
<img src="../media/file57.jpg" alt="Figure 6.15 – The USFederalHolidays column added to the DataFrame, which recognizes New Year's Day" width="302" height="220"/><figcaption aria-hidden="true">Figure 6.15 – The USFederalHolidays column added to the DataFrame, which recognizes New Year's Day</figcaption>
</figure>
<p>The custom holiday option will behave in the same way. You will need to import the <code>Holiday</code> class and the <code>nearest_workday</code> function. You will use the <code>Holiday</code> class to define your specific holidays. In this case, you will determine the New Year's rule:</p>
<div class="C0-SHCodePACKT">
<pre><code>from pandas.tseries.holiday import (
    Holiday,
    nearest_workday,
    USFederalHolidayCalendar
)
newyears = Holiday("New Years",
                   month=1,
                   day=1,
                   observance=nearest_workday)
newyears
&gt;&gt;
Holiday: New Years (month=1, day=1, observance=&lt;function nearest_workday at 0x7fedf3ec1a60&gt;)</code></pre>
</div>
<p>Similar to how you applied the <code>USFederalHolidayCalendar</code> class to the <code>CDay</code> offset, you will apply your new <code>newyears</code> object to <code>Cday</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>df['NewYearsHoliday'] = df.index + pd.offsets.CDay(calendar=newyears)
df</code></pre>
</div>
<p>You will get the following output:</p>
<figure>
<img src="../media/file58.jpg" alt="Figure 6.16 – The NewYearsHoliday column, added using a custom holiday offset" width="416" height="219"/><figcaption aria-hidden="true">Figure 6.16 – The NewYearsHoliday column, added using a custom holiday offset</figcaption>
</figure>
<p>If you are curious about the <code>nearest_workday</code> function and how it was used in both the <code>USFederalHolidayCalendar</code> rules and your custom holiday, then the following code illustrates how it works:</p>
<div class="C0-SHCodePACKT">
<pre><code>nearest_workday(pd.to_datetime('2021-1-3'))
&gt;&gt;
Timestamp('2021-01-04 00:00:00')
nearest_workday(pd.to_datetime('2021-1-2'))
&gt;&gt;
Timestamp('2021-01-01 00:00:00')</code></pre>
</div>
<p>As illustrated, the function mainly determines whether the day is a weekday or not, and based on that, it will either use the day before (if it falls on a Saturday) or the day after (if it falls on a Sunday). There are other rules available as well as <code>nearest_workday</code>, including the following:</p>
<ul>
<li><code>Sunday_to_Monday</code></li>
<li><code>Next_Monday_or_Tuesday</code></li>
<li><code>Previous_Friday</code></li>
<li><code>Next_monday</code></li>
</ul>
</section>
<section id="see-also-26" class="level3" data-number="7.8.4">
<h3 data-number="7.8.4">See also</h3>
<p>For more insight regarding <code>pandas.tseries.holiday</code>, you can view the actual code, which highlights all the classes and functions and can serve as an excellent reference, at <a href="https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py">https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py</a>.</p>
</section>
</section>
<section id="working-with-custom-business-days" class="level2" data-number="7.9">
<h2 data-number="7.9">Working with custom business days</h2>
<p>Companies have different working days worldwide, influenced by the region or territory they belong to. For example, when working with time-series data and depending on the analysis you need to make, knowing whether certain transactions fall on a workday or weekend can make a difference. For example, suppose you are doing anomaly detection, and you know that certain types of activities can only be done during working hours. In that case, any activities beyond these boundaries may trigger some further analysis.</p>
<p>In this recipe, you will see how you can customize an offset to fit your requirements when doing an analysis that depends on defined business days and non-business days.</p>
<section id="how-to-do-it-26" class="level3" data-number="7.9.1">
<h3 data-number="7.9.1">How to do it…</h3>
<p>In this recipe, you will create custom business days and holidays for a company headquartered in Amman, Jordan. In Jordan, the working week is from Sunday to Thursday, whereas Friday and Saturday are the 2-day weekend. Additionally, their National Day (a holiday) is on May 25 of each year:</p>
<ol>
<li>ou will start by importing pandas and defining the workdays for Jordan:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>import pandas as pd
from pandas.tseries.holiday import AbstractHolidayCalendar, Holiday
from pandas.tseries.offsets import CustomBusinessDay
jordan_workdays = "Sun Mon Tue Wed Thu"</code></pre>
</div>
<ol>
<li>You will define a custom class holiday <code>JordanHolidayCalendar</code> and a new <code>rule</code> for Jordan’s independence day:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>class JordanHolidayCalendar(AbstractHolidayCalendar):
    rules = [
        Holiday('Jordan Independence Day', month=5, day=25)
    ]</code></pre>
</div>
<ol>
<li>You will define a new instance of <code>CustomBusinessDay</code> with the custom holiday and weekdays:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>jordan_bday = CustomBusinessDay(
    holidays=JordanHolidayCalendar().holidays(),
    weekmask=jordan_workdays)</code></pre>
</div>
<ol>
<li>You can validate that the rules were registered properly:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>jordan_bday.holidays[53]
&gt;&gt;
numpy.datetime64('2023-05-25')
jordan_bday.weekmask
&gt;&gt;
'Sun Mon Tue Wed Thu'</code></pre>
</div>
<ol>
<li>Now you can use <code>pd.date_range</code> to generate 10 <strong>business</strong> days starting from May 20, 2023. The generated dates will exclude weekends (Friday and Saturday) and the Independence Day holiday (May 25<sup>th</sup>):</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df = pd.DataFrame({'Date': pd.date_range('12-1-2021', periods=10, freq=dubai_uae_bday )})</code></pre>
</div>
<ol>
<li>To make it easier to determine whether things are working as expected, add a new column that represents the day name:</li>
</ol>
<div class="C1-CodePACKT">
<pre><code>df['Day_name'] = df.Date.dt.day_name()
df</code></pre>
</div>
<p>The generated time series should have the new custom business days and a holiday rule for Jordan.</p>
<figure>
<img src="../media/file59.png" alt="Figure 6.17: The time series generated based on the UAE custom working days and holidays" width="402" height="644"/><figcaption aria-hidden="true">Figure 6.17: The time series generated based on the UAE custom working days and holidays</figcaption>
</figure>
<p>In <em>Figure 6.17</em> you can see the custom business workdays are from Sunday to Monday with the exception of May 25<sup>th</sup> (Thursday) that was skipped since it is a national holiday in Jordan.</p>
<p>The example can be further extended to include different countries and holidays to fit the type of analysis you are working with.</p>
</section>
<section id="how-it-works-25" class="level3" data-number="7.9.2">
<h3 data-number="7.9.2">How it works…</h3>
<p>This recipe builds on the Working with date offsets recipe but focuses on customizing offsets. The pandas provides several offsets that can take a custom calendar, <strong>holiday</strong>, and <strong>weekmask</strong>. These include the following:</p>
<ul>
<li><code>CustomBusinessDay</code> or <code>Cday</code></li>
<li><code>CustomBusinessMonthEnd</code> or <code>CBMonthEnd</code></li>
<li><code>CustomBusinessMonthBegin</code> or <code>CBMonthBegin</code></li>
<li><code>CustomBusinessHour</code></li>
</ul>
<p>They behave like any other offset; the only difference is that they allow you to create your own rules.</p>
<p>In the recipe you imported the <code>CustomBusinessDay</code> class, created an instance of it to create a custom frequency for business days, taking into account weekends and holidays. The following code is what you used:</p>
<div class="C0-SHCodePACKT">
<pre><code>jordan_bday = CustomBusinessDay(
    holidays=JordanHolidayCalendar().holidays(),
    weekmask=jordan_workdays
)</code></pre>
</div>
<p>Which is also equivalent to the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>jordan_bday = pd.offsets.CustomBusinessDay(
    holidays=JordanHolidayCalendar().holidays(),
    weekmask=jordan_workdays,
)</code></pre>
</div>
<p>Notice that when defining workdays, it was a string of abbreviated weekday names. This is called <code>weekmask</code>, and it's used in both pandas and NumPy when customizing weekdays. In pandas you can also define a custom holiday calendar by extending the <code>AbstractHolidayCalendar</code> class and including specific dates or rules for holidays, as demonstrated in the earlier code for Jordan Independence Day.</p>
</section>
<section id="theres-more-25" class="level3" data-number="7.9.3">
<h3 data-number="7.9.3">There's more…</h3>
<p>Let's extend the previous example and add custom business hours to the DataFrame. This will be another custom offset that you can use in a similar way to <code>CustomBusinessDay</code>:</p>
<div class="C0-SHCodePACKT">
<pre><code>jordan_bhour = pd.offsets.CustomBusinessHour(
    start="8:30",
    end="15:30",
    holidays=JordanHolidayCalendar().holidays(),
    weekmask=jordan_workdays)</code></pre>
</div>
<p>Here, you are applying the same rules, the custom <code>holidays</code> and <code>weekmask</code> for the custom workdays ensuring that the custom business hours also respect the defined workweek and holidays. You defined the custom hours by providing the <code>start</code> and <code>end</code> times (in 24-hour format).</p>
<p>The following is a usage example of the custom business hours you just created:</p>
<div class="C0-SHCodePACKT">
<pre><code>start_datetime = '2023-05-24 08:00'
end_datetime = '2023-05-24 16:00'
business_hours = pd.date_range(start=start_datetime, end=end_datetime, freq=jordan_bhour)
print(business_hours)
&gt;&gt;
DatetimeIndex(['2023-05-24 08:30:00', '2023-05-24 09:30:00',
               '2023-05-24 10:30:00', '2023-05-24 11:30:00',
               '2023-05-24 12:30:00', '2023-05-24 13:30:00',
               '2023-05-24 14:30:00'],
              dtype='datetime64[ns]', freq='CBH')</code></pre>
</div>
<p>Note that custom offsets like <code>CustomBusinessDay</code> and <code>CustomBusinessHour</code> can be applied to both time zone-naive and time zone-aware datetime objects. However, the behavior and necessity of making a DataFrame time zone-aware depends on the specific use case. When needed, you can make your DataFrame time zone-aware (for example, localize it and then convert it to your time zone) using <code>tz.localize()</code> or <code>tz.convert() </code>before applying the custom offset to get better results.</p>
</section>
<section id="see-also-27" class="level3" data-number="7.9.4">
<h3 data-number="7.9.4">See also</h3>
<ul>
<li>To learn more about pandas' <code>CustomBusinessDay</code>, you can read the official documentation here: <a href="https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html">https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html</a></li>
<li>To learn more about pandas’ <code>CustomBusinessHours</code> you can read the official documentation here:<a href="https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html">https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html</a></li>
</ul>
</section>
</section>
</section>
</div>
</div>
</body>
</html>