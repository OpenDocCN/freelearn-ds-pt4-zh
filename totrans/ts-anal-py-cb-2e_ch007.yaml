- en: 6 Working with Date and Time in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
  prefs: []
  type: TYPE_NORMAL
- en: At the core of time-series data is **time**. **Time-series data** is a sequence
    of observations or data points captured in successive order and at regular time
    intervals. In the context of a pandas DataFrame, time-series data has an ordered
    index of type `DatetimeIndex`, as you have seen in earlier chapters. The **DatetimeIndex**
    offers an easy and efficient slicing, indexing, and time-based grouping of data.
  prefs: []
  type: TYPE_NORMAL
- en: Being familiar with manipulating date and time in time-series data is an essential
    component of time series analysis and modeling. In this chapter, you will find
    recipes for common scenarios when working with date and time in time-series data.
  prefs: []
  type: TYPE_NORMAL
- en: Python has several built-in modules for working with date and time, such as
    the `datetime`, `time`, `calendar`, and `zoneinfo` modules. Additionally, there
    are other popular libraries in Python that further extend the capability to work
    with and manipulate date and time, such as `dateutil`, `pytz`, and `arrow`, to
    name a few.
  prefs: []
  type: TYPE_NORMAL
- en: You will be introduced to the `datetime` module in this chapter but you will
    then transition to using **pandas** for enhanced and more complex date and time
    manipulation, and for generating time-series DataFrames with a sequence of `DatetimeIndex`.
    In addition, the `pandas` library contains several date-specific and time-specific
    classes that inherit from the aforementioned Python modules. In other words, you
    will not need to import additional date/time Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You will be introduced to pandas classes such as `Timestamp`, `Timedelta`, `Period`,
    and `DateOffset`. You will notice similarities between the functionality – for
    example, the pandas `Timestamp` class is equivalent to Python's `Datetime` class
    and can be interchangeable in most scenarios. Similarly, `pandas.Timedelta` is
    equivalent to Python's `datetime.timedelta` object. The `pandas` library offers
    a more straightforward, intuitive, and powerful interface to handle most of your
    date and time manipulation needs without importing additional modules. When using
    pandas, you will appreciate having a library that contains everything you need
    to work with time-series data and can easily handle many challenging tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of the recipes that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with `DatetimeIndex`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a format argument to `DateTime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unix epoch timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with time deltas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting `DateTime` with time zone information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with date offsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with custom business days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a real-world scenario, you may not use all or any of these techniques. Still,
    it is critical to be aware of the options when facing a particular scenario that
    requires certain adjustments or formatting of dates.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter and going forward, we will extensively use pandas 2.1.3 (released
    on November 10, 2023\. This applies to all the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load these libraries in advance, since you will be using them throughout the
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will use `dt`, `np`, and `pd` aliases going forward.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the Jupyter notebooks from the GitHub repository at [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/code/Ch6)
    to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Working with DatetimeIndex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pandas` library has many options and features to simplify tedious tasks
    when working with time-series data, dates, and time.
  prefs: []
  type: TYPE_NORMAL
- en: When working with time-series data in Python, it is common to load into a pandas
    DataFrame with an index of type `DatetimeIndex`. As an index, the `DatetimeIndex`
    class extends pandas DataFrame capabilities to work more efficiently and intelligently
    with time-series data. This was demonstrated numerous times in *Chapter 2*, *Reading
    Time Series Data from Files*, and *Chapter 3*, *Reading Time Series Data from
    Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this recipe, you will appreciate pandas' rich set of date functionality
    to handle almost any representation of date/time in your data. Additionally, you
    will learn how to use different functions in pandas to convert date-like objects
    to a DatetimeIndex.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, you will explore Python's `datetime` module and learn about
    the `Timestamp` and `DatetimeIndex` classes and the relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the relationship between Python''s `datetime.datetime` class
    and pandas'' `Timestamp` and `DatetimeIndex` classes, you will create three different
    `datetime` objects representing the date `2021, 1, 1`. You will then compare these
    objects to gain a better understanding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the datetime representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect their data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s see how they compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the preceding code that pandas'' `Timestamp` object is equivalent
    to Python''s `Datetime` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that `dt2` is an instance of `pandas.Timestamp` class, and the `Timestamp`
    class is a subclass of Python's `dt.datetime` class (but not vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you used the `pandas.to_datetime()` function, it returned a `Timestamp`
    object. Now, use `pandas.to_datetime()` on a list and examine the outcome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, the output is now of type `DatetimeIndex` created using the same
    `pandas.to_datetime()` function that you used earlier. Previously, when using
    the same function on an individual object, the result was of type `Timestamp`,
    but when applied on a list, it produced a sequence of type `DatetimeIndex`. You
    will perform one more task to make things clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print out the first item (slice) from the `pd_dates` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, you can infer a relationship between the two classes:
    `DatetimeIndex` and `Timestamp`. A DatetimeIndex is a sequence (list) of `Timestamp`
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create a `DatetimeIndex` using the `pandas.to_datetime()`
    function, let's further expand on this and see what else you can do with the function.
    For example, you will see how simple it is to convert different `datetime` representations,
    including strings, integers, lists, pandas series, or other `datetime` objects,
    into a `DatetimeIndex`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a `dates` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the list using `pandas.to_datetime()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the `to_datetime()` function properly parsed the entire list of
    different string representations and date types such as Python''s `Datetime` and
    NumPy''s `datetime64`. Similarly, you could have used the `DatetimeIndex` constructor
    directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This would produce similar results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DatetimeIndex` object gives access to many useful properties and methods
    to extract additional date and time properties. As an example, you can extract
    `day_name`, `month`, `year`, `days_in_month`, `quarter`, `is_quarter_start`, `is_leap_year`,
    `is_month_start`, `is_month_end`, and `is_year_start`. The following code shows
    how this can be done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These properties and methods will be very useful when transforming your time-series
    datasets for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The, `pandas.to_datetime()` is a powerful function that can intelligently parse
    different date representations from strings. As you saw in *step 4* in the previous
    *How to do it…* section, the string examples, such as `'2021-01-01'`, `'2/1/2021'`,
    `'03-01-2021'`, `'April 1, 2021'`, and `'20210501'`, were parsed correctly. Other
    date representations such as `'April 1, 2021'` and '`1 April 2021'`, can be parsed
    using the `to_datetime()` function as well, and I'll leave it to you to explore
    additional examples that come to mind.
  prefs: []
  type: TYPE_NORMAL
- en: The `to_datetime` function contains the `errors` parameter. In the following
    example, you specify `errors='coerce'` which instructs pandas to set any value
    it could not parse as `NaT` indicating a missing value. You will learn more about
    `NaT` in the Performing data quality checks recipe in *Chapter 7*, *Handling Missing
    Data*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In pandas, there are different representations to indicate missing values –
    `np.NaN` represents missing numeric values (**Not a Number**), while `pd.NaT`
    represents missing `datetime` values (**Not a Time**). Finally, pandas' `pd.NA`
    is used to represent missing scalar values (**Not Available**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `errors` parameter in `to_datetime` can take one of the three valid string
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`raise`, which means it will raise an exception (`error out`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coerce` will not cause it to raise an exception. Instead, it will just replace
    `pd.NaT`, indicating a missing datetime value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignore` will also not cause it to raise an exception. Instead, it will just
    pass in the original value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example using the `ignore` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the errors parameter is set to `'ignore'`, pandas will not raise an error
    if it stumbles upon a date representation it cannot parse. Instead, the input
    value is passed as-is. For example, notice from the preceding output that the
    `to_datetime` function returned an `Index` type and not a `DatetimeIndex`. Further,
    the items in the Index sequence are of dtype `object` (and not `datetime64`).
    In pandas, the object dtype represents strings or mixed types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you explored how you an extract additional datetime properties
    using built-in properties and methods such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**day_name():** Returns the name of the day of the week (e.g., Monday, Tuesday).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**month**: Provides the month component of the date as an integer (1 through
    12).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**month_name():** Returns the full name of the month (e.g., January, February).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'year: Retrieves the year component of the date as an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**days_in_month**: Gives the number of days in the month for the given date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'quarter: Indicates the quarter of the year for the date (1 through 4).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is_quarter_start**: Boolean value indicating whether the date is the first
    day of a quarter (True or False).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is_leap_year**: Boolean value indicating whether the year of the date is
    a leap year (True or False).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is_month_start**: Boolean value indicating whether the date is the first
    day of its month (True or False).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is_month_end**: Boolean value indicating whether the date is the last day
    of its month (True or False).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is_year_start**: Boolean value indicating whether the date is the first day
    of its year (True or False).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternate way to generate a `DatetimeIndex` is with the `pandas.date_range()`
    function. The following code provides a starting date and the number of periods
    to generate and specifies a daily frequency with `D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`pandas.date_range()` requires at least three of the four parameters to be
    provided – `start`, `end`, `periods`, and `freq`. If you do not provide enough
    information, you will get a `ValueError` exception with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explore the different parameter combinations required to use the `date_range`
    function. In the first example, provide a start date, end date, and specify a
    daily frequency. The function will always return a range of equally spaced time
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, provide a start date and an end date, but instead of
    frequency, provide a number of periods. Remember that the function will always
    return a range of equally spaced time points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, provide an end date and the number of periods returned,
    and indicate a daily frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, the `pd.date_range()` function can work with a minimum of two parameters
    if the information is sufficient to generate equally spaced time points and infer
    the missing parameters. Here is an example of providing start and end dates only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that pandas was able to construct the date sequence using the start
    and end dates and default to daily frequency. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With `start` and `periods`, pandas has enough information to construct the date
    sequence and default to daily frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here is an example that lacks enough information on how to generate the
    sequence and will cause pandas to throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that with just a start date and frequency, pandas does not have enough
    information to construct the date sequence. Therefore, adding either `periods`
    or the `end` date will be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put everything we have learned from generating a DatetimeIndex to extracting
    datatime properties. In the following example you will use date_range() function
    to create a DataFrame with one Date column. You will then create additional columns
    using the different properites and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should produce the following DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 A Time Series DataFrame with 5 rows and 12 columns](img/file43.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 A Time Series DataFrame with 5 rows and 12 columns
  prefs: []
  type: TYPE_NORMAL
- en: THE `Series.dt` ACCESSOR
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice the use of `.dt` accessor in the previous code example when working with
    a pandas **Series** of *datetime* object. The `.dt` accessor in pandas is a property
    used for accessing a wide range of datetime properties of a Series. In the previous
    example, you used `.dt` to access the datetime properties of the `df[‘Date’]`
    Series.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about pandas'' `to_datetime()` function and the `DatetimeIndex`
    class, please check out these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.DatetimeIndex` documentation: [https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html](https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas.to_datetime` documentation: [https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a format argument to DateTime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with datasets extracted from different data sources, you may encounter
    date columns stored in string format, whether from files or databases. In the
    previous recipe, *Working with DatetimeIndex*, you explored the `pandas.to_datetime()`
    function that can parse various date formats with minimal input. However, you
    will want more granular control to ensure that the date is parsed correctly. For
    example, you will now be introduced to the `strptime` and `strftime` methods and
    see how you can specify formatting in `pandas.to_datetime()` to handle different
    date formats.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to parse strings that represent dates to
    a `datetime` or `date` object (an instance of the class `datetime.datetime` or
    `datetime.date`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python''s `datetime` module contains the `strptime()` method to create `datetime`
    or `date` from a string that contains a date. You will first explore how you can
    do this in Python and then extend this to pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore a few examples, parsing strings to `datetime` objects using
    `datetime.strptime`. You will parse four different representations of `January
    1, 2022` that will produce the same output – `datetime.datetime(2022, 1, 1, 0,
    0)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the output is a `datetime` object, representing the year, month,
    day, hour, and minute. You can specify only the date representation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will have a `date` object instead of `datetime`. You can get the readable
    version of `datetime` using the `print()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compare what you did using the `datetime.strptime` method using
    `pandas.to_datetime` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can get the string (readable) representation of the `Timestamp`
    object using the `print()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an advantage in using `pandas.to_datetime()` over Python''s `datetime`
    module. The `to_datetime()` function can parse a variety of date representations,
    including string date formats with minimal input or specifications. The following
    code explains this concept; note that the `format` is omitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike `datetime`, which requires integer values or to use the `strptime`
    method for parsing strings, the `pandas.to_datetime()` function can intelligently
    parse different date representations without specifying a format (this is true
    in most cases).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, you used Python's `datetime.datetime` and `pandas.to_datetime`
    methods to parse dates in string formats. When using `datetime`, you had to use
    the `dt.datetime.strptime()` function to specify the date format representation
    in the string using format codes (example `%d`, `%B`, and `%Y`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `datetime.strptime(''1 January, 2022'', ''%d %B, %Y'')`, you
    provided the `%d`, `%B`, and `%Y` format codes in the exact order and spacing
    to represent the formatting provided in the string. Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Understanding the format](img/file44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Understanding the format
  prefs: []
  type: TYPE_NORMAL
- en: '`%d` indicates that the first value is a zero-padded digit representing the
    day of the month, followed by a space to display spacing between the digit and
    the next object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%B` is used to indicate that the second value represents the month''s full
    name. Note that this was followed by a comma (`,`) to describe the exact format
    in the string, for example `"January,"`. Therefore, it is crucial to match the
    format in the strings you are parsing to include any commas, hyphens, backslashes,
    spaces, or whichever separator characters are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To adhere to the string format, there is a space after the comma (`,`), followed
    by `%Y` to reflect the last value represents a four-digit year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FORMAT DIRECTIVES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember that you always use the percent sign (`%`) followed by the format
    code (a letter with or without a negative sign). This is called a formatting directive.
    For example, lower case `y`, as in `%y`, represents the year `22` without the
    century, while uppercase `y`, as in `%Y`, represents the year `2022` with the
    century. Here is a list of common Python directives that can be used in the `strptime()`
    function[: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recall that you used `pandas.to_datetime()` to parse the same string objects
    as with `dt.datetime.strptime()`. The biggest difference is that the pandas function
    can accurately parse the strings without explicitly providing an argument to the
    format parameter. That is one of many advantages of using pandas for time-series
    analysis, especially when handling complex date and `datetime` scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you know how to use `pandas.to_datetime()` to parse string objects to `datetime`.
    So, let's see how you can apply this knowledge to transform a DataFrame column
    that contains date information in string format to a `datetime` data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you will create a small DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the DataFrame to include a DatetimeIndex, you will parse the `Date`
    column to `datetime` and then assign it as an index to the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note how the index is now of the `DatetimeIndex` type, and there is only one
    column in the DataFrame (`Sales`), since `Date` is now an index.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about `pandas.to_datetime`, please visit the official documentation
    page here:[https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html).
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unix epoch timestamps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Epoch timestamps**, sometimes referred to as **Unix time** or **POSIX time**,
    are a common way to store `datetime` in an **integer** **format**. This integer
    represents the number of seconds elapsed from a reference point, and in the case
    of a Unix-based timestamp, the reference point is **January 1, 1970**, at midnight
    (**00:00:00 UTC**). This arbitrary date and time represent the baseline, starting
    at `0`. So, we just increment in seconds for every second beyond that time.'
  prefs: []
  type: TYPE_NORMAL
- en: Many databases, applications, and systems store dates and times in numeric format,
    making it mathematically easier to work with, convert, increment, decrement, and
    so on. Note that in the case of the **Unix epoch**, it is based on **UTC**, which
    stands for **Universal Time Coordinated**. Using UTC is a clear choice when building
    applications used globally, making it easier to store dates and timestamps in
    a standardized format. This makes it easier to work with dates and times without
    worrying about daylight saving or different time zones around the globe. UTC is
    the standard international time used in aviation systems, weather forecast systems,
    the International Space Station, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You will, at some point, encounter Unix epoch timestamps, and to make more sense
    of the data, you will need to convert it to a human-readable format. This is what
    will be covered in this recipe. Again, you will explore the ease of using pandas'
    built-in functions to work with Unix epoch timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start converting the Unix time to a human-readable `datetime` object,
    which is the easy part, let''s first gain some intuition about the idea of storing
    dates and time as a numeric object (a floating-point number):'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use time from the `time` module (part of Python) to request the current
    time in seconds. This will be the time in seconds since the epoch, which for Unix
    systems starts from January 1, 1970, at 00:00:00 UTC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, copy the numeric value you have and visit [https://www.epoch101.com](https://www.epoch101.com).
    The website should display your current epoch time. If you scroll down, you can
    paste the number and convert it to a human-readable format. Make sure that you
    click on **seconds**, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3: Converting a Unix timestamp to a human-readable format in both
    GMT and local time](img/file45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Converting a Unix timestamp to a human-readable format in both
    GMT and local time'
  prefs: []
  type: TYPE_NORMAL
- en: Note, the GMT format was given as `Tue, 21 Nov 2023 20:02:22 GMT` and my local
    format as `Wed Nov 22 2023, 00:02:22 GMT+0400 (Gulf Standard Time)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how pandas converts the epoch timestamp. The convenience here is
    that you will be using the same `pandas.to_datetime()` function that you should
    be familiar with by now, as you have used it in the previous two recipes from
    this chapter. This is one of the many conveniences you get when using pandas.
    For example, in the following code, you will use `pandas.to_datetime()` to parse
    the Unix epoch `1700596942.589581`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note the need to specify units as seconds. The output is similar to that in
    *Figure 6.3* for the GMT format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want `datetime` to be time-zone aware – for example, the US/Pacific
    time zone – you can use `tz_localize(''US/Pacific'')`. To get a more accurate
    conversion though, it is better to do it in two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the time zone-naive object to UTC using `tz_localize('UTC')`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, convert it to the desired time zone using `tz_convert()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows how this is done to convert to the Pacific time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put all of this together. You will convert a DataFrame that contains
    a `datetime` column in Unix epoch format to a human-readable format. You will
    start by creating a new DataFrame with Unix epoch timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new column, call it `Date` by parsing the `unix_epoch` column into
    a `datetime` (which defaults to GMT), then localize the output to UTC, and convert
    to a local time zone. Finally, set the `Date` column as the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that since the `Date` column was of the `datetime` type (not `DatetimeIndex`),
    you had to use the `Series.dt` accessor to tap into the built-in methods and attributes
    for the `datetime` objects. In the last step, you converted `datetime` to a `DatetimeIndex`
    object (a DataFrame index). If you recall from the *Working with DatetimeIndex*
    recipe of this chapter, a `DatetimeIndex` object can access any of the `datetime`
    methods and attributes without using the `dt` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not need the time in your index (`DatetimeIndex`), given your data
    is daily and there is no use case for using time, then you can request just the
    date, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output displays the date without time.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding Unix Epoch time is more relevant as one engages in technical fields
    where precise and standardized time representation is critical.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have used `pandas.to_datetime()` to parse dates in string format
    to a `datetime` object by leveraging the format attribute (see the *Providing
    a format argument to DateTime* recipe). In this recipe, you used the same function,
    but instead of providing a value to format, you passed a value to the unit parameter,
    as in `unit='s'` .
  prefs: []
  type: TYPE_NORMAL
- en: The `unit` parameter tells pandas which unit to use when calculating the difference
    from the epoch start. In this case, the request was in seconds. However, there
    is another critical parameter that you do not need to adjust (in most cases),
    which is the `origin` parameter. For example, the default value is `origin='unix'`,
    which indicates that the calculation should be based on the Unix (or POSIX) time
    set to `01-01-1970 00:00:00 UTC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the actual code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can modify the `origin` to use a different reference date to calculate
    the datetime value. In the following example, the `unit` is specified to be in
    days and the origin is set at `January 1, 2023`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you would like to store your `datetime` value in Unix epoch, you can do this
    by subtracting `1970-01-01` and then floor-divide by a unit of `1` second. Python
    uses `/` as the division operator, `//` as the floor division operator to return
    the floored quotient, and `%` as the modulus operator to return the remainder
    from a division.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new pandas DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then perform the transformation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now generated your Unix epochs. There are different ways to achieve
    similar results. The preceding example is the recommended approach from pandas,
    which you can read more about here: [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch.](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#from-timestamps-to-epoch.)'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about `Timedelta` [in the next recipe.](ch007.xhtml)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about `pandas.to_datetime`, please visit the official documentation
    page here: [https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with time deltas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with time-series data, you may need to perform some calculations
    on your `datetime` columns, such as adding or subtracting. Examples can include
    adding 30 days to purchase `datetime` to determine when the return policy expires
    for a product or when a warranty ends. For example, the `Timedelta` class makes
    it possible to derive new `datetime` objects by adding or subtracting at different
    ranges or increments, such as seconds, daily, and weekly. This includes time zone-aware
    calculations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will explore two practical approaches in pandas to capture
    date/time differences – the `pandas.Timedelta` class and the `pandas.to_timedelta`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this recipe, you will work with hypothetical sales data for a retail store.
    You will generate the sales DataFrame, which will contain items purchased from
    the store and the purchase date. You will then explore different scenarios using
    the `Timedelta` class and the `to_timedelta()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the `pandas` library and creating a DataFrame with two columns,
    `item` and `purchase_dt`, which will be standardized to UTC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should output a DataFrame with six rows (`items`) and two
    columns (`item` and `purchase_dt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: The DataFrame with the item purchased and purchase datetime (UTC)
    data](img/file46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The DataFrame with the item purchased and purchase datetime (UTC)
    data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another `datetime` column to represent the expiration date, which is 30
    days from the purchase date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should add a third column (`expiration_dt`) to the DataFrame,
    which is set at 30 days from the date of purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: The updated DataFrame with a third column reflecting the expiration
    date](img/file47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The updated DataFrame with a third column reflecting the expiration
    date'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, assume you are asked to create a special extended date for return, and
    this one is set at 35 days, 12 hours, and 30 minutes from the purchase date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should add a fourth column (`extended_dt`) to the DataFrame,
    reflecting the new datetime, based on the additional 35 days, 12 hours, and 30
    minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: The updated DataFrame with a fourth datetime column reflecting
    the extended date](img/file48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The updated DataFrame with a fourth datetime column reflecting
    the extended date'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you are asked to convert the time zone from UTC to the local time
    zone of the retailer store''s headquarters, which is set in Los Angeles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After converting from UTC to the US/Pacific time zone (Los Angeles), you are
    overwriting the `datetime` columns (`purchased_dt`, `expiration_dt`, and `extended_dt`).
    The DataFrame structure should remain the same – six rows and four columns – but
    now the data looks different, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: The updated DataFrame where all datetime columns are in Los Angeles
    (US/Pacific)](img/file49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The updated DataFrame where all datetime columns are in Los Angeles
    (US/Pacific)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can calculate the delta between the extended and original expiration
    dates. Since they are both `datetime` data types, you can achieve this with a
    simple subtraction between the two columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Your final DataFrame should now have a fifth column that captures the difference
    between the extended date and the expiration date:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: The updated DataFrame with a fifth column](img/file50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The updated DataFrame with a fifth column'
  prefs: []
  type: TYPE_NORMAL
- en: These types of transformations and calculations are simplified without needing
    any additional libraries, thanks to pandas' built-in capabilities to work with
    time-series data and `datetime` overall.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time deltas can be handy for capturing the difference between two date or time
    objects. In pandas, the `pandas.Timedelta` class is equivalent to Python''s `datetime.timedelta`
    class and behaves very similarly. However, the advantage of pandas is that it
    includes a wide range of classes and functions for working with time-series data.
    These built-in functions within pandas, in general, are simpler and more efficient
    when working with DataFrames. Let''s try this quick experiment to demonstrate
    how pandas'' `Timedelta` class is a subclass of Python''s `timedelta` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s validate that `pandas.Timedelta` is an instance of `datetime.timedelta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Python''s `datetime.timedelta` class accepts integer values for these parameters
    – `days`, `seconds`, `microseconds`, `milliseconds`, `minutes`, `hours`, and `weeks`.
    On the other hand, `pandas.Timedelta` takes both integers and strings, as demonstrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have defined your `Timedelta` object, you can use it to make calculations
    on `date`, `time`, or `datetime` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `week_td` represents a 1-week `Timedelta` object,
    which can be added (or subtracted) from `datetime` to get the difference. By adding
    `week_td`, you are incrementing by 1 week. What if you want to add 2 weeks? You
    can use multiplication as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `pd.Timedelta` is straightforward and makes working with large time-series
    DataFrames efficient without importing additional libraries, as it is built into
    pandas.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous *How to do it...* section, you created a DataFrame and added
    additional columns based on the `timedelta` calculations. You can also add the
    `timedelta` object into a DataFrame and reference it by its column. Finally, let's
    see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s construct the same DataFrame used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce a DataFrame shown in *Figure 6.4*. Now, you will add a
    new column that contains the `Timedelta` object (1 week) and then use that column
    to add and subtract from the `purchased_dt` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should produce a DataFrame with three additional columns.
    The `1 week` column holds the `Timedelta`, object and because of that, you can
    reference the column to calculate any time differences you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: The updated DataFrame with three additional columns](img/file51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The updated DataFrame with three additional columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the data types for each column in the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `1 week` column is a particular data type, `timedelta64` (our
    `Timedelta` object), which allows you to make arithmetic operations on the `date`,
    `time`, and `datetime` columns in your DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Working with DatetimeIndex* recipe, you explored the `pandas.date_range()`
    function to generate a DataFrame with `DatetimeIndex`. The function returns a
    range of equally spaced time points based on the start, end, period and frequency
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you have an option to generate `TimdedeltaIndex` with a fixed frequency
    using the `pandas.timedelta_range()` function, which takes similar parameters
    as the `pandas.date_range()` function. Here is a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: A DataFrame with a Timedelta column](img/file52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: A DataFrame with a Timedelta column'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about the `pandas.timedelta_range()` function, please refer to
    the official documentation here: [https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html](https://pandas.pydata.org/docs/reference/api/pandas.timedelta_range.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about the `pandas.Timedelta` class, please visit the official
    documentation here: [https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html](https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting DateTime with time zone information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with time-series data that requires attention to different time
    zones, things can get out of hand and become more complicated. For example, when
    developing data pipelines, building a data warehouse, or integrating data between
    systems, dealing with time zones requires attention and consensus amongst the
    different stakeholders in the project. For example, in Python, there are several
    libraries and modules dedicated to working with time zone conversion; these include
    `pytz`, `dateutil`, and `zoneinfo`, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss an inspiring example regarding time zones within time-series data.
    It is common for large companies that span their products and services across
    continents to include data from different places around the globe. For example,
    it would be hard to make data-driven business decisions if we neglect time zones.
    Let's say you want to determine whether most customers come to your e-commerce
    site in the morning or evening, and whether shoppers browse during the day and
    then make a purchase in the evening after work. For this analysis, you need to
    be aware of time zone differences and their interpretation on an international
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, you will work with a hypothetical scenario – a small dataset
    that you will generate to represent website visits at different time intervals
    from various locations worldwide. The data will be standardized to UTC, and you
    will work with time-zone conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will start by importing the `pandas` library and creating the time-series
    DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a DataFrame where `visit_dt` is the index of the `DatetimeIndex`
    type and two columns, `Location` and `tz`, indicate the time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: The DataFrame with visit_dt in UTC as an index](img/file53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: The DataFrame with visit_dt in UTC as an index'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you need to convert this DataFrame to be in the same time zone
    as the company''s headquarters in Tokyo. You can do this easily using `DataFrame.tz_convert()`
    against the DataFrame, but you will get a `TypeError` exception if you do this.
    That is because your time-series DataFrame is not time zone-aware. So, you need
    to localize it first using `tz_localize()` to make it time-zone aware. In this
    case, you will localize it to UTC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now convert the DataFrame to the headquarters'' time zone (`Tokyo`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame index, `visit_dt`, will be converted to the new time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: The DataFrame index converted to the headquarters'' time zone
    (Tokyo)](img/file54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: The DataFrame index converted to the headquarters'' time zone
    (Tokyo)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you were able to access the `tz_localize()` and `tz_convert()` methods
    because the DataFrame had an index of type `DatetimeIndex`. If that was not the
    case, you would get a `TypeError` exception with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will localize each row to the appropriate time zone. You will add
    a new column reflecting the time zone, based on the location of the user that
    accessed the website. You will leverage the `tz` column to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce a new column, `local_dt`, which is based on the UTC datetime
    from `visit_dt` and converted based on the time zone provided in the `tz` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: The updated DataFrame with local_dt based on a localized time
    zone for each visit](img/file55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: The updated DataFrame with local_dt based on a localized time
    zone for each visit'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder, what if you did not have a `tz` column? Where would you find
    the right `tz` string? Well, these are called **Time Zone** (**TZ**) database
    names. These are standard names, and you can find a subset of these in the Python
    documentation, or for a more comprehensive list, you can visit this link: [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Converting a time-series DataFrame from one time zone to another was achieved
    using `DataFrame.tz_convert()`, providing it with a time-zone string argument
    such as `US/Pacific`. There are a few assumptions when using `DataFrame.tz_convert()`
    that you need to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The DataFrame should have an index of the `DatetimeIndex` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatetimeIndex` needs to be time zone-aware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You used the `DataFrame.tz_localize()` function to make the index time zone
    aware. It is a good practice to standardize on *UTC* if you are dealing with different
    time zones and daylight saving, since UTC is always consistent and never changes
    (regardless of where you are or if daylight saving time is applied or not). Once
    in UTC, converting to other time zones is very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first localized the data in the previous steps and then converted it to
    a different time zone in two steps. You can also do this in one step by chaining
    the two methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If your index is already time zone-aware, then using `tz_localize()` will produce
    a `TypeError` exception with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that you do not need to localize it again. Instead, just convert
    it to another time zone.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking at the DataFrame in *Figure 6.12*, it is hard to tell immediately whether
    the time was in the morning (AM) or evening (PM). You can format `datetime` using
    `strftime` (which we discussed in the *Providing a format argument to DateTime*
    recipe).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will construct the same DataFrame, localize it to UTC, then convert it
    to the headquarters'' time zone, and apply the new format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We have combined the steps, and this should produce a DataFrame similar to the
    one in *Figure 6.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can update the formatting to use the pattern – `YYYY-MM-DD HH:MM AM/PM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The index will be updated from a format/layout perspective. However, it is
    still time zone-aware, based on Tokyo''s time zone, and the index is still `DatetimeIndex`.
    The only change is to the `datetime` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The updated DataFrame index, formatted based on the date format
    string provided](img/file56.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The updated DataFrame index, formatted based on the date format
    string provided
  prefs: []
  type: TYPE_NORMAL
- en: I am sure you will agree that this is easier to present to users to determine
    whether the visit was AM or PM quickly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about `tz_convert` you can read the official documentation at
    [https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html
    and https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.tz_convert.html](https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.tz_convert.html).
  prefs: []
  type: TYPE_NORMAL
- en: Working with date offsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with time series, it is critical that you learn more about the
    data you are working with and how it relates to the problem you are attempting
    to solve. For example, when working with manufacturing or sales data, you cannot
    assume that an organization's working day is Monday to Friday or whether it uses
    the standard calendar year or fiscal year. You should also consider understanding
    any holiday schedule, annual shutdowns, and other matters related to the business
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: This is where offsets can be handy. They can help transform your dates into
    something more meaningful and relatable to a business. They can also help correct
    data entries that may not be logical.
  prefs: []
  type: TYPE_NORMAL
- en: We will work through a hypothetical example in this recipe and see how to leverage
    pandas offsets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this recipe, you will generate a time-series DataFrame to represent some
    daily logs of production quantity. The company, a US-based firm, would like to
    analyze data to better understand production capacity for future forecasting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the `pandas` library and then generate our DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the name of the days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: When working with any data, always understand the business context behind it.
    Without domain knowledge or business context, it would be difficult to determine
    whether a data point is acceptable or not. In this scenario, the company was described
    as a US-based firm, and thus, working days are Monday to Friday. If there is data
    on a Saturday or Sunday (the weekend), you should not make assumptions without
    validating with the business. You should confirm whether there was any exception
    made for production on those specific weekend dates. Also, realize that January
    1 was a holiday. After investigation, it was confirmed that production did occur
    due to an emergency exception. The business executives do not want to account
    for weekend or holiday work in the forecast. In other words, it was a one-time
    non-occurring event that they do not want to model or build a hypothesis on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The firm asks you to push the weekend/holiday production numbers to the next
    business day instead. Here, you will use `pandas.offsets.BDay()`, which represents
    business days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Because Saturday and Sunday were weekends, their production numbers were pushed
    to the next business day, Monday, January 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform a summary aggregation that adds production numbers by business
    days to understand the impact of this change better:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now, Monday shows to be the most productive day for that week, given it was
    the first business day after the holiday and a long weekend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the business has made another request – they would like to track production
    monthly (`MonthEnd`) and quarterly (`QuarterEnd`). You can use `pandas.offsets`
    again to add two new columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have a DataFrame that should satisfy most of the reporting requirements
    of the business.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using date offsets made it possible to increment, decrement, and transform
    your dates to a new date range following specific rules. There are several offsets
    provided by pandas, each with its own rules, which can be applied to your dataset.
    Here is a list of the common offsets available in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BusinessDay` or `Bday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonthEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BusinessMonthEnd` or `BmonthEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomBusinessDay` or `Cday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuarterEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FY253Quarter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more comprehensive list and their descriptions, you can visit the documentation
    here: [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying an offset in pandas is as simple as doing an addition or subtraction,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Following our example, you may have noticed when using the `BusinessDay` (`BDay`)
    offset that it did not account for the New Year's Day holiday (January 1). So,
    what can be done to account for both the New Year's Day holiday and weekends?
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, pandas provides two approaches to handle standard holidays.
    The first method is by defining a custom holiday. The second approach (when suitable)
    uses an existing holiday offset.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an existing offset. For this example, dealing with New Year,
    you can use the `USFederalHolidayCalendar` class, which has standard holidays
    such as New Year, Christmas, and other holidays specific to the United States.
    So, let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, generate a new DataFrame and import the needed library and classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`USFederalHolidayCalendar` has some holiday rules that you can check using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply these rules, you will use the `CustomerBusinessDay` or `CDay` offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – The USFederalHolidays column added to the DataFrame, which
    recognizes New Year''s Day](img/file57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – The USFederalHolidays column added to the DataFrame, which recognizes
    New Year's Day
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom holiday option will behave in the same way. You will need to import
    the `Holiday` class and the `nearest_workday` function. You will use the `Holiday`
    class to define your specific holidays. In this case, you will determine the New
    Year''s rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to how you applied the `USFederalHolidayCalendar` class to the `CDay`
    offset, you will apply your new `newyears` object to `Cday`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The NewYearsHoliday column, added using a custom holiday offset](img/file58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The NewYearsHoliday column, added using a custom holiday offset
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious about the `nearest_workday` function and how it was used
    in both the `USFederalHolidayCalendar` rules and your custom holiday, then the
    following code illustrates how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As illustrated, the function mainly determines whether the day is a weekday
    or not, and based on that, it will either use the day before (if it falls on a
    Saturday) or the day after (if it falls on a Sunday). There are other rules available
    as well as `nearest_workday`, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sunday_to_Monday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Next_Monday_or_Tuesday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Previous_Friday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Next_monday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more insight regarding `pandas.tseries.holiday`, you can view the actual
    code, which highlights all the classes and functions and can serve as an excellent
    reference, at [https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py](https://github.com/pandas-dev/pandas/blob/master/pandas/tseries/holiday.py).
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom business days
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Companies have different working days worldwide, influenced by the region or
    territory they belong to. For example, when working with time-series data and
    depending on the analysis you need to make, knowing whether certain transactions
    fall on a workday or weekend can make a difference. For example, suppose you are
    doing anomaly detection, and you know that certain types of activities can only
    be done during working hours. In that case, any activities beyond these boundaries
    may trigger some further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will see how you can customize an offset to fit your requirements
    when doing an analysis that depends on defined business days and non-business
    days.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this recipe, you will create custom business days and holidays for a company
    headquartered in Amman, Jordan. In Jordan, the working week is from Sunday to
    Thursday, whereas Friday and Saturday are the 2-day weekend. Additionally, their
    National Day (a holiday) is on May 25 of each year:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ou will start by importing pandas and defining the workdays for Jordan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You will define a custom class holiday `JordanHolidayCalendar` and a new `rule`
    for Jordan’s independence day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You will define a new instance of `CustomBusinessDay` with the custom holiday
    and weekdays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate that the rules were registered properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use `pd.date_range` to generate 10 **business** days starting from
    May 20, 2023\. The generated dates will exclude weekends (Friday and Saturday)
    and the Independence Day holiday (May 25^(th)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easier to determine whether things are working as expected, add
    a new column that represents the day name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The generated time series should have the new custom business days and a holiday
    rule for Jordan.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: The time series generated based on the UAE custom working days
    and holidays](img/file59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: The time series generated based on the UAE custom working days
    and holidays'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6.17* you can see the custom business workdays are from Sunday to
    Monday with the exception of May 25^(th) (Thursday) that was skipped since it
    is a national holiday in Jordan.
  prefs: []
  type: TYPE_NORMAL
- en: The example can be further extended to include different countries and holidays
    to fit the type of analysis you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe builds on the Working with date offsets recipe but focuses on customizing
    offsets. The pandas provides several offsets that can take a custom calendar,
    **holiday**, and **weekmask**. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomBusinessDay` or `Cday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomBusinessMonthEnd` or `CBMonthEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomBusinessMonthBegin` or `CBMonthBegin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomBusinessHour`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They behave like any other offset; the only difference is that they allow you
    to create your own rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe you imported the `CustomBusinessDay` class, created an instance
    of it to create a custom frequency for business days, taking into account weekends
    and holidays. The following code is what you used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is also equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when defining workdays, it was a string of abbreviated weekday names.
    This is called `weekmask`, and it's used in both pandas and NumPy when customizing
    weekdays. In pandas you can also define a custom holiday calendar by extending
    the `AbstractHolidayCalendar` class and including specific dates or rules for
    holidays, as demonstrated in the earlier code for Jordan Independence Day.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s extend the previous example and add custom business hours to the DataFrame.
    This will be another custom offset that you can use in a similar way to `CustomBusinessDay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are applying the same rules, the custom `holidays` and `weekmask`
    for the custom workdays ensuring that the custom business hours also respect the
    defined workweek and holidays. You defined the custom hours by providing the `start`
    and `end` times (in 24-hour format).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a usage example of the custom business hours you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note that custom offsets like `CustomBusinessDay` and `CustomBusinessHour` can
    be applied to both time zone-naive and time zone-aware datetime objects. However,
    the behavior and necessity of making a DataFrame time zone-aware depends on the
    specific use case. When needed, you can make your DataFrame time zone-aware (for
    example, localize it and then convert it to your time zone) using `tz.localize()`
    or `tz.convert()` before applying the custom offset to get better results.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about pandas'' `CustomBusinessDay`, you can read the official
    documentation here: [https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessDay.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about pandas’ `CustomBusinessHours` you can read the official
    documentation here:[https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html](https://pandas.pydata.org/docs/reference/api/pandas.tseries.offsets.CustomBusinessHour.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
