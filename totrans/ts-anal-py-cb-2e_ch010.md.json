["```py\npip install hvplot seaborn matplotlib jupyterlab\n```", "```py\nconda install jupyterlab matplotlib seaborn\nconda install -c pyviz hvplot\n```", "```py\njupyter labextension install @pyviz/jupyterlab_pyviz\n```", "```py\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom statsmodels.datasets import co2, get_rdataset\nfile = Path(‘../../datasets/Ch9/closing_price.csv’)\nclosing_price = pd.read_csv(file,\n                            index_col=‘Date’,\n                            parse_dates=True)\nco2_df = co2.load_pandas().data\nco2_df = co2_df.ffill()\nair_passengers = get_rdataset(“AirPassengers”)\nairp_df = air_passengers.data\nairp_df.index = pd.date_range(‘1949’, ‘1961’, freq=‘M’)\nairp_df.drop(columns=[‘time’], inplace=True)\n```", "```py\nclosing_price.plot();\n```", "```py\nstart_date = ‘2019’\nend_date = ‘2021’\nclosing_price.plot(\n          title=f’Closing Prices from {start_date} – {end_date}’,\n          ylabel= ‘Closing Price’);\n```", "```py\nclosing_price_n = closing_price.div(closing_price.iloc[0])\nclosing_price_n.plot(\n            title=f’Closing Prices from {start_date} – {end_date}’,\n            ylabel= ‘Normalized Closing Price’);\n```", "```py\nclosing_price_n.head()\n```", "```py\nplt.style.use('ggplot')\nclosing_price_n.plot(\n          title=f'Closing Prices from {start_date} - {end_date}',\n          ylabel= 'Normalized Closing Price');\n```", "```py\nplot = closing_price_n.plot(\n            title=f'Closing Prices from {start_date} - {end_date}',\n            ylabel= 'Norm. Price')\nplot.get_figure().savefig('plot_1.jpg', dpi=300)\n```", "```py\nclosing_price.plot(\n           subplots=True,\n           title=f'Closing Prices from {start_date} - {end_date}');\n```", "```py\nimport pandas as pd\nimport hvplot.pandas\nimport hvplot as hv\nclosing_price_n = closing_price.div(closing_price.iloc[0])\n```", "```py\nclosing_price_n.hvplot(\n    title=f'Closing Prices from {start_date} - {end_date}')\n```", "```py\nclosing_price_n.plot(\n    backend='hvplot',\n    title=f'Closing Prices from {start_date} - {end_date}'\n)\n```", "```py\nclosing_price.hvplot(width=300, subplots=True)\n```", "```py\nclosing_price.hvplot(width=300, subplots=True).cols(2)\n```", "```py\n(closing_price_n['AAPL'].hvplot(width=400) +\n closing_price_n['MSFT'].hvplot(width=400))\n```", "```py\n(closing_price_n['AAPL'].hvplot(width=500, height=300) *\n closing_price_n['MSFT'].hvplot()).opts(legend_position='top_left')\n```", "```py\nclosing_price['AAPL'].hvplot.line(by=['index.year'])\n```", "```py\nfrom statsmodels.tsa.seasonal import seasonal_decompose, STL\nplt.rcParams[\"figure.figsize\"] = [10, 5]\n```", "```py\nplt.style.use('grayscale')\n```", "```py\nco2_df.plot(title=co2.TITLE);\n```", "```py\nairp_df['value'].plot(title=air_passengers['title']);\n```", "```py\nco2_decomposed = seasonal_decompose(co2_df,model='additive')\nair_decomposed = seasonal_decompose(airp_df,model='multiplicative')\n```", "```py\nair_decomposed.plot();\n```", "```py\nco2_decomposed.plot();\n```", "```py\n(air_decomposed.trend *\n air_decomposed.seasonal *\n air_decomposed.resid).plot() ;\n```", "```py\nco2_stl = STL(\n    co2_df,\n    seasonal=13,\n    robust=True).fit()\nco2_stl.plot(); plt.show()\n```", "```py\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 4))\nco2_stl.resid.plot(ax=ax1, title='Residual Plot from Seasonal Decomposition')\nco2_decomposed.resid.plot(ax=ax2, title='Residual Plot from STL');\n```", "```py\nfrom statsmodels.tsa.filters.hp_filter import hpfilter\n```", "```py\nco2_cyclic, co2_trend = hpfilter(co2_df)\n```", "```py\nfig, ax = plt.subplots(1,2, figsize=(16, 4))\nco2_cyclic.plot(ax=ax[0], title='CO2 Cyclic Component')\nco2_trend.plot(ax=ax[1], title='CO2 Trend Component');\n```", "```py\n(co2_cyclic + co2_trend).plot();\n```", "```py\nfrom statsmodels.tsa.stattools import adfuller, kpss\n```", "```py\ndef print_results(output, test='adf'):   \n    pval = output[1]\n    test_score = output[0]\n    lags = output[2]   \n    decision = 'Non-Stationary'\n    if test == 'adf':\n        critical = output[4]\n        if pval < 0.05:\n            decision = 'Stationary'\n    elif test=='kpss':\n        critical = output[3]\n        if pval >= 0.05:\n            decision = 'Stationary'           \n    output_dict = {\n    'Test Statistic': test_score,\n    'p-value': pval,\n    'Numbers of lags': lags,\n    'decision': decision\n    }\n    for key, value in critical.items():\n        output_dict[\"Critical Value (%s)\" % key] = value\n\n    return pd.Series(output_dict, name=test)\n```", "```py\nadf_output = adfuller(co2_df)\nkpss_output = kpss(co2_df)\n```", "```py\npd.concat([\nprint_results(adf_output, 'adf'),\nprint_results(kpss_output, 'kpss')\n], axis=1)\n```", "```py\n def check_stationarity(df):\n    kps = kpss(df)\n    adf = adfuller(df)\n\n    kpss_pv, adf_pv = kps[1], adf[1]\n    kpssh, adfh = 'Stationary', 'Non-stationary'\n\n    if adf_pv < 0.05:\n        # Reject ADF Null Hypothesis\n        adfh = 'Stationary'\n    if kpss_pv < 0.05:\n        # Reject KPSS Null Hypothesis\n        kpssh = 'Non-stationary'\n    return (kpssh, adfh) \n```", "```py\ndef plot_comparison(methods, plot_type='line'):\n    n = len(methods) // 2\n    fig, ax = plt.subplots(n,2, sharex=True, figsize=(20,10))\n    for i, method in enumerate(methods):\n        method.dropna(inplace=True)\n        name = [n for n in globals() if globals()[n] is method]\n        v, r = i // 2, i % 2\n        kpss_s, adf_s = check_stationarity(method)\n        method.plot(kind=plot_type,\n                    ax=ax[v,r],\n                    legend=False,\n                    title=f'{name[0]} --> KPSS: {kpss_s}, ADF {adf_s}')\n        ax[v,r].title.set_size(20)\n        method.rolling(52).mean().plot(ax=ax[v,r], legend=False) \n```", "```py\nfirst_order_diff = co2_df.diff().dropna()\n```", "```py\ndifferencing_twice = co2_df.diff(52).diff().dropna()\n```", "```py\nrolling_mean = co2_df.rolling(window=52).mean()\nrolling_mean = co2_df - rolling\n```", "```py\nlog_transform = np.log(co2_df)\n```", "```py\ndecomp = seasonal_decompose(co2_df)\nseasonal_decomp = decomp.resid\n```", "```py\nco2_stl = STL(co2_df, seasonal=13,robust=True).fit()\nstl_decomp = co2_stl.resid\n```", "```py\nhp_cyclic, hp_trend = hpfilter(co2_df)\n```", "```py\nmethods = [first_ord_diff, second_ord_diff,\n           diseasonalize, rolling_mean,\n           log_transform,  seasonal_decomp,\n           stl_decomp, hp_cyclic]\nplot_comparison(methods)\n```", "```py\nadf_result = adfuller(first_order_diff, store=True)\n```", "```py\nadf_result[-1].resols.summary()\n```", "```py\n> pip install scipy\n```", "```py\n> conda install -c anaconda scipy\n```", "```py\nimport numpy as np\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nimport statsmodels.api as sm\n```", "```py\nplt.rcParams[\"figure.figsize\"] = (20,8)\n```", "```py\nfrom scipy.stats import shapiro, kstest, normaltest\nfrom statsmodels.stats.diagnostic import kstest_normal\n```", "```py\ndef is_normal(test, p_level=0.05):\n    stat, pval = test\n    return 'Normal' if pval > 0.05 else 'Not Normal'\n```", "```py\nnormal_args = (np.mean(co2_df),np.std(co2_df))\nprint(is_normal(shapiro(co2_df)))\nprint(is_normal(normaltest(co2_df)))\nprint(is_normal(normal_ad(co2_df)))\nprint(is_normal(kstest_normal(co2_df)))\nprint(is_normal(kstest(co2_df,\n                   cdf='norm',\n                   args=(np.mean(co2_df), np.std(co2_df)))))\n>>\nNot Normal\nNot Normal\nNot Normal\nNot Normal\nNot Normal\n```", "```py\nfrom statsmodels.tsa.api import AutoReg\nmodel = AutoReg(co2_df.dropna(), lags=1).fit()\n```", "```py\nprint(is_normal(shapiro(model.resid)))\n>>\n'Not Normal'\n```", "```py\nfrom statsmodels.stats.api import (het_breuschpagan,\n                                   het_white)\n```", "```py\ndef het_test(model, test=het_breuschpagan):\n    lm, lm_pvalue, fvalue, f_pvalue = (\n        het_breuschpagan(model.resid,\n                         sm.add_constant(\n                             model.fittedvalues)\n                        ))\n\n    return \"Heteroskedastic\" if f_pvalue < 0.05 else \"Homoskedastic\"\n```", "```py\nhet_test(model, test=het_breuschpagan)\n>> 'Homoskedastic'\n```", "```py\nhet_test(model, test=het_white)\n>> 'Homoskedastic'\n```", "```py\nfrom scipy.stats import boxcox\n```", "```py\nxt, lmbda = boxcox(airp_df['passengers'])\nxts = pd.Series(xt, index=airp_df.index)\n```", "```py\nfig, ax = plt.subplots(1, 2, figsize=(16,5))\nairp_df.hist(ax=ax[0])\nax[0].set_title('Original Time Series')\nxts.hist(ax=ax[1])\nax[1].set_title('Box-Cox Transformed');\n```", "```py\nfig, ax = plt.subplots(1, 2, figsize=(16,5))\nairp_df.plot(ax=ax[0])\nax[0].set_title('Original Time Series')\nxts.plot(ax=ax[1])\nax[1].set_title('Box-Cox Transformed');\n```", "```py\nfig, ax = plt.subplots(1, 2, figsize=(16,5))\nmodel_airp.resid.plot(ax=ax[0])\nax[0].set_title('Residuals Plot - Regular Time Series')\nmodel_bx.resid.plot(ax=ax[1])\nax[1].set_title('Residual Plot - Box-Cox Transformed');\n```", "```py\nprint(model_bx.diagnostic_summary())\n```", "```py\nmodel_bx.plot_diagnostics(); plt.show()\n```", "```py\nfrom statsmodels.stats.diagnostic import acorr_ljungbox\n```", "```py\nco2_diff= np.log(co2_df).diff().dropna()\n```", "```py\nacorr_ljungbox(co2_diff, lags=10, return_df=True)\n```", "```py\nacorr_ljungbox(model_bx.resid, return_df=True, lags=10)\n```"]