- en: <st c="0">10</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">10</st>
- en: <st c="3">Network Analysis</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">网络分析</st>
- en: <st c="20">This chapter is about networks and datasets represented by networks.</st>
    <st c="90">Networks link things together.</st> <st c="121">Since many things in
    real-world data science are linked to each other, you will encounter networks
    and network data a lot as a data scientist.</st> <st c="264">Therefore, as a data
    scientist, you must learn something about networks and how to analyze them.</st>
    <st c="361">To learn about networks, we will cover the</st> <st c="404">following
    topics:</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20">本章讲的是网络和由网络表示的数据集。</st> <st c="90">网络将事物联系在一起。</st> <st c="121">由于现实世界数据科学中的许多事物都是相互连接的，作为数据科学家，你将经常遇到网络和网络数据。</st>
    <st c="264">因此，作为数据科学家，你必须了解一些关于网络及其分析的方法。</st> <st c="361">为了了解网络，我们将涵盖以下主题：</st>
- en: '*<st c="421">Graphs and network data</st>*<st c="445">: In this section, we’ll
    learn why network data is important for data science and what a</st> <st c="535">graph
    is</st>'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="421">图形和网络数据</st>*<st c="445">：在本节中，我们将学习为什么网络数据对数据科学很重要，以及什么是</st>
    <st c="535">图形</st>'
- en: '*<st c="543">Basic characteristics of graphs</st>*<st c="575">: Here, we’ll
    learn the essential concepts and terminology relating to graphs, and in particular
    about</st> <st c="679">adjacency matrices</st>'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="543">图形的基本特征</st>*<st c="575">：在这里，我们将学习与图形相关的基本概念和术语，特别是关于</st> <st
    c="679">邻接矩阵</st>'
- en: '*<st c="697">Different types of graphs</st>*<st c="723">: In this section,
    we’ll learn about some of the main classes of graphs you will encounter as a data
    scientist and the behavior and properties of those different classes</st> <st
    c="894">of graphs</st>'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="697">不同类型的图形</st>*<st c="723">：在本节中，我们将学习一些你作为数据科学家常遇到的主要图形类别，以及这些不同类别图形的行为和特性</st>
    <st c="894">。</st>'
- en: '*<st c="903">Community detection and decomposing graphs</st>*<st c="946">:
    Finally, we’ll learn about breaking a graph down into its</st> <st c="1007">important
    sub-graphs</st>'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="903">社区检测和图的分解</st>*<st c="946">：最后，我们将学习如何将一个图分解成其重要的子图</st>'
- en: <st c="1027">Technical requirements</st>
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1027">技术要求</st>
- en: <st c="1050">All the code examples provided in this chapter can be found in
    this book’s GitHub repository:</st> [<st c="1145">https://github.com/PacktPublishing/15-Math-Concepts-Every-Data-Scientist-Should-Know/tree/main/Chapter10</st>](https://github.com/PacktPublishing/15-Math-Concepts-Every-Data-Scientist-Should-Know/tree/main/Chapter10)<st
    c="1249">. To run the Jupyter Notebooks provided, you will need a full Python
    installation, including the</st> <st c="1346">following packages:</st>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1050">本章提供的所有代码示例可以在本书的 GitHub 仓库中找到：</st> [<st c="1145">https://github.com/PacktPublishing/15-Math-Concepts-Every-Data-Scientist-Should-Know/tree/main/Chapter10</st>](https://github.com/PacktPublishing/15-Math-Concepts-Every-Data-Scientist-Should-Know/tree/main/Chapter10)<st
    c="1249">。要运行提供的 Jupyter Notebooks，你需要完整的 Python 安装，并包括以下包：</st>
- en: '`<st c="1365">numpy</st>` <st c="1371">(>=1.24.3)</st>'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1365">numpy</st>` <st c="1371">(>=1.24.3)</st>'
- en: '`<st c="1382">matplotlib</st>` <st c="1393">(>=3.7.2)</st>'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1382">matplotlib</st>` <st c="1393">(>=3.7.2)</st>'
- en: '`<st c="1403">NetworkX</st>` <st c="1412">(>=3.1.0)</st>'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1403">NetworkX</st>` <st c="1412">(>=3.1.0)</st>'
- en: <st c="1422">Graphs and network data</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1422">图形和网络数据</st>
- en: <st c="1446">In the introduction, we</st> <st c="1470">mentioned that much of
    the real-world data you will encounter as a data scientist is network data.</st>
    <st c="1570">However, not all real-world</st> <st c="1598">data is network data.</st>
    <st c="1620">So, how do we recognize when we are dealing with network data, and
    perhaps more importantly, how do we recognize when the network aspect of the data
    is relevant to how we analyze</st> <st c="1799">the data?</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1446">在介绍中，我们</st> <st c="1470">提到，作为数据科学家，你将遇到的大部分现实世界数据是网络数据。</st>
    <st c="1570">然而，并非所有现实世界</st> <st c="1598">数据都是网络数据。</st> <st c="1620">那么，我们如何识别何时处理的是网络数据？更重要的是，如何识别数据的网络方面是否对我们的分析</st>
    <st c="1799">有影响？</st>
- en: <st c="1808">Network data is about relationships</st>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="1808">网络数据关乎关系</st>
- en: <st c="1844">In the introduction, we</st> <st c="1869">explained that we need
    to learn about network data because the things that produce the data are linked
    to each other.</st> <st c="1987">This tells us that network data is about relationships.</st>
    <st c="2043">Or rather, network data arises when we have relationships between
    many of the data-generating entities we are studying.</st> <st c="2163">This also
    gives us a useful rule-of-thumb for when we should take the network aspect of
    the data into account in</st> <st c="2276">our analysis:</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1844">在引言中，我们</st> <st c="1869">解释了我们需要了解网络数据，因为生成这些数据的事物是相互关联的。</st>
    <st c="1987">这告诉我们，网络数据是关于关系的。</st> <st c="2043">或者说，当我们研究的许多数据生成实体之间存在关系时，就会产生网络数据。</st>
    <st c="2163">这也为我们提供了一个有用的经验法则，告诉我们何时在分析中需要考虑数据的网络属性：</st>
- en: <st c="2289">If the relationships between the entities we are studying are strong,
    then we can’t ignore the network aspect of</st> <st c="2403">the data</st>
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2289">如果我们研究的实体之间的关系很强，那么我们就不能忽略数据的网络属性。</st>
- en: <st c="2411">Conversely, if the relationships between the entities we are studying
    are all weak, then we can probably ignore the network aspect of</st> <st c="2546">the
    data</st>
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2411">相反，如果我们研究的实体之间的关系都很弱，那么我们可能可以忽略数据的网络属性。</st>
- en: <st c="2554">It is important to realize that when relationships are weak, we
    still have a network and network data.</st> <st c="2658">But by ignoring the network
    structure in our analysis, we are making an approximation.</st> <st c="2745">Analyzing
    the data on this basis will be easier and will still yield valuable insights,
    so the approximation of ignoring the network aspect of the data is a useful one.</st>
    <st c="2914">However, we would get more accurate analysis and insights if we did
    consider the network aspect of the data, but this would be at the expense of having
    to use or implement more complex analyses</st> <st c="3108">and algorithms.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2554">需要意识到的是，当关系较弱时，我们仍然有一个网络和网络数据。</st> <st c="2658">但是，忽略网络结构进行分析时，我们实际上是在做一个近似。</st>
    <st c="2745">基于这一点分析数据会更简单，而且仍能提供有价值的见解，因此忽略数据网络属性的近似是一个有用的选择。</st> <st c="2914">然而，如果我们考虑数据的网络属性，分析和洞察将更加准确，但这将需要使用或实施更复杂的分析</st>
    <st c="3108">和算法。</st>
- en: <st c="3123">So, how do we decide whether the relationships are weak enough
    to ignore?</st> <st c="3198">This is a skill that’s acquired through experience.</st>
    <st c="3250">To help you with this, we’ll look at a couple of real-world examples
    where the presence of relationships is central to the data to be analyzed.</st>
    <st c="3394">We’ll touch on these examples throughout</st> <st c="3435">this chapter.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3123">那么，我们如何判断关系是否足够弱以至于可以忽略呢？</st> <st c="3198">这是一个通过经验获得的技能。</st>
    <st c="3250">为了帮助你，我们将通过几个现实世界的例子来说明关系在待分析数据中的重要性。</st> <st c="3394">我们将在本章中多次提到这些例子。</st>
- en: <st c="3448">Example 1 – substituting goods in a supermarket</st>
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3448">示例 1 – 超市中商品替代</st>
- en: <st c="3496">We’ll start with a</st> <st c="3516">commerce example – goods sold
    in a supermarket.</st> <st c="3564">When a shopper buys food in a supermarket,
    they have many choices.</st> <st c="3631">Let’s consider the example of a shopper
    wanting to buy a frozen pizza.</st> <st c="3702">In many supermarkets, the shopper
    will have the choice between a couple of different brands and several different
    flavors.</st> *<st c="3825">Figure 10</st>**<st c="3834">.1</st>* <st c="3836">shows
    a hypothetical but realistic example of the set of brands and flavors that a shopper
    might choose between when buying a</st> <st c="3963">frozen pizza:</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3496">我们将从一个</st> <st c="3516">商业案例开始——超市中销售的商品。</st> <st c="3564">当顾客在超市购买食品时，他们有很多选择。</st>
    <st c="3631">我们以顾客想买一份冷冻披萨为例。</st> <st c="3702">在许多超市中，顾客可以选择几个不同品牌和几种不同口味的冷冻披萨。</st>
    *<st c="3825">图 10</st>**<st c="3834">.1</st>* <st c="3836">展示了一个假设但现实的例子，说明顾客在购买冷冻披萨时可能选择的品牌和口味组合：</st>
    <st c="3963">冷冻披萨：</st>
- en: '![Figure 10.1: Frozen pizza brands and flavors](img/B19496_10_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1: 冷冻披萨品牌和口味](img/B19496_10_1.jpg)'
- en: '<st c="4222">Figure 10.1: Frozen pizza brands and flavors</st>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="4222">图 10.1: 冷冻披萨品牌和口味</st>'
- en: <st c="4266">When choosing a pizza, shoppers are happy to swap between certain
    brands and certain flavors if the price is right.</st> <st c="4383">The solid
    line between two pizzas in</st> <st c="4420">Figure 10</st><st c="4429">.1 indicates
    that a shopper considers those pizzas interchangeable or substitutes for each
    other.</st> <st c="4527">This means that there is a relationship between those
    two pizzas, that</st> <st c="4598">of substitutability.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4266">当选择披萨时，消费者很乐意在某些品牌和口味之间交换，只要价格合适。</st> <st c="4383">图中<st c="4420">图
    10</st><st c="4429">.1 中两种披萨之间的实线表示消费者认为这两种披萨可以互换，或者说是互为替代品。</st> <st c="4527">这意味着这两种披萨之间存在一种关系，即</st>
    <st c="4598">替代性关系。</st>
- en: <st c="4618">From the supermarket’s perspective, it is crucial to understand
    which pairs of pizzas are substitutes for each other.</st> <st c="4737">The more
    substitutes a shopper considers there to be, the more options they have if one
    of the pizzas is priced too high, and so the more price-sensitive the shopper
    is when choosing between the substitutes.</st> <st c="4945">This means that pizzas
    with a lot of substitutes must be priced very competitively.</st> <st c="5029">In
    contrast, the ham and pineapple pizza in</st> *<st c="5073">Figure 10</st>**<st
    c="5082">.1</st>* <st c="5084">has only one substitute – the ham and cheese pizza
    – and so doesn’t have to be priced as competitively as the pepperoni and cheese
    and tomato pizzas.</st> <st c="5235">From the supermarket’s perspective, knowing
    this substitutability network structure determines their pricing strategy and
    ultimately</st> <st c="5368">their profitability.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4618">从超市的角度来看，了解哪些披萨是相互替代的非常重要。</st> <st c="4737">消费者越认为某些披萨之间有替代性，当某种披萨的价格过高时，他们就越有选择余地，因此在选择替代品时，他们的价格敏感度也更高。</st>
    <st c="4945">这意味着，拥有大量替代品的披萨必须定价非常具有竞争力。</st> <st c="5029">相比之下，图中*<st c="5073">图
    10</st>**<st c="5082">.1</st>* 所示的火腿菠萝披萨只有一个替代品——火腿奶酪披萨，因此它的定价不必像意大利辣肠奶酪披萨和番茄披萨那样具有竞争力。</st>
    <st c="5235">从超市的角度来看，了解这种替代性网络结构决定了他们的定价策略，并最终影响了</st> <st c="5368">他们的盈利能力。</st>
- en: <st c="5388">Example 2 – international trade</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5388">示例 2 – 国际贸易</st>
- en: <st c="5420">If we want to understand</st> <st c="5445">economics at an international
    level, we need to understand the imports and exports from each country as trade
    between countries contributes significantly to the balance sheet of each country.</st>
    <st c="5638">This means we cannot ignore trading relationships between countries
    when analyzing the GDP of</st> <st c="5732">each country.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5420">如果我们想要理解</st> <st c="5445">国际经济学，就需要了解各国的进出口情况，因为国家间的贸易对每个国家的财务报表有着重要影响。</st>
    <st c="5638">这意味着，在分析各国 GDP 时，我们不能忽视各国之间的贸易关系。</st>
- en: '*<st c="5745">Figure 10</st>**<st c="5755">.2</st>* <st c="5757">shows the
    cash value (in US dollars) of the total exports from five different European countries
    (UK, Germany, France, Italy, and Spain) for 2022\.</st> <st c="5905">The export
    figures were obtained from</st> [<st c="5943">https://comtradeplus.un.org/</st>](https://comtradeplus.un.org/)<st
    c="5971">. Each arc represents the total export from one country to the other.</st>
    <st c="6041">The color of the arc matches the exporting country.</st> <st c="6093">The
    thickness of the arc is proportional to the total</st> <st c="6147">export value:</st>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="5745">图 10</st>**<st c="5755">.2</st>* <st c="5757">展示了五个不同欧洲国家（英国、德国、法国、意大利和西班牙）在
    2022 年的总出口现金价值（以美元计）。</st> <st c="5905">出口数据来自</st> [<st c="5943">https://comtradeplus.un.org/</st>](https://comtradeplus.un.org/)<st
    c="5971">。每个弧线代表一个国家对另一个国家的总出口。</st> <st c="6041">弧线的颜色与出口国匹配。</st> <st c="6093">弧线的粗细与总出口值成比例：</st>'
- en: '![Figure 10.2: The network of exports between Germany (GER), France (FRA),
    Italy (ITA), Spain (SPN), and the United Kingdom (UK) in 2022](img/B19496_10_2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：2022 年德国（GER）、法国（FRA）、意大利（ITA）、西班牙（SPN）和英国（UK）之间的出口网络](img/B19496_10_2.jpg)'
- en: '<st c="6162">Figure 10.2: The network of exports between Germany (GER), France
    (FRA), Italy (ITA), Spain (SPN), and the United Kingdom (UK) in 2022</st>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6162">图 10.2：2022 年德国（GER）、法国（FRA）、意大利（ITA）、西班牙（SPN）和英国（UK）之间的出口网络</st>
- en: <st c="6296">The network structure of international trade is clear from this
    visualization.</st> <st c="6376">The visualization also makes it immediately clear
    which countries export the most, and which have the strongest</st> <st c="6487">reciprocal</st>
    <st c="6499">trading relationships.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6296">国际贸易的网络结构从这个可视化中可以清楚地看出。</st> <st c="6376">该可视化还立即展示了哪些国家的出口量最大，以及哪些国家有最强的</st>
    <st c="6487">互惠</st> <st c="6499">贸易关系。</st>
- en: <st c="6521">Now that we have introduced two examples of networks in real-world
    data science, let’s look at what they have in common and the terminology we can
    use to describe those common features.</st> <st c="6708">This brings us to the
    mathematical concept of</st> <st c="6754">a</st> **<st c="6756">graph</st>**<st
    c="6761">.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6521">现在我们已经介绍了现实世界数据科学中的两个网络示例，让我们来看一下它们的共同点，以及我们可以用来描述这些共同特征的术语。</st>
    <st c="6708">这将引出我们讨论的数学概念</st> <st c="6754">一个</st> **<st c="6756">图</st>**<st
    c="6761">。</st>
- en: <st c="6762">What is a graph?</st>
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6762">什么是图？</st>
- en: <st c="6779">In both the</st> <st c="6792">real-world examples provided, we
    visualized the network as a 2D object, consisting</st> <st c="6875">of a set of
    entities with connections or arcs between them.</st> <st c="6935">This is because
    this is a very natural and intuitive way of visualizing a network.</st> <st c="7018">Because
    of this, these 2D objects are considered mathematical objects in their own right
    and have their own branch of mathematics that studies them.</st> <st c="7167">In
    mathematics, a 2D object such as that shown in</st> *<st c="7217">Figure 10</st>**<st
    c="7226">.1</st>* <st c="7228">or</st> *<st c="7232">Figure 10</st>**<st c="7241">.2</st>*
    <st c="7244">is called a</st> **<st c="7256">graph</st>**<st c="7261">. The mathematical
    study of graphs is</st> <st c="7299">called</st> **<st c="7306">graph theory</st>**<st
    c="7318">.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6779">在这两个</st> <st c="6792">提供的现实世界示例中，我们将网络可视化为一个二维对象，由一组实体和它们之间的连接或弧组成。</st>
    <st c="6935">这是因为这种方式非常自然且直观，能够展示网络。</st> <st c="7018">因此，这些二维对象被视为独立的数学对象，并且有自己专门的数学分支来研究它们。</st>
    <st c="7167">在数学中，像</st> *<st c="7217">图 10</st>**<st c="7226">.1</st>* <st c="7228">或</st>
    *<st c="7232">图 10</st>**<st c="7241">.2</st>* <st c="7244">所示的二维对象被称为</st> **<st
    c="7256">图</st>**<st c="7261">。图的数学研究被称为</st> **<st c="7306">图论</st>**<st c="7318">。</st>
- en: <st c="7319">Consequently, the terms</st> **<st c="7344">network</st>** <st
    c="7351">and</st> **<st c="7356">graph</st>** <st c="7361">are used interchangeably.</st>
    <st c="7388">Likewise, network analysis and graph theory are used interchangeably,
    although network analysis tends to be preferentially used when we are dealing
    with real-world networks or data generated by real-world networks, while graph
    theory tends to be preferentially used when we are dealing with the more abstract
    analysis of graph structures and</st> <st c="7730">their properties.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7319">因此，术语</st> **<st c="7344">网络</st>** <st c="7351">和</st> **<st c="7356">图</st>**
    <st c="7361">常常可以互换使用。</st> <st c="7388">同样，网络分析和图论也可以互换使用，尽管当我们处理现实世界的网络或由现实世界网络生成的数据时，通常会优先使用网络分析，而在处理更抽象的图结构分析及</st>
    <st c="7730">其属性时</st>，则通常优先使用图论。</st>
- en: <st c="7747">What is central to graph theory is that a graph consists of a set</st>
    <st c="7814">of entities called</st> **<st c="7833">nodes</st>** <st c="7838">and
    a set of connections between</st> <st c="7872">nodes called</st> **<st c="7885">edges</st>**<st
    c="7890">. In graph theory, a node tends to be</st> <st c="7927">called a</st>
    **<st c="7937">vertex</st>**<st c="7943">, so the terminology nodes and vertices
    are interchangeable.</st> <st c="8004">Consequently, a graph,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3354.png)<st
    c="8027"><st c="8028">, consists of a set of vertices,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="8061"><st c="8062">, and a set of edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3356.png)<st
    c="8084"><st c="8085">. In math, we denote this as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3357.png)<st
    c="8114"><st c="8119">, meaning the graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3354.png)<st
    c="8140"><st c="8141">, has vertices,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="8157"><st c="8158">, and edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3360.png)<st
    c="8171"><st c="8172">. This is illustrated schematically by the generic graph
    in</st> <st c="8232">Figure</st> <st c="8238">10</st><st c="8241">.3:</st></st></st></st></st></st></st></st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7747">图论的核心是一个图包含一组实体，称为</st> <st c="7814">**<st c="7833">节点</st>** <st
    c="7838">和一组连接节点的</st> **<st c="7885">边</st>**<st c="7890">。在图论中，节点通常称为</st> **<st
    c="7937">顶点</st>**<st c="7943">，因此术语节点和顶点可以互换使用。</st> <st c="8004">因此，一个图,</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3354.png)<st
    c="8027"><st c="8028">，由一组顶点,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="8061"><st c="8062">，和一组边,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3356.png)<st
    c="8084"><st c="8085">组成。在数学中，我们将其表示为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3357.png)<st
    c="8114"><st c="8119">，意味着图,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3354.png)<st
    c="8140"><st c="8141">，具有顶点,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="8157"><st c="8158">，和边,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3360.png)<st
    c="8171"><st c="8172">。这在通用图中以示意图示。</st> <st c="8232">图</st> <st c="8238">10</st><st
    c="8241">.3:</st></st></st></st></st></st></st></st>
- en: '![Figure 10.3: Schematic of a generic graph, ​G.​](img/B19496_10_3.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：通用图谱的示意图，G](img/B19496_10_3.jpg)'
- en: '<st c="8286">Figure 10.3: Schematic of a generic graph, G</st><st c="8330">.</st>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8286">图 10.3：通用图谱的示意图，G</st><st c="8330">。</st>
- en: <st c="8331">In our first</st> <st c="8345">real-world example, the nodes or
    vertices are the different pizzas, and the edges are the solid lines indicating
    a substitutability relationship between two types of pizza.</st> <st c="8518">In
    our second real-world example, the nodes or vertices were the European countries,
    and the edges were the trading relationships</st> <st c="8648">between them.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8331">在我们的第一个实例中，节点或顶点是不同种类的披萨，边是表示两种披萨之间替代关系的实线。</st> <st c="8518">在我们的第二个实例中，节点或顶点是欧洲国家，边是它们之间的贸易关系。</st>
- en: <st c="8661">In a graph, both the nodes and edges can have attributes – that
    is, additional data or values associated with them.</st> <st c="8778">Typically,
    in a data science context, it is these attributes that we are interested in, and
    we study how the network</st> <st c="8895">structure or</st> **<st c="8908">topology</st>**
    <st c="8916">affects them.</st> <st c="8931">In our first real-world example,
    it was the price of the pizzas that we were interested in, and this was an attribute
    of the pizzas – that is, a node attribute.</st> <st c="9092">In our second real-world
    example, it was the total exports from one country to another that we were interested
    in, and this was an edge attribute.</st> <st c="9239">In general, an edge attribute
    is termed</st> <st c="9279">an</st> **<st c="9282">edge weight</st>**<st c="9293">,
    as it is typically used to quantify the strength or weight of the relationship
    between the entities represented by the two nodes connected by</st> <st c="9437">the
    edge.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8661">在图中，节点和边都可以有属性——即与之相关的额外数据或值。</st> <st c="8778">通常，在数据科学的背景下，正是这些属性是我们关心的，我们研究的是网络</st>
    <st c="8895">结构或</st> **<st c="8908">拓扑</st>** <st c="8916">如何影响它们。</st> <st c="8931">在我们的第一个实际例子中，我们关注的是披萨的价格，这是披萨的一个属性——即，节点属性。</st>
    <st c="9092">在我们的第二个实际例子中，我们关注的是一个国家对另一个国家的总出口，这个是边的属性。</st> <st c="9239">一般来说，边的属性称为</st>
    <st c="9279">边的</st> **<st c="9282">权重</st>**<st c="9293">，因为它通常用于量化由连接两个节点所表示的实体之间关系的强度或权重。</st>
    <st c="9437">边的强度。</st>
- en: <st c="9446">From our real-world examples, we can see that although graphs consist
    of just two simple things, nodes and edges, graphs are far from being simple mathematical
    objects.</st> <st c="9616">There are a lot of different quantities and characteristics
    of a graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3361.png)<st
    c="9688"><st c="9689">, that we can calculate.</st> <st c="9714">In the next section,
    we will begin to outline some of the more commonly calculated graph characteristics
    and introduce some of the more commonly used concepts and terminology in graph
    theory.</st> <st c="9906">However, this is also a good place to end this introductory
    section on network data and what networks are, so we’ll recap what we</st> <st
    c="10036">have covered.</st></st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9446">从我们的实际例子中可以看出，尽管图仅由两个简单的元素组成——节点和边，但图远非简单的数学对象。</st> <st c="9616">图有很多不同的量度和特性，</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3361.png)<st
    c="9688"><st c="9689">，这些我们可以计算出来。</st> <st c="9714">在接下来的部分，我们将开始概述一些更常见的图特性计算方法，并介绍图论中一些常用的概念和术语。</st>
    <st c="9906">不过，这也是结束网络数据和网络是什么的介绍性部分的好时机，因此我们将回顾我们</st> <st c="10036">所涵盖的内容。</st></st>
- en: <st c="10049">What we’ve learned</st>
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10049">我们学到的内容</st>
- en: <st c="10068">In this section, we learned</st> <st c="10097">the following:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10068">在这一部分，我们学到了</st> <st c="10097">以下内容：</st>
- en: <st c="10111">Networks imply relationships and we use networks to represent
    data where relationships are important.</st> <st c="10214">This is usually where
    those relationships have a significant effect on the data associated with the
    entities between which the</st> <st c="10341">relationships exist.</st>
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="10111">网络表示关系，我们使用网络来表示关系重要的数据。</st> <st c="10214">通常，这些关系对相关实体之间的数据有显著影响。</st>
    <st c="10341">这些关系存在于实体之间。</st>
- en: <st c="10361">A network is also a graph.</st> <st c="10389">A graph consists
    of nodes (vertices) and edges.</st> <st c="10437">The nodes and edges can have
    attributes or weights associated</st> <st c="10499">with them.</st>
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="10361">网络也是一个图。</st> <st c="10389">图由节点（顶点）和边组成。</st> <st c="10437">节点和边可以有属性或权重与之关联。</st>
    <st c="10499">它们。</st>
- en: <st c="10509">Having introduced the basic idea of what a network is and how
    one can be used to represent relationship data, let’s learn how to mathematically
    characterize the properties of</st> <st c="10685">a graph.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10509">在介绍了网络是什么以及如何用网络表示关系数据的基本概念后，让我们学习如何数学地表征图的属性。</st>
- en: <st c="10693">Basic characteristics of graphs</st>
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="10693">图的基本特性</st>
- en: <st c="10725">A graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3361.png)<st
    c="10735"><st c="10736">, has nodes (vertices),</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3363.png)<st
    c="10760"><st c="10761">, and edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3364.png)<st
    c="10774"><st c="10775">, but to uncover and analyze the rich structure</st> <st
    c="10822">present in a network, we’ll need to introduce additional concepts and
    terminology beyond just nodes and edges.</st> <st c="10934">Let’s start with those
    edges, which come in</st> <st c="10978">two flavors.</st></st></st></st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10725">图</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3361.png)<st
    c="10735"><st c="10736">，有节点（顶点）</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3363.png)<st
    c="10760"><st c="10761">，和边</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3364.png)<st
    c="10774"><st c="10775">，但是要揭示和分析网络中的丰富结构</st> <st c="10822">，我们需要引入除了节点和边以外的附加概念和术语。</st>
    <st c="10934">我们从这些边开始，它们有</st> <st c="10978">两种类型。</st></st></st></st>
- en: <st c="10990">Undirected and directed edges</st>
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10990">无向边和有向边</st>
- en: <st c="11020">A key</st> <st c="11027">difference between our two real-world
    examples was that in our pizza example, the presence of an edge denoted a substitutability
    relationship that applied in both directions.</st> <st c="11202">An ACME Pizzas
    cheese and tomato pizza is considered by</st> <st c="11258">shoppers to be a substitute
    for a Premier Pizzas cheese and tomato pizza, and vice versa.</st> <st c="11348">In
    contrast, the arcs in our trade network in</st> <st c="11394">Figure 10</st><st
    c="11403">.2 have a direction associated with them, indicated by the arrow at
    the end of each arc.</st> <st c="11492">The exports from the UK to Germany do
    not match the exports from Germany to the UK.</st> <st c="11576">In</st> <st c="11579">Figure
    10</st><st c="11588">.2, we represented this by having two directed edges between
    the UK and Germany nodes, with different edge weights.</st> <st c="11704">Schematically,
    we used the arc thickness to represent the edge weight, so you can see the asymmetry
    in exports between the UK and Germany in</st> <st c="11845">Figure 10</st><st
    c="11854">.2.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11020">我们两个现实世界示例之间的一个关键</st> <st c="11027">区别在于，在我们的披萨示例中，边的存在表示了适用于双向的替代关系。</st>
    <st c="11202">ACME 披萨的芝士和番茄披萨被</st> <st c="11258">顾客视为 Premier 披萨芝士和番茄披萨的替代品，反之亦然。</st>
    <st c="11348">相比之下，我们贸易网络中的弧线</st> <st c="11394">图 10</st><st c="11403">.2 的方向性由每条弧线末端的箭头指示。</st>
    <st c="11492">从英国到德国的出口与从德国到英国的出口不匹配。</st> <st c="11576">在</st> <st c="11579">图
    10</st><st c="11588">.2 中，我们通过在英国和德国节点之间绘制两条有向边并赋予不同的边权重来表示这一点。</st> <st c="11704">在示意图中，我们用弧线的粗细来表示边的权重，所以你可以看到英国和德国之间出口的不对称性，见</st>
    <st c="11845">图 10</st><st c="11854">.2。</st>
- en: <st c="11857">More generally, we</st> <st c="11876">refer to an edge</st> <st
    c="11893">as being</st> **<st c="11903">directed</st>** <st c="11911">if it has
    a specific direction</st> <st c="11942">associated with it.</st> <st c="11963">If
    an edge does not have a specific direction associated with it, we say it is an</st>
    **<st c="12045">undirected</st>** <st c="12055">edge.</st> <st c="12062">Edges</st>
    <st c="12067">that represent flows of some quantity are directed, while an edge
    that represents a symmetric relationship is undirected.</st> <st c="12190">Figure
    10</st><st c="12199">.4 shows the different types of edges we can get bet</st><st
    c="12251">ween</st> <st c="12257">two nodes:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11857">更一般地，我们</st> <st c="11876">将一条边称为</st> **<st c="11903">有向</st>**
    <st c="11911">如果它有特定的方向</st> <st c="11942">与之相关。</st> <st c="11963">如果一条边没有特定的方向，我们说它是一个</st>
    **<st c="12045">无向</st>** <st c="12055">边。</st> <st c="12062">表示某种数量流动的边是有向的，而表示对称关系的边是无向的。</st>
    <st c="12190">图 10</st><st c="12199">.4 显示了我们可以在两个节点之间获得的不同类型的边：</st>
- en: '![Figure 10.4: A schematic of the different types of edges](img/B19496_10_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：不同类型的边的示意图](img/B19496_10_4.jpg)'
- en: '<st c="12453">Figure 10.4: A schematic of the different types of edges</st>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12453">图 10.4：不同类型的边的示意图</st>
- en: <st c="12509">By comparing examples</st> *<st c="12532">a</st>* <st c="12533">and</st>
    *<st c="12538">d</st>* <st c="12539">in</st> <st c="12543">Figure 10</st><st c="12552">.4,
    we can see that two directed edges of equal weight between two nodes are not equivalent
    to an undirected edge between those two nodes.</st> <st c="12691">If we want to
    represent two flows of equal strength between the two nodes, we should use directed
    edges, while if we want to denote the presence of some symmetric logical property
    between the nodes, we should use an</st> <st c="12907">undirected edge.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12509">通过比较图 10</st> *<st c="12532">.4中的</st>* <st c="12533">示例</st>
    *<st c="12538">a</st>* <st c="12539">和</st> *<st c="12543">d</st>* <st c="12552">，我们可以看到，两个节点之间的两个相等权重的有向边并不等同于这两个节点之间的无向边。</st>
    <st c="12691">如果我们想表示两个节点之间等强度的两个流动，我们应该使用有向边，而如果我们想表示节点之间具有某种对称的逻辑属性，我们应该使用一个</st>
    <st c="12907">无向边。</st>
- en: <st c="12923">Having introduced the idea of a directed edge, we can now introduce
    the idea that a node can have a relationship with itself.</st> <st c="13050">We
    can do this by using a directed edge of the form shown i</st><st c="13109">n</st>
    <st c="13112">Figure 10</st><st c="13121">.5:</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12923">引入了有向边的概念后，我们现在可以介绍一个节点与自身之间的关系。</st> <st c="13050">我们可以通过使用图
    10</st><st c="13109">.5中所示的有向边来表示这一点。</st>
- en: '![Figure 10.5: A schematic of the directed edge between a node and itself](img/B19496_10_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5：一个节点与自身之间的有向边示意图](img/B19496_10_5.jpg)'
- en: '<st c="13126">Figure 10.5: A schematic of the directed edge between a node
    and itself</st>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13126">图 10.5：一个节点与自身之间的有向边示意图</st>
- en: <st c="13197">A directed edge between a node and itself is ideal when we want
    to represent a dynamic flow of some quantity out from the node, but some of that
    quantity may be retained by</st> <st c="13370">the node.</st> <st c="13381">For
    example, let’s say we were modeling</st> <st c="13420">flows over time of internet
    users between different pages of a website.</st> <st c="13493">From one time point
    to the next, a user may navigate to a new page within a website or remain on the
    current page.</st> <st c="13608">Here, nodes would represent pages within the
    website and directed edges would represent the flows.</st> <st c="13707">The fact
    that in a single timestep, a proportion of users don’t move pages – that is, they
    effectively flow from the page to itself – means we would represent that using
    an edge of the form in</st> <st c="13900">Figure 10</st><st c="13909">.5.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13197">一个节点与自身之间的有向边是理想的，当我们想表示某个数量从节点中流出，但其中一部分可能会被节点保留时。</st> <st c="13370">例如，假设我们在建模</st>
    <st c="13420">不同网页之间互联网用户的流动情况。</st> <st c="13493">从一个时间点到下一个时间点，用户可能会导航到网站中的新页面，或者停留在当前页面。</st>
    <st c="13608">在这里，节点代表网站中的页面，有向边代表流动。</st> <st c="13707">事实上，在单个时间步中，部分用户不更换页面——也就是说，他们实际上是从当前页面流动到自身——这意味着我们将使用图
    10</st><st c="13900">.5中的边来表示。</st>
- en: <st c="13912">Once we have the</st> <st c="13929">concept of a directed edge,
    we naturally have the concept of a</st> **<st c="13993">directed network</st>**
    <st c="14009">or</st> **<st c="14013">directed graph</st>**<st c="14027">. This
    is a graph consisting of directed</st> <st c="14067">edges.</st> <st c="14075">An
    example directed graph is shown by the schematic in</st> <st c="14130">Figure
    10</st><st c="14139">.6\.</st> <st c="14143">Likewise, a</st> <st c="14154">graph
    made up of undirected</st> <st c="14183">edges is called an</st> **<st c="14202">undirected
    graph</st>** <st c="14218">or an</st> **<st c="14225">undirected network</st>**<st
    c="14243">:</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13912">一旦我们有了</st> <st c="13929">有向边的概念，我们自然就有了</st> **<st c="13993">有向网络</st>**
    <st c="14009">或</st> **<st c="14013">有向图</st>**<st c="14027">的概念。这是一个由有向</st>
    <st c="14067">边组成的图。</st> <st c="14075">一个示例的有向图如</st> <st c="14130">图 10</st><st
    c="14139">.6所示。</st> <st c="14143">同样，由无向边组成的</st> <st c="14154">图称为</st> **<st
    c="14202">无向图</st>** <st c="14218">或</st> **<st c="14225">无向网络</st>**<st c="14243">：</st>
- en: '![Figure 10.6: A simple directed graph](img/B19496_10_6.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6：一个简单的有向图](img/B19496_10_6.jpg)'
- en: '<st c="14246">Figure 10.6: A simple directed graph</st>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14246">图 10.6：一个简单的有向图</st>
- en: <st c="14282">Now that we have introduced the different types of edges, let’s
    look at how to mathematically encode a graph and how that encoding can change
    according to the different edge types in</st> <st c="14466">the graph.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14282">现在我们已经介绍了不同类型的边，接下来让我们看看如何在数学上编码一个图，以及这种编码如何根据图中的不同边类型发生变化。</st>
- en: <st c="14476">The adjacency matrix</st>
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14476">邻接矩阵</st>
- en: <st c="14497">So far, we</st> <st c="14509">have been focusing on the visual
    representation of a graph.</st> <st c="14569">This is good, but what if we want
    to do some mathematics on a graph?</st> <st c="14638">How can we represent a graph
    mathematically?</st> <st c="14683">We introduced the notation that a graph is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3365.png)<st
    c="14726"><st c="14731">, but that is a bit abstract.</st> <st c="14761">What
    if want to work with actual numbers?</st> <st c="14803">How do we encode the presence
    of a relationship or edge mathematically?</st> <st c="14875">We do this using</st>
    <st c="14891">the idea of an</st> **<st c="14907">adjacency matrix</st>**<st c="14923">.
    For a graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3366.png)<st
    c="14938"><st c="14939">, with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)
    <st c="14946"><st c="14947">nodes, its adjacency matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/607.png)<st
    c="14977"><st c="14978">, is an</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:math>](img/651.png)
    <st c="14986"><st c="14987">matrix whose elements are defined</st> <st c="15022">as
    follows:</st></st></st></st></st></st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14497">到目前为止，我们</st> <st c="14509">一直专注于图形的可视化表示。</st> <st c="14569">这是好的，但如果我们想对图形进行一些数学处理怎么办？</st>
    <st c="14638">我们如何在数学上表示图形呢？</st> <st c="14683">我们引入了一个表示图形的符号，即</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3365.png)<st
    c="14726"><st c="14731">，但这有点抽象。</st> <st c="14761">如果我们想要处理实际的数字呢？</st> <st c="14803">我们如何在数学上编码关系或边的存在呢？</st>
    <st c="14875">我们通过使用</st> <st c="14891">邻接矩阵的概念</st> **<st c="14907">邻接矩阵</st>**<st
    c="14923">来实现这一点。对于一个图，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3366.png)<st
    c="14938"><st c="14939">，其包含</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)
    <st c="14946"><st c="14947">个节点，它的邻接矩阵</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/607.png)<st
    c="14977"><st c="14978">是一个</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:math>](img/651.png)
    <st c="14986"><st c="14987">的矩阵，其元素定义如下：</st> <st c="15022">如下所示：</st></st></st></st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>1</mn><mtext>if</mtext><mtext>an</mtext><mtext>edge</mtext><mtext>exists</mtext><mtext>between</mtext><mtext>node</mtext><mi>i</mi><mtext>and</mtext><mtext>node</mtext><mi>j</mi></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3370.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>1</mn><mtext>如果</mtext><mtext>节点</mtext><mi>i</mi><mtext>和</mtext><mtext>节点</mtext><mi>j</mi><mtext>之间</mtext><mtext>有边</mtext></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>否则</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3370.png)'
- en: <st c="15099">Eq.</st> <st c="15103">1</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15099">公式</st> <st c="15103">1</st>
- en: <st c="15104">The adjacency matrix encodes with 1s and 0s, whether two nodes
    are connected or not.</st> <st c="15189">If two nodes are connected, we say they
    are neighbors or adjacent to each other, hence the name adjacency matrix.</st>
    <st c="15303">Another way of looking at this is that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3371.png)
    <st c="15342"><st c="15343">if we can get from node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="15368"><st c="15369">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="15378"><st c="15379">in one step, and if we can they are</st> <st c="15416">nearest
    neighbors.</st></st></st></st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15104">邻接矩阵使用 1 和 0 来编码两个节点是否连接。</st> <st c="15189">如果两个节点连接，我们说它们是邻居或相邻节点，因此得名邻接矩阵。</st>
    <st c="15303">另一种看待这个问题的方式是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3371.png)
    <st c="15342"><st c="15343">如果我们可以一步从节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="15368"><st c="15369">到达节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="15378"><st c="15379">，如果可以到达，它们就是</st> <st c="15416">最近邻。</st></st></st></st>
- en: <st c="15434">Properties of the adjacency matrix</st>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="15434">邻接矩阵的性质</st>
- en: <st c="15469">Figure 10</st><st c="15479">.7 shows a</st> <st c="15489">simple
    undirected graph where we have numbered the nodes, along with their correspond</st><st
    c="15575">ing</st> <st c="15580">adjacency matrix:</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15469">图 10</st><st c="15479">.7 显示了一个</st> <st c="15489">简单的无向图，我们对节点进行了编号，并附上了相应的</st><st
    c="15575">邻接矩阵：</st>
- en: '![Figure 10.7: An example undirected graph and its corresponding adjacency
    matrix](img/B19496_10_7.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7：一个无向图及其对应的邻接矩阵示例](img/B19496_10_7.jpg)'
- en: '<st c="15748">Figure 10.7: An example undirected graph and its corresponding
    adjacency matrix</st>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15748">图 10.7：一个无向图及其对应的邻接矩阵示例</st>
- en: <st c="15827">Because the adjacency matrix encodes the connections of a graph,
    it has some very nice properties and</st> <st c="15930">allows us to do some neat
    calculations.</st> <st c="15970">We’ll look at two of those</st> <st c="15997">properties
    now:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15827">由于邻接矩阵编码了图的连接信息，它具有一些非常好的性质，并且</st> <st c="15930">允许我们进行一些精巧的计算。</st>
    <st c="15970">我们现在来看其中的两个</st> <st c="15997">性质：</st>
- en: '**<st c="16012">Symmetry</st>**<st c="16021">: For an undirected graph such
    as that in</st> <st c="16064">Figure 10</st><st c="16073">.7, the adjacency matrix
    is symmetric.</st> <st c="16112">We can easily see this from the fact that if</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3374.png)<st
    c="16157"><st c="16158">, then there is an edge between nodes</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16196"><st c="16197">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)<st
    c="16202"><st c="16203">, so node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16213"><st c="16214">is also a neighbor of node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)<st
    c="16242"><st c="16243">, which implies that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3379.png)<st
    c="16264"><st c="16265">. A similar argument shows that if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/3380.png)<st
    c="16300"><st c="16301">, then</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16308"><st c="16309">and</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>j</mi></mrow></math>](img/3382.png)<st
    c="16314"><st c="16315">are not neighbors, so</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/3383.png)<st
    c="16337"><st c="16338">. So, overall, for an undirected graph, we always have</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/3384.png)<st
    c="16393"><st c="16394">, meaning the matrix</st> <st c="16415">is symmetric.</st></st></st></st></st></st></st></st></st></st></st></st>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16012">对称性</st>**<st c="16021">：对于如图10.7所示的无向图，邻接矩阵是对称的。</st> <st
    c="16064">我们可以从以下事实轻松看出：</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3374.png)<st
    c="16157"><st c="16158">，那么节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16196"><st c="16197">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)<st
    c="16202"><st c="16203">之间有一条边，</st>因此节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16213"><st c="16214">也是节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)<st
    c="16242"><st c="16243">的邻居，这意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3379.png)<st
    c="16264"><st c="16265">。一个类似的推理表明，如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/3380.png)<st
    c="16300"><st c="16301">，那么</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="16308"><st c="16309">和</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>j</mi></mrow></math>](img/3382.png)<st
    c="16314"><st c="16315">不是邻居，因此</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/3383.png)<st
    c="16337"><st c="16338">。所以，总体而言，对于无向图，我们总是有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/3384.png)<st
    c="16393"><st c="16394">，即矩阵</st> <st c="16415">是对称的。</st>'
- en: '**<st c="16428">Next-nearest-neighbors</st>**<st c="16451">: The adjacency
    matrix allows us to identify next-nearest-neighbors and next-next-nearest-neighbors
    and so on.</st> <st c="16563">Consider the product of matrix elements,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3385.png)<st
    c="16604"><st c="16612">. This number is 1 only if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3386.png)
    <st c="16639"><st c="16640">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3387.png)<st
    c="16645"><st c="16646">, so only if there is a connection between node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="16694"><st c="16695">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3389.png)
    <st c="16705"><st c="16706">and also a connection between node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3389.png)
    <st c="16742"><st c="16743">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="16753"><st c="16754">. So,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3392.png)
    <st c="16760"><st c="16767">if we can get from node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/3393.png)
    <st c="16791"><st c="16792">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)
    <st c="16801"><st c="16802">in two steps via node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3395.png)<st
    c="16825"><st c="16826">, and 0 otherwise.</st> <st c="16845">Now, let’s consider
    all possible intermediate nodes,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/2075.png)<st
    c="16898"><st c="16899">. If we compute</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3397.png)<st
    c="16915"><st c="16924">, it will simply count a 1 every time there is a two-step
    path between node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17000"><st c="17001">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="17011"><st c="17012">. So,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3400.png)
    <st c="17018"><st c="17025">gives the number of possible two-step routes between</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17078"><st c="17079">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="17084"><st c="17085">. But wait a minute,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3400.png)
    <st c="17106"><st c="17113">looks like something we’ve seen before!</st> <st c="17153">It
    is just matrix multiplication.</st> <st c="17187">In</st> [*<st c="17190">Chapter
    3</st>*](B19496_03.xhtml#_idTextAnchor141)<st c="17199">, I mentioned that matrices
    would crop up everywhere in data science.</st> <st c="17269">Here,</st> ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msup><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><mn>2</mn></msup><mo>=</mo><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><mo>×</mo><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder></mrow></mrow></math>](img/3404.png)
    <st c="17275"><st c="17285">is a matrix whose matrix elements tell us the number
    of two-step paths between each pair of nodes in the network.</st> <st c="17399">If
    the matrix element,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mfenced
    open="(" close=")"><msup><munder><munder><mi>A</mi><mo stretchy="true">_</mo></munder><mo
    stretchy="true">_</mo></munder><mn>2</mn></msup></mfenced><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>,</mo></mrow></mrow></math>](img/3405.png)<st
    c="17422"><st c="17423">is non-zero, it means that nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17456"><st c="17457">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="17462"><st c="17463">are connected by a two-step path and so are next-nearest-neighbors.</st>
    <st c="17532">Unsurprisingly, we can continue this logic and we find that the
    matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math>](img/3408.png)<st
    c="17604"><st c="17609">, has matrix elements that count the number of three-step
    paths between each pair of nodes and can be used to easily identify next-next-nearest-neighbors.</st>
    <st c="17764">More generally, the matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3409.png)<st
    c="17792"><st c="17797">, counts the number of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3410.png)
    <st c="17820"><st c="17827">paths between each pair</st> <st c="17851">of nodes.</st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st></st>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16428">下一近邻</st>**<st c="16451">：邻接矩阵允许我们识别下一近邻、下一下近邻，依此类推。</st> <st
    c="16563">考虑矩阵元素的乘积，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3385.png)<st
    c="16604"><st c="16612">。当且仅当</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3386.png)
    <st c="16639"><st c="16640">并且</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3387.png)<st
    c="16645"><st c="16646">，只有当节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="16694"><st c="16695">与节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3389.png)
    <st c="16705"><st c="16706">之间有连接，且节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3389.png)
    <st c="16742"><st c="16743">与节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="16753"><st c="16754">之间也有连接时，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3392.png)
    <st c="16760"><st c="16767">如果我们可以从节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/3393.png)
    <st c="16791"><st c="16792">通过节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/3395.png)
    <st c="16801"><st c="16802">以两步到达节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3376.png)
    <st c="16825"><st c="16826">，否则为0。</st> <st c="16845">现在，让我们考虑所有可能的中介节点，</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>k</mml:mi></mml:math>](img/2075.png)<st
    c="16898"><st c="16899">。如果我们计算</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:munder><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>](img/3397.png)<st
    c="16915"><st c="16924">，它会在每次存在两个步骤的路径时计数1，表示节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="17000"><st c="17001">与节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="17011"><st c="17012">之间存在路径。</st> <st c="17018"><st c="17025">因此，</st> ![<mml'
- en: <st c="17860">The adjacency matrix for a directed graph</st>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="17860">有向图的邻接矩阵</st>
- en: <st c="17902">We have</st> <st c="17911">used undirected graphs to introduce
    the idea of the adjacency matrix, but can the concept be extended to directed
    graphs?</st> <st c="18033">The answer is yes.</st> <st c="18052">Again, the definition</st>
    <st c="18074">is simple:</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17902">我们已经</st> <st c="17911">使用无向图引入了邻接矩阵的概念，但这个概念是否可以扩展到有向图呢？</st>
    <st c="18033">答案是肯定的。</st> <st c="18052">同样，定义</st> <st c="18074">很简单：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>1</mn><mtext>if</mtext><mtext>a</mtext><mtext>directed</mtext><mtext>edge</mtext><mtext>exists</mtext><mtext>going</mtext><mtext>from</mtext><mtext>node</mtext><mi>i</mi><mtext>to</mtext><mtext>node</mtext><mi>j</mi></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3411.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>1</mn><mtext>如果</mtext><mtext>存在从</mtext><mi>i</mi><mtext>到</mtext><mi>j</mi><mtext>的有向边</mtext></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>否则</mtext></mrow></mtd></tr></mtable></mfenced></mrow></mrow></math>](img/3411.png)'
- en: <st c="18160">Eq.</st> <st c="18164">2</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18160">等式</st> <st c="18164">2</st>
- en: <st c="18165">Figure 10</st><st c="18174">.8 shows an example directed graph
    and its correspon</st><st c="18226">ding</st> <st c="18232">adjacency matrix:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18165">图 10</st><st c="18174">.8 展示了一个示例有向图及其对应的</st><st c="18226">邻接矩阵：</st>
- en: '![](img/B19496_10_8.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_8.jpg)'
- en: '<st c="18403">Figure 10.8: An example directed graph and its corresponding
    adjacency matrix</st>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18403">图 10.8：一个示例有向图及其对应的邻接矩阵</st>
- en: <st c="18480">From</st> <st c="18486">Figure 10</st><st c="18495">.8, we can
    see that a directed graph does not necessarily have a symmetric adjacency matrix.</st>
    <st c="18588">It will only be symmetric if, between a pair of nodes, there are
    edges in both directions or no edges</st> <st c="18690">at all.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18480">从</st> <st c="18486">图 10</st><st c="18495">.8 中，我们可以看到有向图的邻接矩阵不一定是对称的。</st>
    <st c="18588">只有在节点对之间存在双向边或根本没有边时，邻接矩阵才会是对称的。</st> <st c="18690">否则，它将不是对称的。</st>
- en: <st c="18697">We can also see that we now have the possibility of non-zero matrix
    elements on the diagonal of the adjacency matrix.</st> <st c="18816">These represent
    edges from a node to itself.</st> <st c="18861">In the example in</st> <st c="18879">Figure
    10</st><st c="18888">.8, we have included an edge from node 2 to itself and likewise
    an edge from node 4</st> <st c="18972">to itself.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18697">我们还可以看到，现在我们有可能在邻接矩阵的对角线上出现非零矩阵元素。</st> <st c="18816">这些表示从一个节点到其自身的边。</st>
    <st c="18861">在</st> <st c="18879">图 10</st><st c="18888">.8 中的示例中，我们包括了从节点 2
    到自身的边，以及从节点 4 到自身的边。</st>
- en: <st c="18982">As with the undirected case, we can use the adjacency matrix of
    a directed graph to identify next-nearest-neighbors and so on.</st> <st c="19110">The
    matrix elements of the matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3412.png)<st
    c="19145"><st c="19148">, still correspond</st> <st c="19166">to counts of the
    number of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3413.png)
    <st c="19194"><st c="19201">paths between each pair of nodes; it’s just that when
    following an</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3413.png)
    <st c="19268"><st c="19275">path, we are only allowed to move in the direction
    given by the edge.</st> <st c="19345">Consequently, as with the undirected case,
    a non-zero value in the matrix element,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3415.png)<st
    c="19428"><st c="19429">, means that there is at least one</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3416.png)
    <st c="19464"><st c="19471">path between nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="19490"><st c="19491">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="19495"><st c="19496">.</st></st></st></st></st></st></st></st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18982">与无向图情况类似，我们可以使用有向图的邻接矩阵来识别下一个最邻近的节点，依此类推。</st> <st c="19110">矩阵元素，</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3412.png)<st
    c="19145"><st c="19148">, 仍然表示每对节点之间的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-步</mml:mtext></mml:math>](img/3413.png)
    <st c="19194"><st c="19201">路径的数量；只不过在跟随一条</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-步</mml:mtext></mml:math>](img/3413.png)
    <st c="19268"><st c="19275">路径时，我们只允许沿着边的方向移动。</st> <st c="19345">因此，与无向图的情况一样，矩阵元素中的非零值，</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3415.png)<st
    c="19428"><st c="19429">, 表示在节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="19490"><st c="19491">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="19495"><st c="19496">之间至少有一条</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-步</mml:mtext></mml:math>](img/3416.png)
    <st c="19464"><st c="19471">路径。</st></st></st></st></st></st></st></st>
- en: <st c="19497">Adjacency matrices for weighted directed graphs</st>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="19497">加权有向图的邻接矩阵</st>
- en: <st c="19545">Again, it is</st> <st c="19558">natural to ask if we can take
    the edge weights into account when defining the adjacency matrix.</st> <st c="19655">Since
    the adjacency matrix captures the neighbor structure of the graph, can we not
    include the edge weight as a measure of “neighborliness?” Again, the answer is
    yes by extending the definition of the matrix elements to</st> <st c="19876">the
    following:</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19545">再次提问，</st> <st c="19558">在定义邻接矩阵时，是否可以考虑边的权重是一个自然的问题。</st> <st
    c="19655">由于邻接矩阵捕捉了图的邻居结构，那么我们是否可以将边的权重作为“邻接度”的一种度量呢？再次回答是肯定的，通过扩展矩阵元素的定义为</st>
    <st c="19876">如下：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mtext>Weight</mtext><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mtext>if</mtext><mtext>a</mtext><mtext>directed</mtext><mtext>edge</mtext><mtext>exists</mtext><mtext>going</mtext><mtext>from</mtext><mtext>node</mtext><mi>i</mi><mtext>to</mtext><mtext>node</mtext><mi>j</mi></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>otherwise</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3419.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mtext>若存在</mtext><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mtext>的有向边</mtext><mtext>从</mtext><mi>i</mi><mtext>节点指向</mtext><mi>j</mi><mtext>节点</mtext></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn><mtext>否则</mtext></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3419.png)'
- en: <st c="19968">Eq.</st> <st c="19972">3</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19968">公式</st> <st c="19972">3</st>
- en: <st c="19973">Since we only have a non-zero edge weight,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3420.png)<st
    c="20016"><st c="20017">, if there is an edge going from node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="20055"><st c="20056">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="20065"><st c="20066">, the matrix of edge weights,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/3423.png)<st
    c="20096"><st c="20097">, is the adjacency matrix in this general definition.</st>
    <st c="20151">So, in general,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder><mml:mo>=</mml:mo><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/3424.png)<st
    c="20167"><st c="20173">. This means we can also think of the absence of an edge
    as simply an edge with</st> <st c="20253">zero weight.</st></st></st></st></st></st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19973">由于我们只有非零的边权，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3420.png)<st
    c="20016"><st c="20017">，如果存在从节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/102.png)
    <st c="20055"><st c="20056">到节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="20065"><st c="20066">的边，边权矩阵</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/3423.png)<st
    c="20096"><st c="20097">就是这个通用定义中的邻接矩阵。</st> <st c="20151">所以，一般来说，</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder><mml:mo>=</mml:mo><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:math>](img/3424.png)<st
    c="20167"><st c="20173">。这意味着我们也可以将缺少的边看作是一个权重为零的边。</st></st></st></st></st></st>
- en: <st c="20265">Figure 10</st><st c="20275">.9 shows an example of a weighted
    directed graph and its correspo</st><st c="20340">nding</st> <st c="20347">adjacency
    matrix:</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20265">图 10</st><st c="20275">.9 展示了一个带权有向图及其对应的邻接矩阵示例：</st>
- en: '![](img/B19496_10_9.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_9.jpg)'
- en: '<st c="20520">Figure 10.9: An example weighted directed graph and its corresponding
    adjacency matrix</st>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20520">图 10.9：带权有向图及其对应的邻接矩阵示例</st>
- en: <st c="20606">The most</st> <st c="20616">obvious difference between</st> <st
    c="20643">Figure 10</st><st c="20652">.9 and the previous examples in</st> <st
    c="20684">Figure 10</st><st c="20693">.7 and</st> <st c="20700">Figure 10</st><st
    c="20709">.8 is that the matrix elements are no longer just 1s and 0s.</st> <st
    c="20770">This means that the matrix,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3425.png)<st
    c="20798"><st c="20803">, no longer counts the number of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3410.png)
    <st c="20836"><st c="20843">paths between nodes.</st> <st c="20864">In fact, if
    the edge weights are allowed to be negative, the interpretation of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3409.png)
    <st c="20943"><st c="20948">is not always clear.</st> <st c="20969">However, if
    the edge weights are restricted to being positive or zero, then a non-zero value
    for the matrix element,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3428.png)<st
    c="21086"><st c="21089">, still indicates that there is at least one</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3410.png)
    <st c="21134"><st c="21141">path between nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="21160"><st c="21161">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="21165"><st c="21166">.</st></st></st></st></st></st></st></st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20606">最</st> <st c="20616">明显的区别在于</st> <st c="20643">图 10</st><st c="20652">.9
    与之前的例子，</st> <st c="20684">图 10</st><st c="20693">.7 和</st> <st c="20700">图 10</st><st
    c="20709">.8 的区别是矩阵元素不再仅仅是 1 和 0。</st> <st c="20770">这意味着矩阵，</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3425.png)<st
    c="20798"><st c="20803">不再计算节点之间的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-步</mml:mtext></mml:math>](img/3410.png)
    <st c="20836"><st c="20843">路径数量。</st> <st c="20864">实际上，如果允许边的权重为负，那么</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/3409.png)
    <st c="20943"><st c="20948">的解释并不总是明确的。</st> <st c="20969">然而，如果边的权重被限制为正数或零，那么矩阵元素</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:munder underaccent="false"><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3428.png)<st
    c="21086"><st c="21089">仍然表示节点之间至少存在一条</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-步</mml:mtext></mml:math>](img/3410.png)
    <st c="21134"><st c="21141">路径</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="21160"><st c="21161">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="21165"><st c="21166">。</st></st></st></st></st></st></st></st>
- en: <st c="21167">The different forms of the adjacency matrix that we have illustrated
    here show how useful it is since it encodes almost everything about a graph.</st>
    <st c="21314">Consequently, almost all calculations involving graphs make use
    of the adjacency matrix.</st> <st c="21403">We’ll look at more characteristics
    of graphs and in some cases show how those characteristics can be calculated from
    the</st> <st c="21524">adjacency matrix.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21167">我们在这里展示的邻接矩阵的不同形式显示了它的有用性，因为它几乎包含了图形的所有信息。</st> <st c="21314">因此，几乎所有涉及图形的计算都依赖于邻接矩阵。</st>
    <st c="21403">我们将进一步探讨图形的更多特性，并在某些情况下展示如何从</st> <st c="21524">邻接矩阵中计算出这些特性。</st>
- en: <st c="21541">In-degree and out-degree</st>
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21541">入度和出度</st>
- en: <st c="21566">We can</st> <st c="21574">also see from</st> <st c="21588">Figure
    10</st><st c="21597">.8 that taking edge direction into account when defining
    the</st> <st c="21658">adjacency matrix can change the matrix markedly.</st> <st
    c="21707">Other than the addition of an edge from node 2 to itself and likewise
    for node 4, the topology of the graph in</st> <st c="21818">Figure 10</st><st
    c="21827">.8 is the same as that for the undirected graph in</st> <st c="21878">Figure
    10</st><st c="21887">.7\.</st> <st c="21891">However, some nodes in</st> <st c="21914">Figure
    10</st><st c="21923">.8 have few edges.</st> <st c="21942">Take node 6, for example.</st>
    <st c="21968">The directed graph in</st> <st c="21990">Figure 10</st><st c="21999">.8
    only has one edge, while the undirected graph in</st> <st c="22051">Figure 10</st><st
    c="22060">.7, which has the same topology, shows that node 6 has three edges.</st>
    <st c="22128">This naturally introduces the idea that we should distinguish between
    counts of edges that are incoming to a node and counts of edges that are outgoing
    from</st> <st c="22285">a node.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21566">我们还可以从</st> <st c="21588">图10.8中看出，定义邻接矩阵时考虑边的方向会显著改变矩阵。</st>
    <st c="21707">除了从节点2到自身的边和节点4的同样情况外，</st> <st c="21818">图10.8中的图的拓扑结构与图10.7中的无向图相同。</st>
    <st c="21827">然而，图10.8中的一些节点有较少的边。</st> <st c="21942">以节点6为例。</st> <st c="21968">图10.8中的有向图只有一条边，而在具有相同拓扑的图10.7中的无向图中，节点6有三条边。</st>
    <st c="22128">这自然引出了一个概念，即我们应区分进入节点的边和从节点出去的边的数量。</st> <st c="22285">节点的出度。</st>
- en: <st c="22292">The number</st> <st c="22303">of edges coming into a node is known
    as the node’s</st> **<st c="22355">in-degree</st>**<st c="22364">, while the number
    of edges leaving a node is known as the node’s</st> **<st c="22430">out-degree</st>**<st
    c="22440">. How</st> <st c="22446">do we calculate the in-degree and out-degree?</st>
    <st c="22492">Using the adjacency matrix, of course.</st> <st c="22531">If we
    have an adjacency matrix of the form shown in</st> <st c="22583">Figure 10</st><st
    c="22592">.8, consisting of just 1s and 0s, then the in-degree for the</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="22653"><st c="22665">node is just the sum of the matrix elements in the</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="22716"><st c="22728">column of the adjacency matrix.</st> <st c="22760">In
    math form, this looks</st> <st c="22785">as follows:</st></st></st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22292">进入一个节点的边的数量被称为该节点的</st> **<st c="22355">入度</st>**<st c="22364">，而离开节点的边的数量被称为该节点的</st>
    **<st c="22430">出度</st>**<st c="22440">。我们如何计算入度和出度呢？</st> <st c="22446">当然是使用邻接矩阵。</st>
    <st c="22492">如果我们有一个如</st> <st c="22583">图10.8</st><st c="22592">所示的邻接矩阵，矩阵中只有1和0，那么该节点的入度就是邻接矩阵中</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="22653"><st c="22665">列的矩阵元素之和。</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="22716"><st c="22728">的列。</st> <st c="22760">数学表达式如下：</st> <st c="22785">如以下所示：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>In-degree</mtext><mtext>for</mtext><mtext>node</mtext><mi>i</mi><mo>=</mo><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mrow></mrow></math>](img/3434.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>节点</mtext><mtext>的入度</mtext><mtext>=</mtext><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mrow></mrow></math>](img/3434.png)'
- en: <st c="22826">Eq.</st> <st c="22830">4</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22826">方程</st> <st c="22830">4</st>
- en: <st c="22831">This also means that if we put all the in-degree values for all
    the nodes,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:math>](img/3435.png)<st
    c="22906"><st c="22907">, into a vector, we can calculate that vector using matrix
    multiplic</st><st c="22975">ation like</st> <st c="22987">like so:</st></st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22831">这也意味着，如果我们将所有节点的入度值</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:math>](img/3435.png)<st
    c="22906"><st c="22907">，汇总成一个向量，我们可以通过矩阵乘法计算该向量，像这样：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>In-degree</mtext><mtext>vector</mtext><mtext>=</mtext><msup><msub><munder><mn>1</mn><mo
    stretchy="true">_</mo></munder><mi>N</mi></msub><mi mathvariant="normal">⊤</mi></msup><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder></mrow></mrow></math>](img/3436.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>入度</mtext><mtext>向量</mtext><mtext>=</mtext><msup><msub><munder><mn>1</mn><mo
    stretchy="true">_</mo></munder><mi>N</mi></msub><mi mathvariant="normal">⊤</mi></msup><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder></mrow></mrow></math>](img/3436.png)'
- en: <st c="23017">Eq.</st> <st c="23021">5</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23017">方程</st> <st c="23021">5</st>
- en: <st c="23022">In Eq.</st> <st c="23029">5,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:msub><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/3437.png)<st
    c="23032"><st c="23033">means an</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)<st
    c="23042"><st c="23043">-element</st> <st c="23052">row-vector consisting of all
    1s.</st> <st c="23085">A similar bit of logic shows that</st> <st c="23118">the
    out-degree of node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="23142"><st c="23143">is just the sum of all the matrix elements in the</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="23194"><st c="23206">row of the adjacency matrix.</st> <st c="23235">In
    math terms, we have</st> <st c="23258">the following:</st></st></st></st></st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23022">在方程</st> <st c="23029">5</st>，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:msub><mml:mrow><mml:munder
    underaccent="false"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mo>_</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/3437.png)<st
    c="23032"><st c="23033">表示一个由所有1构成的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)<st
    c="23042"><st c="23043">元素的行向量。</st> <st c="23085">类似的逻辑显示，</st> <st c="23118">节点</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="23142"><st c="23143">的出度只是邻接矩阵中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:math>](img/909.png)
    <st c="23194"><st c="23206">行中所有矩阵元素的总和。</st> <st c="23235">用数学术语表示，我们有：</st>
    <st c="23258">如下：</st></st></st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Out-degree</mtext><mtext>for</mtext><mtext>node</mtext><mi>i</mi><mo>=</mo><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></mrow></math>](img/3441.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>节点</mtext><mtext>i</mtext><mtext>的出度</mtext><mo>=</mo><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></mrow></math>](img/3441.png)'
- en: <st c="23303">Eq.</st> <st c="23307">6</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23303">公式</st> <st c="23307">6</st>
- en: <st c="23308">So, the vector of out-degree values can calculated as a matrix
    multiplication via the</st> <st c="23394">following equation:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23308">因此，出度值的向量可以通过矩阵乘法计算，使用以下公式：</st> <st c="23394">如下方程：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Out-degree</mtext><mtext>vector</mtext><mtext>=</mtext><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><msub><munder><mn>1</mn><mo
    stretchy="true">_</mo></munder><mi>N</mi></msub></mrow></mrow></math>](img/3442.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>出度</mtext><mtext>向量</mtext><mtext>=</mtext><munder><munder><mi>A</mi><mo
    stretchy="true">_</mo></munder><mo stretchy="true">_</mo></munder><msub><munder><mn>1</mn><mo
    stretchy="true">_</mo></munder><mi>N</mi></msub></mrow></mrow></math>](img/3442.png)'
- en: <st c="23437">Eq.</st> <st c="23441">7</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23437">公式</st> <st c="23441">7</st>
- en: <st c="23442">Centrality</st>
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23442">中心性</st>
- en: <st c="23452">The in-degree and</st> <st c="23471">out-degree are node-level
    characteristics.</st> <st c="23514">Adding the in-degree and out-degree values
    together gives us the total number of edges connected to a node – its total degree.</st>
    <st c="23641">A node with a high total number of edges is connected to a lot of
    other nodes and so is likely to be at the heart of the network.</st> <st c="23771">This
    means that the total degree value of a node gives a measure of how important or
    how central it is</st> <st c="23873">to the network.</st> <st c="23890">We say
    that the total degree value is a</st> **<st c="23930">centrality measure</st>**<st
    c="23948">.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23452">入度和</st> <st c="23471">出度是节点级别的特征。</st> <st c="23514">将入度和出度的值相加，我们得到连接到节点的总边数——即其总度数。</st>
    <st c="23641">具有高总度数的节点连接着大量的其他节点，因此可能处于网络的核心。</st> <st c="23771">这意味着，节点的总度数值反映了它在网络中的重要性或中心性。</st>
    <st c="23873">我们称总度数值为</st> **<st c="23930">中心性度量</st>**<st c="23948">。</st>
- en: <st c="23949">As you can imagine, there are many ways in which you can judge
    the importance of a node, so there are many node centrality measures.</st> <st
    c="24083">The centrality measure based on the number of edges connected to a</st>
    <st c="24149">node is called</st> **<st c="24165">degree centrality</st>**<st
    c="24182">. The following are some other node centrality measures</st> <st c="24238">to
    consider:</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23949">如你所想，评估节点重要性有很多方法，因此有许多节点中心性度量。</st> <st c="24083">基于连接到节点的边数的中心性度量被称为</st>
    **<st c="24165">度数中心性</st>**<st c="24182">。以下是一些其他值得考虑的节点中心性度量：</st>
- en: '**<st c="24250">Betweenness centrality</st>**<st c="24273">: This</st> <st
    c="24281">attempts to measure to what extent a node lies between key parts of
    the network, and so acts as a node through which paths must pass when going between
    any other two nodes in</st> <st c="24456">the network.</st>'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24250">中介中心性</st>**<st c="24273">：这一度量试图衡量节点位于网络关键部分之间的程度，因此它是一个路径必须经过的节点，连接网络中任意两个其他节点。</st>
    <st c="24456">网络中的节点。</st>'
- en: '**<st c="24468">Closeness centrality</st>**<st c="24489">: As the</st> <st
    c="24499">name suggests, this measures how close the node is to all the other
    nodes, based on path distances along the edges of the network.</st> <st c="24630">A
    node that has a short average distance from other nodes is at the heart of</st>
    <st c="24707">the network.</st>'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24468">接近中心性</st>**<st c="24489">：顾名思义，这度量了节点与所有其他节点的接近程度，基于网络边缘上的路径距离。</st>
    <st c="24630">一个与其他节点的平均距离较短的节点位于网络的核心。</st>'
- en: '**<st c="24719">Eigenvector centrality</st>**<st c="24742">: A measure</st>
    <st c="24754">of node importance based on the likelihood of ending up at a node
    while performing a long random walk on the network.</st> <st c="24873">This measures
    how popular the node is, as voted for by the</st> <st c="24932">other nodes.</st>'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24719">特征向量中心性</st>**<st c="24742">：基于在网络中进行长时间随机游走时最终到达某个节点的可能性来衡量节点的重要性。</st>
    <st c="24873">这度量了节点的流行程度，由</st> <st c="24932">其他节点投票决定。</st>'
- en: <st c="24944">Different</st> <st c="24955">node centrality measures capture
    different aspects of node importance.</st> <st c="25026">A node can be very important
    by one centrality measure, and not so important by another measure.</st> <st c="25123">We
    need to be aware of the nuances of different centrality measures when we</st>
    <st c="25199">use them.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24944">不同的</st> <st c="24955">节点中心性度量捕捉到节点重要性的不同方面。</st> <st c="25026">一个节点在某个中心性度量下可能非常重要，而在另一个度量下则可能不那么重要。</st>
    <st c="25123">在使用这些度量时，我们需要了解不同中心性度量的细微差别。</st>
- en: <st c="25208">But why do we care about node centrality measures?</st> <st c="25260">Why
    do we care about knowing whether a node is important or not?</st> <st c="25325">In
    a real-world setting, an important node is typically an influential node, and
    therefore one we want to identify by ranking on a particular node centrality measure.</st>
    <st c="25492">More interestingly, graphs with certain types of highly influential
    nodes can have some surprising behaviors.</st> <st c="25602">We’ll learn about
    these graphs and their behaviors in the next section, but for now, we’ll summarize
    what we have learned in this section about the basic characteristics</st> <st
    c="25772">of graphs.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25208">但我们为什么关心节点中心性度量呢？</st> <st c="25260">为什么我们需要知道一个节点是否重要？</st> <st
    c="25325">在现实世界中，一个重要的节点通常是一个有影响力的节点，因此我们希望通过在某个特定节点中心性度量上进行排序来识别它。</st> <st c="25492">更有趣的是，具有某些类型的高度影响力节点的图可能会表现出一些惊人的行为。</st>
    <st c="25602">我们将在下一节学习这些图及其行为，但目前，我们将总结这一节中关于图的基本特征的内容。</st> <st c="25772">图的基本特征</st>
- en: <st c="25782">What we’ve learned</st>
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="25782">我们所学到的</st>
- en: <st c="25801">In this section, we learned</st> <st c="25830">the following:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25801">在这一节中，我们学到了</st> <st c="25830">以下内容：</st>
- en: <st c="25844">How edges in a graph can be undirected or directed, meaning a
    graph can be an undirected graph or a</st> <st c="25945">directed graph</st>
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25844">图中的边缘可以是无向的或有向的，这意味着图可以是无向图或一个</st> <st c="25945">有向图</st>
- en: <st c="25959">How we can have a directed edge from a node</st> <st c="26004">to
    itself</st>
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25959">我们如何能让一个节点有一个指向</st> <st c="26004">它自己的有向边</st>
- en: <st c="26013">How edges can have a weight associated</st> <st c="26053">with
    them</st>
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26013">如何为边缘分配权重</st> <st c="26053">与它们相关</st>
- en: <st c="26062">Adjacency matrices and how they mathematically encode the</st>
    <st c="26121">network structure</st>
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26062">邻接矩阵及其如何在数学上编码</st> <st c="26121">网络结构</st>
- en: <st c="26138">How an adjacency matrix can be used to identify and count</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-step</mml:mtext></mml:math>](img/3443.png)
    <st c="26197"><st c="26204">paths between each pair of nodes in</st> <st c="26240">a
    network</st></st>
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26138">如何使用邻接矩阵来识别并计算</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi><mml:mtext>-步</mml:mtext></mml:math>](img/3443.png)
    <st c="26197"><st c="26204">节点对之间的路径</st> <st c="26240">在网络中的存在</st></st>
- en: <st c="26249">The in-degree and out-degree values of a node and how they can
    be calculated from the</st> <st c="26336">adjacency matrix</st>
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26249">节点的入度和出度值，以及它们如何从</st> <st c="26336">邻接矩阵中计算</st>
- en: <st c="26352">How the total degree value of a node (the sum of the node’s in-degree
    and out-degree) is a centrality measure that measures the importance of</st> <st
    c="26495">a node</st>
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26352">节点的总度数值（节点的入度和出度之和）是一个中心性度量，衡量</st> <st c="26495">节点的重要性</st>
- en: <st c="26501">How there are many other different node</st> <st c="26542">centrality
    measures</st>
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26501">如何有许多其他不同的节点</st> <st c="26542">中心性度量</st>
- en: <st c="26561">Having learned the basic concepts and terminology that describe
    a graph, next, we’ll look at different types or families of graphs and focus on
    some of their specific but very</st> <st c="26738">interesting properties.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26561">在学习了描述图的基本概念和术语之后，接下来，我们将看看不同类型或类别的图，并专注于它们的一些特定但非常</st> <st c="26738">有趣的特性。</st>
- en: <st c="26761">Different types of graphs</st>
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="26761">不同类型的图</st>
- en: <st c="26787">There are many different</st> <st c="26813">graphs you may encounter
    as a data scientist.</st> <st c="26859">Many of these graphs can be grouped into
    different classes.</st> <st c="26919">In this section, we will outline some of
    the most important classes of graphs you will encounter.</st> <st c="27017">The
    list of classes we’ll cover here is not intended to be exhaustive.</st> <st c="27088">It
    will introduce you to the concepts and terminology associated with the most common
    classes of graphs you</st> <st c="27196">will encounter.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26787">作为数据科学家，你可能会遇到许多不同类型的</st> <st c="26813">图。</st> <st c="26859">这些图中的许多可以归类为不同的类别。</st>
    <st c="26919">在本节中，我们将概述你会遇到的一些最重要的图的类别。</st> <st c="27017">我们在这里提到的类别列表并不打算是详尽无遗的。</st>
    <st c="27088">它将向你介绍与你最常遇到的图类别相关的概念和术语。</st> <st c="27196">你将会遇到的图类别。</st>
- en: <st c="27211">Fully connected graphs</st>
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27211">完全连接的图</st>
- en: <st c="27234">One of</st> <st c="27241">the differences between our two real-world
    examples is that in our trade network example, each node (country) is connected
    to</st> <st c="27368">every other node.</st> <st c="27386">We say that the trade
    network is</st> **<st c="27419">fully connected</st>**<st c="27434">. In contrast,
    in our pizza network, every pizza is not connected to every</st> <st c="27509">other
    pizza.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27234">我们两个现实世界示例之间的区别之一是，在我们的贸易网络示例中，每个节点（国家）都与</st> <st c="27368">其他所有节点相连。</st>
    <st c="27386">我们称这个贸易网络为</st> **<st c="27419">完全连接</st>**<st c="27434">。相比之下，在我们的比萨网络中，并不是每个比萨都与其他比萨相连。</st>
- en: <st c="27521">The left-hand graph in</st> <st c="27545">Figure 10</st><st c="27554">.10
    shows a graph with four nodes.</st> <st c="27589">Each of the nodes is connected
    to every one of the other three nodes.</st> <st c="27659">It is fully connected.</st>
    <st c="27682">In contrast, the graph on the right-hand side of</st> <st c="27731">Figure
    10</st><st c="27740">.10 also contains the same</st> <st c="27766">four nodes
    but is not</st> <st c="27789">fully connected:</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27521">图10</st><st c="27545">.10左边的图显示了一个有四个节点的图。</st> <st c="27554">每个节点都与其他三个节点相连。</st>
    <st c="27589">这是一个完全连接的图。</st> <st c="27659">相比之下，图10</st><st c="27731">.10右边的图也包含了相同的四个节点，但并没有</st>
    <st c="27766">完全连接：</st>
- en: '![](img/B19496_10_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_10.jpg)'
- en: '<st c="27842">Figure 10.10: A graph that is fully connected and one that is
    not</st>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27842">图10.10：一个完全连接的图和一个不完全连接的图</st>
- en: <st c="27907">Disconnected graphs</st>
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27907">不连通的图</st>
- en: <st c="27927">Our</st> <st c="27931">real-world pizza example graph is not fully
    connected.</st> <st c="27987">Some</st> <st c="27992">edges that could be possible
    are absent.</st> <st c="28033">What would happen if we removed even more edges
    from our pizza network?</st> <st c="28105">Removing edges from a network will
    eventually cause it to break into separate distinct and un-connected gra</st><st
    c="28212">phs.</st> <st c="28218">Figure 10</st><st c="28227">.11 shows such</st>
    <st c="28242">an example:</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27927">我们的</st> <st c="27931">现实世界的比萨示例图并未完全连接。</st> <st c="27987">有些</st>
    <st c="27992">可能存在的边缺失了。</st> <st c="28033">如果我们从比萨网络中移除更多的边，会发生什么呢？</st> <st
    c="28105">从网络中移除边最终会导致它分裂成多个独立且不相连的图</st><st c="28212">。</st> <st c="28218">图10</st><st
    c="28227">.11展示了一个这样的示例：</st>
- en: '![](img/B19496_10_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_11.jpg)'
- en: '<st c="28278">Figure 10.11: Disconnected components in a graph</st>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28278">图10.11：图中的不连通组件</st>
- en: <st c="28326">We</st> <st c="28330">refer to</st> <st c="28339">the separate
    disconnected parts of the graph as</st> **<st c="28387">components</st>**<st c="28397">.
    In</st> <st c="28402">Figure 10</st><st c="28411">.11, there are two components.</st>
    <st c="28442">One can have graphs that have many disconnected components.</st>
    <st c="28502">Each component is a graph in its own right, and any analysis we
    apply to a graph can be applied to each separate component of a graph.</st> <st
    c="28637">Consequently, from now on, we shall only discuss how to analyze</st>
    <st c="28701">single-component graphs.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28326">我们</st> <st c="28330">将图中分离的不连通部分称为</st> **<st c="28387">组件</st>**<st
    c="28397">。在</st> <st c="28402">图10</st><st c="28411">.11中，有两个组件。</st> <st c="28442">一个图可以有多个不连通的组件。</st>
    <st c="28502">每个组件都是一个独立的图，任何我们对一个图的分析都可以应用到图的每个独立组件。</st> <st c="28637">因此，从现在开始，我们将仅讨论如何分析</st>
    <st c="28701">单一组件图。</st>
- en: <st c="28725">Directed acyclic graphs</st>
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="28725">有向无环图</st>
- en: <st c="28749">Directed graphs</st> <st c="28766">are great for representing
    flows.</st> <st c="28800">They</st> <st c="28804">are also great for representing
    how one quantity (node) depends on another, or how one quantity (node) influences
    another.</st> <st c="28928">The presence of a directed edge from node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="28970"><st c="28971">to node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="28980"><st c="28981">in a directed graph could be used to indicate that
    the quantity represented by node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="29066"><st c="29067">influences the quantity represented by node</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="29112"><st c="29113">. Or equivalently, node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="29137"><st c="29138">has a dependency on node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)<st
    c="29164"><st c="29165">. Directed graphs are often used to represent patterns
    of dependencies.</st> <st c="29237">An important requirement of any such dependency
    graph is that there are no</st> **<st c="29312">cycles</st>**<st c="29318">. A
    cycle is</st> <st c="29331">a set of steps (hops) that take us from a node back
    to itself.</st> <st c="29394">A cycle would mean we have a chain of dependencies
    from a node back to itself – the quantity would have a dependency on itself, something
    that cannot</st> <st c="29544">be resolved.</st></st></st></st></st></st></st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28749">有向图</st> <st c="28766">非常适合表示流动。</st> <st c="28800">它们</st> <st
    c="28804">也非常适合表示一个量（节点）如何依赖于另一个量，或者一个量（节点）如何影响另一个量。</st> <st c="28928">从节点</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="28970"><st c="28971">到节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="28980"><st c="28981">的有向边可以用来表示节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="29066"><st c="29067">表示的量影响了节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)<st
    c="29112"><st c="29113">表示的量。或者等价地，节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="29137"><st c="29138">依赖于节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)<st
    c="29164"><st c="29165">。有向图通常用于表示依赖关系的模式。</st> <st c="29237">任何这种依赖图的重要要求是不能有</st>
    **<st c="29312">环</st>**<st c="29318">。环是</st> <st c="29331">一组步骤（跳跃），将我们从一个节点带回到自身。</st>
    <st c="29394">一个环意味着我们有一个从节点到自身的依赖链——这个量将依赖于它自身，这是无法</st> <st c="29544">解决的。</st>
- en: <st c="29556">The graph on the left-hand side of</st> <st c="29592">Figure 10</st><st
    c="29601">.12 shows a directed graph with a cycle.</st> <st c="29642">The high</st><st
    c="29650">lighted cycle is a path between</st> <st c="29683">three nodes:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29556">图 10</st><st c="29592">.12 左侧的图显示了一个有环的有向图。</st> <st c="29601">高亮部分的环是一个包含三个节点的路径：</st>
- en: '![](img/B19496_10_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_12.jpg)'
- en: '<st c="29754">Figure 10.12: Directed graphs with and without cycles</st>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29754">图 10.12：有环和无环的有向图</st>
- en: <st c="29807">There are</st> <st c="29818">many cycles in the left-hand graph
    in</st> <st c="29856">Figure 10</st><st c="29865">.12 – there are several pairs
    of nodes with directed edges in both directions between them.</st> <st c="29957">Also,
    any edge from a node to itself automatically represents</st> <st c="30019">a cycle.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29807">在</st> <st c="29818">图 10</st><st c="29856">.12 的左侧图中有许多环——有几个节点对之间存在双向的有向边。</st>
    <st c="29957">此外，任何从节点到自身的边都自动表示</st> <st c="30019">一个环。</st>
- en: <st c="30027">For dependency</st> <st c="30043">graphs, we want graphs that
    do not have any cycles.</st> <st c="30095">Since such graphs have no cycles or
    are</st> **<st c="30135">acyclic</st>**<st c="30142">, they are referred to as</st>
    **<st c="30168">directed acyclic graphs</st>** <st c="30191">(</st>**<st c="30193">DAGs</st>**<st
    c="30197">).</st> <st c="30201">The right-hand graph of</st> <st c="30225">Figure
    10</st><st c="30234">.12 shows an example of</st> <st c="30258">a DAG.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30027">对于依赖图</st> <st c="30043">，我们希望图中没有任何循环。</st> <st c="30095">由于这些图没有循环或是**<st
    c="30135">无环的</st>**<st c="30142">，它们被称为</st> **<st c="30168">有向无环图</st>** <st
    c="30191">(</st>**<st c="30193">DAGs</st>**<st c="30197">)。</st> <st c="30201">图10.12中的右侧图示例展示了一个DAG。</st>
- en: <st c="30264">Small-world networks</st>
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="30264">小世界网络</st>
- en: <st c="30285">You may</st> <st c="30294">have already heard of small-world networks
    as many real-world networks are said to be small-world networks.</st> <st c="30402">Small-world
    networks</st> <st c="30423">are not so much a class of networks but are networks
    that display the small-world effect or small-world phenomenon.</st> <st c="30539">The
    small-world phenomenon is also known colloquially as the “six degrees of separation”
    effect.</st> <st c="30636">It refers to the observation that in many networks,
    the shortest path between any two nodes is not very long – typically only six
    steps or “hops,” meaning that we can get from any node on the network to any other
    node on the network in typically six hops or less.</st> <st c="30900">In a real-world
    setting, you may have heard of the example that any Hollywood actor can be connected
    to actor Kevin Bacon via a chain of six movies or less.</st> <st c="31057">This
    is the “six degrees of Kevin</st> <st c="31091">Bacon” phenomenon.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30285">你可能已经听说过小世界网络，因为许多现实世界中的网络被认为是小世界网络。</st> <st c="30294">小世界网络不算是一类特定的网络，而是表现出小世界效应或小世界现象的网络。</st>
    <st c="30402">小世界现象</st> <st c="30423">也被口语化称为“六度分隔”效应。</st> <st c="30539">它指的是这样一种观察结果：在许多网络中，任意两个节点之间的最短路径并不很长——通常只有六步或“跳跃”，这意味着我们可以从网络上的任何一个节点出发，经过最多六步或更少到达另一个节点。</st>
    <st c="30636">在现实生活中，你可能听说过这样一个例子：任何一位好莱坞演员都可以通过六部电影或更少与演员凯文·贝肯相连。</st> <st c="30900">这就是“凯文·贝肯的六度分隔”现象。</st>
- en: <st c="31109">The small-world phenomenon is widespread in real-world networks.</st>
    <st c="31175">Theoretical models of how networks evolve and grow suggest that
    the small-world phenomenon should be expected in most networks.</st> <st c="31303">The
    phrase “small-world network” itself stems from the real-world phenomenon</st>
    <st c="31380">we often experience in social-network settings, where we meet someone
    new from another part of the world and it turns out they already know one of our
    best friends or one of the friends of our friends.</st> <st c="31582">This strikes
    us as an unlikely occurrence and we exclaim, “What a</st> <st c="31648">small
    world!”</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31109">小世界现象在现实世界的网络中广泛存在。</st> <st c="31175">关于网络如何演化和增长的理论模型表明，在大多数网络中应该能够预见到小世界现象。</st>
    <st c="31303">“小世界网络”这一术语本身源于我们在社交网络中常常经历的现实现象，</st> <st c="31380">我们认识一个来自世界另一端的人，结果发现他们已经认识我们最好的朋友或我们朋友的朋友。</st>
    <st c="31582">这让我们觉得是个不太可能的巧合，我们不禁感叹：“真是个</st> <st c="31648">小世界！”</st>
- en: <st c="31661">At the</st> <st c="31669">heart of the small-world phenomenon
    is the presence of nodes in the network that have a high total degree.</st> <st
    c="31776">As we said when introducing centrality measures, total degree is one
    way of identifying the important nodes.</st> <st c="31885">A node with a high
    total degree is connected to a lot of other nodes.</st> <st c="31955">If you want
    to find a short path between two nodes, going via a node that is connected to
    almost every other node in the network would seem like a smart idea.</st> <st
    c="32114">High-degree nodes allow us to efficie</st><st c="32151">ntly move between
    different parts of</st> <st c="32189">the network:</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31661">在小世界现象的核心是网络中存在着具有高总度的节点。</st> <st c="31669">正如我们在介绍中心性度量时所说，总度是识别重要节点的一种方式。</st>
    <st c="31776">一个具有高总度的节点与许多其他节点相连。</st> <st c="31885">如果你想找到两个节点之间的短路径，通过一个与几乎所有其他节点相连的节点似乎是个聪明的选择。</st>
    <st c="31955">高度节点使我们能够高效地在网络的不同部分之间移动：</st>
- en: '![](img/B19496_10_13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_13.jpg)'
- en: '<st c="32203">Figure 10.13: A high-degree node that connects all parts of the
    network</st>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32203">图 10.13：一个连接网络各部分的高阶节点</st>
- en: <st c="32274">Figure 10</st><st c="32284">.13 shows an example of a high-degree
    node, colored in red, that acts as a connection between any other two nodes.</st>
    <st c="32399">By passing through the red node, we can go from one side of the
    network to the other in three steps</st> <st c="32499">or less.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32274">图 10.13 显示了一个高阶节点的例子，该节点用红色表示，作为连接任意两个其他节点的桥梁。</st> <st c="32399">通过经过这个红色节点，我们可以在三步之内</st>
    <st c="32499">或者更少的步骤中，从网络的一侧到达另一侧。</st>
- en: <st c="32507">Let’s put a bit of math detail on the small-world phenomenon.</st>
    <st c="32570">The presence of high-degree nodes means the typical shortest-path
    distance between any two nodes is always small, no matter how big the network
    gets.</st> <st c="32720">If we denote the shortest-path distance between node</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="32773"><st c="32774">and node</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="32784"><st c="32785">as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3452.png)<st
    c="32789"><st c="32790">, then the mean shortest-path distance i</st><st c="32830">s
    given by the</st> <st c="32846">following equation:</st></st></st></st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32507">让我们为小世界现象加入一些数学细节。</st> <st c="32570">高阶节点的存在意味着，不管网络有多大，任意两个节点之间的典型最短路径距离总是很小。</st>
    <st c="32720">如果我们用最短路径距离表示节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/106.png)
    <st c="32773"><st c="32774">和节点</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>j</mml:mi></mml:math>](img/3373.png)
    <st c="32784"><st c="32785">之间的距离记为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/3452.png)<st
    c="32789"><st c="32790">，则平均最短路径距离i</st><st c="32830">由以下方程给出：</st> <st c="32846">下式：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mover><mi>D</mi><mo
    stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mn>1</mn><msup><mi>N</mi><mn>2</mn></msup></mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></mrow></mrow></math>](img/3453.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mover><mi>D</mi><mo
    stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mn>1</mn><msup><mi>N</mi><mn>2</mn></msup></mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></mrow></mrow></math>](img/3453.png)'
- en: <st c="32877">Eq.</st> <st c="32881">8</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32877">公式</st> <st c="32881">8</st>
- en: <st c="32882">In Eq.</st> <st c="32889">8,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/686.png)
    <st c="32892"><st c="32893">is the number of nodes in the network.</st> <st c="32933">A
    mathematical statement of the small-world phenomenon is that</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3455.png)
    <st c="32996"><st c="32997">grows very slowly as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/629.png)
    <st c="33019"><st c="33020">is increased.</st> <st c="33035">Theoretical analysis
    of</st> <st c="33059">small-world networks shows that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)
    <st c="33091"><st c="33092">typically grows as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3458.png)<st
    c="33112"><st c="33113">. This means that if we double the size of a small-world
    network by doubling</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/443.png)<st
    c="33190"><st c="33191">, we only increase the typical shortest-path distance
    between nodes by an amount,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:math>](img/3460.png)
    <st c="33273"><st c="33278">– that is, a small increase.</st> <st c="33307">A</st>
    <st c="33309">consequence of this is that typical distances between nodes on even
    very large real-world networks, such as the World Wide Web or popular social networks,
    are not large (between</st> <st c="33487">10-20 hops).</st></st></st></st></st></st></st></st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在公式<st c="32882">8</st>中，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/686.png)
    <st c="32892"><st c="32893">是网络中的节点数量。</st> <st c="32933">小世界现象的数学表达式是</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3455.png)
    <st c="32996"><st c="32997">随</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/629.png)
    <st c="33019"><st c="33020">的增加而非常缓慢地增长。</st> <st c="33035">小世界网络的理论分析表明，</st>
    <st c="33059">通常</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)
    <st c="33091"><st c="33092">的增长大致为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3458.png)<st
    c="33112"><st c="33113">。这意味着，如果我们通过将</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/443.png)<st
    c="33190"><st c="33191">的大小加倍来使小世界网络的规模加倍，那么我们仅仅会将节点之间的典型最短路径距离增加一个量，</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:math>](img/3460.png)
    <st c="33273"><st c="33278">– 也就是说，增加非常少。</st> <st c="33307">这意味着，即使是在非常大的现实世界网络中，如万维网或流行社交网络，节点之间的典型距离也并不大（大约在</st>
    <st c="33487">10-20跳</st>）。
- en: <st c="33499">Another common</st> <st c="33514">feature of small-world networks
    is that some of the highly connected nodes also exhibit</st> **<st c="33603">long-range</st>**
    <st c="33613">connections.</st> <st c="33627">This means they are not just connected
    to lots of nodes in the same part of the network, but they are connected to lots
    of different parts of the network.</st> <st c="33782">In</st> <st c="33785">Figure
    10</st><st c="33794">.13, the red node is connected to nodes on the very right-hand
    side of the network via those curved edges.</st> <st c="33901">The red node is
    connected to almost every other node in the network.</st> <st c="33970">In social
    network settings, such nodes are the people who seem to know everyone.</st> <st
    c="34051">In our Hollywood actor example, Kevin Bacon is a node who is connected
    to many other</st> <st c="34136">Hollywood actors.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33499">小世界网络的另一个常见特征是，某些高度连接的节点也展示了</st> **<st c="33603">长程</st>** <st
    c="33613">连接。</st> <st c="33627">这意味着它们不仅仅连接到网络中同一部分的许多节点，而是连接到网络中不同部分的许多节点。</st>
    <st c="33782">在</st> <st c="33785">图 10.13</st><st c="33794">中，红色节点通过那些弯曲的边连接到网络最右侧的节点。</st>
    <st c="33901">红色节点几乎与网络中的每一个其他节点都有连接。</st> <st c="33970">在社交网络环境中，这些节点就是那些似乎认识所有人的人。</st>
    <st c="34051">在我们的好莱坞演员示例中，凯文·贝肯是一个与许多其他</st> <st c="34136">好莱坞演员连接的节点。</st>
- en: <st c="34153">Nodes with many long-range connections not only have a large total
    degree, but they also have a total degree that is significantly above what we
    might expect given the values from most of the other nodes.</st> <st c="34359">This
    raises the question of what sort of distribution of node degree values we see
    in different types of networks.</st> <st c="34474">In a small-world network, we
    expect to see an extended right-hand tail to the distribution, meaning that there
    is a small, but non-negligible, probability of getting a node with a very large
    total degree value.</st> <st c="34685">Beyond this, what kind of degree distribution
    should we expect for a graph?</st> <st c="34761">Does it have a natural shape
    or scale?</st> <st c="34800">Some of the most interesting graphs that graph theorists
    have studied recently are those whose degree distributions have no scale to them
    at all.</st> <st c="34946">These are</st> <st c="34955">called</st> **<st c="34963">scale-free</st>**
    <st c="34973">graphs, and we’ll introduce</st> <st c="35002">them next.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34153">拥有许多长程连接的节点不仅总度数很大，而且它们的总度数也显著高于我们基于其他节点的值所期望的水平。</st> <st c="34359">这引发了一个问题：我们在不同类型的网络中会看到什么样的节点度数分布。</st>
    <st c="34474">在小世界网络中，我们预计度数分布的右侧尾部会延伸，这意味着存在一个小但不可忽视的概率，能够得到一个具有非常大总度数的节点。</st>
    <st c="34685">除此之外，我们应该期待图的度数分布是什么样的呢？</st> <st c="34761">它是否有自然的形态或尺度？</st> <st
    c="34800">一些最近图论学者研究的最有趣的图形是那些其度数分布完全没有尺度的图。</st> <st c="34946">这些图被称为</st> <st
    c="34955">**无标度**</st> <st c="34963">图，我们接下来将介绍它们。</st>
- en: <st c="35012">Scale-free networks</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="35012">无标度网络</st>
- en: <st c="35032">A</st> <st c="35035">scale-free network is</st> <st c="35056">a
    network whose statistical properties have no natural scale to them.</st> <st c="35127">This
    means that if the node degree value is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="35171"><st c="35172">, then the probability distribution of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35211"><st c="35212">can’t be written as some function,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>/</mml:mo><mml:mi>λ</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3463.png)<st
    c="35248"><st c="35255">. If it could, it would mean that the value of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>λ</mml:mi></mml:math>](img/3464.png)
    <st c="35302"><st c="35303">would provide a natural scale against which to measure
    the values of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="35373"><st c="35374">. The only possible distributions that satisfy the requirement
    of not having a</st> <st c="35453">scale are</st> **<st c="35463">power-law distributions</st>**<st
    c="35486">. This means the probability of getting a degree value of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35544"><st c="35545">is proportional to</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:msup></mml:math>](img/3467.png)<st
    c="35565"><st c="35566">. The parameter,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>α</mml:mi><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/3468.png)<st
    c="35583"><st c="35585">, is the exponent of the power-law distribution.</st>
    <st c="35634">The degree value is a discrete quantity, so we can write</st> <st
    c="35690">the probability distribution</st> <st c="35720">as follows:</st></st></st></st></st></st></st></st></st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35032">A</st> <st c="35035">无标度网络是</st> <st c="35056">一种其统计特性没有自然尺度的网络。</st>
    <st c="35127">这意味着，如果节点的度数值是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="35171"><st c="35172">，则</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35211"><st c="35212">的概率分布无法写成某个函数形式，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>/</mml:mo><mml:mi>λ</mml:mi><mml:mo>)</mml:mo></mml:math>](img/3463.png)<st
    c="35248"><st c="35255">。如果可以，这将意味着</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>λ</mml:mi></mml:math>](img/3464.png)
    <st c="35302"><st c="35303">的值将提供一个自然的尺度，用于衡量</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="35373"><st c="35374">的值。唯一符合没有</st> <st c="35453">尺度要求的分布是</st> **<st c="35463">幂律分布</st>**<st
    c="35486">。这意味着获取度数值为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35544"><st c="35545">的概率与</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:msup></mml:math>](img/3467.png)<st
    c="35565"><st c="35566">成正比。</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>α</mml:mi><mml:mo>></mml:mo><mml:mn>0</mml:mn></mml:math>](img/3468.png)<st
    c="35583"><st c="35585">是幂律分布的指数。</st> <st c="35634">度数值是一个离散的量，因此我们可以将</st> <st
    c="35690">概率分布写成如下形式：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Prob</mtext><mfenced
    open="(" close=")"><mrow><mtext>Total</mtext><mtext>Degree</mtext><mtext>=</mtext><mi>x</mi></mrow></mfenced><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>0</mn><mtext>if</mtext><mi>x</mi><mo><</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd><mfrac><msup><mi>x</mi><mrow><mo>−</mo><mi>α</mi></mrow></msup><mrow><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced></mrow></mfrac></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3469.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>Prob</mtext><mfenced
    open="(" close=")"><mrow><mtext>Total</mtext><mtext>Degree</mtext><mtext>=</mtext><mi>x</mi></mrow></mfenced><mo>=</mo><mfenced
    open="{" close=""><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><mrow><mn>0</mn><mtext>if</mtext><mi>x</mi><mo><</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd><mfrac><msup><mi>x</mi><mrow><mo>−</mo><mi>α</mi></mrow></msup><mrow><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced></mrow></mfrac></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3469.png)'
- en: <st c="35782">Eq.</st> <st c="35786">9</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35782">等式</st> <st c="35786">9</st>
- en: <st c="35787">The</st> <st c="35790">value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/3470.png)
    <st c="35800"><st c="35804">is the minimum value that</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35830"><st c="35831">can take.</st> <st c="35842">The function,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>ζ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/3472.png)<st
    c="35856"><st c="35857">, in Eq.</st> <st c="35866">9 is known as the</st> **<st
    c="35884">Hurwitz zeta function</st>**<st c="35905">. It ensures that the probability
    distribution is properly normalized – that is, the sum of all the probabilities
    is 1\.</st> <st c="36025">This means that the function,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>ζ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/3473.png)<st
    c="36055"><st c="36056">, is given by the</st> <st c="36074">following equation:</st></st></st></st></st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35787">值</st> <st c="35790">of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/3470.png)
    <st c="35800"><st c="35804">是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="35830"><st c="35831">的最小值。</st> <st c="35842">该函数，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>ζ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/3472.png)<st
    c="35856"><st c="35857">，在等式</st> <st c="35866">9中被称为</st> **<st c="35884">赫尔维茨ζ函数</st>**<st
    c="35905">。它确保概率分布是正确归一化的——即，所有概率的总和为1。</st> <st c="36025">这意味着该函数，</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>ζ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/3473.png)<st
    c="36055"><st c="36056">，由以下等式给出：</st></st></st></st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced><mo>=</mo><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><msup><mfenced open="(" close=")"><mrow><mi>n</mi><mo>+</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfenced><mrow><mo>−</mo><mi>α</mi></mrow></msup></mrow></mrow></mrow></math>](img/3474.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced><mo>=</mo><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi
    mathvariant="normal">∞</mi></munderover><msup><mfenced open="(" close=")"><mrow><mi>n</mi><mo>+</mo><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfenced><mrow><mo>−</mo><mi>α</mi></mrow></msup></mrow></mrow></mrow></math>](img/3474.png)'
- en: <st c="36120">Eq.</st> <st c="36124">10</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36120">方程</st> <st c="36124">10</st>
- en: <st c="36126">The power-law distribution in Eq.</st> <st c="36161">9 is a slowly
    decreasing function.</st> <st c="36196">The slow decrease in probability as</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="36232"><st c="36233">increases means that there is a small but non-negligible
    probability of getting a very large value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="36336"><st c="36337">. In simple terms, it means that in any large scale-free
    network, there will be a few nodes that are connected to a large proportion of</st>
    <st c="36473">the network.</st></st></st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36126">方程中的幂律分布</st> <st c="36161">9是一个缓慢递减的函数。</st> <st c="36196">概率随着</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)
    <st c="36232"><st c="36233">的增加而缓慢减少，这意味着获得一个非常大值的</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi></mml:math>](img/10.png)<st
    c="36336"><st c="36337">的概率虽然小，但不可忽视。简单来说，这意味着在任何大型无尺度网络中，都会有一些节点与网络中很大一部分节点相连。</st></st></st>
- en: <st c="36485">What does a power-law distribution look like?</st> <st c="36532">Pretty
    boring in fact.</st> <st c="36555">If we look at Eq.</st> <st c="36573">9 in a
    bit more detail and take the logarithm of it for</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi
    mathvariant="normal">n</mml:mi></mml:mrow></mml:msub></mml:math>](img/3477.png)<st
    c="36629"><st c="36630">, then we have</st> <st c="36645">the following:</st></st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36485">幂律分布是什么样的？</st> <st c="36532">实际上相当无聊。</st> <st c="36555">如果我们稍微详细地查看方程</st>
    <st c="36573">9，并对其取对数，得到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi
    mathvariant="normal">n</mml:mi></mml:mrow></mml:msub></mml:math>](img/3477.png)<st
    c="36629"><st c="36630">，那么我们得到如下结果：</st> <st c="36645">以下：</st></st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>log</mi><mtext>Prob</mtext><mfenced
    open="(" close=")"><mrow><mtext>Total</mtext><mtext>Degree</mtext><mtext>=</mtext><mi>x</mi></mrow></mfenced><mo>=</mo><mo>−</mo><mi>α</mi><mi>log</mi><mi>x</mi><mo>−</mo><mi>log</mi><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced></mrow></mrow></math>](img/3478.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>log</mi><mtext>Prob</mtext><mfenced
    open="(" close=")"><mrow><mtext>Total</mtext><mtext>Degree</mtext><mtext>=</mtext><mi>x</mi></mrow></mfenced><mo>=</mo><mo>−</mo><mi>α</mi><mi>log</mi><mi>x</mi><mo>−</mo><mi>log</mi><mi>ζ</mi><mfenced
    open="(" close=")"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>,</mo><mi>α</mi></mrow></mfenced></mrow></mrow></math>](img/3478.png)'
- en: <st c="36712">Eq.</st> <st c="36716">11</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36712">方程。</st> <st c="36716">11</st>
- en: <st c="36718">Eq.</st> <st c="36723">11 is just the equation of a straight line
    with</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3479.png)
    <st c="36771"><st c="36777">being the variable on the</st> *<st c="36803">x</st>*<st
    c="36804">-axis.</st> <st c="36811">This means that on a logarithmic scale, our
    power-law probabilities decrease linearly.</st> <st c="36898">Figure 10</st><st
    c="36907">.14 shows an example of a power-law distribution for</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>2.5</mml:mn></mml:math>](img/3480.png)
    <st c="36960"><st c="36961">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3481.png)<st
    c="36966"><st c="36967">. The line shows the</st> <st c="36987">probabilities
    calculated according to Eq.</st> <st c="37030">9\.</st> <st c="37033">Note that
    the red line is linear.</st> <st c="37067">That is because we have plotted both
    the</st> *<st c="37108">x</st>*<st c="37109">-axis and</st> *<st c="37119">y</st>*<st
    c="37120">-axis in</st> <st c="37129">Figure 10</st><st c="37138">.14 on a logarithmic
    sca</st><st c="37162">le to emphasize the power-law decay of</st> <st c="37202">the
    probabilities:</st></st></st></st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36718">公式</st> <st c="36723">11 只是一个直线方程，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3479.png)
    <st c="36771"><st c="36777">是以</st> *<st c="36803">x</st>*<st c="36804">轴上的变量为基础的。</st>
    <st c="36811">这意味着在对数刻度上，我们的幂律概率呈线性下降。</st> <st c="36898">图 10.14 展示了一个幂律分布的例子，</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>2.5</mml:mn></mml:math>](img/3480.png)
    <st c="36960"><st c="36961">以及</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/3481.png)<st
    c="36966"><st c="36967">。该线表示根据公式</st> <st c="36987">9 计算的概率。</st> <st c="37030">请注意，红线是线性的。</st>
    <st c="37033">这是因为我们在图 10.14 中将</st> *<st c="37108">x</st>*<st c="37109">轴和</st>
    *<st c="37119">y</st>*<st c="37120">轴都绘制在对数刻度上，</st> <st c="37129">以强调概率的幂律衰减：</st>
- en: '![](img/B19496_10_14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19496_10_14.jpg)'
- en: '<st c="37333">Figure 10.14: A power-law distribution of node degree values</st>'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37333">图 10.14：节点度值的幂律分布</st>
- en: <st c="37393">The</st> <st c="37398">black dots in</st> <st c="37412">Figure
    10</st><st c="37421">.14 represent sample proportions of the different node degree
    values when I generated a sample of 5,000,000 degree values from the probability
    distribution represented by the red line.</st> <st c="37606">As you would expect,
    the sample proportions follow the line closely.</st> <st c="37675">We can see
    from those black dots that there is a small but not insignificant fraction of
    total degree values greater than 1,000\.</st> <st c="37804">This would represent
    nodes that were connected to more than 1,000</st> <st c="37870">other nodes.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37393">图</st> <st c="37398">10.14 中的黑点代表了当我从由红线表示的概率分布中生成了 5,000,000
    个度值样本时，不同节点度值的样本比例。</st> <st c="37606">正如你所期望的，样本比例紧密跟随红线。</st> <st c="37675">从这些黑点中我们可以看到，总体度值中有一小部分（但并非微不足道）大于
    1,000。</st> <st c="37804">这代表了连接到超过 1,000 个其他节点的节点。</st>
- en: <st c="37882">From the example in</st> <st c="37903">Figure 10</st><st c="37912">.14,
    it should be apparent that scale-free networks exhibit the small-world phenomenon,
    so scale-free networks are also small-world networks.</st> <st c="38054">Perhaps
    more interesting is that for scale-free networks, the mean shortest path distance
    between nodes,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3482.png)<st
    c="38159"><st c="38160">, only grows as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math>](img/3483.png)
    <st c="38176"><st c="38184">as the size of the network,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/686.png)<st
    c="38212"><st c="38213">, increases.</st> <st c="38226">Now,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math>](img/3483.png)
    <st c="38231"><st c="38239">is an even more slowly increasing function of</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)
    <st c="38285"><st c="38286">than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3487.png)<st
    c="38292"><st c="38293">, meaning that in scale-free networks, the typical distance
    between nodes hardly changes, even as we get to very big networks.</st> <st c="38420">We
    can think of scale-free networks as being</st> <st c="38465">super-small-world
    networks.</st></st></st></st></st></st></st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从<st c="37882">图 10.14 中的示例</st> <st c="37903">可以明显看出，标度无关网络表现出小世界现象，因此标度无关网络也是小世界网络。</st>
    <st c="38054">或许更有趣的是，对于标度无关网络，节点之间的平均最短路径距离，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3482.png)<st
    c="38159"><st c="38160">，仅随</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math>](img/3483.png)
    <st c="38176"><st c="38184">随着网络规模</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/686.png)<st
    c="38212"><st c="38213">，增加。</st> <st c="38226">现在，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math>](img/3483.png)
    <st c="38231"><st c="38239">是一个更缓慢增长的函数，比</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3487.png)<st
    c="38292"><st c="38293">增长得更慢，这意味着在标度无关网络中，即使网络变得非常大，节点之间的典型距离几乎不变。</st> <st c="38420">我们可以将标度无关网络视为</st>
    <st c="38465">超小世界网络。</st>
- en: <st c="38492">In reality, any finite-sized network</st> <st c="38529">always
    has a scale associated with it – the size of the network.</st> <st c="38595">That
    means a real-world network cannot be truly scale-free.</st> <st c="38655">Does
    this mean scale-free networks are useless to us?</st> <st c="38709">No, far from
    it.</st> <st c="38726">Many large real-world networks, while not</st> **<st c="38768">exactly</st>**
    <st c="38775">scale-free, are extremely well approximated by scale-free networks,
    so studying and understanding the properties of scale-free networks helps us understand
    the properties of those real-world networks.</st> <st c="38977">For example, the
    node degree values of real-world</st> <st c="39027">networks can display linear
    behavior like that in</st> <st c="39077">Figure 10</st><st c="39086">.14 or very
    close to it.</st> <st c="39111">Examples of real-world networks whose node degree
    distributions are modeled well by a power-law distribution include</st> <st c="39228">the
    following:</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38492">实际上，任何有限大小的网络</st> <st c="38529">总是有一个与之相关的尺度——网络的大小。</st> <st
    c="38595">这意味着，现实世界的网络不可能真正是无尺度的。</st> <st c="38655">这是否意味着无尺度网络对我们没有用处？</st>
    <st c="38709">不，远非如此。</st> <st c="38726">许多大型现实世界网络，尽管不是</st> **<st c="38768">完全</st>**
    <st c="38775">无尺度的，但它们可以被无尺度网络很好地近似，因此研究和理解无尺度网络的属性有助于我们理解这些现实世界网络的特性。</st> <st
    c="38977">例如，现实世界网络的节点度值可以呈现出类似于</st> <st c="39027">图10.14中那样的线性行为，或者非常接近它。</st>
    <st c="39111">一些现实世界网络的节点度分布很好地被幂律分布建模，例如</st> <st c="39228">以下这些：</st>
- en: <st c="39242">The World Wide Web, where both the node in-degree and out-degree
    values of websites follow power-law</st> <st c="39344">distributions closely</st>
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39242">万维网，其中网站的节点入度和出度值遵循幂律分布</st> <st c="39344">密切相关</st>
- en: <st c="39365">Scientific paper citation networks, where the in-degree values
    appear to follow a</st> <st c="39448">power-law distribution</st>
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39365">科学论文引用网络，其中入度值似乎遵循</st> <st c="39448">幂律分布</st>
- en: <st c="39470">That concludes our introduction to different classes of graphs.</st>
    <st c="39535">We have covered only a small number of classes in this section.</st>
    <st c="39599">There are many more.</st> <st c="39620">However, you will have gained
    a flavor of and feel for the rich variety of structures, behaviors, and uses that
    you can see across different classes of graphs.</st> <st c="39780">Let’s remind
    ourselves what we have covered in</st> <st c="39827">this section.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39470">这就是我们对不同类别图的介绍的总结。</st> <st c="39535">在本节中，我们只覆盖了少数几类。</st> <st
    c="39599">还有更多类别。</st> <st c="39620">然而，你已经对不同类别图的丰富结构、行为和用途有了一个大致的了解。</st> <st
    c="39780">让我们回顾一下本节内容。</st> <st c="39827">我们在本节中学到了：</st>
- en: <st c="39840">What we’ve learned</st>
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="39840">我们学到的</st>
- en: <st c="39859">In this section, we learned</st> <st c="39888">the following:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39859">在本节中，我们学到了</st> <st c="39888">以下内容：</st>
- en: <st c="39902">A graph can be fully connected if every node is connected to every</st>
    <st c="39970">other node.</st>
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39902">如果每个节点都与其他所有节点相连，则一个图可以是完全连通的。</st>
- en: <st c="39981">A graph can consist of several disconnected components, each of
    which is a graph in its</st> <st c="40070">own right.</st>
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="39981">一个图可以由若干个不相连的分量组成，每个分量本身就是一个图。</st> <st c="40070">它们各自独立。</st>
- en: <st c="40080">A directed graph can be used to represent a set of dependencies,
    in which case it is desirable not to have any cycles in the directed graph.</st>
    <st c="40222">Such graphs are</st> <st c="40238">called DAGs.</st>
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="40080">有向图可以用来表示一组依赖关系，在这种情况下，最好不要在有向图中存在任何环。</st> <st c="40222">这种图被称为DAG。</st>
- en: <st c="40250">Many real-world graphs exhibit the small-world phenomenon, where
    the typical distance between any two nodes is small and only a weakly growing
    function of the</st> <st c="40410">network size.</st>
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="40250">许多现实世界的图表现出小世界现象，其中任何两个节点之间的典型距离较小，并且是网络大小的弱增长函数。</st> <st c="40410">网络的大小。</st>
- en: <st c="40423">Scale-free networks have node degree distributions that are scale-free
    and follow a power-law.</st> <st c="40519">Scale-free networks exhibit the</st>
    <st c="40551">small-world phenomenon.</st>
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="40423">无尺度网络的节点度分布是无尺度的，并且遵循幂律。</st> <st c="40519">无尺度网络表现出</st> <st
    c="40551">小世界现象。</st>
- en: <st c="40574">Having learned about some different types of graphs, including
    graph types that occur frequently in real-world settings, in the next section,
    we’ll do some calculations with graph data.</st> <st c="40761">We will look at
    community detection, where we take a graph and try to identify the main sub-graphs
    within it that represent distinct communities</st> <st c="40906">of nodes.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40574">在学习了一些不同类型的图形，包括现实世界环境中常见的图形类型后，在接下来的部分中，我们将使用图形数据进行一些计算。</st>
    <st c="40761">我们将讨论社区检测，在其中我们从一个图形开始，尝试识别其中代表不同社区的主要子图</st> <st c="40906">。</st>
- en: <st c="40915">Community detection and decomposing graphs</st>
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="40915">社区检测与图形分解</st>
- en: <st c="40958">Community detection</st> <st c="40978">is a common data science
    task and a useful technique to have in your data science toolkit, but let’s start
    by describing what we mean by</st> <st c="41116">a community.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40958">社区检测</st> <st c="40978">是数据科学中的一个常见任务，是数据科学工具包中非常有用的技术，但我们先从描述什么是</st>
    <st c="41116">社区</st> <st c="41389">开始。</st>
- en: <st c="41128">What is a community?</st>
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="41128">什么是社区？</st>
- en: <st c="41149">In many real-world networks, nodes are used to represent people.</st>
    <st c="41215">Consequently, when we have a</st> <st c="41243">collection of highly
    connected nodes, forming almost a fully connected separate graph, we can think
    of this as a</st> **<st c="41357">community</st>** <st c="41366">of</st> <st c="41370">interacting
    people.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41149">在许多现实世界的网络中，节点用来表示人。</st> <st c="41215">因此，当我们有一组高度连接的节点，几乎形成一个完全连接的独立图时，我们可以将其看作是一个</st>
    **<st c="41357">社区</st>** <st c="41366">，由</st> <st c="41370">互动的人们组成。</st>
- en: <st c="41389">We can extend this idea to situations where the nodes do not represent
    people.</st> <st c="41469">For example, our trade network example at the beginning
    of this chapter was fully connected, but if it wasn’t, there might be groups of
    countries that preferentially trade with each other and don’t trade with other
    countries.</st> <st c="41695">We would have separate trading blocks or trading
    communities.</st> <st c="41757">Similarly, in our pizza example, we have groups
    of pizzas that are more similar to each other and hence interchangeable.</st>
    <st c="41878">This means we have communities</st> <st c="41909">of pizzas.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41389">我们可以将这个概念扩展到节点不代表人的情况。</st> <st c="41469">例如，本章开头的贸易网络示例是完全连接的，但如果它不是完全连接的，可能会有一些国家群体优先与彼此进行贸易，而不与其他国家进行贸易。</st>
    <st c="41695">我们会有独立的贸易区块或贸易社区。</st> <st c="41757">类似地，在我们的披萨示例中，我们有一些披萨群体，它们彼此之间更为相似，因此是可以互换的。</st>
    <st c="41878">这意味着我们有披萨的</st> <st c="41909">社区。</st>
- en: <st c="41919">Why is knowing about communities useful to us?</st> <st c="41967">A
    community represents a group of similar entities.</st> <st c="42019">In data</st>
    <st c="42027">science, it is often useful to be able to group things – to analyze
    them together, to model their response to a feature using a single parameter.</st>
    <st c="42173">This means we often want to take a graph, as represented by an adjacency
    matrix, and identify the community</st> <st c="42281">structure present in the
    graph.</st> <st c="42313">This is the problem of</st> **<st c="42336">community
    detection</st>**<st c="42355">. We are taking a graph and breaking it down into
    a set of sub-graphs.</st> <st c="42426">In other words, community detection is
    about decomposing</st> <st c="42483">a graph.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41919">了解社区为何对我们有用？</st> <st c="41967">社区代表一组相似的实体。</st> <st c="42019">在数据</st>
    <st c="42027">科学中，能够将事物分组通常是非常有用的——可以一起分析它们，使用单个参数来建模它们对某一特征的响应。</st> <st c="42173">这意味着我们通常希望从一个图形开始，图形由邻接矩阵表示，并识别图形中存在的社区</st>
    <st c="42281">结构。</st> <st c="42313">这就是</st> **<st c="42336">社区检测</st>**<st c="42355">的问题所在。我们正在将一个图形分解为一组子图。</st>
    <st c="42426">换句话说，社区检测就是关于分解</st> <st c="42483">一个图形。</st>
- en: <st c="42491">How to do community detection</st>
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="42491">如何进行社区检测</st>
- en: <st c="42521">We have said that we can think of a community as a highly connected
    set of related nodes.</st> <st c="42612">This means that when we have isolated
    communities, detecting them is easy.</st> <st c="42687">Figure 10</st><st c="42696">.15
    shows an example of two distinct communities of nodes.</st> <st c="42755">The
    different communities are obvious.</st> <st c="42794">The different communities
    correspond to separate graphs.</st> <st c="42851">The communities</st> <st c="42866">are
    disconnected from each other.</st> <st c="42901">If</st> <st c="42904">Figure
    10</st><st c="42913">.15 looks familiar, that is because it is the same as</st>
    <st c="42967">Figure 10</st><st c="42976">.11, which we u</st><st c="42991">sed
    to illustrate a graph consisting of</st> <st c="43032">disconnected components:</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42521">我们曾说过，我们可以把一个社区看作是一个高度连接的相关节点集。</st> <st c="42612">这意味着当我们有孤立的社区时，检测它们是很容易的。</st>
    <st c="42687">图 10</st><st c="42696">.15 展示了两个不同的节点社区的示例。</st> <st c="42755">这些不同的社区非常明显。</st>
    <st c="42794">不同的社区对应着不同的图。</st> <st c="42851">这些社区</st> <st c="42866">相互之间是断开的。</st>
    <st c="42901">如果</st> <st c="42904">图 10</st><st c="42913">.15 看起来很熟悉，那是因为它与我们曾用来展示由断开组件组成的图的</st>
    <st c="42967">图 10</st><st c="42976">.11 相同：</st>
- en: '![Figure 10.15: Two distinct communities of nodes](img/B19496_10_15.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15：两个不同的节点社区](img/B19496_10_15.jpg)'
- en: '<st c="43081">Figure 10.15: Two distinct communities of nodes</st>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43081">图 10.15：两个不同的节点社区</st>
- en: <st c="43128">Mathematically, detecting communities is easy when they correspond
    to disconnected components of a graph.</st> <st c="43235">However, consider the
    graph in</st> <st c="43266">Figure 10</st><st c="43275">.16\.</st> <st c="43280">It
    is a single graph, but how many communities</st> <st c="43327">are there?</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43128">从数学角度来看，当社区对应于图的断开组件时，检测它们是容易的。</st> <st c="43235">然而，考虑图 10</st><st
    c="43266">.16</st> <st c="43275">。这是一个单一的图，但它有多少个社区呢？</st>
- en: '![Figure 10.16: A single graph with two communities](img/B19496_10_16.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16：一个包含两个社区的单一图](img/B19496_10_16.jpg)'
- en: '<st c="43339">Figure 10.16: A single graph with two communities</st>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43339">图 10.16：一个包含两个社区的单一图</st>
- en: <st c="43388">To most</st> <st c="43397">people, the graph in</st> <st c="43418">Figure
    10</st><st c="43427">.16 would also appear to consist of two communities.</st>
    <st c="43480">The communities are clear.</st> <st c="43507">There is one community
    on the left-hand part of the graph in</st> <st c="43568">Figure 10</st><st c="43577">.16
    and one on the right-hand side.</st> <st c="43613">To any human observer, the
    identification of the commun</st><st c="43668">ities is obvious and corresponds
    to that shown in</st> <st c="43719">Figure 10</st><st c="43728">.17:</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43388">对于大多数</st> <st c="43397">人来说，图 10</st><st c="43418">.16 也看起来由两个社区组成。</st>
    <st c="43480">这些社区是显而易见的。</st> <st c="43507">图 10</st><st c="43568">.16 中，左侧有一个社区，右侧有另一个社区。</st>
    <st c="43613">对于任何人类观察者来说，识别这些社区是显而易见的，这也与图 10</st><st c="43719">.17 中的社区划分相对应：</st>
- en: '![Figure 10.17: Identifying two communities in a single graph](img/B19496_10_17.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17：在单一图中识别两个社区](img/B19496_10_17.jpg)'
- en: '<st c="43759">Figure 10.17: Identifying two communities in a single graph</st>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43759">图 10.17：在单一图中识别两个社区</st>
- en: <st c="43818">The two communities in</st> <st c="43842">Figure 10</st><st c="43851">.17
    are connected and have a node in common.</st> <st c="43896">As humans, we are
    OK with the idea that communities are connected, with nodes that act as links
    between them.</st> <st c="44006">Mathematically, we need algorithms that are comfortable
    with the ambiguity of not having perfectly disconnected components and can identify
    the parts of the graph that are most community-like.</st> <st c="44199">We will
    briefly describe some of these</st> <st c="44238">algorithms next.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="43818">图 10.17 中的两个社区是连接的，并且有一个公共节点。</st> <st c="43842">如同人类一样，我们接受社区是相互连接的，节点充当着它们之间的链接。</st>
    <st c="43896">从数学角度来看，我们需要一些算法，能够适应没有完全断开的组件的模糊性，并能识别出图中最像社区的部分。</st> <st c="44006">我们接下来将简要描述其中一些算法。</st> '
- en: <st c="44254">Community detection algorithms</st>
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="44254">社区检测算法</st>
- en: <st c="44285">Community detection algorithms</st> <st c="44317">attempt to identify
    the parts of a graph that look most like a distinct community.</st> <st c="44400">As
    you can imagine, they do this by attempting to find a subset of nodes that are
    tightly connected and weakly connected to nodes outside of the subset.</st> <st
    c="44553">Essentially, community detection corresponds to a process of using the
    information encoded in a graph’s adjacency matrix to assign each node to a subset
    (</st><st c="44707">the community).</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44285">社区检测算法</st> <st c="44317">旨在识别图中最像独立社区的部分。</st> <st c="44400">正如你所想的那样，它们通过尝试找到一个节点子集，节点之间紧密连接，并且与子集外部的节点连接较弱，来实现这一目标。</st>
    <st c="44553">本质上，社区检测对应于使用图的邻接矩阵中编码的信息，将每个节点分配到一个子集（</st><st c="44707">即社区</st>）。
- en: <st c="44723">Once each node has been assigned to a community, we can assess
    the quality of the assignment by measuring how inter-connected nodes within the
    same community are compared to nodes from separate communities.</st> <st c="44931">If
    we have a quantitative metric that measures this quality – that is, measures the
    within-community connectedness compared to the between-community connectedness
    – then we can iterate the overall process to maximize this community quality metric.</st>
    <st c="45179">This is the essence of a community</st> <st c="45214">detection
    algorithm.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44723">一旦每个节点被分配到一个社区，我们可以通过测量同一社区内节点之间的相互连接程度与来自不同社区的节点之间的连接程度来评估分配的质量。</st>
    <st c="44931">如果我们有一个定量度量标准来衡量这个质量——即衡量社区内的连接性与社区之间的连接性——那么我们可以迭代整个过程来最大化这个社区质量度量。</st>
    <st c="45179">这就是社区</st> <st c="45214">检测算法的本质。</st>
- en: <st c="45234">As you can imagine, there are different metrics we can use to
    measure the quality of a specific node-to-community assignment and different optimization
    approaches we can use to maximize the chosen assignment quality metric.</st> <st
    c="45459">This means there are many different types and flavors of community</st>
    <st c="45526">detection algorithms.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45234">如你所想，我们可以使用不同的度量标准来衡量特定节点到社区的分配质量，以及我们可以使用不同的优化方法来最大化选定的分配质量度量。</st>
    <st c="45459">这意味着有许多不同类型和风格的社区</st> <st c="45526">检测算法。</st>
- en: <st c="45547">The most commonly used type of community detection algorithm is</st>
    **<st c="45612">modularity maximization</st>**<st c="45635">. As the</st> <st
    c="45644">name suggests, this algorithm maximizes the total modularity score of
    the community assignment.</st> <st c="45740">The modularity score of a community
    is the difference between the actual number of edges between nodes within the
    community and the expected number of edges within the community if the edges of
    the graph were placed at random.</st> <st c="45967">So, we can think of the modularity
    score as a measure of the observed within-community excess number of edges.</st>
    <st c="46078">If our community assignment genuinely reflected some true underlying
    community structure, then we would expect this excess number of edges to be high
    as nodes within a genuine community have a high probability of being connected.</st>
    <st c="46308">So, a high modularity score is indicative of a good community assignment.</st>
    <st c="46382">Modularity maximization can be applied to split a graph into just
    two communities or more than two communities.</st> <st c="46494">There are also
    different algorithms to perform the maximization, including</st> <st c="46569">the
    following:</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45547">最常用的社区检测算法是</st> **<st c="45612">模块化最大化</st>**<st c="45635">。顾名思义，这种算法通过最大化社区分配的总模块化得分来实现。</st>
    <st c="45644">社区的模块化得分是社区内部节点之间实际边数与如果图的边随机放置时社区内部预期边数之间的差异。</st> <st c="45740">因此，我们可以将模块化得分看作是观察到的社区内部超额边数的度量。</st>
    <st c="45967">如果我们的社区分配确实反映了某种真实的潜在社区结构，那么我们预计这些多余的边数会很高，因为在一个真实的社区中，节点之间有很高的连接概率。</st>
    <st c="46078">因此，高模块化得分是良好社区分配的标志。</st> <st c="46308">模块化最大化可以用于将图分割成两个社区或更多社区。</st>
    <st c="46382">模块化最大化也有不同的算法可以实现，包括</st> <st c="46494">以下几种：</st>
- en: <st c="46583">Greedy algorithms, which perform the</st> <st c="46621">maximization
    iteratively</st>
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="46583">贪心算法，它通过</st> <st c="46621">迭代地执行最大化</st>
- en: <st c="46645">The spectral method, which uses the eigen-decomposition (see</st>
    [*<st c="46707">Chapter 3</st>*](B19496_03.xhtml#_idTextAnchor141)<st c="46716">)
    of the modularity matrix (which is derived from the adjacency matrix) to find
    an optimal</st> <st c="46808">community assignment.</st>
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="46645">谱方法，使用特征分解（参见</st> [*<st c="46707">第3章</st>*](B19496_03.xhtml#_idTextAnchor141)<st
    c="46716">）模块化矩阵（由邻接矩阵推导而来）来寻找最优的</st> <st c="46808">社区分配。</st>
- en: <st c="46829">The Louvain algorithm, which performs the modularity maximization
    agglomeratively.</st> <st c="46913">It</st> <st c="46915">starts by joining single
    nodes into pairs, then joining other pairs or single nodes together, and so on,
    each time measuring the modularity score until no improvement in the modularity
    score</st> <st c="47107">is obtained.</st>
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="46829">Louvain算法通过模块化最大化的方法进行聚类。</st> <st c="46913">它</st> <st c="46915">首先将单个节点合并成对，然后将其他对或单个节点结合在一起，依此类推，每次都衡量模块化得分，直到模块化得分没有进一步提高</st>
    <st c="47107">为止。</st>
- en: <st c="47119">There are also other classes of community detection algorithms,
    including</st> <st c="47194">the following:</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47119">还有其他类型的社区检测算法，包括</st> <st c="47194">以下几种：</st>
- en: '**<st c="47208">Model-based approaches</st>**<st c="47231">: These fit a probabilistic
    model (see</st> [*<st c="47271">Chapter 5</st>*](B19496_05.xhtml#_idTextAnchor261)<st
    c="47280">) to the</st> <st c="47289">graph structure, with the model assuming
    some community structure.</st> <st c="47357">This allows us to compute the likelihood
    of the observed network structure given the assumed community structure.</st>
    <st c="47471">The likelihood can then be maximized with respect to the community
    structure to obtain a community structure that is highly compatible with the given
    network</st> <st c="47629">adjacency matrix.</st>'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="47208">基于模型的方法</st>**<st c="47231">：这些方法将概率模型（参见</st> [*<st c="47271">第5章</st>*](B19496_05.xhtml#_idTextAnchor261)<st
    c="47280">）拟合到</st> <st c="47289">图结构中，模型假设存在某种社区结构。</st> <st c="47357">这使得我们可以计算在给定社区结构下观察到的网络结构的可能性。</st>
    <st c="47471">然后，可以最大化该可能性，以获得与给定网络邻接矩阵高度兼容的社区结构。</st>'
- en: '**<st c="47646">Betweenness-based approaches</st>**<st c="47675">: These attempt
    to uncover the community</st> <st c="47717">structure present in a graph by breaking
    the graph apart into disconnected components.</st> <st c="47804">By iteratively
    identifying and then removing edges that have a high “betweenness” score – that
    is, those edges that connect a high number of different parts of the network –
    the idea is that the graph will quickly separate (fall apart) into disconnected
    communities after the removal of these high “betweenness” edges.</st> <st c="48123">Perhaps
    the most well-known and commonly used betweenness community detection algorithm
    is that of Girvan and Newman – see the</st> *<st c="48250">Notes and further reading</st>*
    <st c="48275">section at the end of this chapter for details on</st> <st c="48326">this
    algorithm.</st>'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="47646">基于介数的算法</st>**<st c="47675">：这些方法试图通过将图拆分为不连通的组件来揭示图中的社区结构。</st>
    <st c="47717">通过反复识别并移除具有高“介数”得分的边——也就是说，那些连接网络中多个不同部分的边——其目的是让图在移除这些高“介数”边之后迅速分裂成不连通的社区。</st>
    <st c="47804">也许最著名和最常用的介数社区检测算法就是Girvan和Newman提出的算法——有关该算法的详细信息，请参见本章末尾的</st>
    *<st c="48250">注释和进一步阅读</st>* <st c="48275">部分。</st>'
- en: <st c="48341">Having introduced community detection algorithms, let’s try some
    out with a</st> <st c="48418">code example.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48341">在介绍了社区检测算法之后，让我们通过</st> <st c="48418">代码示例来尝试一些算法。</st>
- en: <st c="48431">Community detection code example</st>
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48431">社区检测代码示例</st>
- en: <st c="48464">The following</st> <st c="48479">code example and more can be
    found in the</st> `<st c="48521">Code_Examples_Chap10.ipynb</st>` <st c="48547">Jupyter
    Notebook in this book’s GitHub repository.</st> <st c="48599">It uses the example
    of the graph in</st> <st c="48635">Figure 10</st><st c="48644">.16\.</st> <st
    c="48649">We’ll use the</st> `<st c="48663">NetworkX</st>` <st c="48671">Python
    package to do the community detection.</st> <st c="48718">The graph in</st> <st
    c="48731">Figure 10</st><st c="48740">.16 is represented as a series of nodes
    and edges and stored in the</st> `<st c="48808">Data/example_network_adjlist.txt</st>`
    <st c="48840">file in this book’s GitHub repository.</st> <st c="48880">The data
    in the file is in a format that the</st> `<st c="48925">NetworkX</st>` <st c="48933">package
    can understand.</st> <st c="48958">Let’s start by reading in</st> <st c="48984">the
    graph:</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48464">以下</st> <st c="48479">代码示例以及更多内容可以在本书的 GitHub 仓库中的</st> `<st c="48521">Code_Examples_Chap10.ipynb</st>`
    <st c="48547">Jupyter Notebook 中找到。</st> <st c="48599">它使用的是图例</st> <st c="48635">图
    10</st><st c="48644">.16\。</st> <st c="48649">我们将使用</st> `<st c="48663">NetworkX</st>`
    <st c="48671">Python 包进行社区检测。</st> <st c="48718">图 10</st><st c="48731">.16 中的图由一系列节点和边表示，并存储在本书
    GitHub 仓库中的</st> `<st c="48808">Data/example_network_adjlist.txt</st>` <st c="48840">文件中。</st>
    <st c="48880">文件中的数据采用</st> `<st c="48925">NetworkX</st>` <st c="48933">包能够理解的格式。</st>
    <st c="48958">我们先从读取</st> <st c="48984">图开始：</st>
- en: '[PRE0]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="49088">The</st> `<st c="49093">nodetype=int</st>` <st c="49105">option
    tells</st> `<st c="49119">NetworkX</st>` <st c="49127">that the nodes are represented
    (labeled) by integers.</st> <st c="49182">Now that the graph is stored in</st>
    `<st c="49214">G</st>`<st c="49215">, we can</st> <st c="49224">visualize it:</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49088">`<st c="49093">nodetype=int</st>`</st> <st c="49105">选项告诉</st>
    `<st c="49119">NetworkX</st>` <st c="49127">节点是通过整数表示（标注）的。</st> <st c="49182">现在图已经存储在</st>
    `<st c="49214">G</st>`<st c="49215">中，我们可以</st> <st c="49224">将其可视化：</st>
- en: '[PRE1]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="49325">This results in the following graph.</st> <st c="49363">We have
    ove</st><st c="49374">rridden the default node color to make the node labels</st>
    <st c="49430">more visible:</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49325">这将产生以下图形。</st> <st c="49363">我们已经重写了默认的节点颜色，使得节点标签</st> <st c="49430">更加可见：</st>
- en: '![Figure 10.18: Our starting labeled graph](img/B19496_10_18.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18：我们的起始标注图](img/B19496_10_18.jpg)'
- en: '<st c="49445">Figure 10.18: Our starting labeled graph</st>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49445">图 10.18：我们的起始标注图</st>
- en: <st c="49485">Now, we’ll apply a modularity maximization algorithm to the graph,</st>
    `<st c="49553">G</st>`<st c="49554">. In this case, we’ll use the greedy</st>
    <st c="49591">modularity maximization algorithm that the</st> `<st c="49634">NetworkX</st>`
    <st c="49642">package supplies:</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49485">现在，我们将应用一个模块化最大化算法到该图，</st> `<st c="49553">G</st>`<st c="49554">。在这种情况下，我们将使用贪心的</st>
    <st c="49591">模块化最大化算法，这是</st> `<st c="49634">NetworkX</st>` <st c="49642">包提供的：</st>
- en: '[PRE2]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="49720">We’ve stored the result in the</st> `<st c="49752">communities</st>`
    <st c="49763">object.</st> <st c="49772">Let’s look</st> <st c="49783">at it:</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49720">我们将结果存储在</st> `<st c="49752">communities</st>` <st c="49763">对象中。</st>
    <st c="49772">让我们来看一下</st> <st c="49783">它：</st>
- en: '[PRE3]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="49801">This gives us the</st> <st c="49820">following output:</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49801">这将给我们以下输出：</st>
- en: '[PRE4]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="49915">Here, we can see that the</st> `<st c="49942">communities</st>`
    <st c="49953">object is two lists of integers, corresponding to the node IDs that
    the greedy modularity maximization algorithm has placed into two communities.</st>
    <st c="50100">In other words, the algorithm has identified two communities, one
    consisting of nodes [1,2,3,4,5,6], and the other corresponding to nodes [7,8,9,10,11,12,13].</st>
    <st c="50259">We’ll add some colors to the nodes according to which community
    they</st> <st c="50328">are in:</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49915">在这里，我们可以看到</st> `<st c="49942">communities</st>` <st c="49953">对象包含两个整数列表，分别对应贪心模块化最大化算法将节点
    ID 放入的两个社区。</st> <st c="50100">换句话说，算法已经识别出两个社区，一个由节点 [1,2,3,4,5,6] 组成，另一个对应节点
    [7,8,9,10,11,12,13]。</st> <st c="50259">我们将根据节点所在的社区给节点添加一些颜色：</st>
- en: '[PRE5]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="50567">Note that we first created a dictionary that mapped the node label
    to a community color and then created a list that used that dictionary to map
    the node index to a community color.</st> <st c="50750">This is because the order
    in which the nodes are indexed does not necessarily match the node labels, even
    if those labels are integer values.</st> <st c="50892">So, the node with a label
    of “6” is not necessarily stored as the 6</st><st c="50959">th</st> <st c="50962">node.</st>
    <st c="50969">To check the order in which the nodes are indexed, you can</st>
    <st c="51028">use</st> `<st c="51032">G.nodes</st>`<st c="51039">:</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50567">请注意，我们首先创建了一个字典，将节点标签映射到社区颜色，然后创建了一个列表，利用该字典将节点索引映射到社区颜色。</st>
    <st c="50750">这是因为节点的索引顺序不一定与节点标签匹配，即使这些标签是整数值。</st> <st c="50892">因此，标签为“6”的节点不一定是第
    6</st><st c="50959">个</st> <st c="50962">节点。</st> <st c="50969">要检查节点的索引顺序，可以</st>
    <st c="51028">使用</st> `<st c="51032">G.nodes</st>`<st c="51039">：</st>
- en: '[PRE6]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="51049">This gives us the</st> <st c="51068">following output:</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51049">这为我们提供了</st> <st c="51068">以下结果：</st>
- en: '[PRE7]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="51147">Here, we</st> <st c="51156">can see that node 7 is indexed in
    the 6</st><st c="51196">th</st> <st c="51199">position, and node 6 is indexed
    in the 7</st><st c="51240">th</st> <st c="51243">position.</st> <st c="51254">With
    that little nuance sorted out and a color map created, we can now redraw the graph
    with each node colored according to which community it</st> <st c="51397">is in:</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51147">在这里，我们</st> <st c="51156">可以看到节点 7 位于第 6</st><st c="51196">个</st>
    <st c="51199">位置，节点 6 位于第 7</st><st c="51240">个</st> <st c="51243">位置。</st> <st
    c="51254">通过解决这个小细节并创建颜色图后，我们现在可以重新绘制图，按照每个节点所属的社区对其进行着色：</st>
- en: '[PRE8]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="51489">This gives us the</st> <st c="51508">following graph:</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51489">这为我们提供了</st> <st c="51508">以下图：</st>
- en: '![Figure 10.19: Our graph with two communities identified and nodes colored
    according to which community they belong to](img/B19496_10_19.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19：我们识别出两个社区并根据每个节点所属的社区对节点进行着色](img/B19496_10_19.jpg)'
- en: '<st c="51526">Figure 10.19: Our graph with two communities identified and nodes
    colored according to which community they belong to</st>'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51526">图 10.19：我们识别出两个社区并根据每个节点所属的社区对节点进行着色</st>
- en: <st c="51643">From</st> <st c="51649">Figure 10</st><st c="51658">.19, we can
    see that the community detection algorithm has uncovered what we would regard
    as the obvious communities that are present in the starting graph in</st> <st
    c="51817">Figure 10</st><st c="51826">.18\.</st> <st c="51831">While it is a simple
    example, it does illustrate how easy it is to run community detection algorithms.</st>
    <st c="51934">It also illustrates the usefulness of those algorithms.</st> <st
    c="51990">It is usually relatively easy to construct a pairwise measure or weight
    of how closely related two nodes or objects are.</st> <st c="52111">This means
    we can easily construct a weighted adjacency matrix for a set of interacting objects,
    such as a retailer’s products.</st> <st c="52239">Community detection</st> <st
    c="52258">algorithms then allow us to easily uncover the natural groupings of
    those objects, with minimal</st> <st c="52355">extra coding.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51643">从</st> <st c="51649">图 10</st><st c="51658">.19 中，我们可以看到社区检测算法已经揭示了我们认为在初始图中明显存在的社区，这些社区在</st>
    <st c="51817">图 10</st><st c="51826">.18 中可见。</st> <st c="51831">虽然这是一个简单的例子，但它确实展示了运行社区检测算法的简便性。</st>
    <st c="51934">它还展示了这些算法的实用性。</st> <st c="51990">通常，相对容易构建一对一度量或权重来表示两个节点或对象之间的相似度。</st>
    <st c="52111">这意味着我们可以轻松为一组交互对象（例如零售商的产品）构建一个加权邻接矩阵。</st> <st c="52239">社区检测</st>
    <st c="52258">算法可以帮助我们轻松发现这些对象的自然分组，几乎无需</st> <st c="52355">额外的编码。</st>
- en: <st c="52368">Having run a simple code example to illustrate how community detection
    is performed, we’ll wrap up this section and</st> <st c="52485">this chapter.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52368">通过运行一个简单的代码示例来说明如何执行社区检测后，我们将结束本节内容并</st> <st c="52485">本章内容。</st>
- en: <st c="52498">What we’ve learned</st>
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="52498">我们学到了什么</st>
- en: <st c="52517">In this section, we learned</st> <st c="52546">the following:</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52517">在本节中，我们学到了</st> <st c="52546">以下内容：</st>
- en: <st c="52560">A community represents a collection of similar or</st> <st c="52611">related
    nodes</st>
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="52560">一个社区代表一组相似或</st> <st c="52611">相关的节点</st>
- en: <st c="52624">Community detection attempts to break a graph into distinct sub-graphs</st>
    <st c="52696">or communities</st>
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="52624">社区检测尝试将一个图划分成不同的子图</st> <st c="52696">或社区</st>
- en: <st c="52710">How community detection algorithms work by optimizing a metric
    that measures the quality of the assignment of nodes</st> <st c="52827">to communities</st>
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="52710">社区检测算法如何通过优化一个度量来工作，该度量衡量节点分配到社区的质量</st> <st c="52827">到社区</st>
- en: <st c="52841">Modularity maximization community</st> <st c="52876">detection
    algorithms</st>
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="52841">模块化最大化社区</st> <st c="52876">检测算法</st>
- en: <st c="52896">Other approaches to community detection, such as model-based approaches
    and</st> <st c="52973">betweenness-centrality-based approaches</st>
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="52896">其他社区检测方法，如基于模型的方法和</st> <st c="52973">基于介数中心性的的方法</st>
- en: <st c="53012">Summary</st>
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="53012">总结</st>
- en: <st c="53020">This chapter has been about a specific type of data – network
    data.</st> <st c="53089">We have learned that networks are used to represent relationships.</st>
    <st c="53156">Since relationships are prevalent in many real-world scenarios,
    it is essential that, as a data scientist, you are familiar with the main concepts
    and terminology relating to networks.</st> <st c="53341">Of these, the most important
    concepts we have covered in this chapter are</st> <st c="53415">as follows:</st>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53020">本章讲述的是一种特定类型的数据——网络数据。</st> <st c="53089">我们了解到，网络用于表示关系。</st>
    <st c="53156">由于关系在许多现实世界的场景中都很常见，作为数据科学家，熟悉与网络相关的主要概念和术语是至关重要的。</st> <st c="53341">其中，本章涵盖的最重要的概念如下：</st>
    <st c="53415">如下：</st>
- en: <st c="53426">What a network represents and that a network is</st> <st c="53475">a
    graph</st>
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53426">一个网络表示什么，以及一个网络是</st> <st c="53475">一个图</st>
- en: <st c="53482">A graph,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3366.png)<st
    c="53492"><st c="53493">, consists of a set of nodes (vertices),</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="53534"><st c="53535">, and a set of edges,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3360.png)<st
    c="53557"><st c="53558">, between</st> <st c="53568">those nodes</st></st></st></st>
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53482">一个图，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi></mml:math>](img/3366.png)<st
    c="53492"><st c="53493">，由一组节点（顶点）组成，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi></mml:math>](img/3355.png)<st
    c="53534"><st c="53535">，以及一组边，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>E</mml:mi></mml:math>](img/3360.png)<st
    c="53557"><st c="53558">，这些边连接</st> <st c="53568">这些节点</st></st></st></st>
- en: <st c="53579">The edges of a graph can be undirected or directed and can have
    weights associated</st> <st c="53663">with them</st>
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53579">图的边可以是无向的或有向的，并且可以与权重相关联</st> <st c="53663">它们</st>
- en: <st c="53672">The structure of a graph is encoded in the</st> <st c="53716">adjacency
    matrix</st>
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53672">图的结构通过</st> <st c="53716">邻接矩阵</st> 编码
- en: <st c="53732">The in-degree and out-degree of a node can be calculated from
    the adjacency matrix and tell us the number of edges coming into a node and leaving
    a</st> <st c="53881">node, respectively</st>
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53732">节点的入度和出度可以从邻接矩阵中计算得出，它们分别告诉我们有多少条边进入一个节点和离开一个节点</st> <st c="53881">节点</st>
- en: <st c="53899">The sum of the node in-degree and out-degree values gives us the
    total degree value for a node and is a node centrality measure, which is a measure
    of the importance of</st> <st c="54069">the node</st>
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="53899">节点的入度和出度值之和给出了节点的总度数值，这是一个节点中心性度量，衡量的是节点的重要性</st> <st c="54069">节点</st>
- en: <st c="54077">A graph can be fully connected if every node is connected to every</st>
    <st c="54145">other node</st>
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54077">如果每个节点都与其他所有节点连接，则图是完全连接的</st> <st c="54145">其他节点</st>
- en: <st c="54155">If a directed graph doesn’t have any cycles, then it is called
    a DAG, and DAGs are used to represent dependency structures</st> <st c="54279">between
    entities</st>
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54155">如果一个有向图没有任何环，那么它被称为DAG，DAG通常用于表示实体之间的依赖关系</st> <st c="54279">实体之间</st>
- en: <st c="54295">Many graphs exhibit the small-world phenomenon, whereby the typical
    distance between two nodes on the graph is small and a weakly growing function
    of the</st> <st c="54450">network size</st>
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54295">许多图展示了小世界现象，其中图上两个节点之间的典型距离较小，并且是网络规模的弱增长函数</st> <st c="54450">网络规模</st>
- en: <st c="54462">Scale-free graphs have node degree distributions that</st> <st
    c="54517">are power-laws</st>
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无标度图的节点度分布呈现幂律分布。
- en: <st c="54531">Community detection algorithms attempt to break down a graph into
    its natural sub-graphs of closely connected subsets</st> <st c="54650">of nodes</st>
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区检测算法试图将图分解为其自然的子图，即紧密连接的节点子集。
- en: <st c="54658">Key community detection algorithms such as</st> <st c="54702">modularity
    maximization</st>
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键的社区检测算法如模块化最大化。
- en: <st c="54725">The next chapter, like this chapter on network data, is about
    another specific type of data and the systems that generate it.</st> <st c="54852">We’ll
    be looking at dynamical systems, the data they generate, and the underlying equations
    that control the evolution of those</st> <st c="54980">dynamical systems.</st>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，像这一章关于网络数据的内容一样，讨论的是另一种特定类型的数据及其生成的系统。我们将研究动态系统、它们生成的数据以及控制这些动态系统演化的基本方程。
- en: <st c="54998">Exercises</st>
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: <st c="55008">The following is a series of exercises.</st> <st c="55049">Answers
    to all these exercises can be found in the</st> `<st c="55100">Answers_to_Exercises_Chap10.ipynb</st>`
    <st c="55133">Jupyter Notebook in this book’s</st> <st c="55166">GitHub repository:</st>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一系列练习。所有这些练习的答案可以在本书的`Answers_to_Exercises_Chap10.ipynb` Jupyter Notebook中找到，存储在本书的GitHub仓库中：
- en: <st c="55184">The Zachary Karate Club is a well-known network in the field of
    network science, so much so that a copy of the network is stored in the</st> `<st
    c="55321">NetworkX</st>` <st c="55329">package and can be accessed via the</st>
    `<st c="55366">karate_club_graph()</st>` <st c="55385">function.</st> <st c="55396">Use
    this function to create the karate club graph and then use the</st> `<st c="55463">community.greedy_modularity_communities</st>`
    <st c="55502">function to identify the communities within the graph.</st> <st
    c="55558">You can assume that there are two communities, so you should look at
    how to use the</st> `<st c="55642">cutoff</st>` <st c="55648">and</st> `<st c="55653">best_n</st>`
    <st c="55659">parameters of the</st> `<st c="55678">community.greedy_modularity_communities</st>`
    <st c="55718">function to ensure that only two communities are found.</st> <st
    c="55774">Which nodes do you think are at the center of each of the two</st> <st
    c="55836">communities found?</st>
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Zachary空手道俱乐部是网络科学领域著名的网络，甚至在`NetworkX`包中存有该网络的副本，可以通过`karate_club_graph()`函数访问。使用此函数创建空手道俱乐部图，然后使用`community.greedy_modularity_communities`函数识别图中的社区。你可以假设有两个社区，因此你应该查看如何使用`community.greedy_modularity_communities`函数的`cutoff`和`best_n`参数来确保只找到两个社区。你认为在找到的两个社区中，哪些节点位于每个社区的中心？
- en: <st c="55854">Use the</st> `<st c="55863">scale_free_graph</st>` <st c="55879">function
    of the</st> `<st c="55896">NetworkX</st>` <st c="55904">package to create a scale-free
    graph with 10,000 nodes.</st> <st c="55961">Having generated the scale-free graph,
    use the</st> `<st c="56008">degree</st>` <st c="56014">function of the</st> `<st
    c="56031">NetworkX</st>` <st c="56039">package to calculate the degree value of
    each node.</st> <st c="56092">Sort the node degree values in descending order
    and plot them against their rank on a log-log plot.</st> <st c="56192">You should
    see a linear relationship on the log-log plot.</st> <st c="56250">You’ll need
    to pay attention to the object type returned by the</st> `<st c="56314">degree</st>`
    <st c="56320">function of the</st> `<st c="56337">NetworkX</st>` <st c="56345">package.</st>
    <st c="56355">You may find it useful to convert it into a dictionary by wrapping
    it inside a call</st> <st c="56439">to</st> `<st c="56442">dict()</st>`<st c="56448">.</st>
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="56449">Look at the</st> `<st c="56462">NetworkX</st>` <st c="56470">package
    documentation for the</st> `<st c="56501">watts_strogatz_graph</st>` <st c="56521">function.</st>
    <st c="56532">This uses the Strogatz and Watts algorithm to generate simulated
    small-world networks.</st> <st c="56619">Use this function to generate a series
    of graphs with the number of nodes</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/3491.png)<st
    c="56693"><st c="56694">=10,20,40,80,160,320,640,1280\.</st> <st c="56725">For
    each graph, set k=5 and p=0.3\.</st> <st c="56760">These are the initial degree
    values and edge re-wiring probability of the Strogatz and Watts algorithm, respectively.</st>
    <st c="56878">For each graph, use the</st> `<st c="56902">shortest_path_length</st>`
    <st c="56922">function of the</st> `<st c="56939">NetworkX</st>` <st c="56947">package
    to compute the shortest path distance between each of the</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/3492.png)
    <st c="57014"><st c="57015">pair of nodes in the graph.</st> <st c="57044">For
    each value of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)<st
    c="57062"><st c="57063">, calculate the average shortest path distance,</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)<st
    c="57111"><st c="57112">, as defined by Eq.</st> <st c="57132">8, and plot</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)
    <st c="57144"><st c="57145">against</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3496.png)<st
    c="57154"><st c="57155">. You should see a linear relationship between</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3482.png)
    <st c="57202"><st c="57203">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3498.png)<st
    c="57208"><st c="57209">. See if you can spot a short-cut where you don’t have
    to compute all</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/3499.png)
    <st c="57279"><st c="57280">shortest path distances to</st> <st c="57308">calculate</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)<st
    c="57318"><st c="57319">.</st></st></st></st></st></st></st></st></st></st></st>
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56449">查看</st> `<st c="56462">NetworkX</st>` <st c="56470">包的文档，了解</st>
    `<st c="56501">watts_strogatz_graph</st>` <st c="56521">函数。</st> <st c="56532">该函数使用
    Strogatz 和 Watts 算法生成模拟的小世界网络。</st> <st c="56619">使用此函数生成一系列具有不同节点数的图</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/3491.png)<st
    c="56693"><st c="56694">=10,20,40,80,160,320,640,1280\。</st> <st c="56725">对于每个图，设置
    k=5 和 p=0.3\。</st> <st c="56760">这些是 Strogatz 和 Watts 算法的初始度值和边重连概率。</st> <st
    c="56878">对于每个图，使用</st> `<st c="56902">shortest_path_length</st>` <st c="56922">函数，计算</st>
    `<st c="56939">NetworkX</st>` <st c="56947">包中每一对</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/3492.png)
    <st c="57014"><st c="57015">节点对之间的最短路径距离。</st> <st c="57044">对于每个</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>N</mml:mi></mml:math>](img/115.png)<st
    c="57062"><st c="57063">值，计算平均最短路径距离</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)<st
    c="57111"><st c="57112">，如公式 8 所定义，并绘制</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)
    <st c="57144"><st c="57145">与</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3496.png)<st
    c="57154"><st c="57155">的关系图。</st> <st c="57202">你应该能看到</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3482.png)
    <st c="57203">与</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math>](img/3498.png)<st
    c="57208"><st c="57209">之间存在线性关系。</st> <st c="57218">看看你是否能找到一个捷径，避免计算所有的</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>](img/3499.png)
    <st c="57279"><st c="57280">最短路径距离来计算</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mover
    accent="false"><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:math>](img/3457.png)<st
    c="57318"><st c="57319">。</st></st></st></st></st></st></st></st></st></st>
- en: <st c="57320">Notes and further reading</st>
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="57320">注释与进一步阅读</st>
- en: <st c="57346">For details on the Girvan and Newman algorithm, see the research
    paper by M.</st> <st c="57424">Girvan and M.E.J.</st> <st c="57442">Newman</st>*<st
    c="57448">, Community structure in social and biological networks</st>*<st c="57503">,
    Proceedings of the National Academy of Sciences USA, 99:7821-7826, 2002\.</st>
    <st c="57578">A preprint version of the paper can be found in the arXiv archive</st>
    <st c="57644">at</st> [<st c="57647">https://arxiv.org/pdf/cond-mat/0112110.pdf</st>](https://arxiv.org/pdf/cond-mat/0112110.pdf)<st
    c="57689">.</st>
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57346">关于Girvan和Newman算法的详细信息，请参阅M. </st> <st c="57424">Girvan 和 M.E.J.
    </st> <st c="57442">Newman</st>*<st c="57448">，《社交与生物网络中的社区结构》</st>*<st c="57503">，《美国国家科学院学报》，99：7821-7826，2002年。</st>
    <st c="57578">该论文的预印本版本可以在arXiv存档中找到</st> <st c="57644">，网址为</st> [<st c="57647">https://arxiv.org/pdf/cond-mat/0112110.pdf</st>](https://arxiv.org/pdf/cond-mat/0112110.pdf)<st
    c="57689">。</st>
- en: '<st c="0">Part 3: Selected Advanced Concepts</st>'
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第3部分：精选高级概念</st>
- en: <st c="35">In this part, we will introduce a selection of advanced math concepts.</st>
    <st c="107">As with Part 2, each concept is a standalone topic.</st> <st c="159">But,
    in contrast to Part 2, we’re now introducing topics at the cutting edge of data
    science and data science research.</st> <st c="279">There is still a high probability
    you will encounter these concepts in your data science work, especially the longer
    you work in data science.</st> <st c="422">Because of the advanced nature of the
    topics, each chapter is only designed to give you a basic grounding in that topic.</st>
    <st c="543">But by the end of Part 3, you will understand the core ideas of each
    of these topics and be able to use that understanding to guide your</st> <st c="680">own
    studies.</st>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35">在这一部分，我们将介绍一系列高级数学概念。</st> <st c="107">与第2部分一样，每个概念都是一个独立的话题。</st>
    <st c="159">但与第2部分不同的是，我们现在引入的是数据科学和数据科学研究前沿的话题。</st> <st c="279">你很可能会在数据科学工作中遇到这些概念，尤其是当你在数据科学领域工作得越久。</st>
    <st c="422">由于这些话题的高级性质，每一章仅旨在为你提供该主题的基本基础。</st> <st c="543">但到第3部分结束时，你将理解每个主题的核心思想，并能够利用这些理解指导你的</st>
    <st c="680">学习。</st>
- en: <st c="692">This section contains the</st> <st c="719">following chapters:</st>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="692">本节包含以下章节：</st>
- en: '[*<st c="738">Chapter 11</st>*](B19496_11.xhtml#_idTextAnchor555)<st c="749">,</st>
    *<st c="751">Dynamical Systems</st>*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="738">第11章</st>*](B19496_11.xhtml#_idTextAnchor555)<st c="749">，</st>
    *<st c="751">动力系统</st>*'
- en: '[*<st c="768">Chapter 12</st>*](B19496_12.xhtml#_idTextAnchor612)<st c="779">,</st>
    *<st c="781">Kernel Methods</st>*'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="768">第12章</st>*](B19496_12.xhtml#_idTextAnchor612)<st c="779">，</st>
    *<st c="781">核方法</st>*'
- en: '[*<st c="795">Chapter 13</st>*](B19496_13.xhtml#_idTextAnchor646)*<st c="806">,
    Information Theory</st>*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="795">第13章</st>*](B19496_13.xhtml#_idTextAnchor646)*<st c="806">，信息理论</st>*'
- en: '[*<st c="826">Chapter 14</st>*](B19496_14.xhtml#_idTextAnchor702)*<st c="837">,
    Bayesian Non-Parametric Methods</st>*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="826">第14章</st>*](B19496_14.xhtml#_idTextAnchor702)*<st c="837">，贝叶斯非参数方法</st>*'
- en: '[*<st c="870">Chapter 15</st>*](B19496_15.xhtml#_idTextAnchor739)*<st c="881">,
    Random Matrices</st>*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="870">第15章</st>*](B19496_15.xhtml#_idTextAnchor739)*<st c="881">，随机矩阵</st>*'
